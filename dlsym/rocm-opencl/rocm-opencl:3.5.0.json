{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.5.0-2xa4n7bcfhfymr3oqvr5blkv4v6m3wav/spack-src/amdocl/cl_gl_amd.hpp": "/* Copyright (c) 2010-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#ifndef CL_GL_AMD_HPP_\n#define CL_GL_AMD_HPP_\n\n#ifdef _WIN32\n#include <windows.h>\n#else //!_WIN32\n#include <dlfcn.h>\n#endif //!_WIN32\n\n#include <GL/gl.h>\n#include <GL/glext.h>\n#include \"CL/cl_gl.h\"\n#ifndef _WIN32\n#include <GL/glx.h>\n#endif //!_WIN32\n\n#include <EGL/egl.h>\n#include <EGL/eglext.h>\n#include <EGL/eglplatform.h>\n\n#include \"platform/context.hpp\"\n#include \"platform/command.hpp\"\n\nnamespace amd\n{\n\n//! Class GLObject keeps all the info about the GL object\n//! from which the CL object is created\nclass GLObject : public InteropObject\n{\nprotected:\n    cl_gl_object_type   clGLType_;  //!< CL GL object type\n    GLenum  glTarget_;\n    GLuint  gluiName_;\n    GLint   gliMipLevel_;\n    GLenum  glInternalFormat_;\n    GLint   gliWidth_;\n    GLint   gliHeight_;\n    GLint   gliDepth_;\n    GLenum  glCubemapFace_;\n    GLsizei glNumSamples_;\n\npublic:\n//! GLObject constructor initializes member variables\n    GLObject(\n        GLenum  glTarget,\n        GLuint  gluiName,\n        GLint   gliMipLevel,\n        GLenum  glInternalFormat,\n        GLint   gliWidth,\n        GLint   gliHeight,\n        GLint   gliDepth,\n        cl_gl_object_type   clGLType,\n        GLenum  glCubemapFace,\n        GLsizei glNumSamples\n    ): // Initialization of member variables\n            clGLType_(clGLType),\n            glTarget_(glTarget),\n            gluiName_(gluiName),\n            gliMipLevel_(gliMipLevel),\n            glInternalFormat_(glInternalFormat),\n            gliWidth_(gliWidth),\n            gliHeight_(gliHeight),\n            gliDepth_(gliDepth),\n            glCubemapFace_(glCubemapFace),\n            glNumSamples_(glNumSamples)\n    {\n    }\n\n    virtual ~GLObject() {}\n    virtual GLObject* asGLObject() {return this;}\n\n//! GLObject query functions to get GL info from member variables\n    GLenum  getGLTarget() const {return glTarget_;}\n    GLuint  getGLName() const {return gluiName_;}\n    GLint   getGLMipLevel() const {return gliMipLevel_;}\n    GLenum  getGLInternalFormat() const {return glInternalFormat_;}\n    GLint   getGLSize() const {return gliWidth_;}\n    GLint   getGLWidth() const {return gliWidth_;}\n    GLint   getGLHeight() const {return gliHeight_;}\n    GLint   getGLDepth() const {return gliDepth_;}\n    cl_gl_object_type getCLGLObjectType() const { return clGLType_; }\n    GLenum  getCubemapFace() const {return glCubemapFace_;}\n    GLsizei getNumSamples() const { return glNumSamples_;}\n};\n\n\n//! Class BufferGL is drived from classes Buffer and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass BufferGL : public Buffer, public GLObject\n{\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\npublic:\n//! BufferGL constructor just calls constructors of base classes\n//! to pass down the parameters\n    BufferGL(\n        Context&        amdContext,\n        cl_mem_flags    clFlags,\n        size_t          uiSizeInBytes,\n        GLenum          glTarget,\n        GLuint          gluiName)\n        : // Call base classes constructors\n            Buffer(\n                amdContext,\n                clFlags,\n                uiSizeInBytes\n            ),\n            GLObject(\n                glTarget,\n                gluiName,\n                0,                  // Mipmap level default\n                GL_ARRAY_BUFFER,    // Just init to some value\n                (GLint) uiSizeInBytes,\n                1,\n                1,\n                CL_GL_OBJECT_BUFFER,\n                0,\n                0\n            )\n    {\n        setInteropObj(this);\n    }\n    virtual ~BufferGL() {}\n\n    virtual BufferGL* asBufferGL() { return this; }\n};\n\n\n//! Class ImageGL is derived from classes Image and GLObject\n//! where the former keeps all data for CL object and\n//! the latter keeps all data for GL object\nclass ImageGL : public Image, public GLObject\n{\npublic:\n    //! ImageGL constructor just calls constructors of base classes\n    //! to pass down the parameters\n    ImageGL(\n        Context&            amdContext,\n        cl_mem_object_type  clType,\n        cl_mem_flags        clFlags,\n        const Format&       format,\n        size_t              width,\n        size_t              height,\n        size_t              depth,\n        GLenum              glTarget,\n        GLuint              gluiName,\n        GLint               gliMipLevel,\n        GLenum              glInternalFormat,\n        cl_gl_object_type   clGLType,\n        GLsizei             numSamples,\n        GLenum              glCubemapFace = 0)\n        : Image(amdContext, clType, clFlags, format, width, height, depth,\n            Format(format).getElementSize() * width,    \n            Format(format).getElementSize() * width * depth)\n        , GLObject(glTarget, gluiName, gliMipLevel, glInternalFormat,\n            static_cast<GLint>(width), static_cast<GLint>(height),\n            static_cast<GLint>(depth), clGLType, glCubemapFace,numSamples)\n    {\n        setInteropObj(this);\n    }\n\n    virtual ~ImageGL() {}\n\nprotected:\n    //! Initializes the device memory array which is nested\n    // after'BufferGL' object in memory layout.\n    virtual void initDeviceMemory();\n};\n\n#ifdef _WIN32\n#define APICALL WINAPI\n#define GETPROCADDRESS      GetProcAddress\n#define API_GETPROCADDR     \"wglGetProcAddress\"\n#define FCN_STR_TYPE        LPCSTR\n    typedef PROC (WINAPI* PFN_xxxGetProcAddress) (LPCSTR fcnName);\n    typedef HGLRC (APICALL* PFN_wglCreateContext) (HDC hdc);\n    typedef HGLRC (APICALL* PFN_wglGetCurrentContext) (void);\n    typedef HDC   (APICALL* PFN_wglGetCurrentDC) (void);\n    typedef BOOL  (APICALL* PFN_wglDeleteContext) (HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglMakeCurrent) (HDC hdc, HGLRC hglrc);\n    typedef BOOL  (APICALL* PFN_wglShareLists) (HGLRC hglrc1, HGLRC hglrc2);\n#else //!_WIN32\n#define APICALL // __stdcall   //??? todo odintsov\n#define API_GETPROCADDR     \"glXGetProcAddress\"\n#define GETPROCADDRESS      dlsym\n#define FCN_STR_TYPE        const GLubyte*\n#define WINAPI\n#define PROC void*\n    typedef void* (*PFN_xxxGetProcAddress) (const GLubyte* procName);\n    // X11 typedef\n    typedef Display* (*PFNXOpenDisplay)(_Xconst char* display_name );\n    typedef int (*PFNXCloseDisplay)(Display* display );\n\n    //glx typedefs\n    typedef GLXDrawable (*PFNglXGetCurrentDrawable)();\n    typedef Display* (*PFNglXGetCurrentDisplay)();\n    typedef GLXContext (*PFNglXGetCurrentContext)( void );\n    typedef XVisualInfo* (*PFNglXChooseVisual)(Display *dpy, int screen, int *attribList);\n    typedef GLXContext(*PFNglXCreateContext)(Display* dpy,XVisualInfo* vis,GLXContext shareList,Bool direct);\n    typedef void(*PFNglXDestroyContext)(Display* dpy, GLXContext ctx);\n    typedef Bool(*PFNglXMakeCurrent)( Display* dpy, GLXDrawable drawable, GLXContext ctx);\n    typedef void* HMODULE;\n#endif //!_WIN32\n\n#define GLPREFIX(rtype, fcn, dclargs) \\\n    typedef rtype (APICALL* PFN_##fcn) dclargs;\n\n// Declare prototypes for GL functions\n#include \"gl_functions.hpp\"\n\nclass GLFunctions\n{\npublic:\n    //! Locks any access to the virtual GPUs\n    class SetIntEnv : public amd::StackObject {\n    public:\n        //! Default constructor\n        SetIntEnv(GLFunctions* env);\n\n        //! Destructor\n        ~SetIntEnv();\n\n        //! Checks if the environment setup was successful\n        bool isValid() const { return isValid_; }\n\n    private:\n        GLFunctions*    env_;       //!< GL environment\n        bool            isValid_;   //!< If TRUE, then it's a valid setup\n    };\n\nprivate:\n    HMODULE libHandle_;\n    int missed_;    // Indicates how many GL functions not init'ed, if any\n\n    amd::Monitor lock_;\n\n    EGLDisplay eglDisplay_;\n    EGLContext eglOriginalContext_;\n    EGLContext eglInternalContext_;\n    EGLContext eglTempContext_;\n    bool isEGL_;\n\n#ifdef _WIN32\n    HGLRC       hOrigGLRC_;\n    HDC         hDC_;\n    HGLRC       hIntGLRC_;  // handle for internal GLRC to access shared context\n    HDC         tempDC_;\n    HGLRC       tempGLRC_;\n\n    PFN_wglCreateContext     wglCreateContext_;\n    PFN_wglGetCurrentContext wglGetCurrentContext_;\n    PFN_wglGetCurrentDC      wglGetCurrentDC_;\n    PFN_wglDeleteContext     wglDeleteContext_;\n    PFN_wglMakeCurrent       wglMakeCurrent_;\n    PFN_wglShareLists        wglShareLists_;\n#else\npublic:\n    Display*    Dpy_;\n    GLXDrawable Drawable_;\n    GLXContext  origCtx_;\n    Display*    intDpy_;\n    Window      intDrawable_;\n    GLXContext  intCtx_;\n    Display*    tempDpy_;\n    GLXDrawable tempDrawable_;\n    GLXContext  tempCtx_;\n\n    //pointers to X11 functions\n    PFNXOpenDisplay XOpenDisplay_;\n    PFNXCloseDisplay XCloseDisplay_;\n\n    //pointers to GLX functions\n    PFNglXGetCurrentDrawable glXGetCurrentDrawable_;\n    PFNglXGetCurrentDisplay glXGetCurrentDisplay_;\n    PFNglXGetCurrentContext glXGetCurrentContext_;\n    PFNglXChooseVisual glXChooseVisual_;\n    PFNglXCreateContext glXCreateContext_;\n    PFNglXDestroyContext glXDestroyContext_;\n    PFNglXMakeCurrent glXMakeCurrent_;\n#endif\npublic:\n\n    GLFunctions(HMODULE h, bool isEGL);\n    ~GLFunctions();\n\n    // Query CL-GL context association\n    bool isAssociated() const\n    {\n        if (isEGL_ && eglDisplay_ && eglOriginalContext_) return true;\n#ifdef _WIN32\n        if(hDC_ && hOrigGLRC_) return true;\n#else //!_WIN32\n        if(Dpy_ && origCtx_) return true;\n#endif //!_WIN32\n        return false;\n    }\n    bool isEGL() const\n    {\n        return isEGL_;\n    }\n    // Accessor methods\n#ifdef _WIN32\n    HGLRC getOrigGLRC() const {return hOrigGLRC_;}\n    HDC getDC() const {return hDC_;}\n    HGLRC getIntGLRC() const {return hIntGLRC_;}\n#else //!_WIN32\n    Display* getDpy() const {return Dpy_;}\n    GLXDrawable getDrawable() const {return Drawable_;}\n    GLXContext getOrigCtx() const {return origCtx_;}\n\n    Display* getIntDpy() const {return intDpy_;}\n    GLXDrawable getIntDrawable() const {return intDrawable_;}\n    GLXContext getIntCtx() const {return intCtx_;}\n\n    EGLDisplay getEglDpy() const { return eglDisplay_; }\n    EGLContext getEglOrigCtx() const { return eglOriginalContext_; }\n#endif //!_WIN32\n\n    // Initialize GL dynamic library and function pointers\n    bool init(intptr_t hdc, intptr_t hglrc);\n\n    // Return true if successful, false - if error occurred\n    bool setIntEnv();\n    bool restoreEnv();\n\n    amd::Monitor& getLock() { return lock_; }\n\n    PFN_xxxGetProcAddress GetProcAddress_;\n\n#define GLPREFIX(rtype, fcn, dclargs)   \\\n    PFN_##fcn fcn##_;\n// Declare pointers to GL functions\n#include \"gl_functions.hpp\"\n};\n\n//! Functions for executing the GL related stuff\ncl_mem clCreateFromGLBufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint bufobj, cl_int* errcode_ret);\ncl_mem clCreateFromGLTextureAMD(Context& amdContext, cl_mem_flags flags,\n    GLenum target, GLint miplevel, GLuint texture, int* errcode_ret);\ncl_mem clCreateFromGLRenderbufferAMD(Context& amdContext, cl_mem_flags flags,\n    GLuint renderbuffer, int* errcode_ret);\n\nbool\ngetCLFormatFromGL(\n    const Context& amdContext,\n    GLint gliInternalFormat,\n    cl_image_format* pclImageFormat,\n    int* piBytesPerPixel,\n    cl_mem_flags flags\n);\n\n} //namespace amd\n\n#endif //CL_GL_AMD_HPP_\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.5.0-2xa4n7bcfhfymr3oqvr5blkv4v6m3wav/spack-src/amdocl/cl_icd.cpp": "/* Copyright (c) 2008-present Advanced Micro Devices, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE. */\n\n#include \"cl_common.hpp\"\n#include \"vdi_common.hpp\"\n#ifdef _WIN32\n#include <d3d10_1.h>\n#include \"cl_d3d9_amd.hpp\"\n#include \"cl_d3d10_amd.hpp\"\n#include \"cl_d3d11_amd.hpp\"\n#endif  //_WIN32\n\n#include <icd/loader/icd_dispatch.h>\n\n#include <mutex>\n\namd::PlatformIDS amd::PlatformID::Platform =  //{ NULL };\n    {amd::ICDDispatchedObject::icdVendorDispatch_};\n\nstatic cl_int CL_API_CALL icdGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name,\n                                             size_t param_value_size, void* param_value,\n                                             size_t* param_value_size_ret) {\n  return clGetPlatformInfo(NULL, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceIDs(cl_platform_id platform, cl_device_type device_type,\n                                          cl_uint num_entries, cl_device_id* devices,\n                                          cl_uint* num_devices) {\n  return clGetDeviceIDs(NULL, device_type, num_entries, devices, num_devices);\n}\n\nstatic cl_int CL_API_CALL icdGetDeviceInfo(cl_device_id device, cl_device_info param_name,\n                                           size_t param_value_size, void* param_value,\n                                           size_t* param_value_size_ret) {\n  if (param_name == CL_DEVICE_PLATFORM) {\n    // Return the ICD platform instead of the default NULL platform.\n    cl_platform_id platform = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n    return amd::clGetInfo(platform, param_value_size, param_value, param_value_size_ret);\n  }\n\n  return clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);\n}\n\ncl_icd_dispatch amd::ICDDispatchedObject::icdVendorDispatch_[] = {\n    {NULL /* should not get called */, icdGetPlatformInfo, icdGetDeviceIDs, icdGetDeviceInfo,\n     clCreateContext, clCreateContextFromType, clRetainContext, clReleaseContext, clGetContextInfo,\n     clCreateCommandQueue, clRetainCommandQueue, clReleaseCommandQueue, clGetCommandQueueInfo,\n     clSetCommandQueueProperty, clCreateBuffer, clCreateImage2D, clCreateImage3D, clRetainMemObject,\n     clReleaseMemObject, clGetSupportedImageFormats, clGetMemObjectInfo, clGetImageInfo,\n     clCreateSampler, clRetainSampler, clReleaseSampler, clGetSamplerInfo,\n     clCreateProgramWithSource, clCreateProgramWithBinary, clRetainProgram, clReleaseProgram,\n     clBuildProgram, clUnloadCompiler, clGetProgramInfo, clGetProgramBuildInfo, clCreateKernel,\n     clCreateKernelsInProgram, clRetainKernel, clReleaseKernel, clSetKernelArg, clGetKernelInfo,\n     clGetKernelWorkGroupInfo, clWaitForEvents, clGetEventInfo, clRetainEvent, clReleaseEvent,\n     clGetEventProfilingInfo, clFlush, clFinish, clEnqueueReadBuffer, clEnqueueWriteBuffer,\n     clEnqueueCopyBuffer, clEnqueueReadImage, clEnqueueWriteImage, clEnqueueCopyImage,\n     clEnqueueCopyImageToBuffer, clEnqueueCopyBufferToImage, clEnqueueMapBuffer, clEnqueueMapImage,\n     clEnqueueUnmapMemObject, clEnqueueNDRangeKernel, clEnqueueTask, clEnqueueNativeKernel,\n     clEnqueueMarker, clEnqueueWaitForEvents, clEnqueueBarrier, clGetExtensionFunctionAddress,\n     clCreateFromGLBuffer, clCreateFromGLTexture2D, clCreateFromGLTexture3D,\n     clCreateFromGLRenderbuffer, clGetGLObjectInfo, clGetGLTextureInfo, clEnqueueAcquireGLObjects,\n     clEnqueueReleaseGLObjects, clGetGLContextInfoKHR,\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D10KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D10Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D10ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D10ObjectsKHR, NULL), clSetEventCallback, clCreateSubBuffer,\n     clSetMemObjectDestructorCallback, clCreateUserEvent, clSetUserEventStatus,\n     clEnqueueReadBufferRect, clEnqueueWriteBufferRect, clEnqueueCopyBufferRect,\n     NULL, NULL, NULL, clCreateEventFromGLsyncKHR,\n\n     /* OpenCL 1.2*/\n     clCreateSubDevices, clRetainDevice, clReleaseDevice, clCreateImage,\n     clCreateProgramWithBuiltInKernels, clCompileProgram, clLinkProgram, clUnloadPlatformCompiler,\n     clGetKernelArgInfo, clEnqueueFillBuffer, clEnqueueFillImage, clEnqueueMigrateMemObjects,\n     clEnqueueMarkerWithWaitList, clEnqueueBarrierWithWaitList,\n     clGetExtensionFunctionAddressForPlatform, clCreateFromGLTexture,\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromD3D11KHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11BufferKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture2DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromD3D11Texture3DKHR, NULL),\n     WINDOWS_SWITCH(clCreateFromDX9MediaSurfaceKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueAcquireD3D11ObjectsKHR, NULL),\n     WINDOWS_SWITCH(clEnqueueReleaseD3D11ObjectsKHR, NULL),\n\n     WINDOWS_SWITCH(clGetDeviceIDsFromDX9MediaAdapterKHR,\n                    NULL),  // KHRpfn_clGetDeviceIDsFromDX9MediaAdapterKHR\n                            // clGetDeviceIDsFromDX9MediaAdapterKHR;\n     WINDOWS_SWITCH(\n         clEnqueueAcquireDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueAcquireDX9MediaSurfacesKHR clEnqueueAcquireDX9MediaSurfacesKHR;\n     WINDOWS_SWITCH(\n         clEnqueueReleaseDX9MediaSurfacesKHR,\n         NULL),  // KHRpfn_clEnqueueReleaseDX9MediaSurfacesKHR clEnqueueReleaseDX9MediaSurfacesKHR;\n\n     NULL,\n     NULL, NULL, NULL,\n\n     clCreateCommandQueueWithProperties, clCreatePipe, clGetPipeInfo, clSVMAlloc, clSVMFree,\n     clEnqueueSVMFree, clEnqueueSVMMemcpy, clEnqueueSVMMemFill, clEnqueueSVMMap, clEnqueueSVMUnmap,\n     clCreateSamplerWithProperties, clSetKernelArgSVMPointer, clSetKernelExecInfo,\n     clGetKernelSubGroupInfo,\n     clCloneKernel,\n     clCreateProgramWithIL,\n     clEnqueueSVMMigrateMem,\n     clGetDeviceAndHostTimer,\n     clGetHostTimer,\n     clGetKernelSubGroupInfo,\n     clSetDefaultDeviceCommandQueue,\n\n     clSetProgramReleaseCallback,\n     clSetProgramSpecializationConstant }};\n\n#if defined(ATI_OS_WIN)\n#include <Shlwapi.h>\n\n#pragma comment(lib, \"shlwapi.lib\")\n\nstatic bool ShouldLoadPlatform() {\n  // Get the OpenCL ICD registry values\n  HKEY platformsKey = NULL;\n  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Khronos\\\\OpenCL\\\\Vendors\", 0, KEY_READ,\n                    &platformsKey) != ERROR_SUCCESS)\n    return true;\n\n  std::vector<std::string> registryValues;\n  DWORD dwIndex = 0;\n  while (true) {\n    char cszLibraryName[1024] = {0};\n    DWORD dwLibraryNameSize = sizeof(cszLibraryName);\n    DWORD dwLibraryNameType = 0;\n    DWORD dwValue = 0;\n    DWORD dwValueSize = sizeof(dwValue);\n\n    if (RegEnumValueA(platformsKey, dwIndex++, cszLibraryName, &dwLibraryNameSize, NULL,\n                      &dwLibraryNameType, (LPBYTE)&dwValue, &dwValueSize) != ERROR_SUCCESS)\n      break;\n    // Require that the value be a DWORD and equal zero\n    if (dwLibraryNameType != REG_DWORD || dwValue != 0) {\n      continue;\n    }\n    registryValues.push_back(cszLibraryName);\n  }\n  RegCloseKey(platformsKey);\n\n  HMODULE hm = NULL;\n  if (!GetModuleHandleExA(\n          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n          (LPCSTR)&ShouldLoadPlatform, &hm))\n    return true;\n\n  char cszDllPath[1024] = {0};\n  if (!GetModuleFileNameA(hm, cszDllPath, sizeof(cszDllPath))) return true;\n\n  // If we are loaded from the DriverStore, then there should be a registry\n  // value matching our current module absolute path.\n  if (std::find(registryValues.begin(), registryValues.end(), cszDllPath) == registryValues.end())\n    return true;\n\n  LPSTR cszFileName;\n  char buffer[1024] = {0};\n  if (!GetFullPathNameA(cszDllPath, sizeof(buffer), buffer, &cszFileName)) return true;\n\n  // We found an absolute path in the registry that matched this DLL, now\n  // check if there is also an entry with the same filename.\n  if (std::find(registryValues.begin(), registryValues.end(), cszFileName) == registryValues.end())\n    return true;\n\n  // Lastly, check if there is a DLL with the same name in the System folder.\n  char cszSystemPath[1024] = {0};\n#if defined(ATI_BITS_32)\n  if (!GetSystemWow64DirectoryA(cszSystemPath, sizeof(cszSystemPath)))\n#endif  // defined(ATI_BITS_32)\n    if (!GetSystemDirectoryA(cszSystemPath, sizeof(cszSystemPath))) return true;\n\n  std::string systemDllPath;\n  systemDllPath.append(cszSystemPath).append(\"\\\\\").append(cszFileName);\n  if (!PathFileExistsA(systemDllPath.c_str())) {\n    return true;\n  }\n\n  // If we get here, then all 3 conditions are true:\n  // - An entry in the registry with an absolute path matches the current DLL\n  // - An entry in the registry with a relative path matches the current DLL\n  // - A DLL with the same name was found in the system directory\n  //\n  // We should not load this platform!\n\n  return false;\n}\n\n#else\n\n#include <dlfcn.h>\n\n// If there is only one platform, load it.\n// If there is more than one platform, only load platforms that have visible devices\n// If all platforms have no devices available, only load the PAL platform\nstatic bool ShouldLoadPlatform() {\n  bool shouldLoad = true;\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n  const int numDevices = amd::Device::numDevices(CL_DEVICE_TYPE_GPU, false);\n\n  void *otherPlatform = nullptr;\n  if (amd::IS_LEGACY) {\n    otherPlatform = dlopen(\"libamdocl64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Present platform exists\n      shouldLoad = numDevices > 0;\n    }\n  } else {\n    otherPlatform = dlopen(\"libamdocl-orca64.so\", RTLD_LAZY);\n    if (otherPlatform != nullptr) { // Legacy platform exists\n      // gcc4.8 doesn't support casting void* to a function pointer\n      // Work around this by creating a typedef untill we upgrade the compiler\n      typedef void*(*clGetFunctionAddress_t)(const char *);\n      typedef cl_int(*clIcdGetPlatformIDs_t)(cl_uint, cl_platform_id *, cl_uint *);\n\n      clGetFunctionAddress_t legacyGetFunctionAddress =\n        reinterpret_cast<clGetFunctionAddress_t>(dlsym(otherPlatform, \"clGetExtensionFunctionAddress\"));\n      clIcdGetPlatformIDs_t legacyGetPlatformIDs =\n        reinterpret_cast<clIcdGetPlatformIDs_t>(legacyGetFunctionAddress(\"clIcdGetPlatformIDsKHR\"));\n\n      cl_uint numLegacyPlatforms = 0;\n      legacyGetPlatformIDs(0, nullptr, &numLegacyPlatforms);\n\n      shouldLoad = (numDevices > 0) || (numLegacyPlatforms == 0);\n    }\n  }\n\n  if (otherPlatform != nullptr) {\n    dlclose(otherPlatform);\n  }\n\n  return shouldLoad;\n}\n\n#endif // defined(ATI_OS_WIN)\n\nCL_API_ENTRY cl_int CL_API_CALL clIcdGetPlatformIDsKHR(cl_uint num_entries,\n                                                       cl_platform_id* platforms,\n                                                       cl_uint* num_platforms) {\n  if (((num_entries > 0 || num_platforms == NULL) && platforms == NULL) ||\n      (num_entries == 0 && platforms != NULL)) {\n    return CL_INVALID_VALUE;\n  }\n\n  static bool shouldLoad = true;\n\n  static std::once_flag initOnce;\n  std::call_once(initOnce, [](){ shouldLoad = ShouldLoadPlatform(); });\n\n  if (!shouldLoad) {\n    *not_null(num_platforms) = 0;\n    return CL_SUCCESS;\n  }\n\n  if (!amd::Runtime::initialized()) {\n    amd::Runtime::init();\n  }\n\n  if (num_platforms != NULL && platforms == NULL) {\n    *num_platforms = 1;\n    return CL_SUCCESS;\n  }\n\n  assert(platforms != NULL && \"check the code above\");\n  *platforms = reinterpret_cast<cl_platform_id>(&amd::PlatformID::Platform);\n\n  *not_null(num_platforms) = 1;\n  return CL_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-opencl-3.5.0-2xa4n7bcfhfymr3oqvr5blkv4v6m3wav/spack-src/khronos/icd/loader/linux/icd_linux.c": "/*\n * Copyright (c) 2016-2019 The Khronos Group Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * OpenCL is a trademark of Apple Inc. used under license by Khronos.\n */\n\n#include \"icd.h\"\n#include \"icd_envvars.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pthread.h>\n\nstatic pthread_once_t initialized = PTHREAD_ONCE_INIT;\n\n/*\n * \n * Vendor enumeration functions\n *\n */\n\n// go through the list of vendors in the two configuration files\nvoid khrIcdOsVendorsEnumerate(void)\n{\n    DIR *dir = NULL;\n    struct dirent *dirEntry = NULL;\n    char* vendorPath = ICD_VENDOR_PATH;\n    char* envPath = NULL;\n\n    khrIcdVendorsEnumerateEnv();\n\n    envPath = khrIcd_secure_getenv(\"OCL_ICD_VENDORS\");\n    if (NULL != envPath)\n    {\n        vendorPath = envPath;\n    }\n\n    dir = opendir(vendorPath);\n    if (NULL == dir) \n    {\n        KHR_ICD_TRACE(\"Failed to open path %s, continuing\\n\", vendorPath);\n    }\n    else\n    {\n        // attempt to load all files in the directory\n        for (dirEntry = readdir(dir); dirEntry; dirEntry = readdir(dir) )\n        {\n            switch(dirEntry->d_type)\n            {\n            case DT_UNKNOWN:\n            case DT_REG:\n            case DT_LNK:\n                {\n                    const char* extension = \".icd\";\n                    FILE *fin = NULL;\n                    char* fileName = NULL;\n                    char* buffer = NULL;\n                    long bufferSize = 0;\n\n                    // make sure the file name ends in .icd\n                    if (strlen(extension) > strlen(dirEntry->d_name) )\n                    {\n                        break;\n                    }\n                    if (strcmp(dirEntry->d_name + strlen(dirEntry->d_name) - strlen(extension), extension) )\n                    {\n                        break;\n                    }\n\n                    // allocate space for the full path of the vendor library name\n                    fileName = malloc(strlen(dirEntry->d_name) + strlen(vendorPath) + 1);\n                    if (!fileName)\n                    {\n                        KHR_ICD_TRACE(\"Failed allocate space for ICD file path\\n\");\n                        break;\n                    }\n                    sprintf(fileName, \"%s%s\", vendorPath, dirEntry->d_name);\n\n                    // open the file and read its contents\n                    fin = fopen(fileName, \"r\");\n                    if (!fin)\n                    {\n                        free(fileName);\n                        break;\n                    }\n                    fseek(fin, 0, SEEK_END);\n                    bufferSize = ftell(fin);\n\n                    buffer = malloc(bufferSize+1);\n                    if (!buffer)\n                    {\n                        free(fileName);\n                        fclose(fin);\n                        break;\n                    }\n                    memset(buffer, 0, bufferSize+1);\n                    fseek(fin, 0, SEEK_SET);\n                    if (bufferSize != (long)fread(buffer, 1, bufferSize, fin) )\n                    {\n                        free(fileName);\n                        free(buffer);\n                        fclose(fin);\n                        break;\n                    }\n                    // ignore a newline at the end of the file\n                    if (buffer[bufferSize-1] == '\\n') buffer[bufferSize-1] = '\\0';\n\n                    // load the string read from the file\n                    khrIcdVendorAdd(buffer);\n\n                    free(fileName);\n                    free(buffer);\n                    fclose(fin);\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        closedir(dir);\n    }\n\n    if (NULL != envPath)\n    {\n        khrIcd_free_getenv(envPath);\n    }\n}\n\n// go through the list of vendors only once\nvoid khrIcdOsVendorsEnumerateOnce(void)\n{\n    pthread_once(&initialized, khrIcdOsVendorsEnumerate);\n}\n\n/*\n * \n * Dynamic library loading functions\n *\n */\n\n// dynamically load a library.  returns NULL on failure\nvoid *khrIcdOsLibraryLoad(const char *libraryName)\n{\n    return dlopen (libraryName, RTLD_NOW);\n}\n\n// get a function pointer from a loaded library.  returns NULL on failure.\nvoid *khrIcdOsLibraryGetFunctionAddress(void *library, const char *functionName)\n{\n    return dlsym(library, functionName);\n}\n\n// unload a library\nvoid khrIcdOsLibraryUnload(void *library)\n{\n    dlclose(library);\n}\n"
    },
    "skipped": [],
    "total_files": 194
}