{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-debug-agent-3.10.0-4b7ba5lsksnskkowbw62ikinfdijc56h/spack-src/src/debug_agent.cpp": "/* The University of Illinois/NCSA\n   Open Source License (NCSA)\n\n   Copyright (c) 2020, Advanced Micro Devices, Inc. All rights reserved.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to\n   deal with the Software without restriction, including without limitation\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\n   and/or sell copies of the Software, and to permit persons to whom the\n   Software is furnished to do so, subject to the following conditions:\n\n    - Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimers.\n    - Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimers in\n      the documentation and/or other materials provided with the distribution.\n    - Neither the names of Advanced Micro Devices, Inc,\n      nor the names of its contributors may be used to endorse or promote\n      products derived from this Software without specific prior written\n      permission.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n   THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   DEALINGS WITH THE SOFTWARE.  */\n\n#include \"code_object.h\"\n#include \"debug.h\"\n#include \"logging.h\"\n\n#include <amd-dbgapi.h>\n#include <hsa/hsa.h>\n#include <hsa/hsa_api_trace.h>\n#include <hsa/hsa_ext_amd.h>\n\n#include <dlfcn.h>\n#include <getopt.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <cstdint>\n#include <cstdlib>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <optional>\n#include <string>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define DBGAPI_CHECK(expr)                                                    \\\n  do                                                                          \\\n    {                                                                         \\\n      if (amd_dbgapi_status_t status = (expr);                                \\\n          status != AMD_DBGAPI_STATUS_SUCCESS)                                \\\n        agent_error (\"%s:%d: %s failed (rc=%d)\", __FILE__, __LINE__, #expr,   \\\n                     status);                                                 \\\n    }                                                                         \\\n  while (false)\n\nusing namespace amd::debug_agent;\nusing namespace std::string_literals;\n\nnamespace\n{\nstd::optional<std::string> g_code_objects_dir;\nbool g_all_wavefronts{ false };\n\nstatic amd_dbgapi_callbacks_t dbgapi_callbacks = {\n  /* allocate_memory.  */\n  .allocate_memory = malloc,\n\n  /* deallocate_memory.  */\n  .deallocate_memory = free,\n\n  /* get_os_pid.  */\n  .get_os_pid =\n      [] (amd_dbgapi_client_process_id_t client_process_id, pid_t *pid) {\n        *pid = getpid ();\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* enable_notify_shared_library callback.  */\n  .enable_notify_shared_library =\n      [] (amd_dbgapi_client_process_id_t client_process_id,\n          const char *library_name, amd_dbgapi_shared_library_id_t library_id,\n          amd_dbgapi_shared_library_state_t *library_state) {\n        /* If the debug agent is loaded, then the ROCR is already loaded.   */\n        *library_state = (library_name == \"libhsa-runtime64.so.1\"s)\n                             ? AMD_DBGAPI_SHARED_LIBRARY_STATE_LOADED\n                             : AMD_DBGAPI_SHARED_LIBRARY_STATE_UNLOADED;\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* disable_notify_shared_library callback.  */\n  .disable_notify_shared_library =\n      [] (amd_dbgapi_client_process_id_t client_process_id,\n          amd_dbgapi_shared_library_id_t library_id) {\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* get_symbol_address callback.  */\n  .get_symbol_address =\n      [] (amd_dbgapi_client_process_id_t client_process_id,\n          amd_dbgapi_shared_library_id_t library_id, const char *symbol_name,\n          amd_dbgapi_global_address_t *address) {\n        *address = reinterpret_cast<amd_dbgapi_global_address_t> (\n            dlsym (RTLD_DEFAULT, symbol_name));\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* set_breakpoint callback.  */\n  .insert_breakpoint =\n      [] (amd_dbgapi_client_process_id_t client_process_id,\n          amd_dbgapi_shared_library_id_t shared_library_id,\n          amd_dbgapi_global_address_t address,\n          amd_dbgapi_breakpoint_id_t breakpoint_id) {\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* remove_breakpoint callback.  */\n  .remove_breakpoint =\n      [] (amd_dbgapi_client_process_id_t client_process_id,\n          amd_dbgapi_breakpoint_id_t breakpoint_id) {\n        return AMD_DBGAPI_STATUS_SUCCESS;\n      },\n\n  /* log_message callback.  */\n  .log_message =\n      [] (amd_dbgapi_log_level_t level, const char *message) {\n        agent_out << \"rocm-dbgapi: \" << message << std::endl;\n      }\n};\n\nstd::string\nhex_string (const std::vector<uint8_t> &value)\n{\n  std::string value_string;\n  value_string.reserve (2 * value.size ());\n\n  for (size_t pos = value.size (); pos > 0; --pos)\n    {\n      static constexpr char hex_digits[] = \"0123456789abcdef\";\n      value_string.push_back (hex_digits[value[pos - 1] >> 4]);\n      value_string.push_back (hex_digits[value[pos - 1] & 0xF]);\n    }\n\n  return value_string;\n}\n\nstd::string\nregister_value_string (const std::string &register_type,\n                       const std::vector<uint8_t> &register_value)\n{\n  /* handle vector types..  */\n  if (size_t pos = register_type.find_last_of ('['); pos != std::string::npos)\n    {\n      const std::string element_type = register_type.substr (0, pos);\n      const size_t element_count = std::stoi (register_type.substr (pos + 1));\n      const size_t element_size = register_value.size () / element_count;\n\n      agent_assert ((register_value.size () % element_size) == 0);\n\n      std::stringstream ss;\n      for (size_t i = 0; i < element_count; ++i)\n        {\n          if (i != 0)\n            ss << \" \";\n          ss << \"[\" << i << \"] \";\n\n          std::vector<uint8_t> element_value (\n              &register_value[element_size * i],\n              &register_value[element_size * (i + 1)]);\n\n          ss << register_value_string (element_type, element_value);\n        }\n      return ss.str ();\n    }\n\n  return hex_string (register_value);\n}\n\nvoid\nprint_registers (amd_dbgapi_wave_id_t wave_id)\n{\n  amd_dbgapi_architecture_id_t architecture_id;\n  DBGAPI_CHECK (\n      amd_dbgapi_wave_get_info (wave_id, AMD_DBGAPI_WAVE_INFO_ARCHITECTURE,\n                                sizeof (architecture_id), &architecture_id));\n\n  size_t class_count;\n  amd_dbgapi_register_class_id_t *register_class_ids;\n  DBGAPI_CHECK (amd_dbgapi_architecture_register_class_list (\n      architecture_id, &class_count, &register_class_ids));\n\n  size_t register_count;\n  amd_dbgapi_register_id_t *register_ids;\n  DBGAPI_CHECK (\n      amd_dbgapi_wave_register_list (wave_id, &register_count, &register_ids));\n\n  for (size_t i = 0; i < class_count; ++i)\n    {\n      amd_dbgapi_register_class_id_t register_class_id = register_class_ids[i];\n\n      char *class_name_;\n      DBGAPI_CHECK (amd_dbgapi_architecture_register_class_get_info (\n          register_class_id, AMD_DBGAPI_REGISTER_CLASS_INFO_NAME,\n          sizeof (class_name_), &class_name_));\n      std::string class_name (class_name_);\n      free (class_name_);\n\n      if (class_name == \"general\" || class_name == \"all\")\n        continue;\n\n      agent_out << std::endl << class_name << \" registers:\";\n\n      size_t last_register_size = 0;\n      for (size_t j = 0, column = 0; j < register_count; ++j)\n        {\n          amd_dbgapi_register_id_t register_id = register_ids[j];\n\n          amd_dbgapi_register_class_state_t state;\n          DBGAPI_CHECK (amd_dbgapi_register_is_in_register_class (\n              register_class_id, register_id, &state));\n\n          if (state != AMD_DBGAPI_REGISTER_CLASS_STATE_MEMBER)\n            continue;\n\n          char *register_name_;\n          DBGAPI_CHECK (amd_dbgapi_register_get_info (\n              register_id, AMD_DBGAPI_REGISTER_INFO_NAME,\n              sizeof (register_name_), &register_name_));\n          std::string register_name (register_name_);\n          free (register_name_);\n\n          char *register_type_;\n          DBGAPI_CHECK (amd_dbgapi_register_get_info (\n              register_id, AMD_DBGAPI_REGISTER_INFO_TYPE,\n              sizeof (register_type_), &register_type_));\n          std::string register_type (register_type_);\n          free (register_type_);\n\n          size_t register_size;\n          DBGAPI_CHECK (amd_dbgapi_register_get_info (\n              register_id, AMD_DBGAPI_REGISTER_INFO_SIZE,\n              sizeof (register_size), &register_size));\n\n          std::vector<uint8_t> buffer (register_size);\n          DBGAPI_CHECK (amd_dbgapi_read_register (\n              wave_id, register_id, 0, register_size, buffer.data ()));\n\n          const size_t num_register_per_line = 16 / register_size;\n\n          if (register_size > sizeof (uint64_t) /* Registers larger than a\n                                                   uint64_t are printed each\n                                                   on a separate line.  */\n              || register_size != last_register_size\n              || (column++ % num_register_per_line) == 0)\n            {\n              agent_out << std::endl;\n              column = 1;\n            }\n\n          last_register_size = register_size;\n\n          agent_out << std::right << std::setfill (' ') << std::setw (16)\n                    << (register_name + \": \")\n                    << register_value_string (register_type, buffer);\n        }\n\n      agent_out << std::endl;\n    }\n\n  free (register_ids);\n  free (register_class_ids);\n}\n\nvoid\nprint_local_memory (amd_dbgapi_wave_id_t wave_id)\n{\n  amd_dbgapi_process_id_t process_id;\n  DBGAPI_CHECK (amd_dbgapi_wave_get_info (wave_id,\n                                          AMD_DBGAPI_WAVE_INFO_PROCESS,\n                                          sizeof (process_id), &process_id));\n\n  amd_dbgapi_architecture_id_t architecture_id;\n  DBGAPI_CHECK (\n      amd_dbgapi_wave_get_info (wave_id, AMD_DBGAPI_WAVE_INFO_ARCHITECTURE,\n                                sizeof (architecture_id), &architecture_id));\n\n  amd_dbgapi_address_space_id_t local_address_space_id;\n  DBGAPI_CHECK (amd_dbgapi_dwarf_address_space_to_address_space (\n      architecture_id, 0x3 /* DW_ASPACE_AMDGPU_local */,\n      &local_address_space_id));\n\n  std::vector<uint32_t> buffer (1024);\n  amd_dbgapi_segment_address_t base_address{ 0 };\n\n  while (true)\n    {\n      size_t requested_size = buffer.size () * sizeof (buffer[0]);\n      size_t size = requested_size;\n      if (amd_dbgapi_read_memory (process_id, wave_id, 0,\n                                  local_address_space_id, base_address, &size,\n                                  buffer.data ())\n          != AMD_DBGAPI_STATUS_SUCCESS)\n        break;\n\n      agent_assert ((size % sizeof (buffer[0])) == 0);\n      buffer.resize (size / sizeof (buffer[0]));\n\n      if (!base_address)\n        agent_out << std::endl << \"Local memory content:\";\n\n      for (size_t i = 0, column = 0; i < buffer.size (); ++i)\n        {\n          if ((column++ % 8) == 0)\n            {\n              agent_out << std::endl\n                        << \"    0x\" << std::setfill ('0') << std::setw (4)\n                        << (base_address + i * sizeof (buffer[0])) << \":\";\n              column = 1;\n            }\n\n          agent_out << \" \" << std::hex << std::setfill ('0') << std::setw (8)\n                    << buffer[i];\n        }\n\n      base_address += size;\n\n      if (size != requested_size)\n        break;\n    }\n\n  if (base_address)\n    agent_out << std::endl;\n}\n\nvoid\nstop_all_wavefronts (amd_dbgapi_process_id_t process_id)\n{\n  using wave_handle_type_t = decltype (amd_dbgapi_wave_id_t::handle);\n  std::unordered_set<wave_handle_type_t> already_stopped;\n  std::unordered_set<wave_handle_type_t> waiting_to_stop;\n\n  agent_log (log_level_t::info, \"stopping all wavefronts\");\n  for (size_t iter = 0;; ++iter)\n    {\n      agent_log (log_level_t::info, \"iteration %zu:\", iter);\n\n      while (true)\n        {\n          amd_dbgapi_event_id_t event_id;\n          amd_dbgapi_event_kind_t kind;\n\n          DBGAPI_CHECK (amd_dbgapi_process_next_pending_event (\n              process_id, &event_id, &kind));\n\n          if (event_id.handle == AMD_DBGAPI_EVENT_NONE.handle)\n            break;\n\n          if (kind == AMD_DBGAPI_EVENT_KIND_WAVE_STOP)\n            {\n              amd_dbgapi_wave_id_t wave_id;\n              DBGAPI_CHECK (amd_dbgapi_event_get_info (\n                  event_id, AMD_DBGAPI_EVENT_INFO_WAVE, sizeof (wave_id),\n                  &wave_id));\n\n              waiting_to_stop.erase (wave_id.handle);\n              already_stopped.emplace (wave_id.handle);\n\n              agent_log (log_level_t::info, \"wave_%ld is stopped\",\n                         wave_id.handle);\n            }\n        }\n\n      amd_dbgapi_wave_id_t *wave_ids;\n      size_t wave_count;\n      DBGAPI_CHECK (amd_dbgapi_process_wave_list (process_id, &wave_count,\n                                                  &wave_ids, nullptr));\n\n      /* Stop all waves that are still running.  */\n      for (size_t i = 0; i < wave_count; ++i)\n        {\n          amd_dbgapi_wave_id_t wave_id = wave_ids[i];\n\n          if (already_stopped.find (wave_id.handle) != already_stopped.end ())\n            continue;\n\n          /* Already requested to stop.  */\n          if (waiting_to_stop.find (wave_id.handle) != waiting_to_stop.end ())\n            {\n              agent_log (log_level_t::info, \"wave_%ld is still stopping\",\n                         wave_id.handle);\n              continue;\n            }\n\n          agent_log (log_level_t::info,\n                     \"wave_%ld is running, sending stop request\",\n                     wave_id.handle);\n\n          /* FIXME: The wave could be single-stepping, how are we going to\n             restore the state?  */\n          DBGAPI_CHECK (amd_dbgapi_wave_stop (wave_id));\n\n          waiting_to_stop.emplace (wave_id.handle);\n        }\n\n      free (wave_ids);\n\n      if (!waiting_to_stop.size ())\n        break;\n    }\n\n  agent_log (log_level_t::info, \"all wavefronts are stopped\");\n}\n\nvoid\nprint_wavefronts (bool all_wavefronts)\n{\n  /* This function is not thread-safe and not re-entrant.  */\n  static std::mutex lock;\n  if (!lock.try_lock ())\n    return;\n  /* Make sure the lock is released when this function returns.  */\n  std::scoped_lock sl (std::adopt_lock, lock);\n\n  DBGAPI_CHECK (amd_dbgapi_initialize (&dbgapi_callbacks));\n\n  amd_dbgapi_process_id_t process_id;\n  DBGAPI_CHECK (amd_dbgapi_process_attach (\n      reinterpret_cast<amd_dbgapi_client_process_id_t> (&process_id),\n      &process_id));\n\n  /* Check the runtime state.  */\n  while (true)\n    {\n      amd_dbgapi_event_id_t event_id;\n      amd_dbgapi_event_kind_t event_kind;\n\n      DBGAPI_CHECK (amd_dbgapi_process_next_pending_event (\n          process_id, &event_id, &event_kind));\n\n      if (event_kind == AMD_DBGAPI_EVENT_KIND_RUNTIME)\n        {\n          amd_dbgapi_runtime_state_t runtime_state;\n\n          DBGAPI_CHECK (amd_dbgapi_event_get_info (\n              event_id, AMD_DBGAPI_EVENT_INFO_RUNTIME_STATE,\n              sizeof (runtime_state), &runtime_state));\n\n          switch (runtime_state)\n            {\n            case AMD_DBGAPI_RUNTIME_STATE_LOADED_SUCCESS:\n              break;\n\n            case AMD_DBGAPI_RUNTIME_STATE_UNLOADED:\n              agent_error (\"invalid runtime state %d\", runtime_state);\n\n            case AMD_DBGAPI_RUNTIME_STATE_LOADED_ERROR_RESTRICTION:\n              agent_error (\"unable to enable GPU debugging due to a \"\n                           \"restriction error\");\n              break;\n            }\n        }\n\n      /* No more events.  */\n      if (event_kind == AMD_DBGAPI_EVENT_KIND_NONE)\n        break;\n    }\n\n  std::map<amd_dbgapi_global_address_t, code_object_t> code_object_map;\n\n  amd_dbgapi_code_object_id_t *code_objects_id;\n  size_t code_object_count;\n  DBGAPI_CHECK (amd_dbgapi_process_code_object_list (\n      process_id, &code_object_count, &code_objects_id, nullptr));\n\n  for (size_t i = 0; i < code_object_count; ++i)\n    {\n      code_object_t code_object (code_objects_id[i]);\n\n      code_object.open ();\n      if (!code_object.is_open ())\n        {\n          agent_warning (\"could not open code_object_%ld\",\n                         code_objects_id[i].handle);\n          continue;\n        }\n\n      if (g_code_objects_dir && !code_object.save (*g_code_objects_dir))\n        agent_warning (\"could not save code object to %s\",\n                       g_code_objects_dir->c_str ());\n\n      code_object_map.emplace (code_object.load_address (),\n                               std::move (code_object));\n    }\n  free (code_objects_id);\n\n  DBGAPI_CHECK (amd_dbgapi_process_set_progress (\n      process_id, AMD_DBGAPI_PROGRESS_NO_FORWARD));\n\n  DBGAPI_CHECK (amd_dbgapi_process_set_wave_creation (\n      process_id, AMD_DBGAPI_WAVE_CREATION_STOP));\n\n  if (all_wavefronts)\n    stop_all_wavefronts (process_id);\n\n  amd_dbgapi_wave_id_t *wave_ids;\n  size_t wave_count;\n  DBGAPI_CHECK (amd_dbgapi_process_wave_list (process_id, &wave_count,\n                                              &wave_ids, nullptr));\n\n  for (size_t i = 0; i < wave_count; ++i)\n    {\n      amd_dbgapi_wave_id_t wave_id = wave_ids[i];\n\n      amd_dbgapi_wave_state_t state;\n      DBGAPI_CHECK (amd_dbgapi_wave_get_info (\n          wave_id, AMD_DBGAPI_WAVE_INFO_STATE, sizeof (state), &state));\n\n      if (state != AMD_DBGAPI_WAVE_STATE_STOP)\n        continue;\n\n      std::underlying_type_t<amd_dbgapi_wave_stop_reason_t> stop_reason;\n      DBGAPI_CHECK (\n          amd_dbgapi_wave_get_info (wave_id, AMD_DBGAPI_WAVE_INFO_STOP_REASON,\n                                    sizeof (stop_reason), &stop_reason));\n\n      amd_dbgapi_global_address_t pc;\n      DBGAPI_CHECK (amd_dbgapi_wave_get_info (wave_id, AMD_DBGAPI_WAVE_INFO_PC,\n                                              sizeof (pc), &pc));\n\n      if (i)\n        agent_out << std::endl;\n\n      agent_out << \"--------------------------------------------------------\"\n                << std::endl;\n\n      agent_out << \"wave_\" << std::dec << wave_id.handle << \": pc=0x\"\n                << std::hex << pc;\n\n      std::string stop_reason_str;\n      auto stop_reason_bits{ stop_reason };\n      do\n        {\n          /* Consume one bit from the stop reason.  */\n          auto one_bit\n              = stop_reason_bits ^ (stop_reason_bits & (stop_reason_bits - 1));\n          stop_reason_bits ^= one_bit;\n\n          if (!stop_reason_str.empty ())\n            stop_reason_str += \"|\";\n\n          stop_reason_str += [] (amd_dbgapi_wave_stop_reason_t reason) {\n            switch (reason)\n              {\n              case AMD_DBGAPI_WAVE_STOP_REASON_NONE:\n                return \"NONE\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_BREAKPOINT:\n                return \"BREAKPOINT\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_WATCHPOINT:\n                return \"WATCHPOINT\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_SINGLE_STEP:\n                return \"SINGLE_STEP\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_QUEUE_ERROR:\n                return \"QUEUE_ERROR\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_INPUT_DENORMAL:\n                return \"FP_INPUT_DENORMAL\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_DIVIDE_BY_0:\n                return \"FP_DIVIDE_BY_0\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_OVERFLOW:\n                return \"FP_OVERFLOW\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_UNDERFLOW:\n                return \"FP_UNDERFLOW\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_INEXACT:\n                return \"FP_INEXACT\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FP_INVALID_OPERATION:\n                return \"FP_INVALID_OPERATION\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_INT_DIVIDE_BY_0:\n                return \"INT_DIVIDE_BY_0\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_DEBUG_TRAP:\n                return \"DEBUG_TRAP\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_ASSERT_TRAP:\n                return \"ASSERT_TRAP\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_TRAP:\n                return \"TRAP\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_MEMORY_VIOLATION:\n                return \"MEMORY_VIOLATION\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_ILLEGAL_INSTRUCTION:\n                return \"ILLEGAL_INSTRUCTION\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_ECC_ERROR:\n                return \"ECC_ERROR\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_FATAL_HALT:\n                return \"FATAL_HALT\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_XNACK_ERROR:\n                return \"XNACK_ERROR\";\n              case AMD_DBGAPI_WAVE_STOP_REASON_RESERVED:\n                return \"RESERVED\";\n              }\n            return \"\";\n          }(static_cast<amd_dbgapi_wave_stop_reason_t> (one_bit));\n        }\n      while (stop_reason_bits);\n\n      agent_out << \" (\";\n      if (stop_reason != AMD_DBGAPI_WAVE_STOP_REASON_NONE)\n        agent_out << \"stopped, reason: \" << stop_reason_str;\n      else\n        agent_out << \"running\";\n      agent_out << \")\" << std::endl;\n\n      print_registers (wave_id);\n      print_local_memory (wave_id);\n\n      /* Find the code object that contains this pc, and disassemble\n         instructions around `pc`  */\n      code_object_t *code_object_found{ nullptr };\n      if (auto it = code_object_map.upper_bound (pc);\n          it != code_object_map.begin ())\n        if (auto &&[load_address, code_object] = *std::prev (it);\n            (pc - load_address) <= code_object.mem_size ())\n          code_object_found = &code_object;\n\n      if (code_object_found)\n        {\n          amd_dbgapi_architecture_id_t architecture_id;\n          DBGAPI_CHECK (amd_dbgapi_wave_get_info (\n              wave_id, AMD_DBGAPI_WAVE_INFO_ARCHITECTURE,\n              sizeof (architecture_id), &architecture_id));\n\n          code_object_found->disassemble (architecture_id, pc);\n        }\n      else\n        {\n          /* TODO: Add disassembly even if we did not find a code object  */\n        }\n\n      if (stop_reason == AMD_DBGAPI_WAVE_STOP_REASON_NONE)\n        {\n          /* FIXME: What if the wave was single-stepping?  */\n          DBGAPI_CHECK (\n              amd_dbgapi_wave_resume (wave_id, AMD_DBGAPI_RESUME_MODE_NORMAL));\n        }\n    }\n\n  free (wave_ids);\n\n  DBGAPI_CHECK (amd_dbgapi_process_set_wave_creation (\n      process_id, AMD_DBGAPI_WAVE_CREATION_NORMAL));\n\n  DBGAPI_CHECK (amd_dbgapi_process_set_progress (process_id,\n                                                 AMD_DBGAPI_PROGRESS_NORMAL));\n\n  DBGAPI_CHECK (amd_dbgapi_process_detach (process_id));\n  DBGAPI_CHECK (amd_dbgapi_finalize ());\n}\n\nhsa_status_t\nhandle_system_event (const hsa_amd_event_t *event, void *data)\n{\n  if (event->event_type != HSA_AMD_GPU_MEMORY_FAULT_EVENT)\n    return HSA_STATUS_SUCCESS;\n\n  agent_out << \"System event (HSA_AMD_GPU_MEMORY_FAULT_EVENT: \";\n\n  uint32_t fault_reason = event->memory_fault.fault_reason_mask;\n  std::string fault_reason_str;\n  while (fault_reason)\n    {\n      /* Consume one bit from the fault reason.  */\n      uint32_t one_bit = fault_reason ^ (fault_reason & (fault_reason - 1));\n      fault_reason ^= one_bit;\n\n      if (!fault_reason_str.empty ())\n        fault_reason_str += \", \";\n\n      fault_reason_str += [] (hsa_amd_memory_fault_reason_t reason) {\n        switch (reason)\n          {\n          case HSA_AMD_MEMORY_FAULT_PAGE_NOT_PRESENT:\n            return \"page not present or supervisor privilege\";\n          case HSA_AMD_MEMORY_FAULT_READ_ONLY:\n            return \"write access to a read-only page\";\n          case HSA_AMD_MEMORY_FAULT_NX:\n            return \"execute access to a non-executable page\";\n          case HSA_AMD_MEMORY_FAULT_HOST_ONLY:\n            return \"access to host only page\";\n          case HSA_AMD_MEMORY_FAULT_DRAM_ECC:\n            return \"uncorrectable DRAM ECC failure\";\n          case HSA_AMD_MEMORY_FAULT_IMPRECISE:\n            return \"can't determine the exact fault address\";\n          case HSA_AMD_MEMORY_FAULT_SRAM_ECC:\n            return \"SRAM ECC failure\";\n          case HSA_AMD_MEMORY_FAULT_HANG:\n            return \"GPU reset following unspecified hang\";\n          }\n        return \"\";\n      }(static_cast<hsa_amd_memory_fault_reason_t> (one_bit));\n    }\n\n  agent_out << fault_reason_str << \")\" << std::endl;\n\n  agent_out << \"Faulting page: 0x\" << std::hex\n            << event->memory_fault.virtual_address << std::endl\n            << std::endl;\n\n  print_wavefronts (g_all_wavefronts);\n\n  /* FIXME: We really should be returning to the ROCr and let it print more\n     information then abort.  */\n  abort ();\n}\n\nstruct callback_and_data_t\n{\n  void (*callback) (hsa_status_t error_code, hsa_queue_t *source, void *data);\n  void *data;\n};\n\nstd::unordered_map<hsa_queue_t *, std::unique_ptr<callback_and_data_t>>\n    original_callbacks;\n\nvoid\nhandle_queue_error (hsa_status_t error_code, hsa_queue_t *queue, void *data)\n{\n  if (error_code == hsa_status_t (HSA_STATUS_ERROR_MEMORY_APERTURE_VIOLATION)\n      || error_code == hsa_status_t (HSA_STATUS_ERROR_ILLEGAL_INSTRUCTION)\n      || error_code == HSA_STATUS_ERROR_EXCEPTION)\n    {\n      const char *queue_error_str{ nullptr };\n\n      hsa_status_t status = hsa_status_string (error_code, &queue_error_str);\n      agent_assert (status == HSA_STATUS_SUCCESS);\n\n      agent_out << \"Queue error (\" << queue_error_str << \")\" << std::endl\n                << std::endl;\n\n      print_wavefronts (g_all_wavefronts);\n    }\n\n  /* Call the original callback.  */\n  if (auto *original_callback = reinterpret_cast<callback_and_data_t *> (data);\n      original_callback->callback)\n    (*original_callback->callback) (error_code, queue,\n                                    original_callback->data);\n}\n\ndecltype (CoreApiTable::hsa_queue_create_fn) original_hsa_queue_create_fn = {};\n\nhsa_status_t\nqueue_create (hsa_agent_t agent, uint32_t size, hsa_queue_type32_t type,\n              void (*callback) (hsa_status_t status, hsa_queue_t *source,\n                                void *data),\n              void *data, uint32_t private_segment_size,\n              uint32_t group_segment_size, hsa_queue_t **queue)\n{\n  auto original_callback = std::make_unique<callback_and_data_t> (\n      callback_and_data_t{ callback, data });\n\n  hsa_status_t status = (*original_hsa_queue_create_fn) (\n      agent, size, type, handle_queue_error, original_callback.get (),\n      private_segment_size, group_segment_size, queue);\n\n  if (status == HSA_STATUS_SUCCESS)\n    original_callbacks.emplace (*queue, std::move (original_callback));\n\n  return status;\n}\n\ndecltype (CoreApiTable::hsa_queue_destroy_fn) original_hsa_queue_destroy_fn\n    = {};\n\nhsa_status_t\nqueue_destroy (hsa_queue_t *queue)\n{\n  if (auto it = original_callbacks.find (queue);\n      it != original_callbacks.end ())\n    original_callbacks.erase (it);\n\n  return (*original_hsa_queue_destroy_fn) (queue);\n}\n\nvoid\nprint_usage ()\n{\n  std::cerr << \"ROCdebug-agent usage:\" << std::endl;\n  std::cerr << \"  -a, --all                   \"\n               \"Print all wavefronts.\"\n            << std::endl;\n  std::cerr << \"  -s, --save-code-objects[=DIR]   \"\n               \"Save all loaded code objects. If the directory\"\n            << std::endl\n            << \"                              \"\n               \"is not specified, the code objects are saved in\"\n            << std::endl\n            << \"                              \"\n               \"the current directory.\"\n            << std::endl;\n  std::cerr << \"  -o, --output=FILE           \"\n               \"Save the output in FILE. By default, the output\"\n            << std::endl\n            << \"                              \"\n               \"is redirected to stderr.\"\n            << std::endl;\n  std::cerr << \"  -d, --disable-linux-signals \"\n               \"Disable installing a SIGQUIT signal handler, so\"\n            << std::endl\n            << \"                              \"\n               \"that the default Linux handler may dump a core\"\n            << std::endl\n            << \"                              \"\n               \"file.\"\n            << std::endl;\n  std::cerr << \"  -l, --log-level={none|info|warning|error}\" << std::endl\n            << \"                              \"\n               \"Change the Debug Agent and Debugger API log\"\n            << std::endl\n            << \"                              \"\n               \"level. The default log level is 'none'.\"\n            << std ::endl;\n  std::cerr << \"  -h, --help                  \"\n               \"Display a usage message and abort the process.\"\n            << std::endl;\n\n  abort ();\n}\n\n} /* namespace.  */\n\nextern \"C\" bool __attribute__ ((visibility (\"default\")))\nOnLoad (void *table, uint64_t runtime_version, uint64_t failed_tool_count,\n        const char *const *failed_tool_names)\n{\n  bool disable_sigquit{ false };\n\n  set_log_level (log_level_t::warning);\n\n  std::istringstream args_stream;\n  if (const char *env = ::getenv (\"ROCM_DEBUG_AGENT_OPTIONS\"))\n    args_stream.str (env);\n\n  std::vector<char *> args = { strdup (\"rocm-debug-agent\") };\n  std::transform (\n      std::istream_iterator<std::string> (args_stream),\n      std::istream_iterator<std::string> (), std::back_inserter (args),\n      [] (const std::string &str) { return strdup (str.c_str ()); });\n\n  char *const *argv = const_cast<char *const *> (args.data ());\n  int argc = args.size ();\n\n  static struct option options[]\n      = { { \"all\", no_argument, nullptr, 'a' },\n          { \"disable-linux-signals\", no_argument, nullptr, 'd' },\n          { \"log-level\", required_argument, nullptr, 'l' },\n          { \"output\", required_argument, nullptr, 'o' },\n          { \"save-code-objects\", optional_argument, nullptr, 's' },\n          { \"help\", no_argument, nullptr, 'h' },\n          { 0 } };\n\n  while (int c = getopt_long (argc, argv, \":as::o:dl:h\", options, nullptr))\n    {\n      if (c == -1)\n        break;\n\n      std::optional<std::string> argument;\n\n      if (!optarg && optind < argc && *argv[optind] != '-')\n        optarg = argv[optind++];\n\n      if (optarg)\n        argument.emplace (optarg);\n\n      switch (c)\n        {\n        case 'a': /* -a or --all  */\n          g_all_wavefronts = true;\n          break;\n\n        case 'd': /* -d or --disable-linux-signals  */\n          disable_sigquit = true;\n          break;\n\n        case 'l': /* -l or --log-level  */\n          if (!argument)\n            print_usage ();\n\n          if (argument == \"none\")\n            set_log_level (log_level_t::none);\n          else if (argument == \"info\")\n            set_log_level (log_level_t::info);\n          else if (argument == \"warning\")\n            set_log_level (log_level_t::warning);\n          else if (argument == \"error\")\n            set_log_level (log_level_t::error);\n          else\n            print_usage ();\n          break;\n\n        case 's': /* -s or --save-code-objects  */\n          if (argument)\n            {\n              struct stat path_stat;\n              if (stat (argument->c_str (), &path_stat) == -1\n                  || !S_ISDIR (path_stat.st_mode))\n                {\n                  std::cerr\n                      << \"error: Cannot access code object save directory `\"\n                      << *argument << \"'\" << std::endl;\n                  print_usage ();\n                }\n\n              g_code_objects_dir = *argument;\n            }\n          else\n            {\n              g_code_objects_dir = \".\";\n            }\n          break;\n\n        case 'o': /* -o or --output  */\n          if (!argument)\n            print_usage ();\n\n          agent_out.open (*argument);\n          if (!agent_out.is_open ())\n            {\n              std::cerr << \"could not open `\" << *argument << \"'\" << std::endl;\n              abort ();\n            }\n          break;\n\n        case '?': /* Unrecognized option  */\n        case 'h': /* -h or --help */\n        default:\n          print_usage ();\n        }\n    }\n  std::for_each (args.begin (), args.end (), [] (char *str) { free (str); });\n\n  if (!agent_out.is_open ())\n    {\n      agent_out.copyfmt (std::cerr);\n      agent_out.clear (std::cerr.rdstate ());\n      agent_out.basic_ios<char>::rdbuf (std::cerr.rdbuf ());\n    }\n\n  if (!disable_sigquit)\n    {\n      struct sigaction sig_action;\n\n      memset (&sig_action, '\\0', sizeof (sig_action));\n      sigemptyset (&sig_action.sa_mask);\n\n      sig_action.sa_sigaction = [] (int signal, siginfo_t *, void *) {\n        agent_out << std::endl;\n        print_wavefronts (true);\n      };\n\n      /* Install a SIGQUIT (Ctrl-\\) handler.  */\n      sig_action.sa_flags = SA_RESTART;\n      sigaction (SIGQUIT, &sig_action, nullptr);\n    }\n\n  /* Intercept the queue_create & queue_destroy functions.  */\n  CoreApiTable *core_table = reinterpret_cast<HsaApiTable *> (table)->core_;\n\n  original_hsa_queue_create_fn = core_table->hsa_queue_create_fn;\n  core_table->hsa_queue_create_fn = &queue_create;\n\n  original_hsa_queue_destroy_fn = core_table->hsa_queue_destroy_fn;\n  core_table->hsa_queue_destroy_fn = &queue_destroy;\n\n  /* Install a system handler to report memory faults.  */\n  return hsa_amd_register_system_event_handler (handle_system_event, table)\n         == HSA_STATUS_SUCCESS;\n}\n\nextern \"C\" void __attribute__ ((visibility (\"default\"))) OnUnload () {}\n"
    },
    "skipped": [],
    "total_files": 20
}