{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/src/xbt/mmalloc/mm_legacy.c": "/* Copyright (c) 2010-2015. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n/* Redefine the classical malloc/free/realloc functions so that they fit well in the mmalloc framework */\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n#include \"src/mc/mc_base.h\"\n#include \"mmprivate.h\"\n#include \"src/xbt_modinter.h\"\n#include \"src/internal_config.h\"\n#include <math.h>\n#include \"src/mc/mc_protocol.h\"\n\n/* ***** Whether to use `mmalloc` of the underlying malloc ***** */\n\nstatic int __malloc_use_mmalloc;\n\nint malloc_use_mmalloc(void)\n{\n  return __malloc_use_mmalloc;\n}\n\n/* ***** Current heap ***** */\n\n/* The mmalloc() package can use a single implicit malloc descriptor\n   for mmalloc/mrealloc/mfree operations which do not supply an explicit\n   descriptor.  This allows mmalloc() to provide\n   backwards compatibility with the non-mmap'd version. */\nxbt_mheap_t __mmalloc_default_mdp = NULL;\n\n/* The heap we are currently using. */\nstatic xbt_mheap_t __mmalloc_current_heap = NULL;\n\nxbt_mheap_t mmalloc_get_current_heap(void)\n{\n  return __mmalloc_current_heap;\n}\n\nxbt_mheap_t mmalloc_set_current_heap(xbt_mheap_t new_heap)\n{\n  xbt_mheap_t heap = __mmalloc_current_heap;\n  __mmalloc_current_heap = new_heap;\n  return heap;\n}\n\n/* Override the malloc-like functions if MC is activated at compile time */\n#if HAVE_MC\n\n/* ***** Temporary allocator\n *\n * This is used before we have found the real malloc implementation with dlsym.\n */\n\n#ifdef __FreeBSD__ /* FreeBSD require more memory, other might */\n# define BUFFER_SIZE 256\n#else /* Valid on: Linux */\n# define BUFFER_SIZE 32\n#endif\nstatic size_t fake_alloc_index;\nstatic uint64_t buffer[BUFFER_SIZE];\n\n/* Fake implementations, they are used to fool dlsym:\n * dlsym used calloc and falls back to some other mechanism\n * if this fails.\n */\nstatic void* mm_fake_malloc(size_t n)\n{\n  // How many uint64_t do w need?\n  size_t count = n / sizeof(uint64_t);\n  if (n % sizeof(uint64_t))\n    count++;\n  // Check that we have enough available memory:\n  if (fake_alloc_index + count >= BUFFER_SIZE)\n    exit(127);\n  // Allocate it:\n  uint64_t* res = buffer + fake_alloc_index;\n  fake_alloc_index += count;\n  return res;\n}\n\nstatic void* mm_fake_calloc(size_t nmemb, size_t size)\n{\n  // This is fresh .bss data, we don't need to clear it:\n  size_t n = nmemb * size;\n  return mm_fake_malloc(n);\n}\n\nstatic void* mm_fake_realloc(void *p, size_t s)\n{\n  return mm_fake_malloc(s);\n}\n\nstatic void mm_fake_free(void *p)\n{\n}\n\n/* Function signatures for the main malloc functions: */\ntypedef void* (*mm_malloc_t)(size_t size);\ntypedef void  (*mm_free_t)(void*);\ntypedef void* (*mm_calloc_t)(size_t nmemb, size_t size);\ntypedef void* (*mm_realloc_t)(void *ptr, size_t size);\n\n/* Function pointers to the real/next implementations: */\nstatic mm_malloc_t mm_real_malloc;\nstatic mm_free_t mm_real_free;\nstatic mm_calloc_t mm_real_calloc;\nstatic mm_realloc_t mm_real_realloc;\n\nstatic int mm_initializing;\nstatic int mm_initialized;\n\n/** Constructor functions used to initialize the malloc implementation\n */\nstatic void __attribute__((constructor(101))) mm_legacy_constructor()\n{\n  if (mm_initialized)\n    return;\n  mm_initializing = 1;\n  __malloc_use_mmalloc = getenv(MC_ENV_VARIABLE) ? 1 : 0;\n  if (__malloc_use_mmalloc) {\n    __mmalloc_current_heap = mmalloc_preinit();\n  } else {\n#if HAVE_DLFUNC\n    mm_real_realloc  = (void *(*)(void *, size_t))dlfunc(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = (void *(*)(size_t))dlfunc(RTLD_NEXT, \"malloc\");\n    mm_real_free     = (void (*)(void *))dlfunc(RTLD_NEXT, \"free\");\n    mm_real_calloc   = (void *(*)(size_t, size_t))dlfunc(RTLD_NEXT, \"calloc\");\n#else\n    mm_real_realloc  = dlsym(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = dlsym(RTLD_NEXT, \"malloc\");\n    mm_real_free     = dlsym(RTLD_NEXT, \"free\");\n    mm_real_calloc   = dlsym(RTLD_NEXT, \"calloc\");\n#endif\n  }\n  mm_initializing = 0;\n  mm_initialized = 1;\n}\n\n/* ***** malloc/free implementation\n *\n * They call either the underlying/native/RTLD_NEXT implementation (non MC mode)\n * or the mm implementation (MC mode).\n *\n * If we are initializing the malloc subsystem, we call the fake/dummy `malloc`\n * implementation. This is necessary because `dlsym` calls `malloc` and friends.\n */\n\n#define GET_HEAP() __mmalloc_current_heap\n\nvoid* malloc_no_memset(size_t n)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_malloc(n);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_malloc(n);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc_no_memset(mdp, n);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid *malloc(size_t n)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_malloc(n);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_malloc(n);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, n);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_calloc(nmemb, size);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_calloc(nmemb, size);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, nmemb*size);\n  UNLOCK(mdp);\n  // This was already done in the callee:\n  if(!(mdp->options & XBT_MHEAP_OPTION_MEMSET)) {\n    memset(ret, 0, nmemb * size);\n  }\n  return ret;\n}\n\nvoid *realloc(void *p, size_t s)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_realloc(p, s);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_realloc(p, s);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void* ret = mrealloc(mdp, p, s);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid free(void *p)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_free(p);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    mm_real_free(p);\n    return;\n  }\n\n  if (!p)\n    return;\n\n  xbt_mheap_t mdp = GET_HEAP();\n  LOCK(mdp);\n  mfree(mdp, p);\n  UNLOCK(mdp);\n}\n#endif /* HAVE_MC */\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/tools/cmake/test_prog/prog_gnu_dynlinker.c": "/* prog_gnu_dynlinker.c -- check that RTLD_NEXT is defined as in GNU linker */\n/* Copyright (c) 2012-2014. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#define _GNU_SOURCE 1\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic void * (*real_malloc) (size_t);\n\nint main(void) {\n   char *error;\n   dlerror(); // clear any previous error\n   real_malloc = (void * (*) (size_t)) dlsym(RTLD_NEXT, \"malloc\");\n   error = dlerror();\n   if (!error && real_malloc) {\n      char *A = real_malloc(20);\n      strcpy(A,\"epic success\");\n      free(A);\n      return 0; // SUCCESS\n   } else {\n      if (error)\n   printf(\"Error while checking for dlsym: %s\\n\",error);\n      else\n   printf(\"dlsym did not return any error, but failed to find malloc()\\n\");\n      return 1; // FAILED\n   }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/surf++.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/triva-time_interval.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/triva-graph_visualization.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/surf++.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/triva-graph_configuration.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/sc3-description.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/smpi_simgrid_alltoall_pair_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/output.goal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/smpi_simgrid_alltoall_ring_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/AS_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/SGicon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/SGicon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/SGicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/awstats_logo3.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/poster_thumbnail.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/simgrid_logo_2011_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/simgrid_logo_win.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.14.159-tezmubxat44tjxqeo2btcofdth6rbxnx/spack-src/doc/webcruft/simgrid_logo_win_2011.bmp"
    ],
    "total_files": 2234
}