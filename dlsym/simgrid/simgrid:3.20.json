{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/src/xbt/mmalloc/mm_legacy.c": "/* Copyright (c) 2010-2018. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n/* Redefine the classical malloc/free/realloc functions so that they fit well in the mmalloc framework */\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n#include \"mmprivate.h\"\n#include \"src/internal_config.h\"\n#include \"src/mc/mc_base.h\"\n#include \"src/mc/remote/mc_protocol.h\"\n#include \"src/xbt_modinter.h\"\n#include <math.h>\n\n/* ***** Whether to use `mmalloc` of the underlying malloc ***** */\n\nstatic int __malloc_use_mmalloc;\n\nint malloc_use_mmalloc(void)\n{\n  return __malloc_use_mmalloc;\n}\n\n/* ***** Current heap ***** */\n\n/* The mmalloc() package can use a single implicit malloc descriptor\n   for mmalloc/mrealloc/mfree operations which do not supply an explicit\n   descriptor.  This allows mmalloc() to provide\n   backwards compatibility with the non-mmap'd version. */\nxbt_mheap_t __mmalloc_default_mdp = NULL;\n\n/* The heap we are currently using. */\nstatic xbt_mheap_t __mmalloc_current_heap = NULL;\n\nxbt_mheap_t mmalloc_get_current_heap(void)\n{\n  return __mmalloc_current_heap;\n}\n\nxbt_mheap_t mmalloc_set_current_heap(xbt_mheap_t new_heap)\n{\n  xbt_mheap_t heap = __mmalloc_current_heap;\n  __mmalloc_current_heap = new_heap;\n  return heap;\n}\n\n/* Override the malloc-like functions if MC is activated at compile time */\n#if SIMGRID_HAVE_MC\n\n/* ***** Temporary allocator\n *\n * This is used before we have found the real malloc implementation with dlsym.\n */\n\n#ifdef __FreeBSD__ /* FreeBSD require more memory, other might */\n# define BUFFER_SIZE 256\n#else /* Valid on: Linux */\n# define BUFFER_SIZE 32\n#endif\nstatic size_t fake_alloc_index;\nstatic uint64_t buffer[BUFFER_SIZE];\n\n/* Fake implementations, they are used to fool dlsym:\n * dlsym used calloc and falls back to some other mechanism\n * if this fails.\n */\nstatic void* mm_fake_malloc(size_t n)\n{\n  // How many uint64_t do w need?\n  size_t count = n / sizeof(uint64_t);\n  if (n % sizeof(uint64_t))\n    count++;\n  // Check that we have enough available memory:\n  if (fake_alloc_index + count >= BUFFER_SIZE)\n    exit(127);\n  // Allocate it:\n  uint64_t* res = buffer + fake_alloc_index;\n  fake_alloc_index += count;\n  return res;\n}\n\nstatic void* mm_fake_calloc(size_t nmemb, size_t size)\n{\n  // This is fresh .bss data, we don't need to clear it:\n  size_t n = nmemb * size;\n  return mm_fake_malloc(n);\n}\n\nstatic void* mm_fake_realloc(XBT_ATTRIB_UNUSED void* p, size_t s)\n{\n  return mm_fake_malloc(s);\n}\n\nstatic void mm_fake_free(XBT_ATTRIB_UNUSED void* p)\n{\n  // Nothing to do\n}\n\n/* Function signatures for the main malloc functions: */\ntypedef void* (*mm_malloc_t)(size_t size);\ntypedef void  (*mm_free_t)(void*);\ntypedef void* (*mm_calloc_t)(size_t nmemb, size_t size);\ntypedef void* (*mm_realloc_t)(void *ptr, size_t size);\n\n/* Function pointers to the real/next implementations: */\nstatic mm_malloc_t mm_real_malloc;\nstatic mm_free_t mm_real_free;\nstatic mm_calloc_t mm_real_calloc;\nstatic mm_realloc_t mm_real_realloc;\n\nstatic int mm_initializing;\nstatic int mm_initialized;\n\n/** Constructor functions used to initialize the malloc implementation\n */\nXBT_ATTRIB_CONSTRUCTOR(101) static void mm_legacy_constructor()\n{\n  if (mm_initialized)\n    return;\n  mm_initializing = 1;\n  __malloc_use_mmalloc = getenv(MC_ENV_VARIABLE) ? 1 : 0;\n  if (__malloc_use_mmalloc) {\n    __mmalloc_current_heap = mmalloc_preinit();\n  } else {\n#if HAVE_DLFUNC\n    mm_real_realloc  = (void *(*)(void *, size_t))dlfunc(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = (void *(*)(size_t))dlfunc(RTLD_NEXT, \"malloc\");\n    mm_real_free     = (void (*)(void *))dlfunc(RTLD_NEXT, \"free\");\n    mm_real_calloc   = (void *(*)(size_t, size_t))dlfunc(RTLD_NEXT, \"calloc\");\n#else\n    mm_real_realloc  = dlsym(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = dlsym(RTLD_NEXT, \"malloc\");\n    mm_real_free     = dlsym(RTLD_NEXT, \"free\");\n    mm_real_calloc   = dlsym(RTLD_NEXT, \"calloc\");\n#endif\n  }\n  mm_initializing = 0;\n  mm_initialized = 1;\n}\n\n/* ***** malloc/free implementation\n *\n * They call either the underlying/native/RTLD_NEXT implementation (non MC mode)\n * or the mm implementation (MC mode).\n *\n * If we are initializing the malloc subsystem, we call the fake/dummy `malloc`\n * implementation. This is necessary because `dlsym` calls `malloc` and friends.\n */\n\n#define GET_HEAP() __mmalloc_current_heap\n\nvoid* malloc_no_memset(size_t n)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_malloc(n);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_malloc(n);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc_no_memset(mdp, n);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid *malloc(size_t n)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_malloc(n);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_malloc(n);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, n);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_calloc(nmemb, size);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_calloc(nmemb, size);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, nmemb*size);\n  UNLOCK(mdp);\n  // This was already done in the callee:\n  if(!(mdp->options & XBT_MHEAP_OPTION_MEMSET)) {\n    memset(ret, 0, nmemb * size);\n  }\n  return ret;\n}\n\nvoid *realloc(void *p, size_t s)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_realloc(p, s);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_realloc(p, s);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void* ret = mrealloc(mdp, p, s);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid free(void *p)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_free(p);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    mm_real_free(p);\n    return;\n  }\n\n  if (!p)\n    return;\n\n  xbt_mheap_t mdp = GET_HEAP();\n  LOCK(mdp);\n  mfree(mdp, p);\n  UNLOCK(mdp);\n}\n#endif /* SIMGRID_HAVE_MC */\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/src/smpi/internals/smpi_global.cpp": "/* Copyright (c) 2007-2018. The SimGrid Team. All rights reserved.          */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#include \"smpi_host.hpp\"\n#include \"mc/mc.h\"\n#include \"simgrid/s4u/Engine.hpp\"\n#include \"smpi_coll.hpp\"\n#include \"smpi_process.hpp\"\n#include \"src/msg/msg_private.hpp\"\n#include \"src/simix/smx_private.hpp\"\n#include \"xbt/config.hpp\"\n\n#include <cfloat> /* DBL_MAX */\n#include <dlfcn.h>\n#include <fcntl.h>\n#if not defined(__APPLE__)\n#include <link.h>\n#endif\n#include <fstream>\n\n#if HAVE_SENDFILE\n#include <sys/sendfile.h>\n#endif\n\nXBT_LOG_NEW_DEFAULT_SUBCATEGORY(smpi_kernel, smpi, \"Logging specific to SMPI (kernel)\");\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string.hpp> /* trim_right / trim_left */\n\n#ifndef RTLD_DEEPBIND\n/* RTLD_DEEPBIND is a bad idea of GNU ld that obviously does not exist on other platforms\n * See https://www.akkadia.org/drepper/dsohowto.pdf\n * and https://lists.freebsd.org/pipermail/freebsd-current/2016-March/060284.html\n*/\n#define RTLD_DEEPBIND 0\n#endif\n\n#if HAVE_PAPI\n#include \"papi.h\"\nconst char* papi_default_config_name = \"default\";\n\nstruct papi_process_data {\n  papi_counter_t counter_data;\n  int event_set;\n};\n#endif\n\nusing simgrid::s4u::Actor;\nusing simgrid::s4u::ActorPtr;\nstd::unordered_map<std::string, double> location2speedup;\n\nstatic std::map</*process_id*/ ActorPtr, simgrid::smpi::Process*> process_data;\nint process_count = 0;\nstatic int smpi_exit_status = 0;\nint smpi_universe_size = 0;\nextern double smpi_total_benched_time;\nxbt_os_timer_t global_timer;\nstatic std::vector<std::string> privatize_libs_paths;\n/**\n * Setting MPI_COMM_WORLD to MPI_COMM_UNINITIALIZED (it's a variable)\n * is important because the implementation of MPI_Comm checks\n * \"this == MPI_COMM_UNINITIALIZED\"? If yes, it uses smpi_process()->comm_world()\n * instead of \"this\".\n * This is basically how we only have one global variable but all processes have\n * different communicators (the one their SMPI instance uses).\n *\n * See smpi_comm.cpp and the functions therein for details.\n */\nMPI_Comm MPI_COMM_WORLD = MPI_COMM_UNINITIALIZED;\nMPI_Errhandler *MPI_ERRORS_RETURN = nullptr;\nMPI_Errhandler *MPI_ERRORS_ARE_FATAL = nullptr;\nMPI_Errhandler *MPI_ERRHANDLER_NULL = nullptr;\n// No instance gets manually created; check also the smpirun.in script as\n// this default name is used there as well (when the <actor> tag is generated).\nstatic const std::string smpi_default_instance_name(\"smpirun\");\nstatic simgrid::config::Flag<double> smpi_wtime_sleep(\n  \"smpi/wtime\", \"Minimum time to inject inside a call to MPI_Wtime\", 0.0);\nstatic simgrid::config::Flag<double> smpi_init_sleep(\n  \"smpi/init\", \"Time to inject inside a call to MPI_Init\", 0.0);\n\nvoid (*smpi_comm_copy_data_callback) (smx_activity_t, void*, size_t) = &smpi_comm_copy_buffer_callback;\n\nint smpi_process_count()\n{\n  return process_count;\n}\n\nsimgrid::smpi::Process* smpi_process()\n{\n  ActorPtr me = Actor::self();\n  if (me == nullptr) // This happens sometimes (eg, when linking against NS3 because it pulls openMPI...)\n    return nullptr;\n  simgrid::msg::ActorExt* msgExt = static_cast<simgrid::msg::ActorExt*>(me->get_impl()->getUserData());\n  return static_cast<simgrid::smpi::Process*>(msgExt->data);\n}\n\nsimgrid::smpi::Process* smpi_process_remote(ActorPtr actor)\n{\n  return process_data.at(actor);\n}\n\nMPI_Comm smpi_process_comm_self(){\n  return smpi_process()->comm_self();\n}\n\nvoid smpi_process_init(int *argc, char ***argv){\n  simgrid::smpi::Process::init(argc, argv);\n}\n\nint smpi_process_index(){\n  return simgrid::s4u::this_actor::get_pid();\n}\n\nvoid * smpi_process_get_user_data(){\n  return smpi_process()->get_user_data();\n}\n\nvoid smpi_process_set_user_data(void *data){\n  return smpi_process()->set_user_data(data);\n}\n\n\nint smpi_global_size()\n{\n  char *value = getenv(\"SMPI_GLOBAL_SIZE\");\n  xbt_assert(value,\"Please set env var SMPI_GLOBAL_SIZE to the expected number of processes.\");\n\n  return xbt_str_parse_int(value, \"SMPI_GLOBAL_SIZE contains a non-numerical value: %s\");\n}\n\nvoid smpi_comm_set_copy_data_callback(void (*callback) (smx_activity_t, void*, size_t))\n{\n  smpi_comm_copy_data_callback = callback;\n}\n\nstatic void memcpy_private(void* dest, const void* src, std::vector<std::pair<size_t, size_t>>& private_blocks)\n{\n  for (auto const& block : private_blocks)\n    memcpy((uint8_t*)dest+block.first, (uint8_t*)src+block.first, block.second-block.first);\n}\n\nstatic void check_blocks(std::vector<std::pair<size_t, size_t>> &private_blocks, size_t buff_size) {\n  for (auto const& block : private_blocks)\n    xbt_assert(block.first <= block.second && block.second <= buff_size, \"Oops, bug in shared malloc.\");\n}\n\nvoid smpi_comm_copy_buffer_callback(smx_activity_t synchro, void *buff, size_t buff_size)\n{\n  simgrid::kernel::activity::CommImplPtr comm =\n      boost::dynamic_pointer_cast<simgrid::kernel::activity::CommImpl>(synchro);\n  int src_shared                        = 0;\n  int dst_shared                        = 0;\n  size_t src_offset                     = 0;\n  size_t dst_offset                     = 0;\n  std::vector<std::pair<size_t, size_t>> src_private_blocks;\n  std::vector<std::pair<size_t, size_t>> dst_private_blocks;\n  XBT_DEBUG(\"Copy the data over\");\n  if((src_shared=smpi_is_shared(buff, src_private_blocks, &src_offset))) {\n    XBT_DEBUG(\"Sender %p is shared. Let's ignore it.\", buff);\n    src_private_blocks = shift_and_frame_private_blocks(src_private_blocks, src_offset, buff_size);\n  }\n  else {\n    src_private_blocks.clear();\n    src_private_blocks.push_back(std::make_pair(0, buff_size));\n  }\n  if((dst_shared=smpi_is_shared((char*)comm->dst_buff, dst_private_blocks, &dst_offset))) {\n    XBT_DEBUG(\"Receiver %p is shared. Let's ignore it.\", (char*)comm->dst_buff);\n    dst_private_blocks = shift_and_frame_private_blocks(dst_private_blocks, dst_offset, buff_size);\n  }\n  else {\n    dst_private_blocks.clear();\n    dst_private_blocks.push_back(std::make_pair(0, buff_size));\n  }\n  check_blocks(src_private_blocks, buff_size);\n  check_blocks(dst_private_blocks, buff_size);\n  auto private_blocks = merge_private_blocks(src_private_blocks, dst_private_blocks);\n  check_blocks(private_blocks, buff_size);\n  void* tmpbuff=buff;\n  if ((smpi_privatize_global_variables == SmpiPrivStrategies::MMAP) &&\n      (static_cast<char*>(buff) >= smpi_data_exe_start) &&\n      (static_cast<char*>(buff) < smpi_data_exe_start + smpi_data_exe_size)) {\n    XBT_DEBUG(\"Privatization : We are copying from a zone inside global memory... Saving data to temp buffer !\");\n    smpi_switch_data_segment(comm->src_proc->iface());\n    tmpbuff = static_cast<void*>(xbt_malloc(buff_size));\n    memcpy_private(tmpbuff, buff, private_blocks);\n  }\n\n  if ((smpi_privatize_global_variables == SmpiPrivStrategies::MMAP) && ((char*)comm->dst_buff >= smpi_data_exe_start) &&\n      ((char*)comm->dst_buff < smpi_data_exe_start + smpi_data_exe_size)) {\n    XBT_DEBUG(\"Privatization : We are copying to a zone inside global memory - Switch data segment\");\n    smpi_switch_data_segment(comm->dst_proc->iface());\n  }\n  XBT_DEBUG(\"Copying %zu bytes from %p to %p\", buff_size, tmpbuff,comm->dst_buff);\n  memcpy_private(comm->dst_buff, tmpbuff, private_blocks);\n\n  if (comm->detached) {\n    // if this is a detached send, the source buffer was duplicated by SMPI\n    // sender to make the original buffer available to the application ASAP\n    xbt_free(buff);\n    //It seems that the request is used after the call there this should be free somewhere else but where???\n    //xbt_free(comm->comm.src_data);// inside SMPI the request is kept inside the user data and should be free\n    comm->src_buff = nullptr;\n  }\n  if (tmpbuff != buff)\n    xbt_free(tmpbuff);\n}\n\nvoid smpi_comm_null_copy_buffer_callback(smx_activity_t comm, void *buff, size_t buff_size)\n{\n  /* nothing done in this version */\n}\n\nstatic void smpi_check_options()\n{\n  //check correctness of MPI parameters\n\n  xbt_assert(simgrid::config::get_value<int>(\"smpi/async-small-thresh\") <=\n             simgrid::config::get_value<int>(\"smpi/send-is-detached-thresh\"));\n\n  if (simgrid::config::is_default(\"smpi/host-speed\")) {\n    XBT_INFO(\"You did not set the power of the host running the simulation.  \"\n             \"The timings will certainly not be accurate.  \"\n             \"Use the option \\\"--cfg=smpi/host-speed:<flops>\\\" to set its value.\"\n             \"Check http://simgrid.org/simgrid/latest/doc/options.html#options_smpi_bench for more information.\");\n  }\n\n  xbt_assert(simgrid::config::get_value<double>(\"smpi/cpu-threshold\") >= 0,\n             \"The 'smpi/cpu-threshold' option cannot have negative values [anymore]. If you want to discard \"\n             \"the simulation of any computation, please use 'smpi/simulate-computation:no' instead.\");\n}\n\nint smpi_enabled() {\n  return not process_data.empty();\n}\n\nvoid smpi_global_init()\n{\n  if (not MC_is_active()) {\n    global_timer = xbt_os_timer_new();\n    xbt_os_walltimer_start(global_timer);\n  }\n\n  std::string filename = simgrid::config::get_value<std::string>(\"smpi/comp-adjustment-file\");\n  if (not filename.empty()) {\n    std::ifstream fstream(filename);\n    if (not fstream.is_open()) {\n      xbt_die(\"Could not open file %s. Does it exist?\", filename.c_str());\n    }\n\n    std::string line;\n    typedef boost::tokenizer< boost::escaped_list_separator<char>> Tokenizer;\n    std::getline(fstream, line); // Skip the header line\n    while (std::getline(fstream, line)) {\n      Tokenizer tok(line);\n      Tokenizer::iterator it  = tok.begin();\n      Tokenizer::iterator end = std::next(tok.begin());\n\n      std::string location = *it;\n      boost::trim(location);\n      location2speedup.insert(std::pair<std::string, double>(location, std::stod(*end)));\n    }\n  }\n\n#if HAVE_PAPI\n  // This map holds for each computation unit (such as \"default\" or \"process1\" etc.)\n  // the configuration as given by the user (counter data as a pair of (counter_name, counter_counter))\n  // and the (computed) event_set.\n  std::map</* computation unit name */ std::string, papi_process_data> units2papi_setup;\n\n  if (not simgrid::config::get_value<std::string>(\"smpi/papi-events\").empty()) {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT)\n      XBT_ERROR(\"Could not initialize PAPI library; is it correctly installed and linked?\"\n                \" Expected version is %i\",\n                PAPI_VER_CURRENT);\n\n    typedef boost::tokenizer<boost::char_separator<char>> Tokenizer;\n    boost::char_separator<char> separator_units(\";\");\n    std::string str = simgrid::config::get_value<std::string>(\"smpi/papi-events\");\n    Tokenizer tokens(str, separator_units);\n\n    // Iterate over all the computational units. This could be processes, hosts, threads, ranks... You name it.\n    // I'm not exactly sure what we will support eventually, so I'll leave it at the general term \"units\".\n    for (auto const& unit_it : tokens) {\n      boost::char_separator<char> separator_events(\":\");\n      Tokenizer event_tokens(unit_it, separator_events);\n\n      int event_set = PAPI_NULL;\n      if (PAPI_create_eventset(&event_set) != PAPI_OK) {\n        // TODO: Should this let the whole simulation die?\n        XBT_CRITICAL(\"Could not create PAPI event set during init.\");\n      }\n\n      // NOTE: We cannot use a map here, as we must obey the order of the counters\n      // This is important for PAPI: We need to map the values of counters back\n      // to the event_names (so, when PAPI_read() has finished)!\n      papi_counter_t counters2values;\n\n      // Iterate over all counters that were specified for this specific\n      // unit.\n      // Note that we need to remove the name of the unit\n      // (that could also be the \"default\" value), which always comes first.\n      // Hence, we start at ++(events.begin())!\n      for (Tokenizer::iterator events_it = ++(event_tokens.begin()); events_it != event_tokens.end(); ++events_it) {\n\n        int event_code   = PAPI_NULL;\n        char* event_name = const_cast<char*>((*events_it).c_str());\n        if (PAPI_event_name_to_code(event_name, &event_code) == PAPI_OK) {\n          if (PAPI_add_event(event_set, event_code) != PAPI_OK) {\n            XBT_ERROR(\"Could not add PAPI event '%s'. Skipping.\", event_name);\n            continue;\n          } else {\n            XBT_DEBUG(\"Successfully added PAPI event '%s' to the event set.\", event_name);\n          }\n        } else {\n          XBT_CRITICAL(\"Could not find PAPI event '%s'. Skipping.\", event_name);\n          continue;\n        }\n\n        counters2values.push_back(\n            // We cannot just pass *events_it, as this is of type const basic_string\n            std::make_pair<std::string, long long>(std::string(*events_it), 0));\n      }\n\n      std::string unit_name    = *(event_tokens.begin());\n      papi_process_data config = {.counter_data = std::move(counters2values), .event_set = event_set};\n\n      units2papi_setup.insert(std::make_pair(unit_name, std::move(config)));\n    }\n  }\n#endif\n}\n\nvoid smpi_global_destroy()\n{\n  smpi_bench_destroy();\n  smpi_shared_destroy();\n  smpi_deployment_cleanup_instances();\n\n  if (simgrid::smpi::Colls::smpi_coll_cleanup_callback != nullptr)\n    simgrid::smpi::Colls::smpi_coll_cleanup_callback();\n\n  MPI_COMM_WORLD = MPI_COMM_NULL;\n\n  if (not MC_is_active()) {\n    xbt_os_timer_free(global_timer);\n  }\n\n  if (smpi_privatize_global_variables == SmpiPrivStrategies::MMAP)\n    smpi_destroy_global_memory_segments();\n  smpi_free_static();\n}\n\nstatic void smpi_init_options(){\n  // return if already called\n  if (smpi_cpu_threshold > -1)\n    return;\n  simgrid::smpi::Colls::set_collectives();\n  simgrid::smpi::Colls::smpi_coll_cleanup_callback = nullptr;\n  smpi_cpu_threshold                               = simgrid::config::get_value<double>(\"smpi/cpu-threshold\");\n  smpi_host_speed                                  = simgrid::config::get_value<double>(\"smpi/host-speed\");\n  xbt_assert(smpi_host_speed >= 0, \"You're trying to set the host_speed to a negative value (%f)\", smpi_host_speed);\n  std::string smpi_privatize_option = simgrid::config::get_value<std::string>(\"smpi/privatization\");\n  if (smpi_privatize_option == \"no\" || smpi_privatize_option == \"0\")\n    smpi_privatize_global_variables = SmpiPrivStrategies::NONE;\n  else if (smpi_privatize_option == \"yes\" || smpi_privatize_option == \"1\")\n    smpi_privatize_global_variables = SmpiPrivStrategies::DEFAULT;\n  else if (smpi_privatize_option == \"mmap\")\n    smpi_privatize_global_variables = SmpiPrivStrategies::MMAP;\n  else if (smpi_privatize_option == \"dlopen\")\n    smpi_privatize_global_variables = SmpiPrivStrategies::DLOPEN;\n  else\n    xbt_die(\"Invalid value for smpi/privatization: '%s'\", smpi_privatize_option.c_str());\n\n  if (not SMPI_switch_data_segment) {\n    XBT_DEBUG(\"Running without smpi_main(); disable smpi/privatization.\");\n    smpi_privatize_global_variables = SmpiPrivStrategies::NONE;\n  }\n#if defined(__FreeBSD__)\n  if (smpi_privatize_global_variables == SmpiPrivStrategies::MMAP) {\n    XBT_INFO(\"mmap privatization is broken on FreeBSD, switching to dlopen privatization instead.\");\n    smpi_privatize_global_variables = SmpiPrivStrategies::DLOPEN;\n  }\n#endif\n\n  if (smpi_cpu_threshold < 0)\n    smpi_cpu_threshold = DBL_MAX;\n\n  std::string val = simgrid::config::get_value<std::string>(\"smpi/shared-malloc\");\n  if ((val == \"yes\") || (val == \"1\") || (val == \"on\") || (val == \"global\")) {\n    smpi_cfg_shared_malloc = SharedMallocType::GLOBAL;\n  } else if (val == \"local\") {\n    smpi_cfg_shared_malloc = SharedMallocType::LOCAL;\n  } else if ((val == \"no\") || (val == \"0\") || (val == \"off\")) {\n    smpi_cfg_shared_malloc = SharedMallocType::NONE;\n  } else {\n    xbt_die(\"Invalid value '%s' for option smpi/shared-malloc. Possible values: 'on' or 'global', 'local', 'off'\",\n            val.c_str());\n  }\n}\n\ntypedef std::function<int(int argc, char *argv[])> smpi_entry_point_type;\ntypedef int (* smpi_c_entry_point_type)(int argc, char **argv);\ntypedef void (*smpi_fortran_entry_point_type)();\n\nstatic int smpi_run_entry_point(smpi_entry_point_type entry_point, std::vector<std::string> args)\n{\n  char noarg[]   = {'\\0'};\n  const int argc = args.size();\n  std::unique_ptr<char*[]> argv(new char*[argc + 1]);\n  for (int i = 0; i != argc; ++i)\n    argv[i] = args[i].empty() ? noarg : &args[i].front();\n  argv[argc] = nullptr;\n\n  int res = entry_point(argc, argv.get());\n  if (res != 0){\n    XBT_WARN(\"SMPI process did not return 0. Return value : %d\", res);\n    if (smpi_exit_status == 0)\n      smpi_exit_status = res;\n  }\n  return 0;\n}\n\n\n// TODO, remove the number of functions involved here\nstatic smpi_entry_point_type smpi_resolve_function(void* handle)\n{\n  smpi_fortran_entry_point_type entry_point_fortran = (smpi_fortran_entry_point_type)dlsym(handle, \"user_main_\");\n  if (entry_point_fortran != nullptr) {\n    return [entry_point_fortran](int argc, char** argv) {\n      smpi_process_init(&argc, &argv);\n      entry_point_fortran();\n      return 0;\n    };\n  }\n\n  smpi_c_entry_point_type entry_point = (smpi_c_entry_point_type)dlsym(handle, \"main\");\n  if (entry_point != nullptr) {\n    return entry_point;\n  }\n\n  return smpi_entry_point_type();\n}\n\nstatic void smpi_copy_file(std::string src, std::string target, off_t fdin_size)\n{\n  int fdin = open(src.c_str(), O_RDONLY);\n  xbt_assert(fdin >= 0, \"Cannot read from %s. Please make sure that the file exists and is executable.\", src.c_str());\n  int fdout = open(target.c_str(), O_CREAT | O_RDWR, S_IRWXU);\n  xbt_assert(fdout >= 0, \"Cannot write into %s\", target.c_str());\n\n  XBT_DEBUG(\"Copy %ld bytes into %s\", static_cast<long>(fdin_size), target.c_str());\n#if HAVE_SENDFILE\n  ssize_t sent_size = sendfile(fdout, fdin, NULL, fdin_size);\n  xbt_assert(sent_size == fdin_size, \"Error while copying %s: only %zd bytes copied instead of %ld (errno: %d -- %s)\",\n             target.c_str(), sent_size, fdin_size, errno, strerror(errno));\n#else\n  const int bufsize = 1024 * 1024 * 4;\n  char buf[bufsize];\n  while (int got = read(fdin, buf, bufsize)) {\n    if (got == -1) {\n      xbt_assert(errno == EINTR, \"Cannot read from %s\", src.c_str());\n    } else {\n      char* p  = buf;\n      int todo = got;\n      while (int done = write(fdout, p, todo)) {\n        if (done == -1) {\n          xbt_assert(errno == EINTR, \"Cannot write into %s\", target.c_str());\n        } else {\n          p += done;\n          todo -= done;\n        }\n      }\n    }\n  }\n#endif\n  close(fdin);\n  close(fdout);\n}\n\n#if not defined(__APPLE__)\nstatic int visit_libs(struct dl_phdr_info* info, size_t, void* data)\n{\n  char* libname = (char*)(data);\n  const char *path = info->dlpi_name;\n  if(strstr(path, libname)){\n    strncpy(libname, path, 512);\n    return 1;\n  }\n  \n  return 0;\n}\n#endif\n\nint smpi_main(const char* executable, int argc, char *argv[])\n{\n  srand(SMPI_RAND_SEED);\n\n  if (getenv(\"SMPI_PRETEND_CC\") != nullptr) {\n    /* Hack to ensure that smpicc can pretend to be a simple compiler. Particularly handy to pass it to the\n     * configuration tools */\n    return 0;\n  }\n\n  TRACE_global_init();\n\n  SIMIX_global_init(&argc, argv);\n  MSG_init(&argc,argv);\n\n  SMPI_switch_data_segment = &smpi_switch_data_segment;\n\n  // TODO This will not be executed in the case where smpi_main is not called,\n  // e.g., not for smpi_msg_masterslave. This should be moved to another location\n  // that is always called -- maybe close to Actor::onCreation?\n  simgrid::s4u::Host::on_creation.connect(\n      [](simgrid::s4u::Host& host) { host.extension_set(new simgrid::smpi::Host(&host)); });\n\n  // parse the platform file: get the host list\n  SIMIX_create_environment(argv[1]);\n  SIMIX_comm_set_copy_data_callback(smpi_comm_copy_buffer_callback);\n\n  smpi_init_options();\n  if (smpi_privatize_global_variables == SmpiPrivStrategies::DLOPEN) {\n\n    std::string executable_copy = executable;\n\n    // Prepare the copy of the binary (get its size)\n    struct stat fdin_stat;\n    stat(executable_copy.c_str(), &fdin_stat);\n    off_t fdin_size = fdin_stat.st_size;\n    static std::size_t rank = 0;\n    \n    \n    std::string libnames = simgrid::config::get_value<std::string>(\"smpi/privatize-libs\");\n    if(not libnames.empty()){\n      //split option\n      std::vector<std::string> privatize_libs;\n      boost::split(privatize_libs,libnames, boost::is_any_of(\";\"));\n\n      for (auto const& libname : privatize_libs) {\n        //load the library once to add it to the local libs, to get the absolute path\n        void* libhandle = dlopen(libname.c_str(), RTLD_LAZY);\n        //get library name from path\n        char fullpath[512]={'\\0'};\n        strcpy(fullpath, libname.c_str());\n#if not defined(__APPLE__)\n        int ret = dl_iterate_phdr(visit_libs, fullpath);\n        if(ret==0)\n          xbt_die(\"Can't find a linked %s - check the setting you gave to smpi/privatize-libs\", fullpath);\n        else\n          XBT_DEBUG(\"Extra lib to privatize found : %s\", fullpath);\n#else\n          xbt_die(\"smpi/privatize-libs is not (yet) compatible with OSX\");\n#endif\n        privatize_libs_paths.push_back(fullpath);\n        dlclose(libhandle);\n      }\n    }\n    \n    simix_global->default_function = [executable_copy, fdin_size](std::vector<std::string> args) {\n      return std::function<void()>([executable_copy, fdin_size, args] {\n\n        // Copy the dynamic library:\n        std::string target_executable = executable_copy\n          + \"_\" + std::to_string(getpid())\n          + \"_\" + std::to_string(rank) + \".so\";\n\n        smpi_copy_file(executable_copy, target_executable, fdin_size);\n        //if smpi/privatize-libs is set, duplicate pointed lib and link each executable copy to a different one.\n          std::string target_lib;\n          for (auto const& libpath : privatize_libs_paths){\n          //if we were given a full path, strip it\n          size_t index = libpath.find_last_of(\"/\\\\\");\n          std::string libname;\n          if(index!=std::string::npos)\n            libname=libpath.substr(index+1);\n\n          if(not libname.empty()){\n            //load the library to add it to the local libs, to get the absolute path\n            struct stat fdin_stat2;\n            stat(libpath.c_str(), &fdin_stat2);\n            off_t fdin_size2 = fdin_stat2.st_size;\n            \n            // Copy the dynamic library, the new name must be the same length as the old one\n            // just replace the name with 7 digits for the rank and the rest of the name.\n            unsigned int pad=7;\n            if(libname.length()<pad)\n              pad=libname.length();\n            target_lib = std::string(pad - std::to_string(rank).length(), '0')\n                        +std::to_string(rank)+libname.substr(pad);\n            XBT_DEBUG(\"copy lib %s to %s, with size %lld\", libpath.c_str(), target_lib.c_str(), (long long)fdin_size2);\n            smpi_copy_file(libpath, target_lib, fdin_size2);\n\n            std::string sedcommand = \"sed -i -e 's/\"+libname+\"/\"+target_lib+\"/g' \"+target_executable;\n            int ret = system(sedcommand.c_str());\n            if(ret!=0) xbt_die (\"error while applying sed command %s \\n\", sedcommand.c_str());\n          }\n        }\n\n        rank++;\n        // Load the copy and resolve the entry point:\n        void* handle = dlopen(target_executable.c_str(), RTLD_LAZY | RTLD_LOCAL | RTLD_DEEPBIND);\n        int saved_errno = errno;\n        if (simgrid::config::get_value<bool>(\"smpi/keep-temps\") == false){\n          unlink(target_executable.c_str());\n          if(not target_lib.empty())\n            unlink(target_lib.c_str());\n        }\n        if (handle == nullptr)\n          xbt_die(\"dlopen failed: %s (errno: %d -- %s)\", dlerror(), saved_errno, strerror(saved_errno));\n        smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n        if (not entry_point)\n          xbt_die(\"Could not resolve entry point\");\n        smpi_run_entry_point(entry_point, args);\n      });\n    };\n  }\n  else {\n    if (smpi_privatize_global_variables == SmpiPrivStrategies::MMAP)\n      smpi_prepare_global_memory_segment();\n    // Load the dynamic library and resolve the entry point:\n    void* handle = dlopen(executable, RTLD_LAZY | RTLD_LOCAL);\n    if (handle == nullptr)\n      xbt_die(\"dlopen failed for %s: %s (errno: %d -- %s)\", executable, dlerror(), errno, strerror(errno));\n    smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n    if (not entry_point)\n      xbt_die(\"main not found in %s\", executable);\n    if (smpi_privatize_global_variables == SmpiPrivStrategies::MMAP)\n      smpi_backup_global_memory_segment();\n\n    // Execute the same entry point for each simulated process:\n    simix_global->default_function = [entry_point](std::vector<std::string> args) {\n      return std::function<void()>([entry_point, args] {\n        smpi_run_entry_point(entry_point, args);\n      });\n    };\n  }\n\n  SMPI_init();\n  SIMIX_launch_application(argv[2]);\n  SMPI_app_instance_register(smpi_default_instance_name.c_str(), nullptr,\n                             process_data.size()); // This call has a side effect on process_count...\n  MPI_COMM_WORLD = *smpi_deployment_comm_world(smpi_default_instance_name);\n  smpi_universe_size = process_count;\n\n\n  /* Clean IO before the run */\n  fflush(stdout);\n  fflush(stderr);\n\n  if (MC_is_active()) {\n    MC_run();\n  } else {\n\n    SIMIX_run();\n\n    xbt_os_walltimer_stop(global_timer);\n    if (simgrid::config::get_value<bool>(\"smpi/display-timing\")) {\n      double global_time = xbt_os_timer_elapsed(global_timer);\n      XBT_INFO(\"Simulated time: %g seconds. \\n\\n\"\n          \"The simulation took %g seconds (after parsing and platform setup)\\n\"\n          \"%g seconds were actual computation of the application\",\n          SIMIX_get_clock(), global_time , smpi_total_benched_time);\n\n      if (smpi_total_benched_time/global_time>=0.75)\n      XBT_INFO(\"More than 75%% of the time was spent inside the application code.\\n\"\n      \"You may want to use sampling functions or trace replay to reduce this.\");\n    }\n  }\n  smpi_global_destroy();\n\n  return smpi_exit_status;\n}\n\n// Called either directly from the user code, or from the code called by smpirun\nvoid SMPI_init(){\n  simgrid::s4u::Actor::on_creation.connect([](simgrid::s4u::ActorPtr actor) {\n    if (not actor->is_daemon()) {\n      process_data.insert({actor, new simgrid::smpi::Process(actor, nullptr)});\n    }\n  });\n  simgrid::s4u::Actor::on_destruction.connect([](simgrid::s4u::ActorPtr actor) {\n    auto it = process_data.find(actor);\n    if (it != process_data.end()) {\n      delete it->second;\n      process_data.erase(it);\n    }\n  });\n\n  smpi_init_options();\n  smpi_global_init();\n  smpi_check_options();\n  simgrid::s4u::on_simulation_end.connect(TRACE_smpi_release);\n}\n\nvoid SMPI_finalize(){\n  smpi_global_destroy();\n}\n\nvoid smpi_mpi_init() {\n  if(smpi_init_sleep > 0)\n    simcall_process_sleep(smpi_init_sleep);\n}\n\ndouble smpi_mpi_wtime(){\n  double time;\n  if (smpi_process()->initialized() != 0 && smpi_process()->finalized() == 0 && smpi_process()->sampling() == 0) {\n    smpi_bench_end();\n    time = SIMIX_get_clock();\n    // to avoid deadlocks if used as a break condition, such as\n    //     while (MPI_Wtime(...) < time_limit) {\n    //       ....\n    //     }\n    // because the time will not normally advance when only calls to MPI_Wtime\n    // are made -> deadlock (MPI_Wtime never reaches the time limit)\n    if(smpi_wtime_sleep > 0)\n      simcall_process_sleep(smpi_wtime_sleep);\n    smpi_bench_begin();\n  } else {\n    time = SIMIX_get_clock();\n  }\n  return time;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/tools/cmake/test_prog/prog_gnu_dynlinker.c": "/* prog_gnu_dynlinker.c -- check that RTLD_NEXT is defined as in GNU linker */\n/* Copyright (c) 2012-2018. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#define _GNU_SOURCE 1\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic void * (*real_malloc) (size_t);\n\nint main(void) {\n   char *error;\n   dlerror(); // clear any previous error\n   real_malloc = (void * (*) (size_t)) dlsym(RTLD_NEXT, \"malloc\");\n   error = dlerror();\n   if (!error && real_malloc) {\n      char *A = real_malloc(20);\n      strcpy(A,\"epic success\");\n      free(A);\n      return 0; // SUCCESS\n   } else {\n      if (error)\n   printf(\"Error while checking for dlsym: %s\\n\",error);\n      else\n   printf(\"dlsym did not return any error, but failed to find malloc()\\n\");\n      return 1; // FAILED\n   }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/surf++.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/triva-time_interval.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/triva-graph_visualization.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/surf++.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/triva-graph_configuration.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/sc3-description.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/smpi_simgrid_alltoall_pair_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/output.goal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/smpi_simgrid_alltoall_ring_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/AS_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/SGicon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/eclipseScreenShot.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/SGicon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/SGicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/awstats_logo3.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/poster_thumbnail.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/simgrid_logo_2011_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/simgrid_logo_win.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-3.20-xigfpbo5yypiin5odq3dedwvkyxa5sxr/spack-src/doc/webcruft/simgrid_logo_win_2011.bmp"
    ],
    "total_files": 2455
}