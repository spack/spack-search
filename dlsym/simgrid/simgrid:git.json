{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/src/xbt/mmalloc/mm_legacy.c": "/* Copyright (c) 2010-2020. The SimGrid Team.\n * All rights reserved.                                                     */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n/* Redefine the classical malloc/free/realloc functions so that they fit well in the mmalloc framework */\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n#include \"mmprivate.h\"\n#include \"src/internal_config.h\"\n#include \"src/mc/mc_base.h\"\n#include \"src/mc/remote/mc_protocol.h\"\n#include \"src/xbt_modinter.h\"\n#include <math.h>\n\n/* ***** Whether to use `mmalloc` of the underlying malloc ***** */\n\nstatic int __malloc_use_mmalloc;\n\nint malloc_use_mmalloc(void)\n{\n  return __malloc_use_mmalloc;\n}\n\n/* ***** Current heap ***** */\n\n/* The mmalloc() package can use a single implicit malloc descriptor\n   for mmalloc/mrealloc/mfree operations which do not supply an explicit\n   descriptor.  This allows mmalloc() to provide\n   backwards compatibility with the non-mmap'd version. */\nxbt_mheap_t __mmalloc_default_mdp = NULL;\n\n/* The heap we are currently using. */\nstatic xbt_mheap_t __mmalloc_current_heap = NULL;\n\nxbt_mheap_t mmalloc_get_current_heap(void)\n{\n  return __mmalloc_current_heap;\n}\n\n/* Override the malloc-like functions if MC is activated at compile time */\n#if SIMGRID_HAVE_MC\n\n/* ***** Temporary allocator\n *\n * This is used before we have found the real malloc implementation with dlsym.\n */\n\n#ifdef __FreeBSD__ /* FreeBSD require more memory, other might */\n# define BUFFER_SIZE 256\n#else /* Valid on: Linux */\n# define BUFFER_SIZE 32\n#endif\nstatic size_t fake_alloc_index;\nstatic uint64_t buffer[BUFFER_SIZE];\n\n/* Fake implementations, they are used to fool dlsym:\n * dlsym used calloc and falls back to some other mechanism\n * if this fails.\n */\nstatic void* mm_fake_malloc(size_t n)\n{\n  // How many uint64_t do w need?\n  size_t count = n / sizeof(uint64_t);\n  if (n % sizeof(uint64_t))\n    count++;\n  // Check that we have enough available memory:\n  if (fake_alloc_index + count >= BUFFER_SIZE)\n    exit(127);\n  // Allocate it:\n  uint64_t* res = buffer + fake_alloc_index;\n  fake_alloc_index += count;\n  return res;\n}\n\nstatic void* mm_fake_calloc(size_t nmemb, size_t size)\n{\n  // This is fresh .bss data, we don't need to clear it:\n  size_t n = nmemb * size;\n  return mm_fake_malloc(n);\n}\n\nstatic void* mm_fake_realloc(XBT_ATTRIB_UNUSED void* p, size_t s)\n{\n  return mm_fake_malloc(s);\n}\n\nstatic void mm_fake_free(XBT_ATTRIB_UNUSED void* p)\n{\n  // Nothing to do\n}\n\n/* Function signatures for the main malloc functions: */\ntypedef void* (*mm_malloc_t)(size_t size);\ntypedef void  (*mm_free_t)(void*);\ntypedef void* (*mm_calloc_t)(size_t nmemb, size_t size);\ntypedef void* (*mm_realloc_t)(void *ptr, size_t size);\n\n/* Function pointers to the real/next implementations: */\nstatic mm_malloc_t mm_real_malloc;\nstatic mm_free_t mm_real_free;\nstatic mm_calloc_t mm_real_calloc;\nstatic mm_realloc_t mm_real_realloc;\n\nstatic int mm_initializing;\nstatic int mm_initialized;\n\n/** Constructor functions used to initialize the malloc implementation\n */\nXBT_ATTRIB_CONSTRUCTOR(101) static void mm_legacy_constructor()\n{\n  if (mm_initialized)\n    return;\n  mm_initializing = 1;\n  __malloc_use_mmalloc = getenv(MC_ENV_SOCKET_FD) ? 1 : 0;\n  if (__malloc_use_mmalloc) {\n    __mmalloc_current_heap = mmalloc_preinit();\n  } else {\n#if HAVE_DLFUNC\n    mm_real_realloc  = (void *(*)(void *, size_t))dlfunc(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = (void *(*)(size_t))dlfunc(RTLD_NEXT, \"malloc\");\n    mm_real_free     = (void (*)(void *))dlfunc(RTLD_NEXT, \"free\");\n    mm_real_calloc   = (void *(*)(size_t, size_t))dlfunc(RTLD_NEXT, \"calloc\");\n#else\n    mm_real_realloc  = dlsym(RTLD_NEXT, \"realloc\");\n    mm_real_malloc   = dlsym(RTLD_NEXT, \"malloc\");\n    mm_real_free     = dlsym(RTLD_NEXT, \"free\");\n    mm_real_calloc   = dlsym(RTLD_NEXT, \"calloc\");\n#endif\n  }\n  mm_initializing = 0;\n  mm_initialized = 1;\n}\n\n/* ***** malloc/free implementation\n *\n * They call either the underlying/native/RTLD_NEXT implementation (non MC mode)\n * or the mm implementation (MC mode).\n *\n * If we are initializing the malloc subsystem, we call the fake/dummy `malloc`\n * implementation. This is necessary because `dlsym` calls `malloc` and friends.\n */\n\n#define GET_HEAP() __mmalloc_current_heap\n\nvoid *malloc(size_t n)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_malloc(n);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_malloc(n);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, n);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_calloc(nmemb, size);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_calloc(nmemb, size);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void *ret = mmalloc(mdp, nmemb*size);\n  UNLOCK(mdp);\n  // This was already done in the callee:\n  if(!(mdp->options & XBT_MHEAP_OPTION_MEMSET)) {\n    memset(ret, 0, nmemb * size);\n  }\n  return ret;\n}\n\nvoid *realloc(void *p, size_t s)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_realloc(p, s);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    return mm_real_realloc(p, s);\n  }\n\n  xbt_mheap_t mdp = GET_HEAP();\n  if (!mdp)\n    return NULL;\n\n  LOCK(mdp);\n  void* ret = mrealloc(mdp, p, s);\n  UNLOCK(mdp);\n  return ret;\n}\n\nvoid free(void *p)\n{\n  if (!mm_initialized) {\n    if (mm_initializing)\n      return mm_fake_free(p);\n    mm_legacy_constructor();\n  }\n\n  if (!__malloc_use_mmalloc) {\n    mm_real_free(p);\n    return;\n  }\n\n  if (!p)\n    return;\n\n  xbt_mheap_t mdp = GET_HEAP();\n  LOCK(mdp);\n  mfree(mdp, p);\n  UNLOCK(mdp);\n}\n#endif /* SIMGRID_HAVE_MC */\n",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/src/smpi/internals/smpi_global.cpp": "/* Copyright (c) 2007-2020. The SimGrid Team. All rights reserved.          */\n\n/* This program is free software; you can redistribute it and/or modify it\n * under the terms of the license (GNU LGPL) which comes with this package. */\n\n#include \"mc/mc.h\"\n#include \"simgrid/s4u/Engine.hpp\"\n#include \"simgrid/plugins/file_system.h\"\n#include \"smpi_coll.hpp\"\n#include \"smpi_f2c.hpp\"\n#include \"smpi_host.hpp\"\n#include \"smpi_config.hpp\"\n#include \"src/kernel/activity/CommImpl.hpp\"\n#include \"src/simix/smx_private.hpp\"\n#include \"src/smpi/include/smpi_actor.hpp\"\n#include \"xbt/config.hpp\"\n#include \"xbt/file.hpp\"\n\n#include <algorithm>\n#include <array>\n#include <boost/algorithm/string.hpp> /* split */\n#include <boost/tokenizer.hpp>\n#include <cinttypes>\n#include <cstdint> /* intmax_t */\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <fstream>\n#include <sys/stat.h>\n\n#if SG_HAVE_SENDFILE\n#include <sys/sendfile.h>\n#endif\n\n#if HAVE_PAPI\n#include \"papi.h\"\n#endif\n\n#if not defined(__APPLE__) && not defined(__HAIKU__)\n#include <link.h>\n#endif\n\nXBT_LOG_NEW_DEFAULT_SUBCATEGORY(smpi_kernel, smpi, \"Logging specific to SMPI (kernel)\");\n\n#if SMPI_IFORT\n  extern \"C\" void for_rtl_init_ (int *, char **);\n  extern \"C\" void for_rtl_finish_ ();\n#elif SMPI_FLANG\n  extern \"C\" void __io_set_argc(int);\n  extern \"C\" void __io_set_argv(char **);\n#elif SMPI_GFORTRAN\n  extern \"C\" void _gfortran_set_args(int, char **);\n#endif\n\n/* RTLD_DEEPBIND is a bad idea of GNU ld that obviously does not exist on other platforms\n * See https://www.akkadia.org/drepper/dsohowto.pdf\n * and https://lists.freebsd.org/pipermail/freebsd-current/2016-March/060284.html\n*/\n#if !RTLD_DEEPBIND || HAVE_SANITIZER_ADDRESS || HAVE_SANITIZER_THREAD\n#define WANT_RTLD_DEEPBIND 0\n#else\n#define WANT_RTLD_DEEPBIND RTLD_DEEPBIND\n#endif\n\n#if HAVE_PAPI\nstd::string papi_default_config_name = \"default\";\nstd::map</* computation unit name */ std::string, papi_process_data> units2papi_setup;\n#endif\n\nstd::unordered_map<std::string, double> location2speedup;\n\nstatic int smpi_exit_status = 0;\nextern double smpi_total_benched_time;\nxbt_os_timer_t global_timer;\nstatic std::vector<std::string> privatize_libs_paths;\n/**\n * Setting MPI_COMM_WORLD to MPI_COMM_UNINITIALIZED (it's a variable)\n * is important because the implementation of MPI_Comm checks\n * \"this == MPI_COMM_UNINITIALIZED\"? If yes, it uses smpi_process()->comm_world()\n * instead of \"this\".\n * This is basically how we only have one global variable but all processes have\n * different communicators (the one their SMPI instance uses).\n *\n * See smpi_comm.cpp and the functions therein for details.\n */\nMPI_Comm MPI_COMM_WORLD = MPI_COMM_UNINITIALIZED;\n// No instance gets manually created; check also the smpirun.in script as\n// this default name is used there as well (when the <actor> tag is generated).\nstatic const std::string smpi_default_instance_name(\"smpirun\");\nstatic simgrid::config::Flag<double> smpi_init_sleep(\n  \"smpi/init\", \"Time to inject inside a call to MPI_Init\", 0.0);\n\nvoid (*smpi_comm_copy_data_callback)(simgrid::kernel::activity::CommImpl*, void*,\n                                     size_t) = &smpi_comm_copy_buffer_callback;\n\nsimgrid::smpi::ActorExt* smpi_process()\n{\n  simgrid::s4u::ActorPtr me = simgrid::s4u::Actor::self();\n\n  if (me == nullptr) // This happens sometimes (eg, when linking against NS3 because it pulls openMPI...)\n    return nullptr;\n\n  return me->extension<simgrid::smpi::ActorExt>();\n}\n\nsimgrid::smpi::ActorExt* smpi_process_remote(simgrid::s4u::ActorPtr actor)\n{\n  if (actor.get() == nullptr)\n    return nullptr;\n  return actor->extension<simgrid::smpi::ActorExt>();\n}\n\nMPI_Comm smpi_process_comm_self(){\n  return smpi_process()->comm_self();\n}\n\nMPI_Info smpi_process_info_env(){\n  return smpi_process()->info_env();\n}\n\nvoid * smpi_process_get_user_data(){\n  return simgrid::s4u::Actor::self()->get_data();\n}\n\nvoid smpi_process_set_user_data(void *data){\n  simgrid::s4u::Actor::self()->set_data(data);\n}\n\nvoid smpi_comm_set_copy_data_callback(void (*callback) (smx_activity_t, void*, size_t))\n{\n  static void (*saved_callback)(smx_activity_t, void*, size_t);\n  saved_callback               = callback;\n  smpi_comm_copy_data_callback = [](simgrid::kernel::activity::CommImpl* comm, void* buff, size_t size) {\n    saved_callback(comm, buff, size);\n  };\n}\n\nstatic void memcpy_private(void* dest, const void* src, const std::vector<std::pair<size_t, size_t>>& private_blocks)\n{\n  for (auto const& block : private_blocks)\n    memcpy((uint8_t*)dest+block.first, (uint8_t*)src+block.first, block.second-block.first);\n}\n\nstatic void check_blocks(const std::vector<std::pair<size_t, size_t>>& private_blocks, size_t buff_size)\n{\n  for (auto const& block : private_blocks)\n    xbt_assert(block.first <= block.second && block.second <= buff_size, \"Oops, bug in shared malloc.\");\n}\n\nstatic void smpi_cleanup_comm_after_copy(simgrid::kernel::activity::CommImpl* comm, void* buff){\n  if (comm->detached()) {\n    // if this is a detached send, the source buffer was duplicated by SMPI\n    // sender to make the original buffer available to the application ASAP\n    xbt_free(buff);\n    //It seems that the request is used after the call there this should be free somewhere else but where???\n    //xbt_free(comm->comm.src_data);// inside SMPI the request is kept inside the user data and should be free\n    comm->src_buff_ = nullptr;\n  }\n}\n\nvoid smpi_comm_copy_buffer_callback(simgrid::kernel::activity::CommImpl* comm, void* buff, size_t buff_size)\n{\n  size_t src_offset                     = 0;\n  size_t dst_offset                     = 0;\n  std::vector<std::pair<size_t, size_t>> src_private_blocks;\n  std::vector<std::pair<size_t, size_t>> dst_private_blocks;\n  XBT_DEBUG(\"Copy the data over\");\n  if(smpi_is_shared(buff, src_private_blocks, &src_offset)) {\n    src_private_blocks = shift_and_frame_private_blocks(src_private_blocks, src_offset, buff_size);\n    if (src_private_blocks.empty()) { // simple shared malloc ... return.\n      XBT_VERB(\"Sender is shared. Let's ignore it.\");\n      smpi_cleanup_comm_after_copy(comm, buff);\n      return;\n    }\n  }\n  else {\n    src_private_blocks.clear();\n    src_private_blocks.emplace_back(0, buff_size);\n  }\n  if (smpi_is_shared((char*)comm->dst_buff_, dst_private_blocks, &dst_offset)) {\n    dst_private_blocks = shift_and_frame_private_blocks(dst_private_blocks, dst_offset, buff_size);\n    if (dst_private_blocks.empty()) { // simple shared malloc ... return.\n      XBT_VERB(\"Receiver is shared. Let's ignore it.\");\n      smpi_cleanup_comm_after_copy(comm, buff);\n      return;\n    }\n  }\n  else {\n    dst_private_blocks.clear();\n    dst_private_blocks.emplace_back(0, buff_size);\n  }\n  check_blocks(src_private_blocks, buff_size);\n  check_blocks(dst_private_blocks, buff_size);\n  auto private_blocks = merge_private_blocks(src_private_blocks, dst_private_blocks);\n  check_blocks(private_blocks, buff_size);\n  void* tmpbuff=buff;\n  if ((smpi_cfg_privatization() == SmpiPrivStrategies::MMAP) &&\n      (static_cast<char*>(buff) >= smpi_data_exe_start) &&\n      (static_cast<char*>(buff) < smpi_data_exe_start + smpi_data_exe_size)) {\n    XBT_DEBUG(\"Privatization : We are copying from a zone inside global memory... Saving data to temp buffer !\");\n    smpi_switch_data_segment(comm->src_actor_->get_iface());\n    tmpbuff = xbt_malloc(buff_size);\n    memcpy_private(tmpbuff, buff, private_blocks);\n  }\n\n  if ((smpi_cfg_privatization() == SmpiPrivStrategies::MMAP) &&\n      ((char*)comm->dst_buff_ >= smpi_data_exe_start) &&\n      ((char*)comm->dst_buff_ < smpi_data_exe_start + smpi_data_exe_size)) {\n    XBT_DEBUG(\"Privatization : We are copying to a zone inside global memory - Switch data segment\");\n    smpi_switch_data_segment(comm->dst_actor_->get_iface());\n  }\n  XBT_DEBUG(\"Copying %zu bytes from %p to %p\", buff_size, tmpbuff, comm->dst_buff_);\n  memcpy_private(comm->dst_buff_, tmpbuff, private_blocks);\n\n  smpi_cleanup_comm_after_copy(comm,buff);\n  if (tmpbuff != buff)\n    xbt_free(tmpbuff);\n}\n\nvoid smpi_comm_null_copy_buffer_callback(simgrid::kernel::activity::CommImpl*, void*, size_t)\n{\n  /* nothing done in this version */\n}\n\nint smpi_enabled() {\n  return MPI_COMM_WORLD != MPI_COMM_UNINITIALIZED;\n}\n\nstatic void smpi_init_papi()\n{\n#if HAVE_PAPI\n  // This map holds for each computation unit (such as \"default\" or \"process1\" etc.)\n  // the configuration as given by the user (counter data as a pair of (counter_name, counter_counter))\n  // and the (computed) event_set.\n\n  if (not smpi_cfg_papi_events_file().empty()) {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT)\n      XBT_ERROR(\"Could not initialize PAPI library; is it correctly installed and linked?\"\n                \" Expected version is %u\", PAPI_VER_CURRENT);\n\n    using Tokenizer = boost::tokenizer<boost::char_separator<char>>;\n    boost::char_separator<char> separator_units(\";\");\n    std::string str = smpi_cfg_papi_events_file();\n    Tokenizer tokens(str, separator_units);\n\n    // Iterate over all the computational units. This could be processes, hosts, threads, ranks... You name it.\n    // I'm not exactly sure what we will support eventually, so I'll leave it at the general term \"units\".\n    for (auto const& unit_it : tokens) {\n      boost::char_separator<char> separator_events(\":\");\n      Tokenizer event_tokens(unit_it, separator_events);\n\n      int event_set = PAPI_NULL;\n      if (PAPI_create_eventset(&event_set) != PAPI_OK) {\n        // TODO: Should this let the whole simulation die?\n        XBT_CRITICAL(\"Could not create PAPI event set during init.\");\n      }\n\n      // NOTE: We cannot use a map here, as we must obey the order of the counters\n      // This is important for PAPI: We need to map the values of counters back to the event_names (so, when PAPI_read()\n      // has finished)!\n      papi_counter_t counters2values;\n\n      // Iterate over all counters that were specified for this specific unit.\n      // Note that we need to remove the name of the unit (that could also be the \"default\" value), which always comes\n      // first. Hence, we start at ++(events.begin())!\n      for (Tokenizer::iterator events_it = ++(event_tokens.begin()); events_it != event_tokens.end(); ++events_it) {\n        int event_code   = PAPI_NULL;\n        auto* event_name = const_cast<char*>((*events_it).c_str());\n        if (PAPI_event_name_to_code(event_name, &event_code) != PAPI_OK) {\n          XBT_CRITICAL(\"Could not find PAPI event '%s'. Skipping.\", event_name);\n          continue;\n        }\n        if (PAPI_add_event(event_set, event_code) != PAPI_OK) {\n          XBT_ERROR(\"Could not add PAPI event '%s'. Skipping.\", event_name);\n          continue;\n        }\n        XBT_DEBUG(\"Successfully added PAPI event '%s' to the event set.\", event_name);\n\n        counters2values.push_back(\n            // We cannot just pass *events_it, as this is of type const basic_string\n            std::make_pair(std::string(*events_it), 0LL));\n      }\n\n      std::string unit_name    = *(event_tokens.begin());\n      papi_process_data config = {.counter_data = std::move(counters2values), .event_set = event_set};\n\n      units2papi_setup.insert(std::make_pair(unit_name, std::move(config)));\n    }\n  }\n#endif\n}\n\nusing smpi_entry_point_type         = std::function<int(int argc, char* argv[])>;\nusing smpi_c_entry_point_type       = int (*)(int argc, char** argv);\nusing smpi_fortran_entry_point_type = void (*)();\n\ntemplate <typename F>\nstatic int smpi_run_entry_point(const F& entry_point, const std::string& executable_path, std::vector<std::string> args)\n{\n  // copy C strings, we need them writable\n  auto* args4argv = new std::vector<char*>(args.size());\n  std::transform(begin(args), end(args), begin(*args4argv), [](const std::string& s) { return xbt_strdup(s.c_str()); });\n\n  // set argv[0] to executable_path\n  xbt_free((*args4argv)[0]);\n  (*args4argv)[0] = xbt_strdup(executable_path.c_str());\n\n#if !SMPI_IFORT\n  // take a copy of args4argv to keep reference of the allocated strings\n  const std::vector<char*> args2str(*args4argv);\n#endif\n  int argc = args4argv->size();\n  args4argv->push_back(nullptr);\n  char** argv = args4argv->data();\n\n#if SMPI_IFORT\n  for_rtl_init_ (&argc, argv);\n#elif SMPI_FLANG\n  __io_set_argc(argc);\n  __io_set_argv(argv);\n#elif SMPI_GFORTRAN\n  _gfortran_set_args(argc, argv);\n#endif \n  int res = entry_point(argc, argv);\n\n#if SMPI_IFORT\n  for_rtl_finish_ ();\n#else\n  for (char* s : args2str)\n    xbt_free(s);\n  delete args4argv;\n#endif\n\n  if (res != 0){\n    XBT_WARN(\"SMPI process did not return 0. Return value : %d\", res);\n    if (smpi_exit_status == 0)\n      smpi_exit_status = res;\n  }\n  return 0;\n}\n\n\n// TODO, remove the number of functions involved here\nstatic smpi_entry_point_type smpi_resolve_function(void* handle)\n{\n  auto* entry_point_fortran = reinterpret_cast<smpi_fortran_entry_point_type>(dlsym(handle, \"user_main_\"));\n  if (entry_point_fortran != nullptr) {\n    return [entry_point_fortran](int, char**) {\n      entry_point_fortran();\n      return 0;\n    };\n  }\n\n  auto* entry_point = reinterpret_cast<smpi_c_entry_point_type>(dlsym(handle, \"main\"));\n  if (entry_point != nullptr) {\n    return entry_point;\n  }\n\n  return smpi_entry_point_type();\n}\n\nstatic void smpi_copy_file(const std::string& src, const std::string& target, off_t fdin_size)\n{\n  int fdin = open(src.c_str(), O_RDONLY);\n  xbt_assert(fdin >= 0, \"Cannot read from %s. Please make sure that the file exists and is executable.\", src.c_str());\n  int fdout = open(target.c_str(), O_CREAT | O_RDWR, S_IRWXU);\n  xbt_assert(fdout >= 0, \"Cannot write into %s\", target.c_str());\n\n  XBT_DEBUG(\"Copy %\" PRIdMAX \" bytes into %s\", static_cast<intmax_t>(fdin_size), target.c_str());\n#if SG_HAVE_SENDFILE\n  ssize_t sent_size = sendfile(fdout, fdin, nullptr, fdin_size);\n  if (sent_size == fdin_size) {\n    close(fdin);\n    close(fdout);\n    return;\n  } else if (sent_size != -1 || errno != ENOSYS) {\n    xbt_die(\"Error while copying %s: only %zd bytes copied instead of %\" PRIdMAX \" (errno: %d -- %s)\", target.c_str(),\n            sent_size, static_cast<intmax_t>(fdin_size), errno, strerror(errno));\n  }\n#endif\n  // If this point is reached, sendfile() actually is not available.  Copy file by hand.\n  std::vector<unsigned char> buf(1024 * 1024 * 4);\n  while (ssize_t got = read(fdin, buf.data(), buf.size())) {\n    if (got == -1) {\n      xbt_assert(errno == EINTR, \"Cannot read from %s\", src.c_str());\n    } else {\n      const unsigned char* p = buf.data();\n      ssize_t todo           = got;\n      while (ssize_t done = write(fdout, p, todo)) {\n        if (done == -1) {\n          xbt_assert(errno == EINTR, \"Cannot write into %s\", target.c_str());\n        } else {\n          p += done;\n          todo -= done;\n        }\n      }\n    }\n  }\n  close(fdin);\n  close(fdout);\n}\n\n#if not defined(__APPLE__) && not defined(__HAIKU__)\nstatic int visit_libs(struct dl_phdr_info* info, size_t, void* data)\n{\n  auto* libname    = static_cast<std::string*>(data);\n  std::string path = info->dlpi_name;\n  if (path.find(*libname) != std::string::npos) {\n    *libname = std::move(path);\n    return 1;\n  }\n  return 0;\n}\n#endif\n\nstatic void smpi_init_privatization_dlopen(const std::string& executable)\n{\n  // Prepare the copy of the binary (get its size)\n  struct stat fdin_stat;\n  stat(executable.c_str(), &fdin_stat);\n  off_t fdin_size         = fdin_stat.st_size;\n\n  std::string libnames = simgrid::config::get_value<std::string>(\"smpi/privatize-libs\");\n  if (not libnames.empty()) {\n    // split option\n    std::vector<std::string> privatize_libs;\n    boost::split(privatize_libs, libnames, boost::is_any_of(\";\"));\n\n    for (auto const& libname : privatize_libs) {\n      // load the library once to add it to the local libs, to get the absolute path\n      void* libhandle = dlopen(libname.c_str(), RTLD_LAZY);\n      xbt_assert(libhandle != nullptr, \n\t\t      \"Cannot dlopen %s - check your settings in smpi/privatize-libs\", libname.c_str());\n      // get library name from path\n      std::string fullpath = libname;\n#if not defined(__APPLE__) && not defined(__HAIKU__)\n      XBT_ATTRIB_UNUSED int dl_iterate_res = dl_iterate_phdr(visit_libs, &fullpath);\n      xbt_assert(dl_iterate_res != 0, \"Can't find a linked %s - check your settings in smpi/privatize-libs\",\n                 fullpath.c_str());\n      XBT_DEBUG(\"Extra lib to privatize '%s' found\", fullpath.c_str());\n#else\n      xbt_die(\"smpi/privatize-libs is not (yet) compatible with OSX nor with Haiku\");\n#endif\n      privatize_libs_paths.emplace_back(std::move(fullpath));\n      dlclose(libhandle);\n    }\n  }\n\n  simgrid::s4u::Engine::get_instance()->register_default([executable, fdin_size](std::vector<std::string> args) {\n    return std::function<void()>([executable, fdin_size, args] {\n      static std::size_t rank = 0;\n      // Copy the dynamic library:\n      simgrid::xbt::Path path(executable);\n      std::string target_executable = simgrid::config::get_value<std::string>(\"smpi/tmpdir\") + \"/\" +\n          path.get_base_name() + \"_\" + std::to_string(getpid()) + \"_\" + std::to_string(rank) + \".so\";\n\n      smpi_copy_file(executable, target_executable, fdin_size);\n      // if smpi/privatize-libs is set, duplicate pointed lib and link each executable copy to a different one.\n      std::vector<std::string> target_libs;\n      for (auto const& libpath : privatize_libs_paths) {\n        // if we were given a full path, strip it\n        size_t index = libpath.find_last_of(\"/\\\\\");\n        std::string libname;\n        if (index != std::string::npos)\n          libname = libpath.substr(index + 1);\n\n        if (not libname.empty()) {\n          // load the library to add it to the local libs, to get the absolute path\n          struct stat fdin_stat2;\n          stat(libpath.c_str(), &fdin_stat2);\n          off_t fdin_size2 = fdin_stat2.st_size;\n\n          // Copy the dynamic library, the new name must be the same length as the old one\n          // just replace the name with 7 digits for the rank and the rest of the name.\n          unsigned int pad = 7;\n          if (libname.length() < pad)\n            pad = libname.length();\n          std::string target_libname = std::string(pad - std::to_string(rank).length(), '0') + std::to_string(rank) + libname.substr(pad);\n          std::string target_lib = simgrid::config::get_value<std::string>(\"smpi/tmpdir\") + \"/\" + target_libname;\n          target_libs.push_back(target_lib);\n          XBT_DEBUG(\"copy lib %s to %s, with size %lld\", libpath.c_str(), target_lib.c_str(), (long long)fdin_size2);\n          smpi_copy_file(libpath, target_lib, fdin_size2);\n\n          std::string sedcommand = \"sed -i -e 's/\" + libname + \"/\" + target_libname + \"/g' \" + target_executable;\n          int status             = system(sedcommand.c_str());\n          xbt_assert(status == 0, \"error while applying sed command %s \\n\", sedcommand.c_str());\n        }\n      }\n\n      rank++;\n      // Load the copy and resolve the entry point:\n      void* handle    = dlopen(target_executable.c_str(), RTLD_LAZY | RTLD_LOCAL | WANT_RTLD_DEEPBIND);\n      int saved_errno = errno;\n      if (not simgrid::config::get_value<bool>(\"smpi/keep-temps\")) {\n        unlink(target_executable.c_str());\n        for (const std::string& target_lib : target_libs)\n          unlink(target_lib.c_str());\n      }\n      xbt_assert(handle != nullptr, \"dlopen failed: %s (errno: %d -- %s)\", dlerror(), saved_errno,\n                 strerror(saved_errno));\n\n      smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n      xbt_assert(entry_point, \"Could not resolve entry point\");\n      smpi_run_entry_point(entry_point, executable, args);\n    });\n  });\n}\n\nstatic void smpi_init_privatization_no_dlopen(const std::string& executable)\n{\n  if (smpi_cfg_privatization() == SmpiPrivStrategies::MMAP)\n    smpi_prepare_global_memory_segment();\n\n  // Load the dynamic library and resolve the entry point:\n  void* handle = dlopen(executable.c_str(), RTLD_LAZY | RTLD_LOCAL);\n  xbt_assert(handle != nullptr, \"dlopen failed for %s: %s (errno: %d -- %s)\", executable.c_str(), dlerror(), errno,\n             strerror(errno));\n  smpi_entry_point_type entry_point = smpi_resolve_function(handle);\n  xbt_assert(entry_point, \"main not found in %s\", executable.c_str());\n\n  if (smpi_cfg_privatization() == SmpiPrivStrategies::MMAP)\n    smpi_backup_global_memory_segment();\n\n  // Execute the same entry point for each simulated process:\n  simgrid::s4u::Engine::get_instance()->register_default([entry_point, executable](std::vector<std::string> args) {\n    return std::function<void()>(\n        [entry_point, executable, args] { smpi_run_entry_point(entry_point, executable, args); });\n  });\n}\n\nint smpi_main(const char* executable, int argc, char* argv[])\n{\n  if (getenv(\"SMPI_PRETEND_CC\") != nullptr) {\n    /* Hack to ensure that smpicc can pretend to be a simple compiler. Particularly handy to pass it to the\n     * configuration tools */\n    return 0;\n  }\n  \n  SMPI_switch_data_segment = &smpi_switch_data_segment;\n  smpi_init_options();\n  simgrid::instr::init();\n  SIMIX_global_init(&argc, argv);\n\n  auto engine              = simgrid::s4u::Engine::get_instance();\n\n  sg_storage_file_system_init();\n  // parse the platform file: get the host list\n  engine->load_platform(argv[1]);\n  SIMIX_comm_set_copy_data_callback(smpi_comm_copy_buffer_callback);\n\n  if (smpi_cfg_privatization() == SmpiPrivStrategies::DLOPEN)\n    smpi_init_privatization_dlopen(executable);\n  else\n    smpi_init_privatization_no_dlopen(executable);\n\n  simgrid::smpi::colls::set_collectives();\n  simgrid::smpi::colls::smpi_coll_cleanup_callback = nullptr;\n  \n  SMPI_init();\n\n  /* This is a ... heavy way to count the MPI ranks */\n  int rank_counts = 0;\n  simgrid::s4u::Actor::on_creation.connect([&rank_counts](const simgrid::s4u::Actor& actor) {\n    if (not actor.is_daemon())\n      rank_counts++;\n  });\n  engine->load_deployment(argv[2]);\n\n  SMPI_app_instance_register(smpi_default_instance_name.c_str(), nullptr, rank_counts);\n  MPI_COMM_WORLD = *smpi_deployment_comm_world(smpi_default_instance_name);\n\n  /* Clean IO before the run */\n  fflush(stdout);\n  fflush(stderr);\n\n  if (MC_is_active()) {\n    MC_run();\n  } else {\n    SIMIX_run();\n\n    xbt_os_walltimer_stop(global_timer);\n    if (simgrid::config::get_value<bool>(\"smpi/display-timing\")) {\n      double global_time = xbt_os_timer_elapsed(global_timer);\n      XBT_INFO(\"Simulated time: %g seconds. \\n\\n\"\n          \"The simulation took %g seconds (after parsing and platform setup)\\n\"\n          \"%g seconds were actual computation of the application\",\n          SIMIX_get_clock(), global_time , smpi_total_benched_time);\n\n      if (smpi_total_benched_time/global_time>=0.75)\n      XBT_INFO(\"More than 75%% of the time was spent inside the application code.\\n\"\n      \"You may want to use sampling functions or trace replay to reduce this.\");\n    }\n  }\n  SMPI_finalize();\n\n  return smpi_exit_status;\n}\n\n// Called either directly from the user code, or from the code called by smpirun\nvoid SMPI_init(){\n  smpi_init_options();\n  simgrid::s4u::Actor::on_creation.connect([](simgrid::s4u::Actor& actor) {\n    if (not actor.is_daemon())\n      actor.extension_set<simgrid::smpi::ActorExt>(new simgrid::smpi::ActorExt(&actor));\n  });\n  simgrid::s4u::Host::on_creation.connect(\n      [](simgrid::s4u::Host& host) { host.extension_set(new simgrid::smpi::Host(&host)); });\n  for (auto const& host : simgrid::s4u::Engine::get_instance()->get_all_hosts())\n    host->extension_set(new simgrid::smpi::Host(host));\n\n  if (not MC_is_active()) {\n    global_timer = xbt_os_timer_new();\n    xbt_os_walltimer_start(global_timer);\n  }\n  smpi_init_papi();\n  smpi_check_options();\n}\n\nvoid SMPI_finalize()\n{\n  smpi_bench_destroy();\n  smpi_shared_destroy();\n  smpi_deployment_cleanup_instances();\n\n  if (simgrid::smpi::colls::smpi_coll_cleanup_callback != nullptr)\n    simgrid::smpi::colls::smpi_coll_cleanup_callback();\n\n  MPI_COMM_WORLD = MPI_COMM_NULL;\n\n  if (not MC_is_active()) {\n    xbt_os_timer_free(global_timer);\n  }\n\n  if (smpi_cfg_privatization() == SmpiPrivStrategies::MMAP)\n    smpi_destroy_global_memory_segments();\n  if (simgrid::smpi::F2C::lookup() != nullptr)\n    simgrid::smpi::F2C::delete_lookup();\n}\n\nvoid smpi_mpi_init() {\n  smpi_init_fortran_types();\n  if(smpi_init_sleep > 0)\n    simgrid::s4u::this_actor::sleep_for(smpi_init_sleep);\n}\n\nvoid SMPI_thread_create() {\n  TRACE_smpi_init(simgrid::s4u::this_actor::get_pid(), __func__);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/.git/objects/pack/pack-7425f7583187787cc0d723a82f605cceea73c235.idx",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/.git/objects/pack/pack-7425f7583187787cc0d723a82f605cceea73c235.pack",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/tuto_s4u/img/Rscript-screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/tuto_s4u/img/vite-screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/tuto_s4u/img/result.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/img/smpi_simgrid_alltoall_pair_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/img/smpi_simgrid_alltoall_ring_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/img/zone_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/img/eclipseScreenShot.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/img/extlink.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/tuto_smpi/3hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/docs/source/tuto_smpi/img/lu.S.4.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/output.goal.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/SGicon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/eclipseScreenShot.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/SGicon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/SGicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/awstats_logo3.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/poster_thumbnail.png",
        "/tmp/vanessa/spack-stage/spack-stage-simgrid-git-hvh7hm26fuqxfx4ottnhkgshkz2gm6yf/spack-src/doc/webcruft/simgrid_logo_2011_small.png"
    ],
    "total_files": 2772
}