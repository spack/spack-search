{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-guacamole-server-1.1.0-qd7udpqtvcfphcro5dzdzof4h6hykblt/spack-src/src/libguac/client.c": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n#include \"config.h\"\n\n#include \"encode-jpeg.h\"\n#include \"encode-png.h\"\n#include \"encode-webp.h\"\n#include \"guacamole/client.h\"\n#include \"guacamole/error.h\"\n#include \"guacamole/layer.h\"\n#include \"guacamole/plugin.h\"\n#include \"guacamole/pool.h\"\n#include \"guacamole/protocol.h\"\n#include \"guacamole/socket.h\"\n#include \"guacamole/stream.h\"\n#include \"guacamole/string.h\"\n#include \"guacamole/timestamp.h\"\n#include \"guacamole/user.h\"\n#include \"id.h\"\n\n#include <dlfcn.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Empty NULL-terminated array of argument names.\n */\nconst char* __GUAC_CLIENT_NO_ARGS[] = { NULL };\n\nguac_layer __GUAC_DEFAULT_LAYER = {\n    .index = 0\n};\n\nconst guac_layer* GUAC_DEFAULT_LAYER = &__GUAC_DEFAULT_LAYER;\n\nguac_layer* guac_client_alloc_layer(guac_client* client) {\n\n    /* Init new layer */\n    guac_layer* allocd_layer = malloc(sizeof(guac_layer));\n    allocd_layer->index = guac_pool_next_int(client->__layer_pool)+1;\n\n    return allocd_layer;\n\n}\n\nguac_layer* guac_client_alloc_buffer(guac_client* client) {\n\n    /* Init new layer */\n    guac_layer* allocd_layer = malloc(sizeof(guac_layer));\n    allocd_layer->index = -guac_pool_next_int(client->__buffer_pool) - 1;\n\n    return allocd_layer;\n\n}\n\nvoid guac_client_free_buffer(guac_client* client, guac_layer* layer) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__buffer_pool, -layer->index - 1);\n\n    /* Free layer */\n    free(layer);\n\n}\n\nvoid guac_client_free_layer(guac_client* client, guac_layer* layer) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__layer_pool, layer->index);\n\n    /* Free layer */\n    free(layer);\n\n}\n\nguac_stream* guac_client_alloc_stream(guac_client* client) {\n\n    guac_stream* allocd_stream;\n    int stream_index;\n\n    /* Refuse to allocate beyond maximum */\n    if (client->__stream_pool->active == GUAC_CLIENT_MAX_STREAMS)\n        return NULL;\n\n    /* Allocate stream */\n    stream_index = guac_pool_next_int(client->__stream_pool);\n\n    /* Initialize stream with odd index (even indices are user-level) */\n    allocd_stream = &(client->__output_streams[stream_index]);\n    allocd_stream->index = (stream_index * 2) + 1;\n    allocd_stream->data = NULL;\n    allocd_stream->ack_handler = NULL;\n    allocd_stream->blob_handler = NULL;\n    allocd_stream->end_handler = NULL;\n\n    return allocd_stream;\n\n}\n\nvoid guac_client_free_stream(guac_client* client, guac_stream* stream) {\n\n    /* Release index to pool */\n    guac_pool_free_int(client->__stream_pool, (stream->index - 1) / 2);\n\n    /* Mark stream as closed */\n    stream->index = GUAC_CLIENT_CLOSED_STREAM_INDEX;\n\n}\n\nguac_client* guac_client_alloc() {\n\n    int i;\n    pthread_rwlockattr_t lock_attributes;\n\n    /* Allocate new client */\n    guac_client* client = malloc(sizeof(guac_client));\n    if (client == NULL) {\n        guac_error = GUAC_STATUS_NO_MEMORY;\n        guac_error_message = \"Could not allocate memory for client\";\n        return NULL;\n    }\n\n    /* Init new client */\n    memset(client, 0, sizeof(guac_client));\n\n    client->args = __GUAC_CLIENT_NO_ARGS;\n    client->state = GUAC_CLIENT_RUNNING;\n    client->last_sent_timestamp = guac_timestamp_current();\n\n    /* Generate ID */\n    client->connection_id = guac_generate_id(GUAC_CLIENT_ID_PREFIX);\n    if (client->connection_id == NULL) {\n        free(client);\n        return NULL;\n    }\n\n    /* Allocate buffer and layer pools */\n    client->__buffer_pool = guac_pool_alloc(GUAC_BUFFER_POOL_INITIAL_SIZE);\n    client->__layer_pool = guac_pool_alloc(GUAC_BUFFER_POOL_INITIAL_SIZE);\n\n    /* Allocate stream pool */\n    client->__stream_pool = guac_pool_alloc(0);\n\n    /* Initialize streams */\n    client->__output_streams = malloc(sizeof(guac_stream) * GUAC_CLIENT_MAX_STREAMS);\n\n    for (i=0; i<GUAC_CLIENT_MAX_STREAMS; i++) {\n        client->__output_streams[i].index = GUAC_CLIENT_CLOSED_STREAM_INDEX;\n    }\n\n\n    /* Init locks */\n    pthread_rwlockattr_init(&lock_attributes);\n    pthread_rwlockattr_setpshared(&lock_attributes, PTHREAD_PROCESS_SHARED);\n\n    pthread_rwlock_init(&(client->__users_lock), &lock_attributes);\n\n    /* Set up socket to broadcast to all users */\n    client->socket = guac_socket_broadcast(client);\n\n    return client;\n\n}\n\nvoid guac_client_free(guac_client* client) {\n\n    /* Remove all users */\n    while (client->__users != NULL)\n        guac_client_remove_user(client, client->__users);\n\n    if (client->free_handler) {\n\n        /* FIXME: Errors currently ignored... */\n        client->free_handler(client);\n\n    }\n\n    /* Free socket */\n    guac_socket_free(client->socket);\n\n    /* Free layer pools */\n    guac_pool_free(client->__buffer_pool);\n    guac_pool_free(client->__layer_pool);\n\n    /* Free streams */\n    free(client->__output_streams);\n\n    /* Free stream pool */\n    guac_pool_free(client->__stream_pool);\n\n    /* Close associated plugin */\n    if (client->__plugin_handle != NULL) {\n        if (dlclose(client->__plugin_handle))\n            guac_client_log(client, GUAC_LOG_ERROR, \"Unable to close plugin: %s\", dlerror());\n    }\n\n    pthread_rwlock_destroy(&(client->__users_lock));\n    free(client->connection_id);\n    free(client);\n}\n\nvoid vguac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, va_list ap) {\n\n    /* Call handler if defined */\n    if (client->log_handler != NULL)\n        client->log_handler(client, level, format, ap);\n\n}\n\nvoid guac_client_log(guac_client* client, guac_client_log_level level,\n        const char* format, ...) {\n\n    va_list args;\n    va_start(args, format);\n\n    vguac_client_log(client, level, format, args);\n\n    va_end(args);\n\n}\n\nvoid guac_client_stop(guac_client* client) {\n    client->state = GUAC_CLIENT_STOPPING;\n}\n\nvoid vguac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, va_list ap) {\n\n    /* Only relevant if client is running */\n    if (client->state == GUAC_CLIENT_RUNNING) {\n\n        /* Log detail of error */\n        vguac_client_log(client, GUAC_LOG_ERROR, format, ap);\n\n        /* Send error immediately, limit information given */\n        guac_protocol_send_error(client->socket, \"Aborted. See logs.\", status);\n        guac_socket_flush(client->socket);\n\n        /* Stop client */\n        guac_client_stop(client);\n\n    }\n\n}\n\nvoid guac_client_abort(guac_client* client, guac_protocol_status status,\n        const char* format, ...) {\n\n    va_list args;\n    va_start(args, format);\n\n    vguac_client_abort(client, status, format, args);\n\n    va_end(args);\n\n}\n\nint guac_client_add_user(guac_client* client, guac_user* user, int argc, char** argv) {\n\n    int retval = 0;\n\n    /* Call handler, if defined */\n    if (client->join_handler)\n        retval = client->join_handler(user, argc, argv);\n\n    pthread_rwlock_wrlock(&(client->__users_lock));\n\n    /* Add to list if join was successful */\n    if (retval == 0) {\n\n        user->__prev = NULL;\n        user->__next = client->__users;\n\n        if (client->__users != NULL)\n            client->__users->__prev = user;\n\n        client->__users = user;\n        client->connected_users++;\n\n        /* Update owner pointer if user is owner */\n        if (user->owner)\n            client->__owner = user;\n\n    }\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    return retval;\n\n}\n\nvoid guac_client_remove_user(guac_client* client, guac_user* user) {\n\n    pthread_rwlock_wrlock(&(client->__users_lock));\n\n    /* Update prev / head */\n    if (user->__prev != NULL)\n        user->__prev->__next = user->__next;\n    else\n        client->__users = user->__next;\n\n    /* Update next */\n    if (user->__next != NULL)\n        user->__next->__prev = user->__prev;\n\n    client->connected_users--;\n\n    /* Update owner pointer if user was owner */\n    if (user->owner)\n        client->__owner = NULL;\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Call handler, if defined */\n    if (user->leave_handler)\n        user->leave_handler(user);\n    else if (client->leave_handler)\n        client->leave_handler(user);\n\n}\n\nvoid guac_client_foreach_user(guac_client* client, guac_user_callback* callback, void* data) {\n\n    guac_user* current;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Call function on each user */\n    current = client->__users;\n    while (current != NULL) {\n        callback(current, data);\n        current = current->__next;\n    }\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n}\n\nvoid* guac_client_for_owner(guac_client* client, guac_user_callback* callback,\n        void* data) {\n\n    void* retval;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Invoke callback with current owner */\n    retval = callback(client->__owner, data);\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Return value from callback */\n    return retval;\n\n}\n\nvoid* guac_client_for_user(guac_client* client, guac_user* user,\n        guac_user_callback* callback, void* data) {\n\n    guac_user* current;\n\n    int user_valid = 0;\n    void* retval;\n\n    pthread_rwlock_rdlock(&(client->__users_lock));\n\n    /* Loop through all users, searching for a pointer to the given user */\n    current = client->__users;\n    while (current != NULL) {\n\n        /* If the user's pointer exists in the list, they are indeed valid */\n        if (current == user) {\n            user_valid = 1;\n            break;\n        }\n\n        current = current->__next;\n    }\n\n    /* Use NULL if user does not actually exist */\n    if (!user_valid)\n        user = NULL;\n\n    /* Invoke callback with requested user (if they exist) */\n    retval = callback(user, data);\n\n    pthread_rwlock_unlock(&(client->__users_lock));\n\n    /* Return value from callback */\n    return retval;\n\n}\n\nint guac_client_end_frame(guac_client* client) {\n\n    /* Update and send timestamp */\n    client->last_sent_timestamp = guac_timestamp_current();\n\n    /* Log received timestamp and calculated lag (at TRACE level only) */\n    guac_client_log(client, GUAC_LOG_TRACE, \"Server completed \"\n            \"frame %\" PRIu64 \"ms.\", client->last_sent_timestamp);\n\n    return guac_protocol_send_sync(client->socket, client->last_sent_timestamp);\n\n}\n\nint guac_client_load_plugin(guac_client* client, const char* protocol) {\n\n    /* Reference to dlopen()'d plugin */\n    void* client_plugin_handle;\n\n    /* Pluggable client */\n    char protocol_lib[GUAC_PROTOCOL_LIBRARY_LIMIT] =\n        GUAC_PROTOCOL_LIBRARY_PREFIX;\n\n    /* Type-pun for the sake of dlsym() - cannot typecast a void* to a function\n     * pointer otherwise */ \n    union {\n        guac_client_init_handler* client_init;\n        void* obj;\n    } alias;\n\n    /* Add protocol and .so suffix to protocol_lib */\n    guac_strlcat(protocol_lib, protocol, sizeof(protocol_lib));\n    if (guac_strlcat(protocol_lib, GUAC_PROTOCOL_LIBRARY_SUFFIX,\n                sizeof(protocol_lib)) >= sizeof(protocol_lib)) {\n        guac_error = GUAC_STATUS_NO_MEMORY;\n        guac_error_message = \"Protocol name is too long\";\n        return -1;\n    }\n\n    /* Load client plugin */\n    client_plugin_handle = dlopen(protocol_lib, RTLD_LAZY);\n    if (!client_plugin_handle) {\n        guac_error = GUAC_STATUS_NOT_FOUND;\n        guac_error_message = dlerror();\n        return -1;\n    }\n\n    dlerror(); /* Clear errors */\n\n    /* Get init function */\n    alias.obj = dlsym(client_plugin_handle, \"guac_client_init\");\n\n    /* Fail if cannot find guac_client_init */\n    if (dlerror() != NULL) {\n        guac_error = GUAC_STATUS_INTERNAL_ERROR;\n        guac_error_message = dlerror();\n        dlclose(client_plugin_handle);\n        return -1;\n    }\n\n    /* Init client */\n    client->__plugin_handle = client_plugin_handle;\n\n    return alias.client_init(client);\n\n}\n\n/**\n * Updates the provided approximate processing lag, taking into account the\n * processing lag of the given user.\n *\n * @param user\n *     The guac_user to use to update the approximate processing lag.\n *\n * @param data\n *     Pointer to an int containing the current approximate processing lag.\n *     The int will be updated according to the processing lag of the given\n *     user.\n *\n * @return\n *     Always NULL.\n */\nstatic void* __calculate_lag(guac_user* user, void* data) {\n\n    int* processing_lag = (int*) data;\n\n    /* Simply find maximum */\n    if (user->processing_lag > *processing_lag)\n        *processing_lag = user->processing_lag;\n\n    return NULL;\n\n}\n\nint guac_client_get_processing_lag(guac_client* client) {\n\n    int processing_lag = 0;\n\n    /* Approximate the processing lag of all users */\n    guac_client_foreach_user(client, __calculate_lag, &processing_lag);\n\n    return processing_lag;\n\n}\n\nvoid guac_client_stream_argv(guac_client* client, guac_socket* socket,\n        const char* mimetype, const char* name, const char* value) {\n\n    /* Allocate new stream for argument value */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing connection parameter data */\n    guac_protocol_send_argv(socket, stream, mimetype, name);\n\n    /* Write parameter data */\n    guac_protocol_send_blobs(socket, stream, value, strlen(value));\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_png(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface) {\n\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/png\", x, y);\n\n    /* Write PNG data */\n    guac_png_write(socket, stream, surface);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_jpeg(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality) {\n\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/jpeg\", x, y);\n\n    /* Write JPEG data */\n    guac_jpeg_write(socket, stream, surface, quality);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n\n}\n\nvoid guac_client_stream_webp(guac_client* client, guac_socket* socket,\n        guac_composite_mode mode, const guac_layer* layer, int x, int y,\n        cairo_surface_t* surface, int quality, int lossless) {\n\n#ifdef ENABLE_WEBP\n    /* Allocate new stream for image */\n    guac_stream* stream = guac_client_alloc_stream(client);\n\n    /* Declare stream as containing image data */\n    guac_protocol_send_img(socket, stream, mode, layer, \"image/webp\", x, y);\n\n    /* Write WebP data */\n    guac_webp_write(socket, stream, surface, quality, lossless);\n\n    /* Terminate stream */\n    guac_protocol_send_end(socket, stream);\n\n    /* Free allocated stream */\n    guac_client_free_stream(client, stream);\n#else\n    /* Do nothing if WebP support is not built in */\n#endif\n\n}\n\n#ifdef ENABLE_WEBP\n/**\n * Callback which is invoked by guac_client_supports_webp() for each user\n * associated with the given client, thus updating an overall support flag\n * describing the WebP support state for the client as a whole.\n *\n * @param user\n *     The user to check for WebP support.\n *\n * @param data\n *     Pointer to an int containing the current WebP support status for the\n *     client associated with the given user. This flag will be 0 if any user\n *     already checked has lacked WebP support, or 1 otherwise.\n *\n * @return\n *     Always NULL.\n */\nstatic void* __webp_support_callback(guac_user* user, void* data) {\n\n    int* webp_supported = (int*) data;\n\n    /* Check whether current user supports WebP */\n    if (*webp_supported)\n        *webp_supported = guac_user_supports_webp(user);\n\n    return NULL;\n\n}\n#endif\n\nint guac_client_supports_webp(guac_client* client) {\n\n#ifdef ENABLE_WEBP\n    int webp_supported = 1;\n\n    /* WebP is supported for entire client only if each user supports it */\n    guac_client_foreach_user(client, __webp_support_callback, &webp_supported);\n\n    return webp_supported;\n#else\n    /* Support for WebP is completely absent */\n    return 0;\n#endif\n\n}\n\n"
    },
    "skipped": [],
    "total_files": 490
}