{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/main/src/rootcling.cxx": "// Authors: Axel Naumann, Philippe Canal, Danilo Piparo\n\n/*************************************************************************\n * Copyright (C) 1995-2016, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n#include \"rootclingTCling.h\"\n#include \"rootclingIO.h\"\n#include \"rootcling_impl.h\"\n#include \"RConfigure.h\"\n#include <ROOT/RConfig.h>\n#include \"TSystem.h\"\n\nextern \"C\" {\n   R__DLLEXPORT void usedToIdentifyRootClingByDlSym() {}\n}\n\n// force compiler to emit symbol for function above\nstatic void (*dlsymaddr)() = &usedToIdentifyRootClingByDlSym;\n\nint main(int argc, char **argv)\n{\n   (void) dlsymaddr; // avoid unused variable warning\n\n   ROOT::Internal::RootCling::DriverConfig config{};\n\n   config.fBuildingROOTStage1 = false;\n   config.fPRootDir = &gRootDir;\n   config.fTROOT__GetExtraInterpreterArgs = &TROOT__GetExtraInterpreterArgs;\n   config.fTROOT__GetIncludeDir = &TROOT__GetIncludeDir;\n   config.fTROOT__GetEtcDir = &TROOT__GetEtcDir;\n   config.fTCling__GetInterpreter = &TCling__GetInterpreter;\n   config.fInitializeStreamerInfoROOTFile = &InitializeStreamerInfoROOTFile;\n   config.fAddStreamerInfoToROOTFile = &AddStreamerInfoToROOTFile;\n   config.fAddTypedefToROOTFile = &AddTypedefToROOTFile;\n   config.fAddEnumToROOTFile = &AddEnumToROOTFile;\n   config.fAddAncestorPCMROOTFile = &AddAncestorPCMROOTFile;\n   config.fCloseStreamerInfoROOTFile = &CloseStreamerInfoROOTFile;\n\n   return ROOT_rootcling_Driver(argc, argv, config);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/Fuzzer/FuzzerExtFunctionsDlsym.cpp": "//===- FuzzerExtFunctionsDlsym.cpp - Interface to external functions ------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n// Implementation for operating systems that support dlsym(). We only use it on\n// Apple platforms for now. We don't use this approach on Linux because it\n// requires that clients of LibFuzzer pass ``--export-dynamic`` to the linker.\n// That is a complication we don't wish to expose to clients right now.\n//===----------------------------------------------------------------------===//\n#include \"FuzzerDefs.h\"\n#if LIBFUZZER_APPLE\n\n#include \"FuzzerExtFunctions.h\"\n#include \"FuzzerIO.h\"\n#include <dlfcn.h>\n\nusing namespace fuzzer;\n\ntemplate <typename T>\nstatic T GetFnPtr(const char *FnName, bool WarnIfMissing) {\n  dlerror(); // Clear any previous errors.\n  void *Fn = dlsym(RTLD_DEFAULT, FnName);\n  if (Fn == nullptr) {\n    if (WarnIfMissing) {\n      const char *ErrorMsg = dlerror();\n      Printf(\"WARNING: Failed to find function \\\"%s\\\".\", FnName);\n      if (ErrorMsg)\n        Printf(\" Reason %s.\", ErrorMsg);\n      Printf(\"\\n\");\n    }\n  }\n  return reinterpret_cast<T>(Fn);\n}\n\nnamespace fuzzer {\n\nExternalFunctions::ExternalFunctions() {\n#define EXT_FUNC(NAME, RETURN_TYPE, FUNC_SIG, WARN)                            \\\n  this->NAME = GetFnPtr<decltype(ExternalFunctions::NAME)>(#NAME, WARN)\n\n#include \"FuzzerExtFunctions.def\"\n\n#undef EXT_FUNC\n}\n\n} // namespace fuzzer\n\n#endif // LIBFUZZER_APPLE\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c": "/*===-- jitprofiling.c - JIT (Just-In-Time) Profiling API----------*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API implementation. \n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#include \"ittnotify_config.h\"\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\n#pragma optimize(\"\", off)\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdint.h>\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <malloc.h>\n#include <stdlib.h>\n\n#include \"jitprofiling.h\"\n\nstatic const char rcsid[] = \"\\n@(#) $Revision: 243501 $\\n\";\n\n#define DLL_ENVIRONMENT_VAR             \"VS_PROFILER\"\n\n#ifndef NEW_DLL_ENVIRONMENT_VAR\n#if ITT_ARCH==ITT_ARCH_IA32\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER32\"\n#else\n#define NEW_DLL_ENVIRONMENT_VAR\t        \"INTEL_JIT_PROFILER64\"\n#endif\n#endif /* NEW_DLL_ENVIRONMENT_VAR */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define DEFAULT_DLLNAME                 \"JitPI.dll\"\nHINSTANCE m_libHandle = NULL;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define DEFAULT_DLLNAME                 \"libJitPI.so\"\nvoid* m_libHandle = NULL;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/* default location of JIT profiling agent on Android */\n#define ANDROID_JIT_AGENT_PATH  \"/data/intel/libittnotify.so\"\n\n/* the function pointers */\ntypedef unsigned int(*TPInitialize)(void);\nstatic TPInitialize FUNC_Initialize=NULL;\n\ntypedef unsigned int(*TPNotify)(unsigned int, void*);\nstatic TPNotify FUNC_NotifyEvent=NULL;\n\nstatic iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;\n\n/* end collector dll part. */\n\n/* loadiJIT_Funcs() : this function is called just in the beginning \n *  and is responsible to load the functions from BistroJavaCollector.dll\n * result:\n *  on success: the functions loads, iJIT_DLL_is_missing=0, return value = 1\n *  on failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0\n */ \nstatic int loadiJIT_Funcs(void);\n\n/* global representing whether the BistroJavaCollector can't be loaded */\nstatic int iJIT_DLL_is_missing = 0;\n\n/* Virtual stack - the struct is used as a virtual stack for each thread.\n * Every thread initializes with a stack of size INIT_TOP_STACK.\n * Every method entry decreases from the current stack point,\n * and when a thread stack reaches its top of stack (return from the global \n * function), the top of stack and the current stack increase. Notice that \n * when returning from a function the stack pointer is the address of \n * the function return.\n*/\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\nstatic DWORD threadLocalStorageHandle = 0;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nstatic pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#define INIT_TOP_Stack 10000\n\ntypedef struct \n{\n    unsigned int TopStack;\n    unsigned int CurrentStack;\n} ThreadStack, *pThreadStack;\n\n/* end of virtual stack. */\n\n/*\n * The function for reporting virtual-machine related events to VTune.\n * Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill \n * in the stack_id field in the iJIT_Method_NIDS structure, as VTune fills it.\n * The return value in iJVM_EVENT_TYPE_ENTER_NIDS && \n * iJVM_EVENT_TYPE_LEAVE_NIDS events will be 0 in case of failure.\n * in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event \n * it will be -1 if EventSpecificData == 0 otherwise it will be 0.\n*/\n\nITT_EXTERN_C int JITAPI \niJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)\n{\n    int ReturnValue;\n\n    /*\n     * This section is for debugging outside of VTune. \n     * It creates the environment variables that indicates call graph mode.\n     * If running outside of VTune remove the remark.\n     *\n     *\n     * static int firstTime = 1;\n     * char DoCallGraph[12] = \"DoCallGraph\";\n     * if (firstTime)\n     * {\n     * firstTime = 0;\n     * SetEnvironmentVariable( \"BISTRO_COLLECTORS_DO_CALLGRAPH\", DoCallGraph);\n     * }\n     *\n     * end of section.\n    */\n\n    /* initialization part - the functions have not been loaded yet. This part\n     *        will load the functions, and check if we are in Call Graph mode. \n     *        (for special treatment).\n     */\n    if (!FUNC_NotifyEvent) \n    {\n        if (iJIT_DLL_is_missing) \n            return 0;\n\n        /* load the Function from the DLL */\n        if (!loadiJIT_Funcs()) \n            return 0;\n\n        /* Call Graph initialization. */\n    }\n\n    /* If the event is method entry/exit, check that in the current mode \n     * VTune is allowed to receive it\n     */\n    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS || \n         event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&\n        (executionMode != iJIT_CALLGRAPH_ON))\n    {\n        return 0;\n    }\n    /* This section is performed when method enter event occurs.\n     * It updates the virtual stack, or creates it if this is the first \n     * method entry in the thread. The stack pointer is decreased.\n     */\n    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* initialize the stack. */\n            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);\n            threadStack->TopStack = INIT_TOP_Stack;\n            threadStack->CurrentStack = INIT_TOP_Stack;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n\n        /* decrease the stack. */\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            (threadStack->CurrentStack)--;\n    }\n\n    /* This section is performed when method leave event occurs\n     * It updates the virtual stack.\n     *    Increases the stack pointer.\n     *    If the stack pointer reached the top (left the global function)\n     *        increase the pointer and the top pointer.\n     */\n    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n           (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* Error: first report in this thread is method exit */\n            exit (1);\n        }\n\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n            ++(threadStack->CurrentStack) + 1;\n\n        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id \n               > threadStack->TopStack)\n            ((piJIT_Method_NIDS) EventSpecificData)->stack_id = \n                (unsigned int)-1;\n    }\n\n    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)\n    {\n        /* check for use of reserved method IDs */\n        if ( ((piJIT_Method_Load) EventSpecificData)->method_id <= 999 )\n            return 0;\n    }\n\n    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);   \n\n    return ReturnValue;\n}\n\n/* The new mode call back routine */\nITT_EXTERN_C void JITAPI \niJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx \n                        NewModeCallBackFuncEx) \n{\n    /* is it already missing... or the load of functions from the DLL failed */\n    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())\n    {\n        /* then do not bother with notifications */\n        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);  \n        /* Error: could not load JIT functions. */\n        return;\n    }\n    /* nothing to do with the callback */\n}\n\n/*\n * This function allows the user to query in which mode, if at all, \n *VTune is running\n */\nITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()\n{\n    if (!iJIT_DLL_is_missing)\n    {\n        loadiJIT_Funcs();\n    }\n\n    return executionMode;\n}\n\n/* this function loads the collector dll (BistroJavaCollector) \n * and the relevant functions.\n * on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1\n * on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0\n */ \nstatic int loadiJIT_Funcs()\n{\n    static int bDllWasLoaded = 0;\n    char *dllName = (char*)rcsid; /* !! Just to avoid unused code elimination */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    DWORD dNameLength = 0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if(bDllWasLoaded)\n    {\n        /* dll was already loaded, no need to do it for the second time */\n        return 1;\n    }\n\n    /* Assumes that the DLL will not be found */\n    iJIT_DLL_is_missing = 1;\n    FUNC_NotifyEvent = NULL;\n\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    /* Try to get the dll name from the environment */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);\n    if (dNameLength)\n    {\n        DWORD envret = 0;\n        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, \n                                         dllName, dNameLength);\n        if (envret)\n        {\n            /* Try to load the dll from the PATH... */\n            m_libHandle = LoadLibraryExA(dllName, \n                                         NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n        }\n        free(dllName);\n    } else {\n        /* Try to use old VS_PROFILER variable */\n        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);\n        if (dNameLength)\n        {\n            DWORD envret = 0;\n            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, \n                                             dllName, dNameLength);\n            if (envret)\n            {\n                /* Try to load the dll from the PATH... */\n                m_libHandle = LoadLibraryA(dllName);\n            }\n            free(dllName);\n        }\n    }\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);\n    if (!dllName)\n        dllName = getenv(DLL_ENVIRONMENT_VAR);\n#ifdef ANDROID\n    if (!dllName)\n        dllName = ANDROID_JIT_AGENT_PATH;\n#endif\n    if (dllName)\n    {\n        /* Try to load the dll from the PATH... */\n        m_libHandle = dlopen(dllName, RTLD_LAZY);\n    }\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if (!m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    /* if the dll wasn't loaded - exit. */\n    if (!m_libHandle)\n    {\n        iJIT_DLL_is_missing = 1; /* don't try to initialize \n                                  * JIT agent the second time \n                                  */\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, \"NotifyEvent\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_NotifyEvent = (TPNotify)(intptr_t)dlsym(m_libHandle, \"NotifyEvent\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_NotifyEvent) \n    {\n        FUNC_Initialize = NULL;\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, \"Initialize\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_Initialize = (TPInitialize)(intptr_t)dlsym(m_libHandle, \"Initialize\");\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_Initialize) \n    {\n        FUNC_NotifyEvent = NULL;\n        return 0;\n    }\n\n    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();\n\n    bDllWasLoaded = 1;\n    iJIT_DLL_is_missing = 0; /* DLL is ok. */\n\n    /*\n     * Call Graph mode: init the thread local storage\n     * (need to store the virtual stack there).\n     */\n    if ( executionMode == iJIT_CALLGRAPH_ON )\n    {\n        /* Allocate a thread local storage slot for the thread \"stack\" */\n        if (!threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            threadLocalStorageHandle = TlsAlloc();\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pthread_key_create(&threadLocalStorageHandle, NULL);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    return 1;\n}\n\n/*\n * This function should be called by the user whenever a thread ends, \n * to free the thread \"virtual stack\" storage\n */\nITT_EXTERN_C void JITAPI FinalizeThread()\n{\n    if (threadLocalStorageHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = \n            (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = \n            (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        if (threadStack)\n        {\n            free (threadStack);\n            threadStack = NULL;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue (threadLocalStorageHandle, threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle, threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n    }\n}\n\n/*\n * This function should be called by the user when the process ends, \n * to free the local storage index\n*/\nITT_EXTERN_C void JITAPI FinalizeProcess()\n{\n    if (m_libHandle) \n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    if (threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        TlsFree (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    pthread_key_delete(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n}\n\n/*\n * This function should be called by the user for any method once.\n * The function will return a unique method ID, the user should maintain \n * the ID for each method\n */\nITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()\n{\n    static unsigned int methodID = 0x100000;\n\n    if (methodID == 0)\n        return 0;  /* ERROR : this is not a valid value */\n\n    return methodID++;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/ExecutionEngine/IntelJITEvents/ittnotify_config.h": "/*===-- ittnotify_config.h - JIT Profiling API internal config-----*- C -*-===*\n *\n *                     The LLVM Compiler Infrastructure\n *\n * This file is distributed under the University of Illinois Open Source\n * License. See LICENSE.TXT for details.\n *\n *===----------------------------------------------------------------------===*\n *\n * This file provides Intel(R) Performance Analyzer JIT (Just-In-Time) \n * Profiling API internal config.\n *\n * NOTE: This file comes in a style different from the rest of LLVM\n * source base since  this is a piece of code shared from Intel(R)\n * products.  Please do not reformat / re-style this code to make\n * subsequent merges and contributions from the original source base eaiser.\n *\n *===----------------------------------------------------------------------===*/\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif /* _WIN32 */\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define CDECL /* not actual on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define CDECL __attribute__ ((cdecl))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define STDCALL /* not supported on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define STDCALL __attribute__ ((stdcall))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#endif /* __STRICT_ANSI__ */\n#define ITT_INLINE_ATTRIBUTE __attribute__ ((always_inline))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_IA64\n#  define ITT_ARCH_IA64  3\n#endif /* ITT_ARCH_IA64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64\n#    define ITT_ARCH ITT_ARCH_IA64\n#  else\n#    define ITT_ARCH ITT_ARCH_IA32\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#else\n#  define ITT_EXTERN_C /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrlen(s)          lstrlenA(s)\n#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n#define __itt_fstrlen(s)          strlen(s)\n#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA64 */\n#endif /* __INTEL_COMPILER */\n#else /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(long*)ptr)\n                          : \"0\"(addend), \"m\"(*(long*)ptr)\n                          : \"memory\");\n    return result;\n}\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long \n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/ExecutionEngine/MCJIT/MCJIT.h": "//===-- MCJIT.h - Class definition for the MCJIT ----------------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_EXECUTIONENGINE_MCJIT_MCJIT_H\n#define LLVM_LIB_EXECUTIONENGINE_MCJIT_MCJIT_H\n\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n#include \"llvm/ExecutionEngine/ObjectCache.h\"\n#include \"llvm/ExecutionEngine/ObjectMemoryBuffer.h\"\n#include \"llvm/ExecutionEngine/RTDyldMemoryManager.h\"\n#include \"llvm/ExecutionEngine/RuntimeDyld.h\"\n#include \"llvm/IR/Module.h\"\n\nnamespace llvm {\nclass MCJIT;\n\n// This is a helper class that the MCJIT execution engine uses for linking\n// functions across modules that it owns.  It aggregates the memory manager\n// that is passed in to the MCJIT constructor and defers most functionality\n// to that object.\nclass LinkingSymbolResolver : public JITSymbolResolver {\npublic:\n  LinkingSymbolResolver(MCJIT &Parent,\n                        std::shared_ptr<JITSymbolResolver> Resolver)\n    : ParentEngine(Parent), ClientResolver(std::move(Resolver)) {}\n\n  JITSymbol findSymbol(const std::string &Name) override;\n\n  // MCJIT doesn't support logical dylibs.\n  JITSymbol findSymbolInLogicalDylib(const std::string &Name) override {\n    return nullptr;\n  }\n\nprivate:\n  MCJIT &ParentEngine;\n  std::shared_ptr<JITSymbolResolver> ClientResolver;\n};\n\n// About Module states: added->loaded->finalized.\n//\n// The purpose of the \"added\" state is having modules in standby. (added=known\n// but not compiled). The idea is that you can add a module to provide function\n// definitions but if nothing in that module is referenced by a module in which\n// a function is executed (note the wording here because it's not exactly the\n// ideal case) then the module never gets compiled. This is sort of lazy\n// compilation.\n//\n// The purpose of the \"loaded\" state (loaded=compiled and required sections\n// copied into local memory but not yet ready for execution) is to have an\n// intermediate state wherein clients can remap the addresses of sections, using\n// MCJIT::mapSectionAddress, (in preparation for later copying to a new location\n// or an external process) before relocations and page permissions are applied.\n//\n// It might not be obvious at first glance, but the \"remote-mcjit\" case in the\n// lli tool does this.  In that case, the intermediate action is taken by the\n// RemoteMemoryManager in response to the notifyObjectLoaded function being\n// called.\n\nclass MCJIT : public ExecutionEngine {\n  MCJIT(std::unique_ptr<Module> M, std::unique_ptr<TargetMachine> tm,\n        std::shared_ptr<MCJITMemoryManager> MemMgr,\n        std::shared_ptr<JITSymbolResolver> Resolver);\n\n  typedef llvm::SmallPtrSet<Module *, 4> ModulePtrSet;\n\n  class OwningModuleContainer {\n  public:\n    OwningModuleContainer() {\n    }\n    ~OwningModuleContainer() {\n      freeModulePtrSet(AddedModules);\n      freeModulePtrSet(LoadedModules);\n      freeModulePtrSet(FinalizedModules);\n    }\n\n    ModulePtrSet::iterator begin_added() { return AddedModules.begin(); }\n    ModulePtrSet::iterator end_added() { return AddedModules.end(); }\n    iterator_range<ModulePtrSet::iterator> added() {\n      return make_range(begin_added(), end_added());\n    }\n\n    ModulePtrSet::iterator begin_loaded() { return LoadedModules.begin(); }\n    ModulePtrSet::iterator end_loaded() { return LoadedModules.end(); }\n\n    ModulePtrSet::iterator begin_finalized() { return FinalizedModules.begin(); }\n    ModulePtrSet::iterator end_finalized() { return FinalizedModules.end(); }\n\n    void addModule(std::unique_ptr<Module> M) {\n      AddedModules.insert(M.release());\n    }\n\n    bool removeModule(Module *M) {\n      return AddedModules.erase(M) || LoadedModules.erase(M) ||\n             FinalizedModules.erase(M);\n    }\n\n    bool hasModuleBeenAddedButNotLoaded(Module *M) {\n      return AddedModules.count(M) != 0;\n    }\n\n    bool hasModuleBeenLoaded(Module *M) {\n      // If the module is in either the \"loaded\" or \"finalized\" sections it\n      // has been loaded.\n      return (LoadedModules.count(M) != 0 ) || (FinalizedModules.count(M) != 0);\n    }\n\n    bool hasModuleBeenFinalized(Module *M) {\n      return FinalizedModules.count(M) != 0;\n    }\n\n    bool ownsModule(Module* M) {\n      return (AddedModules.count(M) != 0) || (LoadedModules.count(M) != 0) ||\n             (FinalizedModules.count(M) != 0);\n    }\n\n    void markModuleAsLoaded(Module *M) {\n      // This checks against logic errors in the MCJIT implementation.\n      // This function should never be called with either a Module that MCJIT\n      // does not own or a Module that has already been loaded and/or finalized.\n      assert(AddedModules.count(M) &&\n             \"markModuleAsLoaded: Module not found in AddedModules\");\n\n      // Remove the module from the \"Added\" set.\n      AddedModules.erase(M);\n\n      // Add the Module to the \"Loaded\" set.\n      LoadedModules.insert(M);\n    }\n\n    void markModuleAsFinalized(Module *M) {\n      // This checks against logic errors in the MCJIT implementation.\n      // This function should never be called with either a Module that MCJIT\n      // does not own, a Module that has not been loaded or a Module that has\n      // already been finalized.\n      assert(LoadedModules.count(M) &&\n             \"markModuleAsFinalized: Module not found in LoadedModules\");\n\n      // Remove the module from the \"Loaded\" section of the list.\n      LoadedModules.erase(M);\n\n      // Add the Module to the \"Finalized\" section of the list by inserting it\n      // before the 'end' iterator.\n      FinalizedModules.insert(M);\n    }\n\n    void markAllLoadedModulesAsFinalized() {\n      for (ModulePtrSet::iterator I = LoadedModules.begin(),\n                                  E = LoadedModules.end();\n           I != E; ++I) {\n        Module *M = *I;\n        FinalizedModules.insert(M);\n      }\n      LoadedModules.clear();\n    }\n\n  private:\n    ModulePtrSet AddedModules;\n    ModulePtrSet LoadedModules;\n    ModulePtrSet FinalizedModules;\n\n    void freeModulePtrSet(ModulePtrSet& MPS) {\n      // Go through the module set and delete everything.\n      for (ModulePtrSet::iterator I = MPS.begin(), E = MPS.end(); I != E; ++I) {\n        Module *M = *I;\n        delete M;\n      }\n      MPS.clear();\n    }\n  };\n\n  std::unique_ptr<TargetMachine> TM;\n  MCContext *Ctx;\n  std::shared_ptr<MCJITMemoryManager> MemMgr;\n  LinkingSymbolResolver Resolver;\n  RuntimeDyld Dyld;\n  std::vector<JITEventListener*> EventListeners;\n\n  OwningModuleContainer OwnedModules;\n\n  SmallVector<object::OwningBinary<object::Archive>, 2> Archives;\n  SmallVector<std::unique_ptr<MemoryBuffer>, 2> Buffers;\n\n  SmallVector<std::unique_ptr<object::ObjectFile>, 2> LoadedObjects;\n\n  // An optional ObjectCache to be notified of compiled objects and used to\n  // perform lookup of pre-compiled code to avoid re-compilation.\n  ObjectCache *ObjCache;\n\n  Function *FindFunctionNamedInModulePtrSet(StringRef FnName,\n                                            ModulePtrSet::iterator I,\n                                            ModulePtrSet::iterator E);\n\n  GlobalVariable *FindGlobalVariableNamedInModulePtrSet(StringRef Name,\n                                                        bool AllowInternal,\n                                                        ModulePtrSet::iterator I,\n                                                        ModulePtrSet::iterator E);\n\n  void runStaticConstructorsDestructorsInModulePtrSet(bool isDtors,\n                                                      ModulePtrSet::iterator I,\n                                                      ModulePtrSet::iterator E);\n\npublic:\n  ~MCJIT() override;\n\n  /// @name ExecutionEngine interface implementation\n  /// @{\n  void addModule(std::unique_ptr<Module> M) override;\n  void addObjectFile(std::unique_ptr<object::ObjectFile> O) override;\n  void addObjectFile(object::OwningBinary<object::ObjectFile> O) override;\n  void addArchive(object::OwningBinary<object::Archive> O) override;\n  bool removeModule(Module *M) override;\n\n  /// FindFunctionNamed - Search all of the active modules to find the function that\n  /// defines FnName.  This is very slow operation and shouldn't be used for\n  /// general code.\n  Function *FindFunctionNamed(StringRef FnName) override;\n\n  /// FindGlobalVariableNamed - Search all of the active modules to find the\n  /// global variable that defines Name.  This is very slow operation and\n  /// shouldn't be used for general code.\n  GlobalVariable *FindGlobalVariableNamed(StringRef Name,\n                                          bool AllowInternal = false) override;\n\n  /// Sets the object manager that MCJIT should use to avoid compilation.\n  void setObjectCache(ObjectCache *manager) override;\n\n  void setProcessAllSections(bool ProcessAllSections) override {\n    Dyld.setProcessAllSections(ProcessAllSections);\n  }\n\n  void generateCodeForModule(Module *M) override;\n\n  /// finalizeObject - ensure the module is fully processed and is usable.\n  ///\n  /// It is the user-level function for completing the process of making the\n  /// object usable for execution. It should be called after sections within an\n  /// object have been relocated using mapSectionAddress.  When this method is\n  /// called the MCJIT execution engine will reapply relocations for a loaded\n  /// object.\n  /// Is it OK to finalize a set of modules, add modules and finalize again.\n  // FIXME: Do we really need both of these?\n  void finalizeObject() override;\n  virtual void finalizeModule(Module *);\n  void finalizeLoadedModules();\n\n  /// runStaticConstructorsDestructors - This method is used to execute all of\n  /// the static constructors or destructors for a program.\n  ///\n  /// \\param isDtors - Run the destructors instead of constructors.\n  void runStaticConstructorsDestructors(bool isDtors) override;\n\n  void *getPointerToFunction(Function *F) override;\n\n  GenericValue runFunction(Function *F,\n                           ArrayRef<GenericValue> ArgValues) override;\n\n  /// getPointerToNamedFunction - This method returns the address of the\n  /// specified function by using the dlsym function call.  As such it is only\n  /// useful for resolving library symbols, not code generated symbols.\n  ///\n  /// If AbortOnFailure is false and no function with the given name is\n  /// found, this function silently returns a null pointer. Otherwise,\n  /// it prints a message to stderr and aborts.\n  ///\n  void *getPointerToNamedFunction(StringRef Name,\n                                  bool AbortOnFailure = true) override;\n\n  /// mapSectionAddress - map a section to its target address space value.\n  /// Map the address of a JIT section as returned from the memory manager\n  /// to the address in the target process as the running code will see it.\n  /// This is the address which will be used for relocation resolution.\n  void mapSectionAddress(const void *LocalAddress,\n                         uint64_t TargetAddress) override {\n    Dyld.mapSectionAddress(LocalAddress, TargetAddress);\n  }\n  void RegisterJITEventListener(JITEventListener *L) override;\n  void UnregisterJITEventListener(JITEventListener *L) override;\n\n  // If successful, these function will implicitly finalize all loaded objects.\n  // To get a function address within MCJIT without causing a finalize, use\n  // getSymbolAddress.\n  uint64_t getGlobalValueAddress(const std::string &Name) override;\n  uint64_t getFunctionAddress(const std::string &Name) override;\n\n  TargetMachine *getTargetMachine() override { return TM.get(); }\n\n  /// @}\n  /// @name (Private) Registration Interfaces\n  /// @{\n\n  static void Register() {\n    MCJITCtor = createJIT;\n  }\n\n  static ExecutionEngine*\n  createJIT(std::unique_ptr<Module> M,\n            std::string *ErrorStr,\n            std::shared_ptr<MCJITMemoryManager> MemMgr,\n            std::shared_ptr<JITSymbolResolver> Resolver,\n            std::unique_ptr<TargetMachine> TM);\n\n  // @}\n\n  // Takes a mangled name and returns the corresponding JITSymbol (if a\n  // definition of that mangled name has been added to the JIT).\n  JITSymbol findSymbol(const std::string &Name, bool CheckFunctionsOnly);\n\n  // DEPRECATED - Please use findSymbol instead.\n  //\n  // This is not directly exposed via the ExecutionEngine API, but it is\n  // used by the LinkingMemoryManager.\n  //\n  // getSymbolAddress takes an unmangled name and returns the corresponding\n  // JITSymbol if a definition of the name has been added to the JIT.\n  uint64_t getSymbolAddress(const std::string &Name,\n                            bool CheckFunctionsOnly);\n\nprotected:\n  /// emitObject -- Generate a JITed object in memory from the specified module\n  /// Currently, MCJIT only supports a single module and the module passed to\n  /// this function call is expected to be the contained module.  The module\n  /// is passed as a parameter here to prepare for multiple module support in\n  /// the future.\n  std::unique_ptr<MemoryBuffer> emitObject(Module *M);\n\n  void NotifyObjectEmitted(const object::ObjectFile& Obj,\n                           const RuntimeDyld::LoadedObjectInfo &L);\n  void NotifyFreeingObject(const object::ObjectFile& Obj);\n\n  JITSymbol findExistingSymbol(const std::string &Name);\n  Module *findModuleForSymbol(const std::string &Name, bool CheckFunctionsOnly);\n};\n\n} // end llvm namespace\n\n#endif // LLVM_LIB_EXECUTIONENGINE_MCJIT_MCJIT_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/Support/Windows/DynamicLibrary.inc": "//===- Win32/DynamicLibrary.cpp - Win32 DL Implementation -------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the Win32 specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"WindowsSupport.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <psapi.h>\n\n//===----------------------------------------------------------------------===//\n//=== WARNING: Implementation here must contain only Win32 specific code\n//===          and must not be UNIX code.\n//===----------------------------------------------------------------------===//\n\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  for (void *Handle : llvm::reverse(Handles))\n    FreeLibrary(HMODULE(Handle));\n\n  // 'Process' should not be released on Windows.\n  assert((!Process || Process==this) && \"Bad Handle\");\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  // Create the instance and return it to be the *Process* handle\n  // simillar to dlopen(NULL, RTLD_LAZY|RTLD_GLOBAL)\n  if (!File)\n    return &(*OpenedHandles);\n\n  SmallVector<wchar_t, MAX_PATH> FileUnicode;\n  if (std::error_code ec = windows::UTF8ToUTF16(File, FileUnicode)) {\n    SetLastError(ec.value());\n    MakeErrMsg(Err, std::string(File) + \": Can't convert to UTF-16\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  HMODULE Handle = LoadLibraryW(FileUnicode.data());\n  if (Handle == NULL) {\n    MakeErrMsg(Err, std::string(File) + \": Can't open\");\n    return &DynamicLibrary::Invalid;\n  }\n\n  return reinterpret_cast<void*>(Handle);\n}\n\nstatic DynamicLibrary::HandleSet *IsOpenedHandlesInstance(void *Handle) {\n  if (!OpenedHandles.isConstructed())\n    return nullptr;\n  DynamicLibrary::HandleSet &Inst = *OpenedHandles;\n  return Handle == &Inst ? &Inst : nullptr;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  if (HandleSet* HS = IsOpenedHandlesInstance(Handle))\n    HS->Process = nullptr; // Just drop the *Process* handle.\n  else\n    FreeLibrary((HMODULE)Handle);\n}\n\nstatic bool GetProcessModules(HANDLE H, DWORD &Bytes, HMODULE *Data = nullptr) {\n  // EnumProcessModules will fail on Windows 64 while some versions of\n  // MingW-32 don't have EnumProcessModulesEx.\n  if (\n#ifdef _WIN64\n      !EnumProcessModulesEx(H, Data, Bytes, &Bytes, LIST_MODULES_64BIT)\n#else\n      !EnumProcessModules(H, Data, Bytes, &Bytes)\n#endif\n     ) {\n    std::string Err;\n    if (MakeErrMsg(&Err, \"EnumProcessModules failure\"))\n      llvm::errs() << Err << \"\\n\";\n    return false;\n  }\n  return true;\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  HandleSet* HS = IsOpenedHandlesInstance(Handle);\n  if (!HS)\n    return (void *)uintptr_t(GetProcAddress((HMODULE)Handle, Symbol));\n\n  // Could have done a dlclose on the *Process* handle\n  if (!HS->Process)\n    return nullptr;\n\n  // Trials indicate EnumProcessModulesEx is consistantly faster than using\n  // EnumerateLoadedModules64 or CreateToolhelp32Snapshot.\n  //\n  // | Handles | DbgHelp.dll | CreateSnapshot | EnumProcessModulesEx\n  // |=========|=============|========================================\n  // | 37      | 0.0000585 * | 0.0003031      | 0.0000152\n  // | 1020    | 0.0026310 * | 0.0121598      | 0.0002683\n  // | 2084    | 0.0149418 * | 0.0369936      | 0.0005610\n  //\n  // * Not including the load time of Dbghelp.dll (~.005 sec)\n  //\n  // There's still a case to somehow cache the result of EnumProcessModulesEx\n  // across invocations, but the complication of doing that properly...\n  // Possibly using LdrRegisterDllNotification to invalidate the cache?\n\n  DWORD Bytes = 0;\n  HMODULE Self = HMODULE(GetCurrentProcess());\n  if (!GetProcessModules(Self, Bytes))\n    return nullptr;\n\n  // Get the most recent list in case any modules added/removed between calls\n  // to EnumProcessModulesEx that gets the amount of, then copies the HMODULES.\n  // MSDN is pretty clear that if the module list changes during the call to\n  // EnumProcessModulesEx the results should not be used.\n  std::vector<HMODULE> Handles;\n  do {\n    assert(Bytes && ((Bytes % sizeof(HMODULE)) == 0) &&\n           \"Should have at least one module and be aligned\");\n    Handles.resize(Bytes / sizeof(HMODULE));\n    if (!GetProcessModules(Self, Bytes, Handles.data()))\n      return nullptr;\n  } while (Bytes != (Handles.size() * sizeof(HMODULE)));\n\n  // Try EXE first, mirroring what dlsym(dlopen(NULL)) does.\n  if (FARPROC Ptr = GetProcAddress(HMODULE(Handles.front()), Symbol))\n    return (void *) uintptr_t(Ptr);\n\n  if (Handles.size() > 1) {\n    // This is different behaviour than what Posix dlsym(dlopen(NULL)) does.\n    // Doing that here is causing real problems for the JIT where msvc.dll\n    // and ucrt.dll can define the same symbols. The runtime linker will choose\n    // symbols from ucrt.dll first, but iterating NOT in reverse here would\n    // mean that the msvc.dll versions would be returned.\n\n    for (auto I = Handles.rbegin(), E = Handles.rend()-1; I != E; ++I) {\n      if (FARPROC Ptr = GetProcAddress(HMODULE(*I), Symbol))\n        return (void *) uintptr_t(Ptr);\n    }\n  }\n  return nullptr;\n}\n\n\n// Stack probing routines are in the support library (e.g. libgcc), but we don't\n// have dynamic linking on windows. Provide a hook.\n#define EXPLICIT_SYMBOL(SYM)                    \\\n  extern \"C\" { extern void *SYM; }\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO) EXPLICIT_SYMBOL(SYMTO)\n\n#ifdef _M_IX86\n// Win32 on x86 implements certain single-precision math functions as macros.\n// These functions are not exported by the DLL, but will still be needed\n// for symbol-resolution by the JIT loader. Therefore, this Support libray\n// provides helper functions with the same implementation.\n\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X) { return SYM(_X); }\n#define INLINE_DEF_SYMBOL2(TYP, SYM)                                           \\\n  extern \"C\" TYP inline_##SYM(TYP _X, TYP _Y) { return SYM(_X, _Y); }\n#endif\n\n#include \"explicit_symbols.inc\"\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\nstatic void *DoSearch(const char *SymbolName) {\n\n#define EXPLICIT_SYMBOL(SYM)                                                   \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&SYM;\n#define EXPLICIT_SYMBOL2(SYMFROM, SYMTO)                                       \\\n  if (!strcmp(SymbolName, #SYMFROM))                                           \\\n    return (void *)&SYMTO;\n\n#ifdef _M_IX86\n#define INLINE_DEF_SYMBOL1(TYP, SYM)                                           \\\n  if (!strcmp(SymbolName, #SYM))                                               \\\n    return (void *)&inline_##SYM;\n#define INLINE_DEF_SYMBOL2(TYP, SYM) INLINE_DEF_SYMBOL1(TYP, SYM)\n#endif\n\n  {\n#include \"explicit_symbols.inc\"\n  }\n\n#undef EXPLICIT_SYMBOL\n#undef EXPLICIT_SYMBOL2\n#undef INLINE_DEF_SYMBOL1\n#undef INLINE_DEF_SYMBOL2\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/lib/Support/Unix/DynamicLibrary.inc": "//===- Unix/DynamicLibrary.cpp - Unix DL Implementation ---------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides the UNIX specific implementation of DynamicLibrary.\n//\n//===----------------------------------------------------------------------===//\n\n#if defined(HAVE_DLFCN_H) && defined(HAVE_DLOPEN)\n#include <dlfcn.h>\n\nDynamicLibrary::HandleSet::~HandleSet() {\n  // Close the libraries in reverse order.\n  for (void *Handle : llvm::reverse(Handles))\n    ::dlclose(Handle);\n  if (Process)\n    ::dlclose(Process);\n\n  // llvm_shutdown called, Return to default\n  DynamicLibrary::SearchOrder = DynamicLibrary::SO_Linker;\n}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  void *Handle = ::dlopen(File, RTLD_LAZY|RTLD_GLOBAL);\n  if (!Handle) {\n    if (Err) *Err = ::dlerror();\n    return &DynamicLibrary::Invalid;\n  }\n\n#ifdef __CYGWIN__\n  // Cygwin searches symbols only in the main\n  // with the handle of dlopen(NULL, RTLD_GLOBAL).\n  if (!File)\n    Handle = RTLD_DEFAULT;\n#endif\n\n  return Handle;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n  ::dlclose(Handle);\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return ::dlsym(Handle, Symbol);\n}\n\n#else // !HAVE_DLOPEN\n\nDynamicLibrary::HandleSet::~HandleSet() {}\n\nvoid *DynamicLibrary::HandleSet::DLOpen(const char *File, std::string *Err) {\n  if (Err) *Err = \"dlopen() not supported on this platform\";\n  return &Invalid;\n}\n\nvoid DynamicLibrary::HandleSet::DLClose(void *Handle) {\n}\n\nvoid *DynamicLibrary::HandleSet::DLSym(void *Handle, const char *Symbol) {\n  return nullptr;\n}\n\n#endif\n\n// Must declare the symbols in the global namespace.\nstatic void *DoSearch(const char* SymbolName) {\n#define EXPLICIT_SYMBOL(SYM) \\\n   extern void *SYM; if (!strcmp(SymbolName, #SYM)) return &SYM\n\n  // If this is darwin, it has some funky issues, try to solve them here.  Some\n  // important symbols are marked 'private external' which doesn't allow\n  // SearchForAddressOfSymbol to find them.  As such, we special case them here,\n  // there is only a small handful of them.\n\n#ifdef __APPLE__\n  {\n    // __eprintf is sometimes used for assert() handling on x86.\n    //\n    // FIXME: Currently disabled when using Clang, as we don't always have our\n    // runtime support libraries available.\n#ifndef __clang__\n#ifdef __i386__\n    EXPLICIT_SYMBOL(__eprintf);\n#endif\n#endif\n  }\n#endif\n\n#ifdef __CYGWIN__\n  {\n    EXPLICIT_SYMBOL(_alloca);\n    EXPLICIT_SYMBOL(__main);\n  }\n#endif\n\n#undef EXPLICIT_SYMBOL\n\n// This macro returns the address of a well-known, explicit symbol\n#define EXPLICIT_SYMBOL(SYM) \\\n   if (!strcmp(SymbolName, #SYM)) return &SYM\n\n// Under glibc we have a weird situation. The stderr/out/in symbols are both\n// macros and global variables because of standards requirements. So, we\n// boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.\n#if defined(__GLIBC__)\n  {\n    EXPLICIT_SYMBOL(stderr);\n    EXPLICIT_SYMBOL(stdout);\n    EXPLICIT_SYMBOL(stdin);\n  }\n#else\n  // For everything else, we want to check to make sure the symbol isn't defined\n  // as a macro before using EXPLICIT_SYMBOL.\n  {\n#ifndef stdin\n    EXPLICIT_SYMBOL(stdin);\n#endif\n#ifndef stdout\n    EXPLICIT_SYMBOL(stdout);\n#endif\n#ifndef stderr\n    EXPLICIT_SYMBOL(stderr);\n#endif\n  }\n#endif\n#undef EXPLICIT_SYMBOL\n\n  return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/include/llvm/ExecutionEngine/ExecutionEngine.h": "//===- ExecutionEngine.h - Abstract Execution Engine Interface --*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the abstract interface that implements execution support\n// for LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_EXECUTIONENGINE_EXECUTIONENGINE_H\n#define LLVM_EXECUTIONENGINE_EXECUTIONENGINE_H\n\n#include \"llvm-c/ExecutionEngine.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ExecutionEngine/JITSymbol.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Mutex.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <algorithm>\n#include <cstdint>\n#include <functional>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass Constant;\nclass Function;\nstruct GenericValue;\nclass GlobalValue;\nclass GlobalVariable;\nclass JITEventListener;\nclass MCJITMemoryManager;\nclass ObjectCache;\nclass RTDyldMemoryManager;\nclass Triple;\nclass Type;\n\nnamespace object {\n\nclass Archive;\nclass ObjectFile;\n\n} // end namespace object\n\n/// \\brief Helper class for helping synchronize access to the global address map\n/// table.  Access to this class should be serialized under a mutex.\nclass ExecutionEngineState {\npublic:\n  using GlobalAddressMapTy = StringMap<uint64_t>;\n\nprivate:\n  /// GlobalAddressMap - A mapping between LLVM global symbol names values and\n  /// their actualized version...\n  GlobalAddressMapTy GlobalAddressMap;\n\n  /// GlobalAddressReverseMap - This is the reverse mapping of GlobalAddressMap,\n  /// used to convert raw addresses into the LLVM global value that is emitted\n  /// at the address.  This map is not computed unless getGlobalValueAtAddress\n  /// is called at some point.\n  std::map<uint64_t, std::string> GlobalAddressReverseMap;\n\npublic:\n  GlobalAddressMapTy &getGlobalAddressMap() {\n    return GlobalAddressMap;\n  }\n\n  std::map<uint64_t, std::string> &getGlobalAddressReverseMap() {\n    return GlobalAddressReverseMap;\n  }\n\n  /// \\brief Erase an entry from the mapping table.\n  ///\n  /// \\returns The address that \\p ToUnmap was happed to.\n  uint64_t RemoveMapping(StringRef Name);\n};\n\nusing FunctionCreator = std::function<void *(const std::string &)>;\n\n/// \\brief Abstract interface for implementation execution of LLVM modules,\n/// designed to support both interpreter and just-in-time (JIT) compiler\n/// implementations.\nclass ExecutionEngine {\n  /// The state object holding the global address mapping, which must be\n  /// accessed synchronously.\n  //\n  // FIXME: There is no particular need the entire map needs to be\n  // synchronized.  Wouldn't a reader-writer design be better here?\n  ExecutionEngineState EEState;\n\n  /// The target data for the platform for which execution is being performed.\n  ///\n  /// Note: the DataLayout is LLVMContext specific because it has an\n  /// internal cache based on type pointers. It makes unsafe to reuse the\n  /// ExecutionEngine across context, we don't enforce this rule but undefined\n  /// behavior can occurs if the user tries to do it.\n  const DataLayout DL;\n\n  /// Whether lazy JIT compilation is enabled.\n  bool CompilingLazily;\n\n  /// Whether JIT compilation of external global variables is allowed.\n  bool GVCompilationDisabled;\n\n  /// Whether the JIT should perform lookups of external symbols (e.g.,\n  /// using dlsym).\n  bool SymbolSearchingDisabled;\n\n  /// Whether the JIT should verify IR modules during compilation.\n  bool VerifyModules;\n\n  friend class EngineBuilder;  // To allow access to JITCtor and InterpCtor.\n\nprotected:\n  /// The list of Modules that we are JIT'ing from.  We use a SmallVector to\n  /// optimize for the case where there is only one module.\n  SmallVector<std::unique_ptr<Module>, 1> Modules;\n\n  /// getMemoryforGV - Allocate memory for a global variable.\n  virtual char *getMemoryForGV(const GlobalVariable *GV);\n\n  static ExecutionEngine *(*MCJITCtor)(\n                                std::unique_ptr<Module> M,\n                                std::string *ErrorStr,\n                                std::shared_ptr<MCJITMemoryManager> MM,\n                                std::shared_ptr<JITSymbolResolver> SR,\n                                std::unique_ptr<TargetMachine> TM);\n\n  static ExecutionEngine *(*OrcMCJITReplacementCtor)(\n                                std::string *ErrorStr,\n                                std::shared_ptr<MCJITMemoryManager> MM,\n                                std::shared_ptr<JITSymbolResolver> SR,\n                                std::unique_ptr<TargetMachine> TM);\n\n  static ExecutionEngine *(*InterpCtor)(std::unique_ptr<Module> M,\n                                        std::string *ErrorStr);\n\n  /// LazyFunctionCreator - If an unknown function is needed, this function\n  /// pointer is invoked to create it.  If this returns null, the JIT will\n  /// abort.\n  FunctionCreator LazyFunctionCreator;\n\n  /// getMangledName - Get mangled name.\n  std::string getMangledName(const GlobalValue *GV);\n\npublic:\n  /// lock - This lock protects the ExecutionEngine and MCJIT classes. It must\n  /// be held while changing the internal state of any of those classes.\n  sys::Mutex lock;\n\n  //===--------------------------------------------------------------------===//\n  //  ExecutionEngine Startup\n  //===--------------------------------------------------------------------===//\n\n  virtual ~ExecutionEngine();\n\n  /// Add a Module to the list of modules that we can JIT from.\n  virtual void addModule(std::unique_ptr<Module> M) {\n    Modules.push_back(std::move(M));\n  }\n\n  /// addObjectFile - Add an ObjectFile to the execution engine.\n  ///\n  /// This method is only supported by MCJIT.  MCJIT will immediately load the\n  /// object into memory and adds its symbols to the list used to resolve\n  /// external symbols while preparing other objects for execution.\n  ///\n  /// Objects added using this function will not be made executable until\n  /// needed by another object.\n  ///\n  /// MCJIT will take ownership of the ObjectFile.\n  virtual void addObjectFile(std::unique_ptr<object::ObjectFile> O);\n  virtual void addObjectFile(object::OwningBinary<object::ObjectFile> O);\n\n  /// addArchive - Add an Archive to the execution engine.\n  ///\n  /// This method is only supported by MCJIT.  MCJIT will use the archive to\n  /// resolve external symbols in objects it is loading.  If a symbol is found\n  /// in the Archive the contained object file will be extracted (in memory)\n  /// and loaded for possible execution.\n  virtual void addArchive(object::OwningBinary<object::Archive> A);\n\n  //===--------------------------------------------------------------------===//\n\n  const DataLayout &getDataLayout() const { return DL; }\n\n  /// removeModule - Removes a Module from the list of modules, but does not\n  /// free the module's memory. Returns true if M is found, in which case the\n  /// caller assumes responsibility for deleting the module.\n  //\n  // FIXME: This stealth ownership transfer is horrible. This will probably be\n  //        fixed by deleting ExecutionEngine.\n  virtual bool removeModule(Module *M);\n\n  /// FindFunctionNamed - Search all of the active modules to find the function that\n  /// defines FnName.  This is very slow operation and shouldn't be used for\n  /// general code.\n  virtual Function *FindFunctionNamed(StringRef FnName);\n\n  /// FindGlobalVariableNamed - Search all of the active modules to find the global variable\n  /// that defines Name.  This is very slow operation and shouldn't be used for\n  /// general code.\n  virtual GlobalVariable *FindGlobalVariableNamed(StringRef Name, bool AllowInternal = false);\n\n  /// runFunction - Execute the specified function with the specified arguments,\n  /// and return the result.\n  ///\n  /// For MCJIT execution engines, clients are encouraged to use the\n  /// \"GetFunctionAddress\" method (rather than runFunction) and cast the\n  /// returned uint64_t to the desired function pointer type. However, for\n  /// backwards compatibility MCJIT's implementation can execute 'main-like'\n  /// function (i.e. those returning void or int, and taking either no\n  /// arguments or (int, char*[])).\n  virtual GenericValue runFunction(Function *F,\n                                   ArrayRef<GenericValue> ArgValues) = 0;\n\n  /// getPointerToNamedFunction - This method returns the address of the\n  /// specified function by using the dlsym function call.  As such it is only\n  /// useful for resolving library symbols, not code generated symbols.\n  ///\n  /// If AbortOnFailure is false and no function with the given name is\n  /// found, this function silently returns a null pointer. Otherwise,\n  /// it prints a message to stderr and aborts.\n  ///\n  /// This function is deprecated for the MCJIT execution engine.\n  virtual void *getPointerToNamedFunction(StringRef Name,\n                                          bool AbortOnFailure = true) = 0;\n\n  /// mapSectionAddress - map a section to its target address space value.\n  /// Map the address of a JIT section as returned from the memory manager\n  /// to the address in the target process as the running code will see it.\n  /// This is the address which will be used for relocation resolution.\n  virtual void mapSectionAddress(const void *LocalAddress,\n                                 uint64_t TargetAddress) {\n    llvm_unreachable(\"Re-mapping of section addresses not supported with this \"\n                     \"EE!\");\n  }\n\n  /// generateCodeForModule - Run code generation for the specified module and\n  /// load it into memory.\n  ///\n  /// When this function has completed, all code and data for the specified\n  /// module, and any module on which this module depends, will be generated\n  /// and loaded into memory, but relocations will not yet have been applied\n  /// and all memory will be readable and writable but not executable.\n  ///\n  /// This function is primarily useful when generating code for an external\n  /// target, allowing the client an opportunity to remap section addresses\n  /// before relocations are applied.  Clients that intend to execute code\n  /// locally can use the getFunctionAddress call, which will generate code\n  /// and apply final preparations all in one step.\n  ///\n  /// This method has no effect for the interpeter.\n  virtual void generateCodeForModule(Module *M) {}\n\n  /// finalizeObject - ensure the module is fully processed and is usable.\n  ///\n  /// It is the user-level function for completing the process of making the\n  /// object usable for execution.  It should be called after sections within an\n  /// object have been relocated using mapSectionAddress.  When this method is\n  /// called the MCJIT execution engine will reapply relocations for a loaded\n  /// object.  This method has no effect for the interpeter.\n  virtual void finalizeObject() {}\n\n  /// runStaticConstructorsDestructors - This method is used to execute all of\n  /// the static constructors or destructors for a program.\n  ///\n  /// \\param isDtors - Run the destructors instead of constructors.\n  virtual void runStaticConstructorsDestructors(bool isDtors);\n\n  /// This method is used to execute all of the static constructors or\n  /// destructors for a particular module.\n  ///\n  /// \\param isDtors - Run the destructors instead of constructors.\n  void runStaticConstructorsDestructors(Module &module, bool isDtors);\n\n\n  /// runFunctionAsMain - This is a helper function which wraps runFunction to\n  /// handle the common task of starting up main with the specified argc, argv,\n  /// and envp parameters.\n  int runFunctionAsMain(Function *Fn, const std::vector<std::string> &argv,\n                        const char * const * envp);\n\n\n  /// addGlobalMapping - Tell the execution engine that the specified global is\n  /// at the specified location.  This is used internally as functions are JIT'd\n  /// and as global variables are laid out in memory.  It can and should also be\n  /// used by clients of the EE that want to have an LLVM global overlay\n  /// existing data in memory. Values to be mapped should be named, and have\n  /// external or weak linkage. Mappings are automatically removed when their\n  /// GlobalValue is destroyed.\n  void addGlobalMapping(const GlobalValue *GV, void *Addr);\n  void addGlobalMapping(StringRef Name, uint64_t Addr);\n\n  /// clearAllGlobalMappings - Clear all global mappings and start over again,\n  /// for use in dynamic compilation scenarios to move globals.\n  void clearAllGlobalMappings();\n\n  /// clearGlobalMappingsFromModule - Clear all global mappings that came from a\n  /// particular module, because it has been removed from the JIT.\n  void clearGlobalMappingsFromModule(Module *M);\n\n  /// updateGlobalMapping - Replace an existing mapping for GV with a new\n  /// address.  This updates both maps as required.  If \"Addr\" is null, the\n  /// entry for the global is removed from the mappings.  This returns the old\n  /// value of the pointer, or null if it was not in the map.\n  uint64_t updateGlobalMapping(const GlobalValue *GV, void *Addr);\n  uint64_t updateGlobalMapping(StringRef Name, uint64_t Addr);\n\n  /// getAddressToGlobalIfAvailable - This returns the address of the specified\n  /// global symbol.\n  uint64_t getAddressToGlobalIfAvailable(StringRef S);\n\n  /// getPointerToGlobalIfAvailable - This returns the address of the specified\n  /// global value if it is has already been codegen'd, otherwise it returns\n  /// null.\n  void *getPointerToGlobalIfAvailable(StringRef S);\n  void *getPointerToGlobalIfAvailable(const GlobalValue *GV);\n\n  /// getPointerToGlobal - This returns the address of the specified global\n  /// value. This may involve code generation if it's a function.\n  ///\n  /// This function is deprecated for the MCJIT execution engine.  Use\n  /// getGlobalValueAddress instead.\n  void *getPointerToGlobal(const GlobalValue *GV);\n\n  /// getPointerToFunction - The different EE's represent function bodies in\n  /// different ways.  They should each implement this to say what a function\n  /// pointer should look like.  When F is destroyed, the ExecutionEngine will\n  /// remove its global mapping and free any machine code.  Be sure no threads\n  /// are running inside F when that happens.\n  ///\n  /// This function is deprecated for the MCJIT execution engine.  Use\n  /// getFunctionAddress instead.\n  virtual void *getPointerToFunction(Function *F) = 0;\n\n  /// getPointerToFunctionOrStub - If the specified function has been\n  /// code-gen'd, return a pointer to the function.  If not, compile it, or use\n  /// a stub to implement lazy compilation if available.  See\n  /// getPointerToFunction for the requirements on destroying F.\n  ///\n  /// This function is deprecated for the MCJIT execution engine.  Use\n  /// getFunctionAddress instead.\n  virtual void *getPointerToFunctionOrStub(Function *F) {\n    // Default implementation, just codegen the function.\n    return getPointerToFunction(F);\n  }\n\n  /// getGlobalValueAddress - Return the address of the specified global\n  /// value. This may involve code generation.\n  ///\n  /// This function should not be called with the interpreter engine.\n  virtual uint64_t getGlobalValueAddress(const std::string &Name) {\n    // Default implementation for the interpreter.  MCJIT will override this.\n    // JIT and interpreter clients should use getPointerToGlobal instead.\n    return 0;\n  }\n\n  /// getFunctionAddress - Return the address of the specified function.\n  /// This may involve code generation.\n  virtual uint64_t getFunctionAddress(const std::string &Name) {\n    // Default implementation for the interpreter.  MCJIT will override this.\n    // Interpreter clients should use getPointerToFunction instead.\n    return 0;\n  }\n\n  /// getGlobalValueAtAddress - Return the LLVM global value object that starts\n  /// at the specified address.\n  ///\n  const GlobalValue *getGlobalValueAtAddress(void *Addr);\n\n  /// StoreValueToMemory - Stores the data in Val of type Ty at address Ptr.\n  /// Ptr is the address of the memory at which to store Val, cast to\n  /// GenericValue *.  It is not a pointer to a GenericValue containing the\n  /// address at which to store Val.\n  void StoreValueToMemory(const GenericValue &Val, GenericValue *Ptr,\n                          Type *Ty);\n\n  void InitializeMemory(const Constant *Init, void *Addr);\n\n  /// getOrEmitGlobalVariable - Return the address of the specified global\n  /// variable, possibly emitting it to memory if needed.  This is used by the\n  /// Emitter.\n  ///\n  /// This function is deprecated for the MCJIT execution engine.  Use\n  /// getGlobalValueAddress instead.\n  virtual void *getOrEmitGlobalVariable(const GlobalVariable *GV) {\n    return getPointerToGlobal((const GlobalValue *)GV);\n  }\n\n  /// Registers a listener to be called back on various events within\n  /// the JIT.  See JITEventListener.h for more details.  Does not\n  /// take ownership of the argument.  The argument may be NULL, in\n  /// which case these functions do nothing.\n  virtual void RegisterJITEventListener(JITEventListener *) {}\n  virtual void UnregisterJITEventListener(JITEventListener *) {}\n\n  /// Sets the pre-compiled object cache.  The ownership of the ObjectCache is\n  /// not changed.  Supported by MCJIT but not the interpreter.\n  virtual void setObjectCache(ObjectCache *) {\n    llvm_unreachable(\"No support for an object cache\");\n  }\n\n  /// setProcessAllSections (MCJIT Only): By default, only sections that are\n  /// \"required for execution\" are passed to the RTDyldMemoryManager, and other\n  /// sections are discarded. Passing 'true' to this method will cause\n  /// RuntimeDyld to pass all sections to its RTDyldMemoryManager regardless\n  /// of whether they are \"required to execute\" in the usual sense.\n  ///\n  /// Rationale: Some MCJIT clients want to be able to inspect metadata\n  /// sections (e.g. Dwarf, Stack-maps) to enable functionality or analyze\n  /// performance. Passing these sections to the memory manager allows the\n  /// client to make policy about the relevant sections, rather than having\n  /// MCJIT do it.\n  virtual void setProcessAllSections(bool ProcessAllSections) {\n    llvm_unreachable(\"No support for ProcessAllSections option\");\n  }\n\n  /// Return the target machine (if available).\n  virtual TargetMachine *getTargetMachine() { return nullptr; }\n\n  /// DisableLazyCompilation - When lazy compilation is off (the default), the\n  /// JIT will eagerly compile every function reachable from the argument to\n  /// getPointerToFunction.  If lazy compilation is turned on, the JIT will only\n  /// compile the one function and emit stubs to compile the rest when they're\n  /// first called.  If lazy compilation is turned off again while some lazy\n  /// stubs are still around, and one of those stubs is called, the program will\n  /// abort.\n  ///\n  /// In order to safely compile lazily in a threaded program, the user must\n  /// ensure that 1) only one thread at a time can call any particular lazy\n  /// stub, and 2) any thread modifying LLVM IR must hold the JIT's lock\n  /// (ExecutionEngine::lock) or otherwise ensure that no other thread calls a\n  /// lazy stub.  See http://llvm.org/PR5184 for details.\n  void DisableLazyCompilation(bool Disabled = true) {\n    CompilingLazily = !Disabled;\n  }\n  bool isCompilingLazily() const {\n    return CompilingLazily;\n  }\n\n  /// DisableGVCompilation - If called, the JIT will abort if it's asked to\n  /// allocate space and populate a GlobalVariable that is not internal to\n  /// the module.\n  void DisableGVCompilation(bool Disabled = true) {\n    GVCompilationDisabled = Disabled;\n  }\n  bool isGVCompilationDisabled() const {\n    return GVCompilationDisabled;\n  }\n\n  /// DisableSymbolSearching - If called, the JIT will not try to lookup unknown\n  /// symbols with dlsym.  A client can still use InstallLazyFunctionCreator to\n  /// resolve symbols in a custom way.\n  void DisableSymbolSearching(bool Disabled = true) {\n    SymbolSearchingDisabled = Disabled;\n  }\n  bool isSymbolSearchingDisabled() const {\n    return SymbolSearchingDisabled;\n  }\n\n  /// Enable/Disable IR module verification.\n  ///\n  /// Note: Module verification is enabled by default in Debug builds, and\n  /// disabled by default in Release. Use this method to override the default.\n  void setVerifyModules(bool Verify) {\n    VerifyModules = Verify;\n  }\n  bool getVerifyModules() const {\n    return VerifyModules;\n  }\n\n  /// InstallLazyFunctionCreator - If an unknown function is needed, the\n  /// specified function pointer is invoked to create it.  If it returns null,\n  /// the JIT will abort.\n  void InstallLazyFunctionCreator(FunctionCreator C) {\n    LazyFunctionCreator = std::move(C);\n  }\n\nprotected:\n  ExecutionEngine(DataLayout DL) : DL(std::move(DL)) {}\n  explicit ExecutionEngine(DataLayout DL, std::unique_ptr<Module> M);\n  explicit ExecutionEngine(std::unique_ptr<Module> M);\n\n  void emitGlobals();\n\n  void EmitGlobalVariable(const GlobalVariable *GV);\n\n  GenericValue getConstantValue(const Constant *C);\n  void LoadValueFromMemory(GenericValue &Result, GenericValue *Ptr,\n                           Type *Ty);\n\nprivate:\n  void Init(std::unique_ptr<Module> M);\n};\n\nnamespace EngineKind {\n\n  // These are actually bitmasks that get or-ed together.\n  enum Kind {\n    JIT         = 0x1,\n    Interpreter = 0x2\n  };\n  const static Kind Either = (Kind)(JIT | Interpreter);\n\n} // end namespace EngineKind\n\n/// Builder class for ExecutionEngines. Use this by stack-allocating a builder,\n/// chaining the various set* methods, and terminating it with a .create()\n/// call.\nclass EngineBuilder {\nprivate:\n  std::unique_ptr<Module> M;\n  EngineKind::Kind WhichEngine;\n  std::string *ErrorStr;\n  CodeGenOpt::Level OptLevel;\n  std::shared_ptr<MCJITMemoryManager> MemMgr;\n  std::shared_ptr<JITSymbolResolver> Resolver;\n  TargetOptions Options;\n  Optional<Reloc::Model> RelocModel;\n  CodeModel::Model CMModel;\n  std::string MArch;\n  std::string MCPU;\n  SmallVector<std::string, 4> MAttrs;\n  bool VerifyModules;\n  bool UseOrcMCJITReplacement;\n\npublic:\n  /// Default constructor for EngineBuilder.\n  EngineBuilder();\n\n  /// Constructor for EngineBuilder.\n  EngineBuilder(std::unique_ptr<Module> M);\n\n  // Out-of-line since we don't have the def'n of RTDyldMemoryManager here.\n  ~EngineBuilder();\n\n  /// setEngineKind - Controls whether the user wants the interpreter, the JIT,\n  /// or whichever engine works.  This option defaults to EngineKind::Either.\n  EngineBuilder &setEngineKind(EngineKind::Kind w) {\n    WhichEngine = w;\n    return *this;\n  }\n\n  /// setMCJITMemoryManager - Sets the MCJIT memory manager to use. This allows\n  /// clients to customize their memory allocation policies for the MCJIT. This\n  /// is only appropriate for the MCJIT; setting this and configuring the builder\n  /// to create anything other than MCJIT will cause a runtime error. If create()\n  /// is called and is successful, the created engine takes ownership of the\n  /// memory manager. This option defaults to NULL.\n  EngineBuilder &setMCJITMemoryManager(std::unique_ptr<RTDyldMemoryManager> mcjmm);\n\n  EngineBuilder&\n  setMemoryManager(std::unique_ptr<MCJITMemoryManager> MM);\n\n  EngineBuilder&\n  setSymbolResolver(std::unique_ptr<JITSymbolResolver> SR);\n\n  /// setErrorStr - Set the error string to write to on error.  This option\n  /// defaults to NULL.\n  EngineBuilder &setErrorStr(std::string *e) {\n    ErrorStr = e;\n    return *this;\n  }\n\n  /// setOptLevel - Set the optimization level for the JIT.  This option\n  /// defaults to CodeGenOpt::Default.\n  EngineBuilder &setOptLevel(CodeGenOpt::Level l) {\n    OptLevel = l;\n    return *this;\n  }\n\n  /// setTargetOptions - Set the target options that the ExecutionEngine\n  /// target is using. Defaults to TargetOptions().\n  EngineBuilder &setTargetOptions(const TargetOptions &Opts) {\n    Options = Opts;\n    return *this;\n  }\n\n  /// setRelocationModel - Set the relocation model that the ExecutionEngine\n  /// target is using. Defaults to target specific default \"Reloc::Default\".\n  EngineBuilder &setRelocationModel(Reloc::Model RM) {\n    RelocModel = RM;\n    return *this;\n  }\n\n  /// setCodeModel - Set the CodeModel that the ExecutionEngine target\n  /// data is using. Defaults to target specific default\n  /// \"CodeModel::JITDefault\".\n  EngineBuilder &setCodeModel(CodeModel::Model M) {\n    CMModel = M;\n    return *this;\n  }\n\n  /// setMArch - Override the architecture set by the Module's triple.\n  EngineBuilder &setMArch(StringRef march) {\n    MArch.assign(march.begin(), march.end());\n    return *this;\n  }\n\n  /// setMCPU - Target a specific cpu type.\n  EngineBuilder &setMCPU(StringRef mcpu) {\n    MCPU.assign(mcpu.begin(), mcpu.end());\n    return *this;\n  }\n\n  /// setVerifyModules - Set whether the JIT implementation should verify\n  /// IR modules during compilation.\n  EngineBuilder &setVerifyModules(bool Verify) {\n    VerifyModules = Verify;\n    return *this;\n  }\n\n  /// setMAttrs - Set cpu-specific attributes.\n  template<typename StringSequence>\n  EngineBuilder &setMAttrs(const StringSequence &mattrs) {\n    MAttrs.clear();\n    MAttrs.append(mattrs.begin(), mattrs.end());\n    return *this;\n  }\n\n  // \\brief Use OrcMCJITReplacement instead of MCJIT. Off by default.\n  void setUseOrcMCJITReplacement(bool UseOrcMCJITReplacement) {\n    this->UseOrcMCJITReplacement = UseOrcMCJITReplacement;\n  }\n\n  TargetMachine *selectTarget();\n\n  /// selectTarget - Pick a target either via -march or by guessing the native\n  /// arch.  Add any CPU features specified via -mcpu or -mattr.\n  TargetMachine *selectTarget(const Triple &TargetTriple,\n                              StringRef MArch,\n                              StringRef MCPU,\n                              const SmallVectorImpl<std::string>& MAttrs);\n\n  ExecutionEngine *create() {\n    return create(selectTarget());\n  }\n\n  ExecutionEngine *create(TargetMachine *TM);\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(ExecutionEngine, LLVMExecutionEngineRef)\n\n} // end namespace llvm\n\n#endif // LLVM_EXECUTIONENGINE_EXECUTIONENGINE_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/include/llvm/Support/DynamicLibrary.h": "//===-- llvm/Support/DynamicLibrary.h - Portable Dynamic Library -*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the sys::DynamicLibrary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DYNAMICLIBRARY_H\n#define LLVM_SUPPORT_DYNAMICLIBRARY_H\n\n#include <string>\n\nnamespace llvm {\n\nclass StringRef;\n\nnamespace sys {\n\n  /// This class provides a portable interface to dynamic libraries which also\n  /// might be known as shared libraries, shared objects, dynamic shared\n  /// objects, or dynamic link libraries. Regardless of the terminology or the\n  /// operating system interface, this class provides a portable interface that\n  /// allows dynamic libraries to be loaded and searched for externally\n  /// defined symbols. This is typically used to provide \"plug-in\" support.\n  /// It also allows for symbols to be defined which don't live in any library,\n  /// but rather the main program itself, useful on Windows where the main\n  /// executable cannot be searched.\n  ///\n  /// Note: there is currently no interface for temporarily loading a library,\n  /// or for unloading libraries when the LLVM library is unloaded.\n  class DynamicLibrary {\n    // Placeholder whose address represents an invalid library.\n    // We use this instead of NULL or a pointer-int pair because the OS library\n    // might define 0 or 1 to be \"special\" handles, such as \"search all\".\n    static char Invalid;\n\n    // Opaque data used to interface with OS-specific dynamic library handling.\n    void *Data;\n\n  public:\n    explicit DynamicLibrary(void *data = &Invalid) : Data(data) {}\n\n    /// Returns true if the object refers to a valid library.\n    bool isValid() const { return Data != &Invalid; }\n\n    /// Searches through the library for the symbol \\p symbolName. If it is\n    /// found, the address of that symbol is returned. If not, NULL is returned.\n    /// Note that NULL will also be returned if the library failed to load.\n    /// Use isValid() to distinguish these cases if it is important.\n    /// Note that this will \\e not search symbols explicitly registered by\n    /// AddSymbol().\n    void *getAddressOfSymbol(const char *symbolName);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// The library will only be unloaded when llvm_shutdown() is called.\n    /// This returns a valid DynamicLibrary instance on success and an invalid\n    /// instance on failure (see isValid()). \\p *errMsg will only be modified\n    /// if the library fails to load.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    /// @brief Open a dynamic library permanently.\n    static DynamicLibrary getPermanentLibrary(const char *filename,\n                                              std::string *errMsg = nullptr);\n\n    /// Registers an externally loaded library. The library will be unloaded\n    /// when the program terminates.\n    ///\n    /// It is safe to call this function multiple times for the same library,\n    /// though ownership is only taken if there was no error.\n    ///\n    /// \\returns An empty \\p DynamicLibrary if the library was already loaded.\n    static DynamicLibrary addPermanentLibrary(void *handle,\n                                              std::string *errMsg = nullptr);\n\n    /// This function permanently loads the dynamic library at the given path.\n    /// Use this instead of getPermanentLibrary() when you won't need to get\n    /// symbols from the library itself.\n    ///\n    /// It is safe to call this function multiple times for the same library.\n    static bool LoadLibraryPermanently(const char *Filename,\n                                       std::string *ErrMsg = nullptr) {\n      return !getPermanentLibrary(Filename, ErrMsg).isValid();\n    }\n\n    enum SearchOrdering {\n      /// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when\n      /// DynamicLibrary::getPermanentLibrary(NULL) has been called or\n      /// search the list of explcitly loaded symbols if not.\n      SO_Linker,\n      /// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.\n      SO_LoadedFirst,\n      /// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.\n      /// Only useful to search if libraries with RTLD_LOCAL have been added.\n      SO_LoadedLast,\n      /// SO_LoadOrder - Or this in to search libraries in the ordered loaded.\n      /// The default bahaviour is to search loaded libraries in reverse.\n      SO_LoadOrder = 4\n    };\n    static SearchOrdering SearchOrder; // = SO_Linker\n\n    /// This function will search through all previously loaded dynamic\n    /// libraries for the symbol \\p symbolName. If it is found, the address of\n    /// that symbol is returned. If not, null is returned. Note that this will\n    /// search permanently loaded libraries (getPermanentLibrary()) as well\n    /// as explicitly registered symbols (AddSymbol()).\n    /// @throws std::string on error.\n    /// @brief Search through libraries for address of a symbol\n    static void *SearchForAddressOfSymbol(const char *symbolName);\n\n    /// @brief Convenience function for C++ophiles.\n    static void *SearchForAddressOfSymbol(const std::string &symbolName) {\n      return SearchForAddressOfSymbol(symbolName.c_str());\n    }\n\n    /// This functions permanently adds the symbol \\p symbolName with the\n    /// value \\p symbolValue.  These symbols are searched before any\n    /// libraries.\n    /// @brief Add searchable symbol/value pair.\n    static void AddSymbol(StringRef symbolName, void *symbolValue);\n\n    class HandleSet;\n  };\n\n} // End sys namespace\n} // End llvm namespace\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/examples/Kaleidoscope/include/KaleidoscopeJIT.h": "//===- KaleidoscopeJIT.h - A simple JIT for Kaleidoscope --------*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// Contains a simple JIT definition for use in the kaleidoscope tutorials.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_EXECUTIONENGINE_ORC_KALEIDOSCOPEJIT_H\n#define LLVM_EXECUTIONENGINE_ORC_KALEIDOSCOPEJIT_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n#include \"llvm/ExecutionEngine/JITSymbol.h\"\n#include \"llvm/ExecutionEngine/RTDyldMemoryManager.h\"\n#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n#include \"llvm/ExecutionEngine/Orc/CompileUtils.h\"\n#include \"llvm/ExecutionEngine/Orc/IRCompileLayer.h\"\n#include \"llvm/ExecutionEngine/Orc/LambdaResolver.h\"\n#include \"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Mangler.h\"\n#include \"llvm/Support/DynamicLibrary.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include <algorithm>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace llvm {\nnamespace orc {\n\nclass KaleidoscopeJIT {\npublic:\n  using ObjLayerT = RTDyldObjectLinkingLayer;\n  using CompileLayerT = IRCompileLayer<ObjLayerT, SimpleCompiler>;\n  using ModuleHandleT = CompileLayerT::ModuleHandleT;\n\n  KaleidoscopeJIT()\n      : TM(EngineBuilder().selectTarget()), DL(TM->createDataLayout()),\n        ObjectLayer([]() { return std::make_shared<SectionMemoryManager>(); }),\n        CompileLayer(ObjectLayer, SimpleCompiler(*TM)) {\n    llvm::sys::DynamicLibrary::LoadLibraryPermanently(nullptr);\n  }\n\n  TargetMachine &getTargetMachine() { return *TM; }\n\n  ModuleHandleT addModule(std::unique_ptr<Module> M) {\n    // We need a memory manager to allocate memory and resolve symbols for this\n    // new module. Create one that resolves symbols by looking back into the\n    // JIT.\n    auto Resolver = createLambdaResolver(\n        [&](const std::string &Name) {\n          if (auto Sym = findMangledSymbol(Name))\n            return Sym;\n          return JITSymbol(nullptr);\n        },\n        [](const std::string &S) { return nullptr; });\n    auto H = cantFail(CompileLayer.addModule(std::move(M),\n                                             std::move(Resolver)));\n\n    ModuleHandles.push_back(H);\n    return H;\n  }\n\n  void removeModule(ModuleHandleT H) {\n    ModuleHandles.erase(find(ModuleHandles, H));\n    cantFail(CompileLayer.removeModule(H));\n  }\n\n  JITSymbol findSymbol(const std::string Name) {\n    return findMangledSymbol(mangle(Name));\n  }\n\nprivate:\n  std::string mangle(const std::string &Name) {\n    std::string MangledName;\n    {\n      raw_string_ostream MangledNameStream(MangledName);\n      Mangler::getNameWithPrefix(MangledNameStream, Name, DL);\n    }\n    return MangledName;\n  }\n\n  JITSymbol findMangledSymbol(const std::string &Name) {\n#ifdef LLVM_ON_WIN32\n    // The symbol lookup of ObjectLinkingLayer uses the SymbolRef::SF_Exported\n    // flag to decide whether a symbol will be visible or not, when we call\n    // IRCompileLayer::findSymbolIn with ExportedSymbolsOnly set to true.\n    //\n    // But for Windows COFF objects, this flag is currently never set.\n    // For a potential solution see: https://reviews.llvm.org/rL258665\n    // For now, we allow non-exported symbols on Windows as a workaround.\n    const bool ExportedSymbolsOnly = false;\n#else\n    const bool ExportedSymbolsOnly = true;\n#endif\n\n    // Search modules in reverse order: from last added to first added.\n    // This is the opposite of the usual search order for dlsym, but makes more\n    // sense in a REPL where we want to bind to the newest available definition.\n    for (auto H : make_range(ModuleHandles.rbegin(), ModuleHandles.rend()))\n      if (auto Sym = CompileLayer.findSymbolIn(H, Name, ExportedSymbolsOnly))\n        return Sym;\n\n    // If we can't find the symbol in the JIT, try looking in the host process.\n    if (auto SymAddr = RTDyldMemoryManager::getSymbolAddressInProcess(Name))\n      return JITSymbol(SymAddr, JITSymbolFlags::Exported);\n\n#ifdef LLVM_ON_WIN32\n    // For Windows retry without \"_\" at beginning, as RTDyldMemoryManager uses\n    // GetProcAddress and standard libraries like msvcrt.dll use names\n    // with and without \"_\" (for example \"_itoa\" but \"sin\").\n    if (Name.length() > 2 && Name[0] == '_')\n      if (auto SymAddr =\n              RTDyldMemoryManager::getSymbolAddressInProcess(Name.substr(1)))\n        return JITSymbol(SymAddr, JITSymbolFlags::Exported);\n#endif\n\n    return nullptr;\n  }\n\n  std::unique_ptr<TargetMachine> TM;\n  const DataLayout DL;\n  ObjLayerT ObjectLayer;\n  CompileLayerT CompileLayer;\n  std::vector<ModuleHandleT> ModuleHandles;\n};\n\n} // end namespace orc\n} // end namespace llvm\n\n#endif // LLVM_EXECUTIONENGINE_ORC_KALEIDOSCOPEJIT_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/lib/Sema/SemaCast.cpp": "//===--- SemaCast.cpp - Semantic Analysis for Casts -----------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for cast expressions, including\n//  1) C-style casts like '(int) x'\n//  2) C++ functional casts like 'int(x)'\n//  3) C++ named casts like 'static_cast<int>(x)'\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <set>\nusing namespace clang;\n\n\n\nenum TryCastResult {\n  TC_NotApplicable, ///< The cast method is not applicable.\n  TC_Success,       ///< The cast method is appropriate and successful.\n  TC_Failed         ///< The cast method is appropriate, but failed. A\n                    ///< diagnostic has been emitted.\n};\n\nenum CastType {\n  CT_Const,       ///< const_cast\n  CT_Static,      ///< static_cast\n  CT_Reinterpret, ///< reinterpret_cast\n  CT_Dynamic,     ///< dynamic_cast\n  CT_CStyle,      ///< (Type)expr\n  CT_Functional   ///< Type(expr)\n};\n\nnamespace {\n  struct CastOperation {\n    CastOperation(Sema &S, QualType destType, ExprResult src)\n      : Self(S), SrcExpr(src), DestType(destType),\n        ResultType(destType.getNonLValueExprType(S.Context)),\n        ValueKind(Expr::getValueKindForType(destType)),\n        Kind(CK_Dependent), IsARCUnbridgedCast(false) {\n\n      if (const BuiltinType *placeholder =\n            src.get()->getType()->getAsPlaceholderType()) {\n        PlaceholderKind = placeholder->getKind();\n      } else {\n        PlaceholderKind = (BuiltinType::Kind) 0;\n      }\n    }\n\n    Sema &Self;\n    ExprResult SrcExpr;\n    QualType DestType;\n    QualType ResultType;\n    ExprValueKind ValueKind;\n    CastKind Kind;\n    BuiltinType::Kind PlaceholderKind;\n    CXXCastPath BasePath;\n    bool IsARCUnbridgedCast;\n\n    SourceRange OpRange;\n    SourceRange DestRange;\n\n    // Top-level semantics-checking routines.\n    void CheckConstCast();\n    void CheckReinterpretCast();\n    void CheckStaticCast();\n    void CheckDynamicCast();\n    void CheckCXXCStyleCast(bool FunctionalCast, bool ListInitialization);\n    void CheckCStyleCast();\n\n    /// Complete an apparently-successful cast operation that yields\n    /// the given expression.\n    ExprResult complete(CastExpr *castExpr) {\n      // If this is an unbridged cast, wrap the result in an implicit\n      // cast that yields the unbridged-cast placeholder type.\n      if (IsARCUnbridgedCast) {\n        castExpr = ImplicitCastExpr::Create(Self.Context,\n                                            Self.Context.ARCUnbridgedCastTy,\n                                            CK_Dependent, castExpr, nullptr,\n                                            castExpr->getValueKind());\n      }\n      return castExpr;\n    }\n\n    // Internal convenience methods.\n\n    /// Try to handle the given placeholder expression kind.  Return\n    /// true if the source expression has the appropriate placeholder\n    /// kind.  A placeholder can only be claimed once.\n    bool claimPlaceholder(BuiltinType::Kind K) {\n      if (PlaceholderKind != K) return false;\n\n      PlaceholderKind = (BuiltinType::Kind) 0;\n      return true;\n    }\n\n    bool isPlaceholder() const {\n      return PlaceholderKind != 0;\n    }\n    bool isPlaceholder(BuiltinType::Kind K) const {\n      return PlaceholderKind == K;\n    }\n\n    void checkCastAlign() {\n      Self.CheckCastAlign(SrcExpr.get(), DestType, OpRange);\n    }\n\n    void checkObjCConversion(Sema::CheckedConversionKind CCK) {\n      assert(Self.getLangOpts().allowsNonTrivialObjCLifetimeQualifiers());\n\n      Expr *src = SrcExpr.get();\n      if (Self.CheckObjCConversion(OpRange, DestType, src, CCK) ==\n          Sema::ACR_unbridged)\n        IsARCUnbridgedCast = true;\n      SrcExpr = src;\n    }\n\n    /// Check for and handle non-overload placeholder expressions.\n    void checkNonOverloadPlaceholders() {\n      if (!isPlaceholder() || isPlaceholder(BuiltinType::Overload))\n        return;\n\n      SrcExpr = Self.CheckPlaceholderExpr(SrcExpr.get());\n      if (SrcExpr.isInvalid())\n        return;\n      PlaceholderKind = (BuiltinType::Kind) 0;\n    }\n  };\n}\n\nstatic void DiagnoseCastQual(Sema &Self, const ExprResult &SrcExpr,\n                             QualType DestType);\n\n// The Try functions attempt a specific way of casting. If they succeed, they\n// return TC_Success. If their way of casting is not appropriate for the given\n// arguments, they return TC_NotApplicable and *may* set diag to a diagnostic\n// to emit if no other way succeeds. If their way of casting is appropriate but\n// fails, they return TC_Failed and *must* set diag; they can set it to 0 if\n// they emit a specialized diagnostic.\n// All diagnostics returned by these functions must expect the same three\n// arguments:\n// %0: Cast Type (a value from the CastType enumeration)\n// %1: Source Type\n// %2: Destination Type\nstatic TryCastResult TryLValueToRValueCast(Sema &Self, Expr *SrcExpr,\n                                           QualType DestType, bool CStyle,\n                                           CastKind &Kind,\n                                           CXXCastPath &BasePath,\n                                           unsigned &msg);\nstatic TryCastResult TryStaticReferenceDowncast(Sema &Self, Expr *SrcExpr,\n                                               QualType DestType, bool CStyle,\n                                               SourceRange OpRange,\n                                               unsigned &msg,\n                                               CastKind &Kind,\n                                               CXXCastPath &BasePath);\nstatic TryCastResult TryStaticPointerDowncast(Sema &Self, QualType SrcType,\n                                              QualType DestType, bool CStyle,\n                                              SourceRange OpRange,\n                                              unsigned &msg,\n                                              CastKind &Kind,\n                                              CXXCastPath &BasePath);\nstatic TryCastResult TryStaticDowncast(Sema &Self, CanQualType SrcType,\n                                       CanQualType DestType, bool CStyle,\n                                       SourceRange OpRange,\n                                       QualType OrigSrcType,\n                                       QualType OrigDestType, unsigned &msg,\n                                       CastKind &Kind,\n                                       CXXCastPath &BasePath);\nstatic TryCastResult TryStaticMemberPointerUpcast(Sema &Self, ExprResult &SrcExpr,\n                                               QualType SrcType,\n                                               QualType DestType,bool CStyle,\n                                               SourceRange OpRange,\n                                               unsigned &msg,\n                                               CastKind &Kind,\n                                               CXXCastPath &BasePath);\n\nstatic TryCastResult TryStaticImplicitCast(Sema &Self, ExprResult &SrcExpr,\n                                           QualType DestType, \n                                           Sema::CheckedConversionKind CCK,\n                                           SourceRange OpRange,\n                                           unsigned &msg, CastKind &Kind,\n                                           bool ListInitialization);\nstatic TryCastResult TryStaticCast(Sema &Self, ExprResult &SrcExpr,\n                                   QualType DestType, \n                                   Sema::CheckedConversionKind CCK,\n                                   SourceRange OpRange,\n                                   unsigned &msg, CastKind &Kind,\n                                   CXXCastPath &BasePath,\n                                   bool ListInitialization);\nstatic TryCastResult TryConstCast(Sema &Self, ExprResult &SrcExpr,\n                                  QualType DestType, bool CStyle,\n                                  unsigned &msg);\nstatic TryCastResult TryReinterpretCast(Sema &Self, ExprResult &SrcExpr,\n                                        QualType DestType, bool CStyle,\n                                        SourceRange OpRange,\n                                        unsigned &msg,\n                                        CastKind &Kind);\n\n\n/// ActOnCXXNamedCast - Parse {dynamic,static,reinterpret,const}_cast's.\nExprResult\nSema::ActOnCXXNamedCast(SourceLocation OpLoc, tok::TokenKind Kind,\n                        SourceLocation LAngleBracketLoc, Declarator &D,\n                        SourceLocation RAngleBracketLoc,\n                        SourceLocation LParenLoc, Expr *E,\n                        SourceLocation RParenLoc) {\n\n  assert(!D.isInvalidType());\n\n  TypeSourceInfo *TInfo = GetTypeForDeclaratorCast(D, E->getType());\n  if (D.isInvalidType())\n    return ExprError();\n\n  if (getLangOpts().CPlusPlus) {\n    // Check that there are no default arguments (C++ only).\n    CheckExtraCXXDefaultArguments(D);\n  }\n\n  return BuildCXXNamedCast(OpLoc, Kind, TInfo, E,\n                           SourceRange(LAngleBracketLoc, RAngleBracketLoc),\n                           SourceRange(LParenLoc, RParenLoc));\n}\n\nExprResult\nSema::BuildCXXNamedCast(SourceLocation OpLoc, tok::TokenKind Kind,\n                        TypeSourceInfo *DestTInfo, Expr *E,\n                        SourceRange AngleBrackets, SourceRange Parens) {\n  ExprResult Ex = E;\n  QualType DestType = DestTInfo->getType();\n\n  // If the type is dependent, we won't do the semantic analysis now.\n  bool TypeDependent =\n      DestType->isDependentType() || Ex.get()->isTypeDependent();\n\n  CastOperation Op(*this, DestType, E);\n  Op.OpRange = SourceRange(OpLoc, Parens.getEnd());\n  Op.DestRange = AngleBrackets;\n\n  switch (Kind) {\n  default: llvm_unreachable(\"Unknown C++ cast!\");\n\n  case tok::kw_const_cast:\n    if (!TypeDependent) {\n      Op.CheckConstCast();\n      if (Op.SrcExpr.isInvalid())\n        return ExprError();\n      DiscardMisalignedMemberAddress(DestType.getTypePtr(), E);\n    }\n    return Op.complete(CXXConstCastExpr::Create(Context, Op.ResultType,\n                                  Op.ValueKind, Op.SrcExpr.get(), DestTInfo,\n                                                OpLoc, Parens.getEnd(),\n                                                AngleBrackets));\n\n  case tok::kw_dynamic_cast: {\n    if (!TypeDependent) {\n      Op.CheckDynamicCast();\n      if (Op.SrcExpr.isInvalid())\n        return ExprError();\n    }\n    return Op.complete(CXXDynamicCastExpr::Create(Context, Op.ResultType,\n                                    Op.ValueKind, Op.Kind, Op.SrcExpr.get(),\n                                                  &Op.BasePath, DestTInfo,\n                                                  OpLoc, Parens.getEnd(),\n                                                  AngleBrackets));\n  }\n  case tok::kw_reinterpret_cast: {\n    if (!TypeDependent) {\n      Op.CheckReinterpretCast();\n      if (Op.SrcExpr.isInvalid())\n        return ExprError();\n      DiscardMisalignedMemberAddress(DestType.getTypePtr(), E);\n    }\n    return Op.complete(CXXReinterpretCastExpr::Create(Context, Op.ResultType,\n                                    Op.ValueKind, Op.Kind, Op.SrcExpr.get(),\n                                                      nullptr, DestTInfo, OpLoc,\n                                                      Parens.getEnd(),\n                                                      AngleBrackets));\n  }\n  case tok::kw_static_cast: {\n    if (!TypeDependent) {\n      Op.CheckStaticCast();\n      if (Op.SrcExpr.isInvalid())\n        return ExprError();\n      DiscardMisalignedMemberAddress(DestType.getTypePtr(), E);\n    }\n    \n    return Op.complete(CXXStaticCastExpr::Create(Context, Op.ResultType,\n                                   Op.ValueKind, Op.Kind, Op.SrcExpr.get(),\n                                                 &Op.BasePath, DestTInfo,\n                                                 OpLoc, Parens.getEnd(),\n                                                 AngleBrackets));\n  }\n  }\n}\n\n/// Try to diagnose a failed overloaded cast.  Returns true if\n/// diagnostics were emitted.\nstatic bool tryDiagnoseOverloadedCast(Sema &S, CastType CT,\n                                      SourceRange range, Expr *src,\n                                      QualType destType,\n                                      bool listInitialization) {\n  switch (CT) {\n  // These cast kinds don't consider user-defined conversions.\n  case CT_Const:\n  case CT_Reinterpret:\n  case CT_Dynamic:\n    return false;\n\n  // These do.\n  case CT_Static:\n  case CT_CStyle:\n  case CT_Functional:\n    break;\n  }\n\n  QualType srcType = src->getType();\n  if (!destType->isRecordType() && !srcType->isRecordType())\n    return false;\n\n  InitializedEntity entity = InitializedEntity::InitializeTemporary(destType);\n  InitializationKind initKind\n    = (CT == CT_CStyle)? InitializationKind::CreateCStyleCast(range.getBegin(),\n                                                      range, listInitialization)\n    : (CT == CT_Functional)? InitializationKind::CreateFunctionalCast(range,\n                                                             listInitialization)\n    : InitializationKind::CreateCast(/*type range?*/ range);\n  InitializationSequence sequence(S, entity, initKind, src);\n\n  assert(sequence.Failed() && \"initialization succeeded on second try?\");\n  switch (sequence.getFailureKind()) {\n  default: return false;\n\n  case InitializationSequence::FK_ConstructorOverloadFailed:\n  case InitializationSequence::FK_UserConversionOverloadFailed:\n    break;\n  }\n\n  OverloadCandidateSet &candidates = sequence.getFailedCandidateSet();\n\n  unsigned msg = 0;\n  OverloadCandidateDisplayKind howManyCandidates = OCD_AllCandidates;\n\n  switch (sequence.getFailedOverloadResult()) {\n  case OR_Success: llvm_unreachable(\"successful failed overload\");\n  case OR_No_Viable_Function:\n    if (candidates.empty())\n      msg = diag::err_ovl_no_conversion_in_cast;\n    else\n      msg = diag::err_ovl_no_viable_conversion_in_cast;\n    howManyCandidates = OCD_AllCandidates;\n    break;\n\n  case OR_Ambiguous:\n    msg = diag::err_ovl_ambiguous_conversion_in_cast;\n    howManyCandidates = OCD_ViableCandidates;\n    break;\n\n  case OR_Deleted:\n    msg = diag::err_ovl_deleted_conversion_in_cast;\n    howManyCandidates = OCD_ViableCandidates;\n    break;\n  }\n\n  S.Diag(range.getBegin(), msg)\n    << CT << srcType << destType\n    << range << src->getSourceRange();\n\n  candidates.NoteCandidates(S, howManyCandidates, src);\n\n  return true;\n}\n\n/// Diagnose a failed cast.\nstatic void diagnoseBadCast(Sema &S, unsigned msg, CastType castType,\n                            SourceRange opRange, Expr *src, QualType destType,\n                            bool listInitialization) {\n  if (msg == diag::err_bad_cxx_cast_generic &&\n      tryDiagnoseOverloadedCast(S, castType, opRange, src, destType,\n                                listInitialization))\n    return;\n\n  S.Diag(opRange.getBegin(), msg) << castType\n    << src->getType() << destType << opRange << src->getSourceRange();\n\n  // Detect if both types are (ptr to) class, and note any incompleteness.\n  int DifferentPtrness = 0;\n  QualType From = destType;\n  if (auto Ptr = From->getAs<PointerType>()) {\n    From = Ptr->getPointeeType();\n    DifferentPtrness++;\n  }\n  QualType To = src->getType();\n  if (auto Ptr = To->getAs<PointerType>()) {\n    To = Ptr->getPointeeType();\n    DifferentPtrness--;\n  }\n  if (!DifferentPtrness) {\n    auto RecFrom = From->getAs<RecordType>();\n    auto RecTo = To->getAs<RecordType>();\n    if (RecFrom && RecTo) {\n      auto DeclFrom = RecFrom->getAsCXXRecordDecl();\n      if (!DeclFrom->isCompleteDefinition())\n        S.Diag(DeclFrom->getLocation(), diag::note_type_incomplete)\n          << DeclFrom->getDeclName();\n      auto DeclTo = RecTo->getAsCXXRecordDecl();\n      if (!DeclTo->isCompleteDefinition())\n        S.Diag(DeclTo->getLocation(), diag::note_type_incomplete)\n          << DeclTo->getDeclName();\n    }\n  }\n}\n\n/// UnwrapDissimilarPointerTypes - Like Sema::UnwrapSimilarPointerTypes,\n/// this removes one level of indirection from both types, provided that they're\n/// the same kind of pointer (plain or to-member). Unlike the Sema function,\n/// this one doesn't care if the two pointers-to-member don't point into the\n/// same class. This is because CastsAwayConstness doesn't care.\n/// And additionally, it handles C++ references. If both the types are\n/// references, then their pointee types are returned,\n/// else if only one of them is reference, it's pointee type is returned,\n/// and the other type is returned as-is.\nstatic bool UnwrapDissimilarPointerTypes(QualType& T1, QualType& T2) {\n  const PointerType *T1PtrType = T1->getAs<PointerType>(),\n                    *T2PtrType = T2->getAs<PointerType>();\n  if (T1PtrType && T2PtrType) {\n    T1 = T1PtrType->getPointeeType();\n    T2 = T2PtrType->getPointeeType();\n    return true;\n  }\n  const ObjCObjectPointerType *T1ObjCPtrType = \n                                            T1->getAs<ObjCObjectPointerType>(),\n                              *T2ObjCPtrType = \n                                            T2->getAs<ObjCObjectPointerType>();\n  if (T1ObjCPtrType) {\n    if (T2ObjCPtrType) {\n      T1 = T1ObjCPtrType->getPointeeType();\n      T2 = T2ObjCPtrType->getPointeeType();\n      return true;\n    }\n    else if (T2PtrType) {\n      T1 = T1ObjCPtrType->getPointeeType();\n      T2 = T2PtrType->getPointeeType();\n      return true;\n    }\n  }\n  else if (T2ObjCPtrType) {\n    if (T1PtrType) {\n      T2 = T2ObjCPtrType->getPointeeType();\n      T1 = T1PtrType->getPointeeType();\n      return true;\n    }\n  }\n  \n  const MemberPointerType *T1MPType = T1->getAs<MemberPointerType>(),\n                          *T2MPType = T2->getAs<MemberPointerType>();\n  if (T1MPType && T2MPType) {\n    T1 = T1MPType->getPointeeType();\n    T2 = T2MPType->getPointeeType();\n    return true;\n  }\n  \n  const BlockPointerType *T1BPType = T1->getAs<BlockPointerType>(),\n                         *T2BPType = T2->getAs<BlockPointerType>();\n  if (T1BPType && T2BPType) {\n    T1 = T1BPType->getPointeeType();\n    T2 = T2BPType->getPointeeType();\n    return true;\n  }\n  \n  const LValueReferenceType *T1RefType = T1->getAs<LValueReferenceType>(),\n                            *T2RefType = T2->getAs<LValueReferenceType>();\n  if (T1RefType && T2RefType) {\n    T1 = T1RefType->getPointeeType();\n    T2 = T2RefType->getPointeeType();\n    return true;\n  }\n\n  if (T1RefType) {\n    T1 = T1RefType->getPointeeType();\n    // T2 = T2;\n    return true;\n  }\n\n  if (T2RefType) {\n    // T1 = T1;\n    T2 = T2RefType->getPointeeType();\n    return true;\n  }\n\n  return false;\n}\n\n/// CastsAwayConstness - Check if the pointer conversion from SrcType to\n/// DestType casts away constness as defined in C++ 5.2.11p8ff. This is used by\n/// the cast checkers.  Both arguments must denote pointer (possibly to member)\n/// types.\n///\n/// \\param CheckCVR Whether to check for const/volatile/restrict qualifiers.\n///\n/// \\param CheckObjCLifetime Whether to check Objective-C lifetime qualifiers.\nstatic bool\nCastsAwayConstness(Sema &Self, QualType SrcType, QualType DestType,\n                   bool CheckCVR, bool CheckObjCLifetime,\n                   QualType *TheOffendingSrcType = nullptr,\n                   QualType *TheOffendingDestType = nullptr,\n                   Qualifiers *CastAwayQualifiers = nullptr) {\n  // If the only checking we care about is for Objective-C lifetime qualifiers,\n  // and we're not in ObjC mode, there's nothing to check.\n  if (!CheckCVR && CheckObjCLifetime && \n      !Self.Context.getLangOpts().ObjC1)\n    return false;\n    \n  // Casting away constness is defined in C++ 5.2.11p8 with reference to\n  // C++ 4.4. We piggyback on Sema::IsQualificationConversion for this, since\n  // the rules are non-trivial. So first we construct Tcv *...cv* as described\n  // in C++ 5.2.11p8.\n  assert((SrcType->isAnyPointerType() || SrcType->isMemberPointerType() ||\n          SrcType->isBlockPointerType() ||\n          DestType->isLValueReferenceType()) &&\n         \"Source type is not pointer or pointer to member.\");\n  assert((DestType->isAnyPointerType() || DestType->isMemberPointerType() ||\n          DestType->isBlockPointerType() ||\n          DestType->isLValueReferenceType()) &&\n         \"Destination type is not pointer or pointer to member, or reference.\");\n\n  QualType UnwrappedSrcType = Self.Context.getCanonicalType(SrcType), \n           UnwrappedDestType = Self.Context.getCanonicalType(DestType);\n  SmallVector<Qualifiers, 8> cv1, cv2;\n\n  // Find the qualifiers. We only care about cvr-qualifiers for the \n  // purpose of this check, because other qualifiers (address spaces, \n  // Objective-C GC, etc.) are part of the type's identity.\n  QualType PrevUnwrappedSrcType = UnwrappedSrcType;\n  QualType PrevUnwrappedDestType = UnwrappedDestType;\n  while (UnwrapDissimilarPointerTypes(UnwrappedSrcType, UnwrappedDestType)) {\n    // Determine the relevant qualifiers at this level.\n    Qualifiers SrcQuals, DestQuals;\n    Self.Context.getUnqualifiedArrayType(UnwrappedSrcType, SrcQuals);\n    Self.Context.getUnqualifiedArrayType(UnwrappedDestType, DestQuals);\n\n    // We do not meaningfully track object const-ness of Objective-C object\n    // types. Remove const from the source type if either the source or\n    // the destination is an Objective-C object type.\n    if (UnwrappedSrcType->isObjCObjectType() ||\n        UnwrappedDestType->isObjCObjectType())\n      SrcQuals.removeConst();\n\n    Qualifiers RetainedSrcQuals, RetainedDestQuals;\n    if (CheckCVR) {\n      RetainedSrcQuals.setCVRQualifiers(SrcQuals.getCVRQualifiers());\n      RetainedDestQuals.setCVRQualifiers(DestQuals.getCVRQualifiers());\n\n      if (RetainedSrcQuals != RetainedDestQuals && TheOffendingSrcType &&\n          TheOffendingDestType && CastAwayQualifiers) {\n        *TheOffendingSrcType = PrevUnwrappedSrcType;\n        *TheOffendingDestType = PrevUnwrappedDestType;\n        *CastAwayQualifiers = RetainedSrcQuals - RetainedDestQuals;\n      }\n    }\n    \n    if (CheckObjCLifetime &&\n        !DestQuals.compatiblyIncludesObjCLifetime(SrcQuals))\n      return true;\n    \n    cv1.push_back(RetainedSrcQuals);\n    cv2.push_back(RetainedDestQuals);\n\n    PrevUnwrappedSrcType = UnwrappedSrcType;\n    PrevUnwrappedDestType = UnwrappedDestType;\n  }\n  if (cv1.empty())\n    return false;\n\n  // Construct void pointers with those qualifiers (in reverse order of\n  // unwrapping, of course).\n  QualType SrcConstruct = Self.Context.VoidTy;\n  QualType DestConstruct = Self.Context.VoidTy;\n  ASTContext &Context = Self.Context;\n  for (SmallVectorImpl<Qualifiers>::reverse_iterator i1 = cv1.rbegin(),\n                                                     i2 = cv2.rbegin();\n       i1 != cv1.rend(); ++i1, ++i2) {\n    SrcConstruct\n      = Context.getPointerType(Context.getQualifiedType(SrcConstruct, *i1));\n    DestConstruct\n      = Context.getPointerType(Context.getQualifiedType(DestConstruct, *i2));\n  }\n\n  // Test if they're compatible.\n  bool ObjCLifetimeConversion;\n  return SrcConstruct != DestConstruct &&\n    !Self.IsQualificationConversion(SrcConstruct, DestConstruct, false,\n                                    ObjCLifetimeConversion);\n}\n\n/// CheckDynamicCast - Check that a dynamic_cast\\<DestType\\>(SrcExpr) is valid.\n/// Refer to C++ 5.2.7 for details. Dynamic casts are used mostly for runtime-\n/// checked downcasts in class hierarchies.\nvoid CastOperation::CheckDynamicCast() {\n  if (ValueKind == VK_RValue)\n    SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n  else if (isPlaceholder())\n    SrcExpr = Self.CheckPlaceholderExpr(SrcExpr.get());\n  if (SrcExpr.isInvalid()) // if conversion failed, don't report another error\n    return;\n\n  QualType OrigSrcType = SrcExpr.get()->getType();\n  QualType DestType = Self.Context.getCanonicalType(this->DestType);\n\n  // C++ 5.2.7p1: T shall be a pointer or reference to a complete class type,\n  //   or \"pointer to cv void\".\n\n  QualType DestPointee;\n  const PointerType *DestPointer = DestType->getAs<PointerType>();\n  const ReferenceType *DestReference = nullptr;\n  if (DestPointer) {\n    DestPointee = DestPointer->getPointeeType();\n  } else if ((DestReference = DestType->getAs<ReferenceType>())) {\n    DestPointee = DestReference->getPointeeType();\n  } else {\n    Self.Diag(OpRange.getBegin(), diag::err_bad_dynamic_cast_not_ref_or_ptr)\n      << this->DestType << DestRange;\n    SrcExpr = ExprError();\n    return;\n  }\n\n  const RecordType *DestRecord = DestPointee->getAs<RecordType>();\n  if (DestPointee->isVoidType()) {\n    assert(DestPointer && \"Reference to void is not possible\");\n  } else if (DestRecord) {\n    if (Self.RequireCompleteType(OpRange.getBegin(), DestPointee,\n                                 diag::err_bad_dynamic_cast_incomplete,\n                                 DestRange)) {\n      SrcExpr = ExprError();\n      return;\n    }\n  } else {\n    Self.Diag(OpRange.getBegin(), diag::err_bad_dynamic_cast_not_class)\n      << DestPointee.getUnqualifiedType() << DestRange;\n    SrcExpr = ExprError();\n    return;\n  }\n\n  // C++0x 5.2.7p2: If T is a pointer type, v shall be an rvalue of a pointer to\n  //   complete class type, [...]. If T is an lvalue reference type, v shall be\n  //   an lvalue of a complete class type, [...]. If T is an rvalue reference \n  //   type, v shall be an expression having a complete class type, [...]\n  QualType SrcType = Self.Context.getCanonicalType(OrigSrcType);\n  QualType SrcPointee;\n  if (DestPointer) {\n    if (const PointerType *SrcPointer = SrcType->getAs<PointerType>()) {\n      SrcPointee = SrcPointer->getPointeeType();\n    } else {\n      Self.Diag(OpRange.getBegin(), diag::err_bad_dynamic_cast_not_ptr)\n        << OrigSrcType << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n  } else if (DestReference->isLValueReferenceType()) {\n    if (!SrcExpr.get()->isLValue()) {\n      Self.Diag(OpRange.getBegin(), diag::err_bad_cxx_cast_rvalue)\n        << CT_Dynamic << OrigSrcType << this->DestType << OpRange;\n    }\n    SrcPointee = SrcType;\n  } else {\n    // If we're dynamic_casting from a prvalue to an rvalue reference, we need\n    // to materialize the prvalue before we bind the reference to it.\n    if (SrcExpr.get()->isRValue())\n      SrcExpr = Self.CreateMaterializeTemporaryExpr(\n          SrcType, SrcExpr.get(), /*IsLValueReference*/ false);\n    SrcPointee = SrcType;\n  }\n\n  const RecordType *SrcRecord = SrcPointee->getAs<RecordType>();\n  if (SrcRecord) {\n    if (Self.RequireCompleteType(OpRange.getBegin(), SrcPointee,\n                                 diag::err_bad_dynamic_cast_incomplete,\n                                 SrcExpr.get())) {\n      SrcExpr = ExprError();\n      return;\n    }\n  } else {\n    Self.Diag(OpRange.getBegin(), diag::err_bad_dynamic_cast_not_class)\n      << SrcPointee.getUnqualifiedType() << SrcExpr.get()->getSourceRange();\n    SrcExpr = ExprError();\n    return;\n  }\n\n  assert((DestPointer || DestReference) &&\n    \"Bad destination non-ptr/ref slipped through.\");\n  assert((DestRecord || DestPointee->isVoidType()) &&\n    \"Bad destination pointee slipped through.\");\n  assert(SrcRecord && \"Bad source pointee slipped through.\");\n\n  // C++ 5.2.7p1: The dynamic_cast operator shall not cast away constness.\n  if (!DestPointee.isAtLeastAsQualifiedAs(SrcPointee)) {\n    Self.Diag(OpRange.getBegin(), diag::err_bad_cxx_cast_qualifiers_away)\n      << CT_Dynamic << OrigSrcType << this->DestType << OpRange;\n    SrcExpr = ExprError();\n    return;\n  }\n\n  // C++ 5.2.7p3: If the type of v is the same as the required result type,\n  //   [except for cv].\n  if (DestRecord == SrcRecord) {\n    Kind = CK_NoOp;\n    return;\n  }\n\n  // C++ 5.2.7p5\n  // Upcasts are resolved statically.\n  if (DestRecord &&\n      Self.IsDerivedFrom(OpRange.getBegin(), SrcPointee, DestPointee)) {\n    if (Self.CheckDerivedToBaseConversion(SrcPointee, DestPointee,\n                                           OpRange.getBegin(), OpRange, \n                                           &BasePath)) {\n      SrcExpr = ExprError();\n      return;\n    }\n\n    Kind = CK_DerivedToBase;\n    return;\n  }\n\n  // C++ 5.2.7p6: Otherwise, v shall be [polymorphic].\n  const RecordDecl *SrcDecl = SrcRecord->getDecl()->getDefinition();\n  assert(SrcDecl && \"Definition missing\");\n  if (!cast<CXXRecordDecl>(SrcDecl)->isPolymorphic()) {\n    Self.Diag(OpRange.getBegin(), diag::err_bad_dynamic_cast_not_polymorphic)\n      << SrcPointee.getUnqualifiedType() << SrcExpr.get()->getSourceRange();\n    SrcExpr = ExprError();\n  }\n\n  // dynamic_cast is not available with -fno-rtti.\n  // As an exception, dynamic_cast to void* is available because it doesn't\n  // use RTTI.\n  if (!Self.getLangOpts().RTTI && !DestPointee->isVoidType()) {\n    Self.Diag(OpRange.getBegin(), diag::err_no_dynamic_cast_with_fno_rtti);\n    SrcExpr = ExprError();\n    return;\n  }\n\n  // Done. Everything else is run-time checks.\n  Kind = CK_Dynamic;\n}\n\n/// CheckConstCast - Check that a const_cast\\<DestType\\>(SrcExpr) is valid.\n/// Refer to C++ 5.2.11 for details. const_cast is typically used in code\n/// like this:\n/// const char *str = \"literal\";\n/// legacy_function(const_cast\\<char*\\>(str));\nvoid CastOperation::CheckConstCast() {\n  if (ValueKind == VK_RValue)\n    SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n  else if (isPlaceholder())\n    SrcExpr = Self.CheckPlaceholderExpr(SrcExpr.get());\n  if (SrcExpr.isInvalid()) // if conversion failed, don't report another error\n    return;\n\n  unsigned msg = diag::err_bad_cxx_cast_generic;\n  if (TryConstCast(Self, SrcExpr, DestType, /*CStyle*/false, msg) != TC_Success\n      && msg != 0) {\n    Self.Diag(OpRange.getBegin(), msg) << CT_Const\n      << SrcExpr.get()->getType() << DestType << OpRange;\n    SrcExpr = ExprError();\n  }\n}\n\n/// Check that a reinterpret_cast\\<DestType\\>(SrcExpr) is not used as upcast\n/// or downcast between respective pointers or references.\nstatic void DiagnoseReinterpretUpDownCast(Sema &Self, const Expr *SrcExpr,\n                                          QualType DestType,\n                                          SourceRange OpRange) {\n  QualType SrcType = SrcExpr->getType();\n  // When casting from pointer or reference, get pointee type; use original\n  // type otherwise.\n  const CXXRecordDecl *SrcPointeeRD = SrcType->getPointeeCXXRecordDecl();\n  const CXXRecordDecl *SrcRD =\n    SrcPointeeRD ? SrcPointeeRD : SrcType->getAsCXXRecordDecl();\n\n  // Examining subobjects for records is only possible if the complete and\n  // valid definition is available.  Also, template instantiation is not\n  // allowed here.\n  if (!SrcRD || !SrcRD->isCompleteDefinition() || SrcRD->isInvalidDecl())\n    return;\n\n  const CXXRecordDecl *DestRD = DestType->getPointeeCXXRecordDecl();\n\n  if (!DestRD || !DestRD->isCompleteDefinition() || DestRD->isInvalidDecl())\n    return;\n\n  enum {\n    ReinterpretUpcast,\n    ReinterpretDowncast\n  } ReinterpretKind;\n\n  CXXBasePaths BasePaths;\n\n  if (SrcRD->isDerivedFrom(DestRD, BasePaths))\n    ReinterpretKind = ReinterpretUpcast;\n  else if (DestRD->isDerivedFrom(SrcRD, BasePaths))\n    ReinterpretKind = ReinterpretDowncast;\n  else\n    return;\n\n  bool VirtualBase = true;\n  bool NonZeroOffset = false;\n  for (CXXBasePaths::const_paths_iterator I = BasePaths.begin(),\n                                          E = BasePaths.end();\n       I != E; ++I) {\n    const CXXBasePath &Path = *I;\n    CharUnits Offset = CharUnits::Zero();\n    bool IsVirtual = false;\n    for (CXXBasePath::const_iterator IElem = Path.begin(), EElem = Path.end();\n         IElem != EElem; ++IElem) {\n      IsVirtual = IElem->Base->isVirtual();\n      if (IsVirtual)\n        break;\n      const CXXRecordDecl *BaseRD = IElem->Base->getType()->getAsCXXRecordDecl();\n      assert(BaseRD && \"Base type should be a valid unqualified class type\");\n      // Don't check if any base has invalid declaration or has no definition\n      // since it has no layout info.\n      const CXXRecordDecl *Class = IElem->Class,\n                          *ClassDefinition = Class->getDefinition();\n      if (Class->isInvalidDecl() || !ClassDefinition ||\n          !ClassDefinition->isCompleteDefinition())\n        return;\n\n      const ASTRecordLayout &DerivedLayout =\n          Self.Context.getASTRecordLayout(Class);\n      Offset += DerivedLayout.getBaseClassOffset(BaseRD);\n    }\n    if (!IsVirtual) {\n      // Don't warn if any path is a non-virtually derived base at offset zero.\n      if (Offset.isZero())\n        return;\n      // Offset makes sense only for non-virtual bases.\n      else\n        NonZeroOffset = true;\n    }\n    VirtualBase = VirtualBase && IsVirtual;\n  }\n\n  (void) NonZeroOffset; // Silence set but not used warning.\n  assert((VirtualBase || NonZeroOffset) &&\n         \"Should have returned if has non-virtual base with zero offset\");\n\n  QualType BaseType =\n      ReinterpretKind == ReinterpretUpcast? DestType : SrcType;\n  QualType DerivedType =\n      ReinterpretKind == ReinterpretUpcast? SrcType : DestType;\n\n  SourceLocation BeginLoc = OpRange.getBegin();\n  Self.Diag(BeginLoc, diag::warn_reinterpret_different_from_static)\n    << DerivedType << BaseType << !VirtualBase << int(ReinterpretKind)\n    << OpRange;\n  Self.Diag(BeginLoc, diag::note_reinterpret_updowncast_use_static)\n    << int(ReinterpretKind)\n    << FixItHint::CreateReplacement(BeginLoc, \"static_cast\");\n}\n\n/// CheckReinterpretCast - Check that a reinterpret_cast\\<DestType\\>(SrcExpr) is\n/// valid.\n/// Refer to C++ 5.2.10 for details. reinterpret_cast is typically used in code\n/// like this:\n/// char *bytes = reinterpret_cast\\<char*\\>(int_ptr);\nvoid CastOperation::CheckReinterpretCast() {\n  if (ValueKind == VK_RValue && !isPlaceholder(BuiltinType::Overload))\n    SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n  else\n    checkNonOverloadPlaceholders();\n  if (SrcExpr.isInvalid()) // if conversion failed, don't report another error\n    return;\n\n  unsigned msg = diag::err_bad_cxx_cast_generic;\n  TryCastResult tcr = \n    TryReinterpretCast(Self, SrcExpr, DestType, \n                       /*CStyle*/false, OpRange, msg, Kind);\n  if (tcr != TC_Success && msg != 0)\n  {\n    if (SrcExpr.isInvalid()) // if conversion failed, don't report another error\n      return;\n    if (SrcExpr.get()->getType() == Self.Context.OverloadTy) {\n      //FIXME: &f<int>; is overloaded and resolvable \n      Self.Diag(OpRange.getBegin(), diag::err_bad_reinterpret_cast_overload) \n        << OverloadExpr::find(SrcExpr.get()).Expression->getName()\n        << DestType << OpRange;\n      Self.NoteAllOverloadCandidates(SrcExpr.get());\n\n    } else {\n      diagnoseBadCast(Self, msg, CT_Reinterpret, OpRange, SrcExpr.get(),\n                      DestType, /*listInitialization=*/false);\n    }\n    SrcExpr = ExprError();\n  } else if (tcr == TC_Success) {\n    if (Self.getLangOpts().allowsNonTrivialObjCLifetimeQualifiers())\n      checkObjCConversion(Sema::CCK_OtherCast);\n    DiagnoseReinterpretUpDownCast(Self, SrcExpr.get(), DestType, OpRange);\n  }\n}\n\n\n/// CheckStaticCast - Check that a static_cast\\<DestType\\>(SrcExpr) is valid.\n/// Refer to C++ 5.2.9 for details. Static casts are mostly used for making\n/// implicit conversions explicit and getting rid of data loss warnings.\nvoid CastOperation::CheckStaticCast() {\n  if (isPlaceholder()) {\n    checkNonOverloadPlaceholders();\n    if (SrcExpr.isInvalid())\n      return;\n  }\n\n  // This test is outside everything else because it's the only case where\n  // a non-lvalue-reference target type does not lead to decay.\n  // C++ 5.2.9p4: Any expression can be explicitly converted to type \"cv void\".\n  if (DestType->isVoidType()) {\n    Kind = CK_ToVoid;\n\n    if (claimPlaceholder(BuiltinType::Overload)) {\n      Self.ResolveAndFixSingleFunctionTemplateSpecialization(SrcExpr, \n                false, // Decay Function to ptr \n                true, // Complain\n                OpRange, DestType, diag::err_bad_static_cast_overload);\n      if (SrcExpr.isInvalid())\n        return;\n    }\n\n    SrcExpr = Self.IgnoredValueConversions(SrcExpr.get());\n    return;\n  }\n\n  if (ValueKind == VK_RValue && !DestType->isRecordType() &&\n      !isPlaceholder(BuiltinType::Overload)) {\n    SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n    if (SrcExpr.isInvalid()) // if conversion failed, don't report another error\n      return;\n  }\n\n  unsigned msg = diag::err_bad_cxx_cast_generic;\n  TryCastResult tcr\n    = TryStaticCast(Self, SrcExpr, DestType, Sema::CCK_OtherCast, OpRange, msg,\n                    Kind, BasePath, /*ListInitialization=*/false);\n  if (tcr != TC_Success && msg != 0) {\n    if (SrcExpr.isInvalid())\n      return;\n    if (SrcExpr.get()->getType() == Self.Context.OverloadTy) {\n      OverloadExpr* oe = OverloadExpr::find(SrcExpr.get()).Expression;\n      Self.Diag(OpRange.getBegin(), diag::err_bad_static_cast_overload)\n        << oe->getName() << DestType << OpRange \n        << oe->getQualifierLoc().getSourceRange();\n      Self.NoteAllOverloadCandidates(SrcExpr.get());\n    } else {\n      diagnoseBadCast(Self, msg, CT_Static, OpRange, SrcExpr.get(), DestType,\n                      /*listInitialization=*/false);\n    }\n    SrcExpr = ExprError();\n  } else if (tcr == TC_Success) {\n    if (Kind == CK_BitCast)\n      checkCastAlign();\n    if (Self.getLangOpts().allowsNonTrivialObjCLifetimeQualifiers())\n      checkObjCConversion(Sema::CCK_OtherCast);\n  } else if (Kind == CK_BitCast) {\n    checkCastAlign();\n  }\n}\n\n/// TryStaticCast - Check if a static cast can be performed, and do so if\n/// possible. If @p CStyle, ignore access restrictions on hierarchy casting\n/// and casting away constness.\nstatic TryCastResult TryStaticCast(Sema &Self, ExprResult &SrcExpr,\n                                   QualType DestType, \n                                   Sema::CheckedConversionKind CCK,\n                                   SourceRange OpRange, unsigned &msg,\n                                   CastKind &Kind, CXXCastPath &BasePath,\n                                   bool ListInitialization) {\n  // Determine whether we have the semantics of a C-style cast.\n  bool CStyle \n    = (CCK == Sema::CCK_CStyleCast || CCK == Sema::CCK_FunctionalCast);\n  \n  // The order the tests is not entirely arbitrary. There is one conversion\n  // that can be handled in two different ways. Given:\n  // struct A {};\n  // struct B : public A {\n  //   B(); B(const A&);\n  // };\n  // const A &a = B();\n  // the cast static_cast<const B&>(a) could be seen as either a static\n  // reference downcast, or an explicit invocation of the user-defined\n  // conversion using B's conversion constructor.\n  // DR 427 specifies that the downcast is to be applied here.\n\n  // C++ 5.2.9p4: Any expression can be explicitly converted to type \"cv void\".\n  // Done outside this function.\n\n  TryCastResult tcr;\n\n  // C++ 5.2.9p5, reference downcast.\n  // See the function for details.\n  // DR 427 specifies that this is to be applied before paragraph 2.\n  tcr = TryStaticReferenceDowncast(Self, SrcExpr.get(), DestType, CStyle,\n                                   OpRange, msg, Kind, BasePath);\n  if (tcr != TC_NotApplicable)\n    return tcr;\n\n  // C++11 [expr.static.cast]p3: \n  //   A glvalue of type \"cv1 T1\" can be cast to type \"rvalue reference to cv2\n  //   T2\" if \"cv2 T2\" is reference-compatible with \"cv1 T1\".\n  tcr = TryLValueToRValueCast(Self, SrcExpr.get(), DestType, CStyle, Kind,\n                              BasePath, msg);\n  if (tcr != TC_NotApplicable)\n    return tcr;\n\n  // C++ 5.2.9p2: An expression e can be explicitly converted to a type T\n  //   [...] if the declaration \"T t(e);\" is well-formed, [...].\n  tcr = TryStaticImplicitCast(Self, SrcExpr, DestType, CCK, OpRange, msg,\n                              Kind, ListInitialization);\n  if (SrcExpr.isInvalid())\n    return TC_Failed;\n  if (tcr != TC_NotApplicable)\n    return tcr;\n  \n  // C++ 5.2.9p6: May apply the reverse of any standard conversion, except\n  // lvalue-to-rvalue, array-to-pointer, function-to-pointer, and boolean\n  // conversions, subject to further restrictions.\n  // Also, C++ 5.2.9p1 forbids casting away constness, which makes reversal\n  // of qualification conversions impossible.\n  // In the CStyle case, the earlier attempt to const_cast should have taken\n  // care of reverse qualification conversions.\n\n  QualType SrcType = Self.Context.getCanonicalType(SrcExpr.get()->getType());\n\n  // C++0x 5.2.9p9: A value of a scoped enumeration type can be explicitly\n  // converted to an integral type. [...] A value of a scoped enumeration type\n  // can also be explicitly converted to a floating-point type [...].\n  if (const EnumType *Enum = SrcType->getAs<EnumType>()) {\n    if (Enum->getDecl()->isScoped()) {\n      if (DestType->isBooleanType()) {\n        Kind = CK_IntegralToBoolean;\n        return TC_Success;\n      } else if (DestType->isIntegralType(Self.Context)) {\n        Kind = CK_IntegralCast;\n        return TC_Success;\n      } else if (DestType->isRealFloatingType()) {\n        Kind = CK_IntegralToFloating;\n        return TC_Success;\n      }\n    }\n  }\n  \n  // Reverse integral promotion/conversion. All such conversions are themselves\n  // again integral promotions or conversions and are thus already handled by\n  // p2 (TryDirectInitialization above).\n  // (Note: any data loss warnings should be suppressed.)\n  // The exception is the reverse of enum->integer, i.e. integer->enum (and\n  // enum->enum). See also C++ 5.2.9p7.\n  // The same goes for reverse floating point promotion/conversion and\n  // floating-integral conversions. Again, only floating->enum is relevant.\n  if (DestType->isEnumeralType()) {\n    if (SrcType->isIntegralOrEnumerationType()) {\n      Kind = CK_IntegralCast;\n      return TC_Success;\n    } else if (SrcType->isRealFloatingType())   {\n      Kind = CK_FloatingToIntegral;\n      return TC_Success;\n    }\n  }\n\n  // Reverse pointer upcast. C++ 4.10p3 specifies pointer upcast.\n  // C++ 5.2.9p8 additionally disallows a cast path through virtual inheritance.\n  tcr = TryStaticPointerDowncast(Self, SrcType, DestType, CStyle, OpRange, msg,\n                                 Kind, BasePath);\n  if (tcr != TC_NotApplicable)\n    return tcr;\n\n  // Reverse member pointer conversion. C++ 4.11 specifies member pointer\n  // conversion. C++ 5.2.9p9 has additional information.\n  // DR54's access restrictions apply here also.\n  tcr = TryStaticMemberPointerUpcast(Self, SrcExpr, SrcType, DestType, CStyle,\n                                     OpRange, msg, Kind, BasePath);\n  if (tcr != TC_NotApplicable)\n    return tcr;\n\n  // Reverse pointer conversion to void*. C++ 4.10.p2 specifies conversion to\n  // void*. C++ 5.2.9p10 specifies additional restrictions, which really is\n  // just the usual constness stuff.\n  if (const PointerType *SrcPointer = SrcType->getAs<PointerType>()) {\n    QualType SrcPointee = SrcPointer->getPointeeType();\n    if (SrcPointee->isVoidType()) {\n      if (const PointerType *DestPointer = DestType->getAs<PointerType>()) {\n        QualType DestPointee = DestPointer->getPointeeType();\n        if (DestPointee->isIncompleteOrObjectType()) {\n          // This is definitely the intended conversion, but it might fail due\n          // to a qualifier violation. Note that we permit Objective-C lifetime\n          // and GC qualifier mismatches here.\n          if (!CStyle) {\n            Qualifiers DestPointeeQuals = DestPointee.getQualifiers();\n            Qualifiers SrcPointeeQuals = SrcPointee.getQualifiers();\n            DestPointeeQuals.removeObjCGCAttr();\n            DestPointeeQuals.removeObjCLifetime();\n            SrcPointeeQuals.removeObjCGCAttr();\n            SrcPointeeQuals.removeObjCLifetime();\n            if (DestPointeeQuals != SrcPointeeQuals &&\n                !DestPointeeQuals.compatiblyIncludes(SrcPointeeQuals)) {\n              msg = diag::err_bad_cxx_cast_qualifiers_away;\n              return TC_Failed;\n            }\n          }\n          Kind = CK_BitCast;\n          return TC_Success;\n        }\n\n        // Microsoft permits static_cast from 'pointer-to-void' to\n        // 'pointer-to-function'.\n        if (!CStyle && Self.getLangOpts().MSVCCompat &&\n            DestPointee->isFunctionType()) {\n          Self.Diag(OpRange.getBegin(), diag::ext_ms_cast_fn_obj) << OpRange;\n          Kind = CK_BitCast;\n          return TC_Success;\n        }\n      }\n      else if (DestType->isObjCObjectPointerType()) {\n        // allow both c-style cast and static_cast of objective-c pointers as \n        // they are pervasive.\n        Kind = CK_CPointerToObjCPointerCast;\n        return TC_Success;\n      }\n      else if (CStyle && DestType->isBlockPointerType()) {\n        // allow c-style cast of void * to block pointers.\n        Kind = CK_AnyPointerToBlockPointerCast;\n        return TC_Success;\n      }\n    }\n  }\n  // Allow arbitray objective-c pointer conversion with static casts.\n  if (SrcType->isObjCObjectPointerType() &&\n      DestType->isObjCObjectPointerType()) {\n    Kind = CK_BitCast;\n    return TC_Success;\n  }\n  // Allow ns-pointer to cf-pointer conversion in either direction\n  // with static casts.\n  if (!CStyle &&\n      Self.CheckTollFreeBridgeStaticCast(DestType, SrcExpr.get(), Kind))\n    return TC_Success;\n\n  // See if it looks like the user is trying to convert between\n  // related record types, and select a better diagnostic if so.\n  if (auto SrcPointer = SrcType->getAs<PointerType>())\n    if (auto DestPointer = DestType->getAs<PointerType>())\n      if (SrcPointer->getPointeeType()->getAs<RecordType>() &&\n          DestPointer->getPointeeType()->getAs<RecordType>())\n       msg = diag::err_bad_cxx_cast_unrelated_class;\n  \n  // We tried everything. Everything! Nothing works! :-(\n  return TC_NotApplicable;\n}\n\n/// Tests whether a conversion according to N2844 is valid.\nTryCastResult TryLValueToRValueCast(Sema &Self, Expr *SrcExpr,\n                                    QualType DestType, bool CStyle,\n                                    CastKind &Kind, CXXCastPath &BasePath,\n                                    unsigned &msg) {\n  // C++11 [expr.static.cast]p3:\n  //   A glvalue of type \"cv1 T1\" can be cast to type \"rvalue reference to\n  //   cv2 T2\" if \"cv2 T2\" is reference-compatible with \"cv1 T1\".\n  const RValueReferenceType *R = DestType->getAs<RValueReferenceType>();\n  if (!R)\n    return TC_NotApplicable;\n\n  if (!SrcExpr->isGLValue())\n    return TC_NotApplicable;\n\n  // Because we try the reference downcast before this function, from now on\n  // this is the only cast possibility, so we issue an error if we fail now.\n  // FIXME: Should allow casting away constness if CStyle.\n  bool DerivedToBase;\n  bool ObjCConversion;\n  bool ObjCLifetimeConversion;\n  QualType FromType = SrcExpr->getType();\n  QualType ToType = R->getPointeeType();\n  if (CStyle) {\n    FromType = FromType.getUnqualifiedType();\n    ToType = ToType.getUnqualifiedType();\n  }\n\n  Sema::ReferenceCompareResult RefResult = Self.CompareReferenceRelationship(\n      SrcExpr->getLocStart(), ToType, FromType, DerivedToBase, ObjCConversion,\n      ObjCLifetimeConversion);\n  if (RefResult != Sema::Ref_Compatible) {\n    if (CStyle || RefResult == Sema::Ref_Incompatible)\n      return TC_NotApplicable;\n    // Diagnose types which are reference-related but not compatible here since\n    // we can provide better diagnostics. In these cases forwarding to\n    // [expr.static.cast]p4 should never result in a well-formed cast.\n    msg = SrcExpr->isLValue() ? diag::err_bad_lvalue_to_rvalue_cast\n                              : diag::err_bad_rvalue_to_rvalue_cast;\n    return TC_Failed;\n  }\n\n  if (DerivedToBase) {\n    Kind = CK_DerivedToBase;\n    CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                       /*DetectVirtual=*/true);\n    if (!Self.IsDerivedFrom(SrcExpr->getLocStart(), SrcExpr->getType(),\n                            R->getPointeeType(), Paths))\n      return TC_NotApplicable;\n  \n    Self.BuildBasePathArray(Paths, BasePath);\n  } else\n    Kind = CK_NoOp;\n  \n  return TC_Success;\n}\n\n/// Tests whether a conversion according to C++ 5.2.9p5 is valid.\nTryCastResult\nTryStaticReferenceDowncast(Sema &Self, Expr *SrcExpr, QualType DestType,\n                           bool CStyle, SourceRange OpRange,\n                           unsigned &msg, CastKind &Kind,\n                           CXXCastPath &BasePath) {\n  // C++ 5.2.9p5: An lvalue of type \"cv1 B\", where B is a class type, can be\n  //   cast to type \"reference to cv2 D\", where D is a class derived from B,\n  //   if a valid standard conversion from \"pointer to D\" to \"pointer to B\"\n  //   exists, cv2 >= cv1, and B is not a virtual base class of D.\n  // In addition, DR54 clarifies that the base must be accessible in the\n  // current context. Although the wording of DR54 only applies to the pointer\n  // variant of this rule, the intent is clearly for it to apply to the this\n  // conversion as well.\n\n  const ReferenceType *DestReference = DestType->getAs<ReferenceType>();\n  if (!DestReference) {\n    return TC_NotApplicable;\n  }\n  bool RValueRef = DestReference->isRValueReferenceType();\n  if (!RValueRef && !SrcExpr->isLValue()) {\n    // We know the left side is an lvalue reference, so we can suggest a reason.\n    msg = diag::err_bad_cxx_cast_rvalue;\n    return TC_NotApplicable;\n  }\n\n  QualType DestPointee = DestReference->getPointeeType();\n\n  // FIXME: If the source is a prvalue, we should issue a warning (because the\n  // cast always has undefined behavior), and for AST consistency, we should\n  // materialize a temporary.\n  return TryStaticDowncast(Self, \n                           Self.Context.getCanonicalType(SrcExpr->getType()), \n                           Self.Context.getCanonicalType(DestPointee), CStyle,\n                           OpRange, SrcExpr->getType(), DestType, msg, Kind,\n                           BasePath);\n}\n\n/// Tests whether a conversion according to C++ 5.2.9p8 is valid.\nTryCastResult\nTryStaticPointerDowncast(Sema &Self, QualType SrcType, QualType DestType,\n                         bool CStyle, SourceRange OpRange,\n                         unsigned &msg, CastKind &Kind,\n                         CXXCastPath &BasePath) {\n  // C++ 5.2.9p8: An rvalue of type \"pointer to cv1 B\", where B is a class\n  //   type, can be converted to an rvalue of type \"pointer to cv2 D\", where D\n  //   is a class derived from B, if a valid standard conversion from \"pointer\n  //   to D\" to \"pointer to B\" exists, cv2 >= cv1, and B is not a virtual base\n  //   class of D.\n  // In addition, DR54 clarifies that the base must be accessible in the\n  // current context.\n\n  const PointerType *DestPointer = DestType->getAs<PointerType>();\n  if (!DestPointer) {\n    return TC_NotApplicable;\n  }\n\n  const PointerType *SrcPointer = SrcType->getAs<PointerType>();\n  if (!SrcPointer) {\n    msg = diag::err_bad_static_cast_pointer_nonpointer;\n    return TC_NotApplicable;\n  }\n\n  return TryStaticDowncast(Self, \n                   Self.Context.getCanonicalType(SrcPointer->getPointeeType()),\n                  Self.Context.getCanonicalType(DestPointer->getPointeeType()), \n                           CStyle, OpRange, SrcType, DestType, msg, Kind,\n                           BasePath);\n}\n\n/// TryStaticDowncast - Common functionality of TryStaticReferenceDowncast and\n/// TryStaticPointerDowncast. Tests whether a static downcast from SrcType to\n/// DestType is possible and allowed.\nTryCastResult\nTryStaticDowncast(Sema &Self, CanQualType SrcType, CanQualType DestType,\n                  bool CStyle, SourceRange OpRange, QualType OrigSrcType,\n                  QualType OrigDestType, unsigned &msg, \n                  CastKind &Kind, CXXCastPath &BasePath) {\n  // We can only work with complete types. But don't complain if it doesn't work\n  if (!Self.isCompleteType(OpRange.getBegin(), SrcType) ||\n      !Self.isCompleteType(OpRange.getBegin(), DestType))\n    return TC_NotApplicable;\n\n  // Downcast can only happen in class hierarchies, so we need classes.\n  if (!DestType->getAs<RecordType>() || !SrcType->getAs<RecordType>()) {\n    return TC_NotApplicable;\n  }\n\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                     /*DetectVirtual=*/true);\n  if (!Self.IsDerivedFrom(OpRange.getBegin(), DestType, SrcType, Paths)) {\n    return TC_NotApplicable;\n  }\n\n  // Target type does derive from source type. Now we're serious. If an error\n  // appears now, it's not ignored.\n  // This may not be entirely in line with the standard. Take for example:\n  // struct A {};\n  // struct B : virtual A {\n  //   B(A&);\n  // };\n  //\n  // void f()\n  // {\n  //   (void)static_cast<const B&>(*((A*)0));\n  // }\n  // As far as the standard is concerned, p5 does not apply (A is virtual), so\n  // p2 should be used instead - \"const B& t(*((A*)0));\" is perfectly valid.\n  // However, both GCC and Comeau reject this example, and accepting it would\n  // mean more complex code if we're to preserve the nice error message.\n  // FIXME: Being 100% compliant here would be nice to have.\n\n  // Must preserve cv, as always, unless we're in C-style mode.\n  if (!CStyle && !DestType.isAtLeastAsQualifiedAs(SrcType)) {\n    msg = diag::err_bad_cxx_cast_qualifiers_away;\n    return TC_Failed;\n  }\n\n  if (Paths.isAmbiguous(SrcType.getUnqualifiedType())) {\n    // This code is analoguous to that in CheckDerivedToBaseConversion, except\n    // that it builds the paths in reverse order.\n    // To sum up: record all paths to the base and build a nice string from\n    // them. Use it to spice up the error message.\n    if (!Paths.isRecordingPaths()) {\n      Paths.clear();\n      Paths.setRecordingPaths(true);\n      Self.IsDerivedFrom(OpRange.getBegin(), DestType, SrcType, Paths);\n    }\n    std::string PathDisplayStr;\n    std::set<unsigned> DisplayedPaths;\n    for (clang::CXXBasePath &Path : Paths) {\n      if (DisplayedPaths.insert(Path.back().SubobjectNumber).second) {\n        // We haven't displayed a path to this particular base\n        // class subobject yet.\n        PathDisplayStr += \"\\n    \";\n        for (CXXBasePathElement &PE : llvm::reverse(Path))\n          PathDisplayStr += PE.Base->getType().getAsString() + \" -> \";\n        PathDisplayStr += QualType(DestType).getAsString();\n      }\n    }\n\n    Self.Diag(OpRange.getBegin(), diag::err_ambiguous_base_to_derived_cast)\n      << QualType(SrcType).getUnqualifiedType() \n      << QualType(DestType).getUnqualifiedType()\n      << PathDisplayStr << OpRange;\n    msg = 0;\n    return TC_Failed;\n  }\n\n  if (Paths.getDetectedVirtual() != nullptr) {\n    QualType VirtualBase(Paths.getDetectedVirtual(), 0);\n    Self.Diag(OpRange.getBegin(), diag::err_static_downcast_via_virtual)\n      << OrigSrcType << OrigDestType << VirtualBase << OpRange;\n    msg = 0;\n    return TC_Failed;\n  }\n\n  if (!CStyle) {\n    switch (Self.CheckBaseClassAccess(OpRange.getBegin(),\n                                      SrcType, DestType,\n                                      Paths.front(),\n                                diag::err_downcast_from_inaccessible_base)) {\n    case Sema::AR_accessible:\n    case Sema::AR_delayed:     // be optimistic\n    case Sema::AR_dependent:   // be optimistic\n      break;\n\n    case Sema::AR_inaccessible:\n      msg = 0;\n      return TC_Failed;\n    }\n  }\n\n  Self.BuildBasePathArray(Paths, BasePath);\n  Kind = CK_BaseToDerived;\n  return TC_Success;\n}\n\n/// TryStaticMemberPointerUpcast - Tests whether a conversion according to\n/// C++ 5.2.9p9 is valid:\n///\n///   An rvalue of type \"pointer to member of D of type cv1 T\" can be\n///   converted to an rvalue of type \"pointer to member of B of type cv2 T\",\n///   where B is a base class of D [...].\n///\nTryCastResult\nTryStaticMemberPointerUpcast(Sema &Self, ExprResult &SrcExpr, QualType SrcType, \n                             QualType DestType, bool CStyle, \n                             SourceRange OpRange,\n                             unsigned &msg, CastKind &Kind,\n                             CXXCastPath &BasePath) {\n  const MemberPointerType *DestMemPtr = DestType->getAs<MemberPointerType>();\n  if (!DestMemPtr)\n    return TC_NotApplicable;\n\n  bool WasOverloadedFunction = false;\n  DeclAccessPair FoundOverload;\n  if (SrcExpr.get()->getType() == Self.Context.OverloadTy) {\n    if (FunctionDecl *Fn\n          = Self.ResolveAddressOfOverloadedFunction(SrcExpr.get(), DestType, false,\n                                                    FoundOverload)) {\n      CXXMethodDecl *M = cast<CXXMethodDecl>(Fn);\n      SrcType = Self.Context.getMemberPointerType(Fn->getType(),\n                      Self.Context.getTypeDeclType(M->getParent()).getTypePtr());\n      WasOverloadedFunction = true;\n    }\n  }\n  \n  const MemberPointerType *SrcMemPtr = SrcType->getAs<MemberPointerType>();\n  if (!SrcMemPtr) {\n    msg = diag::err_bad_static_cast_member_pointer_nonmp;\n    return TC_NotApplicable;\n  }\n\n  // Lock down the inheritance model right now in MS ABI, whether or not the\n  // pointee types are the same.\n  if (Self.Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    (void)Self.isCompleteType(OpRange.getBegin(), SrcType);\n    (void)Self.isCompleteType(OpRange.getBegin(), DestType);\n  }\n\n  // T == T, modulo cv\n  if (!Self.Context.hasSameUnqualifiedType(SrcMemPtr->getPointeeType(),\n                                           DestMemPtr->getPointeeType()))\n    return TC_NotApplicable;\n\n  // B base of D\n  QualType SrcClass(SrcMemPtr->getClass(), 0);\n  QualType DestClass(DestMemPtr->getClass(), 0);\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                  /*DetectVirtual=*/true);\n  if (!Self.IsDerivedFrom(OpRange.getBegin(), SrcClass, DestClass, Paths))\n    return TC_NotApplicable;\n\n  // B is a base of D. But is it an allowed base? If not, it's a hard error.\n  if (Paths.isAmbiguous(Self.Context.getCanonicalType(DestClass))) {\n    Paths.clear();\n    Paths.setRecordingPaths(true);\n    bool StillOkay =\n        Self.IsDerivedFrom(OpRange.getBegin(), SrcClass, DestClass, Paths);\n    assert(StillOkay);\n    (void)StillOkay;\n    std::string PathDisplayStr = Self.getAmbiguousPathsDisplayString(Paths);\n    Self.Diag(OpRange.getBegin(), diag::err_ambiguous_memptr_conv)\n      << 1 << SrcClass << DestClass << PathDisplayStr << OpRange;\n    msg = 0;\n    return TC_Failed;\n  }\n\n  if (const RecordType *VBase = Paths.getDetectedVirtual()) {\n    Self.Diag(OpRange.getBegin(), diag::err_memptr_conv_via_virtual)\n      << SrcClass << DestClass << QualType(VBase, 0) << OpRange;\n    msg = 0;\n    return TC_Failed;\n  }\n\n  if (!CStyle) {\n    switch (Self.CheckBaseClassAccess(OpRange.getBegin(),\n                                      DestClass, SrcClass,\n                                      Paths.front(),\n                                      diag::err_upcast_to_inaccessible_base)) {\n    case Sema::AR_accessible:\n    case Sema::AR_delayed:\n    case Sema::AR_dependent:\n      // Optimistically assume that the delayed and dependent cases\n      // will work out.\n      break;\n\n    case Sema::AR_inaccessible:\n      msg = 0;\n      return TC_Failed;\n    }\n  }\n\n  if (WasOverloadedFunction) {\n    // Resolve the address of the overloaded function again, this time\n    // allowing complaints if something goes wrong.\n    FunctionDecl *Fn = Self.ResolveAddressOfOverloadedFunction(SrcExpr.get(), \n                                                               DestType, \n                                                               true,\n                                                               FoundOverload);\n    if (!Fn) {\n      msg = 0;\n      return TC_Failed;\n    }\n\n    SrcExpr = Self.FixOverloadedFunctionReference(SrcExpr, FoundOverload, Fn);\n    if (!SrcExpr.isUsable()) {\n      msg = 0;\n      return TC_Failed;\n    }\n  }\n\n  Self.BuildBasePathArray(Paths, BasePath);\n  Kind = CK_DerivedToBaseMemberPointer;\n  return TC_Success;\n}\n\n/// TryStaticImplicitCast - Tests whether a conversion according to C++ 5.2.9p2\n/// is valid:\n///\n///   An expression e can be explicitly converted to a type T using a\n///   @c static_cast if the declaration \"T t(e);\" is well-formed [...].\nTryCastResult\nTryStaticImplicitCast(Sema &Self, ExprResult &SrcExpr, QualType DestType,\n                      Sema::CheckedConversionKind CCK, \n                      SourceRange OpRange, unsigned &msg,\n                      CastKind &Kind, bool ListInitialization) {\n  if (DestType->isRecordType()) {\n    if (Self.RequireCompleteType(OpRange.getBegin(), DestType,\n                                 diag::err_bad_dynamic_cast_incomplete) ||\n        Self.RequireNonAbstractType(OpRange.getBegin(), DestType,\n                                    diag::err_allocation_of_abstract_type)) {\n      msg = 0;\n      return TC_Failed;\n    }\n  }\n\n  InitializedEntity Entity = InitializedEntity::InitializeTemporary(DestType);\n  InitializationKind InitKind\n    = (CCK == Sema::CCK_CStyleCast)\n        ? InitializationKind::CreateCStyleCast(OpRange.getBegin(), OpRange,\n                                               ListInitialization)\n    : (CCK == Sema::CCK_FunctionalCast)\n        ? InitializationKind::CreateFunctionalCast(OpRange, ListInitialization)\n    : InitializationKind::CreateCast(OpRange);\n  Expr *SrcExprRaw = SrcExpr.get();\n  // FIXME: Per DR242, we should check for an implicit conversion sequence\n  // or for a constructor that could be invoked by direct-initialization\n  // here, not for an initialization sequence.\n  InitializationSequence InitSeq(Self, Entity, InitKind, SrcExprRaw);\n\n  // At this point of CheckStaticCast, if the destination is a reference,\n  // or the expression is an overload expression this has to work. \n  // There is no other way that works.\n  // On the other hand, if we're checking a C-style cast, we've still got\n  // the reinterpret_cast way.\n  bool CStyle \n    = (CCK == Sema::CCK_CStyleCast || CCK == Sema::CCK_FunctionalCast);\n  if (InitSeq.Failed() && (CStyle || !DestType->isReferenceType()))\n    return TC_NotApplicable;\n    \n  ExprResult Result = InitSeq.Perform(Self, Entity, InitKind, SrcExprRaw);\n  if (Result.isInvalid()) {\n    msg = 0;\n    return TC_Failed;\n  }\n  \n  if (InitSeq.isConstructorInitialization())\n    Kind = CK_ConstructorConversion;\n  else\n    Kind = CK_NoOp;\n  \n  SrcExpr = Result;\n  return TC_Success;\n}\n\n/// TryConstCast - See if a const_cast from source to destination is allowed,\n/// and perform it if it is.\nstatic TryCastResult TryConstCast(Sema &Self, ExprResult &SrcExpr,\n                                  QualType DestType, bool CStyle,\n                                  unsigned &msg) {\n  DestType = Self.Context.getCanonicalType(DestType);\n  QualType SrcType = SrcExpr.get()->getType();\n  bool NeedToMaterializeTemporary = false;\n\n  if (const ReferenceType *DestTypeTmp =DestType->getAs<ReferenceType>()) {\n    // C++11 5.2.11p4:\n    //   if a pointer to T1 can be explicitly converted to the type \"pointer to\n    //   T2\" using a const_cast, then the following conversions can also be\n    //   made:\n    //    -- an lvalue of type T1 can be explicitly converted to an lvalue of\n    //       type T2 using the cast const_cast<T2&>;\n    //    -- a glvalue of type T1 can be explicitly converted to an xvalue of\n    //       type T2 using the cast const_cast<T2&&>; and\n    //    -- if T1 is a class type, a prvalue of type T1 can be explicitly\n    //       converted to an xvalue of type T2 using the cast const_cast<T2&&>.\n\n    if (isa<LValueReferenceType>(DestTypeTmp) && !SrcExpr.get()->isLValue()) {\n      // Cannot const_cast non-lvalue to lvalue reference type. But if this\n      // is C-style, static_cast might find a way, so we simply suggest a\n      // message and tell the parent to keep searching.\n      msg = diag::err_bad_cxx_cast_rvalue;\n      return TC_NotApplicable;\n    }\n\n    if (isa<RValueReferenceType>(DestTypeTmp) && SrcExpr.get()->isRValue()) {\n      if (!SrcType->isRecordType()) {\n        // Cannot const_cast non-class prvalue to rvalue reference type. But if\n        // this is C-style, static_cast can do this.\n        msg = diag::err_bad_cxx_cast_rvalue;\n        return TC_NotApplicable;\n      }\n\n      // Materialize the class prvalue so that the const_cast can bind a\n      // reference to it.\n      NeedToMaterializeTemporary = true;\n    }\n\n    // It's not completely clear under the standard whether we can\n    // const_cast bit-field gl-values.  Doing so would not be\n    // intrinsically complicated, but for now, we say no for\n    // consistency with other compilers and await the word of the\n    // committee.\n    if (SrcExpr.get()->refersToBitField()) {\n      msg = diag::err_bad_cxx_cast_bitfield;\n      return TC_NotApplicable;\n    }\n\n    DestType = Self.Context.getPointerType(DestTypeTmp->getPointeeType());\n    SrcType = Self.Context.getPointerType(SrcType);\n  }\n\n  // C++ 5.2.11p5: For a const_cast involving pointers to data members [...]\n  //   the rules for const_cast are the same as those used for pointers.\n\n  if (!DestType->isPointerType() &&\n      !DestType->isMemberPointerType() &&\n      !DestType->isObjCObjectPointerType()) {\n    // Cannot cast to non-pointer, non-reference type. Note that, if DestType\n    // was a reference type, we converted it to a pointer above.\n    // The status of rvalue references isn't entirely clear, but it looks like\n    // conversion to them is simply invalid.\n    // C++ 5.2.11p3: For two pointer types [...]\n    if (!CStyle)\n      msg = diag::err_bad_const_cast_dest;\n    return TC_NotApplicable;\n  }\n  if (DestType->isFunctionPointerType() ||\n      DestType->isMemberFunctionPointerType()) {\n    // Cannot cast direct function pointers.\n    // C++ 5.2.11p2: [...] where T is any object type or the void type [...]\n    // T is the ultimate pointee of source and target type.\n    if (!CStyle)\n      msg = diag::err_bad_const_cast_dest;\n    return TC_NotApplicable;\n  }\n  SrcType = Self.Context.getCanonicalType(SrcType);\n\n  // Unwrap the pointers. Ignore qualifiers. Terminate early if the types are\n  // completely equal.\n  // C++ 5.2.11p3 describes the core semantics of const_cast. All cv specifiers\n  // in multi-level pointers may change, but the level count must be the same,\n  // as must be the final pointee type.\n  while (SrcType != DestType &&\n         Self.Context.UnwrapSimilarPointerTypes(SrcType, DestType)) {\n    Qualifiers SrcQuals, DestQuals;\n    SrcType = Self.Context.getUnqualifiedArrayType(SrcType, SrcQuals);\n    DestType = Self.Context.getUnqualifiedArrayType(DestType, DestQuals);\n    \n    // const_cast is permitted to strip cvr-qualifiers, only. Make sure that\n    // the other qualifiers (e.g., address spaces) are identical.\n    SrcQuals.removeCVRQualifiers();\n    DestQuals.removeCVRQualifiers();\n    if (SrcQuals != DestQuals)\n      return TC_NotApplicable;\n  }\n\n  // Since we're dealing in canonical types, the remainder must be the same.\n  if (SrcType != DestType)\n    return TC_NotApplicable;\n\n  if (NeedToMaterializeTemporary)\n    // This is a const_cast from a class prvalue to an rvalue reference type.\n    // Materialize a temporary to store the result of the conversion.\n    SrcExpr = Self.CreateMaterializeTemporaryExpr(SrcExpr.get()->getType(),\n                                                  SrcExpr.get(),\n                                                  /*IsLValueReference*/ false);\n\n  return TC_Success;\n}\n\n// Checks for undefined behavior in reinterpret_cast.\n// The cases that is checked for is:\n// *reinterpret_cast<T*>(&a)\n// reinterpret_cast<T&>(a)\n// where accessing 'a' as type 'T' will result in undefined behavior.\nvoid Sema::CheckCompatibleReinterpretCast(QualType SrcType, QualType DestType,\n                                          bool IsDereference,\n                                          SourceRange Range) {\n  unsigned DiagID = IsDereference ?\n                        diag::warn_pointer_indirection_from_incompatible_type :\n                        diag::warn_undefined_reinterpret_cast;\n\n  if (Diags.isIgnored(DiagID, Range.getBegin()))\n    return;\n\n  QualType SrcTy, DestTy;\n  if (IsDereference) {\n    if (!SrcType->getAs<PointerType>() || !DestType->getAs<PointerType>()) {\n      return;\n    }\n    SrcTy = SrcType->getPointeeType();\n    DestTy = DestType->getPointeeType();\n  } else {\n    if (!DestType->getAs<ReferenceType>()) {\n      return;\n    }\n    SrcTy = SrcType;\n    DestTy = DestType->getPointeeType();\n  }\n\n  // Cast is compatible if the types are the same.\n  if (Context.hasSameUnqualifiedType(DestTy, SrcTy)) {\n    return;\n  }\n  // or one of the types is a char or void type\n  if (DestTy->isAnyCharacterType() || DestTy->isVoidType() ||\n      SrcTy->isAnyCharacterType() || SrcTy->isVoidType()) {\n    return;\n  }\n  // or one of the types is a tag type.\n  if (SrcTy->getAs<TagType>() || DestTy->getAs<TagType>()) {\n    return;\n  }\n\n  // FIXME: Scoped enums?\n  if ((SrcTy->isUnsignedIntegerType() && DestTy->isSignedIntegerType()) ||\n      (SrcTy->isSignedIntegerType() && DestTy->isUnsignedIntegerType())) {\n    if (Context.getTypeSize(DestTy) == Context.getTypeSize(SrcTy)) {\n      return;\n    }\n  }\n\n  Diag(Range.getBegin(), DiagID) << SrcType << DestType << Range;\n}\n\nstatic void DiagnoseCastOfObjCSEL(Sema &Self, const ExprResult &SrcExpr,\n                                  QualType DestType) {\n  QualType SrcType = SrcExpr.get()->getType();\n  if (Self.Context.hasSameType(SrcType, DestType))\n    return;\n  if (const PointerType *SrcPtrTy = SrcType->getAs<PointerType>())\n    if (SrcPtrTy->isObjCSelType()) {\n      QualType DT = DestType;\n      if (isa<PointerType>(DestType))\n        DT = DestType->getPointeeType();\n      if (!DT.getUnqualifiedType()->isVoidType())\n        Self.Diag(SrcExpr.get()->getExprLoc(),\n                  diag::warn_cast_pointer_from_sel)\n        << SrcType << DestType << SrcExpr.get()->getSourceRange();\n    }\n}\n\n/// Diagnose casts that change the calling convention of a pointer to a function\n/// defined in the current TU.\nstatic void DiagnoseCallingConvCast(Sema &Self, const ExprResult &SrcExpr,\n                                    QualType DstType, SourceRange OpRange) {\n  // Check if this cast would change the calling convention of a function\n  // pointer type.\n  QualType SrcType = SrcExpr.get()->getType();\n  if (Self.Context.hasSameType(SrcType, DstType) ||\n      !SrcType->isFunctionPointerType() || !DstType->isFunctionPointerType())\n    return;\n  const auto *SrcFTy =\n      SrcType->castAs<PointerType>()->getPointeeType()->castAs<FunctionType>();\n  const auto *DstFTy =\n      DstType->castAs<PointerType>()->getPointeeType()->castAs<FunctionType>();\n  CallingConv SrcCC = SrcFTy->getCallConv();\n  CallingConv DstCC = DstFTy->getCallConv();\n  if (SrcCC == DstCC)\n    return;\n\n  // We have a calling convention cast. Check if the source is a pointer to a\n  // known, specific function that has already been defined.\n  Expr *Src = SrcExpr.get()->IgnoreParenImpCasts();\n  if (auto *UO = dyn_cast<UnaryOperator>(Src))\n    if (UO->getOpcode() == UO_AddrOf)\n      Src = UO->getSubExpr()->IgnoreParenImpCasts();\n  auto *DRE = dyn_cast<DeclRefExpr>(Src);\n  if (!DRE)\n    return;\n  auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl());\n  if (!FD)\n    return;\n\n  // Only warn if we are casting from the default convention to a non-default\n  // convention. This can happen when the programmer forgot to apply the calling\n  // convention to the function declaration and then inserted this cast to\n  // satisfy the type system.\n  CallingConv DefaultCC = Self.getASTContext().getDefaultCallingConvention(\n      FD->isVariadic(), FD->isCXXInstanceMember());\n  if (DstCC == DefaultCC || SrcCC != DefaultCC)\n    return;\n\n  // Diagnose this cast, as it is probably bad.\n  StringRef SrcCCName = FunctionType::getNameForCallConv(SrcCC);\n  StringRef DstCCName = FunctionType::getNameForCallConv(DstCC);\n  Self.Diag(OpRange.getBegin(), diag::warn_cast_calling_conv)\n      << SrcCCName << DstCCName << OpRange;\n\n  // The checks above are cheaper than checking if the diagnostic is enabled.\n  // However, it's worth checking if the warning is enabled before we construct\n  // a fixit.\n  if (Self.Diags.isIgnored(diag::warn_cast_calling_conv, OpRange.getBegin()))\n    return;\n\n  // Try to suggest a fixit to change the calling convention of the function\n  // whose address was taken. Try to use the latest macro for the convention.\n  // For example, users probably want to write \"WINAPI\" instead of \"__stdcall\"\n  // to match the Windows header declarations.\n  SourceLocation NameLoc = FD->getFirstDecl()->getNameInfo().getLoc();\n  Preprocessor &PP = Self.getPreprocessor();\n  SmallVector<TokenValue, 6> AttrTokens;\n  SmallString<64> CCAttrText;\n  llvm::raw_svector_ostream OS(CCAttrText);\n  if (Self.getLangOpts().MicrosoftExt) {\n    // __stdcall or __vectorcall\n    OS << \"__\" << DstCCName;\n    IdentifierInfo *II = PP.getIdentifierInfo(OS.str());\n    AttrTokens.push_back(II->isKeyword(Self.getLangOpts())\n                             ? TokenValue(II->getTokenID())\n                             : TokenValue(II));\n  } else {\n    // __attribute__((stdcall)) or __attribute__((vectorcall))\n    OS << \"__attribute__((\" << DstCCName << \"))\";\n    AttrTokens.push_back(tok::kw___attribute);\n    AttrTokens.push_back(tok::l_paren);\n    AttrTokens.push_back(tok::l_paren);\n    IdentifierInfo *II = PP.getIdentifierInfo(DstCCName);\n    AttrTokens.push_back(II->isKeyword(Self.getLangOpts())\n                             ? TokenValue(II->getTokenID())\n                             : TokenValue(II));\n    AttrTokens.push_back(tok::r_paren);\n    AttrTokens.push_back(tok::r_paren);\n  }\n  StringRef AttrSpelling = PP.getLastMacroWithSpelling(NameLoc, AttrTokens);\n  if (!AttrSpelling.empty())\n    CCAttrText = AttrSpelling;\n  OS << ' ';\n  Self.Diag(NameLoc, diag::note_change_calling_conv_fixit)\n      << FD << DstCCName << FixItHint::CreateInsertion(NameLoc, CCAttrText);\n}\n\nstatic void checkIntToPointerCast(bool CStyle, SourceLocation Loc,\n                                  const Expr *SrcExpr, QualType DestType,\n                                  Sema &Self) {\n  QualType SrcType = SrcExpr->getType();\n\n  // Not warning on reinterpret_cast, boolean, constant expressions, etc\n  // are not explicit design choices, but consistent with GCC's behavior.\n  // Feel free to modify them if you've reason/evidence for an alternative.\n  if (CStyle && SrcType->isIntegralType(Self.Context)\n      && !SrcType->isBooleanType()\n      && !SrcType->isEnumeralType()\n      && !SrcExpr->isIntegerConstantExpr(Self.Context)\n      && Self.Context.getTypeSize(DestType) >\n         Self.Context.getTypeSize(SrcType)) {\n    // Separate between casts to void* and non-void* pointers.\n    // Some APIs use (abuse) void* for something like a user context,\n    // and often that value is an integer even if it isn't a pointer itself.\n    // Having a separate warning flag allows users to control the warning\n    // for their workflow.\n    unsigned Diag = DestType->isVoidPointerType() ?\n                      diag::warn_int_to_void_pointer_cast\n                    : diag::warn_int_to_pointer_cast;\n    Self.Diag(Loc, Diag) << SrcType << DestType;\n  }\n}\n\nstatic bool fixOverloadedReinterpretCastExpr(Sema &Self, QualType DestType,\n                                             ExprResult &Result) {\n  // We can only fix an overloaded reinterpret_cast if\n  // - it is a template with explicit arguments that resolves to an lvalue\n  //   unambiguously, or\n  // - it is the only function in an overload set that may have its address\n  //   taken.\n\n  Expr *E = Result.get();\n  // TODO: what if this fails because of DiagnoseUseOfDecl or something\n  // like it?\n  if (Self.ResolveAndFixSingleFunctionTemplateSpecialization(\n          Result,\n          Expr::getValueKindForType(DestType) == VK_RValue // Convert Fun to Ptr\n          ) &&\n      Result.isUsable())\n    return true;\n\n  // No guarantees that ResolveAndFixSingleFunctionTemplateSpecialization\n  // preserves Result.\n  Result = E;\n  if (!Self.resolveAndFixAddressOfOnlyViableOverloadCandidate(\n          Result, /*DoFunctionPointerConversion=*/true))\n    return false;\n  return Result.isUsable();\n}\n\nstatic TryCastResult TryReinterpretCast(Sema &Self, ExprResult &SrcExpr,\n                                        QualType DestType, bool CStyle,\n                                        SourceRange OpRange,\n                                        unsigned &msg,\n                                        CastKind &Kind) {\n  bool IsLValueCast = false;\n  \n  DestType = Self.Context.getCanonicalType(DestType);\n  QualType SrcType = SrcExpr.get()->getType();\n\n  // Is the source an overloaded name? (i.e. &foo)\n  // If so, reinterpret_cast generally can not help us here (13.4, p1, bullet 5)\n  if (SrcType == Self.Context.OverloadTy) {\n    ExprResult FixedExpr = SrcExpr;\n    if (!fixOverloadedReinterpretCastExpr(Self, DestType, FixedExpr))\n      return TC_NotApplicable;\n\n    assert(FixedExpr.isUsable() && \"Invalid result fixing overloaded expr\");\n    SrcExpr = FixedExpr;\n    SrcType = SrcExpr.get()->getType();\n  }\n\n  if (const ReferenceType *DestTypeTmp = DestType->getAs<ReferenceType>()) {\n    if (!SrcExpr.get()->isGLValue()) {\n      // Cannot cast non-glvalue to (lvalue or rvalue) reference type. See the\n      // similar comment in const_cast.\n      msg = diag::err_bad_cxx_cast_rvalue;\n      return TC_NotApplicable;\n    }\n\n    if (!CStyle) {\n      Self.CheckCompatibleReinterpretCast(SrcType, DestType,\n                                          /*isDereference=*/false, OpRange);\n    }\n\n    // C++ 5.2.10p10: [...] a reference cast reinterpret_cast<T&>(x) has the\n    //   same effect as the conversion *reinterpret_cast<T*>(&x) with the\n    //   built-in & and * operators.\n\n    const char *inappropriate = nullptr;\n    switch (SrcExpr.get()->getObjectKind()) {\n    case OK_Ordinary:\n      break;\n    case OK_BitField:\n      msg = diag::err_bad_cxx_cast_bitfield;\n      return TC_NotApplicable;\n      // FIXME: Use a specific diagnostic for the rest of these cases.\n    case OK_VectorComponent: inappropriate = \"vector element\";      break;\n    case OK_ObjCProperty:    inappropriate = \"property expression\"; break;\n    case OK_ObjCSubscript:   inappropriate = \"container subscripting expression\"; \n                             break;\n    }\n    if (inappropriate) {\n      Self.Diag(OpRange.getBegin(), diag::err_bad_reinterpret_cast_reference)\n          << inappropriate << DestType\n          << OpRange << SrcExpr.get()->getSourceRange();\n      msg = 0; SrcExpr = ExprError();\n      return TC_NotApplicable;\n    }\n\n    // This code does this transformation for the checked types.\n    DestType = Self.Context.getPointerType(DestTypeTmp->getPointeeType());\n    SrcType = Self.Context.getPointerType(SrcType);\n    \n    IsLValueCast = true;\n  }\n\n  // Canonicalize source for comparison.\n  SrcType = Self.Context.getCanonicalType(SrcType);\n\n  const MemberPointerType *DestMemPtr = DestType->getAs<MemberPointerType>(),\n                          *SrcMemPtr = SrcType->getAs<MemberPointerType>();\n  if (DestMemPtr && SrcMemPtr) {\n    // C++ 5.2.10p9: An rvalue of type \"pointer to member of X of type T1\"\n    //   can be explicitly converted to an rvalue of type \"pointer to member\n    //   of Y of type T2\" if T1 and T2 are both function types or both object\n    //   types.\n    if (DestMemPtr->isMemberFunctionPointer() !=\n        SrcMemPtr->isMemberFunctionPointer())\n      return TC_NotApplicable;\n\n    // C++ 5.2.10p2: The reinterpret_cast operator shall not cast away\n    //   constness.\n    // A reinterpret_cast followed by a const_cast can, though, so in C-style,\n    // we accept it.\n    if (CastsAwayConstness(Self, SrcType, DestType, /*CheckCVR=*/!CStyle,\n                           /*CheckObjCLifetime=*/CStyle)) {\n      msg = diag::err_bad_cxx_cast_qualifiers_away;\n      return TC_Failed;\n    }\n\n    if (Self.Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n      // We need to determine the inheritance model that the class will use if\n      // haven't yet.\n      (void)Self.isCompleteType(OpRange.getBegin(), SrcType);\n      (void)Self.isCompleteType(OpRange.getBegin(), DestType);\n    }\n\n    // Don't allow casting between member pointers of different sizes.\n    if (Self.Context.getTypeSize(DestMemPtr) !=\n        Self.Context.getTypeSize(SrcMemPtr)) {\n      msg = diag::err_bad_cxx_cast_member_pointer_size;\n      return TC_Failed;\n    }\n\n    // A valid member pointer cast.\n    assert(!IsLValueCast);\n    Kind = CK_ReinterpretMemberPointer;\n    return TC_Success;\n  }\n\n  // See below for the enumeral issue.\n  if (SrcType->isNullPtrType() && DestType->isIntegralType(Self.Context)) {\n    // C++0x 5.2.10p4: A pointer can be explicitly converted to any integral\n    //   type large enough to hold it. A value of std::nullptr_t can be\n    //   converted to an integral type; the conversion has the same meaning\n    //   and validity as a conversion of (void*)0 to the integral type.\n    if (Self.Context.getTypeSize(SrcType) >\n        Self.Context.getTypeSize(DestType)) {\n      msg = diag::err_bad_reinterpret_cast_small_int;\n      return TC_Failed;\n    }\n    Kind = CK_PointerToIntegral;\n    return TC_Success;\n  }\n\n  // Allow reinterpret_casts between vectors of the same size and\n  // between vectors and integers of the same size.\n  bool destIsVector = DestType->isVectorType();\n  bool srcIsVector = SrcType->isVectorType();\n  if (srcIsVector || destIsVector) {\n    // The non-vector type, if any, must have integral type.  This is\n    // the same rule that C vector casts use; note, however, that enum\n    // types are not integral in C++.\n    if ((!destIsVector && !DestType->isIntegralType(Self.Context)) ||\n        (!srcIsVector && !SrcType->isIntegralType(Self.Context)))\n      return TC_NotApplicable;\n\n    // The size we want to consider is eltCount * eltSize.\n    // That's exactly what the lax-conversion rules will check.\n    if (Self.areLaxCompatibleVectorTypes(SrcType, DestType)) {\n      Kind = CK_BitCast;\n      return TC_Success;\n    }\n\n    // Otherwise, pick a reasonable diagnostic.\n    if (!destIsVector)\n      msg = diag::err_bad_cxx_cast_vector_to_scalar_different_size;\n    else if (!srcIsVector)\n      msg = diag::err_bad_cxx_cast_scalar_to_vector_different_size;\n    else\n      msg = diag::err_bad_cxx_cast_vector_to_vector_different_size;\n    \n    return TC_Failed;\n  }\n\n  if (SrcType == DestType) {\n    // C++ 5.2.10p2 has a note that mentions that, subject to all other\n    // restrictions, a cast to the same type is allowed so long as it does not\n    // cast away constness. In C++98, the intent was not entirely clear here, \n    // since all other paragraphs explicitly forbid casts to the same type.\n    // C++11 clarifies this case with p2.\n    //\n    // The only allowed types are: integral, enumeration, pointer, or \n    // pointer-to-member types.  We also won't restrict Obj-C pointers either.\n    Kind = CK_NoOp;\n    TryCastResult Result = TC_NotApplicable;\n    if (SrcType->isIntegralOrEnumerationType() ||\n        SrcType->isAnyPointerType() ||\n        SrcType->isMemberPointerType() ||\n        SrcType->isBlockPointerType()) {\n      Result = TC_Success;\n    }\n    return Result;\n  }\n\n  bool destIsPtr = DestType->isAnyPointerType() ||\n                   DestType->isBlockPointerType();\n  bool srcIsPtr = SrcType->isAnyPointerType() ||\n                  SrcType->isBlockPointerType();\n  if (!destIsPtr && !srcIsPtr) {\n    // Except for std::nullptr_t->integer and lvalue->reference, which are\n    // handled above, at least one of the two arguments must be a pointer.\n    return TC_NotApplicable;\n  }\n\n  if (DestType->isIntegralType(Self.Context)) {\n    assert(srcIsPtr && \"One type must be a pointer\");\n    // C++ 5.2.10p4: A pointer can be explicitly converted to any integral\n    //   type large enough to hold it; except in Microsoft mode, where the\n    //   integral type size doesn't matter (except we don't allow bool).\n    bool MicrosoftException = Self.getLangOpts().MicrosoftExt &&\n                              !DestType->isBooleanType();\n    if ((Self.Context.getTypeSize(SrcType) >\n         Self.Context.getTypeSize(DestType)) &&\n         !MicrosoftException) {\n      msg = diag::err_bad_reinterpret_cast_small_int;\n      return TC_Failed;\n    }\n    Kind = CK_PointerToIntegral;\n    return TC_Success;\n  }\n\n  if (SrcType->isIntegralOrEnumerationType()) {\n    assert(destIsPtr && \"One type must be a pointer\");\n    checkIntToPointerCast(CStyle, OpRange.getBegin(), SrcExpr.get(), DestType,\n                          Self);\n    // C++ 5.2.10p5: A value of integral or enumeration type can be explicitly\n    //   converted to a pointer.\n    // C++ 5.2.10p9: [Note: ...a null pointer constant of integral type is not\n    //   necessarily converted to a null pointer value.]\n    Kind = CK_IntegralToPointer;\n    return TC_Success;\n  }\n\n  if (!destIsPtr || !srcIsPtr) {\n    // With the valid non-pointer conversions out of the way, we can be even\n    // more stringent.\n    return TC_NotApplicable;\n  }\n\n  // C++ 5.2.10p2: The reinterpret_cast operator shall not cast away constness.\n  // The C-style cast operator can.\n  if (CastsAwayConstness(Self, SrcType, DestType, /*CheckCVR=*/!CStyle,\n                         /*CheckObjCLifetime=*/CStyle)) {\n    msg = diag::err_bad_cxx_cast_qualifiers_away;\n    return TC_Failed;\n  }\n  \n  // Cannot convert between block pointers and Objective-C object pointers.\n  if ((SrcType->isBlockPointerType() && DestType->isObjCObjectPointerType()) ||\n      (DestType->isBlockPointerType() && SrcType->isObjCObjectPointerType()))\n    return TC_NotApplicable;\n\n  if (IsLValueCast) {\n    Kind = CK_LValueBitCast;\n  } else if (DestType->isObjCObjectPointerType()) {\n    Kind = Self.PrepareCastToObjCObjectPointer(SrcExpr);\n  } else if (DestType->isBlockPointerType()) {\n    if (!SrcType->isBlockPointerType()) {\n      Kind = CK_AnyPointerToBlockPointerCast;\n    } else {\n      Kind = CK_BitCast;\n    }\n  } else {\n    Kind = CK_BitCast;\n  }\n\n  // Any pointer can be cast to an Objective-C pointer type with a C-style\n  // cast.\n  if (CStyle && DestType->isObjCObjectPointerType()) {\n    return TC_Success;\n  }\n  if (CStyle)\n    DiagnoseCastOfObjCSEL(Self, SrcExpr, DestType);\n\n  DiagnoseCallingConvCast(Self, SrcExpr, DestType, OpRange);\n\n  // Not casting away constness, so the only remaining check is for compatible\n  // pointer categories.\n\n  if (SrcType->isFunctionPointerType()) {\n    if (DestType->isFunctionPointerType()) {\n      // C++ 5.2.10p6: A pointer to a function can be explicitly converted to\n      // a pointer to a function of a different type.\n      return TC_Success;\n    }\n\n    // C++0x 5.2.10p8: Converting a pointer to a function into a pointer to\n    //   an object type or vice versa is conditionally-supported.\n    // Compilers support it in C++03 too, though, because it's necessary for\n    // casting the return value of dlsym() and GetProcAddress().\n    // FIXME: Conditionally-supported behavior should be configurable in the\n    // TargetInfo or similar.\n    Self.Diag(OpRange.getBegin(),\n              Self.getLangOpts().CPlusPlus11 ?\n                diag::warn_cxx98_compat_cast_fn_obj : diag::ext_cast_fn_obj)\n      << OpRange;\n    return TC_Success;\n  }\n\n  if (DestType->isFunctionPointerType()) {\n    // See above.\n    Self.Diag(OpRange.getBegin(),\n              Self.getLangOpts().CPlusPlus11 ?\n                diag::warn_cxx98_compat_cast_fn_obj : diag::ext_cast_fn_obj)\n      << OpRange;\n    return TC_Success;\n  }\n  \n  // C++ 5.2.10p7: A pointer to an object can be explicitly converted to\n  //   a pointer to an object of different type.\n  // Void pointers are not specified, but supported by every compiler out there.\n  // So we finish by allowing everything that remains - it's got to be two\n  // object pointers.\n  return TC_Success;\n}                                     \n\nvoid CastOperation::CheckCXXCStyleCast(bool FunctionalStyle,\n                                       bool ListInitialization) {\n  assert(Self.getLangOpts().CPlusPlus);\n\n  // Handle placeholders.\n  if (isPlaceholder()) {\n    // C-style casts can resolve __unknown_any types.\n    if (claimPlaceholder(BuiltinType::UnknownAny)) {\n      SrcExpr = Self.checkUnknownAnyCast(DestRange, DestType,\n                                         SrcExpr.get(), Kind,\n                                         ValueKind, BasePath);\n      return;\n    }\n\n    checkNonOverloadPlaceholders();\n    if (SrcExpr.isInvalid())\n      return;\n  }\n\n  // C++ 5.2.9p4: Any expression can be explicitly converted to type \"cv void\".\n  // This test is outside everything else because it's the only case where\n  // a non-lvalue-reference target type does not lead to decay.\n  if (DestType->isVoidType()) {\n    Kind = CK_ToVoid;\n\n    if (claimPlaceholder(BuiltinType::Overload)) {\n      Self.ResolveAndFixSingleFunctionTemplateSpecialization(\n                  SrcExpr, /* Decay Function to ptr */ false, \n                  /* Complain */ true, DestRange, DestType,\n                  diag::err_bad_cstyle_cast_overload);\n      if (SrcExpr.isInvalid())\n        return;\n    }\n\n    SrcExpr = Self.IgnoredValueConversions(SrcExpr.get());\n    return;\n  }\n\n  // If the type is dependent, we won't do any other semantic analysis now.\n  if (DestType->isDependentType() || SrcExpr.get()->isTypeDependent() ||\n      SrcExpr.get()->isValueDependent()) {\n    assert(Kind == CK_Dependent);\n    return;\n  }\n\n  if (ValueKind == VK_RValue && !DestType->isRecordType() &&\n      !isPlaceholder(BuiltinType::Overload)) {\n    SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n    if (SrcExpr.isInvalid())\n      return;\n  }\n\n  // AltiVec vector initialization with a single literal.\n  if (const VectorType *vecTy = DestType->getAs<VectorType>())\n    if (vecTy->getVectorKind() == VectorType::AltiVecVector\n        && (SrcExpr.get()->getType()->isIntegerType()\n            || SrcExpr.get()->getType()->isFloatingType())) {\n      Kind = CK_VectorSplat;\n      SrcExpr = Self.prepareVectorSplat(DestType, SrcExpr.get());\n      return;\n    }\n\n  // C++ [expr.cast]p5: The conversions performed by\n  //   - a const_cast,\n  //   - a static_cast,\n  //   - a static_cast followed by a const_cast,\n  //   - a reinterpret_cast, or\n  //   - a reinterpret_cast followed by a const_cast,\n  //   can be performed using the cast notation of explicit type conversion.\n  //   [...] If a conversion can be interpreted in more than one of the ways\n  //   listed above, the interpretation that appears first in the list is used,\n  //   even if a cast resulting from that interpretation is ill-formed.\n  // In plain language, this means trying a const_cast ...\n  unsigned msg = diag::err_bad_cxx_cast_generic;\n  TryCastResult tcr = TryConstCast(Self, SrcExpr, DestType,\n                                   /*CStyle*/true, msg);\n  if (SrcExpr.isInvalid())\n    return;\n  if (tcr == TC_Success)\n    Kind = CK_NoOp;\n\n  Sema::CheckedConversionKind CCK\n    = FunctionalStyle? Sema::CCK_FunctionalCast\n                     : Sema::CCK_CStyleCast;\n  if (tcr == TC_NotApplicable) {\n    // ... or if that is not possible, a static_cast, ignoring const, ...\n    tcr = TryStaticCast(Self, SrcExpr, DestType, CCK, OpRange,\n                        msg, Kind, BasePath, ListInitialization);\n    if (SrcExpr.isInvalid())\n      return;\n\n    if (tcr == TC_NotApplicable) {\n      // ... and finally a reinterpret_cast, ignoring const.\n      tcr = TryReinterpretCast(Self, SrcExpr, DestType, /*CStyle*/true,\n                               OpRange, msg, Kind);\n      if (SrcExpr.isInvalid())\n        return;\n    }\n  }\n\n  if (Self.getLangOpts().allowsNonTrivialObjCLifetimeQualifiers() &&\n      tcr == TC_Success)\n    checkObjCConversion(CCK);\n\n  if (tcr != TC_Success && msg != 0) {\n    if (SrcExpr.get()->getType() == Self.Context.OverloadTy) {\n      DeclAccessPair Found;\n      FunctionDecl *Fn = Self.ResolveAddressOfOverloadedFunction(SrcExpr.get(),\n                                DestType,\n                                /*Complain*/ true,\n                                Found);\n      if (Fn) {\n        // If DestType is a function type (not to be confused with the function\n        // pointer type), it will be possible to resolve the function address,\n        // but the type cast should be considered as failure.\n        OverloadExpr *OE = OverloadExpr::find(SrcExpr.get()).Expression;\n        Self.Diag(OpRange.getBegin(), diag::err_bad_cstyle_cast_overload)\n          << OE->getName() << DestType << OpRange\n          << OE->getQualifierLoc().getSourceRange();\n        Self.NoteAllOverloadCandidates(SrcExpr.get());\n      }\n    } else {\n      diagnoseBadCast(Self, msg, (FunctionalStyle ? CT_Functional : CT_CStyle),\n                      OpRange, SrcExpr.get(), DestType, ListInitialization);\n    }\n  } else if (Kind == CK_BitCast) {\n    checkCastAlign();\n  }\n\n  // Clear out SrcExpr if there was a fatal error.\n  if (tcr != TC_Success)\n    SrcExpr = ExprError();\n}\n\n/// DiagnoseBadFunctionCast - Warn whenever a function call is cast to a \n///  non-matching type. Such as enum function call to int, int call to\n/// pointer; etc. Cast to 'void' is an exception.\nstatic void DiagnoseBadFunctionCast(Sema &Self, const ExprResult &SrcExpr,\n                                  QualType DestType) {\n  if (Self.Diags.isIgnored(diag::warn_bad_function_cast,\n                           SrcExpr.get()->getExprLoc()))\n    return;\n  \n  if (!isa<CallExpr>(SrcExpr.get()))\n    return;\n  \n  QualType SrcType = SrcExpr.get()->getType();\n  if (DestType.getUnqualifiedType()->isVoidType())\n    return;\n  if ((SrcType->isAnyPointerType() || SrcType->isBlockPointerType())\n      && (DestType->isAnyPointerType() || DestType->isBlockPointerType()))\n    return;\n  if (SrcType->isIntegerType() && DestType->isIntegerType() &&\n      (SrcType->isBooleanType() == DestType->isBooleanType()) &&\n      (SrcType->isEnumeralType() == DestType->isEnumeralType()))\n    return;\n  if (SrcType->isRealFloatingType() && DestType->isRealFloatingType())\n    return;\n  if (SrcType->isEnumeralType() && DestType->isEnumeralType())\n    return;\n  if (SrcType->isComplexType() && DestType->isComplexType())\n    return;\n  if (SrcType->isComplexIntegerType() && DestType->isComplexIntegerType())\n    return;\n  \n  Self.Diag(SrcExpr.get()->getExprLoc(),\n            diag::warn_bad_function_cast)\n            << SrcType << DestType << SrcExpr.get()->getSourceRange();\n}\n\n/// Check the semantics of a C-style cast operation, in C.\nvoid CastOperation::CheckCStyleCast() {\n  assert(!Self.getLangOpts().CPlusPlus);\n\n  // C-style casts can resolve __unknown_any types.\n  if (claimPlaceholder(BuiltinType::UnknownAny)) {\n    SrcExpr = Self.checkUnknownAnyCast(DestRange, DestType,\n                                       SrcExpr.get(), Kind,\n                                       ValueKind, BasePath);\n    return;\n  }\n\n  // C99 6.5.4p2: the cast type needs to be void or scalar and the expression\n  // type needs to be scalar.\n  if (DestType->isVoidType()) {\n    // We don't necessarily do lvalue-to-rvalue conversions on this.\n    SrcExpr = Self.IgnoredValueConversions(SrcExpr.get());\n    if (SrcExpr.isInvalid())\n      return;\n\n    // Cast to void allows any expr type.\n    Kind = CK_ToVoid;\n    return;\n  }\n\n  // Overloads are allowed with C extensions, so we need to support them.\n  if (SrcExpr.get()->getType() == Self.Context.OverloadTy) {\n    DeclAccessPair DAP;\n    if (FunctionDecl *FD = Self.ResolveAddressOfOverloadedFunction(\n            SrcExpr.get(), DestType, /*Complain=*/true, DAP))\n      SrcExpr = Self.FixOverloadedFunctionReference(SrcExpr.get(), DAP, FD);\n    else\n      return;\n    assert(SrcExpr.isUsable());\n  }\n  SrcExpr = Self.DefaultFunctionArrayLvalueConversion(SrcExpr.get());\n  if (SrcExpr.isInvalid())\n    return;\n  QualType SrcType = SrcExpr.get()->getType();\n\n  assert(!SrcType->isPlaceholderType());\n\n  // OpenCL v1 s6.5: Casting a pointer to address space A to a pointer to\n  // address space B is illegal.\n  if (Self.getLangOpts().OpenCL && DestType->isPointerType() &&\n      SrcType->isPointerType()) {\n    const PointerType *DestPtr = DestType->getAs<PointerType>();\n    if (!DestPtr->isAddressSpaceOverlapping(*SrcType->getAs<PointerType>())) {\n      Self.Diag(OpRange.getBegin(),\n                diag::err_typecheck_incompatible_address_space)\n          << SrcType << DestType << Sema::AA_Casting\n          << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n  }\n\n  if (Self.RequireCompleteType(OpRange.getBegin(), DestType,\n                               diag::err_typecheck_cast_to_incomplete)) {\n    SrcExpr = ExprError();\n    return;\n  }\n\n  if (!DestType->isScalarType() && !DestType->isVectorType()) {\n    const RecordType *DestRecordTy = DestType->getAs<RecordType>();\n\n    if (DestRecordTy && Self.Context.hasSameUnqualifiedType(DestType, SrcType)){\n      // GCC struct/union extension: allow cast to self.\n      Self.Diag(OpRange.getBegin(), diag::ext_typecheck_cast_nonscalar)\n        << DestType << SrcExpr.get()->getSourceRange();\n      Kind = CK_NoOp;\n      return;\n    }\n\n    // GCC's cast to union extension.\n    if (DestRecordTy && DestRecordTy->getDecl()->isUnion()) {\n      RecordDecl *RD = DestRecordTy->getDecl();\n      RecordDecl::field_iterator Field, FieldEnd;\n      for (Field = RD->field_begin(), FieldEnd = RD->field_end();\n           Field != FieldEnd; ++Field) {\n        if (Self.Context.hasSameUnqualifiedType(Field->getType(), SrcType) &&\n            !Field->isUnnamedBitfield()) {\n          Self.Diag(OpRange.getBegin(), diag::ext_typecheck_cast_to_union)\n            << SrcExpr.get()->getSourceRange();\n          break;\n        }\n      }\n      if (Field == FieldEnd) {\n        Self.Diag(OpRange.getBegin(), diag::err_typecheck_cast_to_union_no_type)\n          << SrcType << SrcExpr.get()->getSourceRange();\n        SrcExpr = ExprError();\n        return;\n      }\n      Kind = CK_ToUnion;\n      return;\n    }\n\n    // OpenCL v2.0 s6.13.10 - Allow casts from '0' to event_t type.\n    if (Self.getLangOpts().OpenCL && DestType->isEventT()) {\n      llvm::APSInt CastInt;\n      if (SrcExpr.get()->EvaluateAsInt(CastInt, Self.Context)) {\n        if (0 == CastInt) {\n          Kind = CK_ZeroToOCLEvent;\n          return;\n        }\n        Self.Diag(OpRange.getBegin(),\n                  diag::err_opencl_cast_non_zero_to_event_t)\n                  << CastInt.toString(10) << SrcExpr.get()->getSourceRange();\n        SrcExpr = ExprError();\n        return;\n      }\n    }\n\n    // Reject any other conversions to non-scalar types.\n    Self.Diag(OpRange.getBegin(), diag::err_typecheck_cond_expect_scalar)\n      << DestType << SrcExpr.get()->getSourceRange();\n    SrcExpr = ExprError();\n    return;\n  }\n\n  // The type we're casting to is known to be a scalar or vector.\n\n  // Require the operand to be a scalar or vector.\n  if (!SrcType->isScalarType() && !SrcType->isVectorType()) {\n    Self.Diag(SrcExpr.get()->getExprLoc(),\n              diag::err_typecheck_expect_scalar_operand)\n      << SrcType << SrcExpr.get()->getSourceRange();\n    SrcExpr = ExprError();\n    return;\n  }\n\n  if (DestType->isExtVectorType()) {\n    SrcExpr = Self.CheckExtVectorCast(OpRange, DestType, SrcExpr.get(), Kind);\n    return;\n  }\n\n  if (const VectorType *DestVecTy = DestType->getAs<VectorType>()) {\n    if (DestVecTy->getVectorKind() == VectorType::AltiVecVector &&\n          (SrcType->isIntegerType() || SrcType->isFloatingType())) {\n      Kind = CK_VectorSplat;\n      SrcExpr = Self.prepareVectorSplat(DestType, SrcExpr.get());\n    } else if (Self.CheckVectorCast(OpRange, DestType, SrcType, Kind)) {\n      SrcExpr = ExprError();\n    }\n    return;\n  }\n\n  if (SrcType->isVectorType()) {\n    if (Self.CheckVectorCast(OpRange, SrcType, DestType, Kind))\n      SrcExpr = ExprError();\n    return;\n  }\n\n  // The source and target types are both scalars, i.e.\n  //   - arithmetic types (fundamental, enum, and complex)\n  //   - all kinds of pointers\n  // Note that member pointers were filtered out with C++, above.\n\n  if (isa<ObjCSelectorExpr>(SrcExpr.get())) {\n    Self.Diag(SrcExpr.get()->getExprLoc(), diag::err_cast_selector_expr);\n    SrcExpr = ExprError();\n    return;\n  }\n\n  // If either type is a pointer, the other type has to be either an\n  // integer or a pointer.\n  if (!DestType->isArithmeticType()) {\n    if (!SrcType->isIntegralType(Self.Context) && SrcType->isArithmeticType()) {\n      Self.Diag(SrcExpr.get()->getExprLoc(),\n                diag::err_cast_pointer_from_non_pointer_int)\n        << SrcType << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n    checkIntToPointerCast(/* CStyle */ true, OpRange.getBegin(), SrcExpr.get(),\n                          DestType, Self);\n  } else if (!SrcType->isArithmeticType()) {\n    if (!DestType->isIntegralType(Self.Context) &&\n        DestType->isArithmeticType()) {\n      Self.Diag(SrcExpr.get()->getLocStart(),\n           diag::err_cast_pointer_to_non_pointer_int)\n        << DestType << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n  }\n\n  if (Self.getLangOpts().OpenCL &&\n      !Self.getOpenCLOptions().isEnabled(\"cl_khr_fp16\")) {\n    if (DestType->isHalfType()) {\n      Self.Diag(SrcExpr.get()->getLocStart(), diag::err_opencl_cast_to_half)\n        << DestType << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n  }\n\n  // ARC imposes extra restrictions on casts.\n  if (Self.getLangOpts().allowsNonTrivialObjCLifetimeQualifiers()) {\n    checkObjCConversion(Sema::CCK_CStyleCast);\n    if (SrcExpr.isInvalid())\n      return;\n\n    const PointerType *CastPtr = DestType->getAs<PointerType>();\n    if (Self.getLangOpts().ObjCAutoRefCount && CastPtr) {\n      if (const PointerType *ExprPtr = SrcType->getAs<PointerType>()) {\n        Qualifiers CastQuals = CastPtr->getPointeeType().getQualifiers();\n        Qualifiers ExprQuals = ExprPtr->getPointeeType().getQualifiers();\n        if (CastPtr->getPointeeType()->isObjCLifetimeType() && \n            ExprPtr->getPointeeType()->isObjCLifetimeType() &&\n            !CastQuals.compatiblyIncludesObjCLifetime(ExprQuals)) {\n          Self.Diag(SrcExpr.get()->getLocStart(), \n                    diag::err_typecheck_incompatible_ownership)\n            << SrcType << DestType << Sema::AA_Casting\n            << SrcExpr.get()->getSourceRange();\n          return;\n        }\n      }\n    } \n    else if (!Self.CheckObjCARCUnavailableWeakConversion(DestType, SrcType)) {\n      Self.Diag(SrcExpr.get()->getLocStart(), \n                diag::err_arc_convesion_of_weak_unavailable)\n        << 1 << SrcType << DestType << SrcExpr.get()->getSourceRange();\n      SrcExpr = ExprError();\n      return;\n    }\n  }\n  \n  DiagnoseCastOfObjCSEL(Self, SrcExpr, DestType);\n  DiagnoseCallingConvCast(Self, SrcExpr, DestType, OpRange);\n  DiagnoseBadFunctionCast(Self, SrcExpr, DestType);\n  Kind = Self.PrepareScalarCast(SrcExpr, DestType);\n  if (SrcExpr.isInvalid())\n    return;\n\n  if (Kind == CK_BitCast)\n    checkCastAlign();\n}\n\n/// DiagnoseCastQual - Warn whenever casts discards a qualifiers, be it either\n/// const, volatile or both.\nstatic void DiagnoseCastQual(Sema &Self, const ExprResult &SrcExpr,\n                             QualType DestType) {\n  if (SrcExpr.isInvalid())\n    return;\n\n  QualType SrcType = SrcExpr.get()->getType();\n  if (!((SrcType->isAnyPointerType() && DestType->isAnyPointerType()) ||\n        DestType->isLValueReferenceType()))\n    return;\n\n  QualType TheOffendingSrcType, TheOffendingDestType;\n  Qualifiers CastAwayQualifiers;\n  if (!CastsAwayConstness(Self, SrcType, DestType, true, false,\n                          &TheOffendingSrcType, &TheOffendingDestType,\n                          &CastAwayQualifiers))\n    return;\n\n  int qualifiers = -1;\n  if (CastAwayQualifiers.hasConst() && CastAwayQualifiers.hasVolatile()) {\n    qualifiers = 0;\n  } else if (CastAwayQualifiers.hasConst()) {\n    qualifiers = 1;\n  } else if (CastAwayQualifiers.hasVolatile()) {\n    qualifiers = 2;\n  }\n  // This is a variant of int **x; const int **y = (const int **)x;\n  if (qualifiers == -1)\n    Self.Diag(SrcExpr.get()->getLocStart(), diag::warn_cast_qual2)\n        << SrcType << DestType;\n  else\n    Self.Diag(SrcExpr.get()->getLocStart(), diag::warn_cast_qual)\n        << TheOffendingSrcType << TheOffendingDestType << qualifiers;\n}\n\nExprResult Sema::BuildCStyleCastExpr(SourceLocation LPLoc,\n                                     TypeSourceInfo *CastTypeInfo,\n                                     SourceLocation RPLoc,\n                                     Expr *CastExpr) {\n  CastOperation Op(*this, CastTypeInfo->getType(), CastExpr);  \n  Op.DestRange = CastTypeInfo->getTypeLoc().getSourceRange();\n  Op.OpRange = SourceRange(LPLoc, CastExpr->getLocEnd());\n\n  if (getLangOpts().CPlusPlus) {\n    Op.CheckCXXCStyleCast(/*FunctionalStyle=*/ false,\n                          isa<InitListExpr>(CastExpr));\n  } else {\n    Op.CheckCStyleCast();\n  }\n\n  if (Op.SrcExpr.isInvalid())\n    return ExprError();\n\n  // -Wcast-qual\n  DiagnoseCastQual(Op.Self, Op.SrcExpr, Op.DestType);\n\n  return Op.complete(CStyleCastExpr::Create(Context, Op.ResultType,\n                              Op.ValueKind, Op.Kind, Op.SrcExpr.get(),\n                              &Op.BasePath, CastTypeInfo, LPLoc, RPLoc));\n}\n\nExprResult Sema::BuildCXXFunctionalCastExpr(TypeSourceInfo *CastTypeInfo,\n                                            QualType Type,\n                                            SourceLocation LPLoc,\n                                            Expr *CastExpr,\n                                            SourceLocation RPLoc) {\n  assert(LPLoc.isValid() && \"List-initialization shouldn't get here.\");\n  CastOperation Op(*this, Type, CastExpr);\n  Op.DestRange = CastTypeInfo->getTypeLoc().getSourceRange();\n  Op.OpRange = SourceRange(Op.DestRange.getBegin(), CastExpr->getLocEnd());\n\n  Op.CheckCXXCStyleCast(/*FunctionalStyle=*/true, /*ListInit=*/false);\n  if (Op.SrcExpr.isInvalid())\n    return ExprError();\n\n  auto *SubExpr = Op.SrcExpr.get();\n  if (auto *BindExpr = dyn_cast<CXXBindTemporaryExpr>(SubExpr))\n    SubExpr = BindExpr->getSubExpr();\n  if (auto *ConstructExpr = dyn_cast<CXXConstructExpr>(SubExpr))\n    ConstructExpr->setParenOrBraceRange(SourceRange(LPLoc, RPLoc));\n\n  return Op.complete(CXXFunctionalCastExpr::Create(Context, Op.ResultType,\n                         Op.ValueKind, CastTypeInfo, Op.Kind,\n                         Op.SrcExpr.get(), &Op.BasePath, LPLoc, RPLoc));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/scan-build-py/libear/ear.c": "/* -*- coding: utf-8 -*-\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n*/\n\n/**\n * This file implements a shared library. This library can be pre-loaded by\n * the dynamic linker of the Operating System (OS). It implements a few function\n * related to process creation. By pre-load this library the executed process\n * uses these functions instead of those from the standard library.\n *\n * The idea here is to inject a logic before call the real methods. The logic is\n * to dump the call into a file. To call the real method this library is doing\n * the job of the dynamic linker.\n *\n * The only input for the log writing is about the destination directory.\n * This is passed as environment variable.\n */\n\n#include \"config.h\"\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <pthread.h>\n\n#if defined HAVE_POSIX_SPAWN || defined HAVE_POSIX_SPAWNP\n#include <spawn.h>\n#endif\n\n#if defined HAVE_NSGETENVIRON\n# include <crt_externs.h>\n#else\nextern char **environ;\n#endif\n\n#define ENV_OUTPUT \"INTERCEPT_BUILD_TARGET_DIR\"\n#ifdef APPLE\n# define ENV_FLAT    \"DYLD_FORCE_FLAT_NAMESPACE\"\n# define ENV_PRELOAD \"DYLD_INSERT_LIBRARIES\"\n# define ENV_SIZE 3\n#else\n# define ENV_PRELOAD \"LD_PRELOAD\"\n# define ENV_SIZE 2\n#endif\n\n#define DLSYM(TYPE_, VAR_, SYMBOL_)                                            \\\n    union {                                                                    \\\n        void *from;                                                            \\\n        TYPE_ to;                                                              \\\n    } cast;                                                                    \\\n    if (0 == (cast.from = dlsym(RTLD_NEXT, SYMBOL_))) {                        \\\n        perror(\"bear: dlsym\");                                                 \\\n        exit(EXIT_FAILURE);                                                    \\\n    }                                                                          \\\n    TYPE_ const VAR_ = cast.to;\n\n\ntypedef char const * bear_env_t[ENV_SIZE];\n\nstatic int bear_capture_env_t(bear_env_t *env);\nstatic int bear_reset_env_t(bear_env_t *env);\nstatic void bear_release_env_t(bear_env_t *env);\nstatic char const **bear_update_environment(char *const envp[], bear_env_t *env);\nstatic char const **bear_update_environ(char const **in, char const *key, char const *value);\nstatic char **bear_get_environment();\nstatic void bear_report_call(char const *fun, char const *const argv[]);\nstatic char const **bear_strings_build(char const *arg, va_list *ap);\nstatic char const **bear_strings_copy(char const **const in);\nstatic char const **bear_strings_append(char const **in, char const *e);\nstatic size_t bear_strings_length(char const *const *in);\nstatic void bear_strings_release(char const **);\n\n\nstatic bear_env_t env_names =\n    { ENV_OUTPUT\n    , ENV_PRELOAD\n#ifdef ENV_FLAT\n    , ENV_FLAT\n#endif\n    };\n\nstatic bear_env_t initial_env =\n    { 0\n    , 0\n#ifdef ENV_FLAT\n    , 0\n#endif\n    };\n\nstatic int initialized = 0;\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void on_load(void) __attribute__((constructor));\nstatic void on_unload(void) __attribute__((destructor));\n\n\n#ifdef HAVE_EXECVE\nstatic int call_execve(const char *path, char *const argv[],\n                       char *const envp[]);\n#endif\n#ifdef HAVE_EXECVP\nstatic int call_execvp(const char *file, char *const argv[]);\n#endif\n#ifdef HAVE_EXECVPE\nstatic int call_execvpe(const char *file, char *const argv[],\n                        char *const envp[]);\n#endif\n#ifdef HAVE_EXECVP2\nstatic int call_execvP(const char *file, const char *search_path,\n                       char *const argv[]);\n#endif\n#ifdef HAVE_EXECT\nstatic int call_exect(const char *path, char *const argv[],\n                      char *const envp[]);\n#endif\n#ifdef HAVE_POSIX_SPAWN\nstatic int call_posix_spawn(pid_t *restrict pid, const char *restrict path,\n                            const posix_spawn_file_actions_t *file_actions,\n                            const posix_spawnattr_t *restrict attrp,\n                            char *const argv[restrict],\n                            char *const envp[restrict]);\n#endif\n#ifdef HAVE_POSIX_SPAWNP\nstatic int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                             const posix_spawn_file_actions_t *file_actions,\n                             const posix_spawnattr_t *restrict attrp,\n                             char *const argv[restrict],\n                             char *const envp[restrict]);\n#endif\n\n\n/* Initialization method to Captures the relevant environment variables.\n */\n\nstatic void on_load(void) {\n    pthread_mutex_lock(&mutex);\n    if (!initialized)\n        initialized = bear_capture_env_t(&initial_env);\n    pthread_mutex_unlock(&mutex);\n}\n\nstatic void on_unload(void) {\n    pthread_mutex_lock(&mutex);\n    bear_release_env_t(&initial_env);\n    initialized = 0;\n    pthread_mutex_unlock(&mutex);\n}\n\n\n/* These are the methods we are try to hijack.\n */\n\n#ifdef HAVE_EXECVE\nint execve(const char *path, char *const argv[], char *const envp[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execve(path, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECV\n#ifndef HAVE_EXECVE\n#error can not implement execv without execve\n#endif\nint execv(const char *path, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    char * const * envp = bear_get_environment();\n    return call_execve(path, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECVPE\nint execvpe(const char *file, char *const argv[], char *const envp[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvpe(file, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECVP\nint execvp(const char *file, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvp(file, argv);\n}\n#endif\n\n#ifdef HAVE_EXECVP2\nint execvP(const char *file, const char *search_path, char *const argv[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_execvP(file, search_path, argv);\n}\n#endif\n\n#ifdef HAVE_EXECT\nint exect(const char *path, char *const argv[], char *const envp[]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_exect(path, argv, envp);\n}\n#endif\n\n#ifdef HAVE_EXECL\n# ifndef HAVE_EXECVE\n#  error can not implement execl without execve\n# endif\nint execl(const char *path, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    char * const * envp = bear_get_environment();\n    int const result = call_execve(path, (char *const *)argv, envp);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECLP\n# ifndef HAVE_EXECVP\n#  error can not implement execlp without execvp\n# endif\nint execlp(const char *file, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    int const result = call_execvp(file, (char *const *)argv);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECLE\n# ifndef HAVE_EXECVE\n#  error can not implement execle without execve\n# endif\n// int execle(const char *path, const char *arg, ..., char * const envp[]);\nint execle(const char *path, const char *arg, ...) {\n    va_list args;\n    va_start(args, arg);\n    char const **argv = bear_strings_build(arg, &args);\n    char const **envp = va_arg(args, char const **);\n    va_end(args);\n\n    bear_report_call(__func__, (char const *const *)argv);\n    int const result =\n        call_execve(path, (char *const *)argv, (char *const *)envp);\n\n    bear_strings_release(argv);\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWN\nint posix_spawn(pid_t *restrict pid, const char *restrict path,\n                const posix_spawn_file_actions_t *file_actions,\n                const posix_spawnattr_t *restrict attrp,\n                char *const argv[restrict], char *const envp[restrict]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_posix_spawn(pid, path, file_actions, attrp, argv, envp);\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWNP\nint posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                 const posix_spawn_file_actions_t *file_actions,\n                 const posix_spawnattr_t *restrict attrp,\n                 char *const argv[restrict], char *const envp[restrict]) {\n    bear_report_call(__func__, (char const *const *)argv);\n    return call_posix_spawnp(pid, file, file_actions, attrp, argv, envp);\n}\n#endif\n\n/* These are the methods which forward the call to the standard implementation.\n */\n\n#ifdef HAVE_EXECVE\nstatic int call_execve(const char *path, char *const argv[],\n                       char *const envp[]) {\n    typedef int (*func)(const char *, char *const *, char *const *);\n\n    DLSYM(func, fp, \"execve\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result = (*fp)(path, argv, (char *const *)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVPE\nstatic int call_execvpe(const char *file, char *const argv[],\n                        char *const envp[]) {\n    typedef int (*func)(const char *, char *const *, char *const *);\n\n    DLSYM(func, fp, \"execvpe\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result = (*fp)(file, argv, (char *const *)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVP\nstatic int call_execvp(const char *file, char *const argv[]) {\n    typedef int (*func)(const char *file, char *const argv[]);\n\n    DLSYM(func, fp, \"execvp\");\n\n    bear_env_t current_env;\n    bear_capture_env_t(&current_env);\n    bear_reset_env_t(&initial_env);\n    int const result = (*fp)(file, argv);\n    bear_reset_env_t(&current_env);\n    bear_release_env_t(&current_env);\n\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECVP2\nstatic int call_execvP(const char *file, const char *search_path,\n                       char *const argv[]) {\n    typedef int (*func)(const char *, const char *, char *const *);\n\n    DLSYM(func, fp, \"execvP\");\n\n    bear_env_t current_env;\n    bear_capture_env_t(&current_env);\n    bear_reset_env_t(&initial_env);\n    int const result = (*fp)(file, search_path, argv);\n    bear_reset_env_t(&current_env);\n    bear_release_env_t(&current_env);\n\n    return result;\n}\n#endif\n\n#ifdef HAVE_EXECT\nstatic int call_exect(const char *path, char *const argv[],\n                      char *const envp[]) {\n    typedef int (*func)(const char *, char *const *, char *const *);\n\n    DLSYM(func, fp, \"exect\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result = (*fp)(path, argv, (char *const *)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWN\nstatic int call_posix_spawn(pid_t *restrict pid, const char *restrict path,\n                            const posix_spawn_file_actions_t *file_actions,\n                            const posix_spawnattr_t *restrict attrp,\n                            char *const argv[restrict],\n                            char *const envp[restrict]) {\n    typedef int (*func)(pid_t *restrict, const char *restrict,\n                        const posix_spawn_file_actions_t *,\n                        const posix_spawnattr_t *restrict,\n                        char *const *restrict, char *const *restrict);\n\n    DLSYM(func, fp, \"posix_spawn\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result =\n        (*fp)(pid, path, file_actions, attrp, argv, (char *const *restrict)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n#ifdef HAVE_POSIX_SPAWNP\nstatic int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                             const posix_spawn_file_actions_t *file_actions,\n                             const posix_spawnattr_t *restrict attrp,\n                             char *const argv[restrict],\n                             char *const envp[restrict]) {\n    typedef int (*func)(pid_t *restrict, const char *restrict,\n                        const posix_spawn_file_actions_t *,\n                        const posix_spawnattr_t *restrict,\n                        char *const *restrict, char *const *restrict);\n\n    DLSYM(func, fp, \"posix_spawnp\");\n\n    char const **const menvp = bear_update_environment(envp, &initial_env);\n    int const result =\n        (*fp)(pid, file, file_actions, attrp, argv, (char *const *restrict)menvp);\n    bear_strings_release(menvp);\n    return result;\n}\n#endif\n\n/* this method is to write log about the process creation. */\n\nstatic void bear_report_call(char const *fun, char const *const argv[]) {\n    static int const GS = 0x1d;\n    static int const RS = 0x1e;\n    static int const US = 0x1f;\n\n    if (!initialized)\n        return;\n\n    pthread_mutex_lock(&mutex);\n    const char *cwd = getcwd(NULL, 0);\n    if (0 == cwd) {\n        perror(\"bear: getcwd\");\n        exit(EXIT_FAILURE);\n    }\n    char const * const out_dir = initial_env[0];\n    size_t const path_max_length = strlen(out_dir) + 32;\n    char filename[path_max_length];\n    if (-1 == snprintf(filename, path_max_length, \"%s/%d.cmd\", out_dir, getpid())) {\n        perror(\"bear: snprintf\");\n        exit(EXIT_FAILURE);\n    }\n    FILE * fd = fopen(filename, \"a+\");\n    if (0 == fd) {\n        perror(\"bear: fopen\");\n        exit(EXIT_FAILURE);\n    }\n    fprintf(fd, \"%d%c\", getpid(), RS);\n    fprintf(fd, \"%d%c\", getppid(), RS);\n    fprintf(fd, \"%s%c\", fun, RS);\n    fprintf(fd, \"%s%c\", cwd, RS);\n    size_t const argc = bear_strings_length(argv);\n    for (size_t it = 0; it < argc; ++it) {\n        fprintf(fd, \"%s%c\", argv[it], US);\n    }\n    fprintf(fd, \"%c\", GS);\n    if (fclose(fd)) {\n        perror(\"bear: fclose\");\n        exit(EXIT_FAILURE);\n    }\n    free((void *)cwd);\n    pthread_mutex_unlock(&mutex);\n}\n\n/* update environment assure that chilren processes will copy the desired\n * behaviour */\n\nstatic int bear_capture_env_t(bear_env_t *env) {\n    int status = 1;\n    for (size_t it = 0; it < ENV_SIZE; ++it) {\n        char const * const env_value = getenv(env_names[it]);\n        char const * const env_copy = (env_value) ? strdup(env_value) : env_value;\n        (*env)[it] = env_copy;\n        status &= (env_copy) ? 1 : 0;\n    }\n    return status;\n}\n\nstatic int bear_reset_env_t(bear_env_t *env) {\n    int status = 1;\n    for (size_t it = 0; it < ENV_SIZE; ++it) {\n        if ((*env)[it]) {\n            setenv(env_names[it], (*env)[it], 1);\n        } else {\n            unsetenv(env_names[it]);\n        }\n    }\n    return status;\n}\n\nstatic void bear_release_env_t(bear_env_t *env) {\n    for (size_t it = 0; it < ENV_SIZE; ++it) {\n        free((void *)(*env)[it]);\n        (*env)[it] = 0;\n    }\n}\n\nstatic char const **bear_update_environment(char *const envp[], bear_env_t *env) {\n    char const **result = bear_strings_copy((char const **)envp);\n    for (size_t it = 0; it < ENV_SIZE && (*env)[it]; ++it)\n        result = bear_update_environ(result, env_names[it], (*env)[it]);\n    return result;\n}\n\nstatic char const **bear_update_environ(char const *envs[], char const *key, char const * const value) {\n    // find the key if it's there\n    size_t const key_length = strlen(key);\n    char const **it = envs;\n    for (; (it) && (*it); ++it) {\n        if ((0 == strncmp(*it, key, key_length)) &&\n            (strlen(*it) > key_length) && ('=' == (*it)[key_length]))\n            break;\n    }\n    // allocate a environment entry\n    size_t const value_length = strlen(value);\n    size_t const env_length = key_length + value_length + 2;\n    char *env = malloc(env_length);\n    if (0 == env) {\n        perror(\"bear: malloc [in env_update]\");\n        exit(EXIT_FAILURE);\n    }\n    if (-1 == snprintf(env, env_length, \"%s=%s\", key, value)) {\n        perror(\"bear: snprintf\");\n        exit(EXIT_FAILURE);\n    }\n    // replace or append the environment entry\n    if (it && *it) {\n        free((void *)*it);\n        *it = env;\n\treturn envs;\n    }\n    return bear_strings_append(envs, env);\n}\n\nstatic char **bear_get_environment() {\n#if defined HAVE_NSGETENVIRON\n    return *_NSGetEnviron();\n#else\n    return environ;\n#endif\n}\n\n/* util methods to deal with string arrays. environment and process arguments\n * are both represented as string arrays. */\n\nstatic char const **bear_strings_build(char const *const arg, va_list *args) {\n    char const **result = 0;\n    size_t size = 0;\n    for (char const *it = arg; it; it = va_arg(*args, char const *)) {\n        result = realloc(result, (size + 1) * sizeof(char const *));\n        if (0 == result) {\n            perror(\"bear: realloc\");\n            exit(EXIT_FAILURE);\n        }\n        char const *copy = strdup(it);\n        if (0 == copy) {\n            perror(\"bear: strdup\");\n            exit(EXIT_FAILURE);\n        }\n        result[size++] = copy;\n    }\n    result = realloc(result, (size + 1) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: realloc\");\n        exit(EXIT_FAILURE);\n    }\n    result[size++] = 0;\n\n    return result;\n}\n\nstatic char const **bear_strings_copy(char const **const in) {\n    size_t const size = bear_strings_length(in);\n\n    char const **const result = malloc((size + 1) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: malloc\");\n        exit(EXIT_FAILURE);\n    }\n\n    char const **out_it = result;\n    for (char const *const *in_it = in; (in_it) && (*in_it);\n         ++in_it, ++out_it) {\n        *out_it = strdup(*in_it);\n        if (0 == *out_it) {\n            perror(\"bear: strdup\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    *out_it = 0;\n    return result;\n}\n\nstatic char const **bear_strings_append(char const **const in,\n                                        char const *const e) {\n    size_t size = bear_strings_length(in);\n    char const **result = realloc(in, (size + 2) * sizeof(char const *));\n    if (0 == result) {\n        perror(\"bear: realloc\");\n        exit(EXIT_FAILURE);\n    }\n    result[size++] = e;\n    result[size++] = 0;\n    return result;\n}\n\nstatic size_t bear_strings_length(char const *const *const in) {\n    size_t result = 0;\n    for (char const *const *it = in; (it) && (*it); ++it)\n        ++result;\n    return result;\n}\n\nstatic void bear_strings_release(char const **in) {\n    for (char const *const *it = in; (it) && (*it); ++it) {\n        free((void *)*it);\n    }\n    free((void *)in);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/tutorial/LangImpl04.rst": "==============================================\nKaleidoscope: Adding JIT and Optimizer Support\n==============================================\n\n.. contents::\n   :local:\n\nChapter 4 Introduction\n======================\n\nWelcome to Chapter 4 of the \"`Implementing a language with\nLLVM <index.html>`_\" tutorial. Chapters 1-3 described the implementation\nof a simple language and added support for generating LLVM IR. This\nchapter describes two new techniques: adding optimizer support to your\nlanguage, and adding JIT compiler support. These additions will\ndemonstrate how to get nice, efficient code for the Kaleidoscope\nlanguage.\n\nTrivial Constant Folding\n========================\n\nOur demonstration for Chapter 3 is elegant and easy to extend.\nUnfortunately, it does not produce wonderful code. The IRBuilder,\nhowever, does give us obvious optimizations when compiling simple code:\n\n::\n\n    ready> def test(x) 1+2+x;\n    Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 3.000000e+00, %x\n            ret double %addtmp\n    }\n\nThis code is not a literal transcription of the AST built by parsing the\ninput. That would be:\n\n::\n\n    ready> def test(x) 1+2+x;\n    Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 2.000000e+00, 1.000000e+00\n            %addtmp1 = fadd double %addtmp, %x\n            ret double %addtmp1\n    }\n\nConstant folding, as seen above, in particular, is a very common and\nvery important optimization: so much so that many language implementors\nimplement constant folding support in their AST representation.\n\nWith LLVM, you don't need this support in the AST. Since all calls to\nbuild LLVM IR go through the LLVM IR builder, the builder itself checked\nto see if there was a constant folding opportunity when you call it. If\nso, it just does the constant fold and return the constant instead of\ncreating an instruction.\n\nWell, that was easy :). In practice, we recommend always using\n``IRBuilder`` when generating code like this. It has no \"syntactic\noverhead\" for its use (you don't have to uglify your compiler with\nconstant checks everywhere) and it can dramatically reduce the amount of\nLLVM IR that is generated in some cases (particular for languages with a\nmacro preprocessor or that use a lot of constants).\n\nOn the other hand, the ``IRBuilder`` is limited by the fact that it does\nall of its analysis inline with the code as it is built. If you take a\nslightly more complex example:\n\n::\n\n    ready> def test(x) (1+2+x)*(x+(1+2));\n    ready> Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 3.000000e+00, %x\n            %addtmp1 = fadd double %x, 3.000000e+00\n            %multmp = fmul double %addtmp, %addtmp1\n            ret double %multmp\n    }\n\nIn this case, the LHS and RHS of the multiplication are the same value.\nWe'd really like to see this generate \"``tmp = x+3; result = tmp*tmp;``\"\ninstead of computing \"``x+3``\" twice.\n\nUnfortunately, no amount of local analysis will be able to detect and\ncorrect this. This requires two transformations: reassociation of\nexpressions (to make the add's lexically identical) and Common\nSubexpression Elimination (CSE) to delete the redundant add instruction.\nFortunately, LLVM provides a broad range of optimizations that you can\nuse, in the form of \"passes\".\n\nLLVM Optimization Passes\n========================\n\nLLVM provides many optimization passes, which do many different sorts of\nthings and have different tradeoffs. Unlike other systems, LLVM doesn't\nhold to the mistaken notion that one set of optimizations is right for\nall languages and for all situations. LLVM allows a compiler implementor\nto make complete decisions about what optimizations to use, in which\norder, and in what situation.\n\nAs a concrete example, LLVM supports both \"whole module\" passes, which\nlook across as large of body of code as they can (often a whole file,\nbut if run at link time, this can be a substantial portion of the whole\nprogram). It also supports and includes \"per-function\" passes which just\noperate on a single function at a time, without looking at other\nfunctions. For more information on passes and how they are run, see the\n`How to Write a Pass <../WritingAnLLVMPass.html>`_ document and the\n`List of LLVM Passes <../Passes.html>`_.\n\nFor Kaleidoscope, we are currently generating functions on the fly, one\nat a time, as the user types them in. We aren't shooting for the\nultimate optimization experience in this setting, but we also want to\ncatch the easy and quick stuff where possible. As such, we will choose\nto run a few per-function optimizations as the user types the function\nin. If we wanted to make a \"static Kaleidoscope compiler\", we would use\nexactly the code we have now, except that we would defer running the\noptimizer until the entire file has been parsed.\n\nIn order to get per-function optimizations going, we need to set up a\n`FunctionPassManager <../WritingAnLLVMPass.html#what-passmanager-doesr>`_ to hold\nand organize the LLVM optimizations that we want to run. Once we have\nthat, we can add a set of optimizations to run. We'll need a new\nFunctionPassManager for each module that we want to optimize, so we'll\nwrite a function to create and initialize both the module and pass manager\nfor us:\n\n.. code-block:: c++\n\n    void InitializeModuleAndPassManager(void) {\n      // Open a new module.\n      TheModule = llvm::make_unique<Module>(\"my cool jit\", TheContext);\n\n      // Create a new pass manager attached to it.\n      TheFPM = llvm::make_unique<FunctionPassManager>(TheModule.get());\n\n      // Do simple \"peephole\" optimizations and bit-twiddling optzns.\n      TheFPM->add(createInstructionCombiningPass());\n      // Reassociate expressions.\n      TheFPM->add(createReassociatePass());\n      // Eliminate Common SubExpressions.\n      TheFPM->add(createGVNPass());\n      // Simplify the control flow graph (deleting unreachable blocks, etc).\n      TheFPM->add(createCFGSimplificationPass());\n\n      TheFPM->doInitialization();\n    }\n\nThis code initializes the global module ``TheModule``, and the function pass\nmanager ``TheFPM``, which is attached to ``TheModule``. Once the pass manager is\nset up, we use a series of \"add\" calls to add a bunch of LLVM passes.\n\nIn this case, we choose to add four optimization passes.\nThe passes we choose here are a pretty standard set\nof \"cleanup\" optimizations that are useful for a wide variety of code. I won't\ndelve into what they do but, believe me, they are a good starting place :).\n\nOnce the PassManager is set up, we need to make use of it. We do this by\nrunning it after our newly created function is constructed (in\n``FunctionAST::codegen()``), but before it is returned to the client:\n\n.. code-block:: c++\n\n      if (Value *RetVal = Body->codegen()) {\n        // Finish off the function.\n        Builder.CreateRet(RetVal);\n\n        // Validate the generated code, checking for consistency.\n        verifyFunction(*TheFunction);\n\n        // Optimize the function.\n        TheFPM->run(*TheFunction);\n\n        return TheFunction;\n      }\n\nAs you can see, this is pretty straightforward. The\n``FunctionPassManager`` optimizes and updates the LLVM Function\\* in\nplace, improving (hopefully) its body. With this in place, we can try\nour test above again:\n\n::\n\n    ready> def test(x) (1+2+x)*(x+(1+2));\n    ready> Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double %x, 3.000000e+00\n            %multmp = fmul double %addtmp, %addtmp\n            ret double %multmp\n    }\n\nAs expected, we now get our nicely optimized code, saving a floating\npoint add instruction from every execution of this function.\n\nLLVM provides a wide variety of optimizations that can be used in\ncertain circumstances. Some `documentation about the various\npasses <../Passes.html>`_ is available, but it isn't very complete.\nAnother good source of ideas can come from looking at the passes that\n``Clang`` runs to get started. The \"``opt``\" tool allows you to\nexperiment with passes from the command line, so you can see if they do\nanything.\n\nNow that we have reasonable code coming out of our front-end, lets talk\nabout executing it!\n\nAdding a JIT Compiler\n=====================\n\nCode that is available in LLVM IR can have a wide variety of tools\napplied to it. For example, you can run optimizations on it (as we did\nabove), you can dump it out in textual or binary forms, you can compile\nthe code to an assembly file (.s) for some target, or you can JIT\ncompile it. The nice thing about the LLVM IR representation is that it\nis the \"common currency\" between many different parts of the compiler.\n\nIn this section, we'll add JIT compiler support to our interpreter. The\nbasic idea that we want for Kaleidoscope is to have the user enter\nfunction bodies as they do now, but immediately evaluate the top-level\nexpressions they type in. For example, if they type in \"1 + 2;\", we\nshould evaluate and print out 3. If they define a function, they should\nbe able to call it from the command line.\n\nIn order to do this, we first prepare the environment to create code for\nthe current native target and declare and initialize the JIT. This is\ndone by calling some ``InitializeNativeTarget\\*`` functions and\nadding a global variable ``TheJIT``, and initializing it in\n``main``:\n\n.. code-block:: c++\n\n    static std::unique_ptr<KaleidoscopeJIT> TheJIT;\n    ...\n    int main() {\n      InitializeNativeTarget();\n      InitializeNativeTargetAsmPrinter();\n      InitializeNativeTargetAsmParser();\n\n      // Install standard binary operators.\n      // 1 is lowest precedence.\n      BinopPrecedence['<'] = 10;\n      BinopPrecedence['+'] = 20;\n      BinopPrecedence['-'] = 20;\n      BinopPrecedence['*'] = 40; // highest.\n\n      // Prime the first token.\n      fprintf(stderr, \"ready> \");\n      getNextToken();\n\n      TheJIT = llvm::make_unique<KaleidoscopeJIT>();\n\n      // Run the main \"interpreter loop\" now.\n      MainLoop();\n\n      return 0;\n    }\n\nWe also need to setup the data layout for the JIT:\n\n.. code-block:: c++\n\n    void InitializeModuleAndPassManager(void) {\n      // Open a new module.\n      TheModule = llvm::make_unique<Module>(\"my cool jit\", TheContext);\n      TheModule->setDataLayout(TheJIT->getTargetMachine().createDataLayout());\n\n      // Create a new pass manager attached to it.\n      TheFPM = llvm::make_unique<FunctionPassManager>(TheModule.get());\n      ...\n\nThe KaleidoscopeJIT class is a simple JIT built specifically for these\ntutorials, available inside the LLVM source code\nat llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h.\nIn later chapters we will look at how it works and extend it with\nnew features, but for now we will take it as given. Its API is very simple:\n``addModule`` adds an LLVM IR module to the JIT, making its functions\navailable for execution; ``removeModule`` removes a module, freeing any\nmemory associated with the code in that module; and ``findSymbol`` allows us\nto look up pointers to the compiled code.\n\nWe can take this simple API and change our code that parses top-level expressions to\nlook like this:\n\n.. code-block:: c++\n\n    static void HandleTopLevelExpression() {\n      // Evaluate a top-level expression into an anonymous function.\n      if (auto FnAST = ParseTopLevelExpr()) {\n        if (FnAST->codegen()) {\n\n          // JIT the module containing the anonymous expression, keeping a handle so\n          // we can free it later.\n          auto H = TheJIT->addModule(std::move(TheModule));\n          InitializeModuleAndPassManager();\n\n          // Search the JIT for the __anon_expr symbol.\n          auto ExprSymbol = TheJIT->findSymbol(\"__anon_expr\");\n          assert(ExprSymbol && \"Function not found\");\n\n          // Get the symbol's address and cast it to the right type (takes no\n          // arguments, returns a double) so we can call it as a native function.\n          double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();\n          fprintf(stderr, \"Evaluated to %f\\n\", FP());\n\n          // Delete the anonymous expression module from the JIT.\n          TheJIT->removeModule(H);\n        }\n\nIf parsing and codegen succeeed, the next step is to add the module containing\nthe top-level expression to the JIT. We do this by calling addModule, which\ntriggers code generation for all the functions in the module, and returns a\nhandle that can be used to remove the module from the JIT later. Once the module\nhas been added to the JIT it can no longer be modified, so we also open a new\nmodule to hold subsequent code by calling ``InitializeModuleAndPassManager()``.\n\nOnce we've added the module to the JIT we need to get a pointer to the final\ngenerated code. We do this by calling the JIT's findSymbol method, and passing\nthe name of the top-level expression function: ``__anon_expr``. Since we just\nadded this function, we assert that findSymbol returned a result.\n\nNext, we get the in-memory address of the ``__anon_expr`` function by calling\n``getAddress()`` on the symbol. Recall that we compile top-level expressions\ninto a self-contained LLVM function that takes no arguments and returns the\ncomputed double. Because the LLVM JIT compiler matches the native platform ABI,\nthis means that you can just cast the result pointer to a function pointer of\nthat type and call it directly. This means, there is no difference between JIT\ncompiled code and native machine code that is statically linked into your\napplication.\n\nFinally, since we don't support re-evaluation of top-level expressions, we\nremove the module from the JIT when we're done to free the associated memory.\nRecall, however, that the module we created a few lines earlier (via\n``InitializeModuleAndPassManager``) is still open and waiting for new code to be\nadded.\n\nWith just these two changes, lets see how Kaleidoscope works now!\n\n::\n\n    ready> 4+5;\n    Read top-level expression:\n    define double @0() {\n    entry:\n      ret double 9.000000e+00\n    }\n\n    Evaluated to 9.000000\n\nWell this looks like it is basically working. The dump of the function\nshows the \"no argument function that always returns double\" that we\nsynthesize for each top-level expression that is typed in. This\ndemonstrates very basic functionality, but can we do more?\n\n::\n\n    ready> def testfunc(x y) x + y*2;\n    Read function definition:\n    define double @testfunc(double %x, double %y) {\n    entry:\n      %multmp = fmul double %y, 2.000000e+00\n      %addtmp = fadd double %multmp, %x\n      ret double %addtmp\n    }\n\n    ready> testfunc(4, 10);\n    Read top-level expression:\n    define double @1() {\n    entry:\n      %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)\n      ret double %calltmp\n    }\n\n    Evaluated to 24.000000\n\n    ready> testfunc(5, 10);\n    ready> LLVM ERROR: Program used external function 'testfunc' which could not be resolved!\n\n\nFunction definitions and calls also work, but something went very wrong on that\nlast line. The call looks valid, so what happened? As you may have guessed from\nthe the API a Module is a unit of allocation for the JIT, and testfunc was part\nof the same module that contained anonymous expression. When we removed that\nmodule from the JIT to free the memory for the anonymous expression, we deleted\nthe definition of ``testfunc`` along with it. Then, when we tried to call\ntestfunc a second time, the JIT could no longer find it.\n\nThe easiest way to fix this is to put the anonymous expression in a separate\nmodule from the rest of the function definitions. The JIT will happily resolve\nfunction calls across module boundaries, as long as each of the functions called\nhas a prototype, and is added to the JIT before it is called. By putting the\nanonymous expression in a different module we can delete it without affecting\nthe rest of the functions.\n\nIn fact, we're going to go a step further and put every function in its own\nmodule. Doing so allows us to exploit a useful property of the KaleidoscopeJIT\nthat will make our environment more REPL-like: Functions can be added to the\nJIT more than once (unlike a module where every function must have a unique\ndefinition). When you look up a symbol in KaleidoscopeJIT it will always return\nthe most recent definition:\n\n::\n\n    ready> def foo(x) x + 1;\n    Read function definition:\n    define double @foo(double %x) {\n    entry:\n      %addtmp = fadd double %x, 1.000000e+00\n      ret double %addtmp\n    }\n\n    ready> foo(2);\n    Evaluated to 3.000000\n\n    ready> def foo(x) x + 2;\n    define double @foo(double %x) {\n    entry:\n      %addtmp = fadd double %x, 2.000000e+00\n      ret double %addtmp\n    }\n\n    ready> foo(2);\n    Evaluated to 4.000000\n\n\nTo allow each function to live in its own module we'll need a way to\nre-generate previous function declarations into each new module we open:\n\n.. code-block:: c++\n\n    static std::unique_ptr<KaleidoscopeJIT> TheJIT;\n\n    ...\n\n    Function *getFunction(std::string Name) {\n      // First, see if the function has already been added to the current module.\n      if (auto *F = TheModule->getFunction(Name))\n        return F;\n\n      // If not, check whether we can codegen the declaration from some existing\n      // prototype.\n      auto FI = FunctionProtos.find(Name);\n      if (FI != FunctionProtos.end())\n        return FI->second->codegen();\n\n      // If no existing prototype exists, return null.\n      return nullptr;\n    }\n\n    ...\n\n    Value *CallExprAST::codegen() {\n      // Look up the name in the global module table.\n      Function *CalleeF = getFunction(Callee);\n\n    ...\n\n    Function *FunctionAST::codegen() {\n      // Transfer ownership of the prototype to the FunctionProtos map, but keep a\n      // reference to it for use below.\n      auto &P = *Proto;\n      FunctionProtos[Proto->getName()] = std::move(Proto);\n      Function *TheFunction = getFunction(P.getName());\n      if (!TheFunction)\n        return nullptr;\n\n\nTo enable this, we'll start by adding a new global, ``FunctionProtos``, that\nholds the most recent prototype for each function. We'll also add a convenience\nmethod, ``getFunction()``, to replace calls to ``TheModule->getFunction()``.\nOur convenience method searches ``TheModule`` for an existing function\ndeclaration, falling back to generating a new declaration from FunctionProtos if\nit doesn't find one. In ``CallExprAST::codegen()`` we just need to replace the\ncall to ``TheModule->getFunction()``. In ``FunctionAST::codegen()`` we need to\nupdate the FunctionProtos map first, then call ``getFunction()``. With this\ndone, we can always obtain a function declaration in the current module for any\npreviously declared function.\n\nWe also need to update HandleDefinition and HandleExtern:\n\n.. code-block:: c++\n\n    static void HandleDefinition() {\n      if (auto FnAST = ParseDefinition()) {\n        if (auto *FnIR = FnAST->codegen()) {\n          fprintf(stderr, \"Read function definition:\");\n          FnIR->print(errs());\n          fprintf(stderr, \"\\n\");\n          TheJIT->addModule(std::move(TheModule));\n          InitializeModuleAndPassManager();\n        }\n      } else {\n        // Skip token for error recovery.\n         getNextToken();\n      }\n    }\n\n    static void HandleExtern() {\n      if (auto ProtoAST = ParseExtern()) {\n        if (auto *FnIR = ProtoAST->codegen()) {\n          fprintf(stderr, \"Read extern: \");\n          FnIR->print(errs());\n          fprintf(stderr, \"\\n\");\n          FunctionProtos[ProtoAST->getName()] = std::move(ProtoAST);\n        }\n      } else {\n        // Skip token for error recovery.\n        getNextToken();\n      }\n    }\n\nIn HandleDefinition, we add two lines to transfer the newly defined function to\nthe JIT and open a new module. In HandleExtern, we just need to add one line to\nadd the prototype to FunctionProtos.\n\nWith these changes made, lets try our REPL again (I removed the dump of the\nanonymous functions this time, you should get the idea by now :) :\n\n::\n\n    ready> def foo(x) x + 1;\n    ready> foo(2);\n    Evaluated to 3.000000\n\n    ready> def foo(x) x + 2;\n    ready> foo(2);\n    Evaluated to 4.000000\n\nIt works!\n\nEven with this simple code, we get some surprisingly powerful capabilities -\ncheck this out:\n\n::\n\n    ready> extern sin(x);\n    Read extern:\n    declare double @sin(double)\n\n    ready> extern cos(x);\n    Read extern:\n    declare double @cos(double)\n\n    ready> sin(1.0);\n    Read top-level expression:\n    define double @2() {\n    entry:\n      ret double 0x3FEAED548F090CEE\n    }\n\n    Evaluated to 0.841471\n\n    ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);\n    Read function definition:\n    define double @foo(double %x) {\n    entry:\n      %calltmp = call double @sin(double %x)\n      %multmp = fmul double %calltmp, %calltmp\n      %calltmp2 = call double @cos(double %x)\n      %multmp4 = fmul double %calltmp2, %calltmp2\n      %addtmp = fadd double %multmp, %multmp4\n      ret double %addtmp\n    }\n\n    ready> foo(4.0);\n    Read top-level expression:\n    define double @3() {\n    entry:\n      %calltmp = call double @foo(double 4.000000e+00)\n      ret double %calltmp\n    }\n\n    Evaluated to 1.000000\n\nWhoa, how does the JIT know about sin and cos? The answer is surprisingly\nsimple: The KaleidoscopeJIT has a straightforward symbol resolution rule that\nit uses to find symbols that aren't available in any given module: First\nit searches all the modules that have already been added to the JIT, from the\nmost recent to the oldest, to find the newest definition. If no definition is\nfound inside the JIT, it falls back to calling \"``dlsym(\"sin\")``\" on the\nKaleidoscope process itself. Since \"``sin``\" is defined within the JIT's\naddress space, it simply patches up calls in the module to call the libm\nversion of ``sin`` directly. But in some cases this even goes further:\nas sin and cos are names of standard math functions, the constant folder\nwill directly evaluate the function calls to the correct result when called\nwith constants like in the \"``sin(1.0)``\" above.\n\nIn the future we'll see how tweaking this symbol resolution rule can be used to\nenable all sorts of useful features, from security (restricting the set of\nsymbols available to JIT'd code), to dynamic code generation based on symbol\nnames, and even lazy compilation.\n\nOne immediate benefit of the symbol resolution rule is that we can now extend\nthe language by writing arbitrary C++ code to implement operations. For example,\nif we add:\n\n.. code-block:: c++\n\n    #ifdef LLVM_ON_WIN32\n    #define DLLEXPORT __declspec(dllexport)\n    #else\n    #define DLLEXPORT\n    #endif\n\n    /// putchard - putchar that takes a double and returns 0.\n    extern \"C\" DLLEXPORT double putchard(double X) {\n      fputc((char)X, stderr);\n      return 0;\n    }\n\nNote, that for Windows we need to actually export the functions because\nthe dynamic symbol loader will use GetProcAddress to find the symbols.\n\nNow we can produce simple output to the console by using things like:\n\"``extern putchard(x); putchard(120);``\", which prints a lowercase 'x'\non the console (120 is the ASCII code for 'x'). Similar code could be\nused to implement file I/O, console input, and many other capabilities\nin Kaleidoscope.\n\nThis completes the JIT and optimizer chapter of the Kaleidoscope\ntutorial. At this point, we can compile a non-Turing-complete\nprogramming language, optimize and JIT compile it in a user-driven way.\nNext up we'll look into `extending the language with control flow\nconstructs <LangImpl05.html>`_, tackling some interesting LLVM IR issues\nalong the way.\n\nFull Code Listing\n=================\n\nHere is the complete code listing for our running example, enhanced with\nthe LLVM JIT and optimizer. To build this example, use:\n\n.. code-block:: bash\n\n    # Compile\n    clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy\n    # Run\n    ./toy\n\nIf you are compiling this on Linux, make sure to add the \"-rdynamic\"\noption as well. This makes sure that the external functions are resolved\nproperly at runtime.\n\nHere is the code:\n\n.. literalinclude:: ../../examples/Kaleidoscope/Chapter4/toy.cpp\n   :language: c++\n\n`Next: Extending the language: control flow <LangImpl05.html>`_\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/tutorial/OCamlLangImpl4.rst": "==============================================\nKaleidoscope: Adding JIT and Optimizer Support\n==============================================\n\n.. contents::\n   :local:\n\nChapter 4 Introduction\n======================\n\nWelcome to Chapter 4 of the \"`Implementing a language with\nLLVM <index.html>`_\" tutorial. Chapters 1-3 described the implementation\nof a simple language and added support for generating LLVM IR. This\nchapter describes two new techniques: adding optimizer support to your\nlanguage, and adding JIT compiler support. These additions will\ndemonstrate how to get nice, efficient code for the Kaleidoscope\nlanguage.\n\nTrivial Constant Folding\n========================\n\n**Note:** the default ``IRBuilder`` now always includes the constant\nfolding optimisations below.\n\nOur demonstration for Chapter 3 is elegant and easy to extend.\nUnfortunately, it does not produce wonderful code. For example, when\ncompiling simple code, we don't get obvious optimizations:\n\n::\n\n    ready> def test(x) 1+2+x;\n    Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 1.000000e+00, 2.000000e+00\n            %addtmp1 = fadd double %addtmp, %x\n            ret double %addtmp1\n    }\n\nThis code is a very, very literal transcription of the AST built by\nparsing the input. As such, this transcription lacks optimizations like\nconstant folding (we'd like to get \"``add x, 3.0``\" in the example\nabove) as well as other more important optimizations. Constant folding,\nin particular, is a very common and very important optimization: so much\nso that many language implementors implement constant folding support in\ntheir AST representation.\n\nWith LLVM, you don't need this support in the AST. Since all calls to\nbuild LLVM IR go through the LLVM builder, it would be nice if the\nbuilder itself checked to see if there was a constant folding\nopportunity when you call it. If so, it could just do the constant fold\nand return the constant instead of creating an instruction. This is\nexactly what the ``LLVMFoldingBuilder`` class does.\n\nAll we did was switch from ``LLVMBuilder`` to ``LLVMFoldingBuilder``.\nThough we change no other code, we now have all of our instructions\nimplicitly constant folded without us having to do anything about it.\nFor example, the input above now compiles to:\n\n::\n\n    ready> def test(x) 1+2+x;\n    Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 3.000000e+00, %x\n            ret double %addtmp\n    }\n\nWell, that was easy :). In practice, we recommend always using\n``LLVMFoldingBuilder`` when generating code like this. It has no\n\"syntactic overhead\" for its use (you don't have to uglify your compiler\nwith constant checks everywhere) and it can dramatically reduce the\namount of LLVM IR that is generated in some cases (particular for\nlanguages with a macro preprocessor or that use a lot of constants).\n\nOn the other hand, the ``LLVMFoldingBuilder`` is limited by the fact\nthat it does all of its analysis inline with the code as it is built. If\nyou take a slightly more complex example:\n\n::\n\n    ready> def test(x) (1+2+x)*(x+(1+2));\n    ready> Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double 3.000000e+00, %x\n            %addtmp1 = fadd double %x, 3.000000e+00\n            %multmp = fmul double %addtmp, %addtmp1\n            ret double %multmp\n    }\n\nIn this case, the LHS and RHS of the multiplication are the same value.\nWe'd really like to see this generate \"``tmp = x+3; result = tmp*tmp;``\"\ninstead of computing \"``x*3``\" twice.\n\nUnfortunately, no amount of local analysis will be able to detect and\ncorrect this. This requires two transformations: reassociation of\nexpressions (to make the add's lexically identical) and Common\nSubexpression Elimination (CSE) to delete the redundant add instruction.\nFortunately, LLVM provides a broad range of optimizations that you can\nuse, in the form of \"passes\".\n\nLLVM Optimization Passes\n========================\n\nLLVM provides many optimization passes, which do many different sorts of\nthings and have different tradeoffs. Unlike other systems, LLVM doesn't\nhold to the mistaken notion that one set of optimizations is right for\nall languages and for all situations. LLVM allows a compiler implementor\nto make complete decisions about what optimizations to use, in which\norder, and in what situation.\n\nAs a concrete example, LLVM supports both \"whole module\" passes, which\nlook across as large of body of code as they can (often a whole file,\nbut if run at link time, this can be a substantial portion of the whole\nprogram). It also supports and includes \"per-function\" passes which just\noperate on a single function at a time, without looking at other\nfunctions. For more information on passes and how they are run, see the\n`How to Write a Pass <../WritingAnLLVMPass.html>`_ document and the\n`List of LLVM Passes <../Passes.html>`_.\n\nFor Kaleidoscope, we are currently generating functions on the fly, one\nat a time, as the user types them in. We aren't shooting for the\nultimate optimization experience in this setting, but we also want to\ncatch the easy and quick stuff where possible. As such, we will choose\nto run a few per-function optimizations as the user types the function\nin. If we wanted to make a \"static Kaleidoscope compiler\", we would use\nexactly the code we have now, except that we would defer running the\noptimizer until the entire file has been parsed.\n\nIn order to get per-function optimizations going, we need to set up a\n`Llvm.PassManager <../WritingAnLLVMPass.html#what-passmanager-does>`_ to hold and\norganize the LLVM optimizations that we want to run. Once we have that,\nwe can add a set of optimizations to run. The code looks like this:\n\n.. code-block:: ocaml\n\n      (* Create the JIT. *)\n      let the_execution_engine = ExecutionEngine.create Codegen.the_module in\n      let the_fpm = PassManager.create_function Codegen.the_module in\n\n      (* Set up the optimizer pipeline.  Start with registering info about how the\n       * target lays out data structures. *)\n      DataLayout.add (ExecutionEngine.target_data the_execution_engine) the_fpm;\n\n      (* Do simple \"peephole\" optimizations and bit-twiddling optzn. *)\n      add_instruction_combining the_fpm;\n\n      (* reassociate expressions. *)\n      add_reassociation the_fpm;\n\n      (* Eliminate Common SubExpressions. *)\n      add_gvn the_fpm;\n\n      (* Simplify the control flow graph (deleting unreachable blocks, etc). *)\n      add_cfg_simplification the_fpm;\n\n      ignore (PassManager.initialize the_fpm);\n\n      (* Run the main \"interpreter loop\" now. *)\n      Toplevel.main_loop the_fpm the_execution_engine stream;\n\nThe meat of the matter here, is the definition of \"``the_fpm``\". It\nrequires a pointer to the ``the_module`` to construct itself. Once it is\nset up, we use a series of \"add\" calls to add a bunch of LLVM passes.\nThe first pass is basically boilerplate, it adds a pass so that later\noptimizations know how the data structures in the program are laid out.\nThe \"``the_execution_engine``\" variable is related to the JIT, which we\nwill get to in the next section.\n\nIn this case, we choose to add 4 optimization passes. The passes we\nchose here are a pretty standard set of \"cleanup\" optimizations that are\nuseful for a wide variety of code. I won't delve into what they do but,\nbelieve me, they are a good starting place :).\n\nOnce the ``Llvm.PassManager.`` is set up, we need to make use of it. We\ndo this by running it after our newly created function is constructed\n(in ``Codegen.codegen_func``), but before it is returned to the client:\n\n.. code-block:: ocaml\n\n    let codegen_func the_fpm = function\n          ...\n          try\n            let ret_val = codegen_expr body in\n\n            (* Finish off the function. *)\n            let _ = build_ret ret_val builder in\n\n            (* Validate the generated code, checking for consistency. *)\n            Llvm_analysis.assert_valid_function the_function;\n\n            (* Optimize the function. *)\n            let _ = PassManager.run_function the_function the_fpm in\n\n            the_function\n\nAs you can see, this is pretty straightforward. The ``the_fpm``\noptimizes and updates the LLVM Function\\* in place, improving\n(hopefully) its body. With this in place, we can try our test above\nagain:\n\n::\n\n    ready> def test(x) (1+2+x)*(x+(1+2));\n    ready> Read function definition:\n    define double @test(double %x) {\n    entry:\n            %addtmp = fadd double %x, 3.000000e+00\n            %multmp = fmul double %addtmp, %addtmp\n            ret double %multmp\n    }\n\nAs expected, we now get our nicely optimized code, saving a floating\npoint add instruction from every execution of this function.\n\nLLVM provides a wide variety of optimizations that can be used in\ncertain circumstances. Some `documentation about the various\npasses <../Passes.html>`_ is available, but it isn't very complete.\nAnother good source of ideas can come from looking at the passes that\n``Clang`` runs to get started. The \"``opt``\" tool allows you to\nexperiment with passes from the command line, so you can see if they do\nanything.\n\nNow that we have reasonable code coming out of our front-end, lets talk\nabout executing it!\n\nAdding a JIT Compiler\n=====================\n\nCode that is available in LLVM IR can have a wide variety of tools\napplied to it. For example, you can run optimizations on it (as we did\nabove), you can dump it out in textual or binary forms, you can compile\nthe code to an assembly file (.s) for some target, or you can JIT\ncompile it. The nice thing about the LLVM IR representation is that it\nis the \"common currency\" between many different parts of the compiler.\n\nIn this section, we'll add JIT compiler support to our interpreter. The\nbasic idea that we want for Kaleidoscope is to have the user enter\nfunction bodies as they do now, but immediately evaluate the top-level\nexpressions they type in. For example, if they type in \"1 + 2;\", we\nshould evaluate and print out 3. If they define a function, they should\nbe able to call it from the command line.\n\nIn order to do this, we first declare and initialize the JIT. This is\ndone by adding a global variable and a call in ``main``:\n\n.. code-block:: ocaml\n\n    ...\n    let main () =\n      ...\n      (* Create the JIT. *)\n      let the_execution_engine = ExecutionEngine.create Codegen.the_module in\n      ...\n\nThis creates an abstract \"Execution Engine\" which can be either a JIT\ncompiler or the LLVM interpreter. LLVM will automatically pick a JIT\ncompiler for you if one is available for your platform, otherwise it\nwill fall back to the interpreter.\n\nOnce the ``Llvm_executionengine.ExecutionEngine.t`` is created, the JIT\nis ready to be used. There are a variety of APIs that are useful, but\nthe simplest one is the\n\"``Llvm_executionengine.ExecutionEngine.run_function``\" function. This\nmethod JIT compiles the specified LLVM Function and returns a function\npointer to the generated machine code. In our case, this means that we\ncan change the code that parses a top-level expression to look like\nthis:\n\n.. code-block:: ocaml\n\n                (* Evaluate a top-level expression into an anonymous function. *)\n                let e = Parser.parse_toplevel stream in\n                print_endline \"parsed a top-level expr\";\n                let the_function = Codegen.codegen_func the_fpm e in\n                dump_value the_function;\n\n                (* JIT the function, returning a function pointer. *)\n                let result = ExecutionEngine.run_function the_function [||]\n                  the_execution_engine in\n\n                print_string \"Evaluated to \";\n                print_float (GenericValue.as_float Codegen.double_type result);\n                print_newline ();\n\nRecall that we compile top-level expressions into a self-contained LLVM\nfunction that takes no arguments and returns the computed double.\nBecause the LLVM JIT compiler matches the native platform ABI, this\nmeans that you can just cast the result pointer to a function pointer of\nthat type and call it directly. This means, there is no difference\nbetween JIT compiled code and native machine code that is statically\nlinked into your application.\n\nWith just these two changes, lets see how Kaleidoscope works now!\n\n::\n\n    ready> 4+5;\n    define double @\"\"() {\n    entry:\n            ret double 9.000000e+00\n    }\n\n    Evaluated to 9.000000\n\nWell this looks like it is basically working. The dump of the function\nshows the \"no argument function that always returns double\" that we\nsynthesize for each top level expression that is typed in. This\ndemonstrates very basic functionality, but can we do more?\n\n::\n\n    ready> def testfunc(x y) x + y*2;\n    Read function definition:\n    define double @testfunc(double %x, double %y) {\n    entry:\n            %multmp = fmul double %y, 2.000000e+00\n            %addtmp = fadd double %multmp, %x\n            ret double %addtmp\n    }\n\n    ready> testfunc(4, 10);\n    define double @\"\"() {\n    entry:\n            %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)\n            ret double %calltmp\n    }\n\n    Evaluated to 24.000000\n\nThis illustrates that we can now call user code, but there is something\na bit subtle going on here. Note that we only invoke the JIT on the\nanonymous functions that *call testfunc*, but we never invoked it on\n*testfunc* itself. What actually happened here is that the JIT scanned\nfor all non-JIT'd functions transitively called from the anonymous\nfunction and compiled all of them before returning from\n``run_function``.\n\nThe JIT provides a number of other more advanced interfaces for things\nlike freeing allocated machine code, rejit'ing functions to update them,\netc. However, even with this simple code, we get some surprisingly\npowerful capabilities - check this out (I removed the dump of the\nanonymous functions, you should get the idea by now :) :\n\n::\n\n    ready> extern sin(x);\n    Read extern:\n    declare double @sin(double)\n\n    ready> extern cos(x);\n    Read extern:\n    declare double @cos(double)\n\n    ready> sin(1.0);\n    Evaluated to 0.841471\n\n    ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);\n    Read function definition:\n    define double @foo(double %x) {\n    entry:\n            %calltmp = call double @sin(double %x)\n            %multmp = fmul double %calltmp, %calltmp\n            %calltmp2 = call double @cos(double %x)\n            %multmp4 = fmul double %calltmp2, %calltmp2\n            %addtmp = fadd double %multmp, %multmp4\n            ret double %addtmp\n    }\n\n    ready> foo(4.0);\n    Evaluated to 1.000000\n\nWhoa, how does the JIT know about sin and cos? The answer is\nsurprisingly simple: in this example, the JIT started execution of a\nfunction and got to a function call. It realized that the function was\nnot yet JIT compiled and invoked the standard set of routines to resolve\nthe function. In this case, there is no body defined for the function,\nso the JIT ended up calling \"``dlsym(\"sin\")``\" on the Kaleidoscope\nprocess itself. Since \"``sin``\" is defined within the JIT's address\nspace, it simply patches up calls in the module to call the libm version\nof ``sin`` directly.\n\nThe LLVM JIT provides a number of interfaces (look in the\n``llvm_executionengine.mli`` file) for controlling how unknown functions\nget resolved. It allows you to establish explicit mappings between IR\nobjects and addresses (useful for LLVM global variables that you want to\nmap to static tables, for example), allows you to dynamically decide on\nthe fly based on the function name, and even allows you to have the JIT\ncompile functions lazily the first time they're called.\n\nOne interesting application of this is that we can now extend the\nlanguage by writing arbitrary C code to implement operations. For\nexample, if we add:\n\n.. code-block:: c++\n\n    /* putchard - putchar that takes a double and returns 0. */\n    extern \"C\"\n    double putchard(double X) {\n      putchar((char)X);\n      return 0;\n    }\n\nNow we can produce simple output to the console by using things like:\n\"``extern putchard(x); putchard(120);``\", which prints a lowercase 'x'\non the console (120 is the ASCII code for 'x'). Similar code could be\nused to implement file I/O, console input, and many other capabilities\nin Kaleidoscope.\n\nThis completes the JIT and optimizer chapter of the Kaleidoscope\ntutorial. At this point, we can compile a non-Turing-complete\nprogramming language, optimize and JIT compile it in a user-driven way.\nNext up we'll look into `extending the language with control flow\nconstructs <OCamlLangImpl5.html>`_, tackling some interesting LLVM IR\nissues along the way.\n\nFull Code Listing\n=================\n\nHere is the complete code listing for our running example, enhanced with\nthe LLVM JIT and optimizer. To build this example, use:\n\n.. code-block:: bash\n\n    # Compile\n    ocamlbuild toy.byte\n    # Run\n    ./toy.byte\n\nHere is the code:\n\n\\_tags:\n    ::\n\n        <{lexer,parser}.ml>: use_camlp4, pp(camlp4of)\n        <*.{byte,native}>: g++, use_llvm, use_llvm_analysis\n        <*.{byte,native}>: use_llvm_executionengine, use_llvm_target\n        <*.{byte,native}>: use_llvm_scalar_opts, use_bindings\n\nmyocamlbuild.ml:\n    .. code-block:: ocaml\n\n        open Ocamlbuild_plugin;;\n\n        ocaml_lib ~extern:true \"llvm\";;\n        ocaml_lib ~extern:true \"llvm_analysis\";;\n        ocaml_lib ~extern:true \"llvm_executionengine\";;\n        ocaml_lib ~extern:true \"llvm_target\";;\n        ocaml_lib ~extern:true \"llvm_scalar_opts\";;\n\n        flag [\"link\"; \"ocaml\"; \"g++\"] (S[A\"-cc\"; A\"g++\"]);;\n        dep [\"link\"; \"ocaml\"; \"use_bindings\"] [\"bindings.o\"];;\n\ntoken.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Lexer Tokens\n         *===----------------------------------------------------------------------===*)\n\n        (* The lexer returns these 'Kwd' if it is an unknown character, otherwise one of\n         * these others for known things. *)\n        type token =\n          (* commands *)\n          | Def | Extern\n\n          (* primary *)\n          | Ident of string | Number of float\n\n          (* unknown *)\n          | Kwd of char\n\nlexer.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Lexer\n         *===----------------------------------------------------------------------===*)\n\n        let rec lex = parser\n          (* Skip any whitespace. *)\n          | [< ' (' ' | '\\n' | '\\r' | '\\t'); stream >] -> lex stream\n\n          (* identifier: [a-zA-Z][a-zA-Z0-9] *)\n          | [< ' ('A' .. 'Z' | 'a' .. 'z' as c); stream >] ->\n              let buffer = Buffer.create 1 in\n              Buffer.add_char buffer c;\n              lex_ident buffer stream\n\n          (* number: [0-9.]+ *)\n          | [< ' ('0' .. '9' as c); stream >] ->\n              let buffer = Buffer.create 1 in\n              Buffer.add_char buffer c;\n              lex_number buffer stream\n\n          (* Comment until end of line. *)\n          | [< ' ('#'); stream >] ->\n              lex_comment stream\n\n          (* Otherwise, just return the character as its ascii value. *)\n          | [< 'c; stream >] ->\n              [< 'Token.Kwd c; lex stream >]\n\n          (* end of stream. *)\n          | [< >] -> [< >]\n\n        and lex_number buffer = parser\n          | [< ' ('0' .. '9' | '.' as c); stream >] ->\n              Buffer.add_char buffer c;\n              lex_number buffer stream\n          | [< stream=lex >] ->\n              [< 'Token.Number (float_of_string (Buffer.contents buffer)); stream >]\n\n        and lex_ident buffer = parser\n          | [< ' ('A' .. 'Z' | 'a' .. 'z' | '0' .. '9' as c); stream >] ->\n              Buffer.add_char buffer c;\n              lex_ident buffer stream\n          | [< stream=lex >] ->\n              match Buffer.contents buffer with\n              | \"def\" -> [< 'Token.Def; stream >]\n              | \"extern\" -> [< 'Token.Extern; stream >]\n              | id -> [< 'Token.Ident id; stream >]\n\n        and lex_comment = parser\n          | [< ' ('\\n'); stream=lex >] -> stream\n          | [< 'c; e=lex_comment >] -> e\n          | [< >] -> [< >]\n\nast.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Abstract Syntax Tree (aka Parse Tree)\n         *===----------------------------------------------------------------------===*)\n\n        (* expr - Base type for all expression nodes. *)\n        type expr =\n          (* variant for numeric literals like \"1.0\". *)\n          | Number of float\n\n          (* variant for referencing a variable, like \"a\". *)\n          | Variable of string\n\n          (* variant for a binary operator. *)\n          | Binary of char * expr * expr\n\n          (* variant for function calls. *)\n          | Call of string * expr array\n\n        (* proto - This type represents the \"prototype\" for a function, which captures\n         * its name, and its argument names (thus implicitly the number of arguments the\n         * function takes). *)\n        type proto = Prototype of string * string array\n\n        (* func - This type represents a function definition itself. *)\n        type func = Function of proto * expr\n\nparser.ml:\n    .. code-block:: ocaml\n\n        (*===---------------------------------------------------------------------===\n         * Parser\n         *===---------------------------------------------------------------------===*)\n\n        (* binop_precedence - This holds the precedence for each binary operator that is\n         * defined *)\n        let binop_precedence:(char, int) Hashtbl.t = Hashtbl.create 10\n\n        (* precedence - Get the precedence of the pending binary operator token. *)\n        let precedence c = try Hashtbl.find binop_precedence c with Not_found -> -1\n\n        (* primary\n         *   ::= identifier\n         *   ::= numberexpr\n         *   ::= parenexpr *)\n        let rec parse_primary = parser\n          (* numberexpr ::= number *)\n          | [< 'Token.Number n >] -> Ast.Number n\n\n          (* parenexpr ::= '(' expression ')' *)\n          | [< 'Token.Kwd '('; e=parse_expr; 'Token.Kwd ')' ?? \"expected ')'\" >] -> e\n\n          (* identifierexpr\n           *   ::= identifier\n           *   ::= identifier '(' argumentexpr ')' *)\n          | [< 'Token.Ident id; stream >] ->\n              let rec parse_args accumulator = parser\n                | [< e=parse_expr; stream >] ->\n                    begin parser\n                      | [< 'Token.Kwd ','; e=parse_args (e :: accumulator) >] -> e\n                      | [< >] -> e :: accumulator\n                    end stream\n                | [< >] -> accumulator\n              in\n              let rec parse_ident id = parser\n                (* Call. *)\n                | [< 'Token.Kwd '(';\n                     args=parse_args [];\n                     'Token.Kwd ')' ?? \"expected ')'\">] ->\n                    Ast.Call (id, Array.of_list (List.rev args))\n\n                (* Simple variable ref. *)\n                | [< >] -> Ast.Variable id\n              in\n              parse_ident id stream\n\n          | [< >] -> raise (Stream.Error \"unknown token when expecting an expression.\")\n\n        (* binoprhs\n         *   ::= ('+' primary)* *)\n        and parse_bin_rhs expr_prec lhs stream =\n          match Stream.peek stream with\n          (* If this is a binop, find its precedence. *)\n          | Some (Token.Kwd c) when Hashtbl.mem binop_precedence c ->\n              let token_prec = precedence c in\n\n              (* If this is a binop that binds at least as tightly as the current binop,\n               * consume it, otherwise we are done. *)\n              if token_prec < expr_prec then lhs else begin\n                (* Eat the binop. *)\n                Stream.junk stream;\n\n                (* Parse the primary expression after the binary operator. *)\n                let rhs = parse_primary stream in\n\n                (* Okay, we know this is a binop. *)\n                let rhs =\n                  match Stream.peek stream with\n                  | Some (Token.Kwd c2) ->\n                      (* If BinOp binds less tightly with rhs than the operator after\n                       * rhs, let the pending operator take rhs as its lhs. *)\n                      let next_prec = precedence c2 in\n                      if token_prec < next_prec\n                      then parse_bin_rhs (token_prec + 1) rhs stream\n                      else rhs\n                  | _ -> rhs\n                in\n\n                (* Merge lhs/rhs. *)\n                let lhs = Ast.Binary (c, lhs, rhs) in\n                parse_bin_rhs expr_prec lhs stream\n              end\n          | _ -> lhs\n\n        (* expression\n         *   ::= primary binoprhs *)\n        and parse_expr = parser\n          | [< lhs=parse_primary; stream >] -> parse_bin_rhs 0 lhs stream\n\n        (* prototype\n         *   ::= id '(' id* ')' *)\n        let parse_prototype =\n          let rec parse_args accumulator = parser\n            | [< 'Token.Ident id; e=parse_args (id::accumulator) >] -> e\n            | [< >] -> accumulator\n          in\n\n          parser\n          | [< 'Token.Ident id;\n               'Token.Kwd '(' ?? \"expected '(' in prototype\";\n               args=parse_args [];\n               'Token.Kwd ')' ?? \"expected ')' in prototype\" >] ->\n              (* success. *)\n              Ast.Prototype (id, Array.of_list (List.rev args))\n\n          | [< >] ->\n              raise (Stream.Error \"expected function name in prototype\")\n\n        (* definition ::= 'def' prototype expression *)\n        let parse_definition = parser\n          | [< 'Token.Def; p=parse_prototype; e=parse_expr >] ->\n              Ast.Function (p, e)\n\n        (* toplevelexpr ::= expression *)\n        let parse_toplevel = parser\n          | [< e=parse_expr >] ->\n              (* Make an anonymous proto. *)\n              Ast.Function (Ast.Prototype (\"\", [||]), e)\n\n        (*  external ::= 'extern' prototype *)\n        let parse_extern = parser\n          | [< 'Token.Extern; e=parse_prototype >] -> e\n\ncodegen.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Code Generation\n         *===----------------------------------------------------------------------===*)\n\n        open Llvm\n\n        exception Error of string\n\n        let context = global_context ()\n        let the_module = create_module context \"my cool jit\"\n        let builder = builder context\n        let named_values:(string, llvalue) Hashtbl.t = Hashtbl.create 10\n        let double_type = double_type context\n\n        let rec codegen_expr = function\n          | Ast.Number n -> const_float double_type n\n          | Ast.Variable name ->\n              (try Hashtbl.find named_values name with\n                | Not_found -> raise (Error \"unknown variable name\"))\n          | Ast.Binary (op, lhs, rhs) ->\n              let lhs_val = codegen_expr lhs in\n              let rhs_val = codegen_expr rhs in\n              begin\n                match op with\n                | '+' -> build_add lhs_val rhs_val \"addtmp\" builder\n                | '-' -> build_sub lhs_val rhs_val \"subtmp\" builder\n                | '*' -> build_mul lhs_val rhs_val \"multmp\" builder\n                | '<' ->\n                    (* Convert bool 0/1 to double 0.0 or 1.0 *)\n                    let i = build_fcmp Fcmp.Ult lhs_val rhs_val \"cmptmp\" builder in\n                    build_uitofp i double_type \"booltmp\" builder\n                | _ -> raise (Error \"invalid binary operator\")\n              end\n          | Ast.Call (callee, args) ->\n              (* Look up the name in the module table. *)\n              let callee =\n                match lookup_function callee the_module with\n                | Some callee -> callee\n                | None -> raise (Error \"unknown function referenced\")\n              in\n              let params = params callee in\n\n              (* If argument mismatch error. *)\n              if Array.length params == Array.length args then () else\n                raise (Error \"incorrect # arguments passed\");\n              let args = Array.map codegen_expr args in\n              build_call callee args \"calltmp\" builder\n\n        let codegen_proto = function\n          | Ast.Prototype (name, args) ->\n              (* Make the function type: double(double,double) etc. *)\n              let doubles = Array.make (Array.length args) double_type in\n              let ft = function_type double_type doubles in\n              let f =\n                match lookup_function name the_module with\n                | None -> declare_function name ft the_module\n\n                (* If 'f' conflicted, there was already something named 'name'. If it\n                 * has a body, don't allow redefinition or reextern. *)\n                | Some f ->\n                    (* If 'f' already has a body, reject this. *)\n                    if block_begin f <> At_end f then\n                      raise (Error \"redefinition of function\");\n\n                    (* If 'f' took a different number of arguments, reject. *)\n                    if element_type (type_of f) <> ft then\n                      raise (Error \"redefinition of function with different # args\");\n                    f\n              in\n\n              (* Set names for all arguments. *)\n              Array.iteri (fun i a ->\n                let n = args.(i) in\n                set_value_name n a;\n                Hashtbl.add named_values n a;\n              ) (params f);\n              f\n\n        let codegen_func the_fpm = function\n          | Ast.Function (proto, body) ->\n              Hashtbl.clear named_values;\n              let the_function = codegen_proto proto in\n\n              (* Create a new basic block to start insertion into. *)\n              let bb = append_block context \"entry\" the_function in\n              position_at_end bb builder;\n\n              try\n                let ret_val = codegen_expr body in\n\n                (* Finish off the function. *)\n                let _ = build_ret ret_val builder in\n\n                (* Validate the generated code, checking for consistency. *)\n                Llvm_analysis.assert_valid_function the_function;\n\n                (* Optimize the function. *)\n                let _ = PassManager.run_function the_function the_fpm in\n\n                the_function\n              with e ->\n                delete_function the_function;\n                raise e\n\ntoplevel.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Top-Level parsing and JIT Driver\n         *===----------------------------------------------------------------------===*)\n\n        open Llvm\n        open Llvm_executionengine\n\n        (* top ::= definition | external | expression | ';' *)\n        let rec main_loop the_fpm the_execution_engine stream =\n          match Stream.peek stream with\n          | None -> ()\n\n          (* ignore top-level semicolons. *)\n          | Some (Token.Kwd ';') ->\n              Stream.junk stream;\n              main_loop the_fpm the_execution_engine stream\n\n          | Some token ->\n              begin\n                try match token with\n                | Token.Def ->\n                    let e = Parser.parse_definition stream in\n                    print_endline \"parsed a function definition.\";\n                    dump_value (Codegen.codegen_func the_fpm e);\n                | Token.Extern ->\n                    let e = Parser.parse_extern stream in\n                    print_endline \"parsed an extern.\";\n                    dump_value (Codegen.codegen_proto e);\n                | _ ->\n                    (* Evaluate a top-level expression into an anonymous function. *)\n                    let e = Parser.parse_toplevel stream in\n                    print_endline \"parsed a top-level expr\";\n                    let the_function = Codegen.codegen_func the_fpm e in\n                    dump_value the_function;\n\n                    (* JIT the function, returning a function pointer. *)\n                    let result = ExecutionEngine.run_function the_function [||]\n                      the_execution_engine in\n\n                    print_string \"Evaluated to \";\n                    print_float (GenericValue.as_float Codegen.double_type result);\n                    print_newline ();\n                with Stream.Error s | Codegen.Error s ->\n                  (* Skip token for error recovery. *)\n                  Stream.junk stream;\n                  print_endline s;\n              end;\n              print_string \"ready> \"; flush stdout;\n              main_loop the_fpm the_execution_engine stream\n\ntoy.ml:\n    .. code-block:: ocaml\n\n        (*===----------------------------------------------------------------------===\n         * Main driver code.\n         *===----------------------------------------------------------------------===*)\n\n        open Llvm\n        open Llvm_executionengine\n        open Llvm_target\n        open Llvm_scalar_opts\n\n        let main () =\n          ignore (initialize_native_target ());\n\n          (* Install standard binary operators.\n           * 1 is the lowest precedence. *)\n          Hashtbl.add Parser.binop_precedence '<' 10;\n          Hashtbl.add Parser.binop_precedence '+' 20;\n          Hashtbl.add Parser.binop_precedence '-' 20;\n          Hashtbl.add Parser.binop_precedence '*' 40;    (* highest. *)\n\n          (* Prime the first token. *)\n          print_string \"ready> \"; flush stdout;\n          let stream = Lexer.lex (Stream.of_channel stdin) in\n\n          (* Create the JIT. *)\n          let the_execution_engine = ExecutionEngine.create Codegen.the_module in\n          let the_fpm = PassManager.create_function Codegen.the_module in\n\n          (* Set up the optimizer pipeline.  Start with registering info about how the\n           * target lays out data structures. *)\n          DataLayout.add (ExecutionEngine.target_data the_execution_engine) the_fpm;\n\n          (* Do simple \"peephole\" optimizations and bit-twiddling optzn. *)\n          add_instruction_combination the_fpm;\n\n          (* reassociate expressions. *)\n          add_reassociation the_fpm;\n\n          (* Eliminate Common SubExpressions. *)\n          add_gvn the_fpm;\n\n          (* Simplify the control flow graph (deleting unreachable blocks, etc). *)\n          add_cfg_simplification the_fpm;\n\n          ignore (PassManager.initialize the_fpm);\n\n          (* Run the main \"interpreter loop\" now. *)\n          Toplevel.main_loop the_fpm the_execution_engine stream;\n\n          (* Print out all the generated code. *)\n          dump_module Codegen.the_module\n        ;;\n\n        main ()\n\nbindings.c\n    .. code-block:: c\n\n        #include <stdio.h>\n\n        /* putchard - putchar that takes a double and returns 0. */\n        extern double putchard(double X) {\n          putchar((char)X);\n          return 0;\n        }\n\n`Next: Extending the language: control flow <OCamlLangImpl5.html>`_\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/lib/Utils/PlatformPosix.cpp": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author: Roman Zulak\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#include \"cling/Utils/Platform.h\"\n\n#if defined(LLVM_ON_UNIX)\n\n#include \"cling/Utils/Paths.h\"\n#include \"llvm/ADT/SmallString.h\"\n\n#include <array>\n#include <atomic>\n#include <string>\n#include <cxxabi.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n// PATH_MAX\n#ifdef __APPLE__\n #include <sys/syslimits.h>\n#else\n #include <limits.h>\n#endif\n\n#define PATH_MAXC (PATH_MAX+1)\n\nnamespace cling {\nnamespace utils {\nnamespace platform {\n\nnamespace {\n  struct PointerCheck {\n  private:\n    // A simple round-robin cache: what enters first, leaves first.\n    // MRU cache wasn't worth the extra CPU cycles.\n    static thread_local std::array<const void*, 8> lines;\n    static thread_local unsigned mostRecent;\n    int FD;\n\n    // Concurrent writes to the same cache element can result in invalid cache\n    // elements, causing pointer address not being available in the cache even\n    // though they should be, i.e. false cache misses. While can cause a\n    // slow-down, the cost for keeping the cache thread-local or atomic is\n    // much higher (yes, this was measured).\n    void push(const void* P) {\n      mostRecent = (mostRecent + 1) % lines.size();\n      lines[mostRecent] = P;\n    }\n\n  public:\n    PointerCheck() : FD(::open(\"/dev/random\", O_WRONLY)) {\n      if (FD == -1) ::perror(\"open('/dev/random')\");\n    }\n    ~PointerCheck() {\n      if (FD != -1) ::close(FD);\n    }\n\n    bool operator () (const void* P) {\n      if (FD == -1)\n        return false;\n      // std::find is considerably slower, do manual search instead.\n      if (P == lines[0] || P == lines[1] || P == lines[2] || P == lines[3]\n          || P == lines[4] || P == lines[5] || P == lines[6] || P == lines[7])\n        return true;\n\n      // There is a POSIX way of finding whether an address\n      // can be accessed for reading.\n      if (::write(FD, P, 1/*byte*/) != 1) {\n        assert(errno == EFAULT && \"unexpected write error at address\");\n        return false;\n      }\n      push(P);\n      return true;\n    }\n  };\n  thread_local std::array<const void*, 8> PointerCheck::lines = {};\n  thread_local unsigned PointerCheck::mostRecent = 0;\n}\n\nbool IsMemoryValid(const void *P) {\n  static PointerCheck sPointerCheck;\n  return sPointerCheck(P);\n}\n\nstd::string GetCwd() {\n  char Buffer[PATH_MAXC];\n  if (::getcwd(Buffer, sizeof(Buffer)))\n    return Buffer;\n\n  ::perror(\"Could not get current working directory\");\n  return std::string();\n}\n\nstatic void DLErr(std::string* Err) {\n  if (!Err)\n    return;\n  if (const char* DyLibError = ::dlerror())\n    *Err = DyLibError;\n}\n\nconst void* DLOpen(const std::string& Path, std::string* Err) {\n  void* Lib = dlopen(Path.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n  DLErr(Err);\n  return Lib;\n}\n\nconst void* DLSym(const std::string& Name, std::string* Err) {\n  if (const void* Self = ::dlopen(nullptr, RTLD_GLOBAL)) {\n    // get dlopen error if there is one\n    DLErr(Err);\n    const void* Sym = ::dlsym(const_cast<void*>(Self), Name.c_str());\n    // overwrite error if dlsym caused one\n    DLErr(Err);\n    // only get dlclose error if dlopen & dlsym haven't emited one\n    DLClose(Self, Err && Err->empty() ? Err : nullptr);\n    return Sym;\n  }\n  DLErr(Err);\n  return nullptr;\n}\n\nvoid DLClose(const void* Lib, std::string* Err) {\n  ::dlclose(const_cast<void*>(Lib));\n  DLErr(Err);\n}\n\nstd::string NormalizePath(const std::string& Path) {\n  char Buf[PATH_MAXC];\n  if (const char* Result = ::realpath(Path.c_str(), Buf))\n    return std::string(Result);\n\n  ::perror(\"realpath\");\n  return std::string();\n}\n\nbool Popen(const std::string& Cmd, llvm::SmallVectorImpl<char>& Buf, bool RdE) {\n  if (FILE *PF = ::popen(RdE ? (Cmd + \" 2>&1\").c_str() : Cmd.c_str(), \"r\")) {\n    Buf.resize(0);\n    const size_t Chunk = Buf.capacity_in_bytes();\n    while (true) {\n      const size_t Len = Buf.size();\n      Buf.resize(Len + Chunk);\n      const size_t R = ::fread(&Buf[Len], sizeof(char), Chunk, PF);\n      if (R < Chunk) {\n        Buf.resize(Len + R);\n        break;\n      }\n    }\n    ::pclose(PF);\n    return !Buf.empty();\n  }\n  return false;\n}\n\nbool GetSystemLibraryPaths(llvm::SmallVectorImpl<std::string>& Paths) {\n#if defined(__APPLE__) || defined(__CYGWIN__)\n  Paths.push_back(\"/usr/local/lib/\");\n  Paths.push_back(\"/usr/X11R6/lib/\");\n  Paths.push_back(\"/usr/lib/\");\n  Paths.push_back(\"/lib/\");\n\n #ifndef __APPLE__\n  Paths.push_back(\"/lib/x86_64-linux-gnu/\");\n  Paths.push_back(\"/usr/local/lib64/\");\n  Paths.push_back(\"/usr/lib64/\");\n  Paths.push_back(\"/lib64/\");\n #endif\n#else\n  llvm::SmallString<1024> Buf;\n  platform::Popen(\"LD_DEBUG=libs LD_PRELOAD=DOESNOTEXIST ls\", Buf, true);\n  const llvm::StringRef Result = Buf.str();\n\n  const std::size_t NPos = std::string::npos;\n  const std::size_t LD = Result.find(\"(LD_LIBRARY_PATH)\");\n  std::size_t From = Result.find(\"search path=\", LD == NPos ? 0 : LD);\n  if (From != NPos) {\n    const std::size_t To = Result.find(\"(system search path)\", From);\n    if (To != NPos) {\n      From += 12;\n      std::string SysPath = Result.substr(From, To-From);\n      SysPath.erase(std::remove_if(SysPath.begin(), SysPath.end(), isspace),\n                    SysPath.end());\n\n      llvm::SmallVector<llvm::StringRef, 10> CurPaths;\n      SplitPaths(SysPath, CurPaths);\n      for (const auto& Path : CurPaths)\n        Paths.push_back(Path.str());\n    }\n  }\n#endif\n  return true;\n}\n\nstd::string Demangle(const std::string& Symbol) {\n  struct AutoFree {\n    char* Str;\n    AutoFree(char* Ptr) : Str(Ptr) {}\n    ~AutoFree() { ::free(Str); };\n  };\n  int status = 0;\n  // Some implementations of __cxa_demangle are giving back length of allocation\n  // Passing NULL for length seems to guarantee null termination.\n  AutoFree af(abi::__cxa_demangle(Symbol.c_str(), NULL, NULL, &status));\n  return status == 0 ? std::string(af.Str) : std::string();\n}\n\n} // namespace platform\n} // namespace utils\n} // namespace cling\n\n#endif // LLVM_ON_UNIX\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/lib/Interpreter/IncrementalExecutor.h": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Axel Naumann <axel@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#ifndef CLING_INCREMENTAL_EXECUTOR_H\n#define CLING_INCREMENTAL_EXECUTOR_H\n\n#include \"IncrementalJIT.h\"\n\n#include \"BackendPasses.h\"\n#include \"EnterUserCodeRAII.h\"\n\n#include \"cling/Interpreter/InterpreterCallbacks.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/Interpreter/Value.h\"\n#include \"cling/Utils/Casting.h\"\n#include \"cling/Utils/OrderedMap.h\"\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n\n#include <atomic>\n#include <map>\n#include <memory>\n#include <unordered_set>\n#include <vector>\n\nnamespace clang {\n  class DiagnosticsEngine;\n  class CodeGenOptions;\n  class CompilerInstance;\n}\n\nnamespace llvm {\n  class GlobalValue;\n  class Module;\n  class TargetMachine;\n}\n\nnamespace cling {\n  class IncrementalJIT;\n  class Value;\n\n  class IncrementalExecutor {\n  public:\n    typedef void* (*LazyFunctionCreatorFunc_t)(const std::string&);\n\n  private:\n    ///\\brief Our JIT interface.\n    ///\n    std::unique_ptr<IncrementalJIT> m_JIT;\n\n    // optimizer etc passes\n    std::unique_ptr<BackendPasses> m_BackendPasses;\n\n    ///\\brief Whom to call upon invocation of user code.\n    InterpreterCallbacks* m_Callbacks;\n\n    ///\\brief A pointer to the IncrementalExecutor of the parent Interpreter.\n    ///\n    IncrementalExecutor* m_externalIncrementalExecutor;\n\n    ///\\brief Helper that manages when the destructor of an object to be called.\n    ///\n    /// The object is registered first as an CXAAtExitElement and then cling\n    /// takes the control of it's destruction.\n    ///\n    class CXAAtExitElement {\n      ///\\brief The function to be called.\n      ///\n      void (*m_Func)(void*);\n\n      ///\\brief The single argument passed to the function.\n      ///\n      void* m_Arg;\n\n    public:\n      ///\\brief Constructs an element, whose destruction time will be managed by\n      /// the interpreter. (By registering a function to be called by exit\n      /// or when a shared library is unloaded.)\n      ///\n      /// Registers destructors for objects with static storage duration with\n      /// the _cxa atexit function rather than the atexit function. This option\n      /// is required for fully standards-compliant handling of static\n      /// destructors(many of them created by cling), but will only work if\n      /// your C library supports __cxa_atexit (means we have our own work\n      /// around for Windows). More information about __cxa_atexit could be\n      /// found in the Itanium C++ ABI spec.\n      ///\n      ///\\param [in] func - The function to be called on exit or unloading of\n      ///                   shared lib.(The destructor of the object.)\n      ///\\param [in] arg - The argument the func to be called with.\n      ///\\param [in] fromT - The unloading of this transaction will trigger the\n      ///                    atexit function.\n      ///\n      CXAAtExitElement(void (*func)(void*), void* arg)\n          : m_Func(func), m_Arg(arg) {}\n\n      void operator()() const { (*m_Func)(m_Arg); }\n    };\n\n    ///\\brief Atomic used as a spin lock to protect the access to m_AtExitFuncs\n    ///\n    /// AddAtExitFunc is used at the end of the 'interpreted' user code\n    /// and before the calling framework has any change of taking back/again\n    /// its lock protecting the access to cling, so we need to explicit protect\n    /// again multiple conccurent access.\n    std::atomic_flag m_AtExitFuncsSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;\n\n    ///\\brief Function registered via __cxa_atexit, atexit, or one of\n    /// it's C++ overloads that should be run when a module is unloaded.\n    ///\n    // FIXME: We should probably try using a weak_ptr instead of a shared_ptr.\n    typedef utils::OrderedMap<std::shared_ptr<llvm::Module>,\n                              std::vector<CXAAtExitElement>>\n        AtExitFunctions;\n    AtExitFunctions m_AtExitFuncs;\n\n    ///\\brief Modules to emit upon the next call to the JIT.\n    ///\n    std::vector<llvm::Module*> m_ModulesToJIT;\n\n    ///\\brief Lazy function creator, which is a final callback which the\n    /// JIT fires if there is unresolved symbol.\n    ///\n    std::vector<LazyFunctionCreatorFunc_t> m_lazyFuncCreator;\n\n    ///\\brief Set of the symbols that the JIT couldn't resolve.\n    ///\n    std::unordered_set<std::string> m_unresolvedSymbols;\n\n#if 0 // See FIXME in IncrementalExecutor.cpp\n    ///\\brief The diagnostics engine, printing out issues coming from the\n    /// incremental executor.\n    clang::DiagnosticsEngine& m_Diags;\n#endif\n\n\n  public:\n    enum ExecutionResult {\n      kExeSuccess,\n      kExeFunctionNotCompiled,\n      kExeUnresolvedSymbols,\n      kNumExeResults\n    };\n\n    IncrementalExecutor(clang::DiagnosticsEngine& diags,\n                        const clang::CompilerInstance& CI);\n\n    ~IncrementalExecutor();\n\n    void setExternalIncrementalExecutor(IncrementalExecutor *extIncrExec) {\n      m_externalIncrementalExecutor = extIncrExec;\n    }\n    void setCallbacks(InterpreterCallbacks* callbacks) {\n      m_Callbacks = callbacks;\n    }\n    void installLazyFunctionCreator(LazyFunctionCreatorFunc_t fp);\n\n    ///\\brief Unload a set of JIT symbols.\n    bool unloadModule(const std::shared_ptr<llvm::Module>& M) {\n      // FIXME: Propagate the error in a more verbose way.\n      if (auto Err = m_JIT->removeModule(M))\n        return false;\n      return true;\n    }\n\n    ///\\brief Run the static initializers of all modules collected to far.\n    ExecutionResult runStaticInitializersOnce(const Transaction& T);\n\n    ///\\brief Runs all destructors bound to the given transaction and removes\n    /// them from the list.\n    ///\\param[in] T - Transaction to which the dtors were bound.\n    ///\n    void runAndRemoveStaticDestructors(Transaction* T);\n\n    ///\\brief Runs a wrapper function.\n    ExecutionResult executeWrapper(llvm::StringRef function,\n                                   Value* returnValue = 0) {\n      // Set the value to cling::invalid.\n      if (returnValue) {\n        *returnValue = Value();\n      }\n      typedef void (*InitFun_t)(void*);\n      InitFun_t fun;\n      ExecutionResult res = jitInitOrWrapper(function, fun);\n      if (res != kExeSuccess)\n        return res;\n      EnterUserCodeRAII euc(m_Callbacks);\n      (*fun)(returnValue);\n      return kExeSuccess;\n    }\n\n    ///\\brief Adds a symbol (function) to the execution engine.\n    ///\n    /// Allows runtime declaration of a function passing its pointer for being\n    /// used by JIT generated code.\n    ///\n    /// @param[in] Name - The name of the symbol as required by the\n    ///                         linker (mangled if needed)\n    /// @param[in] Address - The function pointer to register\n    /// @param[in] JIT - Add to the JIT injected symbol table\n    /// @returns true if the symbol is successfully registered, false otherwise.\n    ///\n    bool addSymbol(const char* Name, void* Address, bool JIT = false);\n\n    ///\\brief Emit a llvm::Module to the JIT.\n    ///\n    /// @param[in] module - The module to pass to the execution engine.\n    /// @param[in] optLevel - The optimization level to be used.\n    void emitModule(const std::shared_ptr<llvm::Module>& module, int optLevel) {\n      if (m_BackendPasses)\n        m_BackendPasses->runOnModule(*module, optLevel);\n\n      m_JIT->addModule(module);\n    }\n\n    ///\\brief Tells the execution context that we are shutting down the system.\n    ///\n    /// This that notification is needed because the execution context needs to\n    /// perform extra actions like delete all managed by it symbols, which might\n    /// still require alive system.\n    ///\n    void shuttingDown();\n\n    ///\\brief Gets the address of an existing global and whether it was JITted.\n    ///\n    /// JIT symbols might not be immediately convertible to e.g. a function\n    /// pointer as their call setup is different.\n    ///\n    ///\\param[in]  mangledName - the globa's name\n    ///\\param[out] fromJIT - whether the symbol was JITted.\n    ///\n    void* getAddressOfGlobal(llvm::StringRef mangledName, bool* fromJIT = 0);\n\n    ///\\brief Return the address of a global from the JIT (as\n    /// opposed to dynamic libraries). Forces the emission of the symbol if\n    /// it has not happened yet.\n    ///\n    ///param[in] GV - global value for which the address will be returned.\n    void* getPointerToGlobalFromJIT(const llvm::GlobalValue& GV);\n\n    ///\\brief Keep track of the entities whose dtor we need to call.\n    ///\n    void AddAtExitFunc(void (*func)(void*), void* arg,\n                       const std::shared_ptr<llvm::Module>& M);\n\n    ///\\brief Try to resolve a symbol through our LazyFunctionCreators;\n    /// print an error message if that fails.\n    void* NotifyLazyFunctionCreators(const std::string&);\n\n  private:\n    ///\\brief Report and empty m_unresolvedSymbols.\n    ///\\return true if m_unresolvedSymbols was non-empty.\n    bool diagnoseUnresolvedSymbols(llvm::StringRef trigger,\n                                   llvm::StringRef title = llvm::StringRef());\n\n    ///\\brief Remember that the symbol could not be resolved by the JIT.\n    void* HandleMissingFunction(const std::string& symbol);\n\n    ///\\brief Runs an initializer function.\n    ExecutionResult executeInit(llvm::StringRef function) {\n      typedef void (*InitFun_t)();\n      InitFun_t fun;\n      ExecutionResult res = jitInitOrWrapper(function, fun);\n      if (res != kExeSuccess)\n        return res;\n      EnterUserCodeRAII euc(m_Callbacks);\n      (*fun)();\n      return kExeSuccess;\n    }\n\n    template <class T>\n    ExecutionResult jitInitOrWrapper(llvm::StringRef funcname, T& fun) {\n      fun = utils::UIntToFunctionPtr<T>(m_JIT->getSymbolAddress(funcname,\n                                                              false /*dlsym*/));\n\n      // check if there is any unresolved symbol in the list\n      if (diagnoseUnresolvedSymbols(funcname, \"function\") || !fun)\n        return IncrementalExecutor::kExeUnresolvedSymbols;\n\n      return IncrementalExecutor::kExeSuccess;\n    }\n  };\n} // end cling\n#endif // CLING_INCREMENTAL_EXECUTOR_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/lib/Interpreter/IncrementalJIT.h": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Axel Naumann <axel@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#ifndef CLING_INCREMENTAL_JIT_H\n#define CLING_INCREMENTAL_JIT_H\n\n#include \"cling/Utils/Output.h\"\n\n#include \"llvm/IR/Mangler.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/ExecutionEngine/JITEventListener.h\"\n#include \"llvm/ExecutionEngine/JITSymbol.h\"\n#include \"llvm/ExecutionEngine/Orc/CompileUtils.h\"\n#include \"llvm/ExecutionEngine/Orc/IRCompileLayer.h\"\n#include \"llvm/ExecutionEngine/Orc/LazyEmittingLayer.h\"\n#include \"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h\"\n#include \"llvm/ExecutionEngine/RTDyldMemoryManager.h\"\n#include \"llvm/Target/TargetMachine.h\"\n\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\nnamespace llvm {\nclass Module;\nclass RTDyldMemoryManager;\n}\n\nnamespace cling {\nclass Azog;\nclass IncrementalExecutor;\n\nclass IncrementalJIT {\npublic:\n  using SymbolMapT = llvm::StringMap<llvm::JITTargetAddress>;\n\nprivate:\n  friend class Azog;\n\n  ///\\brief The IncrementalExecutor who owns us.\n  IncrementalExecutor& m_Parent;\n  llvm::JITEventListener* m_GDBListener; // owned by llvm::ManagedStaticBase\n\n  SymbolMapT m_SymbolMap;\n\n  class NotifyObjectLoadedT {\n  public:\n    NotifyObjectLoadedT(IncrementalJIT &jit) : m_JIT(jit) {}\n    void operator()(llvm::orc::RTDyldObjectLinkingLayerBase::ObjHandleT H,\n                    const llvm::orc::RTDyldObjectLinkingLayer::ObjectPtr &Object,\n                    const llvm::LoadedObjectInfo &Info) const {\n      m_JIT.m_UnfinalizedSections[H]\n        = std::move(m_JIT.m_SectionsAllocatedSinceLastLoad);\n      m_JIT.m_SectionsAllocatedSinceLastLoad = SectionAddrSet();\n\n      // FIXME: NotifyObjectEmitted requires a RuntimeDyld::LoadedObjectInfo\n      // object. In order to get it one should call\n      // RTDyld.loadObject(*ObjToLoad->getBinary()) according to r306058.\n      // Moreover this should be done in the finalizer. Currently we are\n      // disabling this since we have globally disabled this functionality in\n      // IncrementalJIT.cpp (m_GDBListener = 0).\n      //\n      // if (auto GDBListener = m_JIT.m_GDBListener)\n      //   GDBListener->NotifyObjectEmitted(*Object->getBinary(), Info);\n\n      for (const auto &Symbol: Object->getBinary()->symbols()) {\n        auto Flags = Symbol.getFlags();\n        if (Flags & llvm::object::BasicSymbolRef::SF_Undefined)\n          continue;\n        // FIXME: this should be uncommented once we serve incremental\n        // modules from a TU module.\n        //if (!(Flags & llvm::object::BasicSymbolRef::SF_Exported))\n        //  continue;\n        auto NameOrError = Symbol.getName();\n        if (!NameOrError)\n          continue;\n        auto Name = NameOrError.get();\n        if (m_JIT.m_SymbolMap.find(Name) == m_JIT.m_SymbolMap.end()) {\n          llvm::JITSymbol Sym\n            = m_JIT.m_CompileLayer.findSymbolIn(H, Name, true);\n          if (auto Addr = Sym.getAddress())\n            m_JIT.m_SymbolMap[Name] = *Addr;\n        }\n      }\n    }\n\n  private:\n    IncrementalJIT &m_JIT;\n  };\n  class RemovableObjectLinkingLayer:\n    public llvm::orc::RTDyldObjectLinkingLayer {\n  public:\n    using Base_t = llvm::orc::RTDyldObjectLinkingLayer;\n    using NotifyFinalizedFtor = Base_t::NotifyFinalizedFtor;\n    RemovableObjectLinkingLayer(SymbolMapT &SymMap,\n                                Base_t::MemoryManagerGetter MM,\n                                NotifyObjectLoadedT NotifyLoaded,\n                                NotifyFinalizedFtor NotifyFinalized)\n      : Base_t(MM, NotifyLoaded, NotifyFinalized), m_SymbolMap(SymMap)\n    {}\n\n    llvm::Error\n    removeObject(llvm::orc::RTDyldObjectLinkingLayerBase::ObjHandleT H) {\n      struct AccessSymbolTable: public LinkedObject {\n        const llvm::StringMap<llvm::JITEvaluatedSymbol>&\n        getSymbolTable() const {\n          return SymbolTable;\n        }\n      };\n      const AccessSymbolTable* HSymTable\n        = static_cast<const AccessSymbolTable*>(H->get());\n      for (auto&& NameSym: HSymTable->getSymbolTable()) {\n        auto iterSymMap = m_SymbolMap.find(NameSym.first());\n        if (iterSymMap == m_SymbolMap.end())\n          continue;\n        // Is this this symbol (address)?\n        if (iterSymMap->second == NameSym.second.getAddress())\n          m_SymbolMap.erase(iterSymMap);\n      }\n      return llvm::orc::RTDyldObjectLinkingLayer::removeObject(H);\n    }\n  private:\n    SymbolMapT& m_SymbolMap;\n  };\n\n  typedef RemovableObjectLinkingLayer ObjectLayerT;\n  typedef llvm::orc::IRCompileLayer<ObjectLayerT,\n                                    llvm::orc::SimpleCompiler> CompileLayerT;\n  typedef llvm::orc::LazyEmittingLayer<CompileLayerT> LazyEmitLayerT;\n  typedef LazyEmitLayerT::ModuleHandleT ModuleHandleT;\n\n  std::unique_ptr<llvm::TargetMachine> m_TM;\n  llvm::DataLayout m_TMDataLayout;\n\n  ///\\brief The RTDyldMemoryManager used to communicate with the\n  /// IncrementalExecutor to handle missing or special symbols.\n  std::shared_ptr<llvm::RTDyldMemoryManager> m_ExeMM;\n\n  NotifyObjectLoadedT m_NotifyObjectLoaded;\n\n  ObjectLayerT m_ObjectLayer;\n  CompileLayerT m_CompileLayer;\n  LazyEmitLayerT m_LazyEmitLayer;\n\n  // We need to store ObjLayerT::ObjHandles for each of the object sets\n  // that have been emitted but not yet finalized so that we can forward the\n  // mapSectionAddress calls appropriately.\n  typedef std::set<const void *> SectionAddrSet;\n  struct ObjHandleCompare {\n    bool operator()(ObjectLayerT::ObjHandleT H1,\n                    ObjectLayerT::ObjHandleT H2) const {\n      return &*H1 < &*H2;\n    }\n  };\n  SectionAddrSet m_SectionsAllocatedSinceLastLoad;\n  std::map<ObjectLayerT::ObjHandleT, SectionAddrSet, ObjHandleCompare>\n    m_UnfinalizedSections;\n\n  ///\\brief Mapping between \\c llvm::Module* and \\c ModuleHandleT.\n  std::map<llvm::Module*, ModuleHandleT> m_UnloadPoints;\n\n  std::string Mangle(llvm::StringRef Name) {\n    stdstrstream MangledName;\n    llvm::Mangler::getNameWithPrefix(MangledName, Name, m_TMDataLayout);\n    return MangledName.str();\n  }\n\n  llvm::JITSymbol getInjectedSymbols(const std::string& Name) const;\n\npublic:\n  IncrementalJIT(IncrementalExecutor& exe,\n                 std::unique_ptr<llvm::TargetMachine> TM);\n\n  ///\\brief Get the address of a symbol from the JIT or the memory manager,\n  /// mangling the name as needed. Use this to resolve symbols as coming\n  /// from clang's mangler.\n  /// \\param Name - name to look for. This name might still get mangled\n  ///   (prefixed by '_') to make IR versus symbol names.\n  /// \\param AlsoInProcess - Sometimes you only care about JITed symbols. If so,\n  ///   pass `false` here to not resolve the symbol through dlsym().\n  uint64_t getSymbolAddress(const std::string& Name, bool AlsoInProcess) {\n    // FIXME: We should decide if we want to handle the error here or make the\n    // return type of the function llvm::Expected<uint64_t> relying on the\n    // users to decide how to handle the error.\n    if (auto S = getSymbolAddressWithoutMangling(Mangle(Name), AlsoInProcess)) {\n      if (auto AddrOrErr = S.getAddress())\n        return *AddrOrErr;\n      else\n        llvm_unreachable(\"Handle the error case\");\n    }\n\n    return 0;\n  }\n\n  ///\\brief Get the address of a symbol from the JIT or the memory manager.\n  /// Use this to resolve symbols of known, target-specific names.\n  llvm::JITSymbol getSymbolAddressWithoutMangling(const std::string& Name,\n                                                  bool AlsoInProcess);\n\n  void addModule(const std::shared_ptr<llvm::Module>& module);\n  llvm::Error removeModule(const std::shared_ptr<llvm::Module>& module);\n\n  IncrementalExecutor& getParent() const { return m_Parent; }\n\n  void RemoveUnfinalizedSection(\n                     llvm::orc::RTDyldObjectLinkingLayerBase::ObjHandleT H) {\n    m_UnfinalizedSections.erase(H);\n  }\n\n  ///\\brief Get the address of a symbol from the process' loaded libraries.\n  /// \\param Name - symbol to look for\n  /// \\param Addr - known address of the symbol that can be cached later use\n  /// \\param Jit - add to the injected symbols cache\n  /// \\returns The address of the symbol and whether it was cached\n  std::pair<void*, bool>\n  lookupSymbol(llvm::StringRef Name, void* Addr = nullptr, bool Jit = false);\n};\n} // end cling\n#endif // CLING_INCREMENTAL_EXECUTOR_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Axel Naumann <axel@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#include \"IncrementalJIT.h\"\n\n#include \"IncrementalExecutor.h\"\n#include \"cling/Utils/Platform.h\"\n\n#include \"llvm/ExecutionEngine/Orc/LambdaResolver.h\"\n#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n#include \"llvm/Support/DynamicLibrary.h\"\n\n#if defined(__APPLE__) || defined (_MSC_VER)\n// Apple and Windows add an extra '_'\n# define MANGLE_PREFIX \"_\"\n#endif\n\nusing namespace llvm;\n\nnamespace {\n\n///\\brief Memory manager providing the lop-level link to the\n/// IncrementalExecutor, handles missing or special / replaced symbols.\nclass ClingMemoryManager: public SectionMemoryManager {\npublic:\n  ClingMemoryManager(cling::IncrementalExecutor& Exe) {}\n\n  ///\\brief Simply wraps the base class's function setting AbortOnFailure\n  /// to false and instead using the error handling mechanism to report it.\n  void* getPointerToNamedFunction(const std::string &Name,\n                                  bool /*AbortOnFailure*/ =true) override {\n    return SectionMemoryManager::getPointerToNamedFunction(Name, false);\n  }\n};\n\n  class NotifyFinalizedT {\n  public:\n    NotifyFinalizedT(cling::IncrementalJIT &jit) : m_JIT(jit) {}\n    void operator()(llvm::orc::RTDyldObjectLinkingLayerBase::ObjHandleT H) {\n      m_JIT.RemoveUnfinalizedSection(H);\n    }\n\n  private:\n    cling::IncrementalJIT &m_JIT;\n  };\n\n} // unnamed namespace\n\nnamespace cling {\n\n///\\brief Memory manager for the OrcJIT layers to resolve symbols from the\n/// common IncrementalJIT. I.e. the master of the Orcs.\n/// Each ObjectLayer instance has one Azog object.\nclass Azog: public RTDyldMemoryManager {\n  cling::IncrementalJIT& m_jit;\n\n  struct AllocInfo {\n    uint8_t *m_Start   = nullptr;\n    uint8_t *m_End     = nullptr;\n    uint8_t *m_Current = nullptr;\n\n    void allocate(RTDyldMemoryManager *exeMM,\n                  uintptr_t Size, uint32_t Align,\n                  bool code, bool isReadOnly) {\n\n      uintptr_t RequiredSize = Size;\n      if (code)\n        m_Start = exeMM->allocateCodeSection(RequiredSize, Align,\n                                             0 /* SectionID */,\n                                             \"codeReserve\");\n      else if (isReadOnly)\n        m_Start = exeMM->allocateDataSection(RequiredSize, Align,\n                                             0 /* SectionID */,\n                                             \"rodataReserve\",isReadOnly);\n      else\n        m_Start = exeMM->allocateDataSection(RequiredSize, Align,\n                                             0 /* SectionID */,\n                                             \"rwataReserve\",isReadOnly);\n      m_Current = m_Start;\n      m_End = m_Start + RequiredSize;\n    }\n\n    uint8_t* getNextAddr(uintptr_t Size, unsigned Alignment) {\n      if (!Alignment)\n        Alignment = 16;\n\n      assert(!(Alignment & (Alignment - 1)) && \"Alignment must be a power of two.\");\n\n      uintptr_t RequiredSize = Alignment * ((Size + Alignment - 1)/Alignment + 1);\n      if ( (m_Current + RequiredSize) > m_End ) {\n        // This must be the last block.\n        if ((m_Current + Size) <= m_End) {\n          RequiredSize = Size;\n        } else {\n          cling::errs() << \"Error in block allocation by Azog. \"\n                        << \"Not enough memory was reserved for the current module. \"\n                        << Size << \" (with alignment: \" << RequiredSize\n                        << \" ) is needed but\\n\"\n                        << \"we only have \" << (m_End - m_Current) << \".\\n\";\n          return nullptr;\n        }\n      }\n\n      uintptr_t Addr = (uintptr_t)m_Current;\n\n      // Align the address.\n      Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n\n      m_Current = (uint8_t*)(Addr + Size);\n\n      return (uint8_t*)Addr;\n    }\n\n    operator bool() {\n      return m_Current != nullptr;\n    }\n  };\n\n  AllocInfo m_Code;\n  AllocInfo m_ROData;\n  AllocInfo m_RWData;\n\n#ifdef CLING_WIN_SEH_EXCEPTIONS\n  uintptr_t getBaseAddr() const {\n    if (LLVM_LIKELY(m_Code.m_Start && m_ROData.m_Start && m_RWData.m_Start)) {\n      return uintptr_t(std::min(std::min(m_Code.m_Start, m_ROData.m_Start),\n                                m_RWData.m_Start));\n    }\n    if (LLVM_LIKELY(m_Code.m_Start)) {\n      return uintptr_t(m_ROData.m_Start\n                           ? std::min(m_Code.m_Start, m_ROData.m_Start)\n                           : std::min(m_Code.m_Start, m_RWData.m_Start));\n    }\n    return uintptr_t(m_ROData.m_Start && m_RWData.m_Start\n                         ? std::min(m_ROData.m_Start, m_RWData.m_Start)\n                         : std::max(m_ROData.m_Start, m_RWData.m_Start));\n  }\n\n  // FIXME: This is directly mirroring a structure in RTDyldMemoryManager that\n  // is private. Get Win64 exceptions into LLVM or add an accessor for it.\n  platform::windows::EHFrameInfos m_EHFrames;\n#endif\n\npublic:\n  Azog(cling::IncrementalJIT& Jit): m_jit(Jit) {}\n\n  RTDyldMemoryManager* getExeMM() const { return m_jit.m_ExeMM.get(); }\n\n  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID,\n                               StringRef SectionName) override {\n    uint8_t *Addr = nullptr;\n    if (m_Code) {\n      Addr = m_Code.getNextAddr(Size, Alignment);\n    }\n    if (!Addr) {\n      Addr = getExeMM()->allocateCodeSection(Size, Alignment, SectionID, SectionName);\n      m_jit.m_SectionsAllocatedSinceLastLoad.insert(Addr);\n    }\n\n    return Addr;\n  }\n\n  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                               unsigned SectionID, StringRef SectionName,\n                               bool IsReadOnly) override {\n\n    uint8_t *Addr = nullptr;\n    if (IsReadOnly && m_ROData) {\n      Addr = m_ROData.getNextAddr(Size,Alignment);\n    } else if (m_RWData) {\n      Addr = m_RWData.getNextAddr(Size,Alignment);\n    }\n    if (!Addr) {\n      Addr = getExeMM()->allocateDataSection(Size, Alignment, SectionID,\n                                                   SectionName, IsReadOnly);\n      m_jit.m_SectionsAllocatedSinceLastLoad.insert(Addr);\n    }\n    return Addr;\n  }\n\n  void reserveAllocationSpace(uintptr_t CodeSize, uint32_t CodeAlign,\n                              uintptr_t RODataSize, uint32_t RODataAlign,\n                              uintptr_t RWDataSize, uint32_t RWDataAlign) override {\n    m_Code.allocate(getExeMM(),CodeSize, CodeAlign, true, false);\n    m_ROData.allocate(getExeMM(),RODataSize, RODataAlign, false, true);\n    m_RWData.allocate(getExeMM(),RWDataSize, RWDataAlign, false, false);\n\n    m_jit.m_SectionsAllocatedSinceLastLoad.insert(m_Code.m_Start);\n    m_jit.m_SectionsAllocatedSinceLastLoad.insert(m_ROData.m_Start);\n    m_jit.m_SectionsAllocatedSinceLastLoad.insert(m_RWData.m_Start);\n  }\n\n  bool needsToReserveAllocationSpace() override {\n    return true; // getExeMM()->needsToReserveAllocationSpace();\n  }\n\n  void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,\n                        size_t Size) override {\n#ifdef CLING_WIN_SEH_EXCEPTIONS\n    const platform::windows::RuntimePRFunction PRFunc = { Addr, Size };\n    m_EHFrames.emplace_back(PRFunc);\n#else\n    return getExeMM()->registerEHFrames(Addr, LoadAddr, Size);\n#endif\n  }\n\n  void deregisterEHFrames() override {\n#ifdef CLING_WIN_SEH_EXCEPTIONS\n    platform::DeRegisterEHFrames(getBaseAddr(), m_EHFrames);\n    platform::windows::EHFrameInfos().swap(m_EHFrames);\n#else\n    return getExeMM()->deregisterEHFrames();\n#endif\n  }\n\n  uint64_t getSymbolAddress(const std::string &Name) override {\n    // FIXME: We should decide if we want to handle the error here or make the\n    // return type of the function llvm::Expected<uint64_t> relying on the\n    // users to decide how to handle the error.\n    if (auto Addr = m_jit.getSymbolAddressWithoutMangling(Name,\n                                                        true /*also use dlsym*/)\n        .getAddress())\n      return *Addr;\n\n    llvm_unreachable(\"Handle the error case\");\n    return ~0U;\n  }\n\n  void *getPointerToNamedFunction(const std::string &Name,\n                                  bool AbortOnFailure = true) override {\n    return getExeMM()->getPointerToNamedFunction(Name, AbortOnFailure);\n  }\n\n  using llvm::RuntimeDyld::MemoryManager::notifyObjectLoaded;\n\n  void notifyObjectLoaded(ExecutionEngine *EE,\n                          const object::ObjectFile &O) override {\n    return getExeMM()->notifyObjectLoaded(EE, O);\n  }\n\n  bool finalizeMemory(std::string *ErrMsg = nullptr) override {\n    // Each set of objects loaded will be finalized exactly once, but since\n    // symbol lookup during relocation may recursively trigger the\n    // loading/relocation of other modules, and since we're forwarding all\n    // finalizeMemory calls to a single underlying memory manager, we need to\n    // defer forwarding the call on until all necessary objects have been\n    // loaded. Otherwise, during the relocation of a leaf object, we will end\n    // up finalizing memory, causing a crash further up the stack when we\n    // attempt to apply relocations to finalized memory.\n    // To avoid finalizing too early, look at how many objects have been\n    // loaded but not yet finalized. This is a bit of a hack that relies on\n    // the fact that we're lazily emitting object files: The only way you can\n    // get more than one set of objects loaded but not yet finalized is if\n    // they were loaded during relocation of another set.\n    if (m_jit.m_UnfinalizedSections.size() == 1) {\n#ifdef CLING_WIN_SEH_EXCEPTIONS\n      platform::RegisterEHFrames(getBaseAddr(), m_EHFrames, true);\n#endif\n      return getExeMM()->finalizeMemory(ErrMsg);\n    }\n    return false;\n  };\n\n}; // class Azog\n\nIncrementalJIT::IncrementalJIT(IncrementalExecutor& exe,\n                               std::unique_ptr<TargetMachine> TM):\n  m_Parent(exe),\n  m_TM(std::move(TM)),\n  m_TMDataLayout(m_TM->createDataLayout()),\n  m_ExeMM(std::make_shared<ClingMemoryManager>(m_Parent)),\n  m_NotifyObjectLoaded(*this),\n  m_ObjectLayer(m_SymbolMap, [this] () { return llvm::make_unique<Azog>(*this); },\n                m_NotifyObjectLoaded, NotifyFinalizedT(*this)),\n  m_CompileLayer(m_ObjectLayer, llvm::orc::SimpleCompiler(*m_TM)),\n  m_LazyEmitLayer(m_CompileLayer) {\n\n  // Force the JIT to query for symbols local to itself, i.e. if it resides in a\n  // shared library it will resolve symbols from there first. This is done to\n  // implement our proto symbol versioning protection. Namely, if some other\n  // library provides llvm symbols, we want out JIT to avoid looking at them.\n  //\n  // FIXME: In general, this approach causes numerous issues when cling is\n  // embedded and the framework needs to provide its own set of symbols which\n  // exist in llvm. Most notably if the framework links against different\n  // versions of linked against llvm libraries. For instance, if we want to provide\n  // a custom zlib in the framework the JIT will still resolve to llvm's version\n  // of libz causing hard-to-debug bugs. In order to work around such cases we\n  // need to swap the llvm system libraries, which can be tricky for two\n  // reasons: (a) llvm's cmake doesn't really support it; (b) only works if we\n  // build llvm from sources.\n  llvm::sys::DynamicLibrary::SearchOrder\n    = llvm::sys::DynamicLibrary::SO_LoadedFirst;\n  // Enable JIT symbol resolution from the binary.\n  llvm::sys::DynamicLibrary::LoadLibraryPermanently(0, 0);\n\n  // Make debug symbols available.\n  m_GDBListener = 0; // JITEventListener::createGDBRegistrationListener();\n\n// #if MCJIT\n//   llvm::EngineBuilder builder(std::move(m));\n\n//   std::string errMsg;\n//   builder.setErrorStr(&errMsg);\n//   builder.setOptLevel(llvm::CodeGenOpt::Less);\n//   builder.setEngineKind(llvm::EngineKind::JIT);\n//   std::unique_ptr<llvm::RTDyldMemoryManager>\n//     MemMan(new ClingMemoryManager(*this));\n//   builder.setMCJITMemoryManager(std::move(MemMan));\n\n//   // EngineBuilder uses default c'ted TargetOptions, too:\n//   llvm::TargetOptions TargetOpts;\n//   TargetOpts.NoFramePointerElim = 1;\n//   TargetOpts.JITEmitDebugInfo = 1;\n\n//   builder.setTargetOptions(TargetOpts);\n\n//   m_engine.reset(builder.create());\n//   assert(m_engine && \"Cannot create module!\");\n// #endif\n}\n\n\nllvm::JITSymbol\nIncrementalJIT::getInjectedSymbols(const std::string& Name) const {\n  using JITSymbol = llvm::JITSymbol;\n  auto SymMapI = m_SymbolMap.find(Name);\n  if (SymMapI != m_SymbolMap.end())\n    return JITSymbol(SymMapI->second, llvm::JITSymbolFlags::Exported);\n\n  return JITSymbol(nullptr);\n}\n\nstd::pair<void*, bool>\nIncrementalJIT::lookupSymbol(llvm::StringRef Name, void *InAddr, bool Jit) {\n  // FIXME: See comments on DLSym below.\n#if !defined(LLVM_ON_WIN32)\n  void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(Name);\n#else\n  void* Addr = const_cast<void*>(platform::DLSym(Name));\n#endif\n\n  if (InAddr && (!Addr || Jit)) {\n    if (Jit) {\n      std::string Key(Name);\n#ifdef MANGLE_PREFIX\n      Key.insert(0, MANGLE_PREFIX);\n#endif\n      m_SymbolMap[Key] = llvm::JITTargetAddress(InAddr);\n    }\n    llvm::sys::DynamicLibrary::AddSymbol(Name, InAddr);\n    return std::make_pair(InAddr, true);\n  }\n  return std::make_pair(Addr, false);\n}\n    \nllvm::JITSymbol\nIncrementalJIT::getSymbolAddressWithoutMangling(const std::string& Name,\n                                                bool AlsoInProcess) {\n  if (auto Sym = getInjectedSymbols(Name))\n    return Sym;\n\n  if (AlsoInProcess) {\n    if (llvm::JITSymbol SymInfo = m_ExeMM->findSymbol(Name)) {\n      if (auto AddrOrErr = SymInfo.getAddress())\n        return llvm::JITSymbol(*AddrOrErr, llvm::JITSymbolFlags::Exported);\n      else\n        llvm_unreachable(\"Handle the error case\");\n    }\n#ifdef LLVM_ON_WIN32\n    // FIXME: DLSym symbol lookup can overlap m_ExeMM->findSymbol wasting time\n    // looking for a symbol in libs where it is already known not to exist.\n    // Perhaps a better solution would be to have IncrementalJIT own the\n    // DynamicLibraryManger instance (or at least have a reference) that will\n    // look only through user loaded libraries.\n    // An upside to doing it this way is RTLD_GLOBAL won't need to be used\n    // allowing libs with competing symbols to co-exists.\n    if (const void* Sym = platform::DLSym(Name))\n      return llvm::JITSymbol(llvm::JITTargetAddress(Sym),\n                             llvm::JITSymbolFlags::Exported);\n#endif\n  }\n\n  if (auto Sym = m_LazyEmitLayer.findSymbol(Name, false))\n    return Sym;\n\n  return llvm::JITSymbol(nullptr);\n}\n\nvoid IncrementalJIT::addModule(const std::shared_ptr<llvm::Module>& module) {\n  // If this module doesn't have a DataLayout attached then attach the\n  // default.\n  module->setDataLayout(m_TMDataLayout);\n\n  // LLVM MERGE FIXME: update this to use new interfaces.\n  auto Resolver = llvm::orc::createLambdaResolver(\n    [&](const std::string &S) {\n      if (auto Sym = getInjectedSymbols(S)) {\n        if (auto AddrOrErr = Sym.getAddress())\n          return JITSymbol((uint64_t)*AddrOrErr, Sym.getFlags());\n        else\n          llvm_unreachable(\"Handle the error case\");\n      }\n      return m_ExeMM->findSymbol(S);\n    },\n    [&](const std::string &Name) {\n      if (auto Sym = getSymbolAddressWithoutMangling(Name, true)) {\n        if (auto AddrOrErr = Sym.getAddress())\n          return JITSymbol(*AddrOrErr, Sym.getFlags());\n        else\n          llvm_unreachable(\"Handle the error case\");\n        }\n\n      const std::string* NameNP = &Name;\n#ifdef MANGLE_PREFIX\n      std::string NameNoPrefix;\n      const size_t PrfxLen = strlen(MANGLE_PREFIX);\n      if (!Name.compare(0, PrfxLen, MANGLE_PREFIX)) {\n        NameNoPrefix = Name.substr(PrfxLen);\n        NameNP = &NameNoPrefix;\n      }\n#endif\n\n      /// This method returns the address of the specified function or variable\n      /// that could not be resolved by getSymbolAddress() or by resolving\n      /// possible weak symbols by the ExecutionEngine.\n      /// It is used to resolve symbols during module linking.\n\n      uint64_t addr = uint64_t(getParent().NotifyLazyFunctionCreators(*NameNP));\n      return JITSymbol(addr, llvm::JITSymbolFlags::Weak);\n    });\n\n  if (auto H = m_LazyEmitLayer.addModule(module, std::move(Resolver)))\n    m_UnloadPoints[module.get()] = *H;\n  else\n    llvm_unreachable(\"Handle the error case\");\n}\n\nllvm::Error\nIncrementalJIT::removeModule(const std::shared_ptr<llvm::Module>& module) {\n  // FIXME: Track down what calls this routine on a not-yet-added module. Once\n  // this is resolved we can remove this check enabling the assert.\n  auto IUnload = m_UnloadPoints.find(module.get());\n  if (IUnload == m_UnloadPoints.end())\n    return llvm::Error::success();\n  auto Handle = IUnload->second;\n  assert(*Handle && \"Trying to remove a non existent module!\");\n  m_UnloadPoints.erase(IUnload);\n  return m_LazyEmitLayer.removeModule(Handle);\n}\n\n}// end namespace cling\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp": "//--------------------------------------------------------------------*- C++ -*-\n// CLING - the C++ LLVM-based InterpreterG :)\n// author:  Axel Naumann <axel@cern.ch>\n//\n// This file is dual-licensed: you can choose to license it under the University\n// of Illinois Open Source License or the GNU Lesser General Public License. See\n// LICENSE.TXT for details.\n//------------------------------------------------------------------------------\n\n#include \"IncrementalExecutor.h\"\n#include \"IncrementalJIT.h\"\n#include \"Threading.h\"\n\n#include \"cling/Interpreter/Value.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/Utils/AST.h\"\n#include \"cling/Utils/Output.h\"\n#include \"cling/Utils/Platform.h\"\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Frontend/CodeGenOptions.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/TargetRegistry.h\"\n#include \"llvm/Target/TargetMachine.h\"\n\nusing namespace llvm;\n\nnamespace cling {\n\nnamespace {\n\nstatic std::unique_ptr<TargetMachine>\nCreateHostTargetMachine(const clang::CompilerInstance& CI) {\n  const clang::TargetOptions& TargetOpts = CI.getTargetOpts();\n  const clang::CodeGenOptions& CGOpt = CI.getCodeGenOpts();\n  const std::string& Triple = TargetOpts.Triple;\n\n  std::string Error;\n  const Target *TheTarget = TargetRegistry::lookupTarget(Triple, Error);\n  if (!TheTarget) {\n    cling::errs() << \"cling::IncrementalExecutor: unable to find target:\\n\"\n                  << Error;\n    return std::unique_ptr<TargetMachine>();\n  }\n\n// We have to use large code model for PowerPC64 because TOC and text sections\n// can be more than 2GB apart.\n#if defined(__powerpc64__) || defined(__PPC64__)\n  CodeModel::Model CMModel = CodeModel::Large;\n#else\n  CodeModel::Model CMModel = CodeModel::JITDefault;\n#endif\n  CodeGenOpt::Level OptLevel = CodeGenOpt::Default;\n  switch (CGOpt.OptimizationLevel) {\n    case 0: OptLevel = CodeGenOpt::None; break;\n    case 1: OptLevel = CodeGenOpt::Less; break;\n    case 2: OptLevel = CodeGenOpt::Default; break;\n    case 3: OptLevel = CodeGenOpt::Aggressive; break;\n    default: OptLevel = CodeGenOpt::Default;\n  }\n\n  std::string MCPU;\n  std::string FeaturesStr;\n\n  auto TM = std::unique_ptr<TargetMachine>(TheTarget->createTargetMachine(\n      Triple, MCPU, FeaturesStr, llvm::TargetOptions(),\n      Optional<Reloc::Model>(), CMModel, OptLevel));\n#if defined(LLVM_ON_WIN32)\n  TM->Options.EmulatedTLS = false;\n#else\n  TM->Options.EmulatedTLS = true;\n#endif\n  return TM;\n}\n\n} // anonymous namespace\n\nIncrementalExecutor::IncrementalExecutor(clang::DiagnosticsEngine& diags,\n                                         const clang::CompilerInstance& CI):\n  m_Callbacks(nullptr), m_externalIncrementalExecutor(nullptr)\n#if 0\n  : m_Diags(diags)\n#endif\n{\n\n  // MSVC doesn't support m_AtExitFuncsSpinLock=ATOMIC_FLAG_INIT; in the class definition\n  std::atomic_flag_clear( &m_AtExitFuncsSpinLock );\n\n  std::unique_ptr<TargetMachine> TM(CreateHostTargetMachine(CI));\n  m_BackendPasses.reset(new BackendPasses(CI.getCodeGenOpts(),\n                                          CI.getTargetOpts(),\n                                          CI.getLangOpts(),\n                                          *TM));\n  m_JIT.reset(new IncrementalJIT(*this, std::move(TM)));\n}\n\n// Keep in source: ~unique_ptr<ClingJIT> needs ClingJIT\nIncrementalExecutor::~IncrementalExecutor() {}\n\nvoid IncrementalExecutor::shuttingDown() {\n  // It is legal to register an atexit handler from within another atexit\n  // handler and furthor-more the standard says they need to run in reverse\n  // order, so this function must be recursion safe.\n  AtExitFunctions Local;\n  {\n    cling::internal::SpinLockGuard slg(m_AtExitFuncsSpinLock);\n    // Check this case first, to avoid the swap all-together.\n    if (m_AtExitFuncs.empty())\n      return;\n    Local.swap(m_AtExitFuncs);\n  }\n  for (auto&& Ordered : llvm::reverse(Local.ordered())) {\n    for (auto&& AtExit : llvm::reverse(Ordered->second))\n      AtExit();\n    // The standard says that they need to run in reverse order, which means\n    // anything added from 'AtExit()' must now be run!\n    shuttingDown();\n  }\n}\n\nvoid IncrementalExecutor::AddAtExitFunc(void (*func)(void*), void* arg,\n                                       const std::shared_ptr<llvm::Module>& M) {\n  // Register a CXAAtExit function\n  cling::internal::SpinLockGuard slg(m_AtExitFuncsSpinLock);\n  m_AtExitFuncs[M].emplace_back(func, arg);\n}\n\nvoid unresolvedSymbol()\n{\n  // This might get called recursively, or a billion of times. Do not generate\n  // useless output; unresolvedSymbol() is always handed out with an error\n  // message - that's enough.\n  //cling::errs() << \"IncrementalExecutor: calling unresolved symbol, \"\n  //  \"see previous error message!\\n\";\n\n  // throw exception instead?\n}\n\nvoid* IncrementalExecutor::HandleMissingFunction(const std::string& mangled_name)\n{\n  // Not found in the map, add the symbol in the list of unresolved symbols\n  if (m_unresolvedSymbols.insert(mangled_name).second) {\n    //cling::errs() << \"IncrementalExecutor: use of undefined symbol '\"\n    //             << mangled_name << \"'!\\n\";\n  }\n\n  return utils::FunctionToVoidPtr(&unresolvedSymbol);\n}\n\nvoid* IncrementalExecutor::NotifyLazyFunctionCreators(const std::string& mangled_name)\n{\n  for (std::vector<LazyFunctionCreatorFunc_t>::iterator it\n         = m_lazyFuncCreator.begin(), et = m_lazyFuncCreator.end();\n       it != et; ++it) {\n    void* ret = (void*)((LazyFunctionCreatorFunc_t)*it)(mangled_name);\n    if (ret)\n      return ret;\n  }\n  void *address = nullptr;\n  if (m_externalIncrementalExecutor)\n   address = m_externalIncrementalExecutor->getAddressOfGlobal(mangled_name);\n\n  return (address ? address : HandleMissingFunction(mangled_name));\n}\n\n#if 0\n// FIXME: employ to empty module dependencies *within* the *current* module.\nstatic void\nfreeCallersOfUnresolvedSymbols(llvm::SmallVectorImpl<llvm::Function*>&\n                               funcsToFree, llvm::ExecutionEngine* engine) {\n  llvm::SmallPtrSet<llvm::Function*, 40> funcsToFreeUnique;\n  for (size_t i = 0; i < funcsToFree.size(); ++i) {\n    llvm::Function* func = funcsToFree[i];\n    assert(func && \"Cannot free NULL function\");\n    if (funcsToFreeUnique.insert(func).second) {\n      for (llvm::Value::use_iterator IU = func->use_begin(),\n             EU = func->use_end(); IU != EU; ++IU) {\n        llvm::Instruction* instUser = llvm::dyn_cast<llvm::Instruction>(*IU);\n        if (!instUser) continue;\n        if (!instUser->getParent()) continue;\n        if (llvm::Function* userFunc = instUser->getParent()->getParent())\n          funcsToFree.push_back(userFunc);\n      }\n    }\n  }\n  for (llvm::SmallPtrSet<llvm::Function*, 40>::iterator\n         I = funcsToFreeUnique.begin(), E = funcsToFreeUnique.end();\n       I != E; ++I) {\n    // This should force the JIT to recompile the function. But the stubs stay,\n    // and the JIT reuses the stubs now pointing nowhere, i.e. without updating\n    // the machine code address. Fix the JIT, or hope that MCJIT helps.\n    //engine->freeMachineCodeForFunction(*I);\n    engine->updateGlobalMapping(*I, 0);\n  }\n}\n#endif\n\nIncrementalExecutor::ExecutionResult\nIncrementalExecutor::runStaticInitializersOnce(const Transaction& T) {\n  auto m = T.getModule();\n  assert(m.get() && \"Module must not be null\");\n\n  // We don't care whether something was unresolved before.\n  m_unresolvedSymbols.clear();\n\n  // check if there is any unresolved symbol in the list\n  if (diagnoseUnresolvedSymbols(\"static initializers\"))\n    return kExeUnresolvedSymbols;\n\n  llvm::GlobalVariable* GV\n     = m->getGlobalVariable(\"llvm.global_ctors\", true);\n  // Nothing to do is good, too.\n  if (!GV) return kExeSuccess;\n\n  // Close similarity to\n  // m_engine->runStaticConstructorsDestructors(false) aka\n  // llvm::ExecutionEngine::runStaticConstructorsDestructors()\n  // is intentional; we do an extra pass to check whether the JIT\n  // managed to collect all the symbols needed by the niitializers.\n  // Should be an array of '{ i32, void ()* }' structs.  The first value is\n  // the init priority, which we ignore.\n  llvm::ConstantArray *InitList\n    = llvm::dyn_cast<llvm::ConstantArray>(GV->getInitializer());\n\n  // We need to delete it here just in case we have recursive inits, otherwise\n  // it will call inits multiple times.\n  GV->eraseFromParent();\n\n  if (InitList == 0)\n    return kExeSuccess;\n\n  //SmallVector<Function*, 2> initFuncs;\n\n  for (unsigned i = 0, e = InitList->getNumOperands(); i != e; ++i) {\n    llvm::ConstantStruct *CS\n      = llvm::dyn_cast<llvm::ConstantStruct>(InitList->getOperand(i));\n    if (CS == 0) continue;\n\n    llvm::Constant *FP = CS->getOperand(1);\n    if (FP->isNullValue())\n      continue;  // Found a sentinal value, ignore.\n\n    // Strip off constant expression casts.\n    if (llvm::ConstantExpr *CE = llvm::dyn_cast<llvm::ConstantExpr>(FP))\n      if (CE->isCast())\n        FP = CE->getOperand(0);\n\n    // Execute the ctor/dtor function!\n    if (llvm::Function *F = llvm::dyn_cast<llvm::Function>(FP)) {\n      const llvm::StringRef fName = F->getName();\n      executeInit(fName);\n/*\n      initFuncs.push_back(F);\n      if (fName.startswith(\"_GLOBAL__sub_I_\")) {\n        BasicBlock& BB = F->getEntryBlock();\n        for (BasicBlock::iterator I = BB.begin(), E = BB.end(); I != E; ++I)\n          if (CallInst* call = dyn_cast<CallInst>(I))\n            initFuncs.push_back(call->getCalledFunction());\n      }\n*/\n    }\n  }\n\n/*\n  for (SmallVector<Function*,2>::iterator I = initFuncs.begin(),\n         E = initFuncs.end(); I != E; ++I) {\n    // Cleanup also the dangling init functions. They are in the form:\n    // define internal void @_GLOBAL__I_aN() section \"...\"{\n    // entry:\n    //   call void @__cxx_global_var_init(N-1)()\n    //   call void @__cxx_global_var_initM()\n    //   ret void\n    // }\n    //\n    // define internal void @__cxx_global_var_init(N-1)() section \"...\" {\n    // entry:\n    //   call void @_ZN7MyClassC1Ev(%struct.MyClass* @n)\n    //   ret void\n    // }\n\n    // Erase __cxx_global_var_init(N-1)() first.\n    (*I)->removeDeadConstantUsers();\n    (*I)->eraseFromParent();\n  }\n*/\n\n  return kExeSuccess;\n}\n\nvoid IncrementalExecutor::runAndRemoveStaticDestructors(Transaction* T) {\n  assert(T && \"Must be set\");\n  // Collect all the dtors bound to this transaction.\n  AtExitFunctions::mapped_type Local;\n  {\n    cling::internal::SpinLockGuard slg(m_AtExitFuncsSpinLock);\n    auto Itr = m_AtExitFuncs.find(T->getModule());\n    if (Itr == m_AtExitFuncs.end()) return;\n    m_AtExitFuncs.erase(Itr, &Local);\n  } // end of spin lock lifetime block.\n\n  // 'Unload' the cxa_atexit, atexit entities.\n  for (auto&& AtExit : llvm::reverse(Local)) {\n    AtExit();\n    // Run anything that was just registered in 'AtExit()'\n    runAndRemoveStaticDestructors(T);\n  }\n}\n\nvoid\nIncrementalExecutor::installLazyFunctionCreator(LazyFunctionCreatorFunc_t fp)\n{\n  m_lazyFuncCreator.push_back(fp);\n}\n\nbool\nIncrementalExecutor::addSymbol(const char* Name,  void* Addr,\n                               bool Jit) {\n  return m_JIT->lookupSymbol(Name, Addr, Jit).second;\n}\n\nvoid* IncrementalExecutor::getAddressOfGlobal(llvm::StringRef symbolName,\n                                              bool* fromJIT /*=0*/) {\n  // Return a symbol's address, and whether it was jitted.\n  void* address = m_JIT->lookupSymbol(symbolName).first;\n\n  // It's not from the JIT if it's in a dylib.\n  if (fromJIT)\n    *fromJIT = !address;\n\n  if (!address)\n    return (void*)m_JIT->getSymbolAddress(symbolName, false /*no dlsym*/);\n\n  return address;\n}\n\nvoid*\nIncrementalExecutor::getPointerToGlobalFromJIT(const llvm::GlobalValue& GV) {\n  // Get the function / variable pointer referenced by GV.\n\n  // We don't care whether something was unresolved before.\n  m_unresolvedSymbols.clear();\n\n  void* addr = (void*)m_JIT->getSymbolAddress(GV.getName(),\n                                              false /*no dlsym*/);\n\n  if (diagnoseUnresolvedSymbols(GV.getName(), \"symbol\"))\n    return 0;\n  return addr;\n}\n\nbool IncrementalExecutor::diagnoseUnresolvedSymbols(llvm::StringRef trigger,\n                                                    llvm::StringRef title) {\n  if (m_unresolvedSymbols.empty())\n    return false;\n\n  llvm::SmallVector<llvm::Function*, 128> funcsToFree;\n  for (const std::string& sym : m_unresolvedSymbols) {\n#if 0\n    // FIXME: This causes a lot of test failures, for some reason it causes\n    // the call to HandleMissingFunction to be elided.\n    unsigned diagID = m_Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n                                              \"%0 unresolved while jitting %1\");\n    (void)diagID;\n    //m_Diags.Report(diagID) << sym << funcname; // TODO: demangle the names.\n#endif\n\n    cling::errs() << \"IncrementalExecutor::executeFunction: symbol '\" << sym\n                  << \"' unresolved while linking \";\n    if (trigger.find(utils::Synthesize::UniquePrefix) != llvm::StringRef::npos)\n      cling::errs() << \"[cling interface function]\";\n    else {\n      if (!title.empty())\n        cling::errs() << title << \" '\";\n      cling::errs() << trigger;\n      if (!title.empty())\n        cling::errs() << \"'\";\n    }\n    cling::errs() << \"!\\n\";\n\n    // Be helpful, demangle!\n    std::string demangledName = platform::Demangle(sym);\n    if (!demangledName.empty()) {\n       cling::errs()\n          << \"You are probably missing the definition of \"\n          << demangledName << \"\\n\"\n          << \"Maybe you need to load the corresponding shared library?\\n\";\n    }\n\n    //llvm::Function *ff = m_engine->FindFunctionNamed(i->c_str());\n    // i could also reference a global variable, in which case ff == 0.\n    //if (ff)\n    //  funcsToFree.push_back(ff);\n  }\n  //freeCallersOfUnresolvedSymbols(funcsToFree, m_engine.get());\n  m_unresolvedSymbols.clear();\n  return true;\n}\n\n}// end namespace cling\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/pyroot_experimental/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx": "// Bindings\n#include \"capi.h\"\n#include \"cpp_cppyy.h\"\n#include \"callcontext.h\"\n\n// ROOT\n#include \"TBaseClass.h\"\n#include \"TClass.h\"\n#include \"TClassRef.h\"\n#include \"TClassTable.h\"\n#include \"TClassEdit.h\"\n#include \"TCollection.h\"\n#include \"TDataMember.h\"\n#include \"TDataType.h\"\n#include \"TEnum.h\"\n#include \"TEnv.h\"\n#include \"TError.h\"\n#include \"TFunction.h\"\n#include \"TFunctionTemplate.h\"\n#include \"TGlobal.h\"\n#include \"TInterpreter.h\"\n#include \"TList.h\"\n#include \"TMethod.h\"\n#include \"TMethodArg.h\"\n#include \"TROOT.h\"\n#include \"TSystem.h\"\n\n// Standard\n#include <assert.h>\n#include <algorithm>     // for std::count\n#include <dlfcn.h>\n#include <stdexcept>\n#include <map>\n#include <new>\n#include <set>\n#include <sstream>\n#include <stdlib.h>      // for getenv\n#include <string.h>\n\n// temp\n#include <iostream>\ntypedef CPyCppyy::Parameter Parameter;\n// --temp\n\n\n// small number that allows use of stack for argument passing\nconst int SMALL_ARGS_N = 8;\n\n// data for life time management ---------------------------------------------\ntypedef std::vector<TClassRef> ClassRefs_t;\nstatic ClassRefs_t g_classrefs(1);\nstatic const ClassRefs_t::size_type GLOBAL_HANDLE = 1;\nstatic const ClassRefs_t::size_type STD_HANDLE = GLOBAL_HANDLE + 1;\n\ntypedef std::map<std::string, ClassRefs_t::size_type> Name2ClassRefIndex_t;\nstatic Name2ClassRefIndex_t g_name2classrefidx;\n\nstruct CallWrapper {\n    CallWrapper(TFunction* f) : fMetaFunction(f), fWrapper(nullptr) {}\n    TFunction*  fMetaFunction;\n    CallFunc_t* fWrapper;\n};\nstatic std::vector<CallWrapper*> gWrapperHolder;\nstatic inline CallWrapper* new_CallWrapper(TFunction* f) {\n    CallWrapper* wrap = new CallWrapper(f);\n    gWrapperHolder.push_back(wrap);\n    return wrap;\n}\n\n\ntypedef std::vector<TGlobal*> GlobalVars_t;\nstatic GlobalVars_t g_globalvars;\n\nstatic std::set<std::string> gSTLNames;\n\n// data ----------------------------------------------------------------------\nCppyy::TCppScope_t Cppyy::gGlobalScope = GLOBAL_HANDLE;\n\n// smart pointer types\nstatic std::set<std::string> gSmartPtrTypes =\n    {\"auto_ptr\", \"shared_ptr\", \"weak_ptr\", \"unique_ptr\"};\n\n// configuration\nstatic bool gEnableFastPath = true;\n\n\n// global initialization -----------------------------------------------------\nnamespace {\n\nclass ApplicationStarter {\npublic:\n    ApplicationStarter() {\n    // setup dummy holders for global and std namespaces\n        assert(g_classrefs.size() == GLOBAL_HANDLE);\n        g_name2classrefidx[\"\"]      = GLOBAL_HANDLE;\n        g_classrefs.push_back(TClassRef(\"\"));\n\n    // aliases for std (setup already in pythonify)\n        g_name2classrefidx[\"std\"]   = STD_HANDLE;\n        g_name2classrefidx[\"::std\"] = g_name2classrefidx[\"std\"];\n        g_classrefs.push_back(TClassRef(\"std\"));\n\n    // add a dummy global to refer to as null at index 0\n        g_globalvars.push_back(nullptr);\n\n    // disable fast path if requested\n        if (getenv(\"CPPYY_DISABLE_FASTPATH\")) gEnableFastPath = false;\n\n    // fill the set of STL names\n        const char* stl_names[] = {\"string\", \"bitset\", \"pair\", \"allocator\",\n            \"auto_ptr\", \"shared_ptr\", \"unique_ptr\", \"weak_ptr\",\n            \"vector\", \"list\", \"forward_list\", \"deque\", \"map\", \"multimap\",\n            \"set\", \"multiset\", \"unordered_set\", \"unordered_multiset\",\n            \"unordered_map\", \"unordered_multimap\",\n            \"iterator\", \"reverse_iterator\", \"basic_string\",\n            \"complex\", \"valarray\"};\n        for (auto& name : stl_names)\n            gSTLNames.insert(name);\n\n    // create a helper for wrapping lambdas\n        gInterpreter->Declare(\n            \"namespace __cppyy_internal { template <typename F>\"\n            \"struct FT : public FT<decltype(&F::operator())> {};\"\n            \"template <typename C, typename R, typename... Args>\"\n            \"struct FT<R(C::*)(Args...) const> { typedef std::function<R(Args...)> F; };}\"\n        );\n\n    // start off with a reasonable size placeholder for wrappers\n        gWrapperHolder.reserve(1024);\n    }\n\n    ~ApplicationStarter() {\n        for (auto wrap : gWrapperHolder) {\n            if (wrap->fWrapper)\n                gInterpreter->CallFunc_Delete(wrap->fWrapper);\n            delete wrap;\n        }\n    }\n} _applicationStarter;\n\n} // unnamed namespace\n\n\n// local helpers -------------------------------------------------------------\nstatic inline\nTClassRef& type_from_handle(Cppyy::TCppScope_t scope)\n{\n    assert((ClassRefs_t::size_type)scope < g_classrefs.size());\n    return g_classrefs[(ClassRefs_t::size_type)scope];\n}\n\n// type_from_handle to go here\nstatic inline\nTFunction* type_get_method(Cppyy::TCppType_t klass, Cppyy::TCppIndex_t idx)\n{\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass())\n        return (TFunction*)cr->GetListOfMethods(false)->At(idx);\n    assert(klass == (Cppyy::TCppType_t)GLOBAL_HANDLE);\n    return ((CallWrapper*)idx)->fMetaFunction;\n}\n\nstatic inline\nTFunction* m2f(Cppyy::TCppMethod_t method) {\n    return ((CallWrapper*)method)->fMetaFunction;\n}\n\nstatic inline\nCppyy::TCppScope_t declaring_scope(Cppyy::TCppMethod_t method)\n{\n    if (method) {\n        TMethod* m = dynamic_cast<TMethod*>(m2f(method));\n        if (m) return Cppyy::GetScope(m->GetClass()->GetName());\n    }\n    return (Cppyy::TCppScope_t)GLOBAL_HANDLE;\n}\n\nstatic inline\nchar* cppstring_to_cstring(const std::string& cppstr)\n{\n    char* cstr = (char*)malloc(cppstr.size()+1);\n    memcpy(cstr, cppstr.c_str(), cppstr.size()+1);\n    return cstr;\n}\n\nstatic inline \nbool match_name(const std::string& tname, const std::string fname)\n{\n// either match exactly, or match the name as template\n    if (fname.rfind(tname, 0) == 0) {\n        if ((tname.size() == fname.size()) ||\n              (tname.size() < fname.size() && fname[tname.size()] == '<'))\n           return true;\n    }\n    return false;\n}\n\nstatic inline\nbool is_stl(const std::string& name)\n{\n    std::string w = name;\n    if (w.compare(0, 5, \"std::\") == 0)\n        w = w.substr(5, std::string::npos);\n    std::string::size_type pos = name.find('<');\n    if (pos != std::string::npos)\n        w = w.substr(0, pos);\n    return gSTLNames.find(w) != gSTLNames.end();\n}\n\nstatic inline\nbool is_missclassified_stl(const std::string& name)\n{\n    std::string::size_type pos = name.find('<');\n    if (pos != std::string::npos)\n        return gSTLNames.find(name.substr(0, pos)) != gSTLNames.end();\n    return gSTLNames.find(name) != gSTLNames.end();\n}\n\n\n// name to opaque C++ scope representation -----------------------------------\nstd::string Cppyy::ResolveName(const std::string& cppitem_name)\n{\n// Fully resolve the given name to the final type name.\n    std::string tclean = cppitem_name.compare(0, 2, \"::\") == 0 ?\n        cppitem_name.substr(2, std::string::npos) : cppitem_name;\n\n// classes (most common)\n    tclean = TClassEdit::CleanType(tclean.c_str());\n    if (tclean.empty() /* unknown, eg. an operator */) return cppitem_name;\n\n// reduce [N] to []\n    if (tclean[tclean.size()-1] == ']')\n        tclean = tclean.substr(0, tclean.rfind('[')) + \"[]\";\n\n// data types (such as builtins)\n    TDataType* dt = gROOT->GetType(tclean.c_str());\n    if (dt) return dt->GetFullTypeName();\n\n// special case for enums\n    if (IsEnum(cppitem_name))\n        return ResolveEnum(cppitem_name);\n\n// typedefs\n    return TClassEdit::ResolveTypedef(tclean.c_str(), true);\n}\n\nstatic std::map<std::string, std::string> resolved_enum_types;\nstd::string Cppyy::ResolveEnum(const std::string& enum_type)\n{\n// The underlying type of a an enum may be any kind of integer.\n// Resolve that type via a workaround (note: this function assumes\n// that the enum_type name is a valid enum type name)\n    auto res = resolved_enum_types.find(enum_type);\n    if (res != resolved_enum_types.end())\n        return res->second;\n\n    if (enum_type.find(\"(anonymous\") == std::string::npos) {\n        std::ostringstream decl;\n        for (auto& itype : {\"unsigned int\"}) {\n            decl << \"std::is_same<\"\n                 << itype\n                 << \", std::underlying_type<\"\n                 << enum_type\n                 << \">::type>::value;\";\n            if (gInterpreter->ProcessLine(decl.str().c_str())) {\n                resolved_enum_types[enum_type] = itype;\n                return itype;\n            }\n        }\n    }\n\n// failed or anonymous ... signal up stream to special case this\n    resolved_enum_types[enum_type] = \"internal_enum_type_t\";\n    return \"internal_enum_type_t\";      // should default to int\n}\n\nCppyy::TCppScope_t Cppyy::GetScope(const std::string& sname)\n{\n// TODO: scope_name should always be final already\n    std::string scope_name = ResolveName(sname);\n    auto icr = g_name2classrefidx.find(scope_name);\n    if (icr != g_name2classrefidx.end())\n        return (TCppType_t)icr->second;\n\n// use TClass directly, to enable auto-loading; class may be stubbed (eg. for\n// function returns) leading to a non-null TClass that is otherwise invalid\n    TClassRef cr(TClass::GetClass(scope_name.c_str(), true /* load */, true /* silent */));\n    if (!cr.GetClass() || !cr->Property())\n        return (TCppScope_t)0;\n\n    // no check for ClassInfo as forward declared classes are okay (fragile)\n\n    ClassRefs_t::size_type sz = g_classrefs.size();\n    g_name2classrefidx[scope_name] = sz;\n    g_classrefs.push_back(TClassRef(scope_name.c_str()));\n    return (TCppScope_t)sz;\n}\n\nbool Cppyy::IsTemplate(const std::string& template_name)\n{\n    return (bool)gInterpreter->CheckClassTemplate(template_name.c_str());\n}\n\nCppyy::TCppType_t Cppyy::GetActualClass(TCppType_t klass, TCppObject_t obj)\n{\n    TClassRef& cr = type_from_handle(klass);\n    TClass* clActual = cr->GetActualClass((void*)obj);\n    if (clActual && clActual != cr.GetClass()) {\n    // TODO: lookup through name should not be needed\n        return (TCppType_t)GetScope(clActual->GetName());\n    }\n    return klass;\n}\n\nsize_t Cppyy::SizeOf(TCppType_t klass)\n{\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass()) return (size_t)cr->Size();\n    return (size_t)0;\n}\n\nsize_t Cppyy::SizeOf(const std::string& type_name)\n{\n    TDataType* dt = gROOT->GetType(type_name.c_str());\n    if (dt) return dt->Size();\n    return SizeOf(GetScope(type_name));\n}\n\nbool Cppyy::IsBuiltin(const std::string& type_name)\n{\n    TDataType* dt = gROOT->GetType(TClassEdit::CleanType(type_name.c_str(), 1).c_str());\n    if (dt) return dt->GetType() != kOther_t;\n    return false;\n}\n\nbool Cppyy::IsComplete(const std::string& type_name)\n{\n// verify whether the dictionary of this class is fully available\n    bool b = false;\n\n    int oldEIL = gErrorIgnoreLevel;\n    gErrorIgnoreLevel = 3000;\n    TClass* klass = TClass::GetClass(TClassEdit::ShortType(type_name.c_str(), 1).c_str());\n    if (klass && klass->GetClassInfo())     // works for normal case w/ dict\n        b = gInterpreter->ClassInfo_IsLoaded(klass->GetClassInfo());\n    else {    // special case for forward declared classes\n        ClassInfo_t* ci = gInterpreter->ClassInfo_Factory(type_name.c_str());\n        if (ci) {\n            b = gInterpreter->ClassInfo_IsLoaded(ci);\n            gInterpreter->ClassInfo_Delete(ci);  // we own the fresh class info\n        }\n    }\n    gErrorIgnoreLevel = oldEIL;\n    return b;\n}\n\n// memory management ---------------------------------------------------------\nCppyy::TCppObject_t Cppyy::Allocate(TCppType_t type)\n{\n    TClassRef& cr = type_from_handle(type);\n    return (TCppObject_t)malloc(cr->Size());\n}\n\nvoid Cppyy::Deallocate(TCppType_t /* type */, TCppObject_t instance)\n{\n    ::operator delete(instance);\n}\n\nCppyy::TCppObject_t Cppyy::Construct(TCppType_t type)\n{\n    TClassRef& cr = type_from_handle(type);\n    return (TCppObject_t)cr->New();\n}\n\nvoid Cppyy::Destruct(TCppType_t type, TCppObject_t instance)\n{\n    TClassRef& cr = type_from_handle(type);\n    cr->Destructor((void*)instance);\n}\n\n\n// method/function dispatching -----------------------------------------------\nstatic inline CallFunc_t* GetCallFunc(Cppyy::TCppMethod_t method)\n{\n// TODO: method should be a callfunc, so that no mapping would be needed.\n    CallWrapper* wrap = (CallWrapper*)method;\n    if (wrap->fWrapper) return wrap->fWrapper;\n\n    TFunction* func = wrap->fMetaFunction;\n\n    CallFunc_t* callf = gInterpreter->CallFunc_Factory();\n    MethodInfo_t* meth = gInterpreter->MethodInfo_Factory(func->GetDeclId());\n    gInterpreter->CallFunc_SetFunc(callf, meth);\n    gInterpreter->MethodInfo_Delete(meth);\n\n    if (!(callf && gInterpreter->CallFunc_IsValid(callf))) {\n    // TODO: propagate this error to caller w/o use of Python C-API\n    /*\n        PyErr_Format(PyExc_RuntimeError, \"could not resolve %s::%s(%s)\",\n            const_cast<TClassRef&>(klass).GetClassName(),\n            func ? func->GetName() : const_cast<TClassRef&>(klass).GetClassName(),\n            callString.c_str()); */\n        std::cerr << \"TODO: report unresolved function error to Python\\n\";\n        if (callf) gInterpreter->CallFunc_Delete(callf);\n        return nullptr;\n    }\n\n    wrap->fWrapper = callf;\n    return callf;\n}\n\nstatic inline\nbool copy_args(void* args_, void** vargs)\n{\n    bool runRelease = false;\n    std::vector<Parameter>& args = *(std::vector<Parameter>*)args_;\n    for (std::vector<Parameter>::size_type i = 0; i < args.size(); ++i) {\n        switch (args[i].fTypeCode) {\n        case 'b':       /* bool */\n            vargs[i] = (void*)&args[i].fValue.fBool;\n            break;\n        case 'h':       /* short */\n            vargs[i] = (void*)&args[i].fValue.fShort;\n            break;\n        case 'H':       /* unsigned short */\n            vargs[i] = (void*)&args[i].fValue.fUShort;\n           break;\n        case 'i':       /* int */\n            vargs[i] = (void*)&args[i].fValue.fInt;\n           break;\n        case 'I':       /* unsigned int */\n            vargs[i] = (void*)&args[i].fValue.fUInt;\n            break;\n        case 'l':       /* long */\n            vargs[i] = (void*)&args[i].fValue.fLong;\n            break;\n        case 'L':       /* unsigned long */\n            vargs[i] = (void*)&args[i].fValue.fULong;\n            break;\n        case 'q':       /* long long */\n            vargs[i] = (void*)&args[i].fValue.fLongLong;\n            break;\n        case 'Q':       /* unsigned long long */\n            vargs[i] = (void*)&args[i].fValue.fULongLong;\n            break;\n        case 'f':       /* float */\n            vargs[i] = (void*)&args[i].fValue.fFloat;\n            break;\n        case 'd':       /* double */\n            vargs[i] = (void*)&args[i].fValue.fDouble;\n            break;\n        case 'g':       /* long double */\n            vargs[i] = (void*)&args[i].fValue.fLongDouble;\n            break;\n        case 'a':\n        case 'o':\n        case 'p':       /* void* */\n            vargs[i] = (void*)&args[i].fValue.fVoidp;\n            break;\n        case 'X':       /* (void*)type& with free */\n            runRelease = true;\n        case 'V':       /* (void*)type& */\n            vargs[i] = args[i].fValue.fVoidp;\n            break;\n        case 'r':       /* const type& */\n            vargs[i] = args[i].fRef;\n            break;\n        default:\n            std::cerr << \"unknown type code: \" << args[i].fTypeCode << std::endl;\n            break;\n        }\n    }\n    return runRelease;\n}\n\nstatic inline\nvoid release_args(const std::vector<Parameter>& args) {\n    for (std::vector<Parameter>::size_type i = 0; i < args.size(); ++i) {\n        if (args[i].fTypeCode == 'X')\n            free(args[i].fValue.fVoidp);\n    }\n}\n\nstatic bool FastCall(Cppyy::TCppMethod_t method, void* args_, void* self, void* result)\n{\n    const std::vector<Parameter>& args = *(std::vector<Parameter>*)args_;\n\n    CallFunc_t* callf = GetCallFunc(method);\n    if (!callf)\n        return false;\n\n    TInterpreter::CallFuncIFacePtr_t faceptr = gCling->CallFunc_IFacePtr(callf);\n    if (faceptr.fKind == TInterpreter::CallFuncIFacePtr_t::kGeneric) {\n        bool runRelease = false;\n        if (args.size() <= SMALL_ARGS_N) {\n            void* smallbuf[SMALL_ARGS_N];\n            runRelease = copy_args(args_, smallbuf);\n            faceptr.fGeneric(self, args.size(), smallbuf, result);\n        } else {\n            std::vector<void*> buf(args.size());\n            runRelease = copy_args(args_, buf.data());\n            faceptr.fGeneric(self, args.size(), buf.data(), result);\n        }\n        if (runRelease) release_args(args);\n        return true;\n    }\n\n    if (faceptr.fKind == TInterpreter::CallFuncIFacePtr_t::kCtor) {\n        bool runRelease = false;\n        if (args.size() <= SMALL_ARGS_N) {\n            void* smallbuf[SMALL_ARGS_N];\n            runRelease = copy_args(args_, (void**)smallbuf);\n            faceptr.fCtor((void**)smallbuf, result, args.size());\n        } else {\n            std::vector<void*> buf(args.size());\n            runRelease = copy_args(args_, buf.data());\n            faceptr.fCtor(buf.data(), result, args.size());\n        }\n        if (runRelease) release_args(args);\n        return true;\n    }\n\n    if (faceptr.fKind == TInterpreter::CallFuncIFacePtr_t::kDtor) {\n        std::cerr << \" DESTRUCTOR NOT IMPLEMENTED YET! \" << std::endl;\n        return false;\n    }\n\n    return false;\n}\n\ntemplate< typename T >\nstatic inline\nT CallT(Cppyy::TCppMethod_t method, Cppyy::TCppObject_t self, void* args)\n{\n    T t{};\n    if (FastCall(method, args, (void*)self, &t))\n        return t;\n    return (T)-1;\n}\n\n#define CPPYY_IMP_CALL(typecode, rtype)                                      \\\nrtype Cppyy::Call##typecode(TCppMethod_t method, TCppObject_t self, void* args)\\\n{                                                                            \\\n    return CallT<rtype>(method, self, args);                                 \\\n}\n\nvoid Cppyy::CallV(TCppMethod_t method, TCppObject_t self, void* args)\n{\n   if (!FastCall(method, args, (void*)self, nullptr))\n       return /* TODO ... report error */;\n}\n\nCPPYY_IMP_CALL(B,  unsigned char)\nCPPYY_IMP_CALL(C,  char         )\nCPPYY_IMP_CALL(H,  short        )\nCPPYY_IMP_CALL(I,  int          )\nCPPYY_IMP_CALL(L,  long         )\nCPPYY_IMP_CALL(LL, Long64_t     )\nCPPYY_IMP_CALL(F,  float        )\nCPPYY_IMP_CALL(D,  double       )\nCPPYY_IMP_CALL(LD, LongDouble_t )\n\nvoid* Cppyy::CallR(TCppMethod_t method, TCppObject_t self, void* args)\n{\n    void* r = nullptr;\n    if (FastCall(method, args, (void*)self, &r))\n        return r;\n    return nullptr;\n}\n\nchar* Cppyy::CallS(\n    TCppMethod_t method, TCppObject_t self, void* args, size_t* length)\n{\n    char* cstr = nullptr;\n    TClassRef cr(\"std::string\");\n    std::string* cppresult = (std::string*)malloc(sizeof(std::string));\n    if (FastCall(method, args, self, (void*)cppresult)) {\n        cstr = cppstring_to_cstring(*cppresult);\n        *length = cppresult->size();\n        cppresult->std::string::~basic_string();\n    } else\n        *length = 0;\n    free((void*)cppresult); \n    return cstr;\n}\n\nCppyy::TCppObject_t Cppyy::CallConstructor(\n    TCppMethod_t method, TCppType_t /* klass */, void* args)\n{\n    void* obj = nullptr;\n    if (FastCall(method, args, nullptr, &obj))\n        return (TCppObject_t)obj;\n    return (TCppObject_t)0;\n}\n\nvoid Cppyy::CallDestructor(TCppType_t type, TCppObject_t self)\n{\n    TClassRef& cr = type_from_handle(type);\n    cr->Destructor((void*)self, true);\n}\n\nCppyy::TCppObject_t Cppyy::CallO(TCppMethod_t method,\n    TCppObject_t self, void* args, TCppType_t result_type)\n{\n    TClassRef& cr = type_from_handle(result_type);\n    void* obj = ::operator new(cr->Size());\n    if (FastCall(method, args, self, obj))\n        return (TCppObject_t)obj;\n    return (TCppObject_t)0;\n}\n\nCppyy::TCppFuncAddr_t Cppyy::GetFunctionAddress(TCppScope_t scope, TCppIndex_t idx)\n{\n    if (!gEnableFastPath) return (TCppFuncAddr_t)nullptr;\n    TFunction* f = type_get_method(scope, idx);\n    return (TCppFuncAddr_t)dlsym(RTLD_DEFAULT, f->GetMangledName());\n}\n\nCppyy::TCppFuncAddr_t Cppyy::GetFunctionAddress(TCppMethod_t method)\n{\n    if (!gEnableFastPath) return (TCppFuncAddr_t)nullptr;\n    TFunction* f = m2f(method);\n    return (TCppFuncAddr_t)dlsym(RTLD_DEFAULT, f->GetMangledName());\n}\n\n\n// handling of function argument buffer --------------------------------------\nvoid* Cppyy::AllocateFunctionArgs(size_t nargs)\n{\n    return new Parameter[nargs];\n}\n\nvoid Cppyy::DeallocateFunctionArgs(void* args)\n{\n    delete [] (Parameter*)args;\n}\n\nsize_t Cppyy::GetFunctionArgSizeof()\n{\n    return sizeof(Parameter);\n}\n\nsize_t Cppyy::GetFunctionArgTypeoffset()\n{\n    return offsetof(Parameter, fTypeCode);\n}\n\n\n// scope reflection information ----------------------------------------------\nbool Cppyy::IsNamespace(TCppScope_t scope)\n{\n// Test if this scope represents a namespace.\n    if (scope == GLOBAL_HANDLE)\n        return true;\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass())\n        return cr->Property() & kIsNamespace;\n    return false;\n}\n\nbool Cppyy::IsAbstract(TCppType_t klass)\n{\n// Test if this type may not be instantiated.\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass())\n        return cr->Property() & kIsAbstract;\n    return false;\n}\n\nbool Cppyy::IsEnum(const std::string& type_name)\n{\n    if (type_name.empty()) return false;\n    return gInterpreter->ClassInfo_IsEnum(type_name.c_str());\n}\n\n// helpers for stripping scope names\nstatic\nstd::string outer_with_template(const std::string& name)\n{\n// Cut down to the outer-most scope from <name>, taking proper care of templates.\n    int tpl_open = 0;\n    for (std::string::size_type pos = 0; pos < name.size(); ++pos) {\n        std::string::value_type c = name[pos];\n\n    // count '<' and '>' to be able to skip template contents\n        if (c == '<')\n            ++tpl_open;\n        else if (c == '>')\n            --tpl_open;\n\n    // collect name up to \"::\"\n        else if (tpl_open == 0 && \\\n                 c == ':' && pos+1 < name.size() && name[pos+1] == ':') {\n        // found the extend of the scope ... done\n            return name.substr(0, pos-1);\n        }\n    }\n\n// whole name is apparently a single scope\n    return name;\n}\n\nstatic\nstd::string outer_no_template(const std::string& name)\n{\n// Cut down to the outer-most scope from <name>, drop templates\n    std::string::size_type first_scope = name.find(':');\n    if (first_scope == std::string::npos)\n        return name.substr(0, name.find('<'));\n    std::string::size_type first_templ = name.find('<');\n    if (first_templ == std::string::npos)\n        return name.substr(0, first_scope);\n    return name.substr(0, std::min(first_templ, first_scope));\n}\n\n#define FILL_COLL(type, filter) {                                             \\\n    TIter itr{coll};                                                          \\\n    type* obj = nullptr;                                                      \\\n    while ((obj = (type*)itr.Next())) {                                       \\\n        const char* nm = obj->GetName();                                      \\\n        if (nm && nm[0] != '_' && !(obj->Property() & (filter)))              \\\n            cppnames.insert(nm);                                              \\\n    }}\n\nstatic inline\nvoid cond_add(Cppyy::TCppScope_t scope, const std::string& ns_scope,\n    std::set<std::string>& cppnames, const char* name)\n{\n    if (!name || name[0] == '_' || strstr(name, \".h\") != 0 || strncmp(name, \"operator\", 8) == 0)\n        return;\n\n    if (scope == GLOBAL_HANDLE) {\n        if (!is_missclassified_stl(name))\n            cppnames.insert(outer_no_template(name));\n    } else if (scope == STD_HANDLE) {\n        if (strncmp(name, \"std::\", 5) == 0) name += 5;\n        else if (!is_missclassified_stl(name)) return;\n        cppnames.insert(outer_no_template(name));\n    } else {\n        if (strncmp(name, ns_scope.c_str(), ns_scope.size()) == 0)\n            cppnames.insert(outer_with_template(name + ns_scope.size()));\n    }\n}\n\nvoid Cppyy::GetAllCppNames(TCppScope_t scope, std::set<std::string>& cppnames)\n{\n// Collect all known names of C++ entities under scope. This is useful for IDEs\n// employing tab-completion, for example. Note that functions names need not be\n// unique as they can be overloaded.\n\n    TClassRef& cr = type_from_handle(scope);\n    if (scope != GLOBAL_HANDLE && !(cr.GetClass() && cr->Property()))\n        return;\n\n    std::string ns_scope = GetFinalName(scope);\n    if (scope != GLOBAL_HANDLE) ns_scope += \"::\";\n\n// add existing values from read rootmap files if within this scope\n    TCollection* coll = gInterpreter->GetMapfile()->GetTable();\n    {\n        TIter itr{coll};\n        TEnvRec* ev = nullptr;\n        while ((ev = (TEnvRec*)itr.Next()))\n            cond_add(scope, ns_scope, cppnames, ev->GetName());\n    }\n\n// do we care about the class table or are the rootmap and list of types enough?\n/*\n    gClassTable->Init();\n    const int N = gClassTable->Classes();\n    for (int i = 0; i < N; ++i)\n        cond_add(scope, ns_scope, cppnames, gClassTable->Next());\n*/\n\n// any other types (e.g. that may have come from parsing headers)\n    coll = gROOT->GetListOfTypes();\n    {\n        TIter itr{coll};\n        TDataType* dt = nullptr;\n        while ((dt = (TDataType*)itr.Next())) {\n            if (!(dt->Property() & kIsFundamental))\n                cond_add(scope, ns_scope, cppnames, dt->GetName());\n        }\n    }\n\n// add functions\n    coll = (scope == GLOBAL_HANDLE) ?\n        gROOT->GetListOfGlobalFunctions() : cr->GetListOfMethods();\n    {\n        TIter itr{coll};\n        TFunction* obj = nullptr;\n        while ((obj = (TFunction*)itr.Next())) {\n            const char* nm = obj->GetName();\n        // skip templated functions, adding only the un-instantiated ones\n            if (nm && nm[0] != '_' && strstr(nm, \"<\") == 0 && strncmp(nm, \"operator\", 8) != 0)\n                cppnames.insert(nm);\n        }\n    }\n\n// add uninstantiated templates\n    coll = (scope == GLOBAL_HANDLE) ?\n        gROOT->GetListOfFunctionTemplates() : cr->GetListOfFunctionTemplates();\n    FILL_COLL(TFunctionTemplate, kIsPrivate | kIsProtected)\n\n// add (global) data members\n    if (scope == GLOBAL_HANDLE) {\n        coll = gROOT->GetListOfGlobals();\n        FILL_COLL(TGlobal, kIsEnum | kIsPrivate | kIsProtected)\n    } else {\n        coll = cr->GetListOfDataMembers();\n        FILL_COLL(TDataMember, kIsEnum | kIsPrivate | kIsProtected)\n    }\n\n// add enums values only for user classes/namespaces\n    if (scope != GLOBAL_HANDLE && scope != STD_HANDLE) {\n        coll = cr->GetListOfEnums();\n        FILL_COLL(TEnum, kIsPrivate | kIsProtected)\n    }\n}\n\n\n// class reflection information ----------------------------------------------\nstd::string Cppyy::GetFinalName(TCppType_t klass)\n{\n    if (klass == GLOBAL_HANDLE)\n        return \"\";\n    TClassRef& cr = type_from_handle(klass);\n    std::string clName = cr->GetName();\n// TODO: why is this template splitting needed?\n    std::string::size_type pos = clName.substr(0, clName.find('<')).rfind(\"::\");\n    if (pos != std::string::npos)\n        return clName.substr(pos+2, std::string::npos);\n    return clName;\n}\n\nstd::string Cppyy::GetScopedFinalName(TCppType_t klass)\n{\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass()) {\n        std::string name = cr->GetName();\n        if (is_missclassified_stl(name))\n            return std::string(\"std::\")+cr->GetName();\n        return cr->GetName();\n    }\n    return \"\";\n}\n\nbool Cppyy::HasComplexHierarchy(TCppType_t klass)\n{\n    int is_complex = 1;\n    size_t nbases = 0;\n\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass() && cr->GetListOfBases() != 0)\n        nbases = GetNumBases(klass);\n\n    if (1 < nbases)\n        is_complex = 1;\n    else if (nbases == 0)\n        is_complex = 0;\n    else {         // one base class only\n        TBaseClass* base = (TBaseClass*)cr->GetListOfBases()->At(0);\n        if (base->Property() & kIsVirtualBase)\n            is_complex = 1;       // TODO: verify; can be complex, need not be.\n        else\n            is_complex = HasComplexHierarchy(GetScope(base->GetName()));\n    }\n\n    return is_complex;\n}\n\nCppyy::TCppIndex_t Cppyy::GetNumBases(TCppType_t klass)\n{\n// Get the total number of base classes that this class has.\n    TClassRef& cr = type_from_handle(klass);\n    if (cr.GetClass() && cr->GetListOfBases() != 0)\n        return (TCppIndex_t)cr->GetListOfBases()->GetSize();\n    return (TCppIndex_t)0;\n}\n\nstd::string Cppyy::GetBaseName(TCppType_t klass, TCppIndex_t ibase)\n{\n    TClassRef& cr = type_from_handle(klass);\n    return ((TBaseClass*)cr->GetListOfBases()->At(ibase))->GetName();\n}\n\nbool Cppyy::IsSubtype(TCppType_t derived, TCppType_t base)\n{\n    if (derived == base)\n        return true;\n    TClassRef& derived_type = type_from_handle(derived);\n    TClassRef& base_type = type_from_handle(base);\n    return derived_type->GetBaseClass(base_type) != 0;\n}\n\nbool Cppyy::GetSmartPtrInfo(\n    const std::string& tname, TCppType_t& raw, TCppMethod_t& deref)\n{\n    const std::string& rn = ResolveName(tname);\n    if (gSmartPtrTypes.find(rn.substr(0, rn.find(\"<\"))) != gSmartPtrTypes.end()) {\n        TClassRef& cr = type_from_handle(GetScope(tname));\n        if (cr.GetClass()) {\n            gInterpreter->UpdateListOfMethods(cr.GetClass());\n            TFunction* func = nullptr;\n            TIter next(cr->GetListOfAllPublicMethods()); \n            while ((func = (TFunction*)next())) {\n                if (strstr(func->GetName(), \"operator->\")) {\n                    deref = (TCppMethod_t)new_CallWrapper(func);\n                    raw = GetScope(TClassEdit::ShortType(\n                        func->GetReturnTypeNormalizedName().c_str(), 1));\n                    return deref && raw;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid Cppyy::AddSmartPtrType(const std::string& type_name)\n{\n    gSmartPtrTypes.insert(ResolveName(type_name));\n}\n\n\n// type offsets --------------------------------------------------------------\nptrdiff_t Cppyy::GetBaseOffset(TCppType_t derived, TCppType_t base,\n    TCppObject_t address, int direction, bool rerror)\n{\n// calculate offsets between declared and actual type, up-cast: direction > 0; down-cast: direction < 0\n    if (derived == base || !(base && derived))\n        return (ptrdiff_t)0;\n\n    TClassRef& cd = type_from_handle(derived);\n    TClassRef& cb = type_from_handle(base);\n\n    if (!cd.GetClass() || !cb.GetClass())\n        return (ptrdiff_t)0;\n\n    ptrdiff_t offset = -1;\n    if (!(cd->GetClassInfo() && cb->GetClassInfo())) {     // gInterpreter requirement\n    // would like to warn, but can't quite determine error from intentional\n    // hiding by developers, so only cover the case where we really should have\n    // had a class info, but apparently don't:\n        if (cd->IsLoaded()) {\n        // warn to allow diagnostics\n            std::ostringstream msg;\n            msg << \"failed offset calculation between \" << cb->GetName() << \" and \" << cd->GetName();\n            // TODO: propagate this warning to caller w/o use of Python C-API\n            // PyErr_Warn(PyExc_RuntimeWarning, const_cast<char*>(msg.str().c_str()));\n            std::cerr << \"Warning: \" << msg.str() << '\\n';\n        }\n\n    // return -1 to signal caller NOT to apply offset\n        return rerror ? (ptrdiff_t)offset : 0;\n    }\n\n    offset = gInterpreter->ClassInfo_GetBaseOffset(\n        cd->GetClassInfo(), cb->GetClassInfo(), (void*)address, direction > 0);\n    if (offset == -1)   // Cling error, treat silently\n        return rerror ? (ptrdiff_t)offset : 0;\n\n    return (ptrdiff_t)(direction < 0 ? -offset : offset);\n}\n\n\n// method/function reflection information ------------------------------------\nCppyy::TCppIndex_t Cppyy::GetNumMethods(TCppScope_t scope)\n{\n    if (IsNamespace(scope))\n        return (TCppIndex_t)0;     // enforce lazy\n\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass() && cr->GetListOfMethods(true)) {\n        Cppyy::TCppIndex_t nMethods = (TCppIndex_t)cr->GetListOfMethods(false)->GetSize();\n        if (nMethods == (TCppIndex_t)0) {\n            std::string clName = GetScopedFinalName(scope);\n            if (clName.find('<') != std::string::npos) {\n            // chicken-and-egg problem: TClass does not know about methods until instantiation: force it\n                if (TClass::GetClass((\"std::\"+clName).c_str())) // TODO: this doesn't work for templates\n                    clName = \"std::\" + clName;\n                std::ostringstream stmt;\n                stmt << \"template class \" << clName << \";\";\n                gInterpreter->Declare(stmt.str().c_str());\n\n            // now reload the methods\n                return (TCppIndex_t)cr->GetListOfMethods(true)->GetSize();\n            }\n        }\n        return nMethods;\n    }\n\n    return (TCppIndex_t)0;         // unknown class?\n}\n\nstd::vector<Cppyy::TCppIndex_t> Cppyy::GetMethodIndicesFromName(\n    TCppScope_t scope, const std::string& name)\n{\n    std::vector<TCppIndex_t> indices;\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        gInterpreter->UpdateListOfMethods(cr.GetClass());\n        int imeth = 0;\n        TFunction* func = nullptr;\n        TIter next(cr->GetListOfMethods()); \n        while ((func = (TFunction*)next())) {\n            if (match_name(name, func->GetName())) {\n                if (func->Property() & kIsPublic)\n                    indices.push_back((TCppIndex_t)imeth);\n            }\n            ++imeth;\n        }\n    } else if (scope == GLOBAL_HANDLE) {\n        TCollection* funcs = gROOT->GetListOfGlobalFunctions(true);\n        \n    // tickle deserialization\n        if (!funcs->FindObject(name.c_str()))\n            return indices;\n\n        TFunction* func = nullptr;\n        TIter ifunc(funcs);\n        while ((func = (TFunction*)ifunc.Next())) {\n            if (match_name(name, func->GetName()))\n                indices.push_back((TCppIndex_t)new_CallWrapper(func));\n        }\n    }\n\n    return indices;\n}\n\nCppyy::TCppMethod_t Cppyy::GetMethod(TCppScope_t scope, TCppIndex_t imeth)\n{\n    TFunction* func = type_get_method(scope, imeth);\n    if (func)\n        return (Cppyy::TCppMethod_t)new_CallWrapper(func);\n    return (Cppyy::TCppMethod_t)nullptr;\n}\n\nstd::string Cppyy::GetMethodName(TCppMethod_t method)\n{\n    if (method) {\n        std::string name = m2f(method)->GetName();\n\n        if (name.compare(0, 8, \"operator\") != 0)\n        // strip template instantiation part, if any\n            return name.substr(0, name.find('<'));\n        return name;\n    }\n    return \"<unknown>\";\n}\n\nstd::string Cppyy::GetMethodMangledName(TCppMethod_t method)\n{\n    if (method)\n        return m2f(method)->GetMangledName();\n    return \"<unknown>\";\n}\n\nstd::string Cppyy::GetMethodResultType(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        if (f->ExtraProperty() & kIsConstructor)\n            return \"constructor\";\n        return f->GetReturnTypeNormalizedName();\n    }\n    return \"<unknown>\";\n}\n\nCppyy::TCppIndex_t Cppyy::GetMethodNumArgs(TCppMethod_t method)\n{\n    if (method)\n        return m2f(method)->GetNargs();\n    return 0;\n}\n\nCppyy::TCppIndex_t Cppyy::GetMethodReqArgs(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return (TCppIndex_t)(f->GetNargs() - f->GetNargsOpt());\n    }\n    return (TCppIndex_t)0;\n}\n\nstd::string Cppyy::GetMethodArgName(TCppMethod_t method, int iarg)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        TMethodArg* arg = (TMethodArg*)f->GetListOfMethodArgs()->At(iarg);\n        return arg->GetName();\n    }\n    return \"<unknown>\";\n}\n\nstd::string Cppyy::GetMethodArgType(TCppMethod_t method, int iarg)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        TMethodArg* arg = (TMethodArg*)f->GetListOfMethodArgs()->At(iarg);\n        return arg->GetTypeNormalizedName();\n    }\n    return \"<unknown>\";\n}\n\nstd::string Cppyy::GetMethodArgDefault(TCppMethod_t method, int iarg)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        TMethodArg* arg = (TMethodArg*)f->GetListOfMethodArgs()->At(iarg);\n        const char* def = arg->GetDefault();\n        if (def)\n            return def;\n    }\n\n    return \"\";\n}\n\nstd::string Cppyy::GetMethodSignature(TCppScope_t scope, TCppIndex_t imeth, bool show_formalargs)\n{\n    TFunction* f = type_get_method(scope, imeth);\n    if (f) {\n        std::ostringstream sig;\n        sig << \"(\";\n        int nArgs = f->GetNargs();\n        for (int iarg = 0; iarg < nArgs; ++iarg) {\n            TMethodArg* arg = (TMethodArg*)f->GetListOfMethodArgs()->At(iarg);\n            sig << arg->GetFullTypeName();\n            if (show_formalargs) {\n                const char* argname = arg->GetName();\n                if (argname && argname[0] != '\\0') sig << \" \" << argname;\n                const char* defvalue = arg->GetDefault();\n                if (defvalue && defvalue[0] != '\\0') sig << \" = \" << defvalue;\n            }\n            if (iarg != nArgs-1) sig << (show_formalargs ? \", \" : \",\");\n        }\n        sig << \")\";\n        return sig.str();\n    }\n    return \"<unknown>\";\n}\n\nstd::string Cppyy::GetMethodPrototype(TCppScope_t scope, TCppIndex_t imeth, bool show_formalargs)\n{\n    std::string scName = GetScopedFinalName(scope);\n    TFunction* f = type_get_method(scope, imeth);\n    if (f) {\n        std::ostringstream sig;\n        sig << f->GetReturnTypeName() << \" \"\n            << scName << \"::\" << f->GetName();\n        sig << GetMethodSignature(scope, imeth, show_formalargs);\n        return sig.str();\n    }\n    return \"<unknown>\";\n}\n\nbool Cppyy::IsConstMethod(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return f->Property() & kIsConstMethod;\n    }\n    return false;\n}\n\nbool Cppyy::ExistsMethodTemplate(TCppScope_t scope, const std::string& name)\n{\n    if (scope == (cppyy_scope_t)GLOBAL_HANDLE)\n        return (bool)gROOT->GetFunctionTemplate(name.c_str());\n    else {\n        TClassRef& cr = type_from_handle(scope);\n        if (cr.GetClass())\n            return (bool)cr->GetFunctionTemplate(name.c_str());\n    }\n\n// failure ...\n    return false;\n}\n\nbool Cppyy::IsMethodTemplate(TCppScope_t scope, TCppIndex_t imeth)\n{\n    TFunction* f = type_get_method(scope, imeth);\n    if (!f) return false;\n\n    if (scope == (Cppyy::TCppType_t)GLOBAL_HANDLE) {\n    // TODO: figure this one out ...\n        return false;\n    } else {\n        TClassRef& cr = type_from_handle(scope);\n        if (cr.GetClass()) {\n            return (bool)cr->GetFunctionTemplate(f->GetName());\n        }\n    }\n    return false;\n}\n\nCppyy::TCppIndex_t Cppyy::GetMethodNumTemplateArgs(\n    TCppScope_t scope, TCppIndex_t imeth)\n{\n// this is dumb, but the fact that Cling can instantiate template\n// methods on-the-fly means that there is some vast reworking TODO\n// in interp_cppyy.py, so this is just to make the original tests\n// pass that worked in the Reflex era ...\n    const std::string name = GetMethodName(GetMethod(scope, imeth));\n    return (TCppIndex_t)(std::count(name.begin(), name.end(), ',')+1);\n}\n\nstd::string Cppyy::GetMethodTemplateArgName(\n    TCppScope_t scope, TCppIndex_t imeth, TCppIndex_t /* iarg */)\n{\n// TODO: like above, given Cling's instantiation capability, this\n// is just dumb ...\n    TFunction* f = type_get_method(scope, imeth);\n    std::string name = f->GetName();\n    std::string::size_type pos = name.find('<');\n// TODO: left as-is, this should loop over arguments, but what is here\n// suffices to pass the Reflex-based tests (need more tests :))\n    return cppstring_to_cstring(\n        ResolveName(name.substr(pos+1, name.size()-pos-2)));\n}\n\nCppyy::TCppMethod_t Cppyy::GetMethodTemplate(\n    TCppScope_t scope, const std::string& name, const std::string& proto)\n{\n    TFunction* func = nullptr;\n    if (scope == (cppyy_scope_t)GLOBAL_HANDLE) {\n        func = gROOT->GetGlobalFunctionWithPrototype(name.c_str(), proto.c_str());\n    } else {\n        TClassRef& cr = type_from_handle(scope);\n        if (cr.GetClass())\n            func = cr->GetMethodWithPrototype(name.c_str(), proto.c_str());\n    }\n\n    if (func)\n        return (TCppMethod_t)new_CallWrapper(func);\n\n// failure ...\n    return (TCppMethod_t)nullptr;\n}\n\nCppyy::TCppIndex_t Cppyy::GetGlobalOperator(\n    TCppScope_t scope, TCppType_t lc, TCppType_t rc, const std::string& opname)\n{\n// Find a global operator function with a matching signature\n    std::string proto = GetScopedFinalName(lc) + \", \" + GetScopedFinalName(rc);\n    if (scope == (cppyy_scope_t)GLOBAL_HANDLE) {\n        TFunction* func = gROOT->GetGlobalFunctionWithPrototype(opname.c_str(), proto.c_str());\n        if (func) return (TCppIndex_t)new_CallWrapper(func);\n    } else {\n        TClassRef& cr = type_from_handle(scope);\n        if (cr.GetClass()) {\n            TFunction* func = cr->GetMethodWithPrototype(opname.c_str(), proto.c_str());\n            if (func) return (TCppIndex_t)cr->GetListOfMethods()->IndexOf(func);\n        }\n    }\n\n// failure ...\n    return (TCppIndex_t)-1;\n}\n\n// method properties ---------------------------------------------------------\nbool Cppyy::IsPublicMethod(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return f->Property() & kIsPublic;\n    }\n    return false;\n}\n\nbool Cppyy::IsConstructor(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return f->ExtraProperty() & kIsConstructor;\n    }\n    return false;\n}\n\nbool Cppyy::IsDestructor(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return f->ExtraProperty() & kIsDestructor;\n    }\n    return false;\n}\n\nbool Cppyy::IsStaticMethod(TCppMethod_t method)\n{\n    if (method) {\n        TFunction* f = m2f(method);\n        return f->Property() & kIsStatic;\n    }\n    return false;\n}\n\n// data member reflection information ----------------------------------------\nCppyy::TCppIndex_t Cppyy::GetNumDatamembers(TCppScope_t scope)\n{\n    if (IsNamespace(scope))\n        return (TCppIndex_t)0;     // enforce lazy\n\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass() && cr->GetListOfDataMembers())\n        return cr->GetListOfDataMembers()->GetSize();\n\n    return (TCppIndex_t)0;         // unknown class?\n}\n\nstd::string Cppyy::GetDatamemberName(TCppScope_t scope, TCppIndex_t idata)\n{\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n        return m->GetName();\n    }\n    assert(scope == GLOBAL_HANDLE);\n    TGlobal* gbl = g_globalvars[idata];\n    return gbl->GetName();\n}\n\nstd::string Cppyy::GetDatamemberType(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gbl = g_globalvars[idata];\n        std::string fullType = gbl->GetFullTypeName();\n        if (!strcmp(gbl->GetName(), \"gInterpreter\"))\n            return fullType;\n\n        if (fullType[fullType.size()-1] == '*' && \\\n              fullType.compare(0, 4, \"char\") != 0)\n            fullType.append(\"*\");\n        else if ((int)gbl->GetArrayDim() > 1)\n            fullType.append(\"*\");\n        else if ((int)gbl->GetArrayDim() == 1) {\n            std::ostringstream s;\n            s << '[' << gbl->GetMaxIndex(0) << ']' << std::ends;\n            fullType.append(s.str());\n        }\n        return fullType;\n    }\n\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass())  {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n        std::string fullType = m->GetTrueTypeName();\n        if ((int)m->GetArrayDim() > 1 || (!m->IsBasic() && m->IsaPointer()))\n            fullType.append(\"*\");\n        else if ((int)m->GetArrayDim() == 1) {\n            std::ostringstream s;\n            s << '[' << m->GetMaxIndex(0) << ']' << std::ends;\n            fullType.append(s.str());\n        }\n        return fullType;\n    }\n\n    return \"<unknown>\";\n}\n\nptrdiff_t Cppyy::GetDatamemberOffset(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gbl = g_globalvars[idata];\n        return (ptrdiff_t)gbl->GetAddress();\n    }\n\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n    // CLING WORKAROUND: the following causes templates to be instantiated first\n    // in the proper scope, making the lookup succeed and preventing spurious\n    // duplicate instantiations later.\n        if ((m->Property() & kIsStatic) && strchr(cr->GetName(), '<'))\n            gInterpreter->ProcessLine(((std::string)cr->GetName()+\"::\"+m->GetName()+\";\").c_str());\n        return (ptrdiff_t)m->GetOffsetCint();    // yes, CINT (GetOffset() is both wrong\n                                                 // and caches that wrong result!\n    }\n\n    return (ptrdiff_t)-1;\n}\n\nCppyy::TCppIndex_t Cppyy::GetDatamemberIndex(TCppScope_t scope, const std::string& name)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gb = (TGlobal*)gROOT->GetListOfGlobals(true)->FindObject(name.c_str());\n        if (gb && gb->GetAddress()) {\n            if (gb->GetAddress() == (void*)-1) {\n            // name known, but variable not in loaded by Cling yet ... force it\n            // TODO: figure out a less hackish way (problem is that the metaProcessor\n            // is hidden in TCling)\n                gInterpreter->ProcessLine((name+\";\").c_str());\n            }\n            if (gb->GetAddress() != (void*)-1) {\n                if (strcmp(gb->GetFullTypeName(), \"(lambda)\") == 0) {\n                // lambdas use a compiler internal closure type, so we wrap\n                // them, then return the wrapper's type\n                // TODO: this current leaks the std::function; also, if possible,\n                //       should instantiate through TClass rather then ProcessLine\n                    std::ostringstream s;\n                    s << \"auto __cppyy_internal_wrap_\" << name << \" = \"\n                        \"new __cppyy_internal::FT<decltype(\" << name << \")>::F\"\n                        \"{\" << name << \"};\";\n                    gInterpreter->ProcessLine(s.str().c_str());\n                    TGlobal* wrap = (TGlobal*)gROOT->GetListOfGlobals(true)->FindObject(\n                        (\"__cppyy_internal_wrap_\"+name).c_str());\n                    if (wrap && wrap->GetAddress()) gb = wrap;\n                }\n\n                g_globalvars.push_back(gb);\n                return g_globalvars.size() - 1;\n            }\n        }\n\n    } else {\n        TClassRef& cr = type_from_handle(scope);\n        if (cr.GetClass()) {\n            TDataMember* dm =\n                (TDataMember*)cr->GetListOfDataMembers()->FindObject(name.c_str());\n            // TODO: turning this into an index is silly ...\n            if (dm) return (TCppIndex_t)cr->GetListOfDataMembers()->IndexOf(dm);\n        }\n    }\n\n    return (TCppIndex_t)-1;\n}\n\n\n// data member properties ----------------------------------------------------\nbool Cppyy::IsPublicData(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE)\n        return true;\n    TClassRef& cr = type_from_handle(scope);\n    if (cr->Property() & kIsNamespace)\n        return true;\n    TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n    return m->Property() & kIsPublic;\n}\n\nbool Cppyy::IsStaticData(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE)\n        return true;\n    TClassRef& cr = type_from_handle(scope);\n    if (cr->Property() & kIsNamespace)\n        return true;\n    TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n    return m->Property() & kIsStatic;\n}\n\nbool Cppyy::IsConstData(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gbl = g_globalvars[idata];\n        return gbl->Property() & kIsConstant;\n    }\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n        return m->Property() & kIsConstant;\n    }\n    return false;\n}\n\nbool Cppyy::IsEnumData(TCppScope_t scope, TCppIndex_t idata)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gbl = g_globalvars[idata];\n        return gbl->Property() & kIsEnum;\n    }\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n        return m->Property() & kIsEnum;\n    }\n    return false;\n}\n\nint Cppyy::GetDimensionSize(TCppScope_t scope, TCppIndex_t idata, int dimension)\n{\n    if (scope == GLOBAL_HANDLE) {\n        TGlobal* gbl = g_globalvars[idata];\n        return gbl->GetMaxIndex(dimension);\n    }\n    TClassRef& cr = type_from_handle(scope);\n    if (cr.GetClass()) {\n        TDataMember* m = (TDataMember*)cr->GetListOfDataMembers()->At(idata);\n        return m->GetMaxIndex(dimension);\n    }\n    return -1;\n}\n\n\n//- C-linkage wrappers -------------------------------------------------------\nstatic inline\nstd::vector<Parameter> vsargs_to_parvec(void* args, int nargs)\n{\n    std::vector<Parameter> v;\n    v.reserve(nargs);\n    for (int i=0; i<nargs; ++i)\n        v.push_back(((Parameter*)args)[i]);\n    return v;\n}\n\nextern \"C\" {\n/* name to opaque C++ scope representation -------------------------------- */\nchar* cppyy_resolve_name(const char* cppitem_name) {\n    return cppstring_to_cstring(Cppyy::ResolveName(cppitem_name));\n}\n\nchar* cppyy_resolve_enum(const char* enum_type) {\n    return cppstring_to_cstring(Cppyy::ResolveEnum(enum_type));\n}\n\ncppyy_scope_t cppyy_get_scope(const char* scope_name) {\n    return cppyy_scope_t(Cppyy::GetScope(scope_name));\n}\n\ncppyy_type_t cppyy_actual_class(cppyy_type_t klass, cppyy_object_t obj) {\n    return cppyy_type_t(Cppyy::GetActualClass(klass, (void*)obj));\n}\n\nsize_t cppyy_size_of_klass(cppyy_type_t klass) {\n    return Cppyy::SizeOf(klass);\n}\n\nsize_t cppyy_size_of_type(const char* type_name) {\n    return Cppyy::SizeOf(type_name);\n}\n\n\n/* memory management ------------------------------------------------------ */\ncppyy_object_t cppyy_allocate(cppyy_type_t type) {\n    return cppyy_object_t(Cppyy::Allocate(type));\n}\n\nvoid cppyy_deallocate(cppyy_type_t type, cppyy_object_t self) {\n    Cppyy::Deallocate(type, (void*)self);\n}\n\ncppyy_object_t cppyy_construct(cppyy_type_t type) {\n    return (cppyy_object_t)Cppyy::Construct(type);\n}\n\nvoid cppyy_destruct(cppyy_type_t type, cppyy_object_t self) {\n    Cppyy::Destruct(type, (void*)self);\n}\n\n\n/* method/function dispatching -------------------------------------------- */\n/* Exception types:\n    1: default (unknown exception)\n    2: standard exception\n*/\n#define CPPYY_HANDLE_EXCEPTION                                               \\\n    catch (std::exception& e) {                                              \\\n        cppyy_exctype_t* etype = (cppyy_exctype_t*)((Parameter*)args+nargs); \\\n        *etype = (cppyy_exctype_t)2;                                         \\\n        *((char**)(etype+1)) = cppstring_to_cstring(e.what());               \\\n    }                                                                        \\\n    catch (...) {                                                            \\\n        cppyy_exctype_t* etype = (cppyy_exctype_t*)((Parameter*)args+nargs); \\\n        *etype = (cppyy_exctype_t)1;                                         \\\n        *((char**)(etype+1)) =                                               \\\n            cppstring_to_cstring(\"unhandled, unknown C++ exception\");        \\\n    }\n\nvoid cppyy_call_v(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        Cppyy::CallV(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n}\n\nunsigned char cppyy_call_b(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (unsigned char)Cppyy::CallB(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (unsigned char)-1;\n}\n\nchar cppyy_call_c(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (char)Cppyy::CallC(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (char)-1;\n}\n\nshort cppyy_call_h(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (short)Cppyy::CallH(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (short)-1;\n}\n\nint cppyy_call_i(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (int)Cppyy::CallI(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (int)-1;\n}\n\nlong cppyy_call_l(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (long)Cppyy::CallL(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (long)-1;\n}\n\nlong long cppyy_call_ll(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (long long)Cppyy::CallLL(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (long long)-1;\n}\n\nfloat cppyy_call_f(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (float)Cppyy::CallF(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (float)-1;\n}\n\ndouble cppyy_call_d(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (double)Cppyy::CallD(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (double)-1;\n}\n\nlong double cppyy_call_ld(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (long double)Cppyy::CallLD(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (long double)-1;\n}\n\nvoid* cppyy_call_r(cppyy_method_t method, cppyy_object_t self, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return (void*)Cppyy::CallR(method, (void*)self, &parvec);\n    } CPPYY_HANDLE_EXCEPTION\n    return (void*)nullptr;\n}\n\nchar* cppyy_call_s(\n        cppyy_method_t method, cppyy_object_t self, int nargs, void* args, size_t* lsz) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return Cppyy::CallS(method, (void*)self, &parvec, lsz);\n    } CPPYY_HANDLE_EXCEPTION\n    return (char*)nullptr;\n}\n\ncppyy_object_t cppyy_constructor(\n        cppyy_method_t method, cppyy_type_t klass, int nargs, void* args) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return cppyy_object_t(Cppyy::CallConstructor(method, klass, &parvec));\n    } CPPYY_HANDLE_EXCEPTION\n    return (cppyy_object_t)0;\n}\n\nvoid cppyy_destructor(cppyy_type_t klass, cppyy_object_t self) {\n    Cppyy::CallDestructor(klass, self);\n}\n\ncppyy_object_t cppyy_call_o(cppyy_method_t method, cppyy_object_t self,\n        int nargs, void* args, cppyy_type_t result_type) {\n    try {\n        std::vector<Parameter> parvec = vsargs_to_parvec(args, nargs);\n        return cppyy_object_t(Cppyy::CallO(method, (void*)self, &parvec, result_type));\n    } CPPYY_HANDLE_EXCEPTION\n    return (cppyy_object_t)0;\n}\n\ncppyy_funcaddr_t cppyy_function_address_from_index(cppyy_scope_t scope, cppyy_index_t idx) {\n    return cppyy_funcaddr_t(Cppyy::GetFunctionAddress(scope, idx));\n}\n\ncppyy_funcaddr_t cppyy_function_address_from_method(cppyy_method_t method) {\n    return cppyy_funcaddr_t(Cppyy::GetFunctionAddress(method));\n}\n\n\n/* handling of function argument buffer ----------------------------------- */\nvoid* cppyy_allocate_function_args(int nargs) {\n// for calls through C interface, require extra space for reporting exceptions\n    return malloc(nargs*sizeof(Parameter)+sizeof(cppyy_exctype_t)+sizeof(char**));\n}\n\nvoid cppyy_deallocate_function_args(void* args) {\n    free(args);\n}\n\nsize_t cppyy_function_arg_sizeof() {\n    return (size_t)Cppyy::GetFunctionArgSizeof();\n}\n\nsize_t cppyy_function_arg_typeoffset() {\n    return (size_t)Cppyy::GetFunctionArgTypeoffset();\n}\n\n\n/* scope reflection information ------------------------------------------- */\nint cppyy_is_namespace(cppyy_scope_t scope) {\n    return (int)Cppyy::IsNamespace(scope);\n}\n\nint cppyy_is_template(const char* template_name) {\n    return (int)Cppyy::IsTemplate(template_name);\n}\n\nint cppyy_is_abstract(cppyy_type_t type) {\n    return (int)Cppyy::IsAbstract(type);\n}\n\nint cppyy_is_enum(const char* type_name) {\n    return (int)Cppyy::IsEnum(type_name);\n}\n\nconst char** cppyy_get_all_cpp_names(cppyy_scope_t scope, size_t* count) {\n    std::set<std::string> cppnames;\n    Cppyy::GetAllCppNames(scope, cppnames);\n    const char** c_cppnames = (const char**)malloc(cppnames.size()*sizeof(const char*));\n    int i = 0;\n    for (const auto& name : cppnames) {\n        c_cppnames[i] = cppstring_to_cstring(name);\n        ++i;\n    }\n    *count = cppnames.size();\n    return c_cppnames;\n}\n\n\n/* class reflection information ------------------------------------------- */\nchar* cppyy_final_name(cppyy_type_t type) {\n    return cppstring_to_cstring(Cppyy::GetFinalName(type));\n}\n\nchar* cppyy_scoped_final_name(cppyy_type_t type) {\n    return cppstring_to_cstring(Cppyy::GetScopedFinalName(type));\n}\n\nint cppyy_has_complex_hierarchy(cppyy_type_t type) {\n    return (int)Cppyy::HasComplexHierarchy(type);\n}\n\nint cppyy_num_bases(cppyy_type_t type) {\n    return (int)Cppyy::GetNumBases(type);\n}\n\nchar* cppyy_base_name(cppyy_type_t type, int base_index) {\n    return cppstring_to_cstring(Cppyy::GetBaseName (type, base_index));\n}\n\nint cppyy_is_subtype(cppyy_type_t derived, cppyy_type_t base) {\n    return (int)Cppyy::IsSubtype(derived, base);\n}\n\nint cppyy_smartptr_info(const char* name, cppyy_type_t* raw, cppyy_method_t* deref) {\n    Cppyy::TCppScope_t r2 = *raw;\n    Cppyy::TCppMethod_t d2 = *deref;\n    int result = (int)Cppyy::GetSmartPtrInfo(name, r2, d2);\n    *raw = r2; *deref = d2;\n    return result;\n}\n\nvoid cppyy_add_smartptr_type(const char* type_name) {\n    Cppyy::AddSmartPtrType(type_name);\n}\n\n\n/* calculate offsets between declared and actual type, up-cast: direction > 0; down-cast: direction < 0 */\nptrdiff_t cppyy_base_offset(cppyy_type_t derived, cppyy_type_t base, cppyy_object_t address, int direction) {\n    return (ptrdiff_t)Cppyy::GetBaseOffset(derived, base, (void*)address, direction, 0);\n}\n\n\n/* method/function reflection information --------------------------------- */\nint cppyy_num_methods(cppyy_scope_t scope) {\n    return (int)Cppyy::GetNumMethods(scope);\n}\n\ncppyy_index_t* cppyy_method_indices_from_name(cppyy_scope_t scope, const char* name)\n{\n    std::vector<cppyy_index_t> result = Cppyy::GetMethodIndicesFromName(scope, name);\n\n    if (result.empty())\n        return (cppyy_index_t*)nullptr;\n\n    cppyy_index_t* llresult = (cppyy_index_t*)malloc(sizeof(cppyy_index_t)*(result.size()+1));\n    for (int i = 0; i < (int)result.size(); ++i) llresult[i] = result[i];\n    llresult[result.size()] = -1;\n    return llresult;\n}\n\nchar* cppyy_method_name(cppyy_scope_t scope, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return cppstring_to_cstring(Cppyy::GetMethodName((Cppyy::TCppMethod_t)&wrap));\n}\n\nchar* cppyy_method_mangled_name(cppyy_scope_t scope, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return cppstring_to_cstring(Cppyy::GetMethodMangledName((Cppyy::TCppMethod_t)&wrap));\n}\n\nchar* cppyy_method_result_type(cppyy_scope_t scope, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return cppstring_to_cstring(Cppyy::GetMethodResultType((Cppyy::TCppMethod_t)&wrap));\n}\n\nint cppyy_method_num_args(cppyy_scope_t scope, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return (int)Cppyy::GetMethodNumArgs((Cppyy::TCppMethod_t)&wrap);\n}\n\nint cppyy_method_req_args(cppyy_scope_t scope, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return (int)Cppyy::GetMethodReqArgs((Cppyy::TCppMethod_t)&wrap);\n}\n\nchar* cppyy_method_arg_type(cppyy_scope_t scope, cppyy_index_t idx, int arg_index) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return cppstring_to_cstring(Cppyy::GetMethodArgType((Cppyy::TCppMethod_t)&wrap, arg_index));\n}\n\nchar* cppyy_method_arg_default(cppyy_scope_t scope, cppyy_index_t idx, int arg_index) {\n    CallWrapper wrap{type_get_method(scope, idx)};\n    return cppstring_to_cstring(Cppyy::GetMethodArgDefault((Cppyy::TCppMethod_t)&wrap, arg_index));\n}\n\nchar* cppyy_method_signature(cppyy_scope_t scope, cppyy_index_t idx, int show_formalargs) {\n    return cppstring_to_cstring(Cppyy::GetMethodSignature(scope, idx, (bool)show_formalargs));\n}\n\nchar* cppyy_method_prototype(cppyy_scope_t scope, cppyy_index_t idx, int show_formalargs) {\n    return cppstring_to_cstring(Cppyy::GetMethodPrototype(scope, idx, (bool)show_formalargs));\n}\n\nint cppyy_is_const_method(cppyy_method_t method) {\n    return (int)Cppyy::IsConstMethod(method);\n}\n\nint cppyy_exists_method_template(cppyy_scope_t scope, const char* name) {\n    return (int)Cppyy::ExistsMethodTemplate(scope, name);\n}\n\nint cppyy_method_is_template(cppyy_scope_t scope, cppyy_index_t idx) {\n    return (int)Cppyy::IsMethodTemplate(scope, idx);\n}\n\nint cppyy_method_num_template_args(cppyy_scope_t scope, cppyy_index_t idx) {\n    return (int)Cppyy::GetMethodNumTemplateArgs(scope, idx);\n}\n\nchar* cppyy_method_template_arg_name(cppyy_scope_t scope, cppyy_index_t idx, cppyy_index_t iarg) {\n    return cppstring_to_cstring(Cppyy::GetMethodTemplateArgName(scope, idx, iarg));\n}\n\ncppyy_method_t cppyy_get_method(cppyy_scope_t scope, cppyy_index_t idx) {\n    return cppyy_method_t(Cppyy::GetMethod(scope, idx));\n}\n\ncppyy_index_t cppyy_get_global_operator(cppyy_scope_t scope, cppyy_scope_t lc, cppyy_scope_t rc, const char* op) {\n    return cppyy_index_t(Cppyy::GetGlobalOperator(scope, lc, rc, op));\n}\n\n\n/* method properties ------------------------------------------------------ */\nint cppyy_is_publicmethod(cppyy_type_t type, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(type, idx)};\n    return (int)Cppyy::IsPublicMethod((Cppyy::TCppMethod_t)&wrap);\n}\n\nint cppyy_is_constructor(cppyy_type_t type, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(type, idx)};\n    return (int)Cppyy::IsConstructor((Cppyy::TCppMethod_t)&wrap);\n}\n\nint cppyy_is_destructor(cppyy_type_t type, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(type, idx)};\n    return (int)Cppyy::IsDestructor((Cppyy::TCppMethod_t)&wrap);\n}\n\nint cppyy_is_staticmethod(cppyy_type_t type, cppyy_index_t idx) {\n    CallWrapper wrap{type_get_method(type, idx)};\n    return (int)Cppyy::IsStaticMethod((Cppyy::TCppMethod_t)&wrap);\n}\n\n\n/* data member reflection information ------------------------------------- */\nint cppyy_num_datamembers(cppyy_scope_t scope) {\n    return (int)Cppyy::GetNumDatamembers(scope);\n}\n\nchar* cppyy_datamember_name(cppyy_scope_t scope, int datamember_index) {\n    return cppstring_to_cstring(Cppyy::GetDatamemberName(scope, datamember_index));\n}\n\nchar* cppyy_datamember_type(cppyy_scope_t scope, int datamember_index) {\n    return cppstring_to_cstring(Cppyy::GetDatamemberType(scope, datamember_index));\n}\n\nptrdiff_t cppyy_datamember_offset(cppyy_scope_t scope, int datamember_index) {\n    return ptrdiff_t(Cppyy::GetDatamemberOffset(scope, datamember_index));\n}\n\nint cppyy_datamember_index(cppyy_scope_t scope, const char* name) {\n    return (int)Cppyy::GetDatamemberIndex(scope, name);\n}\n\n\n\n/* data member properties ------------------------------------------------- */\nint cppyy_is_publicdata(cppyy_type_t type, cppyy_index_t datamember_index) {\n    return (int)Cppyy::IsPublicData(type, datamember_index);\n}\n\nint cppyy_is_staticdata(cppyy_type_t type, cppyy_index_t datamember_index) {\n    return (int)Cppyy::IsStaticData(type, datamember_index);\n}\n\nint cppyy_is_const_data(cppyy_scope_t scope, cppyy_index_t idata) {\n    return (int)Cppyy::IsConstData(scope, idata);\n}\n\nint cppyy_is_enum_data(cppyy_scope_t scope, cppyy_index_t idata) {\n    return (int)Cppyy::IsEnumData(scope, idata);\n}\n\nint cppyy_get_dimension_size(cppyy_scope_t scope, cppyy_index_t idata, int dimension) {\n    return Cppyy::GetDimensionSize(scope, idata, dimension);\n}\n\n\n/* misc helpers ----------------------------------------------------------- */\nRPY_EXTERN\nvoid* cppyy_load_dictionary(const char* lib_name) {\n    int result = gSystem->Load(lib_name);\n    return (void*)(result == 0 /* success */ || result == 1 /* already loaded */);\n}\n\n#if defined(_MSC_VER)\nlong long cppyy_strtoll(const char* str) {\n    return _strtoi64(str, NULL, 0);\n}\n\nextern \"C\" {\nunsigned long long cppyy_strtoull(const char* str) {\n    return _strtoui64(str, NULL, 0);\n}\n}\n#else\nlong long cppyy_strtoll(const char* str) {\n    return strtoll(str, NULL, 0);\n}\n\nextern \"C\" {\nunsigned long long cppyy_strtoull(const char* str) {\n    return strtoull(str, NULL, 0);\n}\n}\n#endif\n\nvoid cppyy_free(void* ptr) {\n    free(ptr);\n}\n\ncppyy_object_t cppyy_charp2stdstring(const char* str, size_t sz) {\n    return (cppyy_object_t)new std::string(str, sz);\n}\n\nconst char* cppyy_stdstring2charp(cppyy_object_t ptr, size_t* lsz) {\n    *lsz = ((std::string*)ptr)->size();\n    return ((std::string*)ptr)->data();\n}\n\ncppyy_object_t cppyy_stdstring2stdstring(cppyy_object_t ptr) {\n    return (cppyy_object_t)new std::string(*(std::string*)ptr);\n}\n\nconst char* cppyy_stdvector_valuetype(const char* clname)\n{\n    const char* result = nullptr;\n    std::string name = clname;\n    TypedefInfo_t* ti = gInterpreter->TypedefInfo_Factory((name+\"::value_type\").c_str());\n    if (gInterpreter->TypedefInfo_IsValid(ti))\n        result = cppstring_to_cstring(gInterpreter->TypedefInfo_TrueName(ti));\n    gInterpreter->TypedefInfo_Delete(ti);\n    return result;\n}\n\nsize_t cppyy_stdvector_valuesize(const char* clname)\n{\n    size_t result = 0;\n    std::string name = clname;\n    TypedefInfo_t* ti = gInterpreter->TypedefInfo_Factory((name+\"::value_type\").c_str());\n    if (gInterpreter->TypedefInfo_IsValid(ti))\n       result = (size_t)gInterpreter->TypedefInfo_Size(ti);\n    gInterpreter->TypedefInfo_Delete(ti);\n    return result;\n}\n   \n} // end C-linkage wrappers\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/meta/src/TClass.cxx": "// @(#)root/meta:$Id: 7109cb45f1219c2aae6be19906ae5a63e31972ef $\n// Author: Rene Brun   07/01/95\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n/** \\class TClass\nThe ROOT global object gROOT contains a list of all defined\nclasses. This list is build when a reference to a class dictionary\nis made. When this happens, the static \"class\"::Dictionary()\nfunction is called to create a TClass object describing the\nclass. The Dictionary() function is defined in the ClassDef\nmacro and stored (at program startup or library load time) together\nwith the class name in the TClassTable singleton object.\nFor a description of all dictionary classes see TDictionary.\n\nThe name of the class as registered in the TClass object and in the\nlist of class is the \"normalized name\" and is defined as:\n\nThe name of the type as accessible from the global scope to which\na 'using namespace std;' has been applied to and with:\n   - all typedefs disagreed except for Double32_t, Float16_t,\n     Long64_t, ULong64_t and std::string.\n   - default template parameters removed for STL collections and\n     added for any other class templates instances.\n   - Fully qualified both for the class name itself and all of its\n     component, except that, at least for moment, all 'std::' are\n     stripped.\n*/\n\n//*-*x7.5 macros/layout_class\n\n#include \"TClass.h\"\n\n#include \"Riostream.h\"\n#include \"TBaseClass.h\"\n#include \"TBrowser.h\"\n#include \"TBuffer.h\"\n#include \"TClassGenerator.h\"\n#include \"TClassEdit.h\"\n#include \"TClassMenuItem.h\"\n#include \"TClassRef.h\"\n#include \"TClassTable.h\"\n#include \"TDataMember.h\"\n#include \"TDataType.h\"\n#include \"TEnum.h\"\n#include \"TError.h\"\n#include \"TExMap.h\"\n#include \"TFunctionTemplate.h\"\n#include \"THashList.h\"\n#include \"TInterpreter.h\"\n#include \"TMemberInspector.h\"\n#include \"TMethod.h\"\n#include \"TMethodArg.h\"\n#include \"TMethodCall.h\"\n#include \"TObjArray.h\"\n#include \"TProtoClass.h\"\n#include \"TROOT.h\"\n#include \"TRealData.h\"\n#include \"TCheckHashRecursiveRemoveConsistency.h\" // Private header\n#include \"TStreamer.h\"\n#include \"TStreamerElement.h\"\n#include \"TVirtualStreamerInfo.h\"\n#include \"TVirtualCollectionProxy.h\"\n#include \"TVirtualIsAProxy.h\"\n#include \"TVirtualRefProxy.h\"\n#include \"TVirtualMutex.h\"\n#include \"TVirtualPad.h\"\n#include \"THashTable.h\"\n#include \"TSchemaRuleSet.h\"\n#include \"TGenericClassInfo.h\"\n#include \"TIsAProxy.h\"\n#include \"TSchemaRule.h\"\n#include \"TSystem.h\"\n#include \"TThreadSlots.h\"\n\n#include <cstdio>\n#include <cctype>\n#include <set>\n#include <sstream>\n#include <string>\n#include <map>\n#include <typeinfo>\n#include <cmath>\n#include <assert.h>\n#include <vector>\n#include <memory>\n\n#include \"TSpinLockGuard.h\"\n\n#ifdef WIN32\n#include <io.h>\n#include \"Windows4Root.h\"\n#include <Psapi.h>\n#define RTLD_DEFAULT ((void *)::GetModuleHandle(NULL))\n#define dlsym(library, function_name) ::GetProcAddress((HMODULE)library, function_name)\n#else\n#include <dlfcn.h>\n#endif\n\n#include \"TListOfDataMembers.h\"\n#include \"TListOfFunctions.h\"\n#include \"TListOfFunctionTemplates.h\"\n#include \"TListOfEnums.h\"\n#include \"TListOfEnumsWithLock.h\"\n#include \"TViewPubDataMembers.h\"\n#include \"TViewPubFunctions.h\"\n#include \"TArray.h\"\n#include \"TClonesArray.h\"\n#include \"TRef.h\"\n#include \"TRefArray.h\"\n\nusing namespace std;\n\n// Mutex to protect CINT and META operations\n// (exported to be used for similar cases in related classes)\n\nTVirtualMutex* gInterpreterMutex = 0;\n\nnamespace {\n   class TMmallocDescTemp {\n   private:\n      void *fSave;\n   public:\n      TMmallocDescTemp(void *value = 0) :\n         fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }\n      ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }\n   };\n}\n\nstd::atomic<Int_t> TClass::fgClassCount;\n\n// Implementation of the TDeclNameRegistry\n\n////////////////////////////////////////////////////////////////////////////////\n/// TDeclNameRegistry class constructor.\n\nTClass::TDeclNameRegistry::TDeclNameRegistry(Int_t verbLevel): fVerbLevel(verbLevel)\n{\n   // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition\n   std::atomic_flag_clear( &fSpinLock );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Extract this part of the name\n/// 1. Templates ns::ns2::,,,::THISPART<...\n/// 2. Namespaces,classes ns::ns2::,,,::THISPART\n\nvoid TClass::TDeclNameRegistry::AddQualifiedName(const char *name)\n{\n   // Sanity check\n   auto strLen = strlen(name);\n   if (strLen == 0) return;\n   // find <. If none, put end of string\n   const char* endCharPtr = strchr(name, '<');\n   endCharPtr = !endCharPtr ? &name[strLen] : endCharPtr;\n   // find last : before the <. If not found, put begin of string\n   const char* beginCharPtr = endCharPtr;\n   while (beginCharPtr!=name){\n      if (*beginCharPtr==':'){\n         beginCharPtr++;\n         break;\n      }\n      beginCharPtr--;\n   }\n   beginCharPtr = beginCharPtr!=endCharPtr ? beginCharPtr : name;\n   std::string s(beginCharPtr, endCharPtr);\n   if (fVerbLevel>1)\n      printf(\"TDeclNameRegistry::AddQualifiedName Adding key %s for class/namespace %s\\n\", s.c_str(), name);\n   ROOT::Internal::TSpinLockGuard slg(fSpinLock);\n   fClassNamesSet.insert(s);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TClass::TDeclNameRegistry::HasDeclName(const char *name) const\n{\n   Bool_t found = false;\n   {\n      ROOT::Internal::TSpinLockGuard slg(fSpinLock);\n      found = fClassNamesSet.find(name) != fClassNamesSet.end();\n   }\n   return found;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTClass::TDeclNameRegistry::~TDeclNameRegistry()\n{\n   if (fVerbLevel > 1) {\n      printf(\"TDeclNameRegistry Destructor. List of %lu names:\\n\",\n             (long unsigned int)fClassNamesSet.size());\n      for (auto const & key: fClassNamesSet) {\n         printf(\" - %s\\n\", key.c_str());\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTClass::InsertTClassInRegistryRAII::InsertTClassInRegistryRAII(TClass::EState &state,\n                                   const char *name,\n                                   TDeclNameRegistry &emuRegistry): fState(state),fName(name), fNoInfoOrEmuOrFwdDeclNameRegistry(emuRegistry) {}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTClass::InsertTClassInRegistryRAII::~InsertTClassInRegistryRAII() {\n   if (fState == TClass::kNoInfo ||\n       fState == TClass::kEmulated ||\n       fState == TClass::kForwardDeclared){\n      fNoInfoOrEmuOrFwdDeclNameRegistry.AddQualifiedName(fName);\n      }\n   }\n\n// Initialise the global member of TClass\nTClass::TDeclNameRegistry TClass::fNoInfoOrEmuOrFwdDeclNameRegistry;\n\n//Intent of why/how TClass::New() is called\n//[Not a static data member because MacOS does not support static thread local data member ... who knows why]\nTClass::ENewType &TClass__GetCallingNew() {\n   TTHREAD_TLS(TClass::ENewType) fgCallingNew = TClass::kRealNew;\n   return fgCallingNew;\n}\n\nstruct ObjRepoValue {\n   ObjRepoValue(const TClass *what, Version_t version) : fClass(what),fVersion(version) {}\n   const TClass *fClass;\n   Version_t     fVersion;\n};\n\nstatic TVirtualMutex* gOVRMutex = 0;\ntypedef std::multimap<void*, ObjRepoValue> RepoCont_t;\nstatic RepoCont_t gObjectVersionRepository;\n\nstatic void RegisterAddressInRepository(const char * /*where*/, void *location, const TClass *what)\n{\n   // Register the object for special handling in the destructor.\n\n   Version_t version = what->GetClassVersion();\n//    if (!gObjectVersionRepository.count(location)) {\n//       Info(where, \"Registering address %p of class '%s' version %d\", location, what->GetName(), version);\n//    } else {\n//       Warning(where, \"Registering address %p again of class '%s' version %d\", location, what->GetName(), version);\n//    }\n   {\n      R__LOCKGUARD2(gOVRMutex);\n      gObjectVersionRepository.insert(RepoCont_t::value_type(location, RepoCont_t::mapped_type(what,version)));\n   }\n#if 0\n   // This code could be used to prevent an address to be registered twice.\n   std::pair<RepoCont_t::iterator, Bool_t> tmp = gObjectVersionRepository.insert(RepoCont_t::value_type>(location, RepoCont_t::mapped_type(what,version)));\n   if (!tmp.second) {\n      Warning(where, \"Reregistering an object of class '%s' version %d at address %p\", what->GetName(), version, p);\n      gObjectVersionRepository.erase(tmp.first);\n      tmp = gObjectVersionRepository.insert(RepoCont_t::value_type>(location, RepoCont_t::mapped_type(what,version)));\n      if (!tmp.second) {\n         Warning(where, \"Failed to reregister an object of class '%s' version %d at address %p\", what->GetName(), version, location);\n      }\n   }\n#endif\n}\n\nstatic void UnregisterAddressInRepository(const char * /*where*/, void *location, const TClass *what)\n{\n   // Remove an address from the repository of address/object.\n\n   R__LOCKGUARD2(gOVRMutex);\n   RepoCont_t::iterator cur = gObjectVersionRepository.find(location);\n   for (; cur != gObjectVersionRepository.end();) {\n      RepoCont_t::iterator tmp = cur++;\n      if ((tmp->first == location) && (tmp->second.fVersion == what->GetClassVersion())) {\n         // -- We still have an address, version match.\n         // Info(where, \"Unregistering address %p of class '%s' version %d\", location, what->GetName(), what->GetClassVersion());\n         gObjectVersionRepository.erase(tmp);\n      } else {\n         // -- No address, version match, we've reached the end.\n         break;\n      }\n   }\n}\n\nstatic void MoveAddressInRepository(const char * /*where*/, void *oldadd, void *newadd, const TClass *what)\n{\n   // Register in the repository that an object has moved.\n\n   // Move not only the object itself but also any base classes or sub-objects.\n   size_t objsize = what->Size();\n   long delta = (char*)newadd - (char*)oldadd;\n   R__LOCKGUARD2(gOVRMutex);\n   RepoCont_t::iterator cur = gObjectVersionRepository.find(oldadd);\n   for (; cur != gObjectVersionRepository.end();) {\n      RepoCont_t::iterator tmp = cur++;\n      if (oldadd <= tmp->first && tmp->first < ( ((char*)oldadd) + objsize) ) {\n         // The location is within the object, let's move it.\n\n         gObjectVersionRepository.insert(RepoCont_t::value_type(((char*)tmp->first)+delta, RepoCont_t::mapped_type(tmp->second.fClass,tmp->second.fVersion)));\n         gObjectVersionRepository.erase(tmp);\n\n      } else {\n         // -- No address, version match, we've reached the end.\n         break;\n      }\n   }\n}\n\n//______________________________________________________________________________\n//______________________________________________________________________________\nnamespace ROOT {\n#define R__USE_STD_MAP\n   class TMapTypeToTClass {\n#if defined R__USE_STD_MAP\n     // This wrapper class allow to avoid putting #include <map> in the\n     // TROOT.h header file.\n   public:\n      typedef std::map<std::string,TClass*>       IdMap_t;\n      typedef IdMap_t::key_type                   key_type;\n      typedef IdMap_t::const_iterator             const_iterator;\n      typedef IdMap_t::size_type                  size_type;\n#ifdef R__WIN32\n     // Window's std::map does NOT defined mapped_type\n      typedef TClass*                             mapped_type;\n#else\n      typedef IdMap_t::mapped_type                mapped_type;\n#endif\n\n   private:\n      IdMap_t fMap;\n\n   public:\n      void Add(const key_type &key, mapped_type &obj)\n      {\n         // Add the <key,obj> pair to the map.\n         fMap[key] = obj;\n      }\n      mapped_type Find(const key_type &key) const\n      {\n         // Find the type corresponding to the key.\n         IdMap_t::const_iterator iter = fMap.find(key);\n         mapped_type cl = 0;\n         if (iter != fMap.end()) cl = iter->second;\n         return cl;\n      }\n      void Remove(const key_type &key) {\n         // Remove the type corresponding to the key.\n         fMap.erase(key);\n      }\n#else\n   private:\n      TMap fMap;\n\n   public:\n#ifdef R__COMPLETE_MEM_TERMINATION\n      TMapTypeToTClass() {\n         TIter next(&fMap);\n         TObjString *key;\n         while((key = (TObjString*)next())) {\n            delete key;\n         }\n      }\n#endif\n      void Add(const char *key, TClass *&obj) {\n         TObjString *realkey = new TObjString(key);\n         fMap.Add(realkey, obj);\n      }\n      TClass* Find(const char *key) const {\n         const TPair *a = (const TPair *)fMap.FindObject(key);\n         if (a) return (TClass*) a->Value();\n         return 0;\n      }\n      void Remove(const char *key) {\n         TObjString realkey(key);\n         TObject *actual = fMap.Remove(&realkey);\n         delete actual;\n      }\n#endif\n   };\n\n   class TMapDeclIdToTClass {\n   // Wrapper class for the multimap of DeclId_t and TClass.\n   public:\n      typedef multimap<TDictionary::DeclId_t, TClass*>   DeclIdMap_t;\n      typedef DeclIdMap_t::key_type                      key_type;\n      typedef DeclIdMap_t::mapped_type                   mapped_type;\n      typedef DeclIdMap_t::const_iterator                const_iterator;\n      typedef std::pair <const_iterator, const_iterator> equal_range;\n      typedef DeclIdMap_t::size_type                     size_type;\n\n   private:\n      DeclIdMap_t fMap;\n\n   public:\n      void Add(const key_type &key, mapped_type obj)\n      {\n         // Add the <key,obj> pair to the map.\n         std::pair<const key_type, mapped_type> pair = make_pair(key, obj);\n         fMap.insert(pair);\n      }\n      size_type CountElementsWithKey(const key_type &key)\n      {\n         return fMap.count(key);\n      }\n      equal_range Find(const key_type &key) const\n      {\n         // Find the type corresponding to the key.\n         return fMap.equal_range(key);\n      }\n      void Remove(const key_type &key) {\n         // Remove the type corresponding to the key.\n         fMap.erase(key);\n      }\n   };\n}\n\nIdMap_t *TClass::GetIdMap() {\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n   static IdMap_t gIdMapObject;\n   return &gIdMapObject;\n#else\n   static IdMap_t *gIdMap = new IdMap_t;\n   return gIdMap;\n#endif\n}\n\nDeclIdMap_t *TClass::GetDeclIdMap() {\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n   static DeclIdMap_t gDeclIdMapObject;\n   return &gDeclIdMapObject;\n#else\n   static DeclIdMap_t *gDeclIdMap = new DeclIdMap_t;\n   return gDeclIdMap;\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// static: Add a class to the list and map of classes.\n\nvoid TClass::AddClass(TClass *cl)\n{\n   if (!cl) return;\n\n   R__LOCKGUARD(gInterpreterMutex);\n   gROOT->GetListOfClasses()->Add(cl);\n   if (cl->GetTypeInfo()) {\n      GetIdMap()->Add(cl->GetTypeInfo()->name(),cl);\n   }\n   if (cl->fClassInfo) {\n      GetDeclIdMap()->Add((void*)(cl->fClassInfo), cl);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// static: Add a TClass* to the map of classes.\n\nvoid TClass::AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl)\n{\n   if (!cl || !id) return;\n   GetDeclIdMap()->Add(id, cl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// static: Remove a class from the list and map of classes\n\nvoid TClass::RemoveClass(TClass *oldcl)\n{\n   if (!oldcl) return;\n\n   R__LOCKGUARD(gInterpreterMutex);\n   gROOT->GetListOfClasses()->Remove(oldcl);\n   if (oldcl->GetTypeInfo()) {\n      GetIdMap()->Remove(oldcl->GetTypeInfo()->name());\n   }\n   if (oldcl->fClassInfo) {\n      //GetDeclIdMap()->Remove((void*)(oldcl->fClassInfo));\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TClass::RemoveClassDeclId(TDictionary::DeclId_t id)\n{\n   if (!id) return;\n   GetDeclIdMap()->Remove(id);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Indirect call to the implementation of ShowMember allowing [forward]\n/// declaration with out a full definition of the TClass class.\n\nvoid ROOT::Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector&insp)\n{\n   gInterpreter->InspectMembers(insp, obj, cl, kFALSE);\n}\n\n//______________________________________________________________________________\n//______________________________________________________________________________\n\nclass TDumpMembers : public TMemberInspector {\n   bool fNoAddr;\npublic:\n   TDumpMembers(bool noAddr): fNoAddr(noAddr) { }\n\n   using TMemberInspector::Inspect;\n   void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n/// Print value of member mname.\n///\n/// This method is called by the ShowMembers() method for each\n/// data member when object.Dump() is invoked.\n///\n///  - cl    is the pointer to the current class\n///  - pname is the parent name (in case of composed objects)\n///  - mname is the data member name\n///  - add   is the data member address\n\nvoid TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */)\n{\n   const Int_t kvalue = 30;\n#ifdef R__B64\n   const Int_t ktitle = 50;\n#else\n   const Int_t ktitle = 42;\n#endif\n   const Int_t kline  = 1024;\n   Int_t cdate = 0;\n   Int_t ctime = 0;\n   UInt_t *cdatime = 0;\n   char line[kline];\n\n   TDataType *membertype;\n   EDataType memberDataType = kNoType_t;\n   const char *memberName;\n   const char *memberFullTypeName;\n   const char *memberTitle;\n   Bool_t isapointer;\n   Bool_t isbasic;\n\n   if (TDataMember *member = cl->GetDataMember(mname)) {\n      if (member->GetDataType()) {\n         memberDataType = (EDataType)member->GetDataType()->GetType();\n      }\n      memberName = member->GetName();\n      memberFullTypeName = member->GetFullTypeName();\n      memberTitle = member->GetTitle();\n      isapointer = member->IsaPointer();\n      isbasic = member->IsBasic();\n      membertype = member->GetDataType();\n   } else if (!cl->IsLoaded()) {\n      // The class is not loaded, hence it is 'emulated' and the main source of\n      // information is the StreamerInfo.\n      TVirtualStreamerInfo *info = cl->GetStreamerInfo();\n      if (!info) return;\n      const char *cursor = mname;\n      while ( (*cursor)=='*' ) ++cursor;\n      TString elname( cursor );\n      Ssiz_t pos = elname.Index(\"[\");\n      if ( pos != kNPOS ) {\n         elname.Remove( pos );\n      }\n      TStreamerElement *element = (TStreamerElement*)info->GetElements()->FindObject(elname.Data());\n      if (!element) return;\n      memberFullTypeName = element->GetTypeName();\n\n      memberDataType = (EDataType)element->GetType();\n\n      memberName = element->GetName();\n      memberTitle = element->GetTitle();\n      isapointer = element->IsaPointer() || element->GetType() == TVirtualStreamerInfo::kCharStar;\n      membertype = gROOT->GetType(memberFullTypeName);\n\n      isbasic = membertype !=0;\n   } else {\n      return;\n   }\n\n\n   Bool_t isdate = kFALSE;\n   if (strcmp(memberName,\"fDatime\") == 0 && memberDataType == kUInt_t) {\n      isdate = kTRUE;\n   }\n   Bool_t isbits = kFALSE;\n   if (strcmp(memberName,\"fBits\") == 0 && memberDataType == kUInt_t) {\n      isbits = kTRUE;\n   }\n   TClass * dataClass = TClass::GetClass(memberFullTypeName);\n   Bool_t isTString = (dataClass == TString::Class());\n   static TClassRef stdClass(\"std::string\");\n   Bool_t isStdString = (dataClass == stdClass);\n\n   Int_t i;\n   for (i = 0;i < kline; i++) line[i] = ' ';\n   line[kline-1] = 0;\n   snprintf(line,kline,\"%s%s \",pname,mname);\n   i = strlen(line); line[i] = ' ';\n\n   // Encode data value or pointer value\n   char *pointer = (char*)add;\n   char **ppointer = (char**)(pointer);\n\n   if (isapointer) {\n      char **p3pointer = (char**)(*ppointer);\n      if (!p3pointer)\n         snprintf(&line[kvalue],kline-kvalue,\"->0\");\n      else if (!isbasic) {\n         if (!fNoAddr) {\n            snprintf(&line[kvalue],kline-kvalue,\"->%lx \", (Long_t)p3pointer);\n         }\n      } else if (membertype) {\n         if (!strcmp(membertype->GetTypeName(), \"char\")) {\n            i = strlen(*ppointer);\n            if (kvalue+i > kline) i=kline-1-kvalue;\n            Bool_t isPrintable = kTRUE;\n            for (Int_t j = 0; j < i; j++) {\n               if (!std::isprint((*ppointer)[j])) {\n                  isPrintable = kFALSE;\n                  break;\n               }\n            }\n            if (isPrintable) {\n               strncpy(line + kvalue, *ppointer, i);\n               line[kvalue+i] = 0;\n            } else {\n               line[kvalue] = 0;\n            }\n         } else {\n            strncpy(&line[kvalue], membertype->AsString(p3pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(p3pointer))));\n         }\n      } else if (!strcmp(memberFullTypeName, \"char*\") ||\n                 !strcmp(memberFullTypeName, \"const char*\")) {\n         i = strlen(*ppointer);\n         if (kvalue+i >= kline) i=kline-1-kvalue;\n         Bool_t isPrintable = kTRUE;\n         for (Int_t j = 0; j < i; j++) {\n            if (!std::isprint((*ppointer)[j])) {\n               isPrintable = kFALSE;\n               break;\n            }\n         }\n         if (isPrintable) {\n            strncpy(line + kvalue, *ppointer, std::min( i, kline - kvalue));\n            line[kvalue+i] = 0;\n         } else {\n            line[kvalue] = 0;\n         }\n      } else {\n         if (!fNoAddr) {\n            snprintf(&line[kvalue],kline-kvalue,\"->%lx \", (Long_t)p3pointer);\n         }\n      }\n   } else if (membertype) {\n      if (isdate) {\n         cdatime = (UInt_t*)pointer;\n         TDatime::GetDateTime(cdatime[0],cdate,ctime);\n         snprintf(&line[kvalue],kline-kvalue,\"%d/%d\",cdate,ctime);\n      } else if (isbits) {\n         snprintf(&line[kvalue],kline-kvalue,\"0x%08x\", *(UInt_t*)pointer);\n      } else {\n         strncpy(&line[kvalue], membertype->AsString(pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(pointer))));\n      }\n   } else {\n      if (isStdString) {\n         std::string *str = (std::string*)pointer;\n         snprintf(&line[kvalue],kline-kvalue,\"%s\",str->c_str());\n      } else if (isTString) {\n         TString *str = (TString*)pointer;\n         snprintf(&line[kvalue],kline-kvalue,\"%s\",str->Data());\n      } else {\n         if (!fNoAddr) {\n            snprintf(&line[kvalue],kline-kvalue,\"->%lx \", (Long_t)pointer);\n         }\n      }\n   }\n   // Encode data member title\n   if (isdate == kFALSE && strcmp(memberFullTypeName, \"char*\") && strcmp(memberFullTypeName, \"const char*\")) {\n      i = strlen(&line[0]); line[i] = ' ';\n      assert(250 > ktitle);\n      strlcpy(&line[ktitle],memberTitle,250-ktitle+1); // strlcpy copy 'size-1' characters.\n   }\n   Printf(\"%s\", line);\n}\n\nTHashTable* TClass::fgClassTypedefHash = 0;\n\n//______________________________________________________________________________\n//______________________________________________________________________________\n////////////////////////////////////////////////////////////////////////////////\n\nTClass::TNameMapNode::TNameMapNode (const char* typedf, const char* orig)\n  : TObjString (typedf),\n    fOrigName (orig)\n{\n}\n\n//______________________________________________________________________________\n\nclass TBuildRealData : public TMemberInspector {\n\nprivate:\n   void    *fRealDataObject;\n   TClass  *fRealDataClass;\n\npublic:\n   TBuildRealData(void *obj, TClass *cl) {\n      // Main constructor.\n      fRealDataObject = obj;\n      fRealDataClass = cl;\n   }\n   using TMemberInspector::Inspect;\n   void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient);\n\n};\n\n////////////////////////////////////////////////////////////////////////////////\n/// This method is called from ShowMembers() via BuildRealdata().\n\nvoid TBuildRealData::Inspect(TClass* cl, const char* pname, const char* mname, const void* add, Bool_t isTransient)\n{\n   TDataMember* dm = cl->GetDataMember(mname);\n   if (!dm) {\n      return;\n   }\n\n   Bool_t isTransientMember = kFALSE;\n\n   if (!dm->IsPersistent()) {\n      // For the DataModelEvolution we need access to the transient member.\n      // so we now record them in the list of RealData.\n      isTransientMember = kTRUE;\n      isTransient = kTRUE;\n   }\n\n   TString rname( pname );\n   // Take into account cases like TPaveStats->TPaveText->TPave->TBox.\n   // Check that member is in a derived class or an object in the class.\n   if (cl != fRealDataClass) {\n      if (!fRealDataClass->InheritsFrom(cl)) {\n         Ssiz_t dot = rname.Index('.');\n         if (dot == kNPOS) {\n            return;\n         }\n         rname[dot] = '\\0';\n         if (!fRealDataClass->GetDataMember(rname)) {\n            //could be a data member in a base class like in this example\n            // class Event : public Data {\n            //   class Data : public TObject {\n            //     EventHeader fEvtHdr;\n            //     class EventHeader {\n            //       Int_t     fEvtNum;\n            //       Int_t     fRun;\n            //       Int_t     fDate;\n            //       EventVertex fVertex;\n            //       class EventVertex {\n            //         EventTime  fTime;\n            //         class EventTime {\n            //           Int_t     fSec;\n            //           Int_t     fNanoSec;\n            if (!fRealDataClass->GetBaseDataMember(rname)) {\n               return;\n            }\n         }\n         rname[dot] = '.';\n      }\n   }\n\n   Long_t offset = Long_t(((Long_t) add) - ((Long_t) fRealDataObject));\n\n   if (TClassEdit::IsStdArray(dm->GetTypeName())){ // We tackle the std array case\n      TString rdName;\n      TRealData::GetName(rdName,dm);\n      rname += rdName;\n      TRealData* rd = new TRealData(rname.Data(), offset, dm);\n      fRealDataClass->GetListOfRealData()->Add(rd);\n      return;\n   }\n\n   rname += mname;\n\n   if (dm->IsaPointer()) {\n      // Data member is a pointer.\n      TRealData* rd = new TRealData(rname, offset, dm);\n      if (isTransientMember) { rd->SetBit(TRealData::kTransient); };\n      fRealDataClass->GetListOfRealData()->Add(rd);\n   } else {\n      // Data Member is a basic data type.\n      TRealData* rd = new TRealData(rname, offset, dm);\n      if (isTransientMember) { rd->SetBit(TRealData::kTransient); };\n      if (!dm->IsBasic()) {\n         rd->SetIsObject(kTRUE);\n\n         // Make sure that BuildReadData is called for any abstract\n         // bases classes involved in this object, i.e for all the\n         // classes composing this object (base classes, type of\n         // embedded object and same for their data members).\n         //\n         TClass* dmclass = TClass::GetClass(dm->GetTypeName(), kTRUE, isTransient);\n         if (!dmclass) {\n            dmclass = TClass::GetClass(dm->GetTrueTypeName(), kTRUE, isTransient);\n         }\n         if (dmclass) {\n            if ((dmclass != cl) && !dm->IsaPointer()) {\n               if (dmclass->GetCollectionProxy()) {\n                  TClass* valcl = dmclass->GetCollectionProxy()->GetValueClass();\n                  // We create the real data for the content of the collection to help the case\n                  // of split branches in a TTree (where the node for the data member itself\n                  // might have been elided).  However, in some cases, like transient members\n                  // and/or classes, the content might not be create-able.   An example is the\n                  // case of a map<A,B> where either A or B does not have default constructor\n                  // and thus the compilation of the default constructor for pair<A,B> will\n                  // fail (noisily) [This could also apply to any template instance, where it\n                  // might have a default constructor definition that can not be compiled due\n                  // to the template parameter]\n                  if (valcl) {\n                     Bool_t wantBuild = kTRUE;\n                     if (valcl->Property() & kIsAbstract) wantBuild = kFALSE;\n                     if ( (isTransient)\n                          && (dmclass->GetCollectionProxy()->GetProperties() & TVirtualCollectionProxy::kIsEmulated)\n                          && (!valcl->IsLoaded()) ) {\n                        // Case where the collection dictionary was not requested and\n                        // the content's dictionary was also not requested.\n                        // [This is a super set of what we need, but we can't really detect it :(]\n                        wantBuild = kFALSE;\n                     }\n\n                     if (wantBuild) valcl->BuildRealData(0, isTransient);\n                  }\n               } else {\n                  void* addrForRecursion = 0;\n                  if (GetObjectValidity() == kValidObjectGiven)\n                     addrForRecursion = const_cast<void*>(add);\n\n                  dmclass->BuildRealData(addrForRecursion, isTransient);\n               }\n            }\n         }\n      }\n      fRealDataClass->GetListOfRealData()->Add(rd);\n   }\n}\n\n//______________________________________________________________________________\n//______________________________________________________________________________\n//______________________________________________________________________________\n\n////////////////////////////////////////////////////////////////////////////////\n\nclass TAutoInspector : public TMemberInspector {\npublic:\n   Int_t     fCount;\n   TBrowser *fBrowser;\n\n   TAutoInspector(TBrowser *b) {\n      // main constructor.\n      fBrowser = b; fCount = 0; }\n   virtual ~TAutoInspector() { }\n   using TMemberInspector::Inspect;\n   virtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient);\n   virtual Bool_t IsTreatingNonAccessibleTypes() {return kFALSE;}\n};\n\n////////////////////////////////////////////////////////////////////////////////\n/// This method is called from ShowMembers() via AutoBrowse().\n\nvoid TAutoInspector::Inspect(TClass *cl, const char *tit, const char *name,\n                             const void *addr, Bool_t /* isTransient */)\n{\n   if(tit && strchr(tit,'.'))    return ;\n   if (fCount && !fBrowser) return;\n\n   TString ts;\n\n   if (!cl) return;\n   //if (*(cl->GetName()) == 'T') return;\n   if (*name == '*') name++;\n   int ln = strcspn(name,\"[ \");\n   TString iname(name,ln);\n\n   ClassInfo_t *classInfo = cl->GetClassInfo();\n   if (!classInfo)               return;\n\n   //              Browse data members\n   DataMemberInfo_t *m = gCling->DataMemberInfo_Factory(classInfo);\n   TString mname;\n\n   int found=0;\n   while (gCling->DataMemberInfo_Next(m)) {    // MemberLoop\n      mname = gCling->DataMemberInfo_Name(m);\n      mname.ReplaceAll(\"*\",\"\");\n      if ((found = (iname==mname))) break;\n   }\n   assert(found);\n\n   // we skip: non static members and non objects\n   //  - the member G__virtualinfo inserted by the CINT RTTI system\n\n   //Long_t prop = m.Property() | m.Type()->Property();\n   Long_t prop = gCling->DataMemberInfo_Property(m) | gCling->DataMemberInfo_TypeProperty(m);\n   if (prop & kIsStatic)           return;\n   if (prop & kIsFundamental)      return;\n   if (prop & kIsEnum)             return;\n   if (mname == \"G__virtualinfo\")  return;\n\n   int  size = sizeof(void*);\n\n   int nmax = 1;\n   if (prop & kIsArray) {\n      for (int dim = 0; dim < gCling->DataMemberInfo_ArrayDim(m); dim++) nmax *= gCling->DataMemberInfo_MaxIndex(m,dim);\n   }\n\n   std::string clmName(TClassEdit::ShortType(gCling->DataMemberInfo_TypeName(m),\n                                             TClassEdit::kDropTrailStar) );\n   TClass * clm = TClass::GetClass(clmName.c_str());\n   R__ASSERT(clm);\n   if (!(prop & kIsPointer)) {\n      size = clm->Size();\n      if (size==0) size = gCling->DataMemberInfo_TypeSize(m);\n   }\n\n\n   gCling->DataMemberInfo_Delete(m);\n   TVirtualCollectionProxy *proxy = clm->GetCollectionProxy();\n\n   for(int i=0; i<nmax; i++) {\n\n      char *ptr = (char*)addr + i*size;\n\n      void *obj = (prop & kIsPointer) ? *((void**)ptr) : (TObject*)ptr;\n\n      if (!obj)           continue;\n\n      fCount++;\n      if (!fBrowser)      return;\n\n      TString bwname;\n      TClass *actualClass = clm->GetActualClass(obj);\n      if (clm->IsTObject()) {\n         TObject *tobj = (TObject*)clm->DynamicCast(TObject::Class(),obj);\n         bwname = tobj->GetName();\n      } else {\n         bwname = actualClass->GetName();\n         bwname += \"::\";\n         bwname += mname;\n      }\n\n      if (!clm->IsTObject() ||\n          bwname.Length()==0 ||\n          strcmp(bwname.Data(),actualClass->GetName())==0) {\n         bwname = name;\n         int l = strcspn(bwname.Data(),\"[ \");\n         if (l<bwname.Length() && bwname[l]=='[') {\n            char cbuf[13]; snprintf(cbuf,13,\"[%02d]\",i);\n            ts.Replace(0,999,bwname,l);\n            ts += cbuf;\n            bwname = (const char*)ts;\n         }\n      }\n\n      if (proxy==0) {\n\n         fBrowser->Add(obj,clm,bwname);\n\n      } else {\n         TClass *valueCl = proxy->GetValueClass();\n\n         if (valueCl==0) {\n\n            fBrowser->Add( obj, clm, bwname );\n\n         } else {\n            TVirtualCollectionProxy::TPushPop env(proxy, obj);\n            TClass *actualCl = 0;\n\n            int sz = proxy->Size();\n\n            char fmt[] = {\"#%09d\"};\n            fmt[3]  = '0'+(int)log10(double(sz))+1;\n            char buf[20];\n            for (int ii=0;ii<sz;ii++) {\n               void *p = proxy->At(ii);\n\n               if (proxy->HasPointers()) {\n                  p = *((void**)p);\n                  if(!p) continue;\n                  actualCl = valueCl->GetActualClass(p);\n                  p = actualCl->DynamicCast(valueCl,p,0);\n               }\n               fCount++;\n               snprintf(buf,20,fmt,ii);\n               ts = bwname;\n               ts += buf;\n               fBrowser->Add( p, actualCl, ts );\n            }\n         }\n      }\n   }\n}\n\n//______________________________________________________________________________\n//______________________________________________________________________________\n//______________________________________________________________________________\n\nClassImp(TClass);\n\n////////////////////////////////////////////////////////////////////////////////\n\nTClass::TClass() :\n   TDictionary(),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kNoInfo),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n\n{\n   // Default ctor.\n\n   R__LOCKGUARD(gInterpreterMutex);\n   {\n      TMmallocDescTemp setreset;\n      fStreamerInfo = new TObjArray(1, -2);\n   }\n   fDeclFileLine   = -2;    // -2 for standalone TClass (checked in dtor)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n/// Use this ctor to create a standalone TClass object. Most useful\n/// to get a TClass interface to an interpreted class. Used by TTabCom.\n/// Normally you would use TClass::GetClass(\"class\") to get access to a\n/// TClass object for a certain class.\n\nTClass::TClass(const char *name, Bool_t silent) :\n   TDictionary(name),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kNoInfo),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!gROOT)\n      ::Fatal(\"TClass::TClass\", \"ROOT system not initialized\");\n\n   {\n      TMmallocDescTemp setreset;\n      fStreamerInfo = new TObjArray(1, -2);\n   }\n   fDeclFileLine   = -2;    // -2 for standalone TClass (checked in dtor)\n\n   SetBit(kLoading);\n   if (!gInterpreter)\n      ::Fatal(\"TClass::TClass\", \"gInterpreter not initialized\");\n\n   gInterpreter->SetClassInfo(this);   // sets fClassInfo pointer\n   if (!silent && !fClassInfo && fName.First('@')==kNPOS)\n      ::Warning(\"TClass::TClass\", \"no dictionary for class %s is available\", name);\n   ResetBit(kLoading);\n\n   if (fClassInfo) SetTitle(gCling->ClassInfo_Title(fClassInfo));\n   fConversionStreamerInfo = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n\nTClass::TClass(const char *name, Version_t cversion, Bool_t silent) :\n   TDictionary(name),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kNoInfo),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   Init(name, cversion, 0, 0, 0, 0, -1, -1, 0, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object does not contain anything. We mimic\n/// the case of a class fwd declared in the interpreter.\n\nTClass::TClass(const char *name, Version_t cversion, EState theState, Bool_t silent) :\n   TDictionary(name),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(theState),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Treat the case in which a TClass instance is created for a namespace\n   if (theState == kNamespaceForMeta){\n      fProperty = kIsNamespace;\n      theState = kForwardDeclared; // it immediately decays in kForwardDeclared\n   }\n\n   if (theState != kForwardDeclared && theState != kEmulated)\n      ::Fatal(\"TClass::TClass\",\n              \"A TClass entry cannot be initialized in a state different from kForwardDeclared or kEmulated.\");\n   Init(name, cversion, 0, 0, 0, 0, -1, -1, 0, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n/// Use this ctor to create a standalone TClass object. Most useful\n/// to get a TClass interface to an interpreted class. Used by TTabCom.\n/// Normally you would use TClass::GetClass(\"class\") to get access to a\n/// TClass object for a certain class.\n///\n/// This copies the ClassInfo (i.e. does *not* take ownership of it).\n\nTClass::TClass(ClassInfo_t *classInfo, Version_t cversion,\n               const char *dfil, const char *ifil, Int_t dl, Int_t il, Bool_t silent) :\n   TDictionary(\"\"),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kNoInfo),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!gROOT)\n      ::Fatal(\"TClass::TClass\", \"ROOT system not initialized\");\n\n   fDeclFileLine   = -2;    // -2 for standalone TClass (checked in dtor)\n\n   SetBit(kLoading);\n   if (!gInterpreter)\n      ::Fatal(\"TClass::TClass\", \"gInterpreter not initialized\");\n\n   if (!classInfo || !gInterpreter->ClassInfo_IsValid(classInfo)) {\n      MakeZombie();\n      fState = kNoInfo;\n   } else {\n      fName = gInterpreter->ClassInfo_FullName(classInfo);\n\n      R__LOCKGUARD(gInterpreterMutex);\n      Init(fName, cversion, 0, 0, dfil, ifil, dl, il, classInfo, silent);\n   }\n   ResetBit(kLoading);\n\n   fConversionStreamerInfo = 0;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n\nTClass::TClass(const char *name, Version_t cversion,\n               const char *dfil, const char *ifil, Int_t dl, Int_t il, Bool_t silent) :\n   TDictionary(name),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0), fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kNoInfo),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   Init(name,cversion, 0, 0, dfil, ifil, dl, il, 0, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n\nTClass::TClass(const char *name, Version_t cversion,\n               const std::type_info &info, TVirtualIsAProxy *isa,\n               const char *dfil, const char *ifil, Int_t dl, Int_t il,\n               Bool_t silent) :\n   TDictionary(name),\n   fPersistentRef(0),\n   fStreamerInfo(0), fConversionStreamerInfo(0), fRealData(0),\n   fBase(0), fData(0), fEnums(0), fFuncTemplate(0), fMethod(0), fAllPubData(0),\n   fAllPubMethod(0),\n   fClassMenuList(0),\n   fDeclFileName(\"\"), fImplFileName(\"\"), fDeclFileLine(0), fImplFileLine(0),\n   fInstanceCount(0), fOnHeap(0),\n   fCheckSum(0), fCollectionProxy(0), fClassVersion(0), fClassInfo(0),\n   fTypeInfo(0), fShowMembers(0),\n   fStreamer(0), fIsA(0), fGlobalIsA(0), fIsAMethod(0),\n   fMerge(0), fResetAfterMerge(0), fNew(0), fNewArray(0), fDelete(0), fDeleteArray(0),\n   fDestructor(0), fDirAutoAdd(0), fStreamerFunc(0), fConvStreamerFunc(0), fSizeof(-1),\n   fCanSplit(-1), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),\n   fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),\n   fState(kHasTClassInit),\n   fCurrentInfo(0), fLastReadInfo(0), fRefProxy(0),\n   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // use info\n   Init(name, cversion, &info, isa, dfil, ifil, dl, il, 0, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// we found at least one equivalent.\n/// let's force a reload\n\nvoid TClass::ForceReload (TClass* oldcl)\n{\n   TClass::RemoveClass(oldcl);\n\n   if (oldcl->CanIgnoreTObjectStreamer()) {\n      IgnoreTObjectStreamer();\n   }\n\n   TVirtualStreamerInfo *info;\n   TIter next(oldcl->GetStreamerInfos());\n   while ((info = (TVirtualStreamerInfo*)next())) {\n      info->Clear(\"build\");\n      info->SetClass(this);\n      fStreamerInfo->AddAtAndExpand(info,info->GetClassVersion());\n   }\n   oldcl->fStreamerInfo->Clear();\n\n   oldcl->ReplaceWith(this);\n   delete oldcl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize a TClass object. This object contains the full dictionary\n/// of a class. It has list to baseclasses, datamembers and methods.\n\nvoid TClass::Init(const char *name, Version_t cversion,\n                  const std::type_info *typeinfo, TVirtualIsAProxy *isa,\n                  const char *dfil, const char *ifil, Int_t dl, Int_t il,\n                  ClassInfo_t *givenInfo,\n                  Bool_t silent)\n{\n   if (!gROOT)\n      ::Fatal(\"TClass::TClass\", \"ROOT system not initialized\");\n   if (!name || !name[0]) {\n      ::Error(\"TClass::Init\", \"The name parameter is invalid (null or empty)\");\n      MakeZombie();\n      return;\n   }\n   // Always strip the default STL template arguments (from any template argument or the class name)\n   fName           = TClassEdit::ShortType(name, TClassEdit::kDropStlDefault).c_str();\n   fClassVersion   = cversion;\n   fDeclFileName   = dfil ? dfil : \"\";\n   fImplFileName   = ifil ? ifil : \"\";\n   fDeclFileLine   = dl;\n   fImplFileLine   = il;\n   fTypeInfo       = typeinfo;\n   fIsA            = isa;\n   if ( fIsA ) fIsA->SetClass(this);\n   // See also TCling::GenerateTClass() which will update fClassVersion after creation!\n   fStreamerInfo   = new TObjArray(fClassVersion+2+10,-1); // +10 to read new data by old\n   fProperty       = -1;\n   fClassProperty  = 0;\n\n   ResetInstanceCount();\n\n   TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(fName.Data());\n\n   InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);\n\n   if (oldcl && oldcl->TestBit(kLoading)) {\n      // Do not recreate a class while it is already being created!\n\n      // We can no longer reproduce this case, to check whether we are, we use\n      // this code:\n      // Fatal(\"Init\",\"A bad replacement for %s was requested\\n\",name);\n      return;\n   }\n\n   TClass **persistentRef = 0;\n   if (oldcl) {\n\n      persistentRef = oldcl->fPersistentRef.exchange(0);\n\n      // The code from here is also in ForceReload.\n      TClass::RemoveClass(oldcl);\n      // move the StreamerInfo immediately so that there are\n      // properly updated!\n\n      if (oldcl->CanIgnoreTObjectStreamer()) {\n         IgnoreTObjectStreamer();\n      }\n      TVirtualStreamerInfo *info;\n\n      TIter next(oldcl->GetStreamerInfos());\n      while ((info = (TVirtualStreamerInfo*)next())) {\n         // We need to force a call to BuildOld\n         info->Clear(\"build\");\n         info->SetClass(this);\n         fStreamerInfo->AddAtAndExpand(info,info->GetClassVersion());\n      }\n      oldcl->fStreamerInfo->Clear();\n      // The code diverges here from ForceReload.\n\n      // Move the Schema Rules too.\n      fSchemaRules = oldcl->fSchemaRules;\n      oldcl->fSchemaRules = 0;\n   }\n\n   SetBit(kLoading);\n   // Advertise ourself as the loading class for this class name\n   TClass::AddClass(this);\n\n   Bool_t isStl = TClassEdit::IsSTLCont(fName);\n\n   if (!gInterpreter)\n      ::Fatal(\"TClass::Init\", \"gInterpreter not initialized\");\n\n   if (givenInfo) {\n      bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);\n      bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);\n      auto property = gInterpreter->ClassInfo_Property(givenInfo);\n\n      if (invalid || (notloaded && (property & kIsNamespace)) ||\n          !(property & (kIsClass | kIsStruct | kIsNamespace))) {\n         if (!TClassEdit::IsSTLCont(fName.Data())) {\n            MakeZombie();\n            fState = kNoInfo;\n            TClass::RemoveClass(this);\n            return;\n         }\n      }\n\n      fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);\n      fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded\n   }\n\n   // We need to check if the class it is not fwd declared for the cases where we\n   // created a TClass directly in the kForwardDeclared state. Indeed in those cases\n   // fClassInfo will always be nullptr.\n   if (fState!=kForwardDeclared && !fClassInfo) {\n\n      if (fState == kHasTClassInit) {\n         // If the TClass is being generated from a ROOT dictionary,\n         // even though we do not seem to have a CINT dictionary for\n         // the class, we will will try to load it anyway UNLESS\n         // the class is an STL container (or string).\n         // This is because we do not expect the CINT dictionary\n         // to be present for all STL classes (and we can handle\n         // the lack of CINT dictionary in that cases).\n         // However, the cling the dictionary no longer carries\n         // an instantiation with it, unless we request the loading\n         // here *or* the user explicitly instantiate the template\n         // we would not have a ClassInfo for the template\n         // instantiation.\n         fCanLoadClassInfo = kTRUE;\n         // Here we check and grab the info from the rootpcm.\n         TProtoClass *proto = TClassTable::GetProtoNorm(GetName());\n         if (proto && proto->FillTClass(this)) {\n            fHasRootPcmInfo = kTRUE;\n         }\n      }\n      if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {\n         gInterpreter->SetClassInfo(this);   // sets fClassInfo pointer\n         if (fClassInfo) {\n            // This should be moved out of GetCheckSum itself however the last time\n            // we tried this cause problem, in particular in the end-of-process operation.\n            // fCheckSum = GetCheckSum(kLatestCheckSum);\n         } else {\n            if (!fClassInfo) {\n               if (IsZombie()) {\n                  TClass::RemoveClass(this);\n                  return;\n               }\n            }\n         }\n      }\n   }\n   if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && fName.First('@')==kNPOS &&\n       !TClassEdit::IsInterpreterDetail(fName.Data()) ) {\n      if (fState == kHasTClassInit) {\n         if (fImplFileLine == -1 && fClassVersion == 0) {\n            // We have a 'transient' class with a ClassDefInline and apparently no interpreter\n            // information. Since it is transient, it is more than likely that the lack\n            // will be harmles.\n         } else {\n            ::Error(\"TClass::Init\", \"no interpreter information for class %s is available even though it has a TClass \"\n                                    \"initialization routine.\",\n                    fName.Data());\n         }\n      } else {\n         // In this case we initialised this TClass instance starting from the fwd declared state\n         // and we know we have no dictionary: no need to warn\n         ::Warning(\"TClass::Init\", \"no dictionary for class %s is available\", fName.Data());\n      }\n   }\n\n   fgClassCount++;\n   SetUniqueID(fgClassCount);\n\n   // Make the typedef-expanded -> original hash table entries.\n   // There may be several entries for any given key.\n   // We only make entries if the typedef-expanded name\n   // is different from the original name.\n   TString resolvedThis;\n   if (!givenInfo && strchr (name, '<')) {\n      if ( fName != name) {\n         if (!fgClassTypedefHash) {\n            fgClassTypedefHash = new THashTable (100, 5);\n            fgClassTypedefHash->SetOwner (kTRUE);\n         }\n\n         fgClassTypedefHash->Add (new TNameMapNode (name, fName));\n         SetBit (kHasNameMapNode);\n\n      }\n      resolvedThis = TClassEdit::ResolveTypedef (name, kTRUE);\n      if (resolvedThis != name) {\n         if (!fgClassTypedefHash) {\n            fgClassTypedefHash = new THashTable (100, 5);\n            fgClassTypedefHash->SetOwner (kTRUE);\n         }\n\n         fgClassTypedefHash->Add (new TNameMapNode (resolvedThis, fName));\n         SetBit (kHasNameMapNode);\n      }\n\n   }\n\n   //In case a class with the same name had been created by TVirtualStreamerInfo\n   //we must delete the old class, importing only the StreamerInfo structure\n   //from the old dummy class.\n   if (oldcl) {\n\n      oldcl->ReplaceWith(this);\n      delete oldcl;\n\n   } else if (!givenInfo && resolvedThis.Length() > 0 && fgClassTypedefHash) {\n\n      // Check for existing equivalent.\n\n      if (resolvedThis != fName) {\n         oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(resolvedThis);\n         if (oldcl && oldcl != this) {\n            persistentRef = oldcl->fPersistentRef.exchange(0);\n            ForceReload (oldcl);\n         }\n      }\n      TIter next( fgClassTypedefHash->GetListForObject(resolvedThis) );\n      while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {\n         if (resolvedThis != htmp->String()) continue;\n         oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);\n         if (oldcl && oldcl != this) {\n            persistentRef = oldcl->fPersistentRef.exchange(0);\n            ForceReload (oldcl);\n         }\n      }\n   }\n   if (fClassInfo) {\n      SetTitle(gCling->ClassInfo_Title(fClassInfo));\n      if ( fDeclFileName == 0 || fDeclFileName[0] == '\\0' ) {\n         fDeclFileName = gInterpreter->ClassInfo_FileName( fClassInfo );\n         // Missing interface:\n         // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );\n\n         // But really do not want to set ImplFileLine as it is currently the\n         // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).\n      }\n   }\n\n   if (persistentRef) {\n      fPersistentRef = persistentRef;\n   } else {\n      fPersistentRef = new TClass*;\n   }\n   *fPersistentRef = this;\n\n   if ( isStl || !strncmp(GetName(),\"stdext::hash_\",13) || !strncmp(GetName(),\"__gnu_cxx::hash_\",16) ) {\n      if (fState != kHasTClassInit) {\n         // If we have a TClass compiled initialization, we can safely assume that\n         // there will also be a collection proxy.\n         fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );\n         if (fCollectionProxy) {\n            fSizeof = fCollectionProxy->Sizeof();\n\n            // Numeric Collections have implicit conversions:\n            GetSchemaRules(kTRUE);\n\n         } else if (!silent) {\n            Warning(\"Init\",\"Collection proxy for %s was not properly initialized!\",GetName());\n         }\n         if (fStreamer==0) {\n            fStreamer =  TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );\n         }\n      }\n   } else if (!strncmp(GetName(),\"std::pair<\",10) || !strncmp(GetName(),\"pair<\",5) ) {\n      // std::pairs have implicit conversions\n      GetSchemaRules(kTRUE);\n   }\n\n   ResetBit(kLoading);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// TClass dtor. Deletes all list that might have been created.\n\nTClass::~TClass()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Remove from the typedef hashtables.\n   if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {\n      TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);\n      TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));\n      while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {\n         if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {\n            fgClassTypedefHash->Remove (htmp);\n            delete htmp;\n            break;\n         }\n      }\n   }\n\n   // Not owning lists, don't call Delete()\n   // But this still need to be done first because the TList destructor\n   // does access the object contained (via GetObject()->TestBit(kCanDelete))\n   delete fStreamer;       fStreamer    =0;\n   delete fAllPubData;     fAllPubData  =0;\n   delete fAllPubMethod;   fAllPubMethod=0;\n\n   delete fPersistentRef.load();\n\n   if (fBase.load())\n      (*fBase).Delete();\n   delete fBase.load(); fBase = 0;\n\n   if (fData)\n      fData->Delete();\n   delete fData;   fData = 0;\n\n   if (fEnums.load())\n      (*fEnums).Delete();\n   delete fEnums.load(); fEnums = 0;\n\n   if (fFuncTemplate)\n      fFuncTemplate->Delete();\n   delete fFuncTemplate; fFuncTemplate = 0;\n\n   if (fMethod.load())\n      (*fMethod).Delete();\n   delete fMethod.load();   fMethod=0;\n\n   if (fRealData)\n      fRealData->Delete();\n   delete fRealData;  fRealData=0;\n\n   if (fStreamerInfo)\n      fStreamerInfo->Delete();\n   delete fStreamerInfo; fStreamerInfo = nullptr;\n\n   if (fDeclFileLine >= -1)\n      TClass::RemoveClass(this);\n\n   gCling->ClassInfo_Delete(fClassInfo);\n   fClassInfo=0;\n\n   if (fClassMenuList)\n      fClassMenuList->Delete();\n   delete fClassMenuList; fClassMenuList=0;\n\n   fIsOffsetStreamerSet=kFALSE;\n\n   if ( fIsA ) delete fIsA;\n\n   if ( fRefProxy ) fRefProxy->Release();\n   fRefProxy = 0;\n\n   delete fStreamer;\n   delete fCollectionProxy;\n   delete fIsAMethod.load();\n   delete fSchemaRules;\n   if (fConversionStreamerInfo.load()) {\n      std::map<std::string, TObjArray*>::iterator it;\n      std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();\n      for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {\n         delete it->second;\n      }\n      delete fConversionStreamerInfo.load();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nnamespace {\n   Int_t ReadRulesContent(FILE *f)\n   {\n      // Read a class.rules file which contains one rule per line with comment\n      // starting with a #\n      // Returns the number of rules loaded.\n      // Returns -1 in case of error.\n\n      R__ASSERT(f!=0);\n      TString rule(1024);\n      int c, state = 0;\n      Int_t count = 0;\n\n      while ((c = fgetc(f)) != EOF) {\n         if (c == 13)        // ignore CR\n            continue;\n         if (c == '\\n') {\n            if (state != 3) {\n               state = 0;\n               if (rule.Length() > 0) {\n                  if (TClass::AddRule(rule)) {\n                     ++count;\n                  }\n                  rule.Clear();\n               }\n            }\n            continue;\n         }\n         switch (state) {\n            case 0:             // start of line\n               switch (c) {\n                  case ' ':\n                  case '\\t':\n                     break;\n                  case '#':\n                     state = 1;\n                     break;\n                  default:\n                     state = 2;\n                     break;\n               }\n               break;\n\n            case 1:             // comment\n               break;\n\n            case 2:             // rule\n               switch (c) {\n                  case '\\\\':\n                     state = 3; // Continuation request\n                  default:\n                     break;\n               }\n               break;\n         }\n         switch (state) {\n            case 2:\n               rule.Append(c);\n               break;\n         }\n      }\n      return count;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read the class.rules files from the default location:.\n///     $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules)\n\nInt_t TClass::ReadRules()\n{\n   static const char *suffix = \"class.rules\";\n   TString sname = suffix;\n   gSystem->PrependPathName(TROOT::GetEtcDir(), sname);\n\n   Int_t res = -1;\n\n   FILE * f = fopen(sname,\"r\");\n   if (f != 0) {\n      res = ReadRulesContent(f);\n      fclose(f);\n   } else {\n      ::Error(\"TClass::ReadRules()\", \"Cannot find rules file %s\", sname.Data());\n   }\n   return res;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read a class.rules file which contains one rule per line with comment\n/// starting with a #\n///  - Returns the number of rules loaded.\n///  - Returns -1 in case of error.\n\nInt_t TClass::ReadRules( const char *filename )\n{\n   if (!filename || !filename[0]) {\n      ::Error(\"TClass::ReadRules\", \"no file name specified\");\n      return -1;\n   }\n\n   FILE * f = fopen(filename,\"r\");\n   if (f == 0) {\n      ::Error(\"TClass::ReadRules\",\"Failed to open %s\\n\",filename);\n      return -1;\n   }\n   Int_t count = ReadRulesContent(f);\n\n   fclose(f);\n   return count;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add a schema evolution customization rule.\n/// The syntax of the rule can be either the short form:\n/// ~~~ {.cpp}\n///  [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]\n/// ~~~\n/// or the long form\n/// ~~~ {.cpp}\n///  [type=Read] sourceClass=classname [targetclass=newClassname] [ source=\"type membername; [type2 membername2]\" ]\n///      [target=\"membername3;membername4\"] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]\n/// ~~~\n///\n/// For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:\n///   HepMC::GenVertex m_event attributes=NotOwner\n///\n/// Semantic of the tags:\n///  - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.\n///  - sourceClass : the name of the class as it is on the rule file\n///  - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass\n///  - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'\n///  - oldtype: in the short form only, indicates the type on disk of the data member.\n///  - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'\n///  - attributes : list of possible qualifiers among: Owner, NotOwner\n///  - version : list of the version of the class layout that this rule applies to.  The syntax can be [1,4,5] or [2-] or [1-3] or [-3]\n///  - checksum : comma delimited list of the checksums of the class layout that this rule applies to.\n///  - code={...} : code to be executed for the rule or name of the function implementing it.\n\nBool_t TClass::AddRule( const char *rule )\n{\n   ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();\n   if (! ruleobj->SetFromRule( rule ) ) {\n      delete ruleobj;\n      return kFALSE;\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );\n   if (!cl) {\n      // Create an empty emulated class for now.\n      cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);\n   }\n   ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );\n\n   TString errmsg;\n   if( !rset->AddRule( ruleobj, ROOT::Detail::TSchemaRuleSet::kCheckConflict, &errmsg ) ) {\n      ::Warning( \"TClass::AddRule\", \"The rule for class: \\\"%s\\\": version, \\\"%s\\\" and data members: \\\"%s\\\" has been skipped because it conflicts with one of the other rules (%s).\",\n                ruleobj->GetTargetClass(), ruleobj->GetVersion(), ruleobj->GetTargetString(), errmsg.Data() );\n      delete ruleobj;\n      return kFALSE;\n   }\n   return kTRUE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Adopt a new set of Data Model Evolution rules.\n\nvoid TClass::AdoptSchemaRules( ROOT::Detail::TSchemaRuleSet *rules )\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   delete fSchemaRules;\n   fSchemaRules = rules;\n   fSchemaRules->SetClass( this );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the set of the schema rules if any.\n\nconst ROOT::Detail::TSchemaRuleSet* TClass::GetSchemaRules() const\n{\n   return fSchemaRules;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the set of the schema rules if any.\n/// If create is true, create an empty set\n\nROOT::Detail::TSchemaRuleSet* TClass::GetSchemaRules(Bool_t create)\n{\n   if (create && fSchemaRules == 0) {\n      fSchemaRules = new ROOT::Detail::TSchemaRuleSet();\n      fSchemaRules->SetClass( this );\n   }\n   return fSchemaRules;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TClass::AddImplFile(const char* filename, int line) {\n   // Currently reset the implementation file and line.\n   // In the close future, it will actually add this file and line\n   // to a \"list\" of implementation files.\n\n   fImplFileName = filename;\n   fImplFileLine = line;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Browse external object inherited from TObject.\n/// It passes through inheritance tree and calls TBrowser::Add\n/// in appropriate cases. Static function.\n\nInt_t TClass::AutoBrowse(TObject *obj, TBrowser *b)\n{\n   if (!obj) return 0;\n\n   TAutoInspector insp(b);\n   obj->ShowMembers(insp);\n   return insp.fCount;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Browse objects of of the class described by this TClass object.\n\nInt_t TClass::Browse(void *obj, TBrowser *b) const\n{\n   if (!obj) return 0;\n\n   TClass *actual = GetActualClass(obj);\n   if (IsTObject()) {\n      // Call TObject::Browse.\n\n      if (!fIsOffsetStreamerSet) {\n         CalculateStreamerOffset();\n      }\n      TObject* realTObject = (TObject*)((size_t)obj + fOffsetStreamer);\n      realTObject->Browse(b);\n      return 1;\n   } else if (actual != this) {\n      return actual->Browse(obj, b);\n   } else if (GetCollectionProxy()) {\n\n      // do something useful.\n\n   } else {\n      TAutoInspector insp(b);\n      CallShowMembers(obj,insp,kFALSE);\n      return insp.fCount;\n   }\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// This method is called by a browser to get the class information.\n\nvoid TClass::Browse(TBrowser *b)\n{\n   if (!HasInterpreterInfo()) return;\n\n   if (b) {\n      if (!fRealData) BuildRealData();\n\n      b->Add(GetListOfDataMembers(), \"Data Members\");\n      b->Add(GetListOfRealData(), \"Real Data Members\");\n      b->Add(GetListOfMethods(), \"Methods\");\n      b->Add(GetListOfBases(), \"Base Classes\");\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Build a full list of persistent data members.\n/// Scans the list of all data members in the class itself and also\n/// in all base classes. For each persistent data member, inserts a\n/// TRealData object in the list fRealData.\n///\n\nvoid TClass::BuildRealData(void* pointer, Bool_t isTransient)\n{\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Only do this once.\n   if (fRealData) {\n      return;\n   }\n\n   if (fClassVersion == 0) {\n      isTransient = kTRUE;\n   }\n\n   // When called via TMapFile (e.g. Update()) make sure that the dictionary\n   // gets allocated on the heap and not in the mapped file.\n   TMmallocDescTemp setreset;\n\n   // Handle emulated classes and STL containers specially.\n   if (!HasInterpreterInfo() || TClassEdit::IsSTLCont(GetName(), 0) || TClassEdit::IsSTLBitset(GetName())) {\n      // We are an emulated class or an STL container.\n      fRealData = new TList;\n      BuildEmulatedRealData(\"\", 0, this);\n      return;\n   }\n\n   // return early on string\n   static TClassRef clRefString(\"std::string\");\n   if (clRefString == this) {\n      return;\n   }\n\n   // Complain about stl classes ending up here (unique_ptr etc) - except for\n   // pair where we will build .first, .second just fine\n   // and those for which the user explicitly requested a dictionary.\n   if (!isTransient && GetState() != kHasTClassInit\n       && TClassEdit::IsStdClass(GetName())\n       && strncmp(GetName(), \"pair<\", 5) != 0) {\n      Error(\"BuildRealData\", \"Inspection for %s not supported!\", GetName());\n   }\n\n   // The following statement will recursively call\n   // all the subclasses of this class.\n   fRealData = new TList;\n   TBuildRealData brd(pointer, this);\n\n   // CallShowMember will force a call to InheritsFrom, which indirectly\n   // calls TClass::GetClass.  It forces the loading of new typedefs in\n   // case some of them were not yet loaded.\n   if ( ! CallShowMembers(pointer, brd, isTransient) ) {\n      if ( isTransient ) {\n         // This is a transient data member, so it is probably fine to not have\n         // access to its content.  However let's no mark it as definitively setup,\n         // since another class might use this class for a persistent data member and\n         // in this case we really want the error message.\n         delete fRealData;\n         fRealData = 0;\n      } else {\n         Error(\"BuildRealData\", \"Cannot find any ShowMembers function for %s!\", GetName());\n      }\n   }\n\n   // Take this opportunity to build the real data for base classes.\n   // In case one base class is abstract, it would not be possible later\n   // to create the list of real data for this abstract class.\n   TBaseClass* base = 0;\n   TIter next(GetListOfBases());\n   while ((base = (TBaseClass*) next())) {\n      if (base->IsSTLContainer()) {\n         continue;\n      }\n      TClass* c = base->GetClassPointer();\n      if (c) {\n         c->BuildRealData(0, isTransient);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Build the list of real data for an emulated class\n\nvoid TClass::BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TVirtualStreamerInfo *info;\n   if (Property() & kIsAbstract) {\n      info = GetStreamerInfoAbstractEmulated();\n   } else {\n      info = GetStreamerInfo();\n   }\n   if (!info) {\n      // This class is abstract, but we don't yet have a SteamerInfo for it ...\n      Error(\"BuildEmulatedRealData\",\"Missing StreamerInfo for %s\",GetName());\n      // Humm .. no information ... let's bail out\n      return;\n   }\n\n   TIter next(info->GetElements());\n   TStreamerElement *element;\n   while ((element = (TStreamerElement*)next())) {\n      Int_t etype    = element->GetType();\n      Long_t eoffset = element->GetOffset();\n      TClass *cle    = element->GetClassPointer();\n      if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {\n         //base class are skipped in this loop, they will be added at the end.\n         continue;\n      } else if (etype == TVirtualStreamerInfo::kTObject ||\n                 etype == TVirtualStreamerInfo::kTNamed ||\n                 etype == TVirtualStreamerInfo::kObject ||\n                 etype == TVirtualStreamerInfo::kAny) {\n         //member class\n         TString rdname; rdname.Form(\"%s%s\",name,element->GetFullName());\n         TRealData *rd = new TRealData(rdname,offset+eoffset,0);\n         if (gDebug > 0) printf(\" Class: %s, adding TRealData=%s, offset=%ld\\n\",cl->GetName(),rd->GetName(),rd->GetThisOffset());\n         cl->GetListOfRealData()->Add(rd);\n         // Now we a dot\n         rdname.Form(\"%s%s.\",name,element->GetFullName());\n         if (cle) cle->BuildEmulatedRealData(rdname,offset+eoffset,cl);\n      } else {\n         //others\n         TString rdname; rdname.Form(\"%s%s\",name,element->GetFullName());\n         TRealData *rd = new TRealData(rdname,offset+eoffset,0);\n         if (gDebug > 0) printf(\" Class: %s, adding TRealData=%s, offset=%ld\\n\",cl->GetName(),rd->GetName(),rd->GetThisOffset());\n         cl->GetListOfRealData()->Add(rd);\n      }\n      //if (fClassInfo==0 && element->IsBase()) {\n      //   if (fBase==0) fBase = new TList;\n      //   TClass *base = element->GetClassPointer();\n      //   fBase->Add(new TBaseClass(this, cl, eoffset));\n      //}\n   }\n   // The base classes must added last on the list of real data (to help with ambiguous data member names)\n   next.Reset();\n   while ((element = (TStreamerElement*)next())) {\n      Int_t etype    = element->GetType();\n      if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {\n         //base class\n         Long_t eoffset = element->GetOffset();\n         TClass *cle    = element->GetClassPointer();\n         if (cle) cle->BuildEmulatedRealData(name,offset+eoffset,cl);\n      }\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Calculate the offset between an object of this class to\n/// its base class TObject. The pointer can be adjusted by\n/// that offset to access any virtual method of TObject like\n/// Streamer() and ShowMembers().\n\nvoid TClass::CalculateStreamerOffset() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (!fIsOffsetStreamerSet && HasInterpreterInfo()) {\n      // When called via TMapFile (e.g. Update()) make sure that the dictionary\n      // gets allocated on the heap and not in the mapped file.\n\n      TMmallocDescTemp setreset;\n      fOffsetStreamer = const_cast<TClass*>(this)->GetBaseClassOffsetRecurse(TObject::Class());\n      if (fStreamerType == kTObject) {\n         fStreamerImpl = &TClass::StreamerTObjectInitialized;\n      }\n      fIsOffsetStreamerSet = kTRUE;\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Call ShowMembers() on the obj of this class type, passing insp and parent.\n/// isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.\n/// The function returns whether it was able to call ShowMembers().\n\nBool_t TClass::CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const\n{\n   if (fShowMembers) {\n      // This should always works since 'pointer' should be pointing\n      // to an object of the actual type of this TClass object.\n      fShowMembers(obj, insp, isTransient);\n      return kTRUE;\n   } else {\n\n      if (fCanLoadClassInfo) LoadClassInfo();\n      if (fClassInfo) {\n\n         if (strcmp(GetName(), \"string\") == 0) {\n            // For std::string we know that we do not have a ShowMembers\n            // function and that it's okay.\n            return kTRUE;\n         }\n         // Since we do have some dictionary information, let's\n         // call the interpreter's ShowMember.\n         // This works with Cling to support interpreted classes.\n         gInterpreter->InspectMembers(insp, obj, this, isTransient);\n         return kTRUE;\n\n      } else if (TVirtualStreamerInfo* sinfo = GetStreamerInfo()) {\n         sinfo->CallShowMembers(obj, insp, isTransient);\n         return kTRUE;\n      } // isATObject\n   } // fShowMembers is set\n\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Do a ShowMembers() traversal of all members and base classes' members\n/// using the reflection information from the interpreter. Works also for\n/// interpreted objects.\n\nvoid TClass::InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient)\n{\n   return gInterpreter->InspectMembers(insp, obj, this, isTransient);\n}\n\nBool_t TClass::CanSplitBaseAllow()\n{\n   if (fCanSplit >= 0) {\n      return ! ( fCanSplit & 0x2 );\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (GetCollectionProxy() != nullptr) {\n      // A collection can never affect its derived class 'splittability'\n      return kTRUE;\n   }\n\n   if (this == TRef::Class()) { fCanSplit = 2; return kFALSE; }\n   if (this == TRefArray::Class()) { fCanSplit = 2; return kFALSE; }\n   if (this == TArray::Class()) { fCanSplit = 2; return kFALSE; }\n   if (this == TClonesArray::Class()) { fCanSplit = 1; return kTRUE; }\n   if (this == TCollection::Class()) { fCanSplit = 2; return kFALSE; }\n\n   // TTree is not always available (for example in rootcling), so we need\n   // to grab it silently.\n   auto refTreeClass( TClass::GetClass(\"TTree\",kTRUE,kTRUE) );\n   if (this == refTreeClass) { fCanSplit = 2; return kFALSE; }\n\n   if (!HasDataMemberInfo()) {\n      TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();\n      if (sinfo==0) sinfo = GetStreamerInfo();\n      TIter next(sinfo->GetElements());\n      TStreamerElement *element;\n      while ((element = (TStreamerElement*)next())) {\n         if (element->IsA() == TStreamerBase::Class()) {\n            TClass *clbase = element->GetClassPointer();\n            if (!clbase) {\n               // If there is a missing base class, we can't split the immediate\n               // derived class.\n               fCanSplit = 0;\n               return kFALSE;\n            } else if (!clbase->CanSplitBaseAllow()) {\n               fCanSplit = 2;\n               return kFALSE;\n            }\n         }\n      }\n   }\n\n   // If we don't have data member info there is no more information\n   // we can find out.\n   if (!HasDataMemberInfo()) return kTRUE;\n\n   TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : 0;\n\n   // Look at inheritance tree\n   while (lnk) {\n      TClass     *c;\n      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n      c = base->GetClassPointer();\n      if(!c) {\n         // If there is a missing base class, we can't split the immediate\n         // derived class.\n         fCanSplit = 0;\n         return kFALSE;\n      } else if (!c->CanSplitBaseAllow()) {\n         fCanSplit = 2;\n         return kFALSE;\n      }\n      lnk = lnk->Next();\n   }\n   return kTRUE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the data member of this TClass can be saved separately.\n\nBool_t TClass::CanSplit() const\n{\n   // Note: add the possibility to set it for the class and the derived class.\n   // save the info in TVirtualStreamerInfo\n   // deal with the info in MakeProject\n   if (fCanSplit >= 0) {\n      // The user explicitly set the value\n      return (fCanSplit & 0x1) == 1;\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n   TClass *This = const_cast<TClass*>(this);\n\n   if (this == TObject::Class())  { This->fCanSplit = 1; return kTRUE; }\n   if (fName == \"TClonesArray\")   { This->fCanSplit = 1; return kTRUE; }\n   if (fRefProxy)                 { This->fCanSplit = 0; return kFALSE; }\n   if (fName.BeginsWith(\"TVectorT<\")) { This->fCanSplit = 0; return kFALSE; }\n   if (fName.BeginsWith(\"TMatrixT<\")) { This->fCanSplit = 0; return kFALSE; }\n   if (fName == \"string\")         { This->fCanSplit = 0; return kFALSE; }\n   if (fName == \"std::string\")    { This->fCanSplit = 0; return kFALSE; }\n\n   if (GetCollectionProxy()!=0) {\n      // For STL collection we need to look inside.\n\n      // However we do not split collections of collections\n      // nor collections of strings\n      // nor collections of pointers (unless explicit request (see TBranchSTL)).\n\n      if (GetCollectionProxy()->HasPointers()) { This->fCanSplit = 0; return kFALSE; }\n\n      TClass *valueClass = GetCollectionProxy()->GetValueClass();\n      if (valueClass == 0) { This->fCanSplit = 0; return kFALSE; }\n      static TClassRef stdStringClass(\"std::string\");\n      if (valueClass==TString::Class() || valueClass==stdStringClass)\n         { This->fCanSplit = 0; return kFALSE; }\n      if (!valueClass->CanSplit()) { This->fCanSplit = 0; return kFALSE; }\n      if (valueClass->GetCollectionProxy() != 0) { This->fCanSplit = 0; return kFALSE; }\n\n      Int_t stl = -TClassEdit::IsSTLCont(GetName(), 0);\n      if ((stl==ROOT::kSTLmap || stl==ROOT::kSTLmultimap)\n          && !valueClass->HasDataMemberInfo()==0)\n      {\n         This->fCanSplit = 0;\n         return kFALSE;\n      }\n\n      This->fCanSplit = 1;\n      return kTRUE;\n\n   }\n\n   if (GetStreamer()!=0) {\n\n      // We have an external custom streamer provided by the user, we must not\n      // split it.\n      This->fCanSplit = 0;\n      return kFALSE;\n\n   } else if ( TestBit(TClass::kHasCustomStreamerMember) ) {\n\n      // We have a custom member function streamer or\n      // an older (not StreamerInfo based) automatic streamer.\n      This->fCanSplit = 0;\n      return kFALSE;\n   }\n\n   if (Size()==1) {\n      // 'Empty' class there is nothing to split!.\n      This->fCanSplit = 0;\n      return kFALSE;\n   }\n\n\n   if ( !This->CanSplitBaseAllow() ) {\n      return kFALSE;\n   }\n\n   This->fCanSplit = 1;\n   return kTRUE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the C++ property of this class, eg. is abstract, has virtual base\n/// class, see EClassProperty in TDictionary.h\n\nLong_t TClass::ClassProperty() const\n{\n   if (fProperty == -1) Property();\n   return fClassProperty;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a Clone of this TClass object using a different name but using the same 'dictionary'.\n/// This effectively creates a hard alias for the class name.\n\nTObject *TClass::Clone(const char *new_name) const\n{\n   if (new_name == 0 || new_name[0]=='\\0' || fName == new_name) {\n      Error(\"Clone\",\"The name of the class must be changed when cloning a TClass object.\");\n      return 0;\n   }\n\n   // Need to lock access to TROOT::GetListOfClasses so the cloning happens atomically\n   R__LOCKGUARD(gInterpreterMutex);\n   // Temporarily remove the original from the list of classes.\n   TClass::RemoveClass(const_cast<TClass*>(this));\n\n   TClass *copy;\n   if (fTypeInfo) {\n      copy = new TClass(GetName(),\n                        fClassVersion,\n                        *fTypeInfo,\n                        new TIsAProxy(*fTypeInfo),\n                        GetDeclFileName(),\n                        GetImplFileName(),\n                        GetDeclFileLine(),\n                        GetImplFileLine());\n   } else {\n      copy = new TClass(GetName(),\n                        fClassVersion,\n                        GetDeclFileName(),\n                        GetImplFileName(),\n                        GetDeclFileLine(),\n                        GetImplFileLine());\n   }\n   copy->fShowMembers = fShowMembers;\n   // Remove the copy before renaming it\n   TClass::RemoveClass(copy);\n   copy->fName = new_name;\n   TClass::AddClass(copy);\n\n   copy->SetNew(fNew);\n   copy->SetNewArray(fNewArray);\n   copy->SetDelete(fDelete);\n   copy->SetDeleteArray(fDeleteArray);\n   copy->SetDestructor(fDestructor);\n   copy->SetDirectoryAutoAdd(fDirAutoAdd);\n   copy->fStreamerFunc = fStreamerFunc;\n   copy->fConvStreamerFunc = fConvStreamerFunc;\n   if (fStreamer) {\n      copy->AdoptStreamer(fStreamer->Generate());\n   }\n   // If IsZombie is true, something went wrong and we will not be\n   // able to properly copy the collection proxy\n   if (fCollectionProxy && !copy->IsZombie()) {\n      copy->CopyCollectionProxy(*fCollectionProxy);\n   }\n   copy->SetClassSize(fSizeof);\n   if (fRefProxy) {\n      copy->AdoptReferenceProxy( fRefProxy->Clone() );\n   }\n   TClass::AddClass(const_cast<TClass*>(this));\n   return copy;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Copy the argument.\n\nvoid TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig)\n{\n//     // This code was used too quickly test the STL Emulation layer\n//    Int_t k = TClassEdit::IsSTLCont(GetName());\n//    if (k==1||k==-1) return;\n\n   delete fCollectionProxy;\n   fCollectionProxy = orig.Generate();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Draw detailed class inheritance structure.\n/// If a class B inherits from a class A, the description of B is drawn\n/// on the right side of the description of A.\n/// Member functions overridden by B are shown in class A with a blue line\n/// erasing the corresponding member function\n\nvoid TClass::Draw(Option_t *option)\n{\n   if (!HasInterpreterInfo()) return;\n\n   TVirtualPad *padsav = gPad;\n\n   // Should we create a new canvas?\n   TString opt=option;\n   if (!padsav || !opt.Contains(\"same\")) {\n      TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(\"R__class\");\n      if (!padclass) {\n         gROOT->ProcessLine(\"new TCanvas(\\\"R__class\\\",\\\"class\\\",20,20,1000,750);\");\n      } else {\n         padclass->cd();\n      }\n   }\n\n   if (gPad) gPad->DrawClassObject(this,option);\n\n   if (padsav) padsav->cd();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Dump contents of object on stdout.\n/// Using the information in the object dictionary\n/// each data member is interpreted.\n/// If a data member is a pointer, the pointer value is printed\n/// 'obj' is assume to point to an object of the class describe by this TClass\n///\n/// The following output is the Dump of a TArrow object:\n/// ~~~ {.cpp}\n///   fAngle                   0           Arrow opening angle (degrees)\n///   fArrowSize               0.2         Arrow Size\n///   fOption.*fData\n///   fX1                      0.1         X of 1st point\n///   fY1                      0.15        Y of 1st point\n///   fX2                      0.67        X of 2nd point\n///   fY2                      0.83        Y of 2nd point\n///   fUniqueID                0           object unique identifier\n///   fBits                    50331648    bit field status word\n///   fLineColor               1           line color\n///   fLineStyle               1           line style\n///   fLineWidth               1           line width\n///   fFillColor               19          fill area color\n///   fFillStyle               1001        fill area style\n/// ~~~\n///\n/// If noAddr is true, printout of all pointer values is skipped.\n\nvoid TClass::Dump(const void *obj, Bool_t noAddr /*=kFALSE*/) const\n{\n\n   Long_t prObj = noAddr ? 0 : (Long_t)obj;\n   if (IsTObject()) {\n      if (!fIsOffsetStreamerSet) {\n         CalculateStreamerOffset();\n      }\n      TObject *tobj = (TObject*)((Long_t)obj + fOffsetStreamer);\n\n\n      if (sizeof(this) == 4)\n         Printf(\"==> Dumping object at: 0x%08lx, name=%s, class=%s\\n\",prObj,tobj->GetName(),GetName());\n      else\n         Printf(\"==> Dumping object at: 0x%016lx, name=%s, class=%s\\n\",prObj,tobj->GetName(),GetName());\n   } else {\n\n      if (sizeof(this) == 4)\n         Printf(\"==> Dumping object at: 0x%08lx, class=%s\\n\",prObj,GetName());\n      else\n         Printf(\"==> Dumping object at: 0x%016lx, class=%s\\n\",prObj,GetName());\n   }\n\n   TDumpMembers dm(noAddr);\n   if (!CallShowMembers(obj, dm, kFALSE)) {\n      Info(\"Dump\", \"No ShowMembers function, dumping disabled\");\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Introduce an escape character (@) in front of a special chars.\n/// You need to use the result immediately before it is being overwritten.\n\nchar *TClass::EscapeChars(const char *text) const\n{\n   static const UInt_t maxsize = 255;\n   static char name[maxsize+2]; //One extra if last char needs to be escaped\n\n   UInt_t nch = strlen(text);\n   UInt_t icur = 0;\n   for (UInt_t i = 0; i < nch && icur < maxsize; ++i, ++icur) {\n      if (text[i] == '\\\"' || text[i] == '[' || text[i] == '~' ||\n          text[i] == ']'  || text[i] == '&' || text[i] == '#' ||\n          text[i] == '!'  || text[i] == '^' || text[i] == '<' ||\n          text[i] == '?'  || text[i] == '>') {\n         name[icur] = '@';\n         ++icur;\n      }\n      name[icur] = text[i];\n   }\n   name[icur] = 0;\n   return name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer the the real class of the object.\n/// This is equivalent to object->IsA() when the class has a ClassDef.\n/// It is REQUIRED that object is coming from a proper pointer to the\n/// class represented by 'this'.\n/// Example: Special case:\n/// ~~~ {.cpp}\n///    class MyClass : public AnotherClass, public TObject\n/// ~~~\n/// then on return, one must do:\n/// ~~~ {.cpp}\n///    TObject *obj = (TObject*)((void*)myobject)directory->Get(\"some object of MyClass\");\n///    MyClass::Class()->GetActualClass(obj); // this would be wrong!!!\n/// ~~~\n/// Also if the class represented by 'this' and NONE of its parents classes\n/// have a virtual ptr table, the result will be 'this' and NOT the actual\n/// class.\n\nTClass *TClass::GetActualClass(const void *object) const\n{\n   if (object==0) return (TClass*)this;\n   if (fIsA) {\n      return (*fIsA)(object); // ROOT::IsA((ThisClass*)object);\n   } else if (fGlobalIsA) {\n      return fGlobalIsA(this,object);\n   } else {\n      if (IsTObject()) {\n\n         if (!fIsOffsetStreamerSet) {\n            CalculateStreamerOffset();\n         }\n         TObject* realTObject = (TObject*)((size_t)object + fOffsetStreamer);\n\n         return realTObject->IsA();\n      }\n\n      if (HasInterpreterInfo()) {\n\n         TVirtualIsAProxy *isa = 0;\n         if (GetClassInfo() && gCling->ClassInfo_HasMethod(fClassInfo,\"IsA\")) {\n            isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format(\"new ::TInstrumentedIsAProxy<%s>(0);\",GetName()));\n         }\n         else {\n            isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format(\"new ::TIsAProxy(typeid(%s));\",GetName()));\n         }\n         if (isa) {\n            R__LOCKGUARD(gInterpreterMutex);\n            const_cast<TClass*>(this)->fIsA = isa;\n         }\n         if (fIsA) {\n            return (*fIsA)(object); // ROOT::IsA((ThisClass*)object);\n         }\n      }\n      TVirtualStreamerInfo* sinfo = GetStreamerInfo();\n      if (sinfo) {\n         return sinfo->GetActualClass(object);\n      }\n      return (TClass*)this;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to the base class \"classname\". Returns 0 in case\n/// \"classname\" is not a base class. Takes care of multiple inheritance.\n\nTClass *TClass::GetBaseClass(const char *classname)\n{\n   // check if class name itself is equal to classname\n   if (strcmp(GetName(), classname) == 0) return this;\n\n   if (!HasDataMemberInfo()) return 0;\n\n   // Make sure we deal with possible aliases, we could also have normalized\n   // the name.\n   TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);\n\n   if (search) return GetBaseClass(search);\n   else return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to the base class \"cl\". Returns 0 in case \"cl\"\n/// is not a base class. Takes care of multiple inheritance.\n\nTClass *TClass::GetBaseClass(const TClass *cl)\n{\n   // check if class name itself is equal to classname\n   if (cl == this) return this;\n\n   if (!HasDataMemberInfo()) return 0;\n\n   TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : 0;\n\n   // otherwise look at inheritance tree\n   while (lnk) {\n      TClass     *c, *c1;\n      TBaseClass *base = (TBaseClass*) lnk->GetObject();\n      c = base->GetClassPointer();\n      if (c) {\n         if (cl == c) return c;\n         c1 = c->GetBaseClass(cl);\n         if (c1) return c1;\n      }\n      lnk = lnk->Next();\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return data member offset to the base class \"cl\".\n///  - Returns -1 in case \"cl\" is not a base class.\n///  - Returns -2 if cl is a base class, but we can't find the offset\n///    because it's virtual.\n/// Takes care of multiple inheritance.\n\nInt_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)\n{\n   // check if class name itself is equal to classname\n   if (cl == this) return 0;\n\n   if (!fBase.load()) {\n      if (fCanLoadClassInfo) LoadClassInfo();\n      // If the information was not provided by the root pcm files and\n      // if we can not find the ClassInfo, we have to fall back to the\n      // StreamerInfo\n      if (!fClassInfo) {\n         TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();\n         if (!sinfo) return -1;\n         TStreamerElement *element;\n         Int_t offset = 0;\n\n         TObjArray &elems = *(sinfo->GetElements());\n         Int_t size = elems.GetLast()+1;\n         for(Int_t i=0; i<size; i++) {\n            element = (TStreamerElement*)elems[i];\n            if (element->IsBase()) {\n               if (element->IsA() == TStreamerBase::Class()) {\n                  TStreamerBase *base = (TStreamerBase*)element;\n                  TClass *baseclass = base->GetClassPointer();\n                  if (!baseclass) return -1;\n                  Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);\n                  if (subOffset == -2) return -2;\n                  if (subOffset != -1) return offset+subOffset;\n                  offset += baseclass->Size();\n               } else if (element->IsA() == TStreamerSTL::Class()) {\n                  TStreamerSTL *base = (TStreamerSTL*)element;\n                  TClass *baseclass = base->GetClassPointer();\n                  if (!baseclass) return -1;\n                  Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);\n                  if (subOffset == -2) return -2;\n                  if (subOffset != -1) return offset+subOffset;\n                  offset += baseclass->Size();\n\n               } else {\n                  Error(\"GetBaseClassOffsetRecurse\",\"Unexpected element type for base class: %s\\n\",element->IsA()->GetName());\n               }\n            }\n         }\n         return -1;\n      }\n   }\n\n   TClass     *c;\n   Int_t      off;\n   TBaseClass *inh;\n   TObjLink *lnk = 0;\n   if (fBase.load() == 0)\n      lnk = GetListOfBases()->FirstLink();\n   else\n      lnk = fBase.load()->FirstLink();\n\n   // otherwise look at inheritance tree\n   while (lnk) {\n      inh = (TBaseClass *)lnk->GetObject();\n      //use option load=kFALSE to avoid a warning like:\n      //\"Warning in <TClass::TClass>: no dictionary for class TRefCnt is available\"\n      //We can not afford to not have the class if it exist, so we\n      //use kTRUE.\n      c = inh->GetClassPointer(kTRUE); // kFALSE);\n      if (c) {\n         if (cl == c) {\n            if ((inh->Property() & kIsVirtualBase) != 0)\n               return -2;\n            return inh->GetDelta();\n         }\n         off = c->GetBaseClassOffsetRecurse(cl);\n         if (off == -2) return -2;\n         if (off != -1) {\n            return off + inh->GetDelta();\n         }\n      }\n      lnk = lnk->Next();\n   }\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///  - Return data member offset to the base class \"cl\".\n///  - Returns -1 in case \"cl\" is not a base class.\n/// Takes care of multiple inheritance.\n\nInt_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject)\n{\n   // Warning(\"GetBaseClassOffset\",\"Requires the use of fClassInfo for %s to %s\",GetName(),toBase->GetName());\n\n   if (this == toBase) return 0;\n\n   if ((!address /* || !has_virtual_base */) &&\n       (!HasInterpreterInfoInMemory() || !toBase->HasInterpreterInfoInMemory())) {\n      // At least of the ClassInfo have not been loaded in memory yet and\n      // since there is no virtual base class (or we don't have enough so it\n      // would not make a difference) we can use the 'static' information\n      Int_t offset = GetBaseClassOffsetRecurse (toBase);\n      if (offset != -2) {\n         return offset;\n      }\n      return offset;\n   }\n\n   ClassInfo_t* derived = GetClassInfo();\n   ClassInfo_t* base = toBase->GetClassInfo();\n   if(derived && base) {\n      // TClingClassInfo::GetBaseOffset takes the lock.\n      return gCling->ClassInfo_GetBaseOffset(derived, base, address, isDerivedObject);\n   }\n   else {\n      Int_t offset = GetBaseClassOffsetRecurse (toBase);\n      if (offset != -2) {\n         return offset;\n      }\n   }\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to (base) class that contains datamember.\n\nTClass *TClass::GetBaseDataMember(const char *datamember)\n{\n   if (!HasDataMemberInfo()) return 0;\n\n   // Check if data member exists in class itself\n   TDataMember *dm = GetDataMember(datamember);\n   if (dm) return this;\n\n   // if datamember not found in class, search in next base classes\n   TBaseClass *inh;\n   TIter       next(GetListOfBases());\n   while ((inh = (TBaseClass *) next())) {\n      TClass *c = inh->GetClassPointer();\n      if (c) {\n         TClass *cdm = c->GetBaseDataMember(datamember);\n         if (cdm) return cdm;\n      }\n   }\n\n   return 0;\n}\n\nnamespace {\n   // A local Helper class used to keep 2 pointer (the collection proxy\n   // and the class streamer) in the thread local storage.\n\n   struct TClassLocalStorage {\n      TClassLocalStorage() : fCollectionProxy(0), fStreamer(0) {};\n\n      TVirtualCollectionProxy *fCollectionProxy;\n      TClassStreamer          *fStreamer;\n\n      static TClassLocalStorage *GetStorage(const TClass *cl)\n      {\n         // Return the thread storage for the TClass.\n\n         void **thread_ptr = (*gThreadTsd)(0,ROOT::kClassThreadSlot);\n         if (thread_ptr) {\n            if (*thread_ptr==0) *thread_ptr = new TExMap();\n            TExMap *lmap = (TExMap*)(*thread_ptr);\n            ULong_t hash = TString::Hash(&cl, sizeof(void*));\n            ULong_t local = 0;\n            UInt_t slot;\n            if ((local = (ULong_t)lmap->GetValue(hash, (Long_t)cl, slot)) != 0) {\n            } else {\n               local = (ULong_t) new TClassLocalStorage();\n               lmap->AddAt(slot, hash, (Long_t)cl, local);\n            }\n            return (TClassLocalStorage*)local;\n         }\n         return 0;\n      }\n   };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the 'type' of the STL the TClass is representing.\n/// and return ROOT::kNotSTL if it is not representing an STL collection.\n\nROOT::ESTLType TClass::GetCollectionType() const\n{\n   auto proxy = GetCollectionProxy();\n   if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();\n   return ROOT::kNotSTL;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the proxy describing the collection (if any).\n\nTVirtualCollectionProxy *TClass::GetCollectionProxy() const\n{\n   // Use assert, so that this line (slow because of the TClassEdit) is completely\n   // removed in optimized code.\n   assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == \"The TClass for the STL collection has no collection proxy!\");\n   if (gThreadTsd && fCollectionProxy) {\n      TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);\n      if (local == 0) return fCollectionProxy;\n      if (local->fCollectionProxy==0) local->fCollectionProxy = fCollectionProxy->Generate();\n      return local->fCollectionProxy;\n   }\n   return fCollectionProxy;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the Streamer Class allowing streaming (if any).\n\nTClassStreamer *TClass::GetStreamer() const\n{\n   if (gThreadTsd && fStreamer) {\n      TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);\n      if (local==0) return fStreamer;\n      if (local->fStreamer==0) {\n         local->fStreamer = fStreamer->Generate();\n         const std::type_info &orig = ( typeid(*fStreamer) );\n         if (!local->fStreamer) {\n            Warning(\"GetStreamer\",\"For %s, the TClassStreamer (%s) passed's call to Generate failed!\",GetName(),orig.name());\n         } else {\n            const std::type_info &copy = ( typeid(*local->fStreamer) );\n            if (strcmp(orig.name(),copy.name())!=0) {\n               Warning(\"GetStreamer\",\"For %s, the TClassStreamer passed does not properly implement the Generate method (%s vs %s)\\n\",GetName(),orig.name(),copy.name());\n            }\n         }\n      }\n      return local->fStreamer;\n   }\n   return fStreamer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get a wrapper/accessor function around this class custom streamer (member function).\n\nClassStreamerFunc_t TClass::GetStreamerFunc() const\n{\n   return fStreamerFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get a wrapper/accessor function around this class custom conversion streamer (member function).\n\nClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const\n{\n   return fConvStreamerFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the proxy implementing the IsA functionality.\n\nTVirtualIsAProxy* TClass::GetIsAProxy() const\n{\n   return fIsA;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Static method returning pointer to TClass of the specified class name.\n/// If load is true an attempt is made to obtain the class by loading\n/// the appropriate shared library (directed by the rootmap file).\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n/// Returns 0 in case class is not found.\n\nTClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)\n{\n   if (!name || !name[0]) return 0;\n\n   if (strstr(name, \"(anonymous)\")) return 0;\n   if (strncmp(name,\"class \",6)==0) name += 6;\n   if (strncmp(name,\"struct \",7)==0) name += 7;\n\n   if (!gROOT->GetListOfClasses())  return 0;\n\n   // FindObject will take the read lock before actually getting the\n   // TClass pointer so we will need not get a partially initialized\n   // object.\n   TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);\n\n   // Early return to release the lock without having to execute the\n   // long-ish normalization.\n   if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;\n\n   R__WRITE_LOCKGUARD(ROOT::gCoreMutex);\n\n   // Now that we got the write lock, another thread may have constructed the\n   // TClass while we were waiting, so we need to do the checks again.\n\n   cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);\n   if (cl) {\n      if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;\n\n      // We could speed-up some of the search by adding (the equivalent of)\n      //\n      //    if (cl->GetState() == kInterpreter) return cl\n      //\n      // In this case, if a ROOT dictionary was available when the TClass\n      // was first requested it would have been used and if a ROOT dictionary is\n      // loaded later on TClassTable::Add will take care of updating the TClass.\n      // So as far as ROOT dictionary are concerned, if the current TClass is\n      // in interpreted state, we are sure there is nothing to load.\n      //\n      // However (see TROOT::LoadClass), the TClass can also be loaded/provided\n      // by a user provided TClassGenerator.  We have no way of knowing whether\n      // those do (or even can) behave the same way as the ROOT dictionary and\n      // have the 'dictionary is now available for use' step informs the existing\n      // TClass that their dictionary is now available.\n\n      //we may pass here in case of a dummy class created by TVirtualStreamerInfo\n      load = kTRUE;\n   }\n\n   // To avoid spurious auto parsing, let's check if the name as-is is\n   // known in the TClassTable.\n   DictFuncPtr_t dict = TClassTable::GetDictNorm(name);\n   if (dict) {\n      // The name is normalized, so the result of the first search is\n      // authoritative.\n      if (!cl && !load) return 0;\n\n      TClass *loadedcl = (dict)();\n      if (loadedcl) {\n         loadedcl->PostLoadCheck();\n         return loadedcl;\n      }\n\n      // We should really not fall through to here, but if we do, let's just\n      // continue as before ...\n   }\n\n   std::string normalizedName;\n   Bool_t checkTable = kFALSE;\n\n   if (!cl) {\n      int oldAutoloadVal = gCling->SetClassAutoloading(false);\n      TClassEdit::GetNormalizedName(normalizedName, name);\n      gCling->SetClassAutoloading(oldAutoloadVal);\n      // Try the normalized name.\n      if (normalizedName != name) {\n         cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());\n\n         if (cl) {\n            if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;\n\n            //we may pass here in case of a dummy class created by TVirtualStreamerInfo\n            load = kTRUE;\n         }\n         checkTable = kTRUE;\n     }\n   } else {\n      normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.\n      checkTable = load && (normalizedName != name);\n   }\n\n   if (!load) return 0;\n\n// This assertion currently fails because of\n//   TClass *c1 = TClass::GetClass(\"basic_iostream<char,char_traits<char> >\");\n//   TClass *c2 = TClass::GetClass(\"std::iostream\");\n// where the TClassEdit normalized name of iostream is basic_iostream<char>\n// i.e missing the addition of the default parameter.  This is because TClingLookupHelper\n// uses only 'part' of TMetaUtils::GetNormalizedName.\n\n//   if (!cl) {\n//      TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);\n//      TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;\n//      if (altcl && normalizedName != altcl->GetName())\n//         ::Fatal(\"TClass::GetClass\",\"The existing name (%s) for %s is different from the normalized name: %s\\n\",\n//                 altcl->GetName(), name, normalizedName.c_str());\n//   }\n\n   TClass *loadedcl = 0;\n   if (checkTable) {\n      loadedcl = LoadClassDefault(normalizedName.c_str(),silent);\n   } else {\n      if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {\n         loadedcl = LoadClassDefault(normalizedName.c_str(),silent);\n      }\n      // Maybe this was a typedef: let's try to see if this is the case\n      if (!loadedcl){\n         if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){\n            // We have a typedef: we get the name of the underlying type\n            auto underlyingTypeName = theDataType->GetTypeName();\n            // We see if we can bootstrap a class with it\n            auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());\n            if (underlyingTypeDict){\n               loadedcl = underlyingTypeDict();\n            }\n\n         }\n      }\n   }\n   if (loadedcl) return loadedcl;\n\n   // See if the TClassGenerator can produce the TClass we need.\n   loadedcl = LoadClassCustom(normalizedName.c_str(),silent);\n   if (loadedcl) return loadedcl;\n\n   // We have not been able to find a loaded TClass, return the Emulated\n   // TClass if we have one.\n   if (cl) return cl;\n\n   if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {\n\n      return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);\n   }\n\n   // Check the interpreter only after autoparsing the template if any.\n   {\n      std::string::size_type posLess = normalizedName.find('<');\n      if (posLess != std::string::npos) {\n         gCling->AutoParse(normalizedName.substr(0, posLess).c_str());\n      }\n   }\n\n   //last attempt. Look in CINT list of all (compiled+interpreted) classes\n   if (gDebug>0){\n      printf(\"TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\\n\",normalizedName.c_str(), normalizedName.c_str());\n   }\n   if (normalizedName.length()) {\n      auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,\n                                              kTRUE /*Only class, structs and ns*/);\n\n      // We could have an interpreted class with an inline ClassDef, in this case we do not\n      // want to create an 'interpreted' TClass but we want the one triggered via the call to\n      // the Dictionary member.  If we go ahead and generate the 'interpreted' version it will\n      // replace if/when there is a call to IsA on an object of this type.\n\n      if (cci == TInterpreter::kWithClassDefInline) {\n         auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());\n         auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, \"Dictionary\", \"\", false, ROOT::kExactMatch);\n         auto method = gInterpreter->MethodInfo_Factory(funcDecl);\n         typedef void (*tcling_callfunc_Wrapper_t)(void *, int, void **, void *);\n         auto funcPtr = (tcling_callfunc_Wrapper_t)gInterpreter->MethodInfo_InterfaceMethod(method);\n\n         TClass *res = nullptr;\n         if (funcPtr)\n            funcPtr(0, 0, nullptr, &res);\n         // else\n         //   We could fallback to the interpreted case ...\n         //   For now just 'fail' (return nullptr)\n\n         gInterpreter->MethodInfo_Delete(method);\n         gInterpreter->ClassInfo_Delete(ci);\n\n         return res;\n      } else if (cci) {\n         // Get the normalized name based on the decl (currently the only way\n         // to get the part to add or drop the default arguments as requested by the user)\n         std::string alternative;\n         gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);\n         const char *altname = alternative.c_str();\n         if (strncmp(altname, \"std::\", 5) == 0) {\n            // For namespace (for example std::__1), GetInterpreterTypeName does\n            // not strip std::, so we must do it explicitly here.\n            altname += 5;\n         }\n         if (altname != normalizedName && strcmp(altname, name) != 0) {\n            // altname now contains the full name of the class including a possible\n            // namespace if there has been a using namespace statement.\n\n            // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname)\n            // the TClassEdit normalization and the TMetaUtils normalization leads to\n            // two different space layout.  To avoid an infinite recursion, we also\n            // add the test on (altname != name)\n\n            return GetClass(altname, load);\n         }\n\n         TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);\n         if (!ncl->IsZombie()) {\n            return ncl;\n         }\n         delete ncl;\n      }\n   }\n   return nullptr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to class with name.\n\nTClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */)\n{\n   if (!gROOT->GetListOfClasses())\n      return 0;\n\n   //protect access to TROOT::GetIdMap\n   R__READ_LOCKGUARD(ROOT::gCoreMutex);\n\n   TClass* cl = GetIdMap()->Find(typeinfo.name());\n\n   if (cl && cl->IsLoaded()) return cl;\n\n   R__WRITE_LOCKGUARD(ROOT::gCoreMutex);\n\n   // Now that we got the write lock, another thread may have constructed the\n   // TClass while we were waiting, so we need to do the checks again.\n\n   cl = GetIdMap()->Find(typeinfo.name());\n\n   if (cl) {\n      if (cl->IsLoaded()) return cl;\n      //we may pass here in case of a dummy class created by TVirtualStreamerInfo\n      load = kTRUE;\n   } else {\n     // Note we might need support for typedefs and simple types!\n\n     //      TDataType *objType = GetType(name, load);\n     //if (objType) {\n     //    const char *typdfName = objType->GetTypeName();\n     //    if (typdfName && strcmp(typdfName, name)) {\n     //       cl = GetClass(typdfName, load);\n     //       return cl;\n     //    }\n     // }\n   }\n\n   if (!load) return 0;\n\n   DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);\n   if (dict) {\n      cl = (dict)();\n      if (cl) cl->PostLoadCheck();\n      return cl;\n   }\n   if (cl) return cl;\n\n   TIter next(gROOT->GetListOfClassGenerators());\n   TClassGenerator *gen;\n   while( (gen = (TClassGenerator*) next()) ) {\n      cl = gen->GetClass(typeinfo,load);\n      if (cl) {\n         cl->PostLoadCheck();\n         return cl;\n      }\n   }\n\n   // try autoloading the typeinfo\n   int autoload_old = gCling->SetClassAutoloading(1);\n   if (!autoload_old) {\n      // Re-disable, we just meant to test\n      gCling->SetClassAutoloading(0);\n   }\n   if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {\n      // Disable autoload to avoid potential infinite recursion\n      gCling->SetClassAutoloading(0);\n      cl = GetClass(typeinfo, load);\n      gCling->SetClassAutoloading(1);\n      if (cl) {\n         return cl;\n      }\n   }\n\n   // last attempt. Look in the interpreter list of all (compiled+interpreted)\n   // classes\n   cl = gInterpreter->GetClass(typeinfo, load);\n\n   return cl; // Can be zero.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Static method returning pointer to TClass of the specified ClassInfo.\n/// If load is true an attempt is made to obtain the class by loading\n/// the appropriate shared library (directed by the rootmap file).\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n/// Returns 0 in case class is not found.\n\nTClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent)\n{\n   if (!info || !gCling->ClassInfo_IsValid(info)) return 0;\n   if (!gROOT->GetListOfClasses())    return 0;\n\n   // Technically we need the write lock only for the call to ClassInfo_FullName\n   // and GenerateTClass but FindObject will take the read lock (and LoadClass will\n   // take the write lock).  Since taking/releasing the lock is expensive, let just\n   // take the write guard and keep it.\n   R__WRITE_LOCKGUARD(ROOT::gCoreMutex);\n\n   // Get the normalized name.\n   TString name( gCling->ClassInfo_FullName(info) );\n\n   TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);\n\n   if (cl) {\n      if (cl->IsLoaded()) return cl;\n\n      //we may pass here in case of a dummy class created by TVirtualStreamerInfo\n      load = kTRUE;\n\n   }\n\n   if (!load) return 0;\n\n   TClass *loadedcl = 0;\n   if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);\n   else    loadedcl = gROOT->LoadClass(name,silent);\n\n   if (loadedcl) return loadedcl;\n\n   if (cl) return cl;  // If we found the class but we already have a dummy class use it.\n\n   // We did not find a proper TClass but we do know (we have a valid\n   // ClassInfo) that the class is known to the interpreter.\n   TClass *ncl = gInterpreter->GenerateTClass(info, silent);\n   if (!ncl->IsZombie()) {\n      return ncl;\n   } else {\n      delete ncl;\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){\n   return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TClass::GetClass(DeclId_t id, std::vector<TClass*> &classes)\n{\n   if (!gROOT->GetListOfClasses())    return 0;\n\n   DeclIdMap_t* map = GetDeclIdMap();\n   // Get all the TClass pointer that have the same DeclId.\n   DeclIdMap_t::equal_range iter = map->Find(id);\n   if (iter.first == iter.second) return false;\n   std::vector<TClass*>::iterator vectIt = classes.begin();\n   for (DeclIdMap_t::const_iterator it = iter.first; it != iter.second; ++it)\n      vectIt = classes.insert(vectIt, it->second);\n   return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the dictionary loading function generated by\n/// rootcint\n\nDictFuncPtr_t  TClass::GetDict (const char *cname)\n{\n   return TClassTable::GetDict(cname);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the dictionary loading function generated by\n/// rootcint\n\nDictFuncPtr_t  TClass::GetDict (const std::type_info& info)\n{\n   return TClassTable::GetDict(info);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to datamember object with name \"datamember\".\n\nTDataMember *TClass::GetDataMember(const char *datamember) const\n{\n   if ((!(fData && fData->IsLoaded()) && !HasInterpreterInfo())\n       || datamember == 0) return 0;\n\n   // Strip off leading *'s and trailing [\n   const char *start_name = datamember;\n   while (*start_name == '*') ++start_name;\n\n   // Empty name are 'legal', they represent anonymous unions.\n   //   if (*start_name == 0) return 0;\n\n   if (const char *s = strchr(start_name, '[')){\n      UInt_t len = s-start_name;\n      TString name(start_name,len);\n      return (TDataMember *)((TClass*)this)->GetListOfDataMembers(kFALSE)->FindObject(name.Data());\n   } else {\n      return (TDataMember *)((TClass*)this)->GetListOfDataMembers(kFALSE)->FindObject(start_name);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// return offset for member name. name can be a data member in\n/// the class itself, one of its base classes, or one member in\n/// one of the aggregated classes.\n///\n/// In case of an emulated class, the list of emulated TRealData is built\n\nLong_t TClass::GetDataMemberOffset(const char *name) const\n{\n   TRealData *rd = GetRealData(name);\n   if (rd) return rd->GetThisOffset();\n   if (strchr(name,'[')==0) {\n      // If this is a simple name there is a chance to find it in the\n      // StreamerInfo even if we did not find it in the RealData.\n      // For example an array name would be fArray[3] in RealData but\n      // just fArray in the streamerInfo.\n      TVirtualStreamerInfo *info = const_cast<TClass*>(this)->GetCurrentStreamerInfo();\n      if (info) {\n         return info->GetOffset(name);\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to TRealData element with name \"name\".\n///\n/// Name can be a data member in the class itself,\n/// one of its base classes, or a member in\n/// one of the aggregated classes.\n///\n/// In case of an emulated class, the list of emulated TRealData is built.\n\nTRealData* TClass::GetRealData(const char* name) const\n{\n   if (!fRealData) {\n      const_cast<TClass*>(this)->BuildRealData();\n   }\n\n   if (!fRealData) {\n      return 0;\n   }\n\n   if (!name) {\n      return 0;\n   }\n\n   // First try just the whole name.\n   TRealData* rd = (TRealData*) fRealData->FindObject(name);\n   if (rd) {\n      return rd;\n   }\n\n   std::string givenName(name);\n\n   // Try ignoring the array dimensions.\n   std::string::size_type firstBracket = givenName.find_first_of(\"[\");\n   if (firstBracket != std::string::npos) {\n      // -- We are looking for an array data member.\n      std::string nameNoDim(givenName.substr(0, firstBracket));\n      TObjLink* lnk = fRealData->FirstLink();\n      while (lnk) {\n         TObject* obj = lnk->GetObject();\n         std::string objName(obj->GetName());\n         std::string::size_type pos = objName.find_first_of(\"[\");\n         // Only match arrays to arrays for now.\n         if (pos != std::string::npos) {\n            objName.erase(pos);\n            if (objName == nameNoDim) {\n               return static_cast<TRealData*>(obj);\n            }\n         }\n         lnk = lnk->Next();\n      }\n   }\n\n   // Now try it as a pointer.\n   std::ostringstream ptrname;\n   ptrname << \"*\" << givenName;\n   rd = (TRealData*) fRealData->FindObject(ptrname.str().c_str());\n   if (rd) {\n      return rd;\n   }\n\n   // Check for a dot in the name.\n   std::string::size_type firstDot = givenName.find_first_of(\".\");\n   if (firstDot == std::string::npos) {\n      // -- Not found, a simple name, all done.\n      return 0;\n   }\n\n   //\n   //  At this point the name has a dot in it, so it is the name\n   //  of some contained sub-object.\n   //\n\n   // May be a pointer like in TH1: fXaxis.fLabels (in TRealdata is named fXaxis.*fLabels)\n   std::string::size_type lastDot = givenName.find_last_of(\".\");\n   std::ostringstream starname;\n   starname << givenName.substr(0, lastDot) << \".*\" << givenName.substr(lastDot + 1);\n   rd = (TRealData*) fRealData->FindObject(starname.str().c_str());\n   if (rd) {\n      return rd;\n   }\n\n   // Strip the first component, it may be the name of\n   // the branch (old TBranchElement code), and try again.\n   std::string firstDotName(givenName.substr(firstDot + 1));\n\n   // New attempt starting after the first \".\" if any,\n   // this allows for the case that the first component\n   // may have been a branch name (for TBranchElement).\n   rd = (TRealData*) fRealData->FindObject(firstDotName.c_str());\n   if (rd) {\n      return rd;\n   }\n\n   // New attempt starting after the first \".\" if any,\n   // but this time try ignoring the array dimensions.\n   // Again, we are allowing for the case that the first\n   // component may have been a branch name (for TBranchElement).\n   std::string::size_type firstDotBracket = firstDotName.find_first_of(\"[\");\n   if (firstDotBracket != std::string::npos) {\n      // -- We are looking for an array data member.\n      std::string nameNoDim(firstDotName.substr(0, firstDotBracket));\n      TObjLink* lnk = fRealData->FirstLink();\n      while (lnk) {\n         TObject* obj = lnk->GetObject();\n         std::string objName(obj->GetName());\n         std::string::size_type pos = objName.find_first_of(\"[\");\n         // Only match arrays to arrays for now.\n         if (pos != std::string::npos) {\n            objName.erase(pos);\n            if (objName == nameNoDim) {\n               return static_cast<TRealData*>(obj);\n            }\n         }\n         lnk = lnk->Next();\n      }\n   }\n\n   // New attempt starting after the first \".\" if any,\n   // but this time check for a pointer type.  Again, we\n   // are allowing for the case that the first component\n   // may have been a branch name (for TBranchElement).\n   ptrname.str(\"\");\n   ptrname << \"*\" << firstDotName;\n   rd = (TRealData*) fRealData->FindObject(ptrname.str().c_str());\n   if (rd) {\n      return rd;\n   }\n\n   // Last attempt in case a member has been changed from\n   // a static array to a pointer, for example the member\n   // was arr[20] and is now *arr.\n   //\n   // Note: In principle, one could also take into account\n   // the opposite situation where a member like *arr has\n   // been converted to arr[20].\n   //\n   // FIXME: What about checking after the first dot as well?\n   //\n   std::string::size_type bracket = starname.str().find_first_of(\"[\");\n   if (bracket == std::string::npos) {\n      return 0;\n   }\n   rd = (TRealData*) fRealData->FindObject(starname.str().substr(0, bracket).c_str());\n   if (rd) {\n      return rd;\n   }\n\n   // Not found;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTFunctionTemplate *TClass::GetFunctionTemplate(const char *name)\n{\n   if (!gInterpreter || !HasInterpreterInfo()) return 0;\n\n   // The following\n   if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);\n\n   return (TFunctionTemplate*)fFuncTemplate->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the list of shared libraries containing the code for class cls.\n/// The first library in the list is the one containing the class, the\n/// others are the libraries the first one depends on. Returns 0\n/// in case the library is not found.\n\nconst char *TClass::GetSharedLibs()\n{\n   if (!gInterpreter) return 0;\n\n   if (fSharedLibs.IsNull())\n      fSharedLibs = gInterpreter->GetClassSharedLibs(fName);\n\n   return !fSharedLibs.IsNull() ? fSharedLibs.Data() : 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TBaseClass(es) of a class.\n\nTList *TClass::GetListOfBases()\n{\n   if (!fBase.load()) {\n      if (fCanLoadClassInfo) {\n         if (fState == kHasTClassInit) {\n\n            R__LOCKGUARD(gInterpreterMutex);\n            // NOTE: Add test to prevent redo if another thread has already done the work.\n            // if (!fHasRootPcmInfo) {\n\n            // The bases are in our ProtoClass; we don't need the class info.\n            TProtoClass *proto = TClassTable::GetProtoNorm(GetName());\n            if (proto && proto->FillTClass(this)) {\n               // Not sure this code is still needed\n               // R__ASSERT(kFALSE);\n\n               fHasRootPcmInfo = kTRUE;\n            }\n         }\n         // We test again on fCanLoadClassInfo has another thread may have executed it.\n         if (!fHasRootPcmInfo && !fCanLoadClassInfo) {\n            LoadClassInfo();\n         }\n      }\n      if (!fClassInfo) return 0;\n\n      if (!gInterpreter)\n         Fatal(\"GetListOfBases\", \"gInterpreter not initialized\");\n\n      R__LOCKGUARD(gInterpreterMutex);\n      if (!fBase.load()) {\n         gInterpreter->CreateListOfBaseClasses(this);\n      }\n   }\n   return fBase;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a list containing the TEnums of a class.\n///\n/// The list returned is safe to use from multiple thread without explicitly\n/// taking the ROOT global lock.\n///\n/// In the case the TClass represents a namespace, the returned list will\n/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock)\n///\n/// In the case the TClass represents a class or struct and requestListLoading\n/// is true, the list is immutable (and thus safe to access from multiple thread\n/// without taking the global lock at all).\n///\n/// In the case the TClass represents a class or struct and requestListLoading\n/// is false, the list is mutable and thus we return a TListOfEnumsWithLock\n/// which will implicit take the ROOT global lock upon any access.\n\nTList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */)\n{\n   auto temp = fEnums.load();\n   if (temp) {\n      if (requestListLoading) {\n         if (fProperty == -1) Property();\n         if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {\n            R__LOCKGUARD(gROOTMutex);\n            temp->Load();\n         } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {\n            // We have a class for which the list was not loaded fully at\n            // first use.\n            R__LOCKGUARD(gROOTMutex);\n            temp->Load();\n         }\n      }\n      return temp;\n   }\n\n   if (!requestListLoading) {\n      if (fProperty == -1) Property();\n      R__LOCKGUARD(gInterpreterMutex);\n      if (fEnums.load()) {\n         return fEnums.load();\n      }\n\n      static bool fromRootCling = dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\");\n\n      if (fromRootCling) // rootcling is single thread (this save some space in the rootpcm).\n         fEnums = new TListOfEnums(this);\n      else\n         fEnums = new TListOfEnumsWithLock(this);\n      return fEnums;\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n   if (fEnums.load()) {\n      (*fEnums).Load();\n      return fEnums.load();\n   }\n   if (fProperty == -1) Property();\n   if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {\n      // For this case, the list will be immutable\n      temp = new TListOfEnums(this);\n   } else {\n      //namespaces can have enums added to them\n      temp = new TListOfEnumsWithLock(this);\n   }\n   temp->Load();\n   fEnums = temp;\n   return temp;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TDataMembers of a class.\n\nTList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fData) {\n      if (fCanLoadClassInfo && fState == kHasTClassInit) {\n         // NOTE: Add test to prevent redo if another thread has already done the work.\n         // if (!fHasRootPcmInfo) {\n\n         // The members are in our ProtoClass; we don't need the class info.\n         TProtoClass *proto = TClassTable::GetProtoNorm(GetName());\n         if (proto && proto->FillTClass(this)) {\n            // Not sure this code is still needed\n            // R__ASSERT(kFALSE);\n\n            fHasRootPcmInfo = kTRUE;\n            return fData;\n         }\n      }\n      fData = new TListOfDataMembers(this);\n   }\n   if (Property() & (kIsClass|kIsStruct|kIsUnion)) {\n      // If the we have a class or struct or union, the order\n      // of data members is the list is essential since it determines their\n      // order on file.  So we must always load.  Also, the list is fixed\n      // since the language does not allow to add members.\n      if (!fData->IsLoaded()) fData->Load();\n\n   } else if (load) fData->Load();\n   return fData;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TEnums of a class.\n\nTList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);\n   if (load) fFuncTemplate->Load();\n   return fFuncTemplate;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TMethods of a class.\n/// If load is true, the list is populated with all the defined function\n/// and currently instantiated function template.\n\nTList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fMethod.load()) GetMethodList();\n   if (load) {\n      if (gDebug>0) Info(\"GetListOfMethods\",\"Header Parsing - Asking for all the methods of class %s: this can involve parsing.\",GetName());\n      (*fMethod).Load();\n   }\n   return fMethod;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the collection of functions named \"name\".\n\nTCollection *TClass::GetListOfMethodOverloads(const char* name) const\n{\n   return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns a list of all public methods of this class and its base classes.\n/// Refers to a subset of the methods in GetListOfMethods() so don't do\n/// GetListOfAllPublicMethods()->Delete().\n/// Algorithm used to get the list is:\n/// - put all methods of the class in the list (also protected and private\n///   ones).\n/// - loop over all base classes and add only those methods not already in the\n///   list (also protected and private ones).\n/// - once finished, loop over resulting list and remove all private and\n///   protected methods.\n\nconst TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);\n   if (load) {\n      if (gDebug>0) Info(\"GetListOfAllPublicMethods\",\"Header Parsing - Asking for all the methods of class %s: this can involve parsing.\",GetName());\n      fAllPubMethod->Load();\n   }\n   return fAllPubMethod;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns a list of all public data members of this class and its base\n/// classes. Refers to a subset of the data members in GetListOfDatamembers()\n/// so don't do GetListOfAllPublicDataMembers()->Delete().\n\nTList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);\n   if (load) fAllPubData->Load();\n   return fAllPubData;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns list of methods accessible by context menu.\n\nvoid TClass::GetMenuItems(TList *list)\n{\n   if (!HasInterpreterInfo()) return;\n\n   // get the base class\n   TIter nextBase(GetListOfBases(), kIterBackward);\n   TBaseClass *baseClass;\n   while ((baseClass = (TBaseClass *) nextBase())) {\n      TClass *base = baseClass->GetClassPointer();\n      if (base) base->GetMenuItems(list);\n   }\n\n   // remove methods redefined in this class with no menu\n   TMethod *method, *m;\n   TIter next(GetListOfMethods(), kIterBackward);\n   while ((method = (TMethod*)next())) {\n      m = (TMethod*)list->FindObject(method->GetName());\n      if (method->IsMenuItem() != kMenuNoMenu) {\n         if (!m)\n            list->AddFirst(method);\n      } else {\n         if (m && m->GetNargs() == method->GetNargs())\n            list->Remove(m);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check whether a class has a dictionary or not.\n/// This is equivalent to ask if a class is coming from a bootstrapping\n/// procedure initiated during the loading of a library.\n\nBool_t TClass::HasDictionary() const\n{\n   return IsLoaded();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check whether a class has a dictionary or ROOT can load one.\n/// This is equivalent to ask HasDictionary() or whether a library is known\n/// where it can be loaded from, or whether a Dictionary function is\n/// available because the class's dictionary library was already loaded.\n\nBool_t TClass::HasDictionarySelection(const char* clname)\n{\n   if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname))\n      return cl->IsLoaded();\n   return  gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Verify the base classes always.\n\nvoid TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse)\n{\n   TList* lb = GetListOfBases();\n   if (!lb) return;\n   TIter nextBase(lb);\n   TBaseClass* base = 0;\n   while ((base = (TBaseClass*)nextBase())) {\n      TClass* baseCl = base->GetClassPointer();\n      if (baseCl) {\n            baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Verify the Data Members.\n\nvoid TClass::GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse)\n{\n   TListOfDataMembers* ldm = (TListOfDataMembers*)GetListOfDataMembers();\n   if (!ldm) return ;\n   TIter nextMemb(ldm);\n   TDataMember * dm = 0;\n   while ((dm = (TDataMember*)nextMemb())) {\n      // If it is a transient\n      if(!dm->IsPersistent()) {\n        continue;\n      }\n      if (dm->Property() & kIsStatic) {\n         continue;\n      }\n      // If it is a built-in data type.\n      TClass* dmTClass = 0;\n      if (dm->GetDataType()) {\n         // We have a basic datatype.\n         dmTClass = nullptr;\n         // Otherwise get the string representing the type.\n      } else if (dm->GetTypeName()) {\n         dmTClass = TClass::GetClass(dm->GetTypeName());\n      }\n      if (dmTClass) {\n         dmTClass->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n      }\n   }\n}\n\nvoid TClass::GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse)\n{\n   // Pair is a special case and we have to check its elements for missing dictionaries\n   // Pair is a transparent container so we should always look at its.\n\n   TVirtualStreamerInfo *SI = (TVirtualStreamerInfo*)this->GetStreamerInfo();\n   for (int i = 0; i < 2; i++) {\n      TClass* pairElement = ((TStreamerElement*)SI->GetElements()->At(i))->GetClass();\n      if (pairElement) {\n         pairElement->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// From the second level of recursion onwards it is different state check.\n\nvoid TClass::GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse)\n{\n   if (result.FindObject(this) || visited.FindObject(this)) return;\n\n   static TClassRef sCIString(\"string\");\n   if (this == sCIString) return;\n\n   TClassEdit::TSplitType splitType(fName);\n   if (splitType.IsTemplate()) {\n      // We now treat special cases:\n      // - pair\n      // - unique_ptr\n      // - array\n      // - tuple\n\n      // Small helper to get the TClass instance from a classname and recursively\n      // investigate it\n      auto checkDicts = [&](const string &clName){\n         auto cl = TClass::GetClass(clName.c_str());\n         if (!cl) {\n            // We try to remove * and const from the type name if any\n            const auto clNameShortType = TClassEdit::ShortType(clName.c_str(), 1);\n            cl = TClass::GetClass(clNameShortType.c_str());\n         }\n         if (cl && !cl->HasDictionary()) {\n            cl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n         }\n      };\n\n      const auto &elements = splitType.fElements;\n      const auto &templName = elements[0];\n\n      // Special treatment for pair.\n      if (templName == \"pair\") {\n         GetMissingDictionariesForPairElements(result, visited, recurse);\n         return;\n      }\n\n      // Special treatment of unique_ptr or array\n      // They are treated together since they have 1 single template argument\n      // which is interesting when checking for missing dictionaries.\n      if (templName == \"unique_ptr\" || templName == \"array\") {\n         checkDicts(elements[1]);\n         return;\n      }\n\n      // Special treatment of tuple\n      // This type must be treated separately since it can have N template\n      // arguments which are interesting, unlike unique_ptr or array.\n      if (templName == \"tuple\") {\n         // -1 because the elements end with a list of the \"stars\", i.e. number of\n         // * after the type name\n         const auto nTemplArgs = elements.size() - 1;\n         // loop starts at 1 because the first element is the template name\n         for (auto iTemplArg = 1U; iTemplArg < nTemplArgs; ++iTemplArg) {\n            checkDicts(elements[iTemplArg]);\n         }\n         return;\n      }\n   } // this is not a template\n\n   if (!HasDictionary()) {\n      result.Add(this);\n   }\n\n   visited.Add(this);\n   //Check whether a custom streamer\n   if (!TestBit(TClass::kHasCustomStreamerMember)) {\n      if (GetCollectionProxy()) {\n         // We need to look at the collection's content\n         // The collection has different kind of elements the check would be required.\n         TClass* t = 0;\n         if ((t = GetCollectionProxy()->GetValueClass())) {\n            if (!t->HasDictionary()) {\n               t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n            }\n         }\n      } else {\n         if (recurse) {\n            GetMissingDictionariesForMembers(result, visited, recurse);\n         }\n         GetMissingDictionariesForBaseClasses(result, visited, recurse);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the classes that have a missing dictionary starting from this one.\n///  - With recurse = false the classes checked for missing dictionaries are:\n///                      the class itself, all base classes, direct data members,\n///                      and for collection proxies the container's\n///                      elements without iterating over the element's data members;\n///  - With recurse = true the classes checked for missing dictionaries are:\n///                      the class itself, all base classes, recursing on the data members,\n///                      and for the collection proxies recursion on the elements of the\n///                      collection and iterating over the element's data members.\n\nvoid TClass::GetMissingDictionaries(THashTable& result, bool recurse)\n{\n   // Top level recursion it different from the following levels of recursion.\n\n   if (result.FindObject(this)) return;\n\n   static TClassRef sCIString(\"string\");\n   if (this == sCIString) return;\n\n   THashTable visited;\n\n   if (strncmp(fName, \"pair<\", 5) == 0) {\n      GetMissingDictionariesForPairElements(result, visited, recurse);\n      return;\n   }\n\n   if (!HasDictionary()) {\n      result.Add(this);\n   }\n\n   visited.Add(this);\n\n   //Check whether a custom streamer\n   if (!TestBit(TClass::kHasCustomStreamerMember)) {\n      if (GetCollectionProxy()) {\n         // We need to look at the collection's content\n         // The collection has different kind of elements the check would be required.\n         TClass* t = 0;\n         if ((t = GetCollectionProxy()->GetValueClass())) {\n            if (!t->HasDictionary()) {\n               t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);\n            }\n         }\n      } else {\n         GetMissingDictionariesForMembers(result, visited, recurse);\n         GetMissingDictionariesForBaseClasses(result, visited, recurse);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if the class has elements.\n\nBool_t TClass::IsFolder(void *obj) const\n{\n   return Browse(obj,(TBrowser*)0);\n}\n\n//______________________________________________________________________________\n//______________________________________________________________________________\nvoid TClass::ReplaceWith(TClass *newcl) const\n{\n   // Inform the other objects to replace this object by the new TClass (newcl)\n\n   R__LOCKGUARD(gInterpreterMutex);\n   //we must update the class pointers pointing to 'this' in all TStreamerElements\n   TIter nextClass(gROOT->GetListOfClasses());\n   TClass *acl;\n   TVirtualStreamerInfo *info;\n   TList tobedeleted;\n\n   // Since we are in the process of replacing a TClass by a TClass\n   // coming from a dictionary, there is no point in loading any\n   // libraries during this search.\n   Bool_t autoload = gInterpreter->SetClassAutoloading(kFALSE);\n\n   while ((acl = (TClass*)nextClass())) {\n      if (acl == newcl) continue;\n\n      TIter nextInfo(acl->GetStreamerInfos());\n      while ((info = (TVirtualStreamerInfo*)nextInfo())) {\n\n         info->Update(this, newcl);\n      }\n\n      if (acl->GetCollectionProxy()) {\n         acl->GetCollectionProxy()->UpdateValueClass(this, newcl);\n      }\n      // We should also inform all the TBranchElement :( but we do not have a master list :(\n   }\n\n   TIter delIter( &tobedeleted );\n   while ((acl = (TClass*)delIter())) {\n      delete acl;\n   }\n   gInterpreter->UnRegisterTClassUpdate(this);\n\n   gInterpreter->SetClassAutoloading(autoload);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Make sure that the current ClassInfo is up to date.\n\nvoid TClass::ResetClassInfo(Long_t /* tagnum */)\n{\n   Warning(\"ResetClassInfo(Long_t tagnum)\",\"Call to deprecated interface (does nothing)\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Make sure that the current ClassInfo is up to date.\n\nvoid TClass::ResetClassInfo()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);\n\n   if (fClassInfo) {\n      TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));\n      gInterpreter->ClassInfo_Delete(fClassInfo);\n      fClassInfo = 0;\n   }\n   // We can not check at this point whether after the unload there will\n   // still be interpreter information about this class (as v5 was doing),\n   // instead this function must only be called if the definition is (about)\n   // to be unloaded.\n\n   ResetCaches();\n\n   // We got here because the definition Decl is about to be unloaded.\n   if (fState != TClass::kHasTClassInit) {\n      if (fStreamerInfo->GetEntries() != 0) {\n         fState = TClass::kEmulated;\n      } else {\n         fState = TClass::kForwardDeclared;\n      }\n   } else {\n      // if the ClassInfo was loaded for a class with a TClass Init and it\n      // gets unloaded, should we guess it can be reloaded?\n      fCanLoadClassInfo = kTRUE;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// To clean out all caches.\n\nvoid TClass::ResetCaches()\n{\n   R__ASSERT(!TestBit(kLoading) && \"Resetting the caches does not make sense during loading!\" );\n\n   // Not owning lists, don't call Delete(), but unload\n   if (fData)\n      fData->Unload();\n   if (fEnums.load())\n      (*fEnums).Unload();\n   if (fMethod.load())\n      (*fMethod).Unload();\n\n   delete fAllPubData; fAllPubData = 0;\n\n   if (fBase.load())\n      (*fBase).Delete();\n   delete fBase.load(); fBase = 0;\n\n   if (fRealData)\n      fRealData->Delete();\n   delete fRealData;  fRealData=0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Resets the menu list to it's standard value.\n\nvoid TClass::ResetMenuList()\n{\n   if (fClassMenuList)\n      fClassMenuList->Delete();\n   else\n      fClassMenuList = new TList();\n   fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The ls function lists the contents of a class on stdout. Ls output\n/// is typically much less verbose then Dump().\n/// If options contains 'streamerinfo', run ls on the list of streamerInfos\n/// and the list of conversion streamerInfos.\n\nvoid TClass::ls(Option_t *options) const\n{\n   TNamed::ls(options);\n   if (options==0 || options[0]==0) return;\n\n   if (strstr(options,\"streamerinfo\")!=0) {\n      GetStreamerInfos()->ls(options);\n\n      if (fConversionStreamerInfo.load()) {\n         std::map<std::string, TObjArray*>::iterator it;\n         std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();\n         for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {\n            it->second->ls(options);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Makes a customizable version of the popup menu list, i.e. makes a list\n/// of TClassMenuItem objects of methods accessible by context menu.\n/// The standard (and different) way consists in having just one element\n/// in this list, corresponding to the whole standard list.\n/// Once the customizable version is done, one can remove or add elements.\n\nvoid TClass::MakeCustomMenuList()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClassMenuItem *menuItem;\n\n   // Make sure fClassMenuList is initialized and empty.\n   GetMenuList()->Delete();\n\n   TList* methodList = new TList;\n   GetMenuItems(methodList);\n\n   TMethod *method;\n   TMethodArg *methodArg;\n   TClass  *classPtr = 0;\n   TIter next(methodList);\n\n   while ((method = (TMethod*) next())) {\n      // if go to a mother class method, add separator\n      if (classPtr != method->GetClass()) {\n         menuItem = new TClassMenuItem(TClassMenuItem::kPopupSeparator, this);\n         fClassMenuList->AddLast(menuItem);\n         classPtr = method->GetClass();\n      }\n      // Build the signature of the method\n      TString sig;\n      TList* margsList = method->GetListOfMethodArgs();\n      TIter nextarg(margsList);\n      while ((methodArg = (TMethodArg*)nextarg())) {\n         sig = sig+\",\"+methodArg->GetFullTypeName();\n      }\n      if (sig.Length()!=0) sig.Remove(0,1);  // remove first comma\n      menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,\n                                    method->GetName(), method->GetName(),0,\n                                    sig.Data(),-1,TClassMenuItem::kIsSelf);\n      if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();\n      fClassMenuList->Add(menuItem);\n   }\n   delete methodList;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register the fact that an object was moved from the memory location\n/// 'arenaFrom' to the memory location 'arenaTo'.\n\nvoid TClass::Move(void *arenaFrom, void *arenaTo) const\n{\n   // If/when we have access to a copy constructor (or better to a move\n   // constructor), this function should also perform the data move.\n   // For now we just information the repository.\n\n   if ((GetState() <= kEmulated) && !fCollectionProxy) {\n      MoveAddressInRepository(\"TClass::Move\",arenaFrom,arenaTo,this);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the list of menu items associated with the class.\n\nTList *TClass::GetMenuList() const {\n   if (!fClassMenuList) {\n      fClassMenuList = new TList();\n      fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));\n   }\n   return fClassMenuList;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return (create an empty one if needed) the list of functions.\n/// The major difference with GetListOfMethod is that this returns\n/// the internal type of fMethod and thus can not be made public.\n/// It also never 'loads' the content of the list.\n\nTListOfFunctions *TClass::GetMethodList()\n{\n   if (!fMethod.load()) {\n      std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };\n      TListOfFunctions* expected = nullptr;\n      if(fMethod.compare_exchange_strong(expected, temp.get()) ) {\n         temp.release();\n      }\n   }\n   return fMethod;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to method without looking at parameters.\n/// Does not look in (possible) base classes.\n/// Has the side effect of loading all the TMethod object in the list\n/// of the class.\n\nTMethod *TClass::GetMethodAny(const char *method)\n{\n   if (!HasInterpreterInfo()) return 0;\n   return (TMethod*) GetMethodList()->FindObject(method);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to method without looking at parameters.\n/// Does look in all base classes.\n\nTMethod *TClass::GetMethodAllAny(const char *method)\n{\n   if (!HasInterpreterInfo()) return 0;\n\n   TMethod* m = GetMethodAny(method);\n   if (m) return m;\n\n   TBaseClass *base;\n   TIter       nextb(GetListOfBases());\n   while ((base = (TBaseClass *) nextb())) {\n      TClass *c = base->GetClassPointer();\n      if (c) {\n         m = c->GetMethodAllAny(method);\n         if (m) return m;\n      }\n   }\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find the best method (if there is one) matching the parameters.\n/// The params string must contain argument values, like \"3189, \\\"aap\\\", 1.3\".\n/// The function invokes GetClassMethod to search for a possible method\n/// in the class itself or in its base classes. Returns 0 in case method\n/// is not found.\n\nTMethod *TClass::GetMethod(const char *method, const char *params,\n                           Bool_t objectIsConst /* = kFALSE */)\n{\n   if (fCanLoadClassInfo) LoadClassInfo();\n   if (!fClassInfo) return 0;\n\n   if (!gInterpreter)\n      Fatal(\"GetMethod\", \"gInterpreter not initialized\");\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(fClassInfo,\n                                                                     method, params,\n                                                                     objectIsConst);\n\n   if (!decl) return 0;\n\n   // search recursively in this class or its base classes\n   TMethod* f = FindClassOrBaseMethodWithId(decl);\n   if (f) return f;\n\n   Error(\"GetMethod\",\n         \"\\nDid not find matching TMethod <%s> with \\\"%s\\\" %sfor %s\",\n         method,params,objectIsConst ? \"const \" : \"\", GetName());\n   return 0;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find a method with decl id in this class or its bases.\n\nTMethod* TClass::FindClassOrBaseMethodWithId(DeclId_t declId) {\n   if (TFunction* method = GetMethodList()->Get(declId))\n      return static_cast<TMethod *>(method);\n\n   for (auto item : *GetListOfBases())\n      if (auto base = static_cast<TBaseClass *>(item)->GetClassPointer())\n         if (TFunction* method = base->FindClassOrBaseMethodWithId(declId))\n            return static_cast<TMethod *>(method);\n\n   return nullptr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find the method with a given prototype. The proto string must be of the\n/// form: \"char*,int,double\". Returns 0 in case method is not found.\n\nTMethod *TClass::GetMethodWithPrototype(const char *method, const char *proto,\n                                        Bool_t objectIsConst /* = kFALSE */,\n                                        ROOT::EFunctionMatchMode mode /* = ROOT::kConversionMatch */)\n{\n   if (fCanLoadClassInfo) LoadClassInfo();\n   if (!fClassInfo) return 0;\n\n   if (!gInterpreter)\n      Fatal(\"GetMethodWithPrototype\", \"gInterpreter not initialized\");\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(fClassInfo,\n                                                                  method, proto,\n                                                            objectIsConst, mode);\n\n   if (!decl) return 0;\n   TMethod* f = FindClassOrBaseMethodWithId(decl);\n   if (f) return f;\n   Error(\"GetMethodWithPrototype\",\n         \"\\nDid not find matching TMethod <%s> with \\\"%s\\\" %sfor %s\",\n         method,proto,objectIsConst ? \"const \" : \"\", GetName());\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Look for a method in this class that has the interface function\n/// address faddr.\n\nTMethod *TClass::GetClassMethod(Long_t faddr)\n{\n   if (!HasInterpreterInfo()) return 0;\n\n   TMethod *m;\n   TIter    next(GetListOfMethods());\n   while ((m = (TMethod *) next())) {\n      if (faddr == (Long_t)m->InterfaceMethod())\n         return m;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Look for a method in this class that has the name and matches the parameters.\n/// The params string must contain argument values, like \"3189, \\\"aap\\\", 1.3\".\n/// Returns 0 in case method is not found.\n/// See TClass::GetMethod to also search the base classes.\n\nTMethod *TClass::GetClassMethod(const char *name, const char* params,\n                                Bool_t objectIsConst /* = kFALSE */)\n{\n   if (fCanLoadClassInfo) LoadClassInfo();\n   if (!fClassInfo) return 0;\n\n   if (!gInterpreter)\n      Fatal(\"GetClassMethod\", \"gInterpreter not initialized\");\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(fClassInfo,\n                                                                     name, params,\n                                                                     objectIsConst);\n\n   if (!decl) return 0;\n\n   TFunction *f = GetMethodList()->Get(decl);\n\n   return (TMethod*)f; // Could be zero if the decl is actually in a base class.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find the method with a given prototype. The proto string must be of the\n/// form: \"char*,int,double\". Returns 0 in case method is not found.\n/// See TClass::GetMethodWithPrototype to also search the base classes.\n\nTMethod *TClass::GetClassMethodWithPrototype(const char *name, const char* proto,\n                                             Bool_t objectIsConst /* = kFALSE */,\n                      ROOT::EFunctionMatchMode mode /* = ROOT::kConversionMatch */)\n{\n   if (fCanLoadClassInfo) LoadClassInfo();\n   if (!fClassInfo) return 0;\n\n   if (!gInterpreter)\n      Fatal(\"GetClassMethodWithPrototype\", \"gInterpreter not initialized\");\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(fClassInfo,\n                                                                        name, proto,\n                                                                        objectIsConst,\n                                                                        mode);\n\n   if (!decl) return 0;\n\n   TFunction *f = GetMethodList()->Get(decl);\n\n   return (TMethod*)f; // Could be zero if the decl is actually in a base class.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the number of data members of this class\n/// Note that in case the list of data members is not yet created, it will be done\n/// by GetListOfDataMembers().\n\nInt_t TClass::GetNdata()\n{\n   if (!HasDataMemberInfo()) return 0;\n\n   TList *lm = GetListOfDataMembers();\n   if (lm)\n      return lm->GetSize();\n   else\n      return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the number of methods of this class\n/// Note that in case the list of methods is not yet created, it will be done\n/// by GetListOfMethods().\n/// This will also load/populate the list of methods, to get 'just' the\n/// number of currently loaded methods use:\n///    cl->GetListOfMethods(false)->GetSize();\n\nInt_t TClass::GetNmethods()\n{\n   if (!HasInterpreterInfo()) return 0;\n\n   TList *lm = GetListOfMethods();\n   if (lm)\n      return lm->GetSize();\n   else\n      return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// returns a pointer to the TVirtualStreamerInfo object for version\n/// If the object does not exist, it is created\n///\n/// Note: There are two special version numbers:\n///\n///     -  0: Use the class version from the currently loaded class library.\n///     - -1: Assume no class library loaded (emulated class).\n///\n/// Warning:  If we create a new streamer info, whether or not the build\n///           optimizes is controlled externally to us by a global variable!\n///           Don't call us unless you have set that variable properly\n///           with TStreamer::Optimize()!\n///\n\nTVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */) const\n{\n   TVirtualStreamerInfo *sinfo = fLastReadInfo;\n\n   // Version 0 is special, it means the currently loaded version.\n   // We need to set it at the beginning to be able to guess it correctly.\n\n   if (version == 0)\n      version = fClassVersion;\n\n   // If the StreamerInfo is assigned to the fLastReadInfo, we are\n   // guaranteed it was built and compiled.\n   if (sinfo && sinfo->GetClassVersion() == version)\n      return sinfo;\n\n   // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.\n   // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via\n   // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.\n   // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.\n   // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem\n   // to indicates they are not yet properly protection against mutli-thread access.\n   //\n   // However, the use of these functions is rare and mostly done at library loading time which should\n   // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread\n   // on that same TClass object.\n   //\n   // Summary: need careful review but risk of problem is extremely low.\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Warning: version may be -1 for an emulated class, or -2 if the\n   //          user requested the emulated streamerInfo for an abstract\n   //          base class, even though we have a dictionary for it.\n\n   if ((version < -1) || (version >= fStreamerInfo->GetSize())) {\n      Error(\"GetStreamerInfo\", \"class: %s, attempting to access a wrong version: %d\", GetName(), version);\n      // FIXME: Shouldn't we go to -1 here, or better just abort?\n      version = fClassVersion;\n   }\n\n   sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);\n\n   if (!sinfo && (version != fClassVersion)) {\n      // When the requested version does not exist we return\n      // the TVirtualStreamerInfo for the currently loaded class version.\n      // FIXME: This arguably makes no sense, we should warn and return nothing instead.\n      // Note: This is done for STL collections\n      // Note: fClassVersion could be -1 here (for an emulated class).\n      // This is also the code path take for unversioned classes.\n      sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);\n   }\n\n   if (!sinfo) {\n      // We just were not able to find a streamer info, we have to make a new one.\n      TMmallocDescTemp setreset;\n      sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));\n      fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);\n      if (gDebug > 0) {\n         printf(\"Creating StreamerInfo for class: %s, version: %d\\n\", GetName(), fClassVersion);\n      }\n      if (HasDataMemberInfo() || fCollectionProxy) {\n         // If we do not have a StreamerInfo for this version and we do not\n         // have dictionary information nor a proxy, there is nothing to build!\n         sinfo->Build();\n      }\n   } else {\n      if (!sinfo->IsCompiled()) {\n         // Streamer info has not been compiled, but exists.\n         // Therefore it was read in from a file and we have to do schema evolution?\n         // Or it didn't have a dictionary before, but does now?\n         sinfo->BuildOld();\n      }\n   }\n\n   // Cache the current info if we now have it.\n   if (version == fClassVersion)\n      fCurrentInfo = sinfo;\n\n   // If the compilation succeeded, remember this StreamerInfo.\n   if (sinfo->IsCompiled())\n      fLastReadInfo = sinfo;\n\n   return sinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// For the case where the requestor class is emulated and this class is abstract,\n/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated\n/// representation whether or not the class is loaded.\n///\n/// If the object does not exist, it is created\n///\n/// Note: There are two special version numbers:\n///\n///    -   0: Use the class version from the currently loaded class library.\n///    -  -1: Assume no class library loaded (emulated class).\n///\n/// Warning:  If we create a new streamer info, whether or not the build\n///           optimizes is controlled externally to us by a global variable!\n///           Don't call us unless you have set that variable properly\n///           with TStreamer::Optimize()!\n///\n\nTVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const\n{\n   TVirtualStreamerInfo *sinfo = nullptr;\n\n   TString newname(GetName());\n   newname += \"@@emulated\";\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClass *emulated = TClass::GetClass(newname);\n\n   if (emulated)\n      sinfo = emulated->GetStreamerInfo(version);\n\n   if (!sinfo) {\n      // The emulated version of the streamerInfo is explicitly requested and has\n      // not been built yet.\n\n      sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);\n\n      if (!sinfo && (version != fClassVersion)) {\n         // When the requested version does not exist we return\n         // the TVirtualStreamerInfo for the currently loaded class version.\n         // FIXME: This arguably makes no sense, we should warn and return nothing instead.\n         sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);\n      }\n\n      if (!sinfo) {\n         // Let's take the first available StreamerInfo as a start\n         Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;\n         for (Int_t i = -1; sinfo == 0 && i < ninfos; ++i)\n            sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);\n      }\n\n      if (sinfo) {\n         sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());\n         if (sinfo) {\n            sinfo->SetClass(0);\n            sinfo->SetName(newname);\n            sinfo->BuildCheck();\n            sinfo->BuildOld();\n            sinfo->GetClass()->AddRule(TString::Format(\"sourceClass=%s targetClass=%s\",GetName(),newname.Data()));\n         } else {\n            Error(\"GetStreamerInfoAbstractEmulated\", \"could not create TVirtualStreamerInfo\");\n         }\n      }\n   }\n   return sinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// For the case where the requestor class is emulated and this class is abstract,\n/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated\n/// representation whether or not the class is loaded.\n///\n/// If the object does not exist, it is created\n///\n/// Warning:  If we create a new streamer info, whether or not the build\n///           optimizes is controlled externally to us by a global variable!\n///           Don't call us unless you have set that variable properly\n///           with TStreamer::Optimize()!\n///\n\nTVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const\n{\n   TVirtualStreamerInfo *sinfo = nullptr;\n\n   TString newname(GetName());\n   newname += \"@@emulated\";\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClass *emulated = TClass::GetClass(newname);\n\n   if (emulated)\n      sinfo = emulated->FindStreamerInfo(checksum);\n\n   if (!sinfo) {\n      // The emulated version of the streamerInfo is explicitly requested and has\n      // not been built yet.\n\n      sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);\n\n      if (!sinfo && (checksum != fCheckSum)) {\n         // When the requested version does not exist we return\n         // the TVirtualStreamerInfo for the currently loaded class version.\n         // FIXME: This arguably makes no sense, we should warn and return nothing instead.\n         sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);\n      }\n\n      if (!sinfo) {\n         // Let's take the first available StreamerInfo as a start\n         Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;\n         for (Int_t i = -1; sinfo == 0 && i < ninfos; ++i)\n            sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);\n      }\n\n      if (sinfo) {\n         sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );\n         if (sinfo) {\n            sinfo->SetClass(0);\n            sinfo->SetName( newname );\n            sinfo->BuildCheck();\n            sinfo->BuildOld();\n            sinfo->GetClass()->AddRule(TString::Format(\"sourceClass=%s targetClass=%s\",GetName(),newname.Data()));\n         } else {\n            Error(\"GetStreamerInfoAbstractEmulated\", \"could not create TVirtualStreamerInfo\");\n         }\n      }\n   }\n   return sinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///  When the class kIgnoreTObjectStreamer bit is set, the automatically\n///  generated Streamer will not call TObject::Streamer.\n///  This option saves the TObject space overhead on the file.\n///  However, the information (fBits, fUniqueID) of TObject is lost.\n///\n///  Note that to be effective for objects streamed object-wise this function\n///  must be called for the class deriving directly from TObject, eg, assuming\n///  that BigTrack derives from Track and Track derives from TObject, one must do:\n/// ~~~ {.cpp}\n///     Track::Class()->IgnoreTObjectStreamer();\n/// ~~~\n///  and not:\n/// ~~~ {.cpp}\n///     BigTrack::Class()->IgnoreTObjectStreamer();\n/// ~~~\n///  To be effective for object streamed member-wise or split in a TTree,\n///  this function must be called for the most derived class (i.e. BigTrack).\n\nvoid TClass::IgnoreTObjectStreamer(Bool_t doIgnore)\n{\n   // We need to tak the lock since we are test and then setting fBits\n   // and TStreamerInfo::fBits (and the StreamerInfo state in general)\n   // which can also be modified by another thread.\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if ( doIgnore &&  TestBit(kIgnoreTObjectStreamer)) return;\n   if (!doIgnore && !TestBit(kIgnoreTObjectStreamer)) return;\n   TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();\n   if (sinfo) {\n      if (sinfo->IsCompiled()) {\n         // -- Warn the user that what they are doing cannot work.\n         // Note: The reason is that TVirtualStreamerInfo::Build() examines\n         // the kIgnoreTObjectStreamer bit and sets the TStreamerElement\n         // type for the TObject base class streamer element it creates\n         // to -1 as a flag.  Later on the TStreamerInfo::Compile()\n         // member function sees the flag and does not insert the base\n         // class element into the compiled streamer info.  None of this\n         // machinery works correctly if we are called after the streamer\n         // info has already been built and compiled.\n         Error(\"IgnoreTObjectStreamer\",\"Must be called before the creation of StreamerInfo\");\n         return;\n      }\n   }\n   if (doIgnore) SetBit  (kIgnoreTObjectStreamer);\n   else          ResetBit(kIgnoreTObjectStreamer);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if this class inherits from a class with name \"classname\".\n/// note that the function returns kTRUE in case classname is the class itself\n\nBool_t TClass::InheritsFrom(const char *classname) const\n{\n   if (strcmp(GetName(), classname) == 0) return kTRUE;\n\n   return InheritsFrom(TClass::GetClass(classname,kTRUE,kTRUE));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if this class inherits from class cl.\n/// note that the function returns KTRUE in case cl is the class itself\n\nBool_t TClass::InheritsFrom(const TClass *cl) const\n{\n   if (!cl) return kFALSE;\n   if (cl == this) return kTRUE;\n\n   if (!HasDataMemberInfo()) {\n      TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();\n      if (sinfo==0) sinfo = GetStreamerInfo();\n      TIter next(sinfo->GetElements());\n      TStreamerElement *element;\n      while ((element = (TStreamerElement*)next())) {\n         if (element->IsA() == TStreamerBase::Class()) {\n            TClass *clbase = element->GetClassPointer();\n            if (!clbase) return kFALSE; //missing class\n            if (clbase->InheritsFrom(cl)) return kTRUE;\n         }\n      }\n      return kFALSE;\n   }\n   // cast const away (only for member fBase which can be set in GetListOfBases())\n   if (((TClass *)this)->GetBaseClass(cl)) return kTRUE;\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Cast obj of this class type up to baseclass cl if up is true.\n/// Cast obj of this class type down from baseclass cl if up is false.\n/// If this class is not a baseclass of cl return 0, else the pointer\n/// to the cl part of this (up) or to this (down).\n\nvoid *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up)\n{\n   if (cl == this) return obj;\n\n   if (!HasDataMemberInfo()) return 0;\n\n   Int_t off;\n   if ((off = GetBaseClassOffset(cl, obj)) != -1) {\n      if (up)\n         return (void*)((Long_t)obj+off);\n      else\n         return (void*)((Long_t)obj-off);\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Cast obj of this class type up to baseclass cl if up is true.\n/// Cast obj of this class type down from baseclass cl if up is false.\n/// If this class is not a baseclass of cl return 0, else the pointer\n/// to the cl part of this (up) or to this (down).\n\nconst void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up)\n{\n   return DynamicCast(cl,const_cast<void*>(obj),up);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to a newly allocated object of this class.\n/// The class must have a default constructor. For meaning of\n/// defConstructor, see TClass::IsCallingNew().\n///\n/// If quiet is true, do no issue a message via Error on case\n/// of problems, just return 0.\n///\n/// The constructor actually called here can be customized by\n/// using the rootcint pragma:\n/// ~~~ {.cpp}\n///    #pragma link C++ ioctortype UserClass;\n/// ~~~\n/// For example, with this pragma and a class named MyClass,\n/// this method will called the first of the following 3\n/// constructors which exists and is public:\n/// ~~~ {.cpp}\n///    MyClass(UserClass*);\n///    MyClass(TRootIOCtor*);\n///    MyClass(); // Or a constructor with all its arguments defaulted.\n/// ~~~\n///\n/// When more than one pragma ioctortype is used, the first seen as priority\n/// For example with:\n/// ~~~ {.cpp}\n///    #pragma link C++ ioctortype UserClass1;\n///    #pragma link C++ ioctortype UserClass2;\n/// ~~~\n/// We look in the following order:\n/// ~~~ {.cpp}\n///    MyClass(UserClass1*);\n///    MyClass(UserClass2*);\n///    MyClass(TRootIOCtor*);\n///    MyClass(); // Or a constructor with all its arguments defaulted.\n/// ~~~\n\nvoid *TClass::New(ENewType defConstructor, Bool_t quiet) const\n{\n   void* p = 0;\n\n   if (fNew) {\n      // We have the new operator wrapper function,\n      // so there is a dictionary and it was generated\n      // by rootcint, so there should be a default\n      // constructor we can call through the wrapper.\n      TClass__GetCallingNew() = defConstructor;\n      p = fNew(0);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p && !quiet) {\n         //Error(\"New\", \"cannot create object of class %s version %d\", GetName(), fClassVersion);\n         Error(\"New\", \"cannot create object of class %s\", GetName());\n      }\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the\n      // constructor wrapper, so the dictionary was\n      // not generated by rootcint.  Let's try to\n      // create the object by having the interpreter\n      // call the new operator, hopefully the class\n      // library is loaded and there will be a default\n      // constructor we can call.\n      // [This is very unlikely to work, but who knows!]\n      TClass__GetCallingNew() = defConstructor;\n      p = gCling->ClassInfo_New(GetClassInfo());\n      TClass__GetCallingNew() = kRealNew;\n      if (!p && !quiet) {\n         //Error(\"New\", \"cannot create object of class %s version %d\", GetName(), fClassVersion);\n         Error(\"New\", \"cannot create object of class %s\", GetName());\n      }\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      TClass__GetCallingNew() = defConstructor;\n      p = fCollectionProxy->New();\n      TClass__GetCallingNew() = kRealNew;\n      if (!p && !quiet) {\n         //Error(\"New\", \"cannot create object of class %s version %d\", GetName(), fClassVersion);\n         Error(\"New\", \"cannot create object of class %s\", GetName());\n      }\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling a\n      // constructor (basically we just make sure that the\n      // pointer data members are null, unless they are marked\n      // as preallocated with the \"->\" comment, in which case\n      // we default-construct an object to point at).\n\n      // Do not register any TObject's that we create\n      // as a result of creating this object.\n      // FIXME: Why do we do this?\n      // FIXME: Partial Answer: Is this because we may never actually deregister them???\n\n      Bool_t statsave = GetObjectStat();\n      if(statsave) {\n         SetObjectStat(kFALSE);\n      }\n      TVirtualStreamerInfo* sinfo = GetStreamerInfo();\n      if (!sinfo && !quiet) {\n         Error(\"New\", \"Cannot construct class '%s' version %d, no streamer info available!\", GetName(), fClassVersion);\n         return 0;\n      }\n\n      TClass__GetCallingNew() = defConstructor;\n      p = sinfo->New();\n      TClass__GetCallingNew() = kRealNew;\n\n      // FIXME: Mistake?  See note above at the GetObjectStat() call.\n      // Allow TObject's to be registered again.\n      if(statsave) {\n         SetObjectStat(statsave);\n      }\n\n      // Register the object for special handling in the destructor.\n      if (p) {\n         RegisterAddressInRepository(\"New\",p,this);\n      } else {\n         Error(\"New\", \"Failed to construct class '%s' using streamer info\", GetName());\n      }\n   } else {\n      Fatal(\"New\", \"This cannot happen!\");\n   }\n\n   return p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to a newly allocated object of this class.\n/// The class must have a default constructor. For meaning of\n/// defConstructor, see TClass::IsCallingNew().\n\nvoid *TClass::New(void *arena, ENewType defConstructor) const\n{\n   void* p = 0;\n\n   if (fNew) {\n      // We have the new operator wrapper function,\n      // so there is a dictionary and it was generated\n      // by rootcint, so there should be a default\n      // constructor we can call through the wrapper.\n      TClass__GetCallingNew() = defConstructor;\n      p = fNew(arena);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"New with placement\", \"cannot create object of class %s version %d at address %p\", GetName(), fClassVersion, arena);\n      }\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the\n      // constructor wrapper, so the dictionary was\n      // not generated by rootcint.  Let's try to\n      // create the object by having the interpreter\n      // call the new operator, hopefully the class\n      // library is loaded and there will be a default\n      // constructor we can call.\n      // [This is very unlikely to work, but who knows!]\n      TClass__GetCallingNew() = defConstructor;\n      p = gCling->ClassInfo_New(GetClassInfo(),arena);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"New with placement\", \"cannot create object of class %s version %d at address %p\", GetName(), fClassVersion, arena);\n      }\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      TClass__GetCallingNew() = defConstructor;\n      p = fCollectionProxy->New(arena);\n      TClass__GetCallingNew() = kRealNew;\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling a\n      // constructor (basically we just make sure that the\n      // pointer data members are null, unless they are marked\n      // as preallocated with the \"->\" comment, in which case\n      // we default-construct an object to point at).\n\n      // ???BUG???  ???WHY???\n      // Do not register any TObject's that we create\n      // as a result of creating this object.\n      Bool_t statsave = GetObjectStat();\n      if(statsave) {\n         SetObjectStat(kFALSE);\n      }\n\n      TVirtualStreamerInfo* sinfo = GetStreamerInfo();\n      if (!sinfo) {\n         Error(\"New with placement\", \"Cannot construct class '%s' version %d at address %p, no streamer info available!\", GetName(), fClassVersion, arena);\n         return 0;\n      }\n\n      TClass__GetCallingNew() = defConstructor;\n      p = sinfo->New(arena);\n      TClass__GetCallingNew() = kRealNew;\n\n      // ???BUG???\n      // Allow TObject's to be registered again.\n      if(statsave) {\n         SetObjectStat(statsave);\n      }\n\n      // Register the object for special handling in the destructor.\n      if (p) {\n         RegisterAddressInRepository(\"TClass::New with placement\",p,this);\n      }\n   } else {\n      Error(\"New with placement\", \"This cannot happen!\");\n   }\n\n   return p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to a newly allocated array of objects\n/// of this class.\n/// The class must have a default constructor. For meaning of\n/// defConstructor, see TClass::IsCallingNew().\n\nvoid *TClass::NewArray(Long_t nElements, ENewType defConstructor) const\n{\n   void* p = 0;\n\n   if (fNewArray) {\n      // We have the new operator wrapper function,\n      // so there is a dictionary and it was generated\n      // by rootcint, so there should be a default\n      // constructor we can call through the wrapper.\n      TClass__GetCallingNew() = defConstructor;\n      p = fNewArray(nElements, 0);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"NewArray\", \"cannot create object of class %s version %d\", GetName(), fClassVersion);\n      }\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the\n      // constructor wrapper, so the dictionary was\n      // not generated by rootcint.  Let's try to\n      // create the object by having the interpreter\n      // call the new operator, hopefully the class\n      // library is loaded and there will be a default\n      // constructor we can call.\n      // [This is very unlikely to work, but who knows!]\n      TClass__GetCallingNew() = defConstructor;\n      p = gCling->ClassInfo_New(GetClassInfo(),nElements);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"NewArray\", \"cannot create object of class %s version %d\", GetName(), fClassVersion);\n      }\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      TClass__GetCallingNew() = defConstructor;\n      p = fCollectionProxy->NewArray(nElements);\n      TClass__GetCallingNew() = kRealNew;\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling a\n      // constructor (basically we just make sure that the\n      // pointer data members are null, unless they are marked\n      // as preallocated with the \"->\" comment, in which case\n      // we default-construct an object to point at).\n\n      // ???BUG???  ???WHY???\n      // Do not register any TObject's that we create\n      // as a result of creating this object.\n      Bool_t statsave = GetObjectStat();\n      if(statsave) {\n         SetObjectStat(kFALSE);\n      }\n\n      TVirtualStreamerInfo* sinfo = GetStreamerInfo();\n      if (!sinfo) {\n         Error(\"NewArray\", \"Cannot construct class '%s' version %d, no streamer info available!\", GetName(), fClassVersion);\n         return 0;\n      }\n\n      TClass__GetCallingNew() = defConstructor;\n      p = sinfo->NewArray(nElements);\n      TClass__GetCallingNew() = kRealNew;\n\n      // ???BUG???\n      // Allow TObject's to be registered again.\n      if(statsave) {\n         SetObjectStat(statsave);\n      }\n\n      // Register the object for special handling in the destructor.\n      if (p) {\n         RegisterAddressInRepository(\"TClass::NewArray\",p,this);\n      }\n   } else {\n      Error(\"NewArray\", \"This cannot happen!\");\n   }\n\n   return p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to a newly allocated object of this class.\n/// The class must have a default constructor. For meaning of\n/// defConstructor, see TClass::IsCallingNew().\n\nvoid *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const\n{\n   void* p = 0;\n\n   if (fNewArray) {\n      // We have the new operator wrapper function,\n      // so there is a dictionary and it was generated\n      // by rootcint, so there should be a default\n      // constructor we can call through the wrapper.\n      TClass__GetCallingNew() = defConstructor;\n      p = fNewArray(nElements, arena);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"NewArray with placement\", \"cannot create object of class %s version %d at address %p\", GetName(), fClassVersion, arena);\n      }\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the constructor wrapper,\n      // so the dictionary was not generated by rootcint (it was made either\n      // by cint or by some external mechanism).  Let's try to create the\n      // object by having the interpreter call the new operator, either the\n      // class library is loaded and there is a default constructor we can\n      // call, or the class is interpreted and we will call the default\n      // constructor that way, or no default constructor is available and\n      // we fail.\n      TClass__GetCallingNew() = defConstructor;\n      p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);\n      TClass__GetCallingNew() = kRealNew;\n      if (!p) {\n         Error(\"NewArray with placement\", \"cannot create object of class %s version %d at address %p\", GetName(), fClassVersion, arena);\n      }\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      TClass__GetCallingNew() = defConstructor;\n      p = fCollectionProxy->NewArray(nElements, arena);\n      TClass__GetCallingNew() = kRealNew;\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling a\n      // constructor (basically we just make sure that the\n      // pointer data members are null, unless they are marked\n      // as preallocated with the \"->\" comment, in which case\n      // we default-construct an object to point at).\n\n      // ???BUG???  ???WHY???\n      // Do not register any TObject's that we create\n      // as a result of creating this object.\n      Bool_t statsave = GetObjectStat();\n      if(statsave) {\n         SetObjectStat(kFALSE);\n      }\n\n      TVirtualStreamerInfo* sinfo = GetStreamerInfo();\n      if (!sinfo) {\n         Error(\"NewArray with placement\", \"Cannot construct class '%s' version %d at address %p, no streamer info available!\", GetName(), fClassVersion, arena);\n         return 0;\n      }\n\n      TClass__GetCallingNew() = defConstructor;\n      p = sinfo->NewArray(nElements, arena);\n      TClass__GetCallingNew() = kRealNew;\n\n      // ???BUG???\n      // Allow TObject's to be registered again.\n      if(statsave) {\n         SetObjectStat(statsave);\n      }\n\n      if (fStreamerType & kEmulatedStreamer) {\n         // We always register emulated objects, we need to always\n         // use the streamer info to destroy them.\n      }\n\n      // Register the object for special handling in the destructor.\n      if (p) {\n         RegisterAddressInRepository(\"TClass::NewArray with placement\",p,this);\n      }\n   } else {\n      Error(\"NewArray with placement\", \"This cannot happen!\");\n   }\n\n   return p;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Explicitly call destructor for object.\n\nvoid TClass::Destructor(void *obj, Bool_t dtorOnly)\n{\n   // Do nothing if passed a null pointer.\n   if (obj == 0) return;\n\n   void* p = obj;\n\n   if (dtorOnly && fDestructor) {\n      // We have the destructor wrapper, use it.\n      fDestructor(p);\n   } else if ((!dtorOnly) && fDelete) {\n      // We have the delete wrapper, use it.\n      fDelete(p);\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the\n      // destruct/delete wrapper, so the dictionary was\n      // not generated by rootcint (it could have been\n      // created by cint or by some external mechanism).\n      // Let's have the interpreter call the destructor,\n      // either the code will be in a loaded library,\n      // or it will be interpreted, otherwise we fail\n      // because there is no destructor code at all.\n      if (dtorOnly) {\n         gCling->ClassInfo_Destruct(fClassInfo,p);\n      } else {\n         gCling->ClassInfo_Delete(fClassInfo,p);\n      }\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      fCollectionProxy->Destructor(p, dtorOnly);\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling a\n      // destructor.\n\n      Bool_t inRepo = kTRUE;\n      Bool_t verFound = kFALSE;\n\n      // Was this object allocated through TClass?\n      std::multiset<Version_t> knownVersions;\n      R__LOCKGUARD2(gOVRMutex);\n\n      {\n         RepoCont_t::iterator iter = gObjectVersionRepository.find(p);\n         if (iter == gObjectVersionRepository.end()) {\n            // No, it wasn't, skip special version handling.\n            //Error(\"Destructor2\", \"Attempt to delete unregistered object of class '%s' at address %p!\", GetName(), p);\n            inRepo = kFALSE;\n         } else {\n            //objVer = iter->second;\n            for (; (iter != gObjectVersionRepository.end()) && (iter->first == p); ++iter) {\n               Version_t ver = iter->second.fVersion;\n               knownVersions.insert(ver);\n               if (ver == fClassVersion && this == iter->second.fClass) {\n                  verFound = kTRUE;\n               }\n            }\n         }\n      }\n\n      if (!inRepo || verFound) {\n         // The object was allocated using code for the same class version\n         // as is loaded now.  We may proceed without worry.\n         TVirtualStreamerInfo* si = GetStreamerInfo();\n         if (si) {\n            si->Destructor(p, dtorOnly);\n         } else {\n            Error(\"Destructor\", \"No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!\", GetName(), fClassVersion, p);\n            Error(\"Destructor\", \"length of fStreamerInfo is %d\", fStreamerInfo->GetSize());\n            Int_t i = fStreamerInfo->LowerBound();\n            for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {\n               Error(\"Destructor\", \"fStreamerInfo->At(%d): %p\", i, fStreamerInfo->At(i));\n               if (fStreamerInfo->At(i) != 0) {\n                  Error(\"Destructor\", \"Doing Dump() ...\");\n                  ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();\n               }\n            }\n         }\n      } else {\n         // The loaded class version is not the same as the version of the code\n         // which was used to allocate this object.  The best we can do is use\n         // the TVirtualStreamerInfo to try to free up some of the allocated memory.\n         Error(\"Destructor\", \"Loaded class %s version %d is not registered for addr %p\", GetName(), fClassVersion, p);\n#if 0\n         TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);\n         if (si) {\n            si->Destructor(p, dtorOnly);\n         } else {\n            Error(\"Destructor2\", \"No streamer info available for class '%s' version %d, cannot destruct object at addr: %p\", GetName(), objVer, p);\n            Error(\"Destructor2\", \"length of fStreamerInfo is %d\", fStreamerInfo->GetSize());\n            Int_t i = fStreamerInfo->LowerBound();\n            for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {\n               Error(\"Destructor2\", \"fStreamerInfo->At(%d): %p\", i, fStreamerInfo->At(i));\n               if (fStreamerInfo->At(i) != 0) {\n                  // Do some debugging output.\n                  Error(\"Destructor2\", \"Doing Dump() ...\");\n                  ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();\n               }\n            }\n         }\n#endif\n      }\n\n      if (inRepo && verFound && p) {\n         UnregisterAddressInRepository(\"TClass::Destructor\",p,this);\n      }\n   } else {\n      Error(\"Destructor\", \"This cannot happen! (class %s)\", GetName());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Explicitly call operator delete[] for an array.\n\nvoid TClass::DeleteArray(void *ary, Bool_t dtorOnly)\n{\n   // Do nothing if passed a null pointer.\n   if (ary == 0) return;\n\n   // Make a copy of the address.\n   void* p = ary;\n\n   if (fDeleteArray) {\n      if (dtorOnly) {\n         Error(\"DeleteArray\", \"Destructor only is not supported!\");\n      } else {\n         // We have the array delete wrapper, use it.\n         fDeleteArray(ary);\n      }\n   } else if (HasInterpreterInfo()) {\n      // We have the dictionary but do not have the\n      // array delete wrapper, so the dictionary was\n      // not generated by rootcint.  Let's try to\n      // delete the array by having the interpreter\n      // call the array delete operator, hopefully\n      // the class library is loaded and there will be\n      // a destructor we can call.\n      gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);\n   } else if (!HasInterpreterInfo() && fCollectionProxy) {\n      // There is no dictionary at all, so this is an emulated\n      // class; however we do have the services of a collection proxy,\n      // so this is an emulated STL class.\n      fCollectionProxy->DeleteArray(ary, dtorOnly);\n   } else if (!HasInterpreterInfo() && !fCollectionProxy) {\n      // There is no dictionary at all and we do not have\n      // the services of a collection proxy available, so\n      // use the streamer info to approximate calling the\n      // array destructor.\n\n      Bool_t inRepo = kTRUE;\n      Bool_t verFound = kFALSE;\n\n      // Was this array object allocated through TClass?\n      std::multiset<Version_t> knownVersions;\n      {\n         R__LOCKGUARD2(gOVRMutex);\n         RepoCont_t::iterator iter = gObjectVersionRepository.find(p);\n         if (iter == gObjectVersionRepository.end()) {\n            // No, it wasn't, we cannot know what to do.\n            //Error(\"DeleteArray\", \"Attempt to delete unregistered array object, element type '%s', at address %p!\", GetName(), p);\n            inRepo = kFALSE;\n         } else {\n            for (; (iter != gObjectVersionRepository.end()) && (iter->first == p); ++iter) {\n               Version_t ver = iter->second.fVersion;\n               knownVersions.insert(ver);\n               if (ver == fClassVersion && this == iter->second.fClass ) {\n                  verFound = kTRUE;\n               }\n            }\n         }\n      }\n\n      if (!inRepo || verFound) {\n         // The object was allocated using code for the same class version\n         // as is loaded now.  We may proceed without worry.\n         TVirtualStreamerInfo* si = GetStreamerInfo();\n         if (si) {\n            si->DeleteArray(ary, dtorOnly);\n         } else {\n            Error(\"DeleteArray\", \"No streamer info available for class '%s' version %d at address %p, cannot destruct object!\", GetName(), fClassVersion, ary);\n            Error(\"DeleteArray\", \"length of fStreamerInfo is %d\", fStreamerInfo->GetSize());\n            Int_t i = fStreamerInfo->LowerBound();\n            for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {\n               Error(\"DeleteArray\", \"fStreamerInfo->At(%d): %p\", v, fStreamerInfo->At(i));\n               if (fStreamerInfo->At(i)) {\n                  Error(\"DeleteArray\", \"Doing Dump() ...\");\n                  ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();\n               }\n            }\n         }\n      } else {\n         // The loaded class version is not the same as the version of the code\n         // which was used to allocate this array.  The best we can do is use\n         // the TVirtualStreamerInfo to try to free up some of the allocated memory.\n         Error(\"DeleteArray\", \"Loaded class version %d is not registered for addr %p\", fClassVersion, p);\n\n\n\n#if 0\n         TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);\n         if (si) {\n            si->DeleteArray(ary, dtorOnly);\n         } else {\n            Error(\"DeleteArray\", \"No streamer info available for class '%s' version %d at address %p, cannot destruct object!\", GetName(), objVer, ary);\n            Error(\"DeleteArray\", \"length of fStreamerInfo is %d\", fStreamerInfo->GetSize());\n            Int_t i = fStreamerInfo->LowerBound();\n            for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {\n               Error(\"DeleteArray\", \"fStreamerInfo->At(%d): %p\", v, fStreamerInfo->At(i));\n               if (fStreamerInfo->At(i)) {\n                  // Print some debugging info.\n                  Error(\"DeleteArray\", \"Doing Dump() ...\");\n                  ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();\n               }\n            }\n         }\n#endif\n\n\n      }\n\n      // Deregister the object for special handling in the destructor.\n      if (inRepo && verFound && p) {\n         UnregisterAddressInRepository(\"TClass::DeleteArray\",p,this);\n      }\n   } else {\n      Error(\"DeleteArray\", \"This cannot happen! (class '%s')\", GetName());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set the splitability of this class:\n///  - -1: Use the default calculation\n///  -  0: Disallow splitting\n///  -  1: Always allow splitting.\n///  -  2: Disallow splitting of the class and splitting of any it's derived classes.\n\nvoid TClass::SetCanSplit(Int_t splitmode)\n{\n   fCanSplit = splitmode;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Private function.  Set the class version for the 'class' represented by\n/// this TClass object.  See the public interface:\n///    ROOT::ResetClassVersion\n/// defined in TClassTable.cxx\n///\n/// Note on class version numbers:\n///  - If no class number has been specified, TClass::GetVersion will return -1\n///  - The Class Version 0 request the whole object to be transient\n///  - The Class Version 1, unless specified via ClassDef indicates that the\n///      I/O should use the TClass checksum to distinguish the layout of the class\n\nvoid TClass::SetClassVersion(Version_t version)\n{\n   fClassVersion = version;\n   fCurrentInfo = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Determine and set pointer to current TVirtualStreamerInfo\n\nTVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo()\n{\n   if(!fCurrentInfo.load()) {\n      R__READ_LOCKGUARD(ROOT::gCoreMutex);\n      fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));\n   }\n   return fCurrentInfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set pointer to current TVirtualStreamerInfo\n\nvoid TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info)\n{\n   fCurrentInfo = info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return size of object of this class.\n\nInt_t TClass::Size() const\n{\n   if (fSizeof!=-1) return fSizeof;\n   if (fCollectionProxy) return fCollectionProxy->Sizeof();\n   if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());\n   return GetStreamerInfo()->GetSize();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load class description from I/O buffer and return class object.\n\nTClass *TClass::Load(TBuffer &b)\n{\n   UInt_t maxsize = 256;\n   char *s = new char[maxsize];\n\n   Int_t pos = b.Length();\n\n   b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.\n   while (strlen(s) == (maxsize - 1)) {\n      // The classname is too large, try again with a large buffer.\n      b.SetBufferOffset(pos);\n      maxsize = 2*maxsize;\n      delete [] s;\n      s = new char[maxsize];\n      b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.\n   }\n\n   TClass *cl = TClass::GetClass(s, kTRUE);\n   if (!cl)\n      ::Error(\"TClass::Load\", \"dictionary of class %s not found\", s);\n\n   delete [] s;\n   return cl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function used by TClass::GetClass().\n/// This function attempts to load the dictionary for 'classname'\n/// either from the TClassTable or from the list of generator.\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n///\n/// The 'requestedname' is expected to be already normalized.\n\nTClass *TClass::LoadClass(const char *requestedname, Bool_t silent)\n{\n   // This function does not (and should not) attempt to check in the\n   // list of loaded classes or in the typedef.\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClass *result = LoadClassDefault(requestedname, silent);\n\n   if (result) return result;\n   else return LoadClassCustom(requestedname,silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function used by TClass::GetClass().\n/// This function attempts to load the dictionary for 'classname' from\n/// the TClassTable or the autoloader.\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n///\n/// The 'requestedname' is expected to be already normalized.\n\nTClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */)\n{\n   // This function does not (and should not) attempt to check in the\n   // list of loaded classes or in the typedef.\n\n   DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);\n\n   if (!dict) {\n      if (gInterpreter->AutoLoad(requestedname,kTRUE)) {\n         dict = TClassTable::GetDictNorm(requestedname);\n      }\n   }\n\n   if (dict) {\n      TClass *ncl = (dict)();\n      if (ncl) ncl->PostLoadCheck();\n      return ncl;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function used by TClass::GetClass().\n/// This function attempts to load the dictionary for 'classname'\n/// from the list of generator.\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n///\n/// The 'requestedname' is expected to be already normalized.\n\nTClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent)\n{\n   // This function does not (and should not) attempt to check in the\n   // list of loaded classes or in the typedef.\n\n   TIter next(gROOT->GetListOfClassGenerators());\n   TClassGenerator *gen;\n   while ((gen = (TClassGenerator*) next())) {\n      TClass *cl = gen->GetClass(requestedname, kTRUE, silent);\n      if (cl) {\n         cl->PostLoadCheck();\n         return cl;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Try to load the ClassInfo if available. This function may require parsing\n/// the header file and/or loading data from the clang pcm. If further calls to\n/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set\n/// to false.\n\nvoid TClass::LoadClassInfo() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Return if another thread already loaded the info\n   // while we were waiting for the lock\n   if (!fCanLoadClassInfo)\n      return;\n\n   bool autoParse = !gInterpreter->IsAutoParsingSuspended();\n\n   if (autoParse)\n      gInterpreter->AutoParse(GetName());\n\n   if (!fClassInfo)\n      gInterpreter->SetClassInfo(const_cast<TClass *>(this));\n\n   if (autoParse && !fClassInfo) {\n      if (fImplFileLine == -1 && fClassVersion == 0) {\n         // We have a 'transient' class with a ClassDefInline and apparently no interpreter\n         // information. Since it is transient, it is more than likely that the lack\n         // will be harmles.\n      } else {\n         ::Error(\"TClass::LoadClassInfo\", \"no interpreter information for class %s is available\"\n                                          \" even though it has a TClass initialization routine.\",\n                 fName.Data());\n      }\n      return;\n   }\n\n   fCanLoadClassInfo = false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Store class description on I/O buffer.\n\nvoid TClass::Store(TBuffer &b) const\n{\n   b.WriteString(GetName());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Global function called by a class' static Dictionary() method\n/// (see the ClassDef macro).\n\nTClass *ROOT::CreateClass(const char *cname, Version_t id,\n                          const std::type_info &info, TVirtualIsAProxy *isa,\n                          const char *dfil, const char *ifil,\n                          Int_t dl, Int_t il)\n{\n   // When called via TMapFile (e.g. Update()) make sure that the dictionary\n   // gets allocated on the heap and not in the mapped file.\n   TMmallocDescTemp setreset;\n   return new TClass(cname, id, info, isa, dfil, ifil, dl, il);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Global function called by a class' static Dictionary() method\n/// (see the ClassDef macro).\n\nTClass *ROOT::CreateClass(const char *cname, Version_t id,\n                          const char *dfil, const char *ifil,\n                          Int_t dl, Int_t il)\n{\n   // When called via TMapFile (e.g. Update()) make sure that the dictionary\n   // gets allocated on the heap and not in the mapped file.\n   TMmallocDescTemp setreset;\n   return new TClass(cname, id, dfil, ifil, dl, il);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Static method returning the defConstructor flag passed to TClass::New().\n/// New type is either:\n///  - TClass::kRealNew  - when called via plain new\n///  - TClass::kClassNew - when called via TClass::New()\n///  - TClass::kDummyNew - when called via TClass::New() but object is a dummy,\n///                        in which case the object ctor might take short cuts\n\nTClass::ENewType TClass::IsCallingNew()\n{\n   return TClass__GetCallingNew();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the shared library of this class is currently in the a\n/// process's memory.  Return false, after the shared library has been\n/// unloaded or if this is an 'emulated' class created from a file's StreamerInfo.\n\nBool_t TClass::IsLoaded() const\n{\n   return fState == kHasTClassInit;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns true if this class inherits from TObject and if the start of\n/// the TObject parts is at the very beginning of the objects.\n/// Concretely this means that the following code is proper for this class:\n/// ~~~ {.cpp}\n///     ThisClass *ptr;\n///     void *void_ptr = (void)ptr;\n///     TObject *obj = (TObject*)void_ptr;\n/// ~~~\n/// This code would be wrong if 'ThisClass' did not inherit 'first' from\n/// TObject.\n\nBool_t  TClass::IsStartingWithTObject() const\n{\n   if (fProperty==(-1)) Property();\n   return TestBit(kStartWithTObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE is the class inherits from TObject.\n\nBool_t  TClass::IsTObject() const\n{\n   if (fProperty==(-1)) Property();\n   return TestBit(kIsTObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).\n\nBool_t  TClass::IsForeign() const\n{\n   if (fProperty==(-1)) Property();\n   return TestBit(kIsForeign);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Do the initialization that can only be done after the CINT dictionary has\n/// been fully populated and can not be delayed efficiently.\n\nvoid TClass::PostLoadCheck()\n{\n   // In the case of a Foreign class (loaded class without a Streamer function)\n   // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not\n   // be confused with a previously loaded streamerInfo.\n\n   if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo\n       && fStreamerInfo->At(1)*/ && IsForeign() )\n   {\n      SetClassVersion(-1);\n   }\n   // Note: We are careful to check the class version first because checking\n   //       for foreign can trigger an AutoParse.\n   else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign()))\n   {\n      R__LOCKGUARD(gInterpreterMutex);\n\n      TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));\n      // Here we need to check whether this TVirtualStreamerInfo (which presumably has been\n      // loaded from a file) is consistent with the definition in the library we just loaded.\n      // BuildCheck is not appropriate here since it check a streamerinfo against the\n      // 'current streamerinfo' which, at time point, would be the same as 'info'!\n      if (info && GetListOfDataMembers() && !GetCollectionProxy()\n          && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,0,kFALSE,kFALSE, 0) && !(MatchLegacyCheckSum(info->GetCheckSum()))))\n      {\n         Bool_t warn = ! TestBit(kWarned);\n         if (warn && info->GetOldVersion()<=2) {\n            // Names of STL base classes was modified in vers==3. Allocators removed\n            //\n            TIter nextBC(GetListOfBases());\n            TBaseClass *bc;\n            while ((bc=(TBaseClass*)nextBC()))\n            {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}\n         }\n\n         if (warn) {\n            if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {\n               Warning(\"PostLoadCheck\",\"\\n\\\n   The class %s transitioned from not having a specified class version\\n\\\n   to having a specified class version (the current class version is %d).\\n\\\n   However too many different non-versioned layouts of the class have\\n\\\n   already been loaded so far.  To work around this problem you can\\n\\\n   load fewer 'old' file in the same ROOT session or load the C++ library\\n\\\n   describing the class %s before opening the files or increase the version\\n\\\n   number of the class for example ClassDef(%s,%d).\\n\\\n   Do not try to write objects with the current class definition,\\n\\\n   the files might not be readable.\\n\",\n                       GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);\n            } else {\n               Warning(\"PostLoadCheck\",\"\\n\\\n   The StreamerInfo version %d for the class %s which was read\\n\\\n   from a file previously opened has the same version as the active class\\n\\\n   but a different checksum. You should update the version to ClassDef(%s,%d).\\n\\\n   Do not try to write objects with the current class definition,\\n\\\n   the files will not be readable.\\n\"\n                       , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);\n            }\n            info->CompareContent(this,0,kTRUE,kTRUE,0);\n            SetBit(kWarned);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set TObject::fBits and fStreamerType to cache information about the\n/// class.  The bits are\n/// ~~~ {.cpp}\n///    kIsTObject : the class inherits from TObject\n///    kStartWithTObject:  TObject is the left-most class in the inheritance tree\n///    kIsForeign : the class doe not have a Streamer method\n/// ~~~\n/// The value of fStreamerType are\n/// ~~~ {.cpp}\n///    kTObject : the class inherits from TObject\n///    kForeign : the class does not have a Streamer method\n///    kInstrumented: the class does have a Streamer method\n///    kExternal: the class has a free standing way of streaming itself\n///    kEmulatedStreamer: the class is missing its shared library.\n/// ~~~\n\nLong_t TClass::Property() const\n{\n   // Check if we can return without taking the lock,\n   // this is valid since fProperty is atomic and set as\n   // the last operation before return.\n   if (fProperty!=(-1)) return fProperty;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Check if another thread set fProperty while we\n   // were waiting.\n   if (fProperty!=(-1)) return fProperty;\n\n   // Avoid asking about the class when it is still building\n   if (TestBit(kLoading)) return fProperty;\n\n   // When called via TMapFile (e.g. Update()) make sure that the dictionary\n   // gets allocated on the heap and not in the mapped file.\n   TMmallocDescTemp setreset;\n\n   TClass *kl = const_cast<TClass*>(this);\n\n   kl->fStreamerType = TClass::kDefault;\n   kl->fStreamerImpl = &TClass::StreamerDefault;\n\n   if (InheritsFrom(TObject::Class())) {\n      kl->SetBit(kIsTObject);\n\n      // Is it DIRECT inheritance from TObject?\n      Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());\n      if (delta==0) kl->SetBit(kStartWithTObject);\n\n      kl->fStreamerType  = kTObject;\n      kl->fStreamerImpl  = &TClass::StreamerTObject;\n   }\n\n   if (HasInterpreterInfo()) {\n\n      // This code used to use ClassInfo_Has|IsValidMethod but since v6\n      // they return true if the routine is defined in the class or any of\n      // its parent.  We explicitly want to know whether the function is\n      // defined locally.\n      if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(\"Streamer\",\"TBuffer&\",kFALSE)) {\n\n         kl->SetBit(kIsForeign);\n         kl->fStreamerType  = kForeign;\n         kl->fStreamerImpl  = &TClass::StreamerStreamerInfo;\n\n      } else if ( kl->fStreamerType == TClass::kDefault ) {\n         if (kl->fConvStreamerFunc) {\n            kl->fStreamerType  = kInstrumented;\n            kl->fStreamerImpl  = &TClass::ConvStreamerInstrumented;\n         } else if (kl->fStreamerFunc) {\n            kl->fStreamerType  = kInstrumented;\n            kl->fStreamerImpl  = &TClass::StreamerInstrumented;\n         } else {\n            // We have an automatic streamer using the StreamerInfo .. no need to go through the\n            // Streamer method function itself.\n            kl->fStreamerType  = kInstrumented;\n            kl->fStreamerImpl  = &TClass::StreamerStreamerInfo;\n         }\n      }\n\n      if (fStreamer) {\n         kl->fStreamerType  = kExternal;\n         kl->fStreamerImpl  = &TClass::StreamerExternal;\n      }\n\n      if (const_cast<TClass *>(this)->GetClassMethodWithPrototype(\"Hash\", \"\", kTRUE)) {\n         kl->SetBit(kHasLocalHashMember);\n      }\n\n      if (GetClassInfo()) {\n         // In the case where the TClass for one of ROOT's core class\n         // (eg TClonesArray for map<int,TClonesArray*>) is requested\n         // during the execution of rootcling, we could end up in a situation\n         // where we should have the information (since TClonesArray has\n         // a dictionary as part of libCore) but do not because the user\n         // only include a forward declaration of TClonesArray and we do not\n         // forcefully load the header file either (because the autoparsing\n         // is intentionally disabled).\n         kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);\n         // Must set this last since other threads may read fProperty\n         // and think all test bits have been properly set.\n         kl->fProperty = gCling->ClassInfo_Property(fClassInfo);\n      }\n   } else {\n\n      if (fStreamer) {\n         kl->fStreamerType  = kExternal;\n         kl->fStreamerImpl  = &TClass::StreamerExternal;\n      }\n\n      kl->fStreamerType |= kEmulatedStreamer;\n      kl->SetStreamerImpl();\n      // fProperty was *not* set so that it can be forced to be recalculated\n      // next time.\n      return 0;\n   }\n\n   return fProperty;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal routine to set calculate the class properties that can only be\n/// known at run-time, for example whether the Hash member function and the\n/// destructor are consistent.\n\nvoid TClass::SetRuntimeProperties()\n{\n   // For now, no need to lock this routines as fRuntimeProperties is\n   // the only atomic set here and this is done at the end\n   // and there is no downside if the execution is done twice.\n\n   // Note SetRuntimeProperties is set to const as it is technically\n   // thread-safe.\n\n   UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);\n\n   if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this))\n      properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);\n\n   const_cast<TClass *>(this)->fRuntimeProperties = properties;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal routine to set fStreamerImpl based on the value of\n/// fStreamerType.\n\nvoid TClass::SetStreamerImpl()\n{\n   switch (fStreamerType) {\n      case kTObject:  fStreamerImpl  = &TClass::StreamerTObject; break;\n      case kForeign:  fStreamerImpl  = &TClass::StreamerStreamerInfo; break;\n      case kExternal: fStreamerImpl  = &TClass::StreamerExternal; break;\n      case kInstrumented:  {\n         if (fConvStreamerFunc)  fStreamerImpl  = &TClass::ConvStreamerInstrumented;\n         else if (fStreamerFunc) fStreamerImpl  = &TClass::StreamerInstrumented;\n         else                    fStreamerImpl  = &TClass::StreamerStreamerInfo;\n         break;\n      }\n\n      case kEmulatedStreamer:               // intentional fall through\n      case kForeign|kEmulatedStreamer:      // intentional fall through\n      case kInstrumented|kEmulatedStreamer: fStreamerImpl = &TClass::StreamerStreamerInfo; break;\n      case kExternal|kEmulatedStreamer:     fStreamerImpl = &TClass::StreamerExternal; break;\n      case kTObject|kEmulatedStreamer:      fStreamerImpl = &TClass::StreamerTObjectEmulated; break;\n      case TClass::kDefault:                fStreamerImpl = &TClass::StreamerDefault; break;\n      default:\n         Error(\"SetStreamerImpl\",\"Unexpected value of fStreamerType: %d\",fStreamerType);\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create the collection proxy object (and the streamer object) from\n/// using the information in the TCollectionProxyInfo.\n\nvoid TClass::SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &info)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   delete fCollectionProxy;\n\n   // We can not use GetStreamerInfo() instead of TVirtualStreamerInfo::Factory()\n   // because GetStreamerInfo call TStreamerInfo::Build which need to have fCollectionProxy\n   // set correctly.\n\n   TVirtualCollectionProxy *p = TVirtualStreamerInfo::Factory()->GenExplicitProxy(info,this);\n   fCollectionProxy = p;\n\n   AdoptStreamer(TVirtualStreamerInfo::Factory()->GenExplicitClassStreamer(info,this));\n\n   if (fCollectionProxy && !fSchemaRules) {\n      // Numeric Collections have implicit conversions:\n      GetSchemaRules(kTRUE);\n   }\n   fCanSplit = -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Change (i.e. set) the title of the TNamed.\n\nvoid TClass::SetContextMenuTitle(const char *title)\n{\n   fContextMenuTitle = title;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// This function installs a global IsA function for this class.\n/// The global IsA function will be used if there is no local IsA function (fIsA)\n///\n/// A global IsA function has the signature:\n///\n/// ~~~ {.cpp}\n///    TClass *func( TClass *cl, const void *obj);\n/// ~~~\n///\n/// 'cl' is a pointer to the  TClass object that corresponds to the\n/// 'pointer type' used to retrieve the value 'obj'\n///\n///  For example with:\n/// ~~~ {.cpp}\n///    TNamed * m = new TNamed(\"example\",\"test\");\n///    TObject* o = m\n/// ~~~\n/// and\n///    the global IsA function would be called with TObject::Class() as\n///    the first parameter and the exact numerical value in the pointer\n///    'o'.\n///\n///  In other word, inside the global IsA function. it is safe to C-style\n///  cast the value of 'obj' into a pointer to the class described by 'cl'.\n\nvoid TClass::SetGlobalIsA(IsAGlobalFunc_t func)\n{\n   fGlobalIsA = func;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Call this method to indicate that the shared library containing this\n/// class's code has been removed (unloaded) from the process's memory\n\nvoid TClass::SetUnloaded()\n{\n   if (TestBit(kUnloaded) && !TestBit(kUnloading)) {\n      // Don't redo the work.\n      return;\n   }\n   SetBit(kUnloading);\n\n   //R__ASSERT(fState == kLoaded);\n   if (fState != kLoaded) {\n      Fatal(\"SetUnloaded\",\"The TClass for %s is being unloaded when in state %d\\n\",\n            GetName(),(int)fState);\n   }\n\n   // Make sure SetClassInfo, re-calculated the state.\n   fState = kForwardDeclared;\n\n   delete fIsA; fIsA = 0;\n   // Disable the autoloader while calling SetClassInfo, to prevent\n   // the library from being reloaded!\n   {\n      int autoload_old = gCling->SetClassAutoloading(0);\n      TInterpreter::SuspendAutoParsing autoParseRaii(gCling);\n\n      gInterpreter->SetClassInfo(this,kTRUE);\n\n      gCling->SetClassAutoloading(autoload_old);\n   }\n   fDeclFileName = 0;\n   fDeclFileLine = 0;\n   fImplFileName = 0;\n   fImplFileLine = 0;\n   fTypeInfo     = 0;\n\n   if (fMethod.load()) {\n      (*fMethod).Unload();\n   }\n   if (fData) {\n      fData->Unload();\n   }\n   if (fEnums.load()) {\n      (*fEnums).Unload();\n   }\n\n   if (fState <= kForwardDeclared && fStreamerInfo->GetEntries() != 0) {\n      fState = kEmulated;\n   }\n\n   ResetBit(kUnloading);\n   SetBit(kUnloaded);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Info is a string describing the names and types of attributes\n/// written by the class Streamer function.\n/// If info is an empty string (when called by TObject::StreamerInfo)\n/// the default Streamer info string is build. This corresponds to\n/// the case of an automatically generated Streamer.\n/// In case of user defined Streamer function, it is the user responsibility\n/// to implement a StreamerInfo function (override TObject::StreamerInfo).\n/// The user must call IsA()->SetStreamerInfo(info) from this function.\n\nTVirtualStreamerInfo *TClass::SetStreamerInfo(Int_t /*version*/, const char * /*info*/)\n{\n   // info is specified, nothing to do, except that we should verify\n   // that it contains a valid descriptor.\n\n/*\n   TDataMember *dm;\n   Int_t nch = strlen(info);\n   Bool_t update = kTRUE;\n   if (nch != 0) {\n      //decode strings like \"TObject;TAttLine;fA;fB;Int_t i,j,k;\"\n      char *save, *temp, *blank, *colon, *comma;\n      save = new char[10000];\n      temp = save;\n      strlcpy(temp,info,10000);\n      //remove heading and trailing blanks\n      while (*temp == ' ') temp++;\n      while (save[nch-1] == ' ') {nch--; save[nch] = 0;}\n      if (nch == 0) {delete [] save; return;}\n      if (save[nch-1] != ';') {save[nch] = ';'; save[nch+1] = 0;}\n      //remove blanks around , or ;\n      while ((blank = strstr(temp,\"; \"))) strcpy(blank+1,blank+2);\n      while ((blank = strstr(temp,\" ;\"))) strcpy(blank,  blank+1);\n      while ((blank = strstr(temp,\", \"))) strcpy(blank+1,blank+2);\n      while ((blank = strstr(temp,\" ,\"))) strcpy(blank,  blank+1);\n      while ((blank = strstr(temp,\"  \"))) strcpy(blank,  blank+1);\n      //loop on tokens separated by ;\n      char *final = new char[1000];\n      char token[100];\n      while ((colon=strchr(temp,';'))) {\n         *colon = 0;\n         strlcpy(token,temp,100);\n         blank = strchr(token,' ');\n         if (blank) {\n            *blank = 0;\n            if (!gROOT->GetType(token)) {\n               Error(\"SetStreamerInfo\",\"Illegal type: %s in %s\",token,info);\n               return;\n            }\n            while (blank) {\n               strlcat(final,token,1000);\n               strlcat(final,\" \",1000);\n               comma = strchr(blank+1,','); if (comma) *comma=0;\n               strlcat(final,blank+1,1000);\n               strlcat(final,\";\",1000);\n               blank = comma;\n            }\n\n         } else {\n            if (TClass::GetClass(token,update)) {\n               //a class name\n               strlcat(final,token,1000); strlcat(final,\";\",1000);\n            } else {\n               //a data member name\n               dm = (TDataMember*)GetListOfDataMembers()->FindObject(token);\n               if (dm) {\n                  strlcat(final,dm->GetFullTypeName(),1000);\n                  strlcat(final,\" \",1000);\n                  strlcat(final,token,1000); strlcat(final,\";\",1000);\n               } else {\n                  Error(\"SetStreamerInfo\",\"Illegal name: %s in %s\",token,info);\n                  return;\n               }\n            }\n            update = kFALSE;\n         }\n         temp = colon+1;\n         if (*temp == 0) break;\n      }\n ////     fStreamerInfo = final;\n      delete [] final;\n      delete [] save;\n      return;\n   }\n\n   //info is empty. Let's build the default Streamer descriptor\n\n   char *temp = new char[10000];\n   temp[0] = 0;\n   char local[100];\n\n   //add list of base classes\n   TIter nextb(GetListOfBases());\n   TBaseClass *base;\n   while ((base = (TBaseClass*) nextb())) {\n      snprintf(local,100,\"%s;\",base->GetName());\n      strlcat(temp,local,10000);\n   }\n\n   //add list of data members and types\n   TIter nextd(GetListOfDataMembers());\n   while ((dm = (TDataMember *) nextd())) {\n      if (dm->IsEnum()) continue;\n      if (!dm->IsPersistent()) continue;\n      Long_t property = dm->Property();\n      if (property & kIsStatic) continue;\n      TClass *acl = TClass::GetClass(dm->GetTypeName(),update);\n      update = kFALSE;\n      if (acl) {\n         if (acl->GetClassVersion() == 0) continue;\n      }\n\n      // dm->GetArrayIndex() returns an empty string if it does not\n      // applies\n      const char * index = dm->GetArrayIndex();\n      if (strlen(index)==0)\n         snprintf(local,100,\"%s %s;\",dm->GetFullTypeName(),dm->GetName());\n      else\n         snprintf(local,100,\"%s %s[%s];\",dm->GetFullTypeName(),dm->GetName(),index);\n      strlcat(temp,local,10000);\n   }\n   //fStreamerInfo = temp;\n   delete [] temp;\n*/\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the checksum passed as argument is one of the checksum\n/// value produced by the older checksum calculation algorithm.\n\nBool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const\n{\n   for(UInt_t i = 1; i < kLatestCheckSum; ++i) {\n      if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;\n   }\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Call GetCheckSum with validity check.\n\nUInt_t TClass::GetCheckSum(ECheckSum code) const\n{\n   bool isvalid;\n   return GetCheckSum(code,isvalid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return GetCheckSum(kCurrentCheckSum,isvalid);\n\nUInt_t TClass::GetCheckSum(Bool_t &isvalid) const\n{\n   return GetCheckSum(kCurrentCheckSum,isvalid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Compute and/or return the class check sum.\n///\n/// isvalid is set to false, if the function is unable to calculate the\n/// checksum.\n///\n/// The class ckecksum is used by the automatic schema evolution algorithm\n/// to uniquely identify a class version.\n/// The check sum is built from the names/types of base classes and\n/// data members.\n/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).\n///\n/// The valid range of code is determined by ECheckSum.\n///\n///  - kNoEnum:  data members of type enum are not counted in the checksum\n///  - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.\n///  - kWithTypeDef: use the sugared type name in the calculation.\n///\n/// This is needed for backward compatibility.\n///\n/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.\n/// They are both used to handle backward compatibility and should both return the same values.\n/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information\n/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.\n\nUInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const\n{\n   // fCheckSum is an atomic variable.  Also once it has\n   // transition from a zero Value it never changes.  If two\n   // thread reach past this if statement and calculated the\n   // 'kLastestCheckSum', they will by definition obtain the\n   // same value, so technically we could simply have:\n   //    if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;\n   // However save a little bit of barrier time by calling load()\n   // only once.\n\n   isvalid = kTRUE;\n\n   UInt_t currentChecksum = fCheckSum.load();\n   if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // kCurrentCheckSum (0) is the default parameter value and should be kept\n   // for backward compatibility, too be able to use the inequality checks,\n   // we need to set the code to the largest value.\n   if (code == kCurrentCheckSum) code = kLatestCheckSum;\n\n   UInt_t id = 0;\n\n   int il;\n   TString name = GetName();\n   TString type;\n   il = name.Length();\n   for (int i=0; i<il; i++) id = id*3+name[i];\n\n   TList *tlb = ((TClass*)this)->GetListOfBases();\n   if (tlb && !GetCollectionProxy()) {   // Loop over bases if not a proxied collection\n\n      TIter nextBase(tlb);\n\n      TBaseClass *tbc=0;\n      while((tbc=(TBaseClass*)nextBase())) {\n         name = tbc->GetName();\n         Bool_t isSTL = TClassEdit::IsSTLCont(name);\n         if (isSTL)\n            name = TClassEdit::ShortType( name, TClassEdit::kDropStlDefault );\n         il = name.Length();\n         for (int i=0; i<il; i++) id = id*3+name[i];\n         if (code > kNoBaseCheckSum && !isSTL) {\n            if (tbc->GetClassPointer() == 0) {\n               Error(\"GetCheckSum\",\"Calculating the checksum for (%s) requires the base class (%s) meta information to be available!\",\n                     GetName(),tbc->GetName());\n               isvalid = kFALSE;\n               return 0;\n            } else\n               id = id*3 + tbc->GetClassPointer()->GetCheckSum();\n         }\n      }/*EndBaseLoop*/\n   }\n   TList *tlm = ((TClass*)this)->GetListOfDataMembers();\n   if (tlm) {   // Loop over members\n      TIter nextMemb(tlm);\n      TDataMember *tdm=0;\n      Long_t prop = 0;\n      while((tdm=(TDataMember*)nextMemb())) {\n         if (!tdm->IsPersistent())        continue;\n         //  combine properties\n         prop = (tdm->Property());\n         TDataType* tdt = tdm->GetDataType();\n         if (tdt) prop |= tdt->Property();\n\n         if ( prop&kIsStatic)             continue;\n         name = tdm->GetName(); il = name.Length();\n         if ( (code > kNoEnum) && code != kReflex && code != kReflexNoComment && prop&kIsEnum)\n            id = id*3 + 1;\n\n         int i;\n         for (i=0; i<il; i++) id = id*3+name[i];\n\n         if (code > kWithTypeDef || code == kReflexNoComment) {\n            type = tdm->GetTrueTypeName();\n            // GetTrueTypeName uses GetFullyQualifiedName which already drops\n            // the default template parameter, so we no longer need to do this.\n            //if (TClassEdit::IsSTLCont(type))\n            //   type = TClassEdit::ShortType( type, TClassEdit::kDropStlDefault );\n            if (code == kReflex || code == kReflexNoComment) {\n               if (prop&kIsEnum) {\n                  type = \"int\";\n               } else {\n                  type.ReplaceAll(\"ULong64_t\",\"unsigned long long\");\n                  type.ReplaceAll(\"Long64_t\",\"long long\");\n                  type.ReplaceAll(\"<signed char\",\"<char\");\n                  type.ReplaceAll(\",signed char\",\",char\");\n                  if (type==\"signed char\") type = \"char\";\n               }\n            }\n         } else {\n            type = tdm->GetFullTypeName();\n            // GetFullTypeName uses GetFullyQualifiedName which already drops\n            // the default template parameter, so we no longer need to do this.\n            //if (TClassEdit::IsSTLCont(type))\n            //   type = TClassEdit::ShortType( type, TClassEdit::kDropStlDefault );\n         }\n\n         il = type.Length();\n         for (i=0; i<il; i++) id = id*3+type[i];\n\n         int dim = tdm->GetArrayDim();\n         if (prop&kIsArray) {\n            for (int ii=0;ii<dim;ii++) id = id*3+tdm->GetMaxIndex(ii);\n         }\n         if (code > kNoRange) {\n            const char *left;\n            if (code > TClass::kNoRangeCheck)\n               left = TVirtualStreamerInfo::GetElementCounterStart(tdm->GetTitle());\n            else\n               left = strstr(tdm->GetTitle(),\"[\");\n            if (left) {\n               const char *right = strstr(left,\"]\");\n               if (right) {\n                  ++left;\n                  while (left != right) {\n                     id = id*3 + *left;\n                     ++left;\n                  }\n               }\n            }\n         }\n      }/*EndMembLoop*/\n   }\n   // This should be moved to Initialization time however the last time\n   // we tried this cause problem, in particular in the end-of-process operation.\n   if (code==kLatestCheckSum) fCheckSum = id;\n   return id;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Adopt the Reference proxy pointer to indicate that this class\n/// represents a reference.\n/// When a new proxy is adopted, the old one is deleted.\n\nvoid TClass::AdoptReferenceProxy(TVirtualRefProxy* proxy)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if ( fRefProxy )  {\n      fRefProxy->Release();\n   }\n   fRefProxy = proxy;\n   if ( fRefProxy )  {\n      fRefProxy->SetClass(this);\n   }\n   fCanSplit = -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Adopt the TMemberStreamer pointer to by p and use it to Stream non basic\n/// member name.\n\nvoid TClass::AdoptMemberStreamer(const char *name, TMemberStreamer *p)\n{\n   if (!fRealData) return;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TIter next(fRealData);\n   TRealData *rd;\n   while ((rd = (TRealData*)next())) {\n      if (strcmp(rd->GetName(),name) == 0) {\n         // If there is a TStreamerElement that took a pointer to the\n         // streamer we should inform it!\n         rd->AdoptStreamer(p);\n         break;\n      }\n   }\n\n//  NOTE: This alternative was proposed but not is not used for now,\n//  One of the major difference with the code above is that the code below\n//  did not require the RealData to have been built\n//    if (!fData) return;\n//    const char *n = name;\n//    while (*n=='*') n++;\n//    TString ts(n);\n//    int i = ts.Index(\"[\");\n//    if (i>=0) ts.Remove(i,999);\n//    TDataMember *dm = (TDataMember*)fData->FindObject(ts.Data());\n//    if (!dm) {\n//       Warning(\"SetStreamer\",\"Can not find member %s::%s\",GetName(),name);\n//       return;\n//    }\n//    dm->SetStreamer(p);\n   return;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new member streamer (p will be copied).\n\nvoid TClass::SetMemberStreamer(const char *name, MemberStreamerFunc_t p)\n{\n   AdoptMemberStreamer(name,new TMemberStreamer(p));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Function called by the Streamer functions to deserialize information\n/// from buffer b into object at p.\n/// This function assumes that the class version and the byte count information\n/// have been read.\n///  - version  is the version number of the class\n///  - start    is the starting position in the buffer b\n///  - count    is the number of bytes for this object in the buffer\n\nInt_t TClass::ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count)\n{\n   return b.ReadClassBuffer(this,pointer,version,start,count);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Function called by the Streamer functions to deserialize information\n/// from buffer b into object at p.\n\nInt_t TClass::ReadBuffer(TBuffer &b, void *pointer)\n{\n   return b.ReadClassBuffer(this,pointer);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Function called by the Streamer functions to serialize object at p\n/// to buffer b. The optional argument info may be specified to give an\n/// alternative StreamerInfo instead of using the default StreamerInfo\n/// automatically built from the class definition.\n/// For more information, see class TVirtualStreamerInfo.\n\nInt_t TClass::WriteBuffer(TBuffer &b, void *pointer, const char * /*info*/)\n{\n   b.WriteClassBuffer(this,pointer);\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///There is special streamer for the class\n\nvoid TClass::StreamerExternal(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class)\n{\n   //      case kExternal:\n   //      case kExternal|kEmulatedStreamer:\n\n   TClassStreamer *streamer = gThreadTsd ? pThis->GetStreamer() : pThis->fStreamer;\n   streamer->Stream(b,object,onfile_class);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of TObjects\n\nvoid TClass::StreamerTObject(const TClass* pThis, void *object, TBuffer &b, const TClass * /* onfile_class */)\n{\n   // case kTObject:\n\n   if (!pThis->fIsOffsetStreamerSet) {\n      pThis->CalculateStreamerOffset();\n   }\n   TObject *tobj = (TObject*)((Long_t)object + pThis->fOffsetStreamer);\n   tobj->Streamer(b);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of TObjects when fIsOffsetStreamerSet is known to have been set.\n\nvoid TClass::StreamerTObjectInitialized(const TClass* pThis, void *object, TBuffer &b, const TClass * /* onfile_class */)\n{\n   TObject *tobj = (TObject*)((Long_t)object + pThis->fOffsetStreamer);\n   tobj->Streamer(b);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of TObjects when we do not have the library defining the class.\n\nvoid TClass::StreamerTObjectEmulated(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class)\n{\n   // case kTObject|kEmulatedStreamer :\n   if (b.IsReading()) {\n      b.ReadClassEmulated(pThis, object, onfile_class);\n   } else {\n      b.WriteClassBuffer(pThis, object);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of instrumented class with a library\n\nvoid TClass::StreamerInstrumented(const TClass* pThis, void *object, TBuffer &b, const TClass * /* onfile_class */)\n{\n   // case kInstrumented:\n   pThis->fStreamerFunc(b,object);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of instrumented class with a library\n\nvoid TClass::ConvStreamerInstrumented(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class)\n{\n   // case kInstrumented:\n   pThis->fConvStreamerFunc(b,object,onfile_class);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Case of where we should directly use the StreamerInfo.\n///  - case kForeign:\n///  - case kForeign|kEmulatedStreamer:\n///  - case kInstrumented|kEmulatedStreamer:\n///  - case kEmulatedStreamer:\n\nvoid TClass::StreamerStreamerInfo(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class)\n{\n   if (b.IsReading()) {\n      b.ReadClassBuffer(pThis, object, onfile_class);\n      //ReadBuffer (b, object);\n   } else {\n      //WriteBuffer(b, object);\n      b.WriteClassBuffer(pThis, object);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Default streaming in cases where either we have no way to know what to do\n/// or if Property() has not yet been called.\n\nvoid TClass::StreamerDefault(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class)\n{\n   if (pThis->fProperty==(-1)) {\n      pThis->Property();\n   }\n\n   // We could get here because after this thread started StreamerDefault\n   // *and* before check fProperty, another thread might have call Property\n   // and this fProperty when we read it, is not -1 and fStreamerImpl is\n   // supposed to be set properly (no longer pointing to the default).\n   if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {\n      pThis->Fatal(\"StreamerDefault\", \"fStreamerImpl not properly initialized (%d)\", pThis->fStreamerType);\n   } else {\n      (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Adopt a TClassStreamer object.  Ownership is transfered to this TClass\n/// object.\n\nvoid TClass::AdoptStreamer(TClassStreamer *str)\n{\n//    // This code can be used to quickly test the STL Emulation layer\n//    Int_t k = TClassEdit::IsSTLCont(GetName());\n//    if (k==1||k==-1) { delete str; return; }\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (fStreamer) delete fStreamer;\n   if (str) {\n      fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );\n      fStreamer = str;\n      fStreamerImpl = &TClass::StreamerExternal;\n   } else if (fStreamer) {\n      // Case where there was a custom streamer and it is hereby removed,\n      // we need to reset fStreamerType\n      fStreamer = str;\n      fStreamerType = TClass::kDefault;\n      if (fProperty != -1) {\n         fProperty = -1;\n         Property();\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a wrapper/accessor function around this class custom streamer.\n\nvoid TClass::SetStreamerFunc(ClassStreamerFunc_t strm)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (fProperty != -1 && !fConvStreamerFunc &&\n       ( (fStreamerFunc == 0 && strm != 0) || (fStreamerFunc != 0 && strm == 0) ) )\n   {\n      fStreamerFunc = strm;\n\n      // Since initialization has already been done, make sure to tweak it\n      // for the new state.\n      if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {\n         fStreamerType  = kInstrumented;\n         fStreamerImpl  = &TClass::StreamerInstrumented;\n      }\n   } else {\n      fStreamerFunc = strm;\n   }\n   fCanSplit = -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a wrapper/accessor function around this class custom conversion streamer.\n\nvoid TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (fProperty != -1 &&\n       ( (fConvStreamerFunc == 0 && strm != 0) || (fConvStreamerFunc != 0 && strm == 0) ) )\n   {\n      fConvStreamerFunc = strm;\n\n      // Since initialization has already been done, make sure to tweak it\n      // for the new state.\n      if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {\n         fStreamerType  = kInstrumented;\n         fStreamerImpl  = &TClass::ConvStreamerInstrumented;\n      }\n   } else {\n      fConvStreamerFunc = strm;\n   }\n   fCanSplit = -1;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'Merge'.\n\nvoid TClass::SetMerge(ROOT::MergeFunc_t newMerge)\n{\n   fMerge = newMerge;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'ResetAfterMerge'.\n\nvoid TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset)\n{\n   fResetAfterMerge = newReset;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'new'.\n\nvoid TClass::SetNew(ROOT::NewFunc_t newFunc)\n{\n   fNew = newFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'new []'.\n\nvoid TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc)\n{\n   fNewArray = newArrayFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'delete'.\n\nvoid TClass::SetDelete(ROOT::DelFunc_t deleteFunc)\n{\n   fDelete = deleteFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around 'delete []'.\n\nvoid TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc)\n{\n   fDeleteArray = deleteArrayFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around the destructor.\n\nvoid TClass::SetDestructor(ROOT::DesFunc_t destructorFunc)\n{\n   fDestructor = destructorFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Install a new wrapper around the directory auto add function..\n/// The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir)\n/// and should register 'obj' to the directory if dir is not null\n/// and unregister 'obj' from its current directory if dir is null\n\nvoid TClass::SetDirectoryAutoAdd(ROOT::DirAutoAdd_t autoAddFunc)\n{\n   fDirAutoAdd = autoAddFunc;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum\n\nTVirtualStreamerInfo *TClass::FindStreamerInfo(UInt_t checksum) const\n{\n   TVirtualStreamerInfo *guess = fLastReadInfo;\n   if (guess && guess->GetCheckSum() == checksum) {\n      return guess;\n   } else {\n      if (fCheckSum == checksum) return GetStreamerInfo();\n\n      R__LOCKGUARD(gInterpreterMutex);\n      Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;\n      for (Int_t i=-1;i<ninfos;++i) {\n         // TClass::fStreamerInfos has a lower bound not equal to 0,\n         // so we have to use At and should not use UncheckedAt\n         TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);\n         if (info && info->GetCheckSum() == checksum) {\n            // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));\n            info->BuildOld();\n            if (info->IsCompiled()) fLastReadInfo = info;\n            return info;\n         }\n      }\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum\n\nTVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   Int_t ninfos = arr->GetEntriesFast()-1;\n   for (Int_t i=-1;i<ninfos;i++) {\n      // TClass::fStreamerInfos has a lower bound not equal to 0,\n      // so we have to use At and should not use UncheckedAt\n      TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);\n      if (!info) continue;\n      if (info->GetCheckSum() == checksum) {\n         R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));\n         return info;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.\n\nTVirtualStreamerInfo *TClass::GetConversionStreamerInfo( const char* classname, Int_t version ) const\n{\n   TClass *cl = TClass::GetClass( classname );\n   if( !cl )\n      return 0;\n   return GetConversionStreamerInfo( cl, version );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any.\n\nTVirtualStreamerInfo *TClass::GetConversionStreamerInfo( const TClass* cl, Int_t version ) const\n{\n   //----------------------------------------------------------------------------\n   // Check if the classname was specified correctly\n   /////////////////////////////////////////////////////////////////////////////\n\n   if( !cl )\n      return 0;\n\n   if( cl == this )\n      return GetStreamerInfo( version );\n\n   //----------------------------------------------------------------------------\n   // Check if we already have it\n   /////////////////////////////////////////////////////////////////////////////\n\n   TObjArray* arr = 0;\n   if (fConversionStreamerInfo.load()) {\n      std::map<std::string, TObjArray*>::iterator it;\n      R__LOCKGUARD(gInterpreterMutex);\n\n      it = (*fConversionStreamerInfo).find( cl->GetName() );\n\n      if( it != (*fConversionStreamerInfo).end() ) {\n         arr = it->second;\n      }\n\n      if( arr && version > -1 && version < arr->GetSize() && arr->At( version ) )\n         return (TVirtualStreamerInfo*) arr->At( version );\n   }\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   //----------------------------------------------------------------------------\n   // We don't have the streamer info so find it in other class\n   /////////////////////////////////////////////////////////////////////////////\n\n   const TObjArray *clSI = cl->GetStreamerInfos();\n   TVirtualStreamerInfo* info = 0;\n   if( version >= -1 && version < clSI->GetSize() )\n      info = (TVirtualStreamerInfo*)clSI->At( version );\n\n   if (!info && cl->GetCollectionProxy()) {\n      info = cl->GetStreamerInfo(); // instantiate the StreamerInfo for STL collections.\n   }\n\n   if( !info )\n      return 0;\n\n   //----------------------------------------------------------------------------\n   // We have the right info so we need to clone it to create new object with\n   // non artificial streamer elements and we should build it for current class\n   /////////////////////////////////////////////////////////////////////////////\n\n   info = (TVirtualStreamerInfo*)info->Clone();\n\n   if( !info->BuildFor( this ) ) {\n      delete info;\n      return 0;\n   }\n\n   if (!info->IsCompiled()) {\n      // Streamer info has not been compiled, but exists.\n      // Therefore it was read in from a file and we have to do schema evolution?\n      // Or it didn't have a dictionary before, but does now?\n      info->BuildOld();\n   }\n\n   //----------------------------------------------------------------------------\n   // Cache this streamer info\n   /////////////////////////////////////////////////////////////////////////////\n\n   if (!arr) {\n      arr = new TObjArray(version+10, -1);\n      if (!fConversionStreamerInfo.load()) {\n         fConversionStreamerInfo = new std::map<std::string, TObjArray*>();\n      }\n      (*fConversionStreamerInfo)[cl->GetName()] = arr;\n   }\n   arr->AddAtAndExpand( info, info->GetClassVersion() );\n   return info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.\n\nTVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const\n{\n   TClass *cl = TClass::GetClass( classname );\n   if( !cl )\n      return 0;\n   return FindConversionStreamerInfo( cl, checksum );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.\n\nTVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const\n{\n   //---------------------------------------------------------------------------\n   // Check if the classname was specified correctly\n   /////////////////////////////////////////////////////////////////////////////\n\n   if( !cl )\n      return 0;\n\n   if( cl == this )\n      return FindStreamerInfo( checksum );\n\n   //----------------------------------------------------------------------------\n   // Check if we already have it\n   /////////////////////////////////////////////////////////////////////////////\n\n   TObjArray* arr = 0;\n   TVirtualStreamerInfo* info = 0;\n   if (fConversionStreamerInfo.load()) {\n      std::map<std::string, TObjArray*>::iterator it;\n\n      R__LOCKGUARD(gInterpreterMutex);\n\n      it = (*fConversionStreamerInfo).find( cl->GetName() );\n\n      if( it != (*fConversionStreamerInfo).end() ) {\n         arr = it->second;\n      }\n      if (arr) {\n         info = FindStreamerInfo( arr, checksum );\n      }\n   }\n\n   if( info )\n      return info;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   //----------------------------------------------------------------------------\n   // Get it from the foreign class\n   /////////////////////////////////////////////////////////////////////////////\n\n   info = cl->FindStreamerInfo( checksum );\n\n   if( !info )\n      return 0;\n\n   //----------------------------------------------------------------------------\n   // We have the right info so we need to clone it to create new object with\n   // non artificial streamer elements and we should build it for current class\n   /////////////////////////////////////////////////////////////////////////////\n\n   info = (TVirtualStreamerInfo*)info->Clone();\n   if( !info->BuildFor( this ) ) {\n      delete info;\n      return 0;\n   }\n\n   if (!info->IsCompiled()) {\n      // Streamer info has not been compiled, but exists.\n      // Therefore it was read in from a file and we have to do schema evolution?\n      // Or it didn't have a dictionary before, but does now?\n      info->BuildOld();\n   }\n\n   //----------------------------------------------------------------------------\n   // Cache this streamer info\n   /////////////////////////////////////////////////////////////////////////////\n\n   if (!arr) {\n      arr = new TObjArray(16, -2);\n      if (!fConversionStreamerInfo.load()) {\n         fConversionStreamerInfo = new std::map<std::string, TObjArray*>();\n      }\n      (*fConversionStreamerInfo)[cl->GetName()] = arr;\n   }\n   arr->AddAtAndExpand( info, info->GetClassVersion() );\n\n   return info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register the StreamerInfo in the given slot, change the State of the\n/// TClass as appropriate.\n\nvoid TClass::RegisterStreamerInfo(TVirtualStreamerInfo *info)\n{\n   if (info) {\n      R__LOCKGUARD(gInterpreterMutex);\n      Int_t slot = info->GetClassVersion();\n      if (fStreamerInfo->GetSize() > (slot-fStreamerInfo->LowerBound())\n          && fStreamerInfo->At(slot) != 0\n          && fStreamerInfo->At(slot) != info) {\n         Error(\"RegisterStreamerInfo\",\n               \"Register StreamerInfo for %s on non-empty slot (%d).\",\n               GetName(),slot);\n      }\n      fStreamerInfo->AddAtAndExpand(info, slot);\n      if (fState <= kForwardDeclared) {\n         fState = kEmulated;\n         if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove and delete the StreamerInfo in the given slot.\n/// Update the slot accordingly.\n\nvoid TClass::RemoveStreamerInfo(Int_t slot)\n{\n   if (fStreamerInfo->GetSize() >= slot) {\n      R__LOCKGUARD(gInterpreterMutex);\n      TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);\n      fStreamerInfo->RemoveAt(fClassVersion);\n      delete info;\n      if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {\n         fState = kForwardDeclared;\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all\n/// classes in the class hierarchy that overload TObject::Hash do call\n/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.\n/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.\n/// This routines is used for a small subset of the class for which we need\n/// the answer before gROOT is properly initialized.\n\nBool_t ROOT::Internal::HasConsistentHashMember(const char *cname)\n{\n   // Hand selection of correct classes, those classes should be\n   // cross-checked in testHashRecursiveRemove.cxx\n   static const char *handVerified[] = {\n      \"TEnvRec\",    \"TDataType\",      \"TObjArray\",    \"TList\",   \"THashList\",\n      \"TClass\",     \"TCling\",         \"TInterpreter\", \"TMethod\", \"ROOT::Internal::TCheckHashRecursiveRemoveConsistency\",\n      \"TCheckHashRecursiveRemoveConsistency\", \"TGWindow\",\n      \"TDirectory\", \"TDirectoryFile\", \"TObject\",      \"TH1\",\n      \"TQClass\", \"TGlobal\" };\n\n   if (cname && cname[0]) {\n      for (auto cursor : handVerified) {\n         if (strcmp(cname, cursor) == 0)\n            return true;\n      }\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all\n/// classes in the class hierarchy that overload TObject::Hash do call\n/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.\n/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.\n\nBool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef)\n{\n   return clRef.HasConsistentHashMember();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if we have access to a constructor useable for I/O.  This is\n/// typically the default constructor but can also be a constructor specifically\n/// marked for I/O (for example a constructor taking a TRootIOCtor* as an\n/// argument).  In other words, if this routine returns true, TClass::New is\n/// guarantee to succeed.\n/// To know if the class described by this TClass has a default constructor\n/// (public or not), use\n/// \\code{.cpp}\n///     cl->GetProperty() & kClassHasDefaultCtor\n/// \\code\n/// To know if the class described by this TClass has a public default\n/// constructor use:\n/// \\code{.cpp}\n///    gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());\n/// \\code\n\nBool_t TClass::HasDefaultConstructor() const\n{\n\n   if (fNew) return kTRUE;\n\n   if (HasInterpreterInfo()) {\n      R__LOCKGUARD(gInterpreterMutex);\n      return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo());\n   }\n   if (fCollectionProxy) {\n      return kTRUE;\n   }\n   if (fCurrentInfo.load()) {\n      // Emulated class, we know how to construct them via the TStreamerInfo\n      return kTRUE;\n   }\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns true if this class has an definition and/or overload of the\n/// member function Hash.\n///\n/// For example to test if the class overload TObject::Hash use\n/// ~~~ {.cpp}\n///     if (cl->IsTObject() && cl->HasLocalHashMember())\n/// ~~~\n\nBool_t TClass::HasLocalHashMember() const\n{\n   if (fProperty == (-1))\n      Property();\n   return TestBit(kHasLocalHashMember);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around Merge.\n\nROOT::MergeFunc_t TClass::GetMerge() const\n{\n   return fMerge;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around Merge.\n\nROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const\n{\n   return fResetAfterMerge;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around new ThisClass().\n\nROOT::NewFunc_t TClass::GetNew() const\n{\n   return fNew;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around new ThisClass[].\n\nROOT::NewArrFunc_t TClass::GetNewArray() const\n{\n   return fNewArray;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around delete ThiObject.\n\nROOT::DelFunc_t TClass::GetDelete() const\n{\n   return fDelete;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around delete [] ThiObject.\n\nROOT::DelArrFunc_t TClass::GetDeleteArray() const\n{\n   return fDeleteArray;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around the destructor\n\nROOT::DesFunc_t TClass::GetDestructor() const\n{\n   return fDestructor;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the wrapper around the directory auto add function.\n\nROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd() const\n{\n   return fDirAutoAdd;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/rootcling_stage1/src/rootcling_stage1.cxx": "// Authors: Axel Naumann, Philippe Canal, Danilo Piparo\n\n/*************************************************************************\n * Copyright (C) 1995-2016, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n#include \"rootcling_impl.h\"\n#include \"RConfigure.h\"\n#include <ROOT/RConfig.h>\n#include <stdlib.h>\n\nextern \"C\" {\n   R__DLLEXPORT void usedToIdentifyRootClingByDlSym() {}\n}\n\n// force compiler to emit symbol for function above\nstatic void (*dlsymaddr)() = &usedToIdentifyRootClingByDlSym;\n\nROOT::Internal::RootCling::TROOTSYSSetter gROOTSYSSetter;\n\nstatic const char *GetIncludeDir() {\n   static std::string incdir = std::string(getenv(\"ROOTSYS\")) + \"/include\";\n   return incdir.c_str();\n}\n\nstatic const char *GetEtcDir() {\n   static std::string etcdir = std::string(getenv(\"ROOTSYS\")) + \"/etc\";\n   return etcdir.c_str();\n}\n\nint main(int argc, char **argv)\n{\n   (void) dlsymaddr; // avoid unused variable warning\n\n   ROOT::Internal::RootCling::DriverConfig config{};\n\n   config.fBuildingROOTStage1 = true;\n   config.fTROOT__GetIncludeDir = &GetIncludeDir;\n   config.fTROOT__GetEtcDir = &GetEtcDir;\n\n   return ROOT_rootcling_Driver(argc, argv, config);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/multiproc/src/TMPClient.cxx": "/* @(#)root/multiproc:$Id$ */\n// Author: Enrico Guiraud July 2015\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n#include \"MPCode.h\"\n#include \"TGuiFactory.h\" //gGuiFactory\n#include \"TError.h\" //gErrorIgnoreLevel\n#include \"TMPClient.h\"\n#include \"TMPWorker.h\"\n#include \"TROOT.h\" //gROOT\n#include \"TSocket.h\"\n#include \"TSystem.h\" //gSystem\n#include \"TVirtualX.h\" //gVirtualX\n#include <errno.h> //errno, used by socketpair\n#include <memory> //unique_ptr\n#include <sys/socket.h> //socketpair\n#include <sys/wait.h> // waitpid\n#include <unistd.h> // close, fork\n#include <dlfcn.h>\n\n//////////////////////////////////////////////////////////////////////////\n///\n/// \\class TMPClient\n///\n/// Base class for multiprocess applications' clients. It provides a\n/// simple interface to fork a ROOT session into server/worker sessions\n/// and exchange messages with them. Multiprocessing applications can build\n/// on TMPClient and TMPWorker: the class providing multiprocess\n/// functionalities to users should inherit (possibly privately) from\n/// TMPClient, and the workers executing tasks should inherit from TMPWorker.\n///\n//////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////\n/// Class constructor.\n/// \\param nWorkers\n/// \\parblock\n/// the number of children processes that will be created by\n/// Fork, i.e. the number of workers that will be available after this call.\n/// The default value (0) means that a number of workers equal to the number\n/// of cores of the machine is going to be spawned. If that information is\n/// not available, 2 workers are created instead.\n/// \\endparblock\nTMPClient::TMPClient(unsigned nWorkers) : fIsParent(true), fWorkerPids(), fMon(), fNWorkers(0)\n{\n   // decide on number of workers\n   if (nWorkers) {\n      fNWorkers = nWorkers;\n   } else {\n      SysInfo_t si;\n      if (gSystem->GetSysInfo(&si) == 0)\n         fNWorkers = si.fCpus;\n      else\n         fNWorkers = 2;\n   }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// Class destructor.\n/// This method is in charge of shutting down any remaining worker,\n/// closing off connections and reap the terminated children processes.\nTMPClient::~TMPClient()\n{\n   Broadcast(MPCode::kShutdownOrder);\n   TList *l = fMon.GetListOfActives();\n   l->Delete();\n   delete l;\n   l = fMon.GetListOfDeActives();\n   l->Delete();\n   delete l;\n   fMon.RemoveAll();\n   ReapWorkers();\n}\n\nnamespace ROOT {\n   namespace Internal {\n      /// Class to acquire and release the Python GIL where it applies, i.e.\n      /// if libPython is loaded and the interpreter is initialized.\n      class TGILRAII {\n         using Py_IsInitialized_type = int (*)(void);\n         using PyGILState_Ensure_type = void* (*)(void);\n         using PyGILState_Release_type = void (*)(void*);\n         void* fPyGILState_STATE = nullptr;\n         template<class FPTYPE>\n         FPTYPE GetSymT(const char* name) {return (FPTYPE) dlsym(nullptr,name);}\n      public:\n         TGILRAII()\n         {\n            auto Py_IsInitialized = GetSymT<Py_IsInitialized_type>(\"Py_IsInitialized\");\n            if (!Py_IsInitialized || !Py_IsInitialized()) return;\n            auto PyGILState_Ensure = GetSymT<PyGILState_Ensure_type>(\"PyGILState_Ensure\");\n            if (PyGILState_Ensure) fPyGILState_STATE = PyGILState_Ensure();\n         }\n\n         ~TGILRAII()\n         {\n            auto PyGILState_Release = GetSymT<PyGILState_Release_type>(\"PyGILState_Release\");\n            if (fPyGILState_STATE && PyGILState_Release) PyGILState_Release(fPyGILState_STATE);\n         }\n      };\n   }\n}\n\n//////////////////////////////////////////////////////////////////////////\n/// This method forks the ROOT session into fNWorkers children processes.\n/// The ROOT sessions spawned in this way will not have graphical\n/// capabilities and will not read from standard input, but will be\n/// connected to the original (interactive) session through TSockets.\n/// The children processes' PIDs are added to the fWorkerPids vector.\n/// The parent session can then communicate with the children using the\n/// Broadcast and MPSend methods, and receive messages through MPRecv.\\n\n/// \\param server\n/// \\parblock\n/// A pointer to an instance of the class that will take control\n/// of the subprocesses after forking. Applications should implement their\n/// own class inheriting from TMPWorker. Behaviour can be customized\n/// overriding TMPWorker::HandleInput.\n/// \\endparblock\n/// \\return true if Fork succeeded, false otherwise\nbool TMPClient::Fork(TMPWorker &server)\n{\n   std::string basePath = \"/tmp/ROOTMP-\";\n\n   //fork as many times as needed and save pids\n   pid_t pid = 1; //must be positive to handle the case in which fNWorkers is 0\n   int sockets[2]; //sockets file descriptors\n   unsigned nWorker = 0;\n   for (; nWorker < fNWorkers; ++nWorker) {\n      //create socket pair\n      int ret = socketpair(AF_UNIX, SOCK_STREAM, 0, sockets);\n      if (ret != 0) {\n         Error(\"TMPClient::Fork\", \"[E][C] Could not create socketpair. Error n. . Now retrying.\\n%d\", errno);\n         --nWorker;\n         continue;\n      }\n\n      //fork\n      {\n         ROOT::Internal::TGILRAII tgilraai;\n         pid = fork();\n      }\n\n      if (!pid) {\n         //child process, exit loop. sockets[1] is the fd that should be used\n         break;\n      } else {\n         //parent process, create TSocket with current value of sockets[0]\n         close(sockets[1]); //we don't need this\n         TSocket *s = new TSocket(sockets[0], (std::to_string(pid)).c_str()); //TSocket's constructor with this signature seems much faster than TSocket(int fd)\n         if (s && s->IsValid()) {\n            fMon.Add(s);\n            fWorkerPids.push_back(pid);\n         } else {\n            Error(\"TMPClient::Fork\",\"[E][C] Could not connect to worker with pid %d. Giving up.\\n\", pid);\n            delete s;\n         }\n      }\n   }\n\n   if (pid) {\n      //parent returns here\n      return true;\n   } else {\n      //CHILD/WORKER\n      fIsParent = false;\n      close(sockets[0]); //we don't need this\n\n      //override signal handler (make the servers exit on SIGINT)\n      TSeqCollection *signalHandlers = gSystem->GetListOfSignalHandlers();\n      TSignalHandler *sh = nullptr;\n      if (signalHandlers && signalHandlers->GetSize() > 0)\n         sh = (TSignalHandler *)signalHandlers->First();\n      if (sh)\n         gSystem->RemoveSignalHandler(sh);\n\n      //remove stdin from eventloop and close it\n      TSeqCollection *fileHandlers = gSystem->GetListOfFileHandlers();\n      if (fileHandlers) {\n         for (auto h : *fileHandlers) {\n            if (h && ((TFileHandler *)h)->GetFd() == 0) {\n               gSystem->RemoveFileHandler((TFileHandler *)h);\n               break;\n            }\n         }\n      }\n      close(0);\n      if (fMon.GetListOfActives()) {\n         while (fMon.GetListOfActives()->GetSize() > 0) {\n            TSocket *s = (TSocket *) fMon.GetListOfActives()->First();\n            fMon.Remove(s);\n            delete s;\n         }\n      }\n      if (fMon.GetListOfDeActives()) {\n         while (fMon.GetListOfDeActives()->GetSize() > 0) {\n            TSocket *s = (TSocket *) fMon.GetListOfDeActives()->First();\n            fMon.Remove(s);\n            delete s;\n         }\n      }\n      //disable graphics\n      //these instructions were copied from TApplication::MakeBatch\n      gROOT->SetBatch();\n      if (gGuiFactory != gBatchGuiFactory)\n         delete gGuiFactory;\n      gGuiFactory = gBatchGuiFactory;\n#ifndef R__WIN32\n      if (gVirtualX != gGXBatch)\n         delete gVirtualX;\n#endif\n      gVirtualX = gGXBatch;\n\n      //prepare server and add it to eventloop\n      server.Init(sockets[1], nWorker);\n\n      //enter worker loop\n      server.Run();\n   }\n\n   //control should never reach here\n   return true;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// Send a message with the specified code to at most nMessages workers.\n/// Sockets can either be in an \"active\" or \"non-active\" state. This method\n/// activates all the sockets through which the client is connected to the\n/// workers, and deactivates them when a message is sent to the corresponding\n/// worker. This way the sockets pertaining to workers who have been left\n/// idle will be the only ones in the active list\n/// (TSocket::GetMonitor()->GetListOfActives()) after execution.\n/// \\param code the code to send (e.g. EMPCode)\n/// \\param nMessages\n/// \\parblock\n/// the maximum number of messages to send.\n/// If `nMessages == 0 || nMessage > fNWorkers`, send a message to every worker.\n/// \\endparblock\n/// \\return the number of messages successfully sent\nunsigned TMPClient::Broadcast(unsigned code, unsigned nMessages)\n{\n   if (nMessages == 0)\n      nMessages = fNWorkers;\n   unsigned count = 0;\n   fMon.ActivateAll();\n\n   //send message to all sockets\n   std::unique_ptr<TList> lp(fMon.GetListOfActives());\n   for (auto s : *lp) {\n      if (count == nMessages)\n         break;\n      if (MPSend((TSocket *)s, code)) {\n         fMon.DeActivate((TSocket *)s);\n         ++count;\n      } else {\n         Error(\"TMPClient:Broadcast\", \"[E] Could not send message to server\\n\");\n      }\n   }\n\n   return count;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// DeActivate a certain socket.\n/// This does not remove it from the monitor: it will be reactivated by\n/// the next call to Broadcast() (or possibly other methods that are\n/// specified to do so).\\n\n/// A socket should be DeActivated when the corresponding\n/// worker is done *for now* and we want to stop listening to this worker's\n/// socket. If the worker is done *forever*, Remove() should be used instead.\n/// \\param s the socket to be deactivated\nvoid TMPClient::DeActivate(TSocket *s)\n{\n   fMon.DeActivate(s);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// Remove a certain socket from the monitor.\n/// A socket should be Removed from the monitor when the\n/// corresponding worker is done *forever*. For example HandleMPCode()\n/// calls this method on sockets pertaining to workers which sent an\n/// MPCode::kShutdownNotice.\\n\n/// If the worker is done *for now*, DeActivate should be used instead.\n/// \\param s the socket to be removed from the monitor fMon\nvoid TMPClient::Remove(TSocket *s)\n{\n   fMon.Remove(s);\n   delete s;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// Wait on worker processes and remove their pids from fWorkerPids.\n/// A blocking waitpid is called, but this should actually not block\n/// execution since ReapWorkers should only be called when all workers\n/// have already quit. ReapWorkers is then called not to leave zombie\n/// processes hanging around, and to clean-up fWorkerPids.\nvoid TMPClient::ReapWorkers()\n{\n   for (auto &pid : fWorkerPids) {\n      waitpid(pid, nullptr, 0);\n   }\n   fWorkerPids.clear();\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n/// Handle messages containing an EMPCode.\n/// This method should be called upon receiving a message with a code >= 1000\n/// (i.e. EMPCode). It handles the most generic types of messages.\\n\n/// Classes inheriting from TMPClient should implement a similar method\n/// to handle message codes specific to the application they're part of.\\n\n/// \\param msg the MPCodeBufPair returned by a MPRecv call\n/// \\param s\n/// \\parblock\n/// a pointer to the socket from which the message has been received is passed.\n/// This way HandleMPCode knows which socket to reply on.\n/// \\endparblock\nvoid TMPClient::HandleMPCode(MPCodeBufPair &msg, TSocket *s)\n{\n   unsigned code = msg.first;\n   //message contains server's pid. retrieve it\n   const char *str = ReadBuffer<const char*>(msg.second.get());\n\n   if (code == MPCode::kMessage) {\n      Error(\"TMPClient::HandleMPCode\", \"[I][C] message received: %s\\n\", str);\n   } else if (code == MPCode::kError) {\n      Error(\"TMPClient::HandleMPCode\", \"[E][C] error message received: %s\\n\", str);   \n   } else if (code == MPCode::kShutdownNotice || code == MPCode::kFatalError) {\n      if (gDebug > 0) //generally users don't want to know this\n         Error(\"TMPClient::HandleMPCode\", \"[I][C] shutdown notice received from %s\\n\", str);\n      Remove(s);\n   } else\n       Error(\"TMPClient::HandleMPCode\", \"[W][C] unknown code received. code=%d\\n\", code);\n   delete [] str;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/base/src/TROOT.cxx": "// @(#)root/base:$Id$\n// Author: Rene Brun   08/12/94\n\n/*************************************************************************\n * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n/** \\class TROOT\n\\ingroup Base\n\nROOT top level object description.\n\nThe TROOT object is the entry point to the ROOT system.\nThe single instance of TROOT is accessible via the global gROOT.\nUsing the gROOT pointer one has access to basically every object\ncreated in a ROOT based program. The TROOT object is essentially a\ncontainer of several lists pointing to the main ROOT objects.\n\nThe following lists are accessible from gROOT object:\n\n~~~ {.cpp}\n      gROOT->GetListOfClasses\n      gROOT->GetListOfColors\n      gROOT->GetListOfTypes\n      gROOT->GetListOfGlobals\n      gROOT->GetListOfGlobalFunctions\n      gROOT->GetListOfFiles\n      gROOT->GetListOfMappedFiles\n      gROOT->GetListOfSockets\n      gROOT->GetListOfSecContexts\n      gROOT->GetListOfCanvases\n      gROOT->GetListOfStyles\n      gROOT->GetListOfFunctions\n      gROOT->GetListOfSpecials (for example graphical cuts)\n      gROOT->GetListOfGeometries\n      gROOT->GetListOfBrowsers\n      gROOT->GetListOfCleanups\n      gROOT->GetListOfMessageHandlers\n~~~\n\nThe TROOT class provides also many useful services:\n  - Get pointer to an object in any of the lists above\n  - Time utilities TROOT::Time\n\nThe ROOT object must be created as a static object. An example\nof a main program creating an interactive version is shown below:\n\n### Example of a main program\n\n~~~ {.cpp}\n      #include \"TRint.h\"\n\n      int main(int argc, char **argv)\n      {\n         TRint *theApp = new TRint(\"ROOT example\", &argc, argv);\n\n         // Init Intrinsics, build all windows, and enter event loop\n         theApp->Run();\n\n         return(0);\n      }\n~~~\n*/\n\n#include <ROOT/RConfig.h>\n#include \"RConfigure.h\"\n#include \"RConfigOptions.h\"\n#include \"RVersion.h\"\n#include \"RGitCommit.h\"\n\n#include <string>\n#include <map>\n#include <stdlib.h>\n#ifdef WIN32\n#include <io.h>\n#include \"Windows4Root.h\"\n#include <Psapi.h>\n#define RTLD_DEFAULT ((void *)::GetModuleHandle(NULL))\n//#define dlsym(library, function_name) ::GetProcAddress((HMODULE)library, function_name)\n#define dlopen(library_name, flags) ::LoadLibrary(library_name)\n#define dlclose(library) ::FreeLibrary((HMODULE)library)\nchar *dlerror() {\n   static char Msg[1000];\n   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),\n                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), Msg,\n                 sizeof(Msg), NULL);\n   return Msg;\n}\nFARPROC dlsym(void *library, const char *function_name)\n{\n   HMODULE hMods[1024];\n   DWORD cbNeeded;\n   FARPROC address = NULL;\n   unsigned int i;\n   if (library == RTLD_DEFAULT) {\n      if (EnumProcessModules(::GetCurrentProcess(), hMods, sizeof(hMods), &cbNeeded)) {\n         for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {\n            address = ::GetProcAddress((HMODULE)hMods[i], function_name);\n            if (address)\n               return address;\n         }\n      }\n      return address;\n   } else {\n      return ::GetProcAddress((HMODULE)library, function_name);\n   }\n}\n#else\n#include <dlfcn.h>\n#endif\n\n#include \"Riostream.h\"\n#include \"TROOT.h\"\n#include \"TClass.h\"\n#include \"TClassEdit.h\"\n#include \"TClassGenerator.h\"\n#include \"TDataType.h\"\n#include \"TDatime.h\"\n#include \"TStyle.h\"\n#include \"TObjectTable.h\"\n#include \"TClassTable.h\"\n#include \"TSystem.h\"\n#include \"THashList.h\"\n#include \"TObjArray.h\"\n#include \"TEnv.h\"\n#include \"TError.h\"\n#include \"TColor.h\"\n#include \"TGlobal.h\"\n#include \"TFunction.h\"\n#include \"TVirtualPad.h\"\n#include \"TBrowser.h\"\n#include \"TSystemDirectory.h\"\n#include \"TApplication.h\"\n#include \"TInterpreter.h\"\n#include \"TGuiFactory.h\"\n#include \"TMessageHandler.h\"\n#include \"TFolder.h\"\n#include \"TQObject.h\"\n#include \"TProcessUUID.h\"\n#include \"TPluginManager.h\"\n#include \"TMap.h\"\n#include \"TObjString.h\"\n#include \"TVirtualMutex.h\"\n#include \"TInterpreter.h\"\n#include \"TListOfTypes.h\"\n#include \"TListOfDataMembers.h\"\n#include \"TListOfEnumsWithLock.h\"\n#include \"TListOfFunctions.h\"\n#include \"TListOfFunctionTemplates.h\"\n#include \"TFunctionTemplate.h\"\n#include \"ThreadLocalStorage.h\"\n#include \"TVirtualRWMutex.h\"\n\n#include <string>\nnamespace std {} using namespace std;\n\n#if defined(R__UNIX)\n#if defined(R__HAS_COCOA)\n#include \"TMacOSXSystem.h\"\n#include \"TUrl.h\"\n#else\n#include \"TUnixSystem.h\"\n#endif\n#elif defined(R__WIN32)\n#include \"TWinNTSystem.h\"\n#endif\n\nextern \"C\" void R__SetZipMode(int);\n\nstatic DestroyInterpreter_t *gDestroyInterpreter = 0;\nstatic void *gInterpreterLib = 0;\n\n// Mutex for protection of concurrent gROOT access\nTVirtualMutex* gROOTMutex = 0;\nROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;\n\n// For accessing TThread::Tsd indirectly.\nvoid **(*gThreadTsd)(void*,Int_t) = 0;\n\n//-------- Names of next three routines are a small homage to CMZ --------------\n////////////////////////////////////////////////////////////////////////////////\n/// Return version id as an integer, i.e. \"2.22/04\" -> 22204.\n\nstatic Int_t IVERSQ()\n{\n   Int_t maj, min, cycle;\n   sscanf(ROOT_RELEASE, \"%d.%d/%d\", &maj, &min, &cycle);\n   return 10000*maj + 100*min + cycle;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return built date as integer, i.e. \"Apr 28 2000\" -> 20000428.\n\nstatic Int_t IDATQQ(const char *date)\n{\n   static const char *months[] = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\n                                  \"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\n                                  \"Nov\",\"Dec\"};\n\n   char  sm[12];\n   Int_t yy, mm=0, dd;\n   sscanf(date, \"%s %d %d\", sm, &dd, &yy);\n   for (int i = 0; i < 12; i++)\n      if (!strncmp(sm, months[i], 3)) {\n         mm = i+1;\n         break;\n      }\n   return 10000*yy + 100*mm + dd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return built time as integer (with min precision), i.e.\n/// \"17:32:37\" -> 1732.\n\nstatic Int_t ITIMQQ(const char *time)\n{\n   Int_t hh, mm, ss;\n   sscanf(time, \"%d:%d:%d\", &hh, &mm, &ss);\n   return 100*hh + mm;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Clean up at program termination before global objects go out of scope.\n\nstatic void CleanUpROOTAtExit()\n{\n   if (gROOT) {\n      R__LOCKGUARD(gROOTMutex);\n\n      if (gROOT->GetListOfFiles())\n         gROOT->GetListOfFiles()->Delete(\"slow\");\n      if (gROOT->GetListOfSockets())\n         gROOT->GetListOfSockets()->Delete();\n      if (gROOT->GetListOfMappedFiles())\n         gROOT->GetListOfMappedFiles()->Delete(\"slow\");\n      if (gROOT->GetListOfClosedObjects())\n         gROOT->GetListOfClosedObjects()->Delete(\"slow\");\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// A module and its headers. Intentionally not a copy:\n/// If these strings end up in this struct they are\n/// long lived by definition because they get passed in\n/// before initialization of TCling.\n\nnamespace {\n   struct ModuleHeaderInfo_t {\n      ModuleHeaderInfo_t(const char* moduleName,\n                         const char** headers,\n                         const char** includePaths,\n                         const char* payloadCode,\n                         const char* fwdDeclCode,\n                         void (*triggerFunc)(),\n                         const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                         const char **classesHeaders,\n                         bool hasCxxModule):\n                           fModuleName(moduleName),\n                           fHeaders(headers),\n                           fPayloadCode(payloadCode),\n                           fFwdDeclCode(fwdDeclCode),\n                           fIncludePaths(includePaths),\n                           fTriggerFunc(triggerFunc),\n                           fClassesHeaders(classesHeaders),\n                           fFwdNargsToKeepColl(fwdDeclsArgToSkip),\n                           fHasCxxModule(hasCxxModule) {}\n\n      const char* fModuleName; // module name\n      const char** fHeaders; // 0-terminated array of header files\n      const char* fPayloadCode; // Additional code to be given to cling at library load\n      const char* fFwdDeclCode; // Additional code to let cling know about selected classes and functions\n      const char** fIncludePaths; // 0-terminated array of header files\n      void (*fTriggerFunc)(); // Pointer to the dict initialization used to find the library name\n      const char** fClassesHeaders; // 0-terminated list of classes and related header files\n      const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of\n                                                                      // pairs of template fwd decls and number of\n      bool fHasCxxModule; // Whether this module has a C++ module alongside it.\n   };\n\n   std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {\n      static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;\n      return moduleHeaderInfoBuffer;\n   }\n}\n\nInt_t  TROOT::fgDirLevel = 0;\nBool_t TROOT::fgRootInit = kFALSE;\nBool_t TROOT::fgMemCheck = kFALSE;\n\nstatic void at_exit_of_TROOT() {\n   if (ROOT::Internal::gROOTLocal)\n      ROOT::Internal::gROOTLocal->~TROOT();\n}\n\n// This local static object initializes the ROOT system\nnamespace ROOT {\nnamespace Internal {\n   class TROOTAllocator {\n      // Simple wrapper to separate, time-wise, the call to the\n      // TROOT destructor and the actual free-ing of the memory.\n      //\n      // Since the interpreter implementation (currently TCling) is\n      // loaded via dlopen by libCore, the destruction of its global\n      // variable (i.e. in particular clang's) is scheduled before\n      // those in libCore so we need to schedule the call to the TROOT\n      // destructor before that *but* we want to make sure the memory\n      // stay around until libCore itself is unloaded so that code\n      // using gROOT can 'properly' check for validity.\n      //\n      // The order of loading for is:\n      //    libCore.so\n      //    libRint.so\n      //    ... anything other library hard linked to the executable ...\n      //    ... for example libEvent\n      //    libCling.so\n      //    ... other libraries like libTree for example ....\n      // and the destruction order is (of course) the reverse.\n      // By default the unloading of the dictionary, does use\n      // the service of the interpreter ... which of course\n      // fails if libCling is already unloaded by that information\n      // has not been registered per se.\n      //\n      // To solve this problem, we now schedule the destruction\n      // of the TROOT object to happen _just_ before the\n      // unloading/destruction of libCling so that we can\n      // maximize the amount of clean-up we can do correctly\n      // and we can still allocate the TROOT object's memory\n      // statically.\n      //\n      char fHolder[sizeof(TROOT)];\n   public:\n      TROOTAllocator() {\n         new(&(fHolder[0])) TROOT(\"root\", \"The ROOT of EVERYTHING\");\n      }\n\n      ~TROOTAllocator() {\n         if (gROOTLocal) {\n            gROOTLocal->~TROOT();\n         }\n      }\n   };\n\n   // The global gROOT is defined to be a function (ROOT::GetROOT())\n   // which itself is dereferencing a function pointer.\n\n   // Initially this function pointer's value is & GetROOT1 whose role is to\n   // create and initialize the TROOT object itself.\n   // At the very end of the TROOT constructor the value of the function pointer\n   // is switch to & GetROOT2 whose role is to initialize the interpreter.\n\n   // This mechanism was primarily intended to fix the issues with order in which\n   // global TROOT and LLVM globals are initialized. TROOT was initializing\n   // Cling, but Cling could not be used yet due to LLVM globals not being\n   // Initialized yet.  The solution is to delay initializing the interpreter in\n   // TROOT till after main() when all LLVM globals are initialized.\n\n   // Technically, the mechanism used actually delay the interpreter\n   // initialization until the first use of gROOT *after* the end of the\n   // TROOT constructor.\n\n   // So to delay until after the start of main, we also made sure that none\n   // of the ROOT code (mostly the dictionary code) used during library loading\n   // is using gROOT (directly or indirectly).\n\n   // In practice, the initialization of the interpreter is now delayed until\n   // the first use gROOT (or gInterpreter) after the start of main (but user\n   // could easily break this by using gROOT in their library initialization\n   // code).\n\n   extern TROOT *gROOTLocal;\n\n   TROOT *GetROOT1() {\n      if (gROOTLocal)\n         return gROOTLocal;\n      static TROOTAllocator alloc;\n      return gROOTLocal;\n   }\n\n   TROOT *GetROOT2() {\n      static Bool_t initInterpreter = kFALSE;\n      if (!initInterpreter) {\n         initInterpreter = kTRUE;\n         gROOTLocal->InitInterpreter();\n         // Load and init threads library\n         gROOTLocal->InitThreads();\n      }\n      return gROOTLocal;\n   }\n   typedef TROOT *(*GetROOTFun_t)();\n\n   static GetROOTFun_t gGetROOT = &GetROOT1;\n\n   static Func_t GetSymInLibImt(const char *funcname)\n   {\n      const static bool loadSuccess = dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")? false : 0 <= gSystem->Load(\"libImt\");\n      if (loadSuccess) {\n         if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {\n            return sym;\n         } else {\n            Error(\"GetSymInLibImt\", \"Cannot get symbol %s.\", funcname);\n         }\n      }\n      return nullptr;\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally enables the parallel branch processing, which is a case of\n   /// implicit multi-threading (IMT) in ROOT, activating the required locks.\n   /// This IMT use case, implemented in TTree::GetEntry, spawns a task for\n   /// each branch of the tree. Therefore, a task takes care of the reading,\n   /// decompression and deserialisation of a given branch.\n   void EnableParBranchProcessing()\n   {\n#ifdef R__USE_IMT\n      if (!IsImplicitMTEnabled())\n         EnableImplicitMT();\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableParBranchProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"EnableParBranchProcessing\", \"Cannot enable parallel branch processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally disables the IMT use case of parallel branch processing,\n   /// deactivating the corresponding locks.\n   void DisableParBranchProcessing()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableParBranchProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"DisableParBranchProcessing\", \"Cannot disable parallel branch processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Returns true if parallel branch processing is enabled.\n   Bool_t IsParBranchProcessingEnabled()\n   {\n#ifdef R__USE_IMT\n      static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_IsParBranchProcessingEnabled\");\n      if (sym)\n         return sym();\n      else\n         return kFALSE;\n#else\n      return kFALSE;\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Globally enables the parallel tree processing, which is a case of\n   /// implicit multi-threading in ROOT, activating the required locks.\n   /// This IMT use case, implemented in TTreeProcessor::Process, receives a user\n   /// function and applies it to subranges of the tree, which correspond to its\n   /// clusters. Hence, for every cluster, a task is spawned to potentially\n   /// process it in parallel with the other clusters.\n   void EnableParTreeProcessing()\n   {\n#ifdef R__USE_IMT\n      if (!IsImplicitMTEnabled())\n         EnableImplicitMT();\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableParTreeProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"EnableParTreeProcessing\", \"Cannot enable parallel tree processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   //////////////////////////////////////////////////////////////////////////////\n   /// Globally disables the IMT use case of parallel branch processing,\n   /// deactivating the corresponding locks.\n   void DisableParTreeProcessing()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableParTreeProcessing\");\n      if (sym)\n         sym();\n#else\n      ::Warning(\"DisableParTreeProcessing\", \"Cannot disable parallel tree processing, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns true if parallel tree processing is enabled.\n   Bool_t IsParTreeProcessingEnabled()\n   {\n#ifdef R__USE_IMT\n      static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_IsParTreeProcessingEnabled\");\n      if (sym)\n         return sym();\n      else\n         return kFALSE;\n#else\n      return kFALSE;\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Keeps track of the status of ImplicitMT w/o resorting to the load of\n   /// libImt\n   static Bool_t &IsImplicitMTEnabledImpl()\n   {\n      static Bool_t isImplicitMTEnabled = kFALSE;\n      return isImplicitMTEnabled;\n   }\n\n} // end of Internal sub namespace\n// back to ROOT namespace\n\n   TROOT *GetROOT() {\n      return (*Internal::gGetROOT)();\n   }\n\n   TString &GetMacroPath() {\n      static TString macroPath;\n      return macroPath;\n   }\n\n   // clang-format off\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Enables the global mutex to make ROOT thread safe/aware.\n   ///\n   /// The following becomes safe:\n   /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles())\n   /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas)\n   /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum\n   /// - concurrent calls to the interpreter through gInterpreter\n   /// - concurrent loading of ROOT plug-ins\n   ///\n   /// In addition, gDirectory, gFile and gPad become a thread-local variable.\n   /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.\n   /// gFile and gPad default to nullptr, as it is for single-thread programs.\n   ///\n   /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.\n   // clang-format on\n   void EnableThreadSafety()\n   {\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TThread_Initialize\");\n      if (sym)\n         sym();\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// @param[in] numthreads Number of threads to use. If not specified or\n   ///                       set to zero, the number of threads is automatically\n   ///                       decided by the implementation. Any other value is\n   ///                       used as a hint.\n   ///\n   /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.\n   /// The following objects and methods automatically take advantage of\n   /// multi-threading if a call to `EnableImplicitMT` has been made before usage:\n   ///\n   ///  - RDataFrame internally runs the event-loop by parallelizing over clusters of entries\n   ///  - TTree::GetEntry reads multiple branches in parallel\n   ///  - TTree::FlushBaskets writes multiple baskets to disk in parallel\n   ///  - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel\n   ///  - THx::Fit performs in parallel the evaluation of the objective function over the data\n   ///  - TMVA::DNN trains the deep neural networks in parallel\n   ///  - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel\n   ///\n   /// EnableImplicitMT calls in turn EnableThreadSafety.\n   /// The 'numthreads' parameter allows to control the number of threads to\n   /// be used by the implicit multi-threading. However, this parameter is just\n   /// a hint for ROOT: it will try to satisfy the request if the execution\n   /// scenario allows it. For example, if ROOT is configured to use an external\n   /// scheduler, setting a value for 'numthreads' might not have any effect.\n   void EnableImplicitMT(UInt_t numthreads)\n   {\n#ifdef R__USE_IMT\n      if (ROOT::Internal::IsImplicitMTEnabledImpl())\n         return;\n      EnableThreadSafety();\n      static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(\"ROOT_TImplicitMT_EnableImplicitMT\");\n      if (sym)\n         sym(numthreads);\n      ROOT::Internal::IsImplicitMTEnabledImpl() = true;\n#else\n      ::Warning(\"EnableImplicitMT\", \"Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON\", numthreads);\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).\n   void DisableImplicitMT()\n   {\n#ifdef R__USE_IMT\n      static void (*sym)() = (void(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_DisableImplicitMT\");\n      if (sym)\n         sym();\n      ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;\n#else\n      ::Warning(\"DisableImplicitMT\", \"Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON\");\n#endif\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns true if the implicit multi-threading in ROOT is enabled.\n   Bool_t IsImplicitMTEnabled()\n   {\n      return ROOT::Internal::IsImplicitMTEnabledImpl();\n   }\n\n   ////////////////////////////////////////////////////////////////////////////////\n   /// Returns the size of the pool used for implicit multi-threading.\n   UInt_t GetImplicitMTPoolSize()\n   {\n#ifdef R__USE_IMT\n      static UInt_t (*sym)() = (UInt_t(*)())Internal::GetSymInLibImt(\"ROOT_TImplicitMT_GetImplicitMTPoolSize\");\n      if (sym)\n         return sym();\n      else\n         return 0;\n#else\n      return 0;\n#endif\n   }\n\n}\n\nTROOT *ROOT::Internal::gROOTLocal = ROOT::GetROOT();\n\n// Global debug flag (set to > 0 to get debug output).\n// Can be set either via the interpreter (gDebug is exported to CINT),\n// via the rootrc resource \"Root.Debug\", via the shell environment variable\n// ROOTDEBUG, or via the debugger.\nInt_t gDebug;\n\n\nClassImp(TROOT);\n\n////////////////////////////////////////////////////////////////////////////////\n/// Default ctor.\n\nTROOT::TROOT() : TDirectory(),\n     fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),\n     fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),\n     fTimer(0), fApplication(0), fInterpreter(0), fBatch(kTRUE),\n     fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),\n     fFromPopUp(kTRUE),fMustClean(kTRUE),fReadingObject(kFALSE),fForceStyle(kFALSE),\n     fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),\n     fPrimitive(0),fSelectPad(0),fClasses(0),fTypes(0),fGlobals(0),fGlobalFunctions(0),\n     fClosedObjects(0),fFiles(0),fMappedFiles(0),fSockets(0),fCanvases(0),fStyles(0),fFunctions(0),\n     fTasks(0),fColors(0),fGeometries(0),fBrowsers(0),fSpecials(0),fCleanups(0),\n     fMessageHandlers(0),fStreamerInfo(0),fClassGenerators(0),fSecContexts(0),\n     fProofs(0),fClipboard(0),fDataSets(0),fUUIDs(0),fRootFolder(0),fBrowsables(0),\n     fPluginManager(0)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the ROOT system. The creation of the TROOT object initializes\n/// the ROOT system. It must be the first ROOT related action that is\n/// performed by a program. The TROOT object must be created on the stack\n/// (can not be called via new since \"operator new\" is protected). The\n/// TROOT object is either created as a global object (outside the main()\n/// program), or it is one of the first objects created in main().\n/// Make sure that the TROOT object stays in scope for as long as ROOT\n/// related actions are performed. TROOT is a so called singleton so\n/// only one instance of it can be created. The single TROOT object can\n/// always be accessed via the global pointer gROOT.\n/// The name and title arguments can be used to identify the running\n/// application. The initfunc argument can contain an array of\n/// function pointers (last element must be 0). These functions are\n/// executed at the end of the constructor. This way one can easily\n/// extend the ROOT system without adding permanent dependencies\n/// (e.g. the graphics system is initialized via such a function).\n\nTROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc)\n   : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),\n     fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),\n     fTimer(0), fApplication(0), fInterpreter(0), fBatch(kTRUE),\n     fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),\n     fFromPopUp(kTRUE),fMustClean(kTRUE),fReadingObject(kFALSE),fForceStyle(kFALSE),\n     fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),\n     fPrimitive(0),fSelectPad(0),fClasses(0),fTypes(0),fGlobals(0),fGlobalFunctions(0),\n     fClosedObjects(0),fFiles(0),fMappedFiles(0),fSockets(0),fCanvases(0),fStyles(0),fFunctions(0),\n     fTasks(0),fColors(0),fGeometries(0),fBrowsers(0),fSpecials(0),fCleanups(0),\n     fMessageHandlers(0),fStreamerInfo(0),fClassGenerators(0),fSecContexts(0),\n     fProofs(0),fClipboard(0),fDataSets(0),fUUIDs(0),fRootFolder(0),fBrowsables(0),\n     fPluginManager(0)\n{\n   if (fgRootInit || ROOT::Internal::gROOTLocal) {\n      //Warning(\"TROOT\", \"only one instance of TROOT allowed\");\n      return;\n   }\n\n   R__LOCKGUARD(gROOTMutex);\n\n   ROOT::Internal::gROOTLocal = this;\n   gDirectory = 0;\n\n   SetName(name);\n   SetTitle(title);\n\n   // will be used by global \"operator delete\" so make sure it is set\n   // before anything is deleted\n   fMappedFiles = 0;\n\n   // create already here, but only initialize it after gEnv has been created\n   gPluginMgr = fPluginManager = new TPluginManager;\n\n   // Initialize Operating System interface\n   InitSystem();\n\n   // Initialize static directory functions\n   GetRootSys();\n   GetBinDir();\n   GetLibDir();\n   GetIncludeDir();\n   GetEtcDir();\n   GetDataDir();\n   GetDocDir();\n   GetMacroDir();\n   GetTutorialDir();\n   GetSourceDir();\n   GetIconPath();\n   GetTTFFontDir();\n\n   gRootDir = GetRootSys().Data();\n\n   TDirectory::Build();\n\n   // Initialize interface to CINT C++ interpreter\n   fVersionInt      = 0;  // check in TROOT dtor in case TCling fails\n   fClasses         = 0;  // might be checked via TCling ctor\n   fEnums           = 0;\n\n   fConfigOptions   = R__CONFIGUREOPTIONS;\n   fConfigFeatures  = R__CONFIGUREFEATURES;\n   fVersion         = ROOT_RELEASE;\n   fVersionCode     = ROOT_VERSION_CODE;\n   fVersionInt      = IVERSQ();\n   fVersionDate     = IDATQQ(ROOT_RELEASE_DATE);\n   fVersionTime     = ITIMQQ(ROOT_RELEASE_TIME);\n   fBuiltDate       = IDATQQ(__DATE__);\n   fBuiltTime       = ITIMQQ(__TIME__);\n\n   ReadGitInfo();\n\n   fClasses         = new THashTable(800,3); fClasses->UseRWLock();\n   //fIdMap           = new IdMap_t;\n   fStreamerInfo    = new TObjArray(100); fStreamerInfo->UseRWLock();\n   fClassGenerators = new TList;\n\n   // usedToIdentifyRootClingByDlSym is available when TROOT is part of\n   // rootcling.\n   if (!dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")) {\n      // initialize plugin manager early\n      fPluginManager->LoadHandlersFromEnv(gEnv);\n#if defined(R__MACOSX) && (TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR)\n      if (TARGET_OS_IPHONE | TARGET_IPHONE_SIMULATOR) {\n         TEnv plugins(\".plugins-ios\");\n         fPluginManager->LoadHandlersFromEnv(&plugins);\n      }\n#endif\n   }\n\n   TSystemDirectory *workdir = new TSystemDirectory(\"workdir\", gSystem->WorkingDirectory());\n\n   auto setNameLocked = [](TSeqCollection *l, const char *collection_name) {\n      l->SetName(collection_name);\n      l->UseRWLock();\n      return l;\n   };\n\n   fTimer       = 0;\n   fApplication = 0;\n   fColors      = setNameLocked(new TObjArray(1000), \"ListOfColors\");\n   fTypes       = 0;\n   fGlobals     = 0;\n   fGlobalFunctions = 0;\n   // fList was created in TDirectory::Build but with different sizing.\n   delete fList;\n   fList        = new THashList(1000,3); fList->UseRWLock();\n   fClosedObjects = setNameLocked(new TList, \"ClosedFiles\");\n   fFiles       = setNameLocked(new TList, \"Files\");\n   fMappedFiles = setNameLocked(new TList, \"MappedFiles\");\n   fSockets     = setNameLocked(new TList, \"Sockets\");\n   fCanvases    = setNameLocked(new TList, \"Canvases\");\n   fStyles      = setNameLocked(new TList, \"Styles\");\n   fFunctions   = setNameLocked(new TList, \"Functions\");\n   fTasks       = setNameLocked(new TList, \"Tasks\");\n   fGeometries  = setNameLocked(new TList, \"Geometries\");\n   fBrowsers    = setNameLocked(new TList, \"Browsers\");\n   fSpecials    = setNameLocked(new TList, \"Specials\");\n   fBrowsables  = (TList*)setNameLocked(new TList, \"Browsables\");\n   fCleanups    = setNameLocked(new THashList, \"Cleanups\");\n   fMessageHandlers = setNameLocked(new TList, \"MessageHandlers\");\n   fSecContexts = setNameLocked(new TList, \"SecContexts\");\n   fProofs      = setNameLocked(new TList, \"Proofs\");\n   fClipboard   = setNameLocked(new TList, \"Clipboard\");\n   fDataSets    = setNameLocked(new TList, \"DataSets\");\n   fTypes       = new TListOfTypes; fTypes->UseRWLock();\n\n   TProcessID::AddProcessID();\n   fUUIDs = new TProcessUUID();\n\n   fRootFolder = new TFolder();\n   fRootFolder->SetName(\"root\");\n   fRootFolder->SetTitle(\"root of all folders\");\n   fRootFolder->AddFolder(\"Classes\",   \"List of Active Classes\",fClasses);\n   fRootFolder->AddFolder(\"Colors\",    \"List of Active Colors\",fColors);\n   fRootFolder->AddFolder(\"MapFiles\",  \"List of MapFiles\",fMappedFiles);\n   fRootFolder->AddFolder(\"Sockets\",   \"List of Socket Connections\",fSockets);\n   fRootFolder->AddFolder(\"Canvases\",  \"List of Canvases\",fCanvases);\n   fRootFolder->AddFolder(\"Styles\",    \"List of Styles\",fStyles);\n   fRootFolder->AddFolder(\"Functions\", \"List of Functions\",fFunctions);\n   fRootFolder->AddFolder(\"Tasks\",     \"List of Tasks\",fTasks);\n   fRootFolder->AddFolder(\"Geometries\",\"List of Geometries\",fGeometries);\n   fRootFolder->AddFolder(\"Browsers\",  \"List of Browsers\",fBrowsers);\n   fRootFolder->AddFolder(\"Specials\",  \"List of Special Objects\",fSpecials);\n   fRootFolder->AddFolder(\"Handlers\",  \"List of Message Handlers\",fMessageHandlers);\n   fRootFolder->AddFolder(\"Cleanups\",  \"List of RecursiveRemove Collections\",fCleanups);\n   fRootFolder->AddFolder(\"StreamerInfo\",\"List of Active StreamerInfo Classes\",fStreamerInfo);\n   fRootFolder->AddFolder(\"SecContexts\",\"List of Security Contexts\",fSecContexts);\n   fRootFolder->AddFolder(\"PROOF Sessions\", \"List of PROOF sessions\",fProofs);\n   fRootFolder->AddFolder(\"ROOT Memory\",\"List of Objects in the gROOT Directory\",fList);\n   fRootFolder->AddFolder(\"ROOT Files\",\"List of Connected ROOT Files\",fFiles);\n\n   // by default, add the list of files, tasks, canvases and browsers in the Cleanups list\n   fCleanups->Add(fCanvases); fCanvases->SetBit(kMustCleanup);\n   fCleanups->Add(fBrowsers); fBrowsers->SetBit(kMustCleanup);\n   fCleanups->Add(fTasks);    fTasks->SetBit(kMustCleanup);\n   fCleanups->Add(fFiles);    fFiles->SetBit(kMustCleanup);\n   fCleanups->Add(fClosedObjects); fClosedObjects->SetBit(kMustCleanup);\n   // And add TROOT's TDirectory personality\n   fCleanups->Add(fList);\n\n   fExecutingMacro= kFALSE;\n   fForceStyle    = kFALSE;\n   fFromPopUp     = kFALSE;\n   fReadingObject = kFALSE;\n   fInterrupt     = kFALSE;\n   fEscape        = kFALSE;\n   fMustClean     = kTRUE;\n   fPrimitive     = 0;\n   fSelectPad     = 0;\n   fEditorMode    = 0;\n   fDefCanvasName = \"c1\";\n   fEditHistograms= kFALSE;\n   fLineIsProcessing = 1;   // This prevents WIN32 \"Windows\" thread to pick ROOT objects with mouse\n   gDirectory     = this;\n   gPad           = 0;\n\n   //set name of graphical cut class for the graphics editor\n   //cannot call SetCutClassName at this point because the TClass of TCutG\n   //is not yet build\n   fCutClassName = \"TCutG\";\n\n   // Create a default MessageHandler\n   new TMessageHandler((TClass*)0);\n\n   // Create some styles\n   gStyle = 0;\n   TStyle::BuildStyles();\n   SetStyle(gEnv->GetValue(\"Canvas.Style\", \"Modern\"));\n\n   // Setup default (batch) graphics and GUI environment\n   gBatchGuiFactory = new TGuiFactory;\n   gGuiFactory      = gBatchGuiFactory;\n   gGXBatch         = new TVirtualX(\"Batch\", \"ROOT Interface to batch graphics\");\n   gVirtualX        = gGXBatch;\n\n#if defined(R__WIN32)\n   fBatch = kFALSE;\n#elif defined(R__HAS_COCOA)\n   fBatch = kFALSE;\n#else\n   if (gSystem->Getenv(\"DISPLAY\"))\n      fBatch = kFALSE;\n   else\n      fBatch = kTRUE;\n#endif\n\n   int i = 0;\n   while (initfunc && initfunc[i]) {\n      (initfunc[i])();\n      fBatch = kFALSE;  // put system in graphics mode (backward compatible)\n      i++;\n   }\n\n   // Set initial/default list of browsable objects\n   fBrowsables->Add(fRootFolder, \"root\");\n   fBrowsables->Add(fProofs, \"PROOF Sessions\");\n   fBrowsables->Add(workdir, gSystem->WorkingDirectory());\n   fBrowsables->Add(fFiles, \"ROOT Files\");\n\n   atexit(CleanUpROOTAtExit);\n\n   ROOT::Internal::gGetROOT = &ROOT::Internal::GetROOT2;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Clean up and free resources used by ROOT (files, network sockets,\n/// shared memory segments, etc.).\n\nTROOT::~TROOT()\n{\n   using namespace ROOT::Internal;\n\n   if (gROOTLocal == this) {\n\n      // If the interpreter has not yet been initialized, don't bother\n      gGetROOT = &GetROOT1;\n\n      // Mark the object as invalid, so that we can veto some actions\n      // (like autoloading) while we are in the destructor.\n      SetBit(TObject::kInvalidObject);\n\n      // Turn-off the global mutex to avoid recreating mutexes that have\n      // already been deleted during the destruction phase\n      gGlobalMutex = 0;\n\n      // Return when error occurred in TCling, i.e. when setup file(s) are\n      // out of date\n      if (!fVersionInt) return;\n\n      // ATTENTION!!! Order is important!\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      SafeDelete(fBrowsables);\n\n      // FIXME: Causes rootcling to deadlock, debug and uncomment\n      // SafeDelete(fRootFolder);\n\n      fSpecials->Delete();   SafeDelete(fSpecials);    // delete special objects : PostScript, Minuit, Html\n#endif\n      fClosedObjects->Delete(\"slow\"); // and closed files\n      fFiles->Delete(\"slow\");       // and files\n      SafeDelete(fFiles);\n      fSecContexts->Delete(\"slow\"); SafeDelete(fSecContexts); // and security contexts\n      fSockets->Delete();           SafeDelete(fSockets);     // and sockets\n      fMappedFiles->Delete(\"slow\");                     // and mapped files\n      TSeqCollection *tl = fMappedFiles; fMappedFiles = 0; delete tl;\n\n      SafeDelete(fClosedObjects);\n\n      delete fUUIDs;\n      TProcessID::Cleanup();                            // and list of ProcessIDs\n\n      fFunctions->Delete();  SafeDelete(fFunctions);   // etc..\n      fGeometries->Delete(); SafeDelete(fGeometries);\n      fBrowsers->Delete();   SafeDelete(fBrowsers);\n#ifdef R__COMPLETE_MEM_TERMINATION\n      SafeDelete(fCanvases);\n#endif\n      fColors->Delete();     SafeDelete(fColors);\n      fStyles->Delete();     SafeDelete(fStyles);\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      if (gGuiFactory != gBatchGuiFactory) SafeDelete(gGuiFactory);\n      SafeDelete(gBatchGuiFactory);\n      if (gGXBatch != gVirtualX) SafeDelete(gGXBatch);\n      SafeDelete(gVirtualX);\n#endif\n\n      // Stop emitting signals\n      TQObject::BlockAllSignals(kTRUE);\n\n      fMessageHandlers->Delete(); SafeDelete(fMessageHandlers);\n\n#ifdef R__COMPLETE_MEM_TERMINATION\n      SafeDelete(fCanvases);\n      SafeDelete(fTasks);\n      SafeDelete(fProofs);\n      SafeDelete(fDataSets);\n      SafeDelete(fClipboard);\n\n      fCleanups->Clear();\n      delete fPluginManager; gPluginMgr = fPluginManager = 0;\n      delete gClassTable;  gClassTable = 0;\n      delete gEnv; gEnv = 0;\n\n      if (fTypes) fTypes->Delete();\n      SafeDelete(fTypes);\n      if (fGlobals) fGlobals->Delete();\n      SafeDelete(fGlobals);\n      if (fGlobalFunctions) fGlobalFunctions->Delete();\n      SafeDelete(fGlobalFunctions);\n      fEnums.load()->Delete();\n\n      // FIXME: Causes segfault in rootcling, debug and uncomment\n      // fClasses->Delete();    SafeDelete(fClasses);     // TClass'es must be deleted last\n#endif\n\n      // Remove shared libraries produced by the TSystem::CompileMacro() call\n      gSystem->CleanCompiledMacros();\n\n      // Cleanup system class\n      delete gSystem;\n\n      // ROOT-6022:\n      //   if (gInterpreterLib) dlclose(gInterpreterLib);\n#ifdef R__COMPLETE_MEM_TERMINATION\n      // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the\n      // initialization order is (by default?) is 'wrong' and so we can't\n      // delete the interpreter now .. because any of the static in the\n      // interpreter's library have already been deleted.\n      // On the link line, we must list the most dependent .o file\n      // and end with the least dependent (LLVM libraries), unfortunately,\n      // Fedora Core 17+ or Ubuntu 12 will also execute the initialization\n      // in the same order (hence doing libCore's before LLVM's and\n      // vice et versa for both the destructor.  We worked around the\n      // initialization order by delay the TROOT creation until first use.\n      // We can not do the same for destruction as we have no way of knowing\n      // the last access ...\n      // So for now, let's avoid delete TCling except in the special build\n      // checking the completeness of the termination deletion.\n\n      // TODO: Should we do more cleanup here than just call delete?\n      // Segfaults rootcling in some cases, debug and uncomment:\n      //\n      //    delete fInterpreter;\n\n      SafeDelete(fCleanups);\n#endif\n\n      // llvm::TimingGroup used for measuring the timing relies the destructors.\n      // In order to make use of this feature we have to call the destructor of\n      // TCling which will shut down clang, cling and llvm.\n      // gSystem->Getenv is not available anymore.\n      if (::getenv(\"ROOT_CLING_TIMING\"))\n         delete fInterpreter;\n\n\n      // Prints memory stats\n      TStorage::PrintStatistics();\n\n      gROOTLocal = 0;\n      fgRootInit = kFALSE;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add a class to the list and map of classes.\n/// This routine is deprecated, use TClass::AddClass directly.\n\nvoid TROOT::AddClass(TClass *cl)\n{\n   TClass::AddClass(cl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add a class generator.  This generator will be called by TClass::GetClass\n/// in case its does not find a loaded rootcint dictionary to request the\n/// creation of a TClass object.\n\nvoid TROOT::AddClassGenerator(TClassGenerator *generator)\n{\n   if (!generator) return;\n   fClassGenerators->Add(generator);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Append object to this directory.\n///\n/// If replace is true:\n///   remove any existing objects with the same same (if the name is not \"\")\n\nvoid TROOT::Append(TObject *obj, Bool_t replace /* = kFALSE */)\n{\n   R__LOCKGUARD(gROOTMutex);\n   TDirectory::Append(obj,replace);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add browsable objects to TBrowser.\n\nvoid TROOT::Browse(TBrowser *b)\n{\n   TObject *obj;\n   TIter next(fBrowsables);\n\n   while ((obj = (TObject *) next())) {\n      const char *opt = next.GetOption();\n      if (opt && strlen(opt))\n         b->Add(obj, opt);\n      else\n         b->Add(obj, obj->GetName());\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// return class status bit kClassSaved for class cl\n/// This function is called by the SavePrimitive functions writing\n/// the C++ code for an object.\n\nBool_t TROOT::ClassSaved(TClass *cl)\n{\n   if (cl == 0) return kFALSE;\n   if (cl->TestBit(TClass::kClassSaved)) return kTRUE;\n   cl->SetBit(TClass::kClassSaved);\n   return kFALSE;\n}\n\nnamespace {\n   static void R__ListSlowClose(TList *files)\n   {\n      // Routine to close a list of files using the 'slow' techniques\n      // that also for the deletion ot update the list itself.\n\n      static TObject harmless;\n      TObjLink *cursor = files->FirstLink();\n      while (cursor) {\n         TDirectory *dir = static_cast<TDirectory*>( cursor->GetObject() );\n         if (dir) {\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n            // See related comment at the files->Clear(\"nodelete\");\n            dir->Close(\"nodelete\");\n            // Put it back\n            cursor->SetObject(dir);\n         }\n         cursor = cursor->Next();\n      };\n      // Now were done, clear the list but do not delete the objects as\n      // they have been moved to the list of closed objects and must be\n      // deleted from there in order to avoid a double delete from a\n      // use objects (on the interpreter stack).\n      files->Clear(\"nodelete\");\n   }\n\n   static void R__ListSlowDeleteContent(TList *files)\n   {\n      // Routine to delete the content of list of files using the 'slow' techniques\n\n      static TObject harmless;\n      TObjLink *cursor = files->FirstLink();\n      while (cursor) {\n         TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );\n         if (dir) {\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n            // See related comment at the files->Clear(\"nodelete\");\n            dir->GetList()->Delete(\"slow\");\n            // Put it back\n            cursor->SetObject(dir);\n         }\n         cursor = cursor->Next();\n      };\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Close any files and sockets that gROOT knows about.\n/// This can be used to insures that the files and sockets are closed before any library is unloaded!\n\nvoid TROOT::CloseFiles()\n{\n   if (fFiles && fFiles->First()) {\n      R__ListSlowClose(static_cast<TList*>(fFiles));\n   }\n   // and Close TROOT itself.\n   Close(\"slow\");\n   // Now sockets.\n   if (fSockets && fSockets->First()) {\n      if (0==fCleanups->FindObject(fSockets) ) {\n         fCleanups->Add(fSockets);\n         fSockets->SetBit(kMustCleanup);\n      }\n      CallFunc_t *socketCloser = gInterpreter->CallFunc_Factory();\n      Long_t offset = 0;\n      TClass *socketClass = TClass::GetClass(\"TSocket\");\n      gInterpreter->CallFunc_SetFuncProto(socketCloser, socketClass->GetClassInfo(), \"Close\", \"\", &offset);\n      if (gInterpreter->CallFunc_IsValid(socketCloser)) {\n         static TObject harmless;\n         TObjLink *cursor = static_cast<TList*>(fSockets)->FirstLink();\n         TList notclosed;\n         while (cursor) {\n            TObject *socket = cursor->GetObject();\n            // In order for the iterator to stay valid, we must\n            // prevent the removal of the object (dir) from the list\n            // (which is done in TFile::Close).   We can also can not\n            // just move to the next iterator since the Close might\n            // also (indirectly) remove that file.\n            // So we SetObject to a harmless value, so that 'dir'\n            // is not seen as part of the list.\n            // We will later, remove all the object (see files->Clear()\n            cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.\n\n            if (socket->IsA()->InheritsFrom(socketClass)) {\n               gInterpreter->CallFunc_Exec(socketCloser, ((char*)socket)+offset);\n               // Put the object in the closed list for later deletion.\n               socket->SetBit(kMustCleanup);\n               fClosedObjects->AddLast(socket);\n            } else {\n               // Crap ... this is not a socket, likely Proof or something, let's try to find a Close\n               Long_t other_offset;\n               CallFunc_t *otherCloser = gInterpreter->CallFunc_Factory();\n               gInterpreter->CallFunc_SetFuncProto(otherCloser, socket->IsA()->GetClassInfo(), \"Close\", \"\", &other_offset);\n               if (gInterpreter->CallFunc_IsValid(otherCloser)) {\n                  gInterpreter->CallFunc_Exec(otherCloser, ((char*)socket)+other_offset);\n                  // Put the object in the closed list for later deletion.\n                  socket->SetBit(kMustCleanup);\n                  fClosedObjects->AddLast(socket);\n               } else {\n                  notclosed.AddLast(socket);\n               }\n               gInterpreter->CallFunc_Delete(otherCloser);\n               // Put it back\n               cursor->SetObject(socket);\n            }\n            cursor = cursor->Next();\n         }\n         // Now were done, clear the list\n         fSockets->Clear();\n         // Read the one we did not close\n         cursor = notclosed.FirstLink();\n         while (cursor) {\n            static_cast<TList*>(fSockets)->AddLast(cursor->GetObject());\n            cursor = cursor->Next();\n         }\n      }\n      gInterpreter->CallFunc_Delete(socketCloser);\n   }\n   if (fMappedFiles && fMappedFiles->First()) {\n      R__ListSlowClose(static_cast<TList*>(fMappedFiles));\n   }\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute the cleanups necessary at the end of the process, in particular\n/// those that must be executed before the library start being unloaded.\n\nvoid TROOT::EndOfProcessCleanups()\n{\n   // This will not delete the objects 'held' by the TFiles so that\n   // they can still be 'reacheable' when ResetGlobals is run.\n   CloseFiles();\n\n   if (gInterpreter) {\n      gInterpreter->ResetGlobals();\n   }\n\n   // Now delete the objects 'held' by the TFiles so that it\n   // is done before the tear down of the libraries.\n   if (fClosedObjects && fClosedObjects->First()) {\n      R__ListSlowDeleteContent(static_cast<TList*>(fClosedObjects));\n   }\n\n   // Now a set of simpler things to delete.  See the same ordering in\n   // TROOT::~TROOT\n   fFunctions->Delete();\n   fGeometries->Delete();\n   fBrowsers->Delete();\n   fCanvases->Delete(\"slow\");\n   fColors->Delete();\n   fStyles->Delete();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find an object in one Root folder\n\nTObject *TROOT::FindObject(const TObject *) const\n{\n   Error(\"FindObject\",\"Not yet implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns address of a ROOT object if it exists\n///\n/// If name contains at least one \"/\" the function calls FindObjectany\n/// else\n/// This function looks in the following order in the ROOT lists:\n///     - List of files\n///     - List of memory mapped files\n///     - List of functions\n///     - List of geometries\n///     - List of canvases\n///     - List of styles\n///     - List of specials\n///     - List of materials in current geometry\n///     - List of shapes in current geometry\n///     - List of matrices in current geometry\n///     - List of Nodes in current geometry\n///     - Current Directory in memory\n///     - Current Directory on file\n\nTObject *TROOT::FindObject(const char *name) const\n{\n   if (name && strstr(name,\"/\")) return FindObjectAny(name);\n\n   TObject *temp = 0;\n\n   temp   = fFiles->FindObject(name);       if (temp) return temp;\n   temp   = fMappedFiles->FindObject(name); if (temp) return temp;\n   {\n      R__LOCKGUARD(gROOTMutex);\n      temp   = fFunctions->FindObject(name);if (temp) return temp;\n   }\n   temp   = fGeometries->FindObject(name);  if (temp) return temp;\n   temp   = fCanvases->FindObject(name);    if (temp) return temp;\n   temp   = fStyles->FindObject(name);      if (temp) return temp;\n   {\n      R__LOCKGUARD(gROOTMutex);\n      temp = fSpecials->FindObject(name);   if (temp) return temp;\n   }\n   TIter next(fGeometries);\n   TObject *obj;\n   while ((obj=next())) {\n      temp = obj->FindObject(name);         if (temp) return temp;\n   }\n   if (gDirectory) temp = gDirectory->Get(name);\n   if (temp) return temp;\n   if (gPad) {\n      TVirtualPad *canvas = gPad->GetVirtCanvas();\n      if (fCanvases->FindObject(canvas)) {  //this check in case call from TCanvas ctor\n         temp = canvas->FindObject(name);\n         if (!temp && canvas != gPad) temp  = gPad->FindObject(name);\n      }\n   }\n   return temp;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns address and folder of a ROOT object if it exists\n///\n/// This function looks in the following order in the ROOT lists:\n///     - List of files\n///     - List of memory mapped files\n///     - List of functions\n///     - List of geometries\n///     - List of canvases\n///     - List of styles\n///     - List of specials\n///     - List of materials in current geometry\n///     - List of shapes in current geometry\n///     - List of matrices in current geometry\n///     - List of Nodes in current geometry\n///     - Current Directory in memory\n///     - Current Directory on file\n\nTObject *TROOT::FindSpecialObject(const char *name, void *&where)\n{\n   TObject *temp = 0;\n   where = 0;\n\n   if (!temp) {\n      temp  = fFiles->FindObject(name);\n      where = fFiles;\n   }\n   if (!temp) {\n      temp  = fMappedFiles->FindObject(name);\n      where = fMappedFiles;\n   }\n   if (!temp) {\n      R__LOCKGUARD(gROOTMutex);\n      temp  = fFunctions->FindObject(name);\n      where = fFunctions;\n   }\n   if (!temp) {\n      temp  = fCanvases->FindObject(name);\n      where = fCanvases;\n   }\n   if (!temp) {\n      temp  = fStyles->FindObject(name);\n      where = fStyles;\n   }\n   if (!temp) {\n      temp  = fSpecials->FindObject(name);\n      where = fSpecials;\n   }\n   if (!temp) {\n      TObject *glast = fGeometries->Last();\n      if (glast) {where = glast; temp = glast->FindObject(name);}\n   }\n   if (!temp && gDirectory) {\n      temp  = gDirectory->Get(name);\n      where = gDirectory;\n   }\n   if (!temp && gPad) {\n      TVirtualPad *canvas = gPad->GetVirtCanvas();\n      if (fCanvases->FindObject(canvas)) {  //this check in case call from TCanvas ctor\n         temp  = canvas->FindObject(name);\n         where = canvas;\n         if (!temp && canvas != gPad) {\n            temp  = gPad->FindObject(name);\n            where = gPad;\n         }\n      }\n   }\n   if (!temp) return 0;\n   if (temp->TestBit(kNotDeleted)) return temp;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a pointer to the first object with name starting at //root.\n/// This function scans the list of all folders.\n/// if no object found in folders, it scans the memory list of all files.\n\nTObject *TROOT::FindObjectAny(const char *name) const\n{\n   TObject *obj = fRootFolder->FindObjectAny(name);\n   if (obj) return obj;\n   return gDirectory->FindObjectAnyFile(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Scan the memory lists of all files for an object with name\n\nTObject *TROOT::FindObjectAnyFile(const char *name) const\n{\n   R__LOCKGUARD(gROOTMutex);\n   TDirectory *d;\n   TIter next(GetListOfFiles());\n   while ((d = (TDirectory*)next())) {\n      // Call explicitly TDirectory::FindObject to restrict the search to the\n      // already in memory object.\n      TObject *obj = d->TDirectory::FindObject(name);\n      if (obj) return obj;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Returns class name of a ROOT object including CINT globals.\n\nconst char *TROOT::FindObjectClassName(const char *name) const\n{\n   // Search first in the list of \"standard\" objects\n   TObject *obj = FindObject(name);\n   if (obj) return obj->ClassName();\n\n   // Is it a global variable?\n   TGlobal *g = GetGlobal(name);\n   if (g) return g->GetTypeName();\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return path name of obj somewhere in the //root/... path.\n/// The function returns the first occurence of the object in the list\n/// of folders. The returned string points to a static char array in TROOT.\n/// If this function is called in a loop or recursively, it is the\n/// user's responsibility to copy this string in their area.\n\nconst char *TROOT::FindObjectPathName(const TObject *) const\n{\n   Error(\"FindObjectPathName\",\"Not yet implemented\");\n   return \"??\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// return a TClass object corresponding to 'name' assuming it is an STL container.\n/// In particular we looking for possible alternative name (default template\n/// parameter, typedefs template arguments, typedefed name).\n\nTClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const\n{\n   // Example of inputs are\n   //   vector<int>  (*)\n   //   vector<Int_t>\n   //   vector<long long>\n   //   vector<Long_64_t> (*)\n   //   vector<int, allocator<int> >\n   //   vector<Int_t, allocator<int> >\n   //\n   //   One of the possibly expensive operation is the resolving of the typedef\n   //   which can provoke the parsing of the header files (and/or the loading\n   //   of clang pcms information).\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.\n   std::string normalized;\n   TClassEdit::GetNormalizedName(normalized, name);\n\n   TClass *cl = 0;\n   if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);\n\n   if (load && cl==0) {\n      // Create an Emulated class for this container.\n      cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);\n   }\n\n   return cl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to class with name. Obsolete, use TClass::GetClass directly\n\nTClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const\n{\n   return TClass::GetClass(name,load,silent);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly\n/// See TClass::GetClass\n\nTClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const\n{\n   return TClass::GetClass(typeinfo,load,silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return address of color with index color.\n\nTColor *TROOT::GetColor(Int_t color) const\n{\n   TColor::InitializeColors();\n   TObjArray *lcolors = (TObjArray*) GetListOfColors();\n   if (!lcolors) return 0;\n   if (color < 0 || color >= lcolors->GetSize()) return 0;\n   TColor *col = (TColor*)lcolors->At(color);\n   if (col && col->GetNumber() == color) return col;\n   TIter   next(lcolors);\n   while ((col = (TColor *) next()))\n      if (col->GetNumber() == color) return col;\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a default canvas.\n\nTCanvas *TROOT::MakeDefCanvas() const\n{\n   return (TCanvas*)gROOT->ProcessLine(\"TCanvas::MakeDefCanvas();\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to type with name.\n\nTDataType *TROOT::GetType(const char *name, Bool_t /* load */) const\n{\n   return (TDataType*)gROOT->GetListOfTypes()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to file with name.\n\nTFile *TROOT::GetFile(const char *name) const\n{\n   R__LOCKGUARD(gROOTMutex);\n   return (TFile*)GetListOfFiles()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to style with name\n\nTStyle *TROOT::GetStyle(const char *name) const\n{\n   return (TStyle*)GetListOfStyles()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to function with name.\n\nTObject *TROOT::GetFunction(const char *name) const\n{\n   if (name == 0 || name[0] == 0) {\n      return 0;\n   }\n\n   {\n      R__LOCKGUARD(gROOTMutex);\n      TObject *f1 = fFunctions->FindObject(name);\n      if (f1) return f1;\n   }\n\n   gROOT->ProcessLine(\"TF1::InitStandardFunctions();\");\n\n   R__LOCKGUARD(gROOTMutex);\n   return fFunctions->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTFunctionTemplate *TROOT::GetFunctionTemplate(const char *name)\n{\n   if (!gInterpreter) return 0;\n\n   if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(0);\n\n   return (TFunctionTemplate*)fFuncTemplate->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global variable by name. If load is true force\n/// reading of all currently defined globals from CINT (more expensive).\n\nTGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const\n{\n   return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global variable with address addr.\n\nTGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const\n{\n   if (addr == 0 || ((Long_t)addr) == -1) return 0;\n\n   TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);\n   if (decl) {\n      TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));\n      return (TGlobal*)globals->Get(decl);\n   }\n   // If we are actually looking for a global that is held by a global\n   // pointer (for example gRandom), we need to find a pointer with the\n   // correct value.\n   decl = gInterpreter->GetDataMemberWithValue(addr);\n   if (decl) {\n      TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));\n      return (TGlobal*)globals->Get(decl);\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal routine returning, and creating if necessary, the list\n/// of global function.\n\nTListOfFunctions *TROOT::GetGlobalFunctions()\n{\n   if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(0);\n   return fGlobalFunctions;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the collection of functions named \"name\".\n\nTCollection *TROOT::GetListOfFunctionOverloads(const char* name) const\n{\n   return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global function by name.\n/// If params != 0 it will also resolve overloading other it returns the first\n/// name match.\n/// If params == 0 and load is true force reading of all currently defined\n/// global functions from Cling.\n/// The param string must be of the form: \"3189,\\\"aap\\\",1.3\".\n\nTFunction *TROOT::GetGlobalFunction(const char *function, const char *params,\n                                    Bool_t load)\n{\n   if (!params) {\n      R__LOCKGUARD(gROOTMutex);\n      return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);\n   } else {\n      if (!fInterpreter)\n         Fatal(\"GetGlobalFunction\", \"fInterpreter not initialized\");\n\n      R__LOCKGUARD(gROOTMutex);\n      TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(0,\n                                                                 function, params,\n                                                                 false);\n\n      if (!decl) return 0;\n\n      TFunction *f = GetGlobalFunctions()->Get(decl);\n      if (f) return f;\n\n      Error(\"GetGlobalFunction\",\n            \"\\nDid not find matching TFunction <%s> with \\\"%s\\\".\",\n            function,params);\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to global function by name. If proto != 0\n/// it will also resolve overloading. If load is true force reading\n/// of all currently defined global functions from CINT (more expensive).\n/// The proto string must be of the form: \"int, char*, float\".\n\nTFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,\n                                               const char *proto, Bool_t load)\n{\n   if (!proto) {\n      R__LOCKGUARD(gROOTMutex);\n      return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);\n   } else {\n      if (!fInterpreter)\n         Fatal(\"GetGlobalFunctionWithPrototype\", \"fInterpreter not initialized\");\n\n      R__LOCKGUARD(gROOTMutex);\n      TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(0,\n                                                                           function, proto);\n\n      if (!decl) return 0;\n\n      TFunction *f = GetGlobalFunctions()->Get(decl);\n      if (f) return f;\n\n      Error(\"GetGlobalFunctionWithPrototype\",\n            \"\\nDid not find matching TFunction <%s> with \\\"%s\\\".\",\n            function,proto);\n      return 0;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to Geometry with name\n\nTObject *TROOT::GetGeometry(const char *name) const\n{\n   return GetListOfGeometries()->FindObject(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */)\n{\n   if(!fEnums.load()) {\n      R__LOCKGUARD(gROOTMutex);\n      // Test again just in case, another thread did the work while we were\n      // waiting.\n      if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(0);\n   }\n   if (load) {\n      R__LOCKGUARD(gROOTMutex);\n      (*fEnums).Load(); // Refresh the list of enums.\n   }\n   return fEnums.load();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCollection *TROOT::GetListOfFunctionTemplates()\n{\n   R__LOCKGUARD(gROOTMutex);\n   if(!fFuncTemplate) {\n      fFuncTemplate = new TListOfFunctionTemplates(0);\n   }\n   return fFuncTemplate;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TGlobals currently defined.\n/// Since globals are created and deleted during execution of the\n/// program, we need to update the list of globals every time we\n/// execute this method. However, when calling this function in\n/// a (tight) loop where no interpreter symbols will be created\n/// you can set load=kFALSE (default).\n\nTCollection *TROOT::GetListOfGlobals(Bool_t load)\n{\n   if (!fGlobals) {\n      // We add to the list the \"funcky-fake\" globals.\n      fGlobals = new TListOfDataMembers(0);\n      fGlobals->Add(new TGlobalMappedFunction(\"gROOT\", \"TROOT*\",\n               (TGlobalMappedFunction::GlobalFunc_t)((void*)&ROOT::GetROOT)));\n      fGlobals->Add(new TGlobalMappedFunction(\"gPad\", \"TVirtualPad*\",\n               (TGlobalMappedFunction::GlobalFunc_t)((void*)&TVirtualPad::Pad)));\n      fGlobals->Add(new TGlobalMappedFunction(\"gInterpreter\", \"TInterpreter*\",\n               (TGlobalMappedFunction::GlobalFunc_t)((void*)&TInterpreter::Instance)));\n      fGlobals->Add(new TGlobalMappedFunction(\"gVirtualX\", \"TVirtualX*\",\n               (TGlobalMappedFunction::GlobalFunc_t)((void*)&TVirtualX::Instance)));\n      fGlobals->Add(new TGlobalMappedFunction(\"gDirectory\", \"TDirectory*\",\n               (TGlobalMappedFunction::GlobalFunc_t)((void*)&TDirectory::CurrentDirectory)));\n      // Don't let TGlobalMappedFunction delete our globals, now that we take them.\n      fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());\n      TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);\n      TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();\n   }\n\n   if (!fInterpreter)\n      Fatal(\"GetListOfGlobals\", \"fInterpreter not initialized\");\n\n   if (load) fGlobals->Load();\n\n   return fGlobals;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return list containing the TFunctions currently defined.\n/// Since functions are created and deleted during execution of the\n/// program, we need to update the list of functions every time we\n/// execute this method. However, when calling this function in\n/// a (tight) loop where no interpreter symbols will be created\n/// you can set load=kFALSE (default).\n\nTCollection *TROOT::GetListOfGlobalFunctions(Bool_t load)\n{\n   R__LOCKGUARD(gROOTMutex);\n\n   if (!fGlobalFunctions) {\n      fGlobalFunctions = new TListOfFunctions(0);\n   }\n\n   if (!fInterpreter)\n      Fatal(\"GetListOfGlobalFunctions\", \"fInterpreter not initialized\");\n\n   // A thread that calls with load==true and a thread that calls with load==false\n   // will conflict here (the load==true will be updating the list while the\n   // other is reading it).  To solve the problem, we could use a read-write lock\n   // inside the list itself.\n   if (load) fGlobalFunctions->Load();\n\n   return fGlobalFunctions;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a dynamic list giving access to all TDataTypes (typedefs)\n/// currently defined.\n///\n/// The list is populated on demand.  Calling\n/// ~~~ {.cpp}\n///    gROOT->GetListOfTypes()->FindObject(nameoftype);\n/// ~~~\n/// will return the TDataType corresponding to 'nameoftype'.  If the\n/// TDataType is not already in the list itself and the type does exist,\n/// a new TDataType will be created and added to the list.\n///\n/// Calling\n/// ~~~ {.cpp}\n///    gROOT->GetListOfTypes()->ls(); // or Print()\n/// ~~~\n/// list only the typedefs that have been previously accessed through the\n/// list (plus the builtins types).\n\nTCollection *TROOT::GetListOfTypes(Bool_t /* load */)\n{\n   if (!fInterpreter)\n      Fatal(\"GetListOfTypes\", \"fInterpreter not initialized\");\n\n   return fTypes;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute command when system has been idle for idleTimeInSec seconds.\n\nvoid TROOT::Idle(UInt_t idleTimeInSec, const char *command)\n{\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   if (idleTimeInSec <= 0)\n      (*fApplication).RemoveIdleTimer();\n   else\n      (*fApplication).SetIdleTimer(idleTimeInSec, command);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check whether className is a known class, and only autoload\n/// if we can. Helper function for TROOT::IgnoreInclude().\n\nstatic TClass* R__GetClassIfKnown(const char* className)\n{\n   // Check whether the class is available for auto-loading first:\n   const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);\n   TClass* cla = 0;\n   if (libsToLoad) {\n      // trigger autoload, and only create TClass in this case.\n      return TClass::GetClass(className);\n   } else if (gROOT->GetListOfClasses()\n              && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {\n      // cla assigned in if statement\n   } else if (gClassTable->FindObject(className)) {\n      return TClass::GetClass(className);\n   }\n   return cla;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return 1 if the name of the given include file corresponds to a class that\n///  is known to ROOT, e.g. \"TLorentzVector.h\" versus TLorentzVector.\n\nInt_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/)\n{\n   if (fname == 0) return 0;\n\n   TString stem(fname);\n   // Remove extension if any, ignore files with extension not being .h*\n   Int_t where = stem.Last('.');\n   if (where != kNPOS) {\n      if (stem.EndsWith(\".so\") || stem.EndsWith(\".sl\") ||\n          stem.EndsWith(\".dl\") || stem.EndsWith(\".a\")  ||\n          stem.EndsWith(\".dll\", TString::kIgnoreCase))\n         return 0;\n      stem.Remove(where);\n   }\n\n   TString className = gSystem->BaseName(stem);\n   TClass* cla = R__GetClassIfKnown(className);\n   if (!cla) {\n      // Try again with modifications to the file name:\n      className = stem;\n      className.ReplaceAll(\"/\", \"::\");\n      className.ReplaceAll(\"\\\\\", \"::\");\n      if (className.Contains(\":::\")) {\n         // \"C:\\dir\" becomes \"C:::dir\".\n         // fname corresponds to whatever is stated after #include and\n         // a full path name usually means that it's not a regular #include\n         // but e.g. a \".L\", so we can assume that this is not a header of\n         // a class in a namespace (a global-namespace class would have been\n         // detected already before).\n         return 0;\n      }\n      cla = R__GetClassIfKnown(className);\n   }\n\n   if (!cla) {\n      return 0;\n   }\n\n   // cla is valid, check wether it's actually in the header of the same name:\n   if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++\n   TString decfile = gSystem->BaseName(cla->GetDeclFileName());\n   if (decfile != gSystem->BaseName(fname)) {\n      return 0;\n   }\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize operating system interface.\n\nvoid TROOT::InitSystem()\n{\n   if (gSystem == 0) {\n#if defined(R__UNIX)\n#if defined(R__HAS_COCOA)\n      gSystem = new TMacOSXSystem;\n#else\n      gSystem = new TUnixSystem;\n#endif\n#elif defined(R__WIN32)\n      gSystem = new TWinNTSystem;\n#else\n      gSystem = new TSystem;\n#endif\n\n      if (gSystem->Init())\n         fprintf(stderr, \"Fatal in <TROOT::InitSystem>: can't init operating system layer\\n\");\n\n      if (!gSystem->HomeDirectory()) {\n         fprintf(stderr, \"Fatal in <TROOT::InitSystem>: HOME directory not set\\n\");\n         fprintf(stderr, \"Fix this by defining the HOME shell variable\\n\");\n      }\n\n      // read default files\n      gEnv = new TEnv(\".rootrc\");\n\n      gDebug = gEnv->GetValue(\"Root.Debug\", 0);\n\n      if (!gEnv->GetValue(\"Root.ErrorHandlers\", 1))\n         gSystem->ResetSignals();\n\n      // The old \"Root.ZipMode\" had a discrepancy between documentation vs actual meaning.\n      // Also, a value with the meaning \"default\" wasn't available. To solved this,\n      // \"Root.ZipMode\" was replaced by \"Root.CompressionAlgorithm\". Warn about usage of\n      // the old value, if it's set to 0, but silently translate the setting to\n      // \"Root.CompressionAlgorithm\" for values > 1.\n      Int_t oldzipmode = gEnv->GetValue(\"Root.ZipMode\", -1);\n      if (oldzipmode == 0) {\n         fprintf(stderr, \"Warning in <TROOT::InitSystem>: ignoring old rootrc entry \\\"Root.ZipMode = 0\\\"!\\n\");\n      } else {\n         if (oldzipmode == -1 || oldzipmode == 1) {\n            // Not set or default value, use \"default\" for \"Root.CompressionAlgorithm\":\n            oldzipmode = 0;\n         }\n         // else keep the old zipmode (e.g. \"3\") as \"Root.CompressionAlgorithm\"\n         // if \"Root.CompressionAlgorithm\" isn't set; see below.\n      }\n\n      Int_t zipmode = gEnv->GetValue(\"Root.CompressionAlgorithm\", oldzipmode);\n      if (zipmode != 0) R__SetZipMode(zipmode);\n\n      const char *sdeb;\n      if ((sdeb = gSystem->Getenv(\"ROOTDEBUG\")))\n         gDebug = atoi(sdeb);\n\n      if (gDebug > 0 && isatty(2))\n         fprintf(stderr, \"Info in <TROOT::InitSystem>: running with gDebug = %d\\n\", gDebug);\n\n      if (gEnv->GetValue(\"Root.MemStat\", 0))\n         TStorage::EnableStatistics();\n      int msize = gEnv->GetValue(\"Root.MemStat.size\", -1);\n      int mcnt  = gEnv->GetValue(\"Root.MemStat.cnt\", -1);\n      if (msize != -1 || mcnt != -1)\n         TStorage::EnableStatistics(msize, mcnt);\n\n      fgMemCheck = gEnv->GetValue(\"Root.MemCheck\", 0);\n\n#if defined(R__HAS_COCOA)\n      // create and delete a dummy TUrl so that TObjectStat table does not contain\n      // objects that are deleted after recording is turned-off (in next line),\n      // like the TUrl::fgSpecialProtocols list entries which are created in the\n      // TMacOSXSystem ctor.\n      { TUrl dummy(\"/dummy\"); }\n#endif\n      TObject::SetObjectStat(gEnv->GetValue(\"Root.ObjectStat\", 0));\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load and initialize thread library.\n\nvoid TROOT::InitThreads()\n{\n   if (gEnv->GetValue(\"Root.UseThreads\", 0) || gEnv->GetValue(\"Root.EnableThreadSafety\", 0)) {\n      ROOT::EnableThreadSafety();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the interpreter. Should be called only after main(),\n/// to make sure LLVM/Clang is fully initialized.\n\nvoid TROOT::InitInterpreter()\n{\n   // usedToIdentifyRootClingByDlSym is available when TROOT is part of\n   // rootcling.\n   if (!dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\")\n       && !dlsym(RTLD_DEFAULT, \"usedToIdentifyStaticRoot\")) {\n      // Make sure no llvm symbols are visible before loading libCling. If they\n      // exist libCling will use those and not ours, causing havoc in the\n      // interpreter. Look for an extern \"C\" symbol to avoid mangling; look for a\n      // symbol from llvm because clang builds on top, so users would likely\n      // have also their own llvm symbols when providing their own clang.\n      void *LLVMEnablePrettyStackTraceAddr = 0;\n      // Can't use gSystem->DynFindSymbol() because that iterates over all *known*\n      // libraries which is not the same!\n      LLVMEnablePrettyStackTraceAddr = dlsym(RTLD_DEFAULT, \"LLVMEnablePrettyStackTrace\");\n      // FIXME: When we configure with -Dclingtest=On we intentionally export the symbols. Silence this error.\n      if (LLVMEnablePrettyStackTraceAddr) {\n         Error(\"InitInterpreter()\", \"LLVM SYMBOLS ARE EXPOSED TO CLING! \"\n               \"This will cause problems; please hide them or dlopen() them \"\n               \"after the call to TROOT::InitInterpreter()!\");\n      }\n\n      char *libRIO = gSystem->DynamicPathName(\"libRIO\");\n      void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);\n      delete [] libRIO;\n      if (!libRIOHandle) {\n         TString err = dlerror();\n         fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load library %s\\n\", err.Data());\n         exit(1);\n      }\n\n      char *libcling = gSystem->DynamicPathName(\"libCling\");\n      gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);\n      delete [] libcling;\n\n      if (!gInterpreterLib) {\n         TString err = dlerror();\n         fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load library %s\\n\", err.Data());\n         exit(1);\n      }\n      dlerror();   // reset error message\n   } else {\n      gInterpreterLib = RTLD_DEFAULT;\n   }\n   CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, \"CreateInterpreter\");\n   if (!CreateInterpreter) {\n      TString err = dlerror();\n      fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\\n\", err.Data());\n      exit(1);\n   }\n   // Schedule the destruction of TROOT.\n   atexit(at_exit_of_TROOT);\n\n   gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, \"DestroyInterpreter\");\n   if (!gDestroyInterpreter) {\n      TString err = dlerror();\n      fprintf(stderr, \"Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\\n\", err.Data());\n      exit(1);\n   }\n\n   const char *interpArgs[] = {\n#ifdef NDEBUG\n      \"-DNDEBUG\",\n#else\n      \"-UNDEBUG\",\n#endif\n#ifdef DEBUG\n      \"-DDEBUG\",\n#else\n      \"-UDEBUG\",\n#endif\n#ifdef _DEBUG\n      \"-D_DEBUG\",\n#else\n      \"-U_DEBUG\",\n#endif\n      nullptr};\n\n   fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);\n\n   fCleanups->Add(fInterpreter);\n   fInterpreter->SetBit(kMustCleanup);\n\n   fgRootInit = kTRUE;\n\n   // initialize gClassTable is not already done\n   if (!gClassTable)\n      new TClassTable;\n\n   // Initialize all registered dictionaries.\n   for (std::vector<ModuleHeaderInfo_t>::const_iterator\n           li = GetModuleHeaderInfoBuffer().begin(),\n           le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {\n         // process buffered module registrations\n      fInterpreter->RegisterModule(li->fModuleName,\n                                   li->fHeaders,\n                                   li->fIncludePaths,\n                                   li->fPayloadCode,\n                                   li->fFwdDeclCode,\n                                   li->fTriggerFunc,\n                                   li->fFwdNargsToKeepColl,\n                                   li->fClassesHeaders,\n                                   kTRUE /*lateRegistration*/,\n                                   li->fHasCxxModule);\n   }\n   GetModuleHeaderInfoBuffer().clear();\n\n   fInterpreter->Initialize();\n\n   // Read the rules before enabling the auto loading to not inadvertently\n   // load the libraries for the classes concerned even-though the user is\n   // *not* using them.\n   TClass::ReadRules(); // Read the default customization rules ...\n\n   // Enable autoloading\n   fInterpreter->EnableAutoLoading();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function used by TClass::GetClass().\n/// This function attempts to load the dictionary for 'classname'\n/// either from the TClassTable or from the list of generator.\n/// If silent is 'true', do not warn about missing dictionary for the class.\n/// (typically used for class that are used only for transient members)\n///\n/// The 'requestedname' is expected to be already normalized.\n\nTClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const\n{\n   return TClass::LoadClass(requestedname, silent);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check if class \"classname\" is known to the interpreter (in fact,\n/// this check is not needed anymore, so classname is ignored). If\n/// not it will load library \"libname\". If the library couldn't be found with original\n/// libname and if the name was not prefixed with lib, try to prefix with \"lib\" and search again.\n/// If DynamicPathName still couldn't find the library, return -1.\n/// If check is true it will only check if libname exists and is\n/// readable.\n/// Returns 0 on successful loading, -1 in case libname does not\n/// exist or in case of error and -2 in case of version mismatch.\n\nInt_t TROOT::LoadClass(const char * /*classname*/, const char *libname,\n                       Bool_t check)\n{\n   TString lib(libname);\n\n   // Check if libname exists in path or not\n   if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {\n      // If check == true, only check if it exists and if it's readable\n      if (check) {\n         delete [] path;\n         return 0;\n      }\n\n      // If check == false, try to load the library\n      else {\n         int err = gSystem->Load(path, 0, kTRUE);\n         delete [] path;\n\n         // TSystem::Load returns 1 when the library was already loaded, return success in this case.\n         if (err == 1)\n            err = 0;\n         return err;\n      }\n   } else {\n      // This is the branch where libname didn't exist\n      if (check) {\n         FileStat_t stat;\n         if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&\n             !gSystem->AccessPathName(libname, kReadPermission)))\n            return 0;\n      }\n\n      // Take care of user who didn't write the whole name\n      if (!lib.BeginsWith(\"lib\")) {\n         lib = \"lib\" + lib;\n         return LoadClass(\"\", lib.Data(), check);\n      }\n   }\n\n   // Execution reaches here when library was prefixed with lib, check is false and couldn't find\n   // the library name.\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the file is local and is (likely) to be a ROOT file\n\nBool_t TROOT::IsRootFile(const char *filename) const\n{\n   Bool_t result = kFALSE;\n   FILE *mayberootfile = fopen(filename,\"rb\");\n   if (mayberootfile) {\n      char header[5];\n      if (fgets(header,5,mayberootfile)) {\n         result = strncmp(header,\"root\",4)==0;\n      }\n      fclose(mayberootfile);\n   }\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// To list all objects of the application.\n/// Loop on all objects created in the ROOT linked lists.\n/// Objects may be files and windows or any other object directly\n/// attached to the ROOT linked list.\n\nvoid TROOT::ls(Option_t *option) const\n{\n//   TObject::SetDirLevel();\n//   GetList()->R__FOR_EACH(TObject,ls)(option);\n   TDirectory::ls(option);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a macro in the interpreter's memory. Equivalent to the command line\n/// command \".L filename\". If the filename has \"+\" or \"++\" appended\n/// the macro will be compiled by ACLiC. The filename must have the format:\n/// [path/]macro.C[+|++[g|O]].\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// If check is true it will only check if filename exists and is\n/// readable.\n/// Returns 0 on successful loading and -1 in case filename does not\n/// exist or in case of error.\n\nInt_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check)\n{\n   Int_t err = -1;\n   Int_t lerr, *terr;\n   if (error)\n      terr = error;\n   else\n      terr = &lerr;\n\n   if (fInterpreter) {\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);\n\n      if (arguments.Length()) {\n         Warning(\"LoadMacro\", \"argument(%s) ignored in %s\", arguments.Data(), GetMacroPath());\n      }\n      char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);\n      if (!mac) {\n         if (!check)\n            Error(\"LoadMacro\", \"macro %s not found in path %s\", fname.Data(), GetMacroPath());\n         *terr = TInterpreter::kFatal;\n      } else {\n         err = 0;\n         if (!check) {\n            fname = mac;\n            fname += aclicMode;\n            fname += io;\n            gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);\n            if (*terr)\n               err = -1;\n         }\n      }\n      delete [] mac;\n   }\n   return err;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a macro in the interpreter. Equivalent to the command line\n/// command \".x filename\". If the filename has \"+\" or \"++\" appended\n/// the macro will be compiled by ACLiC. The filename must have the format:\n/// [path/]macro.C[+|++[g|O]][(args)].\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// If padUpdate is true (default) update the current pad.\n/// Returns the macro return value.\n\nLong_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate)\n{\n   Long_t result = 0;\n\n   if (fInterpreter) {\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);\n\n      char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);\n      if (!mac) {\n         Error(\"Macro\", \"macro %s not found in path %s\", fname.Data(), GetMacroPath());\n         if (error)\n            *error = TInterpreter::kFatal;\n      } else {\n         fname = mac;\n         fname += aclicMode;\n         fname += arguments;\n         fname += io;\n         result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);\n      }\n      delete [] mac;\n\n      if (padUpdate && gPad)\n         gPad->Update();\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process message id called by obj.\n\nvoid  TROOT::Message(Int_t id, const TObject *obj)\n{\n   TIter next(fMessageHandlers);\n   TMessageHandler *mh;\n   while ((mh = (TMessageHandler*)next())) {\n      mh->HandleMessage(id,obj);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command via TApplication::ProcessLine().\n/// On Win32 the line will be processed asynchronously by sending\n/// it to the CINT interpreter thread. For explicit synchronous processing\n/// use ProcessLineSync(). On non-Win32 platforms there is no difference\n/// between ProcessLine() and ProcessLineSync().\n/// The possible error codes are defined by TInterpreter::EErrorCode. In\n/// particular, error will equal to TInterpreter::kProcessing until the\n/// CINT interpreted thread has finished executing the line.\n/// Returns the result of the command, cast to a Long_t.\n\nLong_t TROOT::ProcessLine(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   return (*fApplication).ProcessLine(sline, kFALSE, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command via TApplication::ProcessLine().\n/// On Win32 the line will be processed synchronously (i.e. it will\n/// only return when the CINT interpreter thread has finished executing\n/// the line). On non-Win32 platforms there is no difference between\n/// ProcessLine() and ProcessLineSync().\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n/// Returns the result of the command, cast to a Long_t.\n\nLong_t TROOT::ProcessLineSync(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   return (*fApplication).ProcessLine(sline, kTRUE, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Process interpreter command directly via CINT interpreter.\n/// Only executable statements are allowed (no variable declarations),\n/// In all other cases use TROOT::ProcessLine().\n/// The possible error codes are defined by TInterpreter::EErrorCode.\n\nLong_t TROOT::ProcessLineFast(const char *line, Int_t *error)\n{\n   TString sline = line;\n   sline = sline.Strip(TString::kBoth);\n\n   if (!fApplication.load())\n      TApplication::CreateApplication();\n\n   Long_t result = 0;\n\n   if (fInterpreter) {\n      TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;\n      result = gInterpreter->Calc(sline, code);\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read Git commit information and branch name from the\n/// etc/gitinfo.txt file.\n\nvoid TROOT::ReadGitInfo()\n{\n#ifdef ROOT_GIT_COMMIT\n   fGitCommit = ROOT_GIT_COMMIT;\n#endif\n#ifdef ROOT_GIT_BRANCH\n   fGitBranch = ROOT_GIT_BRANCH;\n#endif\n\n   TString gitinfo = \"gitinfo.txt\";\n   char *filename = gSystem->ConcatFileName(TROOT::GetEtcDir(), gitinfo);\n\n   FILE *fp = fopen(filename, \"r\");\n   if (fp) {\n      TString s;\n      // read branch name\n      s.Gets(fp);\n      fGitBranch = s;\n      // read commit SHA1\n      s.Gets(fp);\n      fGitCommit = s;\n      // read date/time make was run\n      s.Gets(fp);\n      fGitDate = s;\n      fclose(fp);\n   }\n   delete [] filename;\n}\n\nBool_t &GetReadingObject() {\n   TTHREAD_TLS(Bool_t) fgReadingObject = false;\n   return fgReadingObject;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Deprecated (will be removed in next release).\n\nBool_t TROOT::ReadingObject() const\n{\n   return GetReadingObject();\n}\n\nvoid TROOT::SetReadingObject(Bool_t flag)\n{\n   GetReadingObject() = flag;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return date/time make was run.\n\nconst char *TROOT::GetGitDate()\n{\n   if (fGitDate == \"\") {\n      Int_t iday,imonth,iyear, ihour, imin;\n      static const char *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                      \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n      Int_t idate = gROOT->GetBuiltDate();\n      Int_t itime = gROOT->GetBuiltTime();\n      iday   = idate%100;\n      imonth = (idate/100)%100;\n      iyear  = idate/10000;\n      ihour  = itime/100;\n      imin   = itime%100;\n      fGitDate.Form(\"%s %02d %4d, %02d:%02d:00\", months[imonth-1], iday, iyear, ihour, imin);\n   }\n   return fGitDate;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Recursively remove this object from the list of Cleanups.\n/// Typically RecursiveRemove is implemented by classes that can contain\n/// mulitple references to a same object or shared ownership of the object\n/// with others.\n\nvoid TROOT::RecursiveRemove(TObject *obj)\n{\n   R__READ_LOCKGUARD(ROOT::gCoreMutex);\n\n   fCleanups->RecursiveRemove(obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Refresh all browsers. Call this method when some command line\n/// command or script has changed the browser contents. Not needed\n/// for objects that have the kMustCleanup bit set. Most useful to\n/// update browsers that show the file system or other objects external\n/// to the running ROOT session.\n\nvoid TROOT::RefreshBrowsers()\n{\n   TIter next(GetListOfBrowsers());\n   TBrowser *b;\n   while ((b = (TBrowser*) next()))\n      b->SetRefreshFlag(kTRUE);\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Insure that the files, canvases and sockets are closed.\n\nstatic void CallCloseFiles()\n{\n   if (TROOT::Initialized() && ROOT::Internal::gROOTLocal) {\n      gROOT->CloseFiles();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Called by static dictionary initialization to register clang modules\n/// for headers. Calls TCling::RegisterModule() unless gCling\n/// is NULL, i.e. during startup, where the information is buffered in\n/// the static GetModuleHeaderInfoBuffer().\n\nvoid TROOT::RegisterModule(const char* modulename,\n                           const char** headers,\n                           const char** includePaths,\n                           const char* payloadCode,\n                           const char* fwdDeclCode,\n                           void (*triggerFunc)(),\n                           const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                           const char** classesHeaders,\n                           bool hasCxxModule)\n{\n\n   // First a side track to insure proper end of process behavior.\n\n   // Register for each loaded dictionary (and thus for each library),\n   // that we need to Close the ROOT files as soon as this library\n   // might start being unloaded after main.\n   //\n   // By calling atexit here (rather than directly from within the\n   // library) we make sure that this is not called if the library is\n   // 'only' dlclosed.\n\n   // On Ubuntu the linker strips the unused libraries.  Eventhough\n   // stressHistogram is explicitly linked against libNet, it is not\n   // retained and thus is loaded only as needed in the middle part of\n   // the execution.  Concretely this also means that it is loaded\n   // *after* the construction of the TApplication object and thus\n   // after the registration (atexit) of the EndOfProcessCleanups\n   // routine.  Consequently, after the end of main, libNet is\n   // unloaded before EndOfProcessCleanups is called.  When\n   // EndOfProcessCleanups is executed it indirectly needs the TClass\n   // for TSocket and its search will use resources that have already\n   // been unloaded (technically the function static in TUnixSystem's\n   // DynamicPath and the dictionary from libNet).\n\n   // Similarly, the ordering (before this commit) was broken in the\n   // following case:\n\n   //    TApplication creation (EndOfProcessCleanups registration)\n   //    load UserLibrary\n   //    create TFile\n   //    Append UserObject to TFile\n\n   // and after the end of main the order of execution was\n\n   //    unload UserLibrary\n   //    call EndOfProcessCleanups\n   //       Write the TFile\n   //         attempt to write the user object.\n   //    ....\n\n   // where what we need is to have the files closen/written before\n   // the unloading of the library.\n\n   // To solve the problem we now register an atexit function for\n   // every dictionary thus making sure there is at least one executed\n   // before the first library tear down after main.\n\n   // If atexit is called directly within a library's code, the\n   // function will called *either* when the library is 'dlclose'd or\n   // after then end of main (whichever comes first).  We do *not*\n   // want the files to be closed whenever a library is unloaded via\n   // dlclose.  To avoid this, we add the function (CallCloseFiles)\n   // from the dictionary indirectly (via ROOT::RegisterModule).  In\n   // this case the function will only only be called either when\n   // libCore is 'dlclose'd or right after the end of main.\n\n   atexit(CallCloseFiles);\n\n   // Now register with TCling.\n   if (gCling) {\n      gCling->RegisterModule(modulename, headers, includePaths, payloadCode, fwdDeclCode, triggerFunc,\n                             fwdDeclsArgToSkip, classesHeaders, false, hasCxxModule);\n   } else {\n      GetModuleHeaderInfoBuffer().push_back(ModuleHeaderInfo_t(modulename, headers, includePaths, payloadCode,\n                                                               fwdDeclCode, triggerFunc, fwdDeclsArgToSkip,\n                                                               classesHeaders, hasCxxModule));\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove an object from the in-memory list.\n///    Since TROOT is global resource, this is lock protected.\n\nTObject *TROOT::Remove(TObject* obj)\n{\n   R__LOCKGUARD(gROOTMutex);\n   return TDirectory::Remove(obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Remove a class from the list and map of classes.\n/// This routine is deprecated, use TClass::RemoveClass directly.\n\nvoid TROOT::RemoveClass(TClass *oldcl)\n{\n   TClass::RemoveClass(oldcl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete all global interpreter objects created since the last call to Reset\n///\n/// If option=\"a\" is set reset to startup context (i.e. unload also\n/// all loaded files, classes, structs, typedefs, etc.).\n///\n/// This function is typically used at the beginning (or end) of an unnamed macro\n/// to clean the environment.\n///\n/// IMPORTANT WARNING:\n/// Do not use this call from within any function (neither compiled nor\n/// interpreted.  This should only be used from a unnamed macro\n/// (which starts with a { (curly braces)  ).  For example, using TROOT::Reset\n/// from within an interpreted function will lead to the unloading of the\n/// dictionary and source file, including the one defining the function being\n/// executed.\n///\n\nvoid TROOT::Reset(Option_t *option)\n{\n   if (IsExecutingMacro()) return;  //True when TMacro::Exec runs\n   if (fInterpreter) {\n      if (!strncmp(option, \"a\", 1)) {\n         fInterpreter->Reset();\n         fInterpreter->SaveContext();\n      } else\n         gInterpreter->ResetGlobals();\n\n      if (fGlobals) fGlobals->Unload();\n      if (fGlobalFunctions) fGlobalFunctions->Unload();\n\n      SaveContext();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current interpreter context.\n\nvoid TROOT::SaveContext()\n{\n   if (fInterpreter)\n      gInterpreter->SaveGlobalsContext();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set the default graphical cut class name for the graphics editor\n/// By default the graphics editor creates an instance of a class TCutG.\n/// This function may be called to specify a different class that MUST\n/// derive from TCutG\n\nvoid TROOT::SetCutClassName(const char *name)\n{\n   if (!name) {\n      Error(\"SetCutClassName\",\"Invalid class name\");\n      return;\n   }\n   TClass *cl = TClass::GetClass(name);\n   if (!cl) {\n      Error(\"SetCutClassName\",\"Unknown class:%s\",name);\n      return;\n   }\n   if (!cl->InheritsFrom(\"TCutG\")) {\n      Error(\"SetCutClassName\",\"Class:%s does not derive from TCutG\",name);\n      return;\n   }\n   fCutClassName = name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set editor mode\n\nvoid TROOT::SetEditorMode(const char *mode)\n{\n   fEditorMode = 0;\n   if (!mode[0]) return;\n   if (!strcmp(mode,\"Arc\"))      {fEditorMode = kArc;        return;}\n   if (!strcmp(mode,\"Line\"))     {fEditorMode = kLine;       return;}\n   if (!strcmp(mode,\"Arrow\"))    {fEditorMode = kArrow;      return;}\n   if (!strcmp(mode,\"Button\"))   {fEditorMode = kButton;     return;}\n   if (!strcmp(mode,\"Diamond\"))  {fEditorMode = kDiamond;    return;}\n   if (!strcmp(mode,\"Ellipse\"))  {fEditorMode = kEllipse;    return;}\n   if (!strcmp(mode,\"Pad\"))      {fEditorMode = kPad;        return;}\n   if (!strcmp(mode,\"Pave\"))     {fEditorMode = kPave;       return;}\n   if (!strcmp(mode,\"PaveLabel\")){fEditorMode = kPaveLabel;  return;}\n   if (!strcmp(mode,\"PaveText\")) {fEditorMode = kPaveText;   return;}\n   if (!strcmp(mode,\"PavesText\")){fEditorMode = kPavesText;  return;}\n   if (!strcmp(mode,\"PolyLine\")) {fEditorMode = kPolyLine;   return;}\n   if (!strcmp(mode,\"CurlyLine\")){fEditorMode = kCurlyLine;  return;}\n   if (!strcmp(mode,\"CurlyArc\")) {fEditorMode = kCurlyArc;   return;}\n   if (!strcmp(mode,\"Text\"))     {fEditorMode = kText;       return;}\n   if (!strcmp(mode,\"Marker\"))   {fEditorMode = kMarker;     return;}\n   if (!strcmp(mode,\"CutG\"))     {fEditorMode = kCutG;       return;}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Change current style to style with name stylename\n\nvoid TROOT::SetStyle(const char *stylename)\n{\n   TString style_name = stylename;\n\n   TStyle *style = GetStyle(style_name);\n   if (style) style->cd();\n   else       Error(\"SetStyle\",\"Unknown style:%s\",style_name.Data());\n}\n\n\n//-------- Static Member Functions ---------------------------------------------\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Decrease the indentation level for ls().\n\nInt_t TROOT::DecreaseDirLevel()\n{\n   return --fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///return directory level\n\nInt_t TROOT::GetDirLevel()\n{\n   return fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get macro search path. Static utility function.\n\nconst char *TROOT::GetMacroPath()\n{\n   TString &macroPath = ROOT::GetMacroPath();\n\n   if (macroPath.Length() == 0) {\n      macroPath = gEnv->GetValue(\"Root.MacroPath\", (char*)0);\n#if defined(R__WIN32)\n      macroPath.ReplaceAll(\"; \", \";\");\n#else\n      macroPath.ReplaceAll(\": \", \":\");\n#endif\n      if (macroPath.Length() == 0)\n#if !defined(R__WIN32)\n         macroPath = \".:\" + TROOT::GetMacroDir();\n#else\n         macroPath = \".;\" + TROOT::GetMacroDir();\n#endif\n   }\n\n   return macroPath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set or extend the macro search path. Static utility function.\n/// If newpath=0 or \"\" reset to value specified in the rootrc file.\n\nvoid TROOT::SetMacroPath(const char *newpath)\n{\n   TString &macroPath = ROOT::GetMacroPath();\n\n   if (!newpath || !*newpath)\n      macroPath = \"\";\n   else\n      macroPath = newpath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The input parameter `webdisplay` defines where web graphics should be rendered.\n///\n/// if `webdisplay` may contains:\n///\n///  - \"off\": turns off the web display and come back to normal graphics in\n///    interactive mode.\n///  - \"batch\":  turns the web display in batch mode. It can be prepend with an\n///    other string which will be considered as the new current web display\n///  - \"nobatch\": turns the web display in interactive mode. It can be prepend with an\n///    other string which will be considered as the new current web display\n///\n/// If the option \"off\" is not set, this method turns the normal graphics to\n/// \"Batch\" to avoid the loading of local graphics libraries.\n\nvoid TROOT::SetWebDisplay(const char *webdisplay)\n{\n   const char *wd = webdisplay;\n   if (!wd)\n      wd = \"\";\n\n   if (!strcmp(wd, \"off\")) {\n      fIsWebDisplay = kFALSE;\n      fIsWebDisplayBatch = kFALSE;\n      fWebDisplay = \"\";\n   } else {\n      fIsWebDisplay = kTRUE;\n      if (!strncmp(wd, \"batch\", 5)) {\n         fIsWebDisplayBatch = kTRUE;\n         wd += 5;\n      } else if (!strncmp(wd, \"nobatch\", 7)) {\n         fIsWebDisplayBatch = kFALSE;\n         wd += 7;\n      } else {\n         fIsWebDisplayBatch = kFALSE;\n      }\n      fWebDisplay = wd;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Increase the indentation level for ls().\n\nInt_t TROOT::IncreaseDirLevel()\n{\n   return ++fgDirLevel;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Functions used by ls() to indent an object hierarchy.\n\nvoid TROOT::IndentLevel()\n{\n   for (int i = 0; i < fgDirLevel; i++) std::cout.put(' ');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if the TROOT object has been initialized.\n\nBool_t TROOT::Initialized()\n{\n   return fgRootInit;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return kTRUE if the memory leak checker is on.\n\nBool_t TROOT::MemCheck()\n{\n   return fgMemCheck;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return Indentation level for ls().\n\nvoid TROOT::SetDirLevel(Int_t level)\n{\n   fgDirLevel = level;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Convert version code to an integer, i.e. 331527 -> 51507.\n\nInt_t TROOT::ConvertVersionCode2Int(Int_t code)\n{\n   return 10000*(code>>16) + 100*((code&65280)>>8) + (code&255);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Convert version as an integer to version code as used in RVersion.h.\n\nInt_t TROOT::ConvertVersionInt2Code(Int_t v)\n{\n   int a = v/10000;\n   int b = (v - a*10000)/100;\n   int c = v - a*10000 - b*100;\n   return (a << 16) + (b << 8) + c;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return ROOT version code as defined in RVersion.h.\n\nInt_t TROOT::RootVersionCode()\n{\n   return ROOT_VERSION_CODE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char**& TROOT::GetExtraInterpreterArgs() {\n   static const char** extraInterpArgs = 0;\n   return extraInterpArgs;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef ROOTPREFIX\nstatic Bool_t IgnorePrefix() {\n   static Bool_t ignorePrefix = gSystem->Getenv(\"ROOTIGNOREPREFIX\");\n   return ignorePrefix;\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the rootsys directory in the installation. Static utility function.\n\nconst TString& TROOT::GetRootSys() {\n#ifdef ROOTPREFIX\n   if (IgnorePrefix()) {\n#endif\n      static TString rootsys;\n      if (rootsys.IsNull())\n         rootsys = gSystem->UnixPathName(gSystem->Getenv(\"ROOTSYS\"));\n      if (rootsys.IsNull())\n         rootsys = gRootDir;\n      return rootsys;\n#ifdef ROOTPREFIX\n   } else {\n      const static TString rootsys = ROOTPREFIX;\n      return rootsys;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the binary directory in the installation. Static utility function.\n\nconst TString& TROOT::GetBinDir() {\n#ifdef ROOTBINDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootbindir;\n      if (rootbindir.IsNull()) {\n         rootbindir = \"bin\";\n         gSystem->PrependPathName(GetRootSys(), rootbindir);\n      }\n      return rootbindir;\n#ifdef ROOTBINDIR\n   } else {\n      const static TString rootbindir = ROOTBINDIR;\n      return rootbindir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the library directory in the installation. Static utility function.\n\nconst TString& TROOT::GetLibDir() {\n#ifdef ROOTLIBDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootlibdir;\n      if (rootlibdir.IsNull()) {\n         rootlibdir = \"lib\";\n         gSystem->PrependPathName(GetRootSys(), rootlibdir);\n      }\n      return rootlibdir;\n#ifdef ROOTLIBDIR\n   } else {\n      const static TString rootlibdir = ROOTLIBDIR;\n      return rootlibdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the include directory in the installation. Static utility function.\n\nconst TString& TROOT::GetIncludeDir() {\n#ifdef ROOTINCDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootincdir;\n      if (rootincdir.IsNull()) {\n         rootincdir = \"include\";\n         gSystem->PrependPathName(GetRootSys(), rootincdir);\n      }\n      return rootincdir;\n#ifdef ROOTINCDIR\n   } else {\n      const static TString rootincdir = ROOTINCDIR;\n      return rootincdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the sysconfig directory in the installation. Static utility function.\n\nconst TString& TROOT::GetEtcDir() {\n#ifdef ROOTETCDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootetcdir;\n      if (rootetcdir.IsNull()) {\n         rootetcdir = \"etc\";\n         gSystem->PrependPathName(GetRootSys(), rootetcdir);\n      }\n      return rootetcdir;\n#ifdef ROOTETCDIR\n   } else {\n      const static TString rootetcdir = ROOTETCDIR;\n      return rootetcdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the data directory in the installation. Static utility function.\n\nconst TString& TROOT::GetDataDir() {\n#ifdef ROOTDATADIR\n   if (IgnorePrefix()) {\n#endif\n      return GetRootSys();\n#ifdef ROOTDATADIR\n   } else {\n      const static TString rootdatadir = ROOTDATADIR;\n      return rootdatadir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the documentation directory in the installation. Static utility function.\n\nconst TString& TROOT::GetDocDir() {\n#ifdef ROOTDOCDIR\n   if (IgnorePrefix()) {\n#endif\n      return GetRootSys();\n#ifdef ROOTDOCDIR\n   } else {\n      const static TString rootdocdir = ROOTDOCDIR;\n      return rootdocdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the macro directory in the installation. Static utility function.\n\nconst TString& TROOT::GetMacroDir() {\n#ifdef ROOTMACRODIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootmacrodir;\n      if (rootmacrodir.IsNull()) {\n         rootmacrodir = \"macros\";\n         gSystem->PrependPathName(GetRootSys(), rootmacrodir);\n      }\n      return rootmacrodir;\n#ifdef ROOTMACRODIR\n   } else {\n      const static TString rootmacrodir = ROOTMACRODIR;\n      return rootmacrodir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the tutorials directory in the installation. Static utility function.\n\nconst TString& TROOT::GetTutorialDir() {\n#ifdef ROOTTUTDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString roottutdir;\n      if (roottutdir.IsNull()) {\n         roottutdir = \"tutorials\";\n         gSystem->PrependPathName(GetRootSys(), roottutdir);\n      }\n      return roottutdir;\n#ifdef ROOTTUTDIR\n   } else {\n      const static TString roottutdir = ROOTTUTDIR;\n      return roottutdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the source directory in the installation. Static utility function.\n\nconst TString& TROOT::GetSourceDir() {\n#ifdef ROOTSRCDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString rootsrcdir;\n      if (rootsrcdir.IsNull()) {\n         rootsrcdir = \"src\";\n         gSystem->PrependPathName(GetRootSys(), rootsrcdir);\n      }\n      return rootsrcdir;\n#ifdef ROOTSRCDIR\n   } else {\n      const static TString rootsrcdir = ROOTSRCDIR;\n      return rootsrcdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the icon path in the installation. Static utility function.\n\nconst TString& TROOT::GetIconPath() {\n#ifdef ROOTICONPATH\n   if (IgnorePrefix()) {\n#endif\n      static TString rooticonpath;\n      if (rooticonpath.IsNull()) {\n         rooticonpath = \"icons\";\n         gSystem->PrependPathName(GetRootSys(), rooticonpath);\n      }\n      return rooticonpath;\n#ifdef ROOTICONPATH\n   } else {\n      const static TString rooticonpath = ROOTICONPATH;\n      return rooticonpath;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the fonts directory in the installation. Static utility function.\n\nconst TString& TROOT::GetTTFFontDir() {\n#ifdef TTFFONTDIR\n   if (IgnorePrefix()) {\n#endif\n      static TString ttffontdir;\n      if (ttffontdir.IsNull()) {\n         ttffontdir = \"fonts\";\n         gSystem->PrependPathName(GetRootSys(), ttffontdir);\n      }\n      return ttffontdir;\n#ifdef TTFFONTDIR\n   } else {\n      const static TString ttffontdir = TTFFONTDIR;\n      return ttffontdir;\n   }\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the tutorials directory in the installation. Static utility function.\n/// Backward compatibility function - do not use for new code\n\nconst char *TROOT::GetTutorialsDir() {\n   return GetTutorialDir();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/metacling/src/TCling.cxx": "// @(#)root/meta:$Id$\n// vim: sw=3 ts=3 expandtab foldmethod=indent\n\n/*************************************************************************\n * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n/** \\class TCling\n\nThis class defines an interface to the cling C++ interpreter.\n\nCling is a full ANSI compliant C++-11 interpreter based on\nclang/LLVM technology.\n*/\n\n#include \"TCling.h\"\n\n#include \"TClingBaseClassInfo.h\"\n#include \"TClingCallFunc.h\"\n#include \"TClingClassInfo.h\"\n#include \"TClingDataMemberInfo.h\"\n#include \"TClingMethodArgInfo.h\"\n#include \"TClingMethodInfo.h\"\n#include \"TClingTypedefInfo.h\"\n#include \"TClingTypeInfo.h\"\n#include \"TClingValue.h\"\n\n#include \"TROOT.h\"\n#include \"TApplication.h\"\n#include \"TGlobal.h\"\n#include \"TDataType.h\"\n#include \"TClass.h\"\n#include \"TClassEdit.h\"\n#include \"TClassTable.h\"\n#include \"TClingCallbacks.h\"\n#include \"TBaseClass.h\"\n#include \"TDataMember.h\"\n#include \"TMemberInspector.h\"\n#include \"TMethod.h\"\n#include \"TMethodArg.h\"\n#include \"TFunctionTemplate.h\"\n#include \"TObjArray.h\"\n#include \"TObjString.h\"\n#include \"TString.h\"\n#include \"THashList.h\"\n#include \"TOrdCollection.h\"\n#include \"TVirtualPad.h\"\n#include \"TSystem.h\"\n#include \"TVirtualMutex.h\"\n#include \"TError.h\"\n#include \"TEnv.h\"\n#include \"TEnum.h\"\n#include \"TEnumConstant.h\"\n#include \"THashTable.h\"\n#include \"RConversionRuleParser.h\"\n#include \"RConfigure.h\"\n#include \"compiledata.h\"\n#include \"TClingUtils.h\"\n#include \"TVirtualCollectionProxy.h\"\n#include \"TVirtualStreamerInfo.h\"\n#include \"TListOfDataMembers.h\"\n#include \"TListOfEnums.h\"\n#include \"TListOfEnumsWithLock.h\"\n#include \"TListOfFunctions.h\"\n#include \"TListOfFunctionTemplates.h\"\n#include \"TProtoClass.h\"\n#include \"TStreamerInfo.h\" // This is here to avoid to use the plugin manager\n#include \"ThreadLocalStorage.h\"\n#include \"TFile.h\"\n#include \"TKey.h\"\n#include \"ClingRAII.h\"\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/CodeGen/ModuleBuilder.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendDiagnostic.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Parse/Parser.h\"\n\n#include \"cling/Interpreter/ClangInternalState.h\"\n#include \"cling/Interpreter/DynamicLibraryManager.h\"\n#include \"cling/Interpreter/Interpreter.h\"\n#include \"cling/Interpreter/LookupHelper.h\"\n#include \"cling/Interpreter/Value.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/MetaProcessor/MetaProcessor.h\"\n#include \"cling/Utils/AST.h\"\n#include \"cling/Utils/ParserStateRAII.h\"\n#include \"cling/Utils/SourceNormalization.h\"\n#include \"cling/Interpreter/Exception.h\"\n\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Module.h\"\n\n#include \"llvm/Support/DynamicLibrary.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <map>\n#include <set>\n#include <stdexcept>\n#include <stdint.h>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n#include <functional>\n\n#ifndef R__WIN32\n#include <cxxabi.h>\n#define R__DLLEXPORT __attribute__ ((visibility (\"default\")))\n#include <sys/stat.h>\n#endif\n#include <limits.h>\n#include <stdio.h>\n\n#ifdef __APPLE__\n#include <dlfcn.h>\n#include <mach-o/dyld.h>\n#include <mach-o/loader.h>\n#endif // __APPLE__\n\n#ifdef R__UNIX\n#include <dlfcn.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include <sys/cygwin.h>\n#define HMODULE void *\nextern \"C\" {\n   __declspec(dllimport) void * __stdcall GetCurrentProcess();\n   __declspec(dllimport) bool __stdcall EnumProcessModules(void *, void **, unsigned long, unsigned long *);\n   __declspec(dllimport) unsigned long __stdcall GetModuleFileNameExW(void *, void *, wchar_t *, unsigned long);\n}\n#endif\n\n// Fragment copied from LLVM's raw_ostream.cpp\n#if defined(_MSC_VER)\n#ifndef STDIN_FILENO\n# define STDIN_FILENO 0\n#endif\n#ifndef STDOUT_FILENO\n# define STDOUT_FILENO 1\n#endif\n#ifndef STDERR_FILENO\n# define STDERR_FILENO 2\n#endif\n#ifndef R__WIN32\n//#if defined(HAVE_UNISTD_H)\n# include <unistd.h>\n//#endif\n#else\n#include \"Windows4Root.h\"\n#include <Psapi.h>\n#undef GetModuleFileName\n#define RTLD_DEFAULT ((void *)::GetModuleHandle(NULL))\n#define dlsym(library, function_name) ::GetProcAddress((HMODULE)library, function_name)\n#define dlopen(library_name, flags) ::LoadLibraryA(library_name)\n#define dlclose(library) ::FreeLibrary((HMODULE)library)\n#define R__DLLEXPORT __declspec(dllexport)\n#endif\n#endif\n\n//______________________________________________________________________________\n// Infrastructure to detect and react to libCling being teared down.\n//\nnamespace {\n   class TCling_UnloadMarker {\n   public:\n      ~TCling_UnloadMarker() {\n         if (ROOT::Internal::gROOTLocal) {\n            ROOT::Internal::gROOTLocal->~TROOT();\n         }\n      }\n   };\n   static TCling_UnloadMarker gTClingUnloadMarker;\n}\n\n\n\n//______________________________________________________________________________\n// These functions are helpers for debugging issues with non-LLVMDEV builds.\n//\nR__DLLEXPORT clang::DeclContext* TCling__DEBUG__getDeclContext(clang::Decl* D) {\n   return D->getDeclContext();\n}\nR__DLLEXPORT clang::NamespaceDecl* TCling__DEBUG__DCtoNamespace(clang::DeclContext* DC) {\n   return llvm::dyn_cast<clang::NamespaceDecl>(DC);\n}\nR__DLLEXPORT clang::RecordDecl* TCling__DEBUG__DCtoRecordDecl(clang::DeclContext* DC) {\n   return llvm::dyn_cast<clang::RecordDecl>(DC);\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::DeclContext* DC) {\n   return DC->dumpDeclContext();\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::Decl* D) {\n   return D->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__dump(clang::FunctionDecl* FD) {\n   return FD->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__decl_dump(void* D) {\n   return ((clang::Decl*)D)->dump();\n}\nR__DLLEXPORT void TCling__DEBUG__printName(clang::Decl* D) {\n   if (clang::NamedDecl* ND = llvm::dyn_cast<clang::NamedDecl>(D)) {\n      std::string name;\n      {\n         llvm::raw_string_ostream OS(name);\n         ND->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),\n                                  true /*Qualified*/);\n      }\n      printf(\"%s\\n\", name.c_str());\n   }\n}\n//______________________________________________________________________________\n// These functions are helpers for testing issues directly rather than\n// relying on side effects.\n// This is used for the test for ROOT-7462/ROOT-6070\nR__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {\n   return D->isInvalidDecl();\n}\nR__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {\n   TClingClassInfo *info( (TClingClassInfo*) input);\n   assert(info && info->IsValid());\n   return info->GetDecl()->isInvalidDecl();\n}\n\nusing namespace std;\nusing namespace clang;\nusing namespace ROOT;\n\nnamespace {\n  static const std::string gInterpreterClassDef = R\"ICF(\n#undef ClassDef\n#define ClassDef(name, id) \\\n_ClassDefInterp_(name,id,virtual,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefNV\n#define ClassDefNV(name, id) \\\n_ClassDefInterp_(name,id,,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefOverride\n#define ClassDefOverride(name, id) \\\n_ClassDefInterp_(name,id,,override) \\\nstatic int DeclFileLine() { return __LINE__; }\n)ICF\";\n\n  static const std::string gNonInterpreterClassDef = R\"ICF(\n#define __ROOTCLING__ 1\n#undef ClassDef\n#define ClassDef(name,id) \\\n_ClassDefOutline_(name,id,virtual,) \\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefNV\n#define ClassDefNV(name, id)\\\n_ClassDefOutline_(name,id,,)\\\nstatic int DeclFileLine() { return __LINE__; }\n#undef ClassDefOverride\n#define ClassDefOverride(name, id)\\\n_ClassDefOutline_(name,id,,override)\\\nstatic int DeclFileLine() { return __LINE__; }\n)ICF\";\n\n// The macros below use ::Error, so let's ensure it is included\n  static const std::string gClassDefInterpMacro = R\"ICF(\n#include \"TError.h\"\n\n#define _ClassDefInterp_(name,id,virtual_keyword, overrd) \\\nprivate: \\\npublic: \\\n   static TClass *Class() { static TClass* sIsA = 0; if (!sIsA) sIsA = TClass::GetClass(#name); return sIsA; } \\\n   static const char *Class_Name() { return #name; } \\\n   virtual_keyword Bool_t CheckTObjectHashConsistency() const overrd { return true; } \\\n   static Version_t Class_Version() { return id; } \\\n   static TClass *Dictionary() { return 0; } \\\n   virtual_keyword TClass *IsA() const overrd { return name::Class(); } \\\n   virtual_keyword void ShowMembers(TMemberInspector&insp) const overrd { ::ROOT::Class_ShowMembers(name::Class(), this, insp); } \\\n   virtual_keyword void Streamer(TBuffer&) overrd { ::Error(\"Streamer\", \"Cannot stream interpreted class.\"); } \\\n   void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { name::Streamer(ClassDef_StreamerNVirtual_b); } \\\n   static const char *DeclFileName() { return __FILE__; } \\\n   static int ImplFileLine() { return 0; } \\\n   static const char *ImplFileName() { return __FILE__; }\n)ICF\";\n}\nR__EXTERN int optind;\n\n// The functions are used to bridge cling/clang/llvm compiled with no-rtti and\n// ROOT (which uses rtti)\n\n//______________________________________________________________________________\n\n// Class extracting recursively every Enum type defined for a class.\nclass EnumVisitor : public RecursiveASTVisitor<EnumVisitor> {\nprivate:\n   llvm::SmallVector<EnumDecl*,128> &fClassEnums;\npublic:\n   EnumVisitor(llvm::SmallVector<EnumDecl*,128> &enums) : fClassEnums(enums)\n   {}\n\n   bool TraverseStmt(Stmt*) {\n      // Don't descend into function bodies.\n      return true;\n   }\n\n   bool shouldVisitTemplateInstantiations() const { return true; }\n\n   bool TraverseClassTemplateDecl(ClassTemplateDecl*) {\n      // Don't descend into templates (but only instances thereof).\n      return true; // returning false will abort the in-depth traversal.\n   }\n\n   bool TraverseClassTemplatePartialSpecializationDecl(ClassTemplatePartialSpecializationDecl*) {\n      // Don't descend into templates partial specialization (but only instances thereof).\n      return true; // returning false will abort the in-depth traversal.\n   }\n\n   bool VisitEnumDecl(EnumDecl *TEnumD) {\n      if (!TEnumD->getDeclContext()->isDependentContext())\n         fClassEnums.push_back(TEnumD);\n      return true; // returning false will abort the in-depth traversal.\n   }\n};\n\n////////////////////////////////////////////////////////////////////////////////\n/// Print a StackTrace!\n\nextern \"C\"\nvoid TCling__PrintStackTrace() {\n   gSystem->StackTrace();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.\n\nextern \"C\" void TCling__RestoreInterpreterMutex(void *delta)\n{\n   ((TCling*)gCling)->ApplyToInterpreterMutex(delta);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name,\n/// which is extracted by error messages we get from callback from cling. Return true\n/// when the missing library was autoloaded.\n\nextern \"C\" bool TCling__LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved)\n{\n   return ((TCling*)gCling)->LibraryLoadingFailed(errmessage, libStem, permanent, resolved);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter lock to the state it had before interpreter-related\n/// calls happened.\n\nextern \"C\" void *TCling__ResetInterpreterMutex()\n{\n   return ((TCling*)gCling)->RewindInterpreterMutex();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Lock the interpreter.\n\nextern \"C\" void *TCling__LockCompilationDuringUserCodeExecution()\n{\n   if (gInterpreterMutex) {\n      gInterpreterMutex->Lock();\n   }\n   return nullptr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unlock the interpreter.\n\nextern \"C\" void TCling__UnlockCompilationDuringUserCodeExecution(void* /*state*/)\n{\n   if (gInterpreterMutex) {\n      gInterpreterMutex->UnLock();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update TClingClassInfo for a class (e.g. upon seeing a definition).\n\nstatic void TCling__UpdateClassInfo(const NamedDecl* TD)\n{\n   static Bool_t entered = kFALSE;\n   static vector<const NamedDecl*> updateList;\n   Bool_t topLevel;\n\n   if (entered) topLevel = kFALSE;\n   else {\n      entered = kTRUE;\n      topLevel = kTRUE;\n   }\n   if (topLevel) {\n      ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(TD);\n   } else {\n      // If we are called indirectly from within another call to\n      // TCling::UpdateClassInfo, we delay the update until the dictionary loading\n      // is finished (i.e. when we return to the top level TCling::UpdateClassInfo).\n      // This allows for the dictionary to be fully populated when we actually\n      // update the TClass object.   The updating of the TClass sometimes\n      // (STL containers and when there is an emulated class) forces the building\n      // of the TClass object's real data (which needs the dictionary info).\n      updateList.push_back(TD);\n   }\n   if (topLevel) {\n      while (!updateList.empty()) {\n         ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(updateList.back());\n         updateList.pop_back();\n      }\n      entered = kFALSE;\n   }\n}\n\nvoid TCling::UpdateEnumConstants(TEnum* enumObj, TClass* cl) const {\n   const clang::Decl* D = static_cast<const clang::Decl*>(enumObj->GetDeclId());\n   if(const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(D)) {\n      // Add the constants to the enum type.\n      for (EnumDecl::enumerator_iterator EDI = ED->enumerator_begin(),\n                EDE = ED->enumerator_end(); EDI != EDE; ++EDI) {\n         // Get name of the enum type.\n         std::string constbuf;\n         if (const NamedDecl* END = llvm::dyn_cast<NamedDecl>(*EDI)) {\n            PrintingPolicy Policy((*EDI)->getASTContext().getPrintingPolicy());\n            llvm::raw_string_ostream stream(constbuf);\n            // Don't trigger fopen of the source file to count lines:\n            Policy.AnonymousTagLocations = false;\n            (END)->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n         }\n         const char* constantName = constbuf.c_str();\n\n         // Get value of the constant.\n         Long64_t value;\n         const llvm::APSInt valAPSInt = (*EDI)->getInitVal();\n         if (valAPSInt.isSigned()) {\n            value = valAPSInt.getSExtValue();\n         } else {\n            value = valAPSInt.getZExtValue();\n         }\n\n         // Create the TEnumConstant or update it if existing\n         TEnumConstant* enumConstant = nullptr;\n         TClingClassInfo* tcCInfo = (TClingClassInfo*)(cl ? cl->GetClassInfo() : 0);\n         TClingDataMemberInfo* tcDmInfo = new TClingDataMemberInfo(fInterpreter, *EDI, tcCInfo);\n         DataMemberInfo_t* dmInfo = (DataMemberInfo_t*) tcDmInfo;\n         if (TObject* encAsTObj = enumObj->GetConstants()->FindObject(constantName)){\n            ((TEnumConstant*)encAsTObj)->Update(dmInfo);\n         } else {\n            enumConstant = new TEnumConstant(dmInfo, constantName, value, enumObj);\n         }\n\n         // Add the global constants to the list of Globals.\n         if (!cl) {\n            TCollection* globals = gROOT->GetListOfGlobals(false);\n            if (!globals->FindObject(constantName)) {\n               globals->Add(enumConstant);\n            }\n         }\n      }\n   }\n}\n\nTEnum* TCling::CreateEnum(void *VD, TClass *cl) const\n{\n   // Handle new enum declaration for either global and nested enums.\n\n   // Create the enum type.\n   TEnum* enumType = 0;\n   const clang::Decl* D = static_cast<const clang::Decl*>(VD);\n   std::string buf;\n   if (const EnumDecl* ED = llvm::dyn_cast<EnumDecl>(D)) {\n      // Get name of the enum type.\n      PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());\n      llvm::raw_string_ostream stream(buf);\n      // Don't trigger fopen of the source file to count lines:\n      Policy.AnonymousTagLocations = false;\n      ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n      // If the enum is unnamed we do not add it to the list of enums i.e unusable.\n   }\n   if (buf.empty()) {\n      return 0;\n   }\n   const char* name = buf.c_str();\n   enumType = new TEnum(name, VD, cl);\n   UpdateEnumConstants(enumType, cl);\n\n   return enumType;\n}\n\nvoid TCling::HandleNewDecl(const void* DV, bool isDeserialized, std::set<TClass*> &modifiedTClasses) {\n   // Handle new declaration.\n   // Record the modified class, struct and namespaces in 'modifiedTClasses'.\n\n   const clang::Decl* D = static_cast<const clang::Decl*>(DV);\n\n   if (!D->isCanonicalDecl() && !isa<clang::NamespaceDecl>(D)\n       && !dyn_cast<clang::RecordDecl>(D)) return;\n\n   if (isa<clang::FunctionDecl>(D->getDeclContext())\n       || isa<clang::TagDecl>(D->getDeclContext()))\n      return;\n\n   // Don't list templates.\n   if (const clang::CXXRecordDecl* RD = dyn_cast<clang::CXXRecordDecl>(D)) {\n      if (RD->getDescribedClassTemplate())\n         return;\n   } else if (const clang::FunctionDecl* FD = dyn_cast<clang::FunctionDecl>(D)) {\n      if (FD->getDescribedFunctionTemplate())\n         return;\n   }\n\n   if (const RecordDecl *TD = dyn_cast<RecordDecl>(D)) {\n      if (TD->isCanonicalDecl() || TD->isThisDeclarationADefinition())\n         TCling__UpdateClassInfo(TD);\n   }\n   else if (const NamedDecl *ND = dyn_cast<NamedDecl>(D)) {\n\n      if (const TagDecl *TD = dyn_cast<TagDecl>(D)) {\n         // Mostly just for EnumDecl (the other TagDecl are handled\n         // by the 'RecordDecl' if statement.\n         TCling__UpdateClassInfo(TD);\n      } else if (const NamespaceDecl* NSD = dyn_cast<NamespaceDecl>(D)) {\n         TCling__UpdateClassInfo(NSD);\n      }\n\n      // We care about declarations on the global scope.\n      if (!isa<TranslationUnitDecl>(ND->getDeclContext()))\n         return;\n\n      // Enums are lazyly created, thus we don not need to handle them here.\n      if (isa<EnumDecl>(ND))\n         return;\n\n      // ROOT says that global is enum(lazylycreated)/var/field declared on the global\n      // scope.\n      if (!(isa<VarDecl>(ND)))\n         return;\n\n      // Skip if already in the list.\n      if (gROOT->GetListOfGlobals()->FindObject(ND->getNameAsString().c_str()))\n         return;\n\n      // Put the global constants and global enums in the corresponding lists.\n      gROOT->GetListOfGlobals()->Add(new TGlobal((DataMemberInfo_t *)\n                                                new TClingDataMemberInfo(fInterpreter,\n                                                                        cast<ValueDecl>(ND), 0)));\n   }\n}\n\nextern \"C\"\nvoid TCling__GetNormalizedContext(const ROOT::TMetaUtils::TNormalizedCtxt*& normCtxt)\n{\n   // We are sure in this context of the type of the interpreter\n   normCtxt = &( (TCling*) gInterpreter)->GetNormalizedContext();\n}\n\nextern \"C\"\nvoid TCling__UpdateListsOnCommitted(const cling::Transaction &T, cling::Interpreter*) {\n\n   ((TCling*)gCling)->UpdateListsOnCommitted(T);\n}\n\nextern \"C\"\nvoid TCling__UpdateListsOnUnloaded(const cling::Transaction &T) {\n\n   ((TCling*)gCling)->UpdateListsOnUnloaded(T);\n}\n\nextern \"C\"\nvoid TCling__TransactionRollback(const cling::Transaction &T) {\n\n   ((TCling*)gCling)->TransactionRollback(T);\n}\n\nextern \"C\" void TCling__LibraryLoadedRTTI(const void* dyLibHandle,\n                                          const char* canonicalName) {\n\n   ((TCling*)gCling)->LibraryLoaded(dyLibHandle, canonicalName);\n}\n\nextern \"C\" void TCling__LibraryUnloadedRTTI(const void* dyLibHandle,\n                                            const char* canonicalName) {\n\n   ((TCling*)gCling)->LibraryUnloaded(dyLibHandle, canonicalName);\n}\n\n\nextern \"C\"\nTObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx) {\n   return ((TCling*)gCling)->GetObjectAddress(Name, LookupCtx);\n}\n\nextern \"C\" const Decl* TCling__GetObjectDecl(TObject *obj) {\n   return ((TClingClassInfo*)obj->IsA()->GetClassInfo())->GetDecl();\n}\n\nextern \"C\" R__DLLEXPORT TInterpreter *CreateInterpreter(void* interpLibHandle,\n                                                        const char* argv[])\n{\n   cling::DynamicLibraryManager::ExposeHiddenSharedLibrarySymbols(interpLibHandle);\n   return new TCling(\"C++\", \"cling C++ Interpreter\", argv);\n}\n\nextern \"C\" R__DLLEXPORT void DestroyInterpreter(TInterpreter *interp)\n{\n   delete interp;\n}\n\n// Load library containing specified class. Returns 0 in case of error\n// and 1 in case if success.\nextern \"C\" int TCling__AutoLoadCallback(const char* className)\n{\n   return ((TCling*)gCling)->AutoLoad(className);\n}\n\nextern \"C\" int TCling__AutoParseCallback(const char* className)\n{\n   return ((TCling*)gCling)->AutoParse(className);\n}\n\nextern \"C\" const char* TCling__GetClassSharedLibs(const char* className)\n{\n   return ((TCling*)gCling)->GetClassSharedLibs(className);\n}\n\n// // Returns 0 for failure 1 for success\n// extern \"C\" int TCling__IsAutoLoadNamespaceCandidate(const char* name)\n// {\n//    return ((TCling*)gCling)->IsAutoLoadNamespaceCandidate(name);\n// }\n\n// Returns 0 for failure 1 for success\nextern \"C\" int TCling__IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl)\n{\n   return ((TCling*)gCling)->IsAutoLoadNamespaceCandidate(nsDecl);\n}\n\nextern \"C\" int TCling__CompileMacro(const char *fileName, const char *options)\n{\n   string file(fileName);\n   string opt(options);\n   return gSystem->CompileMacro(file.c_str(), opt.c_str());\n}\n\nextern \"C\" void TCling__SplitAclicMode(const char* fileName, string &mode,\n                                       string &args, string &io, string &fname)\n{\n   string file(fileName);\n   TString f, amode, arguments, aclicio;\n   f = gSystem->SplitAclicMode(file.c_str(), amode, arguments, aclicio);\n   mode = amode.Data(); args = arguments.Data();\n   io = aclicio.Data(); fname = f.Data();\n}\n\n// Implemented in TClingCallbacks.\nextern \"C\" void TCling__FindLoadedLibraries(std::vector<std::pair<uint32_t, std::string>> &sLibraries,\n                                 std::vector<StringRef> &sPaths,\n                                 cling::Interpreter &interpreter);\n\n//______________________________________________________________________________\n//\n//\n//\n\n#ifdef R__WIN32\nextern \"C\" {\n   char *__unDName(char *demangled, const char *mangled, int out_len,\n                   void * (* pAlloc )(size_t), void (* pFree )(void *),\n                   unsigned short int flags);\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Find a template decl within N nested namespaces, 0<=N<inf\n/// Assumes 1 and only 1 template present and 1 and only 1 entity contained\n/// by the namespace. Example: ns1::ns2::..::nsN::myTemplate\n/// Returns nullptr in case of error\n\nstatic clang::ClassTemplateDecl* FindTemplateInNamespace(clang::Decl* decl)\n{\n   using namespace clang;\n   if (NamespaceDecl* nsd = llvm::dyn_cast<NamespaceDecl>(decl)){\n      return FindTemplateInNamespace(*nsd->decls_begin());\n   }\n\n   if (ClassTemplateDecl* ctd = llvm::dyn_cast<ClassTemplateDecl>(decl)){\n      return ctd;\n   }\n\n   return nullptr; // something went wrong.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Autoload a library provided the mangled name of a missing symbol.\n\nvoid* llvmLazyFunctionCreator(const std::string& mangled_name)\n{\n   return ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\nint TCling_GenerateDictionary(const std::vector<std::string> &classes,\n                              const std::vector<std::string> &headers,\n                              const std::vector<std::string> &fwdDecls,\n                              const std::vector<std::string> &unknown)\n{\n   //This function automatically creates the \"LinkDef.h\" file for templated\n   //classes then executes CompileMacro on it.\n   //The name of the file depends on the class name, and it's not generated again\n   //if the file exist.\n   if (classes.empty()) {\n      return 0;\n   }\n   // Use the name of the first class as the main name.\n   const std::string& className = classes[0];\n   //(0) prepare file name\n   TString fileName = \"AutoDict_\";\n   std::string::const_iterator sIt;\n   for (sIt = className.begin(); sIt != className.end(); ++sIt) {\n      if (*sIt == '<' || *sIt == '>' ||\n            *sIt == ' ' || *sIt == '*' ||\n            *sIt == ',' || *sIt == '&' ||\n            *sIt == ':') {\n         fileName += '_';\n      }\n      else {\n         fileName += *sIt;\n      }\n   }\n   if (classes.size() > 1) {\n      Int_t chk = 0;\n      std::vector<std::string>::const_iterator it = classes.begin();\n      while ((++it) != classes.end()) {\n         for (UInt_t cursor = 0; cursor != it->length(); ++cursor) {\n            chk = chk * 3 + it->at(cursor);\n         }\n      }\n      fileName += TString::Format(\"_%u\", chk);\n   }\n   fileName += \".cxx\";\n   if (gSystem->AccessPathName(fileName) != 0) {\n      //file does not exist\n      //(1) prepare file data\n      // If STL, also request iterators' operators.\n      // vector is special: we need to check whether\n      // vector::iterator is a typedef to pointer or a\n      // class.\n      static const std::set<std::string> sSTLTypes {\n         \"vector\",\"list\",\"forward_list\",\"deque\",\"map\",\"unordered_map\",\"multimap\",\n         \"unordered_multimap\",\"set\",\"unordered_set\",\"multiset\",\"unordered_multiset\",\n         \"queue\",\"priority_queue\",\"stack\",\"iterator\"};\n      std::vector<std::string>::const_iterator it;\n      std::string fileContent(\"\");\n      for (it = headers.begin(); it != headers.end(); ++it) {\n         fileContent += \"#include \\\"\" + *it + \"\\\"\\n\";\n      }\n      for (it = unknown.begin(); it != unknown.end(); ++it) {\n         TClass* cl = TClass::GetClass(it->c_str());\n         if (cl && cl->GetDeclFileName()) {\n            TString header(gSystem->BaseName(cl->GetDeclFileName()));\n            TString dir(gSystem->DirName(cl->GetDeclFileName()));\n            TString dirbase(gSystem->BaseName(dir));\n            while (dirbase.Length() && dirbase != \".\"\n                   && dirbase != \"include\" && dirbase != \"inc\"\n                   && dirbase != \"prec_stl\") {\n               gSystem->PrependPathName(dirbase, header);\n               dir = gSystem->DirName(dir);\n            }\n            fileContent += TString(\"#include \\\"\") + header + \"\\\"\\n\";\n         }\n      }\n      for (it = fwdDecls.begin(); it != fwdDecls.end(); ++it) {\n         fileContent += \"class \" + *it + \";\\n\";\n      }\n      fileContent += \"#ifdef __CINT__ \\n\";\n      fileContent += \"#pragma link C++ nestedclasses;\\n\";\n      fileContent += \"#pragma link C++ nestedtypedefs;\\n\";\n      for (it = classes.begin(); it != classes.end(); ++it) {\n         std::string n(*it);\n         size_t posTemplate = n.find('<');\n         std::set<std::string>::const_iterator iSTLType = sSTLTypes.end();\n         if (posTemplate != std::string::npos) {\n            n.erase(posTemplate, std::string::npos);\n            if (n.compare(0, 5, \"std::\") == 0) {\n               n.erase(0, 5);\n            }\n            iSTLType = sSTLTypes.find(n);\n         }\n         fileContent += \"#pragma link C++ class \";\n         fileContent +=    *it + \"+;\\n\" ;\n         fileContent += \"#pragma link C++ class \";\n         if (iSTLType != sSTLTypes.end()) {\n            // STL class; we cannot (and don't need to) store iterators;\n            // their shadow and the compiler's version don't agree. So\n            // don't ask for the '+'\n            fileContent +=    *it + \"::*;\\n\" ;\n         }\n         else {\n            // Not an STL class; we need to allow the I/O of contained\n            // classes (now that we have a dictionary for them).\n            fileContent +=    *it + \"::*+;\\n\" ;\n         }\n         std::string oprLink(\"#pragma link C++ operators \");\n         oprLink += *it;\n         // Don't! Requests e.g. op<(const vector<T>&, const vector<T>&):\n         // fileContent += oprLink + \";\\n\";\n         if (iSTLType != sSTLTypes.end()) {\n            if (n == \"vector\") {\n               fileContent += \"#ifdef G__VECTOR_HAS_CLASS_ITERATOR\\n\";\n            }\n            fileContent += oprLink + \"::iterator;\\n\";\n            fileContent += oprLink + \"::const_iterator;\\n\";\n            fileContent += oprLink + \"::reverse_iterator;\\n\";\n            if (n == \"vector\") {\n               fileContent += \"#endif\\n\";\n            }\n         }\n      }\n      fileContent += \"#endif\\n\";\n      //end(1)\n      //(2) prepare the file\n      FILE* filePointer;\n      filePointer = fopen(fileName, \"w\");\n      if (filePointer == NULL) {\n         //can't open a file\n         return 1;\n      }\n      //end(2)\n      //write data into the file\n      fprintf(filePointer, \"%s\", fileContent.c_str());\n      fclose(filePointer);\n   }\n   //(3) checking if we can compile a macro, if not then cleaning\n   Int_t oldErrorIgnoreLevel = gErrorIgnoreLevel;\n   gErrorIgnoreLevel = kWarning; // no \"Info: creating library...\"\n   Int_t ret = gSystem->CompileMacro(fileName, \"k\");\n   gErrorIgnoreLevel = oldErrorIgnoreLevel;\n   if (ret == 0) { //can't compile a macro\n      return 2;\n   }\n   //end(3)\n   return 0;\n}\n\nint TCling_GenerateDictionary(const std::string& className,\n                              const std::vector<std::string> &headers,\n                              const std::vector<std::string> &fwdDecls,\n                              const std::vector<std::string> &unknown)\n{\n   //This function automatically creates the \"LinkDef.h\" file for templated\n   //classes then executes CompileMacro on it.\n   //The name of the file depends on the class name, and it's not generated again\n   //if the file exist.\n   std::vector<std::string> classes;\n   classes.push_back(className);\n   return TCling_GenerateDictionary(classes, headers, fwdDecls, unknown);\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\n// It is a \"fantom\" method to synchronize user keyboard input\n// and ROOT prompt line (for WIN32)\nconst char* fantomline = \"TRint::EndOfLineAction();\";\n\n//______________________________________________________________________________\n//\n//\n//\n\nvoid* TCling::fgSetOfSpecials = 0;\n\n//______________________________________________________________________________\n//\n// llvm error handler through exceptions; see also cling/UserInterface\n//\nnamespace {\n   // Handle fatal llvm errors by throwing an exception.\n   // Yes, throwing exceptions in error handlers is bad.\n   // Doing nothing is pretty terrible, too.\n   void exceptionErrorHandler(void * /*user_data*/,\n                              const std::string& reason,\n                              bool /*gen_crash_diag*/) {\n      throw std::runtime_error(std::string(\">>> Interpreter compilation error:\\n\") + reason);\n   }\n}\n\n//______________________________________________________________________________\n//\n//\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nnamespace{\n   // An instance of this class causes the diagnostics of clang to be suppressed\n   // during its lifetime\n   class clangDiagSuppr {\n   public:\n      clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){\n         fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();\n         fDiagEngine.setIgnoreAllWarnings(true);\n      }\n\n      ~clangDiagSuppr() {\n         fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);\n      }\n   private:\n      clang::DiagnosticsEngine& fDiagEngine;\n      bool fOldDiagValue;\n   };\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Allow calling autoparsing from TMetaUtils\nbool TClingLookupHelper__AutoParse(const char *cname)\n{\n   return gCling->AutoParse(cname);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Try hard to avoid looking up in the Cling database as this could enduce\n/// an unwanted autoparsing.\n\nbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,\n                                           std::string &result)\n{\n   result.clear();\n\n   unsigned long offset = 0;\n   if (strncmp(tname.c_str(), \"const \", 6) == 0) {\n      offset = 6;\n   }\n   unsigned long end = tname.length();\n   while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {\n      if ( tname[end-1]==']' ) {\n         --end;\n         while ( end && tname[end-1]!='[' ) --end;\n      }\n      --end;\n   }\n   std::string innerbuf;\n   const char *inner;\n   if (end != tname.length()) {\n      innerbuf = tname.substr(offset,end-offset);\n      inner = innerbuf.c_str();\n   } else {\n      inner = tname.c_str()+offset;\n   }\n\n   //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,\"DEBUG: checking on %s vs %s %lu %lu\\n\",tname.c_str(),inner,offset,end);\n   if (gROOT->GetListOfClasses()->FindObject(inner)\n       || TClassTable::Check(inner,result) ) {\n      // This is a known class.\n      return true;\n   }\n\n   THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );\n   TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );\n   if (type) {\n      // This is a raw type and an already loaded typedef.\n      const char *newname = type->GetFullTypeName();\n      if (type->GetType() == kLong64_t) {\n         newname = \"Long64_t\";\n      } else if (type->GetType() == kULong64_t) {\n         newname = \"ULong64_t\";\n      }\n      if (strcmp(inner,newname) == 0) {\n         return true;\n      }\n      if (offset) result = \"const \";\n      result += newname;\n      if ( end != tname.length() ) {\n         result += tname.substr(end,tname.length()-end);\n      }\n      if (result == tname) result.clear();\n      return true;\n   }\n\n   // Check if the name is an enumerator\n   const auto lastPos = TClassEdit::GetUnqualifiedName(inner);\n   if (lastPos != inner)   // Main switch: case 1 - scoped enum, case 2 global enum\n   {\n      // We have a scope\n      // All of this C gymnastic is to avoid allocations on the heap\n      const auto enName = lastPos;\n      const auto scopeNameSize = ((Long64_t)lastPos - (Long64_t)inner) / sizeof(decltype(*lastPos)) - 2;\n      char *scopeName = new char[scopeNameSize + 1];\n      strncpy(scopeName, inner, scopeNameSize);\n      scopeName[scopeNameSize] = '\\0';\n      // Check if the scope is in the list of classes\n      if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName))) {\n         auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));\n         if (enumTable && enumTable->THashList::FindObject(enName)) return true;\n      }\n      // It may still be in one of the loaded protoclasses\n      else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName))) {\n         auto listOfEnums = scope->GetListOfEnums();\n         if (listOfEnums) { // it could be null: no enumerators in the protoclass\n            auto enumTable = dynamic_cast<const THashList *>(listOfEnums);\n            if (enumTable && enumTable->THashList::FindObject(enName)) return true;\n         }\n      }\n      delete [] scopeName;\n   } else\n   {\n      // We don't have any scope: this could only be a global enum\n      auto enumTable = dynamic_cast<const THashList *>(gROOT->GetListOfEnums());\n      if (enumTable && enumTable->THashList::FindObject(inner)) return true;\n   }\n\n   if (gCling->GetClassSharedLibs(inner))\n   {\n      // This is a class name.\n      return true;\n   }\n\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTCling::TUniqueString::TUniqueString(Long64_t size)\n{\n   fContent.reserve(size);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ninline const char *TCling::TUniqueString::Data()\n{\n   return fContent.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Append string to the storage if not added already.\n\ninline bool TCling::TUniqueString::Append(const std::string& str)\n{\n   bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;\n   if (notPresent){\n      fContent+=str;\n   }\n   return notPresent;\n}\n\nstd::string TCling::ToString(const char* type, void* obj)\n{\n   return fInterpreter->toString(type, obj);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n///\\returns true if the module was loaded.\nstatic bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp, bool Complain = true)\n{\n   clang::CompilerInstance &CI = *interp.getCI();\n\n   assert(CI.getLangOpts().Modules && \"Function only relevant when C++ modules are turned on!\");\n\n   clang::Preprocessor &PP = CI.getPreprocessor();\n   clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();\n\n   cling::Interpreter::PushTransactionRAII RAII(&interp);\n   if (clang::Module *M = headerSearch.lookupModule(ModuleName, true /*AllowSearch*/, true /*AllowExtraSearch*/)) {\n      clang::IdentifierInfo *II = PP.getIdentifierInfo(M->Name);\n      SourceLocation ValidLoc = M->DefinitionLoc;\n      bool success = !CI.getSema().ActOnModuleImport(ValidLoc, ValidLoc, std::make_pair(II, ValidLoc)).isInvalid();\n      if (success) {\n         // Also make the module visible in the preprocessor to export its macros.\n         PP.makeModuleVisible(M, ValidLoc);\n         return success;\n      }\n      if (Complain) {\n         if (M->IsSystem)\n            Error(\"TCling::LoadModule\", \"Module %s failed to load\", M->Name.c_str());\n         else\n            Info(\"TCling::LoadModule\", \"Module %s failed to load\", M->Name.c_str());\n      }\n   }\n\n   // Load modulemap if we have one in current directory\n   SourceManager& SM = PP.getSourceManager();\n   FileManager& FM = SM.getFileManager();\n   const clang::DirectoryEntry *DE = FM.getDirectory(\".\");\n   if (DE) {\n      const clang::FileEntry *FE = headerSearch.lookupModuleMapFile(DE, /*IsFramework*/ false);\n      // Check if \"./module.modulemap is already loaded or not\n      if (!gCling->IsLoaded(\"./module.modulemap\") && FE) {\n         if(!headerSearch.loadModuleMapFile(FE, /*IsSystem*/ false))\n            return LoadModule(ModuleName, interp, Complain);\n         Error(\"TCling::LoadModule\", \"Could not load modulemap in the current directory\");\n      }\n   }\n\n   if (Complain)\n      Error(\"TCling::LoadModule\", \"Module %s not found!\", ModuleName.c_str());\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Loads the C++ modules that we require to run any ROOT program. This is just\n/// supposed to make a C++ module from a modulemap available to the interpreter.\nstatic void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp)\n{\n   for (const auto &modName : modules)\n      LoadModule(modName, interp);\n}\n\nstatic bool FileExists(const char *file)\n{\n   struct stat buf;\n   return (stat(file, &buf) == 0);\n}\n\nstatic bool IsFromRootCling() {\n  // rootcling also uses TCling for generating the dictionary ROOT files.\n  const static bool foundSymbol = dlsym(RTLD_DEFAULT, \"usedToIdentifyRootClingByDlSym\");\n  return foundSymbol;\n}\n\nstatic std::string GetModuleNameAsString(clang::Module *M, const clang::Preprocessor &PP)\n{\n   const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();\n\n   std::string ModuleFileName;\n   if (!HSOpts.PrebuiltModulePaths.empty())\n      // Load the module from the prebuilt module path.\n      ModuleFileName = PP.getHeaderSearchInfo().getModuleFileName(M->Name, \"\", /*UsePrebuiltPath*/ true);\n   if (ModuleFileName.empty()) return \"\";\n\n   std::string ModuleName = llvm::sys::path::filename(ModuleFileName);\n   // Return stem of the filename\n   return std::string(llvm::sys::path::stem(ModuleName));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the cling interpreter interface.\n/// \\param argv - array of arguments passed to the cling::Interpreter constructor\n///               e.g. `-DFOO=bar`. The last element of the array must be `nullptr`.\n\nTCling::TCling(const char *name, const char *title, const char* const argv[])\n: TInterpreter(name, title), fGlobalsListSerial(-1), fInterpreter(0),\n   fMetaProcessor(0), fNormalizedCtxt(0), fPrevLoadedDynLibInfo(0),\n   fClingCallbacks(0), fAutoLoadCallBack(0),\n   fTransactionCount(0), fHeaderParsingOnDemand(true), fIsAutoParsingSuspended(kFALSE)\n{\n   const bool fromRootCling = IsFromRootCling();\n\n   fCxxModulesEnabled = false;\n#ifdef R__USE_CXXMODULES\n   fCxxModulesEnabled = true;\n#endif\n\n   llvm::install_fatal_error_handler(&exceptionErrorHandler);\n\n   fTemporaries = new std::vector<cling::Value>();\n\n   std::vector<std::string> clingArgsStorage;\n   clingArgsStorage.push_back(\"cling4root\");\n   for (const char* const* arg = argv; *arg; ++arg)\n      clingArgsStorage.push_back(*arg);\n\n   // rootcling sets its arguments through TROOT::GetExtraInterpreterArgs().\n   if (!fromRootCling) {\n      ROOT::TMetaUtils::SetPathsForRelocatability(clingArgsStorage);\n\n      // Add -I early so ASTReader can find the headers.\n      std::string interpInclude(TROOT::GetEtcDir().Data());\n      clingArgsStorage.push_back(\"-I\" + interpInclude);\n\n      // Add include path to etc/cling.\n      clingArgsStorage.push_back(\"-I\" + interpInclude + \"/cling\");\n\n      // Add the root include directory and etc/ to list searched by default.\n      clingArgsStorage.push_back(std::string((\"-I\" + TROOT::GetIncludeDir()).Data()));\n\n      // Add the current path to the include path\n      // TCling::AddIncludePath(\".\");\n\n      // Attach the PCH (unless we have C++ modules enabled which provide the\n      // same functionality).\n      if (!fCxxModulesEnabled) {\n         std::string pchFilename = interpInclude + \"/allDict.cxx.pch\";\n         if (gSystem->Getenv(\"ROOT_PCH\")) {\n            pchFilename = gSystem->Getenv(\"ROOT_PCH\");\n         }\n\n         clingArgsStorage.push_back(\"-include-pch\");\n         clingArgsStorage.push_back(pchFilename);\n      }\n\n      clingArgsStorage.push_back(\"-Wno-undefined-inline\");\n      clingArgsStorage.push_back(\"-fsigned-char\");\n   }\n\n   // Process externally passed arguments if present.\n   llvm::Optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(\"EXTRA_CLING_ARGS\");\n   if (EnvOpt.hasValue()) {\n      StringRef Env(*EnvOpt);\n      while (!Env.empty()) {\n         StringRef Arg;\n         std::tie(Arg, Env) = Env.split(' ');\n         clingArgsStorage.push_back(Arg.str());\n      }\n   }\n\n   // FIXME: This only will enable frontend timing reports.\n   EnvOpt = llvm::sys::Process::GetEnv(\"ROOT_CLING_TIMING\");\n   if (EnvOpt.hasValue())\n     clingArgsStorage.push_back(\"-ftime-report\");\n\n   std::vector<const char*> interpArgs;\n   for (std::vector<std::string>::const_iterator iArg = clingArgsStorage.begin(),\n           eArg = clingArgsStorage.end(); iArg != eArg; ++iArg)\n      interpArgs.push_back(iArg->c_str());\n\n   // Activate C++ modules support. If we are running within rootcling, it's up\n   // to rootcling to set this flag depending on whether it wants to produce\n   // C++ modules.\n   TString vfsArg;\n   if (fCxxModulesEnabled && !fromRootCling) {\n      // We only set this flag, rest is done by the CIFactory.\n      interpArgs.push_back(\"-fmodules\");\n      // We should never build modules during runtime, so let's enable the\n      // module build remarks from clang to make it easier to spot when we do\n      // this by accident.\n      interpArgs.push_back(\"-Rmodule-build\");\n\n      TString vfsPath = TROOT::GetIncludeDir() + \"/modulemap.overlay.yaml\";\n      // On modules aware build systems (such as OSX) we do not need an overlay file and thus the build system does not\n      // generate it.\n      if (FileExists(vfsPath.Data())) {\n         vfsArg = \"-ivfsoverlay\" + vfsPath;\n         interpArgs.push_back(vfsArg.Data());\n      }\n   }\n\n#ifdef R__FAST_MATH\n   // Same setting as in rootcling_impl.cxx.\n   interpArgs.push_back(\"-ffast-math\");\n#endif\n\n#ifdef R__EXTERN_LLVMDIR\n   TString llvmResourceDir = R__EXTERN_LLVMDIR;\n#else\n   TString llvmResourceDir = TROOT::GetEtcDir() + \"/cling\";\n#endif\n   // Add statically injected extra arguments, usually coming from rootcling.\n   for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();\n        extraArgs && *extraArgs; ++extraArgs) {\n      if (!strcmp(*extraArgs, \"-resource-dir\")) {\n         // Take the next arg as the llvm resource directory.\n         llvmResourceDir = *(++extraArgs);\n      } else {\n         interpArgs.push_back(*extraArgs);\n      }\n   }\n\n   fInterpreter = new cling::Interpreter(interpArgs.size(),\n                                         &(interpArgs[0]),\n                                         llvmResourceDir);\n\n   if (!fromRootCling) {\n      fInterpreter->installLazyFunctionCreator(llvmLazyFunctionCreator);\n   }\n\n   // Don't check whether modules' files exist.\n   fInterpreter->getCI()->getPreprocessorOpts().DisablePCHValidation = true;\n\n   // Until we can disable autoloading during Sema::CorrectTypo() we have\n   // to disable spell checking.\n   fInterpreter->getCI()->getLangOpts().SpellChecking = false;\n\n\n   // We need stream that doesn't close its file descriptor, thus we are not\n   // using llvm::outs. Keeping file descriptor open we will be able to use\n   // the results in pipes (Savannah #99234).\n   static llvm::raw_fd_ostream fMPOuts (STDOUT_FILENO, /*ShouldClose*/false);\n   fMetaProcessor = new cling::MetaProcessor(*fInterpreter, fMPOuts);\n\n   if (fInterpreter->getCI()->getLangOpts().Modules) {\n      // Setup core C++ modules if we have any to setup.\n\n      // Load libc and stl first.\n      LoadModules({\"libc\", \"stl\"}, *fInterpreter);\n\n      // Load core modules\n      // This should be vector in order to be able to pass it to LoadModules\n      std::vector<std::string> CoreModules = {\"ROOT_Foundation_C\",\"ROOT_Config\",\n         \"ROOT_Foundation_Stage1_NoRTTI\", \"Core\", \"RIO\"};\n      // These modules contain global variables which conflict with users' code such as \"PI\".\n      // FIXME: Reducing those will let us be less dependent on rootmap files\n      static constexpr std::array<const char*, 4> ExcludeModules =\n         { { \"Rtools\", \"RSQLite\", \"RInterface\", \"RMVA\"} };\n\n      LoadModules(CoreModules, *fInterpreter);\n\n      // Take this branch only from ROOT because we don't need to preload modules in rootcling\n      if (!fromRootCling) {\n         // Dynamically get all the modules and load them if they are not in core modules\n         clang::CompilerInstance &CI = *fInterpreter->getCI();\n         clang::ModuleMap &moduleMap = CI.getPreprocessor().getHeaderSearchInfo().getModuleMap();\n         clang::Preprocessor &PP = CI.getPreprocessor();\n         std::vector<std::string> ModulesPreloaded;\n\n         for (auto I = moduleMap.module_begin(), E = moduleMap.module_end(); I != E; ++I) {\n            clang::Module *M = I->second;\n            assert(M);\n\n            std::string ModuleName = GetModuleNameAsString(M, PP);\n            if (!ModuleName.empty() &&\n                  std::find(CoreModules.begin(), CoreModules.end(), ModuleName) == CoreModules.end()\n                  && std::find(ExcludeModules.begin(), ExcludeModules.end(), ModuleName) == ExcludeModules.end()) {\n               if (M->IsSystem && !M->IsMissingRequirement)\n                  LoadModule(ModuleName, *fInterpreter);\n               else if (!M->IsSystem && !M->IsMissingRequirement)\n                  ModulesPreloaded.push_back(ModuleName);\n            }\n         }\n         LoadModules(ModulesPreloaded, *fInterpreter);\n      }\n\n      // Check that the gROOT macro was exported by any core module.\n      assert(fInterpreter->getMacro(\"gROOT\") && \"Couldn't load gROOT macro?\");\n\n      // C99 decided that it's a very good idea to name a macro `I` (the letter I).\n      // This seems to screw up nearly all the template code out there as `I` is\n      // common template parameter name and iterator variable name.\n      // Let's follow the GCC recommendation and undefine `I` in case any of the\n      // core modules have defined it:\n      // https://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html\n      fInterpreter->declare(\"#ifdef I\\n #undef I\\n #endif\\n\");\n   }\n\n   // For the list to also include string, we have to include it now.\n   // rootcling does parts already if needed, e.g. genreflex does not want using\n   // namespace std.\n   if (fromRootCling) {\n      fInterpreter->declare(\"#include \\\"RtypesCore.h\\\"\\n\"\n                            \"#include <string>\\n\"\n                            \"using std::string;\\n\"\n                            \"#include <cassert>\\n\");\n   } else {\n      fInterpreter->declare(\"#include \\\"Rtypes.h\\\"\\n\"\n                            + gClassDefInterpMacro + \"\\n\"\n                            + gInterpreterClassDef + \"\\n\"\n                            \"#undef ClassImp\\n\"\n                            \"#define ClassImp(X);\\n\"\n                            \"#include <string>\\n\"\n                            \"using namespace std;\\n\"\n                            \"#include <cassert>\\n\");\n   }\n\n   // We are now ready (enough is loaded) to init the list of opaque typedefs.\n   fNormalizedCtxt = new ROOT::TMetaUtils::TNormalizedCtxt(fInterpreter->getLookupHelper());\n   fLookupHelper = new ROOT::TMetaUtils::TClingLookupHelper(*fInterpreter, *fNormalizedCtxt, TClingLookupHelper__ExistingTypeCheck, TClingLookupHelper__AutoParse);\n   TClassEdit::Init(fLookupHelper);\n\n   // Initialize the cling interpreter interface.\n   fMore      = 0;\n   fPrompt[0] = 0;\n   fMapfile   = 0;\n//    fMapNamespaces   = 0;\n   fRootmapFiles = 0;\n   fLockProcessLine = kTRUE;\n\n   fAllowLibLoad = !fromRootCling;\n   // Disallow auto-parsing in rootcling\n   fIsAutoParsingSuspended = fromRootCling;\n   // Disable the autoloader until it is explicitly enabled.\n   SetClassAutoloading(false);\n\n   ResetAll();\n#ifndef R__WIN32\n   //optind = 1;  // make sure getopt() works in the main program\n#endif // R__WIN32\n\n   // Enable dynamic lookup\n   if (!fromRootCling) {\n      fInterpreter->enableDynamicLookup();\n   }\n\n   // Attach cling callbacks last; they might need TROOT::fInterpreter\n   // and should thus not be triggered during the equivalent of\n   // TROOT::fInterpreter = new TCling;\n   std::unique_ptr<TClingCallbacks>\n      clingCallbacks(new TClingCallbacks(fInterpreter));\n   fClingCallbacks = clingCallbacks.get();\n   fClingCallbacks->SetAutoParsingSuspended(fIsAutoParsingSuspended);\n   fInterpreter->setCallbacks(std::move(clingCallbacks));\n\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Destroy the interpreter interface.\n\nTCling::~TCling()\n{\n   delete fMapfile;\n//    delete fMapNamespaces;\n   delete fRootmapFiles;\n   delete fMetaProcessor;\n   delete fTemporaries;\n   delete fNormalizedCtxt;\n   delete fInterpreter;\n   delete fLookupHelper;\n   gCling = 0;\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"~TCling\", \"Interface not available yet.\");\n#ifdef R__COMPLETE_MEM_TERMINATION\n   // remove all cling objects\n#endif\n#endif\n#endif\n   //--\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Initialize the interpreter, once TROOT::fInterpreter is set.\n\nvoid TCling::Initialize()\n{\n   fClingCallbacks->Initialize();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Wrapper around dladdr (and friends)\n\nstatic const char *FindLibraryName(void (*func)())\n{\n#if defined(__CYGWIN__) && defined(__GNUC__)\n   return 0;\n#elif defined(G__WIN32)\n   MEMORY_BASIC_INFORMATION mbi;\n   if (!VirtualQuery (func, &mbi, sizeof (mbi)))\n   {\n      return 0;\n   }\n\n   HMODULE hMod = (HMODULE) mbi.AllocationBase;\n   TTHREAD_TLS_ARRAY(char, MAX_PATH, moduleName);\n\n   if (!GetModuleFileNameA (hMod, moduleName, sizeof (moduleName)))\n   {\n      return 0;\n   }\n   return moduleName;\n#else\n   Dl_info info;\n   if (dladdr((void*)func,&info)==0) {\n      // Not in a known share library, let's give up\n      return 0;\n   } else {\n      //fprintf(stdout,\"Found address in %s\\n\",info.dli_fname);\n      return info.dli_fname;\n   }\n#endif\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper to initialize TVirtualStreamerInfo's factor early.\n/// Use static initialization to insure only one TStreamerInfo is created.\nstatic bool R__InitStreamerInfoFactory()\n{\n   // Use lambda since SetFactory return void.\n   auto setFactory = []() {\n      TVirtualStreamerInfo::SetFactory(new TStreamerInfo());\n      return kTRUE;\n   };\n   static bool doneFactory = setFactory();\n   return doneFactory; // avoid unused variable warning.\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Tries to load a PCM; returns true on success.\n\nbool TCling::LoadPCM(TString pcmFileName,\n                     const char** headers,\n                     void (*triggerFunc)()) const {\n   // pcmFileName is an intentional copy; updated by FindFile() below.\n\n   TString searchPath;\n\n   if (triggerFunc) {\n      const char *libraryName = FindLibraryName(triggerFunc);\n      if (libraryName) {\n         searchPath = llvm::sys::path::parent_path(libraryName);\n#ifdef R__WIN32\n         searchPath += \";\";\n#else\n         searchPath += \":\";\n#endif\n      }\n   }\n   // Note: if we know where the library is, we probably shouldn't even\n   // look in other places.\n   searchPath.Append( gSystem->GetDynamicPath() );\n\n   if (!gSystem->FindFile(searchPath, pcmFileName))\n      return kFALSE;\n\n   // Prevent the ROOT-PCMs hitting this during auto-load during\n   // JITting - which will cause recursive compilation.\n   // Avoid to call the plugin manager at all.\n   R__InitStreamerInfoFactory();\n\n   if (gROOT->IsRootFile(pcmFileName)) {\n      Int_t oldDebug = gDebug;\n      if (gDebug > 5) {\n         gDebug -= 5;\n         ::Info(\"TCling::LoadPCM\", \"Loading ROOT PCM %s\", pcmFileName.Data());\n      } else {\n         gDebug = 0;\n      }\n\n      TDirectory::TContext ctxt;\n\n      TFile *pcmFile = new TFile(pcmFileName+\"?filetype=pcm\",\"READ\");\n\n      auto listOfKeys = pcmFile->GetListOfKeys();\n\n      // This is an empty pcm\n      if (\n         listOfKeys &&\n         (\n            (listOfKeys->GetSize() == 0) || // Nothing here, or\n            (\n               (listOfKeys->GetSize() == 1) && // only one, and\n               !strcmp(((TKey*)listOfKeys->At(0))->GetName(), \"EMPTY\") // name is EMPTY\n            )\n         )\n      ) {\n         delete pcmFile;\n         gDebug = oldDebug;\n         return kTRUE;\n      }\n\n      TObjArray *protoClasses;\n      if (gDebug > 1)\n            ::Info(\"TCling::LoadPCM\",\"reading protoclasses for %s \\n\",pcmFileName.Data());\n\n      pcmFile->GetObject(\"__ProtoClasses\", protoClasses);\n\n      if (protoClasses) {\n         for (auto obj : *protoClasses) {\n            TProtoClass * proto = (TProtoClass*)obj;\n            TClassTable::Add(proto);\n         }\n         // Now that all TClass-es know how to set them up we can update\n         // existing TClasses, which might cause the creation of e.g. TBaseClass\n         // objects which in turn requires the creation of TClasses, that could\n         // come from the PCH, but maybe later in the loop. Instead of resolving\n         // a dependency graph the addition to the TClassTable above allows us\n         // to create these dependent TClasses as needed below.\n         for (auto proto : *protoClasses) {\n            if (TClass* existingCl\n                = (TClass*)gROOT->GetListOfClasses()->FindObject(proto->GetName())) {\n               // We have an existing TClass object. It might be emulated\n               // or interpreted; we now have more information available.\n               // Make that available.\n               if (existingCl->GetState() != TClass::kHasTClassInit) {\n                  DictFuncPtr_t dict = gClassTable->GetDict(proto->GetName());\n                  if (!dict) {\n                     ::Error(\"TCling::LoadPCM\", \"Inconsistent TClassTable for %s\",\n                             proto->GetName());\n                  } else {\n                     // This will replace the existing TClass.\n                     TClass *ncl = (*dict)();\n                     if (ncl) ncl->PostLoadCheck();\n\n                  }\n               }\n            }\n         }\n\n         protoClasses->Clear(); // Ownership was transfered to TClassTable.\n         delete protoClasses;\n      }\n\n      TObjArray *dataTypes;\n      pcmFile->GetObject(\"__Typedefs\", dataTypes);\n      if (dataTypes) {\n         for (auto typedf: *dataTypes)\n            gROOT->GetListOfTypes()->Add(typedf);\n         dataTypes->Clear(); // Ownership was transfered to TListOfTypes.\n         delete dataTypes;\n      }\n\n      TObjArray *enums;\n      pcmFile->GetObject(\"__Enums\", enums);\n      if (enums) {\n         // Cache the pointers\n         auto listOfGlobals = gROOT->GetListOfGlobals();\n         auto listOfEnums = dynamic_cast<THashList*>(gROOT->GetListOfEnums());\n         // Loop on enums and then on enum constants\n         for (auto selEnum: *enums){\n            const char* enumScope = selEnum->GetTitle();\n            const char* enumName = selEnum->GetName();\n            if (strcmp(enumScope,\"\") == 0){\n               // This is a global enum and is added to the\n               // list of enums and its constants to the list of globals\n               if (!listOfEnums->THashList::FindObject(enumName)){\n                  ((TEnum*) selEnum)->SetClass(nullptr);\n                  listOfEnums->Add(selEnum);\n               }\n               for (auto enumConstant: *static_cast<TEnum*>(selEnum)->GetConstants()){\n                  if (!listOfGlobals->FindObject(enumConstant)){\n                     listOfGlobals->Add(enumConstant);\n                  }\n               }\n            }\n            else {\n               // This enum is in a namespace. A TClass entry is bootstrapped if\n               // none exists yet and the enum is added to it\n               TClass* nsTClassEntry = TClass::GetClass(enumScope);\n               if (!nsTClassEntry){\n                  nsTClassEntry = new TClass(enumScope,0,TClass::kNamespaceForMeta, true);\n               }\n               auto listOfEnums = nsTClassEntry->fEnums.load();\n               if (!listOfEnums) {\n                  if ( (kIsClass | kIsStruct | kIsUnion) & nsTClassEntry->Property() ) {\n                     // For this case, the list will be immutable once constructed\n                     // (i.e. in this case, by the end of this routine).\n                     listOfEnums = nsTClassEntry->fEnums = new TListOfEnums(nsTClassEntry);\n                  } else {\n                     //namespaces can have enums added to them\n                     listOfEnums = nsTClassEntry->fEnums = new TListOfEnumsWithLock(nsTClassEntry);\n                  }\n               }\n               if (listOfEnums && !listOfEnums->THashList::FindObject(enumName)){\n                  ((TEnum*) selEnum)->SetClass(nsTClassEntry);\n                  listOfEnums->Add(selEnum);\n               }\n            }\n         }\n         enums->Clear();\n         delete enums;\n      }\n\n      delete pcmFile;\n\n      gDebug = oldDebug;\n   } else {\n      if (gDebug > 5)\n         ::Info(\"TCling::LoadPCM\", \"Loading clang PCM %s\", pcmFileName.Data());\n\n   }\n   return kTRUE;\n}\n\n//______________________________________________________________________________\n\nnamespace {\n   using namespace clang;\n\n   class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{\n      // This class is to be considered an helper for autoparsing.\n      // It visits the AST and marks all classes (in all of their redeclarations)\n      // with the setHasExternalLexicalStorage method.\n   public:\n      bool VisitRecordDecl(clang::RecordDecl* rcd){\n         if (gDebug > 2)\n            Info(\"ExtLexicalStorageAdder\",\n                 \"Adding external lexical storage to class %s\",\n                 rcd->getNameAsString().c_str());\n         auto reDeclPtr = rcd->getMostRecentDecl();\n         do {\n            reDeclPtr->setHasExternalLexicalStorage();\n         } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));\n\n         return false;\n      }\n   };\n\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// List of dicts that have the PCM information already in the PCH.\nstatic const std::unordered_set<std::string> gIgnoredPCMNames = {\"libCore\",\n                                                                 \"libRint\",\n                                                                 \"libThread\",\n                                                                 \"libRIO\",\n                                                                 \"libImt\",\n                                                                 \"libcomplexDict\",\n                                                                 \"libdequeDict\",\n                                                                 \"liblistDict\",\n                                                                 \"libforward_listDict\",\n                                                                 \"libvectorDict\",\n                                                                 \"libmapDict\",\n                                                                 \"libmultimap2Dict\",\n                                                                 \"libmap2Dict\",\n                                                                 \"libmultimapDict\",\n                                                                 \"libsetDict\",\n                                                                 \"libmultisetDict\",\n                                                                 \"libunordered_setDict\",\n                                                                 \"libunordered_multisetDict\",\n                                                                 \"libunordered_mapDict\",\n                                                                 \"libunordered_multimapDict\",\n                                                                 \"libvalarrayDict\",\n                                                                 \"G__GenVector32\",\n                                                                 \"G__Smatrix32\"};\n\n////////////////////////////////////////////////////////////////////////////////\n/// Inject the module named \"modulename\" into cling; load all headers.\n/// headers is a 0-terminated array of header files to #include after\n/// loading the module. The module is searched for in all $LD_LIBRARY_PATH\n/// entries (or %PATH% on Windows).\n/// This function gets called by the static initialization of dictionary\n/// libraries.\n/// The payload code is injected \"as is\" in the interpreter.\n/// The value of 'triggerFunc' is used to find the shared library location.\n\nvoid TCling::RegisterModule(const char* modulename,\n                            const char** headers,\n                            const char** includePaths,\n                            const char* payloadCode,\n                            const char* fwdDeclsCode,\n                            void (*triggerFunc)(),\n                            const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,\n                            const char** classesHeaders,\n                            Bool_t lateRegistration /*=false*/,\n                            Bool_t hasCxxModule /*=false*/)\n{\n   const bool fromRootCling = IsFromRootCling();\n   // We need the dictionary initialization but we don't want to inject the\n   // declarations into the interpreter, except for those we really need for\n   // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().\n   if (fromRootCling) return;\n\n   // When we cannot provide a module for the library we should enable header\n   // parsing. This 'mixed' mode ensures gradual migration to modules.\n   llvm::SaveAndRestore<bool> SaveHeaderParsing(fHeaderParsingOnDemand);\n   fHeaderParsingOnDemand = !hasCxxModule;\n\n   // Treat Aclic Libs in a special way. Do not delay the parsing.\n   bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;\n   bool isACLiC = strstr(modulename, \"_ACLiC_dict\") != nullptr;\n   if (hasHeaderParsingOnDemand && isACLiC) {\n      if (gDebug>1)\n         Info(\"TCling::RegisterModule\",\n              \"Header parsing on demand is active but this is an Aclic library. Disabling it for this library.\");\n      hasHeaderParsingOnDemand = false;\n   }\n\n\n   // Make sure we relookup symbols that were search for before we loaded\n   // their autoparse information.  We could be more subtil and remove only\n   // the failed one or only the one in this module, but for now this is\n   // better than nothing.\n   fLookedUpClasses.clear();\n\n   // Make sure we do not set off autoloading or autoparsing during the\n   // module registration!\n   Int_t oldAutoloadValue = SetClassAutoloading(false);\n\n   for (const char** inclPath = includePaths; *inclPath; ++inclPath) {\n      TCling::AddIncludePath(*inclPath);\n   }\n   cling::Transaction* T = 0;\n   // Put the template decls and the number of arguments to skip in the TNormalizedCtxt\n   for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){\n      const std::string& fwdDecl = fwdDeclArgToSkipPair.first;\n      const int nArgsToSkip = fwdDeclArgToSkipPair.second;\n      auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);\n      assert(cling::Interpreter::kSuccess == compRes &&\n            \"A fwd declaration could not be compiled\");\n      if (compRes!=cling::Interpreter::kSuccess){\n         Warning(\"TCling::RegisterModule\",\n               \"Problems in declaring string '%s' were encountered.\",\n               fwdDecl.c_str()) ;\n         continue;\n      }\n\n      // Drill through namespaces recursively until the template is found\n      if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){\n         fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);\n      }\n\n   }\n\n   // FIXME: Remove #define __ROOTCLING__ once PCMs are there.\n   // This is used to give Sema the same view on ACLiC'ed files (which\n   // are then #included through the dictionary) as rootcling had.\n   TString code = gNonInterpreterClassDef;\n   if (payloadCode)\n      code += payloadCode;\n\n   const char* dyLibName = nullptr;\n   // If this call happens after dlopen has finished (i.e. late registration)\n   // there is no need to dlopen the library recursively. See ROOT-8437 where\n   // the dyLibName would correspond to the binary.\n   if (!lateRegistration) {\n      // We need to open the dictionary shared library, to resolve symbols\n      // requested by the JIT from it: as the library is currently being dlopen'ed,\n      // its symbols are not yet reachable from the process.\n      // Recursive dlopen seems to work just fine.\n      dyLibName = FindLibraryName(triggerFunc);\n      if (dyLibName) {\n         // We were able to determine the library name.\n         void* dyLibHandle = dlopen(dyLibName, RTLD_LAZY | RTLD_GLOBAL);\n         if (!dyLibHandle) {\n#ifdef R__WIN32\n            char dyLibError[1000];\n            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                           dyLibError, sizeof(dyLibError), NULL);\n#else\n            const char* dyLibError = dlerror();\n            if (dyLibError)\n#endif\n            {\n               if (gDebug > 0) {\n                  ::Info(\"TCling::RegisterModule\",\n                         \"Cannot open shared library %s for dictionary %s:\\n  %s\",\n                         dyLibName, modulename, dyLibError);\n               }\n            }\n            dyLibName = 0;\n         } else {\n            fRegisterModuleDyLibs.push_back(dyLibHandle);\n         } // if (!dyLibHandle) .. else\n      } // if (dyLibName)\n   } // if (!lateRegistration)\n\n   if (hasHeaderParsingOnDemand && fwdDeclsCode){\n      // We now parse the forward declarations. All the classes are then modified\n      // in order for them to have an external lexical storage.\n      std::string fwdDeclsCodeLessEnums;\n      {\n         // Search for enum forward decls and only declare them if no\n         // declaration exists yet.\n         std::string fwdDeclsLine;\n         std::istringstream fwdDeclsCodeStr(fwdDeclsCode);\n         std::vector<std::string> scopes;\n         while (std::getline(fwdDeclsCodeStr, fwdDeclsLine)) {\n            const auto enumPos = fwdDeclsLine.find(\"enum  __attribute__((annotate(\\\"\");\n            // We check if the line contains a fwd declaration of an enum\n            if (enumPos != std::string::npos) {\n               // We clear the scopes which we may have carried from a previous iteration\n               scopes.clear();\n               // We check if the enum is not in a scope. If yes, save its name\n               // and the names of the enclosing scopes.\n               if (enumPos != 0) {\n                  // it's enclosed in namespaces. We need to understand what they are\n                  auto nsPos = fwdDeclsLine.find(\"namespace\");\n                  R__ASSERT(nsPos < enumPos && \"Inconsistent enum and enclosing scope parsing!\");\n                  while (nsPos < enumPos && nsPos != std::string::npos) {\n                     // we have a namespace, let's put it in the collection of scopes\n                     const auto nsNameStart = nsPos + 10;\n                     const auto nsNameEnd = fwdDeclsLine.find('{', nsNameStart);\n                     const auto nsName = fwdDeclsLine.substr(nsNameStart, nsNameEnd - nsNameStart);\n                     scopes.push_back(nsName);\n                     nsPos = fwdDeclsLine.find(\"namespace\", nsNameEnd);\n                  }\n               }\n               clang::DeclContext* DC = 0;\n               for (auto &&aScope: scopes) {\n                  DC = cling::utils::Lookup::Namespace(&fInterpreter->getSema(), aScope.c_str(), DC);\n                  if (!DC) {\n                     // No decl context means we have to fwd declare the enum.\n                     break;\n                  }\n               }\n               if (scopes.empty() || DC) {\n                  // We know the scope; let's look for the enum.\n                  size_t posEnumName = fwdDeclsLine.find(\"\\\"))) \", 32);\n                  R__ASSERT(posEnumName != std::string::npos && \"Inconsistent enum fwd decl!\");\n                  posEnumName += 5; // skip \"\\\"))) \"\n                  while (isspace(fwdDeclsLine[posEnumName]))\n                     ++posEnumName;\n                  size_t posEnumNameEnd = fwdDeclsLine.find(\" : \", posEnumName);\n                  R__ASSERT(posEnumNameEnd  != std::string::npos && \"Inconsistent enum fwd decl (end)!\");\n                  while (isspace(fwdDeclsLine[posEnumNameEnd]))\n                     --posEnumNameEnd;\n                  // posEnumNameEnd now points to the last character of the name.\n\n                  std::string enumName = fwdDeclsLine.substr(posEnumName,\n                                                             posEnumNameEnd - posEnumName + 1);\n\n                  if (clang::NamedDecl* enumDecl\n                      = cling::utils::Lookup::Named(&fInterpreter->getSema(),\n                                                    enumName.c_str(), DC)) {\n                     // We have an existing enum decl (forward or definition);\n                     // skip this.\n                     R__ASSERT(llvm::dyn_cast<clang::EnumDecl>(enumDecl) && \"not an enum decl!\");\n                     (void)enumDecl;\n                     continue;\n                  }\n               }\n            }\n\n            fwdDeclsCodeLessEnums += fwdDeclsLine + \"\\n\";\n         }\n      }\n\n      if (fwdDeclsCodeLessEnums.size() != 0){ // Avoid the overhead if nothing is to be declared\n         auto compRes = fInterpreter->declare(fwdDeclsCodeLessEnums, &T);\n         assert(cling::Interpreter::kSuccess == compRes &&\n               \"The forward declarations could not be compiled\");\n         if (compRes!=cling::Interpreter::kSuccess){\n            Warning(\"TCling::RegisterModule\",\n                  \"Problems in compiling forward declarations for module %s: '%s'\",\n                  modulename, fwdDeclsCodeLessEnums.c_str()) ;\n         }\n         else if (T){\n            // Loop over all decls in the transaction and go through them all\n            // to mark them properly.\n            // In order to do that, we first iterate over all the DelayedCallInfos\n            // within the transaction. Then we loop over all Decls in the DeclGroupRef\n            // contained in the DelayedCallInfos. For each decl, we traverse.\n            ExtLexicalStorageAdder elsa;\n            for (auto dciIt = T->decls_begin();dciIt!=T->decls_end();dciIt++){\n               cling::Transaction::DelayCallInfo& dci = *dciIt;\n               for(auto dit = dci.m_DGR.begin(); dit != dci.m_DGR.end(); ++dit) {\n                  clang::Decl* declPtr = *dit;\n                  elsa.TraverseDecl(declPtr);\n               }\n            }\n         }\n      }\n\n      // Now we register all the headers necessary for the class\n      // Typical format of the array:\n      //    {\"A\", \"classes.h\", \"@\",\n      //     \"vector<A>\", \"vector\", \"@\",\n      //     \"myClass\", payloadCode, \"@\",\n      //    nullptr};\n\n      std::string temp;\n      for (const char** classesHeader = classesHeaders; *classesHeader; ++classesHeader) {\n         temp=*classesHeader;\n\n         size_t theTemplateHash = 0;\n         bool addTemplate = false;\n         size_t posTemplate = temp.find('<');\n         if (posTemplate != std::string::npos) {\n            // Add an entry for the template itself.\n            std::string templateName = temp.substr(0, posTemplate);\n            theTemplateHash = fStringHashFunction(templateName);\n            addTemplate = true;\n         }\n         size_t theHash = fStringHashFunction(temp);\n         classesHeader++;\n         for (const char** classesHeader_inner = classesHeader; 0!=strcmp(*classesHeader_inner,\"@\"); ++classesHeader_inner,++classesHeader){\n            // This is done in order to distinguish headers from files and from the payloadCode\n            if (payloadCode == *classesHeader_inner ){\n               fPayloads.insert(theHash);\n               if (addTemplate) fPayloads.insert(theTemplateHash);\n            }\n            if (gDebug > 2)\n               Info(\"TCling::RegisterModule\",\n                     \"Adding a header for %s\", temp.c_str());\n            fClassesHeadersMap[theHash].push_back(*classesHeader_inner);\n            if (addTemplate) {\n               if (fClassesHeadersMap.find(theTemplateHash) == fClassesHeadersMap.end()) {\n                  fClassesHeadersMap[theTemplateHash].push_back(*classesHeader_inner);\n               }\n               addTemplate = false;\n            }\n         }\n      }\n   }\n\n   if (gIgnoredPCMNames.find(modulename) == gIgnoredPCMNames.end()) {\n      TString pcmFileName(ROOT::TMetaUtils::GetModuleFileName(modulename).c_str());\n      if (!LoadPCM(pcmFileName, headers, triggerFunc)) {\n         ::Error(\"TCling::RegisterModule\", \"cannot find dictionary module %s\",\n                 ROOT::TMetaUtils::GetModuleFileName(modulename).c_str());\n      }\n   }\n\n   bool oldValue = false;\n   if (fClingCallbacks)\n     oldValue = SetClassAutoloading(false);\n\n   clang::Sema &TheSema = fInterpreter->getSema();\n\n   bool ModuleWasSuccessfullyLoaded = false;\n   if (hasCxxModule) {\n      std::string ModuleName = llvm::StringRef(modulename).substr(3).str();\n      // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about\n      // modules such as GenVector32 because it needs to fall back to GenVector.\n      ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter, /*Complain=*/ false);\n      if (!ModuleWasSuccessfullyLoaded) {\n         // Only report if we found the module in the modulemap.\n         clang::Preprocessor &PP = TheSema.getPreprocessor();\n         clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();\n         clang::ModuleMap &moduleMap = headerSearch.getModuleMap();\n         if (moduleMap.findModule(ModuleName))\n            Info(\"TCling::RegisterModule\", \"Module %s in modulemap failed to load.\", ModuleName.c_str());\n      }\n   }\n\n   { // scope within which diagnostics are de-activated\n   // For now we disable diagnostics because we saw them already at\n   // dictionary generation time. That won't be an issue with the PCMs.\n\n      clangDiagSuppr diagSuppr(TheSema.getDiagnostics());\n\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n      Warning(\"TCling::RegisterModule\",\"Diagnostics suppression should be gone by now.\");\n#endif\n#endif\n\n      if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){\n         SuspendAutoParsing autoParseRaii(this);\n\n         const cling::Transaction* watermark = fInterpreter->getLastTransaction();\n         cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());\n         if (isACLiC) {\n            // Register an unload point.\n            fMetaProcessor->registerUnloadPoint(watermark, headers[0]);\n         }\n\n         assert(cling::Interpreter::kSuccess == compRes &&\n                        \"Payload code of a dictionary could not be parsed correctly.\");\n         if (compRes!=cling::Interpreter::kSuccess) {\n            Warning(\"TCling::RegisterModule\",\n                  \"Problems declaring payload for module %s.\", modulename) ;\n         }\n      }\n   }\n\n   // Now that all the header have been registered/compiled, let's\n   // make sure to 'reset' the TClass that have a class init in this module\n   // but already had their type information available (using information/header\n   // loaded from other modules or from class rules).\n   if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {\n      // This code is likely to be superseded by the similar code in LoadPCM,\n      // and have been disabled, (inadvertently or awkwardly) by\n      // commit 7903f09f3beea69e82ffba29f59fb2d656a4fd54 (Refactor the routines used for header parsing on demand)\n      // whereas it seems that a more semantically correct conditional would have\n      // been 'if this module does not have a rootpcm'.\n      // Note: this need to be review when the clang pcm are being installed.\n      //       #if defined(R__MUST_REVISIT)\n      while (!fClassesToUpdate.empty()) {\n         TClass *oldcl = fClassesToUpdate.back().first;\n         if (oldcl->GetState() != TClass::kHasTClassInit) {\n            // if (gDebug > 2) Info(\"RegisterModule\", \"Forcing TClass init for %s\", oldcl->GetName());\n            DictFuncPtr_t dict = fClassesToUpdate.back().second;\n            fClassesToUpdate.pop_back();\n            // Calling func could manipulate the list so, let maintain the list\n            // then call the dictionary function.\n            TClass *ncl = dict();\n            if (ncl) ncl->PostLoadCheck();\n         } else {\n            fClassesToUpdate.pop_back();\n         }\n      }\n   }\n\n   if (fClingCallbacks)\n     SetClassAutoloading(oldValue);\n\n   if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {\n      // __ROOTCLING__ might be pulled in through PCH\n      fInterpreter->declare(\"#ifdef __ROOTCLING__\\n\"\n                            \"#undef __ROOTCLING__\\n\"\n                            + gInterpreterClassDef +\n                            \"#endif\");\n   }\n\n   if (dyLibName) {\n      void* dyLibHandle = fRegisterModuleDyLibs.back();\n      fRegisterModuleDyLibs.pop_back();\n      dlclose(dyLibHandle);\n   }\n\n   SetClassAutoloading(oldAutoloadValue);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register classes that already existed prior to their dictionary loading\n/// and that already had a ClassInfo (and thus would not be refresh via\n/// UpdateClassInfo.\n\nvoid TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict)\n{\n   fClassesToUpdate.push_back(std::make_pair(oldcl,dict));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If the dictionary is loaded, we can remove the class from the list\n/// (otherwise the class might be loaded twice).\n\nvoid TCling::UnRegisterTClassUpdate(const TClass *oldcl)\n{\n   typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;\n   iterator stop = fClassesToUpdate.end();\n   for(iterator i = fClassesToUpdate.begin();\n       i != stop;\n       ++i)\n   {\n      if ( i->first == oldcl ) {\n         fClassesToUpdate.erase(i);\n         return;\n      }\n   }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line.\n///\n/// If the command is executed and the error is 0, then the return value\n/// is the int value corresponding to the result of the executed command\n/// (float and double return values will be truncated).\n///\n\n// Method for handling the interpreter exceptions.\n// the MetaProcessor is passing in as argument to teh function, because\n// cling::Interpreter::CompilationResult is a nested class and it cannot be\n// forward declared, thus this method cannot be a static member function\n// of TCling.\n\nstatic int HandleInterpreterException(cling::MetaProcessor* metaProcessor,\n                                 const char* input_line,\n                                 cling::Interpreter::CompilationResult& compRes,\n                                 cling::Value* result)\n{\n   try {\n      return metaProcessor->process(input_line, compRes, result);\n   }\n   catch (cling::InterpreterException& ex)\n   {\n      Error(\"HandleInterpreterException\", \"%s.\\n%s\", ex.what(), \"Execution of your code was aborted.\");\n      ex.diagnose();\n      compRes = cling::Interpreter::kFailure;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::DiagnoseIfInterpreterException(const std::exception &e) const\n{\n   if (auto ie = dynamic_cast<const cling::InterpreterException*>(&e)) {\n      ie->diagnose();\n      return true;\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ProcessLine(const char* line, EErrorCode* error/*=0*/)\n{\n   // Copy the passed line, it comes from a static buffer in TApplication\n   // which can be reentered through the Cling evaluation routines,\n   // which would overwrite the static buffer and we would forget what we\n   // were doing.\n   //\n   TString sLine(line);\n   if (strstr(line,fantomline)) {\n      // End-Of-Line action\n      // See the comment (copied from above):\n      // It is a \"fantom\" method to synchronize user keyboard input\n      // and ROOT prompt line (for WIN32)\n      // and is implemented by\n      if (gApplication) {\n         if (gApplication->IsCmdThread()) {\n            R__LOCKGUARD(fLockProcessLine ? gInterpreterMutex : 0);\n            gROOT->SetLineIsProcessing();\n\n            UpdateAllCanvases();\n\n            gROOT->SetLineHasBeenProcessed();\n         }\n      }\n      return 0;\n   }\n\n   if (gGlobalMutex && !gInterpreterMutex && fLockProcessLine) {\n      gGlobalMutex->Lock();\n      if (!gInterpreterMutex)\n         gInterpreterMutex = gGlobalMutex->Factory(kTRUE);\n      gGlobalMutex->UnLock();\n   }\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   gROOT->SetLineIsProcessing();\n\n   struct InterpreterFlagsRAII {\n      cling::Interpreter* fInterpreter;\n      bool fWasDynamicLookupEnabled;\n\n      InterpreterFlagsRAII(cling::Interpreter* interp):\n         fInterpreter(interp),\n         fWasDynamicLookupEnabled(interp->isDynamicLookupEnabled())\n      {\n         fInterpreter->enableDynamicLookup(true);\n      }\n      ~InterpreterFlagsRAII() {\n         fInterpreter->enableDynamicLookup(fWasDynamicLookupEnabled);\n         gROOT->SetLineHasBeenProcessed();\n      }\n   } interpreterFlagsRAII(fInterpreter);\n\n   // A non-zero returned value means the given line was\n   // not a complete statement.\n   int indent = 0;\n   // This will hold the resulting value of the evaluation the given line.\n   cling::Value result;\n   cling::Interpreter::CompilationResult compRes = cling::Interpreter::kSuccess;\n   if (!strncmp(sLine.Data(), \".L\", 2) || !strncmp(sLine.Data(), \".x\", 2) ||\n       !strncmp(sLine.Data(), \".X\", 2)) {\n      // If there was a trailing \"+\", then CINT compiled the code above,\n      // and we will need to strip the \"+\" before passing the line to cling.\n      TString mod_line(sLine);\n      TString aclicMode;\n      TString arguments;\n      TString io;\n      TString fname = gSystem->SplitAclicMode(sLine.Data() + 3,\n         aclicMode, arguments, io);\n      if (aclicMode.Length()) {\n         // Remove the leading '+'\n         R__ASSERT(aclicMode[0]=='+' && \"ACLiC mode must start with a +\");\n         aclicMode[0]='k';    // We always want to keep the .so around.\n         if (aclicMode[1]=='+') {\n            // We have a 2nd +\n            aclicMode[1]='f'; // We want to force the recompilation.\n         }\n         if (!gSystem->CompileMacro(fname,aclicMode)) {\n            // ACLiC failed.\n            compRes = cling::Interpreter::kFailure;\n         } else {\n            if (strncmp(sLine.Data(), \".L\", 2) != 0) {\n               // if execution was requested.\n\n               if (arguments.Length()==0) {\n                  arguments = \"()\";\n               }\n               // We need to remove the extension.\n               Ssiz_t ext = fname.Last('.');\n               if (ext != kNPOS) {\n                  fname.Remove(ext);\n               }\n               const char *function = gSystem->BaseName(fname);\n               mod_line = function + arguments + io;\n               indent = HandleInterpreterException(fMetaProcessor, mod_line, compRes, &result);\n            }\n         }\n      } else {\n         // not ACLiC\n         size_t unnamedMacroOpenCurly;\n         {\n            std::string code;\n            std::string codeline;\n            std::ifstream in(fname);\n            while (in) {\n               std::getline(in, codeline);\n               code += codeline + \"\\n\";\n            }\n            unnamedMacroOpenCurly\n              = cling::utils::isUnnamedMacro(code, fInterpreter->getCI()->getLangOpts());\n         }\n\n         fCurExecutingMacros.push_back(fname);\n         if (unnamedMacroOpenCurly != std::string::npos) {\n            compRes = fMetaProcessor->readInputFromFile(fname.Data(), &result,\n                                                        unnamedMacroOpenCurly);\n         } else {\n            // No DynLookup for .x, .L of named macros.\n            fInterpreter->enableDynamicLookup(false);\n            indent = HandleInterpreterException(fMetaProcessor, mod_line, compRes, &result);\n         }\n         fCurExecutingMacros.pop_back();\n      }\n   } // .L / .X / .x\n   else {\n      if (0!=strncmp(sLine.Data(), \".autodict \",10) && sLine != \".autodict\") {\n         // explicitly ignore .autodict without having to support it\n         // in cling.\n\n         // Turn off autoparsing if this is an include directive\n         bool isInclusionDirective = sLine.Contains(\"\\n#include\") || sLine.BeginsWith(\"#include\");\n         if (isInclusionDirective) {\n            SuspendAutoParsing autoParseRaii(this);\n            indent = HandleInterpreterException(fMetaProcessor, sLine, compRes, &result);\n         } else {\n            indent = HandleInterpreterException(fMetaProcessor, sLine, compRes, &result);\n         }\n      }\n   }\n   if (result.isValid())\n      RegisterTemporary(result);\n   if (indent) {\n      if (error)\n         *error = kProcessing;\n      return 0;\n   }\n   if (error) {\n      switch (compRes) {\n      case cling::Interpreter::kSuccess: *error = kNoError; break;\n      case cling::Interpreter::kFailure: *error = kRecoverable; break;\n      case cling::Interpreter::kMoreInputExpected: *error = kProcessing; break;\n      }\n   }\n   if (compRes == cling::Interpreter::kSuccess\n       && result.isValid()\n       && !result.isVoid())\n   {\n      return result.simplisticCastAs<long>();\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No-op; see TRint instead.\n\nvoid TCling::PrintIntro()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Add the given path to the list of directories in which the interpreter\n/// looks for include files. Only one path item can be specified at a\n/// time, i.e. \"path1:path2\" is NOT supported.\n\nvoid TCling::AddIncludePath(const char *path)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // Favorite source of annoyance: gSystem->AddIncludePath() needs \"-I\",\n   // gCling->AddIncludePath() does not! Work around that inconsistency:\n   if (path[0] == '-' && path[1] == 'I')\n      path += 2;\n\n   fInterpreter->AddIncludePath(path);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Visit all members over members, recursing over base classes.\n\nvoid TCling::InspectMembers(TMemberInspector& insp, const void* obj,\n                            const TClass* cl, Bool_t isTransient)\n{\n   if (insp.GetObjectValidity() == TMemberInspector::kUnset) {\n      insp.SetObjectValidity(obj ? TMemberInspector::kValidObjectGiven\n                             : TMemberInspector::kNoObjectGiven);\n   }\n\n   if (!cl || cl->GetCollectionProxy()) {\n      // We do not need to investigate the content of the STL\n      // collection, they are opaque to us (and details are\n      // uninteresting).\n      return;\n   }\n\n   static const TClassRef clRefString(\"std::string\");\n   if (clRefString == cl) {\n      // We stream std::string without going through members..\n      return;\n   }\n\n   if (TClassEdit::IsStdArray(cl->GetName())) {\n      // We treat std arrays as C arrays\n      return;\n   }\n\n   const char* cobj = (const char*) obj; // for ptr arithmetics\n\n   // Treat the case of std::complex in a special manner. We want to enforce\n   // the layout of a stl implementation independent class, which is the\n   // complex as implemented in ROOT5.\n\n   // A simple lambda to simplify the code\n   auto inspInspect =  [&] (ptrdiff_t offset){\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), \"_real\", cobj, isTransient);\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), \"_imag\", cobj + offset, isTransient);\n   };\n\n   auto complexType = TClassEdit::GetComplexType(cl->GetName());\n   switch(complexType) {\n      case TClassEdit::EComplexType::kNone:\n      {\n        break;\n      }\n      case TClassEdit::EComplexType::kFloat:\n      {\n        inspInspect(sizeof(float));\n        return;\n      }\n      case TClassEdit::EComplexType::kDouble:\n      {\n        inspInspect(sizeof(double));\n        return;\n      }\n      case TClassEdit::EComplexType::kInt:\n      {\n        inspInspect(sizeof(int));\n        return;\n      }\n      case TClassEdit::EComplexType::kLong:\n      {\n        inspInspect(sizeof(long));\n        return;\n      }\n   }\n\n   static clang::PrintingPolicy\n      printPol(fInterpreter->getCI()->getLangOpts());\n   if (printPol.Indentation) {\n      // not yet initialized\n      printPol.Indentation = 0;\n      printPol.SuppressInitializers = true;\n   }\n\n   const char* clname = cl->GetName();\n   // Printf(\"Inspecting class %s\\n\", clname);\n\n   const clang::ASTContext& astContext = fInterpreter->getCI()->getASTContext();\n   const clang::Decl *scopeDecl = 0;\n   const clang::Type *recordType = 0;\n\n   if (cl->GetClassInfo()) {\n      TClingClassInfo * clingCI = (TClingClassInfo *)cl->GetClassInfo();\n      scopeDecl = clingCI->GetDecl();\n      recordType = clingCI->GetType();\n   } else {\n      const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n      // Diags will complain about private classes:\n      scopeDecl = lh.findScope(clname, cling::LookupHelper::NoDiagnostics,\n                               &recordType);\n   }\n   if (!scopeDecl) {\n      Error(\"InspectMembers\", \"Cannot find Decl for class %s\", clname);\n      return;\n   }\n   const clang::CXXRecordDecl* recordDecl\n     = llvm::dyn_cast<const clang::CXXRecordDecl>(scopeDecl);\n   if (!recordDecl) {\n      Error(\"InspectMembers\", \"Cannot find Decl for class %s is not a CXXRecordDecl.\", clname);\n      return;\n   }\n\n   {\n      // Force possible deserializations first. We need to have no pending\n      // Transaction when passing control flow to the inspector below (ROOT-7779).\n      cling::Interpreter::PushTransactionRAII deserRAII(fInterpreter);\n\n      astContext.getASTRecordLayout(recordDecl);\n\n      for (clang::RecordDecl::field_iterator iField = recordDecl->field_begin(),\n              eField = recordDecl->field_end(); iField != eField; ++iField) {}\n   }\n\n   const clang::ASTRecordLayout& recLayout\n      = astContext.getASTRecordLayout(recordDecl);\n\n   // TVirtualCollectionProxy *proxy = cl->GetCollectionProxy();\n   // if (proxy && ( proxy->GetProperties() & TVirtualCollectionProxy::kIsEmulated ) ) {\n   //    Error(\"InspectMembers\",\"The TClass for %s has an emulated proxy but we are looking at a compiled version of the collection!\\n\",\n   //          cl->GetName());\n   // }\n   if (cl->Size() != recLayout.getSize().getQuantity()) {\n      Error(\"InspectMembers\",\"TClass and cling disagree on the size of the class %s, respectively %d %lld\\n\",\n            cl->GetName(),cl->Size(),(Long64_t)recLayout.getSize().getQuantity());\n   }\n\n   unsigned iNField = 0;\n   // iterate over fields\n   // FieldDecls are non-static, else it would be a VarDecl.\n   for (clang::RecordDecl::field_iterator iField = recordDecl->field_begin(),\n        eField = recordDecl->field_end(); iField != eField;\n        ++iField, ++iNField) {\n\n\n      clang::QualType memberQT = iField->getType();\n      if (recordType) {\n         // if (we_need_to_do_the_subst_because_the_class_is_a_template_instance_of_double32_t)\n         memberQT = ROOT::TMetaUtils::ReSubstTemplateArg(memberQT, recordType);\n      }\n      memberQT = cling::utils::Transform::GetPartiallyDesugaredType(astContext, memberQT, fNormalizedCtxt->GetConfig(), false /* fully qualify */);\n      if (memberQT.isNull()) {\n         std::string memberName;\n         llvm::raw_string_ostream stream(memberName);\n         // Don't trigger fopen of the source file to count lines:\n         printPol.AnonymousTagLocations = false;\n         iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n         stream.flush();\n         Error(\"InspectMembers\",\n               \"Cannot retrieve QualType for member %s while inspecting class %s\",\n               memberName.c_str(), clname);\n         continue; // skip member\n      }\n      const clang::Type* memType = memberQT.getTypePtr();\n      if (!memType) {\n         std::string memberName;\n         llvm::raw_string_ostream stream(memberName);\n         // Don't trigger fopen of the source file to count lines:\n         printPol.AnonymousTagLocations = false;\n         iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n         stream.flush();\n         Error(\"InspectMembers\",\n               \"Cannot retrieve Type for member %s while inspecting class %s\",\n               memberName.c_str(), clname);\n         continue; // skip member\n      }\n\n      const clang::Type* memNonPtrType = memType;\n      Bool_t ispointer = false;\n      if (memNonPtrType->isPointerType()) {\n         ispointer = true;\n         clang::QualType ptrQT\n            = memNonPtrType->getAs<clang::PointerType>()->getPointeeType();\n         if (recordType) {\n            // if (we_need_to_do_the_subst_because_the_class_is_a_template_instance_of_double32_t)\n            ptrQT = ROOT::TMetaUtils::ReSubstTemplateArg(ptrQT, recordType);\n         }\n         ptrQT = cling::utils::Transform::GetPartiallyDesugaredType(astContext, ptrQT, fNormalizedCtxt->GetConfig(), false /* fully qualify */);\n         if (ptrQT.isNull()) {\n            std::string memberName;\n            llvm::raw_string_ostream stream(memberName);\n            // Don't trigger fopen of the source file to count lines:\n            printPol.AnonymousTagLocations = false;\n            iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n            stream.flush();\n            Error(\"InspectMembers\",\n                  \"Cannot retrieve pointee Type for member %s while inspecting class %s\",\n                  memberName.c_str(), clname);\n            continue; // skip member\n         }\n         memNonPtrType = ptrQT.getTypePtr();\n      }\n\n      // assemble array size(s): \"[12][4][]\"\n      llvm::SmallString<8> arraySize;\n      const clang::ArrayType* arrType = memNonPtrType->getAsArrayTypeUnsafe();\n      unsigned arrLevel = 0;\n      bool haveErrorDueToArray = false;\n      while (arrType) {\n         ++arrLevel;\n         arraySize += '[';\n         const clang::ConstantArrayType* constArrType =\n         clang::dyn_cast<clang::ConstantArrayType>(arrType);\n         if (constArrType) {\n            constArrType->getSize().toStringUnsigned(arraySize);\n         }\n         arraySize += ']';\n         clang::QualType subArrQT = arrType->getElementType();\n         if (subArrQT.isNull()) {\n            std::string memberName;\n            llvm::raw_string_ostream stream(memberName);\n            // Don't trigger fopen of the source file to count lines:\n            printPol.AnonymousTagLocations = false;\n            iField->getNameForDiagnostic(stream, printPol, true /*fqi*/);\n            stream.flush();\n            Error(\"InspectMembers\",\n                  \"Cannot retrieve QualType for array level %d (i.e. element type of %s) for member %s while inspecting class %s\",\n                  arrLevel, subArrQT.getAsString(printPol).c_str(),\n                  memberName.c_str(), clname);\n            haveErrorDueToArray = true;\n            break;\n         }\n         arrType = subArrQT.getTypePtr()->getAsArrayTypeUnsafe();\n      }\n      if (haveErrorDueToArray) {\n         continue; // skip member\n      }\n\n      // construct member name\n      std::string fieldName;\n      if (memType->isPointerType()) {\n         fieldName = \"*\";\n      }\n\n      // Check if this field has a custom ioname, if not, just use the one of the decl\n      std::string ioname(iField->getName());\n      ROOT::TMetaUtils::ExtractAttrPropertyFromName(**iField,\"ioname\",ioname);\n      fieldName += ioname;\n      fieldName += arraySize;\n\n      // get member offset\n      // NOTE currently we do not support bitfield and do not support\n      // member that are not aligned on 'bit' boundaries.\n      clang::CharUnits offset(astContext.toCharUnitsFromBits(recLayout.getFieldOffset(iNField)));\n      ptrdiff_t fieldOffset = offset.getQuantity();\n\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"fBits[2]\", fBits);\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"fName\", &fName);\n      // R__insp.InspectMember(fName, \"fName.\");\n      // R__insp.Inspect(R__cl, R__insp.GetParent(), \"*fClass\", &fClass);\n\n      // If the class has a custom streamer and the type of the filed is a\n      // private enum, struct or class, skip it.\n      if (!insp.IsTreatingNonAccessibleTypes()){\n         auto iFiledQtype = iField->getType();\n         if (auto tagDecl = iFiledQtype->getAsTagDecl()){\n            auto declAccess = tagDecl->getAccess();\n            if (declAccess == AS_private || declAccess == AS_protected) {\n               continue;\n            }\n         }\n      }\n\n      insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), fieldName.c_str(), cobj + fieldOffset, isTransient);\n\n      if (!ispointer) {\n         const clang::CXXRecordDecl* fieldRecDecl = memNonPtrType->getAsCXXRecordDecl();\n         if (fieldRecDecl) {\n            // nested objects get an extra call to InspectMember\n            // R__insp.InspectMember(\"FileStat_t\", (void*)&fFileStat, \"fFileStat.\", false);\n            std::string sFieldRecName;\n            if (!ROOT::TMetaUtils::ExtractAttrPropertyFromName(*fieldRecDecl,\"iotype\",sFieldRecName)){\n               ROOT::TMetaUtils::GetNormalizedName(sFieldRecName,\n                                                   clang::QualType(memNonPtrType,0),\n                                                   *fInterpreter,\n                                                   *fNormalizedCtxt);\n            }\n\n            TDataMember* mbr = cl->GetDataMember(ioname.c_str());\n            // if we can not find the member (which should not really happen),\n            // let's consider it transient.\n            Bool_t transient = isTransient || !mbr || !mbr->IsPersistent();\n\n            insp.InspectMember(sFieldRecName.c_str(), cobj + fieldOffset,\n                               (fieldName + '.').c_str(), transient);\n\n         }\n      }\n   } // loop over fields\n\n   // inspect bases\n   // TNamed::ShowMembers(R__insp);\n   unsigned iNBase = 0;\n   for (clang::CXXRecordDecl::base_class_const_iterator iBase\n        = recordDecl->bases_begin(), eBase = recordDecl->bases_end();\n        iBase != eBase; ++iBase, ++iNBase) {\n      clang::QualType baseQT = iBase->getType();\n      if (baseQT.isNull()) {\n         Error(\"InspectMembers\",\n               \"Cannot find QualType for base number %d while inspecting class %s\",\n               iNBase, clname);\n         continue;\n      }\n      const clang::CXXRecordDecl* baseDecl\n         = baseQT->getAsCXXRecordDecl();\n      if (!baseDecl) {\n         Error(\"InspectMembers\",\n               \"Cannot find CXXRecordDecl for base number %d while inspecting class %s\",\n               iNBase, clname);\n         continue;\n      }\n      TClass* baseCl=nullptr;\n      std::string sBaseName;\n      // Try with the DeclId\n      std::vector<TClass*> foundClasses;\n      TClass::GetClass(static_cast<DeclId_t>(baseDecl), foundClasses);\n      if (foundClasses.size()==1){\n         baseCl=foundClasses[0];\n      } else {\n         // Try with the normalised Name, as a fallback\n         if (!baseCl){\n            ROOT::TMetaUtils::GetNormalizedName(sBaseName,\n                                                baseQT,\n                                                *fInterpreter,\n                                                *fNormalizedCtxt);\n            baseCl = TClass::GetClass(sBaseName.c_str());\n         }\n      }\n\n      if (!baseCl){\n         std::string qualNameForDiag;\n         ROOT::TMetaUtils::GetQualifiedName(qualNameForDiag, *baseDecl);\n         Error(\"InspectMembers\",\n               \"Cannot find TClass for base class %s\", qualNameForDiag.c_str() );\n         continue;\n      }\n\n      int64_t baseOffset;\n      if (iBase->isVirtual()) {\n         if (insp.GetObjectValidity() == TMemberInspector::kNoObjectGiven) {\n            if (!isTransient) {\n               Error(\"InspectMembers\",\n                     \"Base %s of class %s is virtual but no object provided\",\n                     sBaseName.c_str(), clname);\n            }\n            baseOffset = TVirtualStreamerInfo::kNeedObjectForVirtualBaseClass;\n         } else {\n            // We have an object to determine the vbase offset.\n            TClingClassInfo* ci = (TClingClassInfo*)cl->GetClassInfo();\n            TClingClassInfo* baseCi = (TClingClassInfo*)baseCl->GetClassInfo();\n            if (ci && baseCi) {\n               baseOffset = ci->GetBaseOffset(baseCi, const_cast<void*>(obj),\n                                              true /*isDerivedObj*/);\n               if (baseOffset == -1) {\n                  Error(\"InspectMembers\",\n                        \"Error calculating offset of virtual base %s of class %s\",\n                        sBaseName.c_str(), clname);\n               }\n            } else {\n               Error(\"InspectMembers\",\n                     \"Cannot calculate offset of virtual base %s of class %s\",\n                     sBaseName.c_str(), clname);\n               continue;\n            }\n         }\n      } else {\n         baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();\n      }\n      // TOFIX: baseCl can be null here!\n      if (baseCl->IsLoaded()) {\n         // For loaded class, CallShowMember will (especially for TObject)\n         // call the virtual ShowMember rather than the class specific version\n         // resulting in an infinite recursion.\n         InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);\n      } else {\n         baseCl->CallShowMembers(cobj + baseOffset,\n                                 insp, isTransient);\n      }\n   } // loop over bases\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter internal state in case a previous action was not correctly\n/// terminated.\n\nvoid TCling::ClearFileBusy()\n{\n   // No-op there is not equivalent state (to be cleared) in Cling.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete existing temporary values.\n\nvoid TCling::ClearStack()\n{\n   // No-op for cling due to cling::Value.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Declare code to the interpreter, without any of the interpreter actions\n/// that could trigger a re-interpretation of the code. I.e. make cling\n/// behave like a compiler: no dynamic lookup, no input wrapping for\n/// subsequent execution, no automatic provision of declarations but just a\n/// plain #include.\n/// Returns true on success, false on failure.\n\nbool TCling::Declare(const char* code)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n\n   int oldload = SetClassAutoloading(0);\n   SuspendAutoParsing autoParseRaii(this);\n\n   bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();\n   fInterpreter->enableDynamicLookup(false);\n   bool oldRawInput = fInterpreter->isRawInputEnabled();\n   fInterpreter->enableRawInput(true);\n\n   Bool_t ret = LoadText(code);\n\n   fInterpreter->enableRawInput(oldRawInput);\n   fInterpreter->enableDynamicLookup(oldDynLookup);\n   SetClassAutoloading(oldload);\n   return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable the automatic loading of shared libraries when a class\n/// is used that is stored in a not yet loaded library. Uses the\n/// information stored in the class/library map (typically\n/// $ROOTSYS/etc/system.rootmap).\n\nvoid TCling::EnableAutoLoading()\n{\n   if (fAllowLibLoad) {\n      LoadLibraryMap();\n      SetClassAutoloading(true);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// It calls a \"fantom\" method to synchronize user keyboard input\n/// and ROOT prompt line.\n\nvoid TCling::EndOfLineAction()\n{\n   ProcessLineSynch(fantomline);\n}\n\n// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling\n// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which\n// was already taking a lock.\nstatic Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter)\n{\n   // Check shared library.\n   TString tLibName(libname);\n   if (gSystem->FindDynamicLibrary(tLibName, kTRUE))\n      return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());\n   return false;\n}\n\nBool_t TCling::IsLibraryLoaded(const char* libname) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return s_IsLibraryLoaded(libname, fInterpreter);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the file has already been loaded by cint.\n/// We will try in this order:\n///   actual filename\n///   filename as a path relative to\n///            the include path\n///            the shared library path\n\nBool_t TCling::IsLoaded(const char* filename) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See\n   // cling::DynamicLibraryManager.\n\n   std::string file_name = filename;\n   size_t at = std::string::npos;\n   while ((at = file_name.find(\"/./\")) != std::string::npos)\n       file_name.replace(at, 3, \"/\");\n\n   std::string filesStr = \"\";\n   llvm::raw_string_ostream filesOS(filesStr);\n   clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();\n   cling::ClangInternalState::printIncludedFiles(filesOS, SM);\n   filesOS.flush();\n\n   llvm::SmallVector<llvm::StringRef, 100> files;\n   llvm::StringRef(filesStr).split(files, \"\\n\");\n\n   std::set<std::string> fileMap;\n   // Fill fileMap; return early on exact match.\n   for (llvm::SmallVector<llvm::StringRef, 100>::const_iterator\n           iF = files.begin(), iE = files.end(); iF != iE; ++iF) {\n      if ((*iF) == file_name.c_str()) return kTRUE; // exact match\n      fileMap.insert(*iF);\n   }\n\n   if (fileMap.empty()) return kFALSE;\n\n   // Check MacroPath.\n   TString sFilename(file_name.c_str());\n   if (gSystem->FindFile(TROOT::GetMacroPath(), sFilename, kReadPermission)\n       && fileMap.count(sFilename.Data())) {\n      return kTRUE;\n   }\n\n   // Check IncludePath.\n   TString incPath = gSystem->GetIncludePath(); // of the form -Idir1  -Idir2 -Idir3\n   incPath.Append(\":\").Prepend(\" \"); // to match \" -I\" (note leading ' ')\n   incPath.ReplaceAll(\" -I\", \":\");      // of form :dir1 :dir2:dir3\n   while (incPath.Index(\" :\") != -1) {\n      incPath.ReplaceAll(\" :\", \":\");\n   }\n   incPath.Prepend(\".:\");\n   sFilename = file_name.c_str();\n   if (gSystem->FindFile(incPath, sFilename, kReadPermission)\n       && fileMap.count(sFilename.Data())) {\n      return kTRUE;\n   }\n\n   // Check shared library.\n   if (s_IsLibraryLoaded(file_name.c_str(), fInterpreter))\n      return kTRUE;\n\n   //FIXME: We must use the cling::Interpreter::lookupFileOrLibrary iface.\n   const clang::DirectoryLookup *CurDir = 0;\n   clang::Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();\n   clang::HeaderSearch &HS = PP.getHeaderSearchInfo();\n   const clang::FileEntry *FE = HS.LookupFile(file_name.c_str(),\n                                              clang::SourceLocation(),\n                                              /*isAngled*/ false,\n                                              /*FromDir*/ 0, CurDir,\n                                              clang::ArrayRef<std::pair<const clang::FileEntry *,\n                                                                        const clang::DirectoryEntry *>>(),\n                                              /*SearchPath*/ 0,\n                                              /*RelativePath*/ 0,\n                                              /*RequestingModule*/ 0,\n                                              /*SuggestedModule*/ 0,\n                                              /*IsMapped*/ 0,\n                                              /*SkipCache*/ false,\n                                              /*BuildSystemModule*/ false,\n                                              /*OpenFile*/ false,\n                                              /*CacheFail*/ false);\n   if (FE && FE->isValid()) {\n      // check in the source manager if the file is actually loaded\n      clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();\n      // this works only with header (and source) files...\n      clang::FileID FID = SM.translateFile(FE);\n      if (!FID.isInvalid() && FID.getHashValue() == 0)\n         return kFALSE;\n      else {\n         clang::SrcMgr::SLocEntry SLocE = SM.getSLocEntry(FID);\n         if (SLocE.isFile() && SLocE.getFile().getContentCache()->getRawBuffer() == 0)\n            return kFALSE;\n         if (!FID.isInvalid())\n            return kTRUE;\n      }\n      // ...then check shared library again, but with full path now\n      sFilename = FE->getName();\n      if (gSystem->FindDynamicLibrary(sFilename, kTRUE)\n          && fileMap.count(sFilename.Data())) {\n         return kTRUE;\n      }\n   }\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::UpdateListOfLoadedSharedLibraries()\n{\n#if defined(R__WIN32) || defined(__CYGWIN__)\n   HMODULE hModules[1024];\n   void *hProcess;\n   unsigned long cbModules;\n   unsigned int i;\n   hProcess = (void *)::GetCurrentProcess();\n   ::EnumProcessModules(hProcess, hModules, sizeof(hModules), &cbModules);\n   // start at 1 to skip the executable itself\n   for (i = 1; i < (cbModules / sizeof(void *)); i++) {\n      static const int bufsize = 260;\n      wchar_t winname[bufsize];\n      char posixname[bufsize];\n      ::GetModuleFileNameExW(hProcess, hModules[i], winname, bufsize);\n#if defined(__CYGWIN__)\n      cygwin_conv_path(CCP_WIN_W_TO_POSIX, winname, posixname, bufsize);\n#else\n      std::wstring wpath = winname;\n      std::replace(wpath.begin(), wpath.end(), '\\\\', '/');\n      string path(wpath.begin(), wpath.end());\n      strncpy(posixname, path.c_str(), bufsize);\n#endif\n      if (!fSharedLibs.Contains(posixname)) {\n         RegisterLoadedSharedLibrary(posixname);\n      }\n   }\n#elif defined(R__MACOSX)\n   // fPrevLoadedDynLibInfo stores the *next* image index to look at\n   uint32_t imageIndex = (uint32_t) (size_t) fPrevLoadedDynLibInfo;\n\n   while (const mach_header* mh = _dyld_get_image_header(imageIndex)) {\n      // Skip non-dylibs\n      if (mh->filetype == MH_DYLIB) {\n         if (const char* imageName = _dyld_get_image_name(imageIndex)) {\n            RegisterLoadedSharedLibrary(imageName);\n         }\n      }\n\n      ++imageIndex;\n   }\n   fPrevLoadedDynLibInfo = (void*)(size_t)imageIndex;\n#elif defined(R__LINUX)\n   struct PointerNo4 {\n      void* fSkip[3];\n      void* fPtr;\n   };\n   struct LinkMap {\n      void* fAddr;\n      const char* fName;\n      void* fLd;\n      LinkMap* fNext;\n      LinkMap* fPrev;\n   };\n   if (!fPrevLoadedDynLibInfo || fPrevLoadedDynLibInfo == (void*)(size_t)-1) {\n      PointerNo4* procLinkMap = (PointerNo4*)dlopen(0,  RTLD_LAZY | RTLD_GLOBAL);\n      // 4th pointer of 4th pointer is the linkmap.\n      // See http://syprog.blogspot.fr/2011/12/listing-loaded-shared-objects-in-linux.html\n      LinkMap* linkMap = (LinkMap*) ((PointerNo4*)procLinkMap->fPtr)->fPtr;\n      RegisterLoadedSharedLibrary(linkMap->fName);\n      fPrevLoadedDynLibInfo = linkMap;\n      // reduce use count of link map structure:\n      dlclose(procLinkMap);\n   }\n\n   LinkMap* iDyLib = (LinkMap*)fPrevLoadedDynLibInfo;\n   while (iDyLib->fNext) {\n      iDyLib = iDyLib->fNext;\n      RegisterLoadedSharedLibrary(iDyLib->fName);\n   }\n   fPrevLoadedDynLibInfo = iDyLib;\n#else\n   Error(\"TCling::UpdateListOfLoadedSharedLibraries\",\n         \"Platform not supported!\");\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register a new shared library name with the interpreter; add it to\n/// fSharedLibs.\n\nvoid TCling::RegisterLoadedSharedLibrary(const char* filename)\n{\n   // Ignore NULL filenames, aka \"the process\".\n   if (!filename) return;\n\n   // Tell the interpreter that this library is available; all libraries can be\n   // used to resolve symbols.\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   if (!DLM->isLibraryLoaded(filename)) {\n      DLM->loadLibrary(filename, true /*permanent*/);\n   }\n\n#if defined(R__MACOSX)\n   // Check that this is not a system library\n   if (!strncmp(filename, \"/usr/lib/system/\", 16)\n       || !strncmp(filename, \"/usr/lib/libc++\", 15)\n       || !strncmp(filename, \"/System/Library/Frameworks/\", 27)\n       || !strncmp(filename, \"/System/Library/PrivateFrameworks/\", 34)\n       || !strncmp(filename, \"/System/Library/CoreServices/\", 29)\n       || !strcmp(filename, \"cl_kernels\") // yepp, no directory\n       || strstr(filename, \"/usr/lib/libSystem\")\n       || strstr(filename, \"/usr/lib/libstdc++\")\n       || strstr(filename, \"/usr/lib/libicucore\")\n       || strstr(filename, \"/usr/lib/libbsm\")\n       || strstr(filename, \"/usr/lib/libobjc\")\n       || strstr(filename, \"/usr/lib/libresolv\")\n       || strstr(filename, \"/usr/lib/libauto\")\n       || strstr(filename, \"/usr/lib/libcups\")\n       || strstr(filename, \"/usr/lib/libDiagnosticMessagesClient\")\n       || strstr(filename, \"/usr/lib/liblangid\")\n       || strstr(filename, \"/usr/lib/libCRFSuite\")\n       || strstr(filename, \"/usr/lib/libpam\")\n       || strstr(filename, \"/usr/lib/libOpenScriptingUtil\")\n       || strstr(filename, \"/usr/lib/libextension\"))\n      return;\n#elif defined(__CYGWIN__)\n   // Check that this is not a system library\n   static const int bufsize = 260;\n   char posixwindir[bufsize];\n   char *windir = getenv(\"WINDIR\");\n   if (windir)\n      cygwin_conv_path(CCP_WIN_A_TO_POSIX, windir, posixwindir, bufsize);\n   else\n      snprintf(posixwindir, sizeof(posixwindir), \"/Windows/\");\n   if (strstr(filename, posixwindir) ||\n       strstr(filename, \"/usr/bin/cyg\"))\n      return;\n#elif defined(R__WIN32)\n   if (strstr(filename, \"/Windows/\"))\n      return;\n#elif defined (R__LINUX)\n   if (strstr(filename, \"/ld-linux\")\n       || strstr(filename, \"linux-gnu/\")\n       || strstr(filename, \"/libstdc++.\")\n       || strstr(filename, \"/libgcc\")\n       || strstr(filename, \"/libc.\")\n       || strstr(filename, \"/libdl.\")\n       || strstr(filename, \"/libm.\"))\n      return;\n#endif\n   // Update string of available libraries.\n   if (!fSharedLibs.IsNull()) {\n      fSharedLibs.Append(\" \");\n   }\n   fSharedLibs.Append(filename);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a library file in cling's memory.\n/// if 'system' is true, the library is never unloaded.\n/// Return 0 on success, -1 on failure.\n\nInt_t TCling::Load(const char* filename, Bool_t system)\n{\n   if (!fAllowLibLoad) {\n      Error(\"Load\",\"Trying to load library (%s) from rootcling.\",filename);\n      return -1;\n   }\n\n   // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on \"fatal\".\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   std::string canonLib = DLM->lookupLibrary(filename);\n   cling::DynamicLibraryManager::LoadLibResult res\n      = cling::DynamicLibraryManager::kLoadLibNotFound;\n   if (!canonLib.empty()) {\n      if (system)\n         res = DLM->loadLibrary(filename, system);\n      else {\n         // For the non system libs, we'd like to be able to unload them.\n         // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.\n         cling::Interpreter::CompilationResult compRes;\n         HandleInterpreterException(fMetaProcessor, Form(\".L %s\", canonLib.c_str()), compRes, /*cling::Value*/0);\n         if (compRes == cling::Interpreter::kSuccess)\n            res = cling::DynamicLibraryManager::kLoadLibSuccess;\n      }\n   }\n\n   if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {\n      UpdateListOfLoadedSharedLibraries();\n   }\n   switch (res) {\n   case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;\n   case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded:  return 1;\n   default: break;\n   };\n   return -1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a macro file in cling's memory.\n\nvoid TCling::LoadMacro(const char* filename, EErrorCode* error)\n{\n   ProcessLine(Form(\".L %s\", filename), error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line asynch.\n\nLong_t TCling::ProcessLineAsynch(const char* line, EErrorCode* error)\n{\n   return ProcessLine(line, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let cling process a command line synchronously, i.e we are waiting\n/// it will be finished.\n\nLong_t TCling::ProcessLineSynch(const char* line, EErrorCode* error)\n{\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   if (gApplication) {\n      if (gApplication->IsCmdThread()) {\n         return ProcessLine(line, error);\n      }\n      return 0;\n   }\n   return ProcessLine(line, error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Directly execute an executable statement (e.g. \"func()\", \"3+5\", etc.\n/// however not declarations, like \"Int_t x;\").\n\nLong_t TCling::Calc(const char* line, EErrorCode* error)\n{\n#ifdef R__WIN32\n   // Test on ApplicationImp not being 0 is needed because only at end of\n   // TApplication ctor the IsLineProcessing flag is set to 0, so before\n   // we can not use it.\n   if (gApplication && gApplication->GetApplicationImp()) {\n      while (gROOT->IsLineProcessing() && !gApplication) {\n         Warning(\"Calc\", \"waiting for cling thread to free\");\n         gSystem->Sleep(500);\n      }\n      gROOT->SetLineIsProcessing();\n   }\n#endif // R__WIN32\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   cling::Value valRef;\n   cling::Interpreter::CompilationResult cr = fInterpreter->evaluate(line, valRef);\n   if (cr != cling::Interpreter::kSuccess) {\n      // Failure in compilation.\n      if (error) {\n         // Note: Yes these codes are weird.\n         *error = TInterpreter::kRecoverable;\n      }\n      return 0L;\n   }\n   if (!valRef.isValid()) {\n      // Failure at runtime.\n      if (error) {\n         // Note: Yes these codes are weird.\n         *error = TInterpreter::kDangerous;\n      }\n      return 0L;\n   }\n\n   if (valRef.isVoid()) {\n      return 0;\n   }\n\n   RegisterTemporary(valRef);\n#ifdef R__WIN32\n   if (gApplication && gApplication->GetApplicationImp()) {\n      gROOT->SetLineHasBeenProcessed();\n   }\n#endif // R__WIN32\n   return valRef.simplisticCastAs<long>();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a getline function to call when input is needed.\n\nvoid TCling::SetGetline(const char * (*getlineFunc)(const char* prompt),\n                                void (*histaddFunc)(const char* line))\n{\n   // If cling offers a replacement for G__pause(), it would need to\n   // also offer a way to customize at least the history recording.\n\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetGetline\",\"Cling should support the equivalent of SetGetlineFunc(getlineFunc, histaddFunc)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function to increase the internal Cling count of transactions\n/// that change the AST.\n\nBool_t TCling::HandleNewTransaction(const cling::Transaction &T)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if ((std::distance(T.decls_begin(), T.decls_end()) != 1)\n      || T.deserialized_decls_begin() != T.deserialized_decls_end()\n      || T.macros_begin() != T.macros_end()\n      || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {\n      fTransactionCount++;\n      return true;\n   }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete object from cling symbol table so it can not be used anymore.\n/// cling objects are always on the heap.\n\nvoid TCling::RecursiveRemove(TObject* obj)\n{\n   // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**\n   // put in place the Read/Write part here.  Keeping the write lock\n   // here is 'catasptrophic' for scaling as it means that ALL calls\n   // to RecursiveRemove will take the write lock and performance\n   // of many threads trying to access the write lock at the same\n   // time is relatively bad.\n   R__READ_LOCKGUARD(ROOT::gCoreMutex);\n   // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal\n   // (but isn't at the moment).\n   if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {\n      std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);\n      if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {\n         R__WRITE_LOCKGUARD(ROOT::gCoreMutex);\n         DeleteGlobal(obj);\n         ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Pressing Ctrl+C should forward here. In the case where we have had\n/// continuation requested we must reset it.\n\nvoid TCling::Reset()\n{\n   fMetaProcessor->cancelContinuation();\n   // Reset the Cling state to the state saved by the last call to\n   // TCling::SaveContext().\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"Reset\",\"Cling should support the equivalent of scratch_upto(&fDictPos)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the Cling state to its initial state.\n\nvoid TCling::ResetAll()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"ResetAll\",\"Cling should support the equivalent of complete reset (unload everything but the startup decls.\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset in Cling the list of global variables to the state saved by the last\n/// call to TCling::SaveGlobalsContext().\n///\n/// Note: Right now, all we do is run the global destructors.\n\nvoid TCling::ResetGlobals()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // TODO:\n   // Here we should iterate over the transactions (N-3) and revert.\n   // N-3 because the first three internal to cling.\n\n   fInterpreter->runAndRemoveStaticDestructors();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the Cling 'user' global objects/variables state to the state saved by the last\n/// call to TCling::SaveGlobalsContext().\n\nvoid TCling::ResetGlobalVar(void* obj)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"ResetGlobalVar\",\"Cling should support the equivalent of resetglobalvar(obj)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Rewind Cling dictionary to the point where it was before executing\n/// the current macro. This function is typically called after SEGV or\n/// ctlr-C after doing a longjmp back to the prompt.\n\nvoid TCling::RewindDictionary()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"RewindDictionary\",\"Cling should provide a way to revert transaction similar to rewinddictionary()\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete obj from Cling symbol table so it cannot be accessed anymore.\n/// Returns 1 in case of success and 0 in case object was not in table.\n\nInt_t TCling::DeleteGlobal(void* obj)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"DeleteGlobal\",\"Cling should provide the equivalent of deleteglobal(obj), see also DeleteVariable.\");\n#endif\n#endif\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Undeclare obj called name.\n/// Returns 1 in case of success, 0 for failure.\n\nInt_t TCling::DeleteVariable(const char* name)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"DeleteVariable\",\"should do more that just reseting the value to zero\");\n#endif\n#endif\n\n   R__LOCKGUARD(gInterpreterMutex);\n   llvm::StringRef srName(name);\n   const char* unscopedName = name;\n   llvm::StringRef::size_type posScope = srName.rfind(\"::\");\n   const clang::DeclContext* declCtx = 0;\n   if (posScope != llvm::StringRef::npos) {\n      const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n      const clang::Decl* scopeDecl\n         = lh.findScope(srName.substr(0, posScope),\n                        cling::LookupHelper::WithDiagnostics);\n      if (!scopeDecl) {\n         Error(\"DeleteVariable\", \"Cannot find enclosing scope for variable %s\",\n               name);\n         return 0;\n      }\n      declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);\n      if (!declCtx) {\n         Error(\"DeleteVariable\",\n               \"Enclosing scope for variable %s is not a declaration context\",\n               name);\n         return 0;\n      }\n      unscopedName += posScope + 2;\n   }\n   // Could trigger deserialization of decls.\n   cling::Interpreter::PushTransactionRAII RAII(fInterpreter);\n   clang::NamedDecl* nVarDecl\n      = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);\n   if (!nVarDecl) {\n      Error(\"DeleteVariable\", \"Unknown variable %s\", name);\n      return 0;\n   }\n   clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);\n   if (!varDecl) {\n      Error(\"DeleteVariable\", \"Entity %s is not a variable\", name);\n      return 0;\n   }\n\n   clang::QualType qType = varDecl->getType();\n   const clang::Type* type = qType->getUnqualifiedDesugaredType();\n   // Cannot set a reference's address to nullptr; the JIT can place it\n   // into read-only memory (ROOT-7100).\n   if (type->isPointerType()) {\n      int** ppInt = (int**)fInterpreter->getAddressOfGlobal(GlobalDecl(varDecl));\n      // set pointer to invalid.\n      if (ppInt) *ppInt = 0;\n   }\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current Cling state.\n\nvoid TCling::SaveContext()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"SaveContext\",\"Cling should provide a way to record a state watermark similar to store_dictposition(&fDictPos)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Save the current Cling state of global objects.\n\nvoid TCling::SaveGlobalsContext()\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   R__LOCKGUARD(gInterpreterMutex);\n   Warning(\"SaveGlobalsContext\",\"Cling should provide a way to record a watermark for the list of global variable similar to store_dictposition(&fDictPosGlobals)\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of globals)\n\nvoid TCling::UpdateListOfGlobals()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of global functions)\n\nvoid TCling::UpdateListOfGlobalFunctions()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks (used to update the list of types)\n\nvoid TCling::UpdateListOfTypes()\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check in what order the member of a tuple are layout.\nenum class ETupleOrdering {\n   kAscending,\n   kDescending,\n   kUnexpected\n};\n\nstruct AlternateTupleIntDoubleAsc\n{\n   Int_t    _0;\n   Double_t _1;\n};\n\nstruct AlternateTupleIntDoubleDes\n{\n   Double_t _1;\n   Int_t    _0;\n};\n\nstatic ETupleOrdering IsTupleAscending()\n{\n   std::tuple<int,double> value;\n   AlternateTupleIntDoubleAsc asc;\n   AlternateTupleIntDoubleDes des;\n\n   size_t offset0 = ((char*)&(std::get<0>(value))) - ((char*)&value);\n   size_t offset1 = ((char*)&(std::get<1>(value))) - ((char*)&value);\n\n   size_t ascOffset0 = ((char*)&(asc._0)) - ((char*)&asc);\n   size_t ascOffset1 = ((char*)&(asc._1)) - ((char*)&asc);\n\n   size_t desOffset0 = ((char*)&(des._0)) - ((char*)&des);\n   size_t desOffset1 = ((char*)&(des._1)) - ((char*)&des);\n\n   if (offset0 == ascOffset0 && offset1 == ascOffset1) {\n      return ETupleOrdering::kAscending;\n   } else if (offset0 == desOffset0 && offset1 == desOffset1) {\n      return ETupleOrdering::kDescending;\n   } else {\n      return ETupleOrdering::kUnexpected;\n   }\n}\n\nstd::string AlternateTuple(const char *classname)\n{\n   TClassEdit::TSplitType tupleContent(classname);\n   std::string alternateName = \"TEmulatedTuple\";\n   alternateName.append( classname + 5 );\n\n   std::string guard_name;\n   ROOT::TMetaUtils::GetCppName(guard_name,alternateName.c_str());\n   std::ostringstream guard;\n   guard << \"ROOT_INTERNAL_TEmulated_\";\n   guard << guard_name;\n\n   std::ostringstream alternateTuple;\n   alternateTuple << \"#ifndef \" << guard.str() << \"\\n\";\n   alternateTuple << \"#define \" << guard.str() << \"\\n\";\n   alternateTuple << \"namespace ROOT { namespace Internal {\\n\";\n   alternateTuple << \"template <class... Types> struct TEmulatedTuple;\\n\";\n   alternateTuple << \"template <> struct \" << alternateName << \" {\\n\";\n\n   // This could also be a compile time choice ...\n   switch(IsTupleAscending()) {\n      case ETupleOrdering::kAscending: {\n         unsigned int nMember = 0;\n         auto iter = tupleContent.fElements.begin() + 1; // Skip the template name (tuple)\n         auto theEnd = tupleContent.fElements.end() - 1; // skip the 'stars'.\n         while (iter != theEnd) {\n            alternateTuple << \"   \" << *iter << \" _\" << nMember << \";\\n\";\n            ++iter;\n            ++nMember;\n         }\n         break;\n      }\n      case ETupleOrdering::kDescending: {\n         unsigned int nMember = tupleContent.fElements.size() - 3;\n         auto iter = tupleContent.fElements.rbegin() + 1; // Skip the template name (tuple)\n         auto theEnd = tupleContent.fElements.rend() - 1; // skip the 'stars'.\n         while (iter != theEnd) {\n            alternateTuple << \"   \" << *iter << \" _\" << nMember << \";\\n\";\n            ++iter;\n            --nMember;\n         }\n         break;\n      }\n      case ETupleOrdering::kUnexpected: {\n         Fatal(\"TCling::SetClassInfo::AlternateTuple\",\n               \"Layout of std::tuple on this platform is unexpected.\");\n         break;\n      }\n   }\n\n   alternateTuple << \"};\\n\";\n   alternateTuple << \"}}\\n\";\n   alternateTuple << \"#endif\\n\";\n   if (!gCling->Declare(alternateTuple.str().c_str())) {\n      Error(\"Load\",\"Could not declare %s\",alternateName.c_str());\n      return \"\";\n   }\n   alternateName = \"ROOT::Internal::\" + alternateName;\n   return alternateName;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set pointer to the TClingClassInfo in TClass.\n/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we\n/// already have one.\n\nvoid TCling::SetClassInfo(TClass* cl, Bool_t reload)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl->fClassInfo && !reload) {\n      return;\n   }\n   //Remove the decl_id from the DeclIdToTClass map\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;\n   if (TClinginfo) {\n      TClass::RemoveClassDeclId(TClinginfo->GetDeclId());\n   }\n   delete TClinginfo;\n   cl->fClassInfo = 0;\n   std::string name(cl->GetName());\n\n   // Handle the special case of 'tuple' where we ignore the real implementation\n   // details and just overlay a 'simpler'/'simplistic' version that is easy\n   // for the I/O to understand and handle.\n   if (!(fCxxModulesEnabled && IsFromRootCling()) && strncmp(cl->GetName(),\"tuple<\",strlen(\"tuple<\"))==0) {\n\n      name = AlternateTuple(cl->GetName());\n\n   }\n\n   TClingClassInfo* info = new TClingClassInfo(fInterpreter, name.c_str());\n   if (!info->IsValid()) {\n      if (cl->fState != TClass::kHasTClassInit) {\n         if (cl->fStreamerInfo->GetEntries() != 0) {\n            cl->fState = TClass::kEmulated;\n         } else {\n            cl->fState = TClass::kForwardDeclared;\n         }\n      }\n      delete info;\n      return;\n   }\n   cl->fClassInfo = (ClassInfo_t*)info; // Note: We are transferring ownership here.\n   // In case a class contains an external enum, the enum will be seen as a\n   // class. We must detect this special case and make the class a Zombie.\n   // Here we assume that a class has at least one method.\n   // We can NOT call TClass::Property from here, because this method\n   // assumes that the TClass is well formed to do a lot of information\n   // caching. The method SetClassInfo (i.e. here) is usually called during\n   // the building phase of the TClass, hence it is NOT well formed yet.\n   Bool_t zombieCandidate = kFALSE;\n   if (\n      info->IsValid() &&\n      !(info->Property() & (kIsClass | kIsStruct | kIsNamespace))\n   ) {\n      zombieCandidate = kTRUE;\n   }\n   if (!info->IsLoaded()) {\n      if (info->Property() & (kIsNamespace)) {\n         // Namespaces can have info but no corresponding CINT dictionary\n         // because they are auto-created if one of their contained\n         // classes has a dictionary.\n         zombieCandidate = kTRUE;\n      }\n      // this happens when no dictionary is available\n      delete info;\n      cl->fClassInfo = 0;\n   }\n   if (zombieCandidate && !cl->GetCollectionType()) {\n      cl->MakeZombie();\n   }\n   // If we reach here, the info was valid (See early returns).\n   if (cl->fState != TClass::kHasTClassInit) {\n      if (cl->fClassInfo) {\n         cl->fState = TClass::kInterpreted;\n         cl->ResetBit(TClass::kIsEmulation);\n      } else {\n//         if (TClassEdit::IsSTLCont(cl->GetName()) {\n//            There will be an emulated collection proxy, is that the same?\n//            cl->fState = TClass::kEmulated;\n//         } else {\n         if (cl->fStreamerInfo->GetEntries() != 0) {\n            cl->fState = TClass::kEmulated;\n         } else {\n            cl->fState = TClass::kForwardDeclared;\n         }\n//         }\n      }\n   }\n   if (cl->fClassInfo) {\n      TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Checks if an entity with the specified name is defined in Cling.\n/// Returns kUnknown if the entity is not defined.\n/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline\n/// Returns kKnown if the entity is defined.\n///\n/// By default, structs, namespaces, classes, enums and unions are looked for.\n/// If the flag isClassOrNamespaceOnly is true, classes, structs and\n/// namespaces only are considered. I.e. if the name is an enum or a union,\n/// the returned value is false.\n///\n/// In the case where the class is not loaded and belongs to a namespace\n/// or is nested, looking for the full class name is outputting a lots of\n/// (expected) error messages.  Currently the only way to avoid this is to\n/// specifically check that each level of nesting is already loaded.\n/// In case of templates the idea is that everything between the outer\n/// '<' and '>' has to be skipped, e.g.: aap<pippo<noot>::klaas>::a_class\n\nTInterpreter::ECheckClassInfo\nTCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   static const char *anonEnum = \"anonymous enum \";\n   static const int cmplen = strlen(anonEnum);\n\n   if (0 == strncmp(name,anonEnum,cmplen)) {\n      return kUnknown;\n   }\n\n   // Avoid the double search below in case the name is a fundamental type\n   // or typedef to a fundamental type.\n   THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );\n   TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );\n\n   if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject\n       && fundType->GetType() > 0) {\n      // Fundamental type, no a class.\n      return kUnknown;\n   }\n\n   // Migrated from within TClass::GetClass\n   // If we want to know if a class or a namespace with this name exists in the\n   // interpreter and this is an enum in the type system, before or after loading\n   // according to the autoload function argument, return kUnknown.\n   if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone))\n      return kUnknown;\n\n   const char *classname = name;\n\n   int storeAutoload = SetClassAutoloading(autoload);\n\n   // First we want to check whether the decl exist, but _without_\n   // generating any template instantiation. However, the lookup\n   // still will create a forward declaration of the class template instance\n   // if it exist.  In this case, the return value of findScope will still\n   // be zero but the type will be initialized.\n   // Note in the corresponding code in ROOT 5, CINT was not instantiating\n   // this forward declaration.\n   const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n   const clang::Type *type = 0;\n   const clang::Decl *decl\n      = lh.findScope(classname,\n                     gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                     : cling::LookupHelper::NoDiagnostics,\n                     &type, /* intantiateTemplate= */ false );\n   if (!decl) {\n      std::string buf = TClassEdit::InsertStd(classname);\n      decl = lh.findScope(buf,\n                          gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                          : cling::LookupHelper::NoDiagnostics,\n                          &type,false);\n   }\n\n   if (type) {\n      // If decl==0 and the type is valid, then we have a forward declaration.\n      if (!decl) {\n         // If we have a forward declaration for a class template instantiation,\n         // we want to ignore it if it was produced/induced by the call to\n         // findScope, however we can not distinguish those from the\n         // instantiation induce by 'soft' use (and thus also induce by the\n         // same underlying code paths)\n         // ['soft' use = use not requiring a complete definition]\n         // So to reduce the amount of disruption to the existing code we\n         // would just ignore those for STL collection, for which we really\n         // need to have the compiled collection proxy (and thus the TClass\n         // bootstrap).\n         clang::ClassTemplateSpecializationDecl *tmpltDecl =\n            llvm::dyn_cast_or_null<clang::ClassTemplateSpecializationDecl>\n               (type->getAsCXXRecordDecl());\n         if (tmpltDecl && !tmpltDecl->getPointOfInstantiation().isValid()) {\n            // Since the point of instantiation is invalid, we 'guess' that\n            // the 'instantiation' of the forwarded type appended in\n            // findscope.\n            if (ROOT::TMetaUtils::IsSTLCont(*tmpltDecl)) {\n               // For STL Collection we return kUnknown.\n               SetClassAutoloading(storeAutoload);\n               return kUnknown;\n            }\n         }\n      }\n      TClingClassInfo tci(fInterpreter, *type);\n      if (!tci.IsValid()) {\n         SetClassAutoloading(storeAutoload);\n         return kUnknown;\n      }\n      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsNamespace :\n                                                     kIsClass | kIsStruct | kIsNamespace | kIsEnum | kIsUnion;\n\n      if (tci.Property() & propertiesMask) {\n         bool hasClassDefInline = false;\n         if (isClassOrNamespaceOnly) {\n            // We do not need to check for ClassDefInline when this is called from\n            // TClass::Init, we only do it for the call from TClass::GetClass.\n            auto hasDictionary = tci.GetMethod(\"Dictionary\", \"\", false, 0, ROOT::kExactMatch);\n            auto implLineFunc = tci.GetMethod(\"ImplFileLine\", \"\", false, 0, ROOT::kExactMatch);\n\n            if (hasDictionary.IsValid() && implLineFunc.IsValid()) {\n               int lineNumber = 0;\n               bool success = false;\n               std::tie(success, lineNumber) =\n                  ROOT::TMetaUtils::GetTrivialIntegralReturnValue(implLineFunc.GetMethodDecl(), *fInterpreter);\n               hasClassDefInline = success && (lineNumber == -1);\n            }\n         }\n\n         // fprintf(stderr,\"CheckClassInfo: %s had dict=%d  inline=%d\\n\",name,hasDictionary.IsValid()\n         // , hasClassDefInline);\n\n         // We are now sure that the entry is not in fact an autoload entry.\n         SetClassAutoloading(storeAutoload);\n         if (hasClassDefInline)\n            return kWithClassDefInline;\n         else\n            return kKnown;\n      } else {\n         // We are now sure that the entry is not in fact an autoload entry.\n         SetClassAutoloading(storeAutoload);\n         return kUnknown;\n      }\n   }\n\n   SetClassAutoloading(storeAutoload);\n   if (decl)\n      return kKnown;\n   else\n      return kUnknown;\n\n   // Setting up iterator part of TClingTypedefInfo is too slow.\n   // Copy the lookup code instead:\n   /*\n   TClingTypedefInfo t(fInterpreter, name);\n   if (t.IsValid() && !(t.Property() & kIsFundamental)) {\n      delete[] classname;\n      SetClassAutoloading(storeAutoload);\n      return kTRUE;\n   }\n   */\n\n//   const clang::Decl *decl = lh.findScope(name);\n//   if (!decl) {\n//      std::string buf = TClassEdit::InsertStd(name);\n//      decl = lh.findScope(buf);\n//   }\n\n//   SetClassAutoloading(storeAutoload);\n//   return (decl);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if there is a class template by the given name ...\n\nBool_t TCling::CheckClassTemplate(const char *name)\n{\n   const cling::LookupHelper& lh = fInterpreter->getLookupHelper();\n   const clang::Decl *decl\n      = lh.findClassTemplate(name,\n                             gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                             : cling::LookupHelper::NoDiagnostics);\n   if (!decl) {\n      std::string strname = \"std::\";\n      strname += name;\n      decl = lh.findClassTemplate(strname,\n                                  gDebug > 5 ? cling::LookupHelper::WithDiagnostics\n                                  : cling::LookupHelper::NoDiagnostics);\n   }\n   return 0 != decl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to base class(es) for TClass cl.\n\nvoid TCling::CreateListOfBaseClasses(TClass *cl) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl->fBase) {\n      return;\n   }\n   TClingClassInfo *tci = (TClingClassInfo *)cl->GetClassInfo();\n   if (!tci) return;\n   TClingBaseClassInfo t(fInterpreter, tci);\n   TList *listOfBase = new TList;\n   while (t.Next()) {\n      // if name cannot be obtained no use to put in list\n      if (t.IsValid() && t.Name()) {\n         TClingBaseClassInfo *a = new TClingBaseClassInfo(t);\n         listOfBase->Add(new TBaseClass((BaseClassInfo_t *)a, cl));\n      }\n   }\n   // Now that is complete, publish it.\n   cl->fBase = listOfBase;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to enums for TClass cl.\n\nvoid TCling::LoadEnums(TListOfEnums& enumList) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const Decl * D;\n   TClass* cl = enumList.GetClass();\n   if (cl) {\n      D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();\n   }\n   else {\n      D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n   }\n   // Iterate on the decl of the class and get the enums.\n   if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {\n      cling::Interpreter::PushTransactionRAII deserRAII(fInterpreter);\n      // Collect all contexts of the namespace.\n      llvm::SmallVector< DeclContext *, 4> allDeclContexts;\n      const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);\n      for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(), declEnd = allDeclContexts.end();\n           declIter != declEnd; ++declIter) {\n         // Iterate on all decls for each context.\n         for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),\n              DE = (*declIter)->decls_end(); DI != DE; ++DI) {\n            if (const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(*DI)) {\n               // Get name of the enum type.\n               std::string buf;\n               PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());\n               llvm::raw_string_ostream stream(buf);\n               // Don't trigger fopen of the source file to count lines:\n               Policy.AnonymousTagLocations = false;\n               ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);\n               stream.flush();\n               // If the enum is unnamed we do not add it to the list of enums i.e unusable.\n               if (!buf.empty()) {\n                  const char* name = buf.c_str();\n                  // Add the enum to the list of loaded enums.\n                  enumList.Get(ED, name);\n               }\n            }\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to function templates for TClass cl.\n\nvoid TCling::LoadFunctionTemplates(TClass* cl) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const Decl * D;\n   TListOfFunctionTemplates* funcTempList;\n   if (cl) {\n      D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();\n      funcTempList = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates(false);\n   }\n   else {\n      D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n      funcTempList = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();\n   }\n   // Iterate on the decl of the class and get the enums.\n   if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {\n      cling::Interpreter::PushTransactionRAII deserRAII(fInterpreter);\n      // Collect all contexts of the namespace.\n      llvm::SmallVector< DeclContext *, 4> allDeclContexts;\n      const_cast< clang::DeclContext *>(DC)->collectAllContexts(allDeclContexts);\n      for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(),\n           declEnd = allDeclContexts.end(); declIter != declEnd; ++declIter) {\n         // Iterate on all decls for each context.\n         for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),\n              DE = (*declIter)->decls_end(); DI != DE; ++DI) {\n            if (const clang::FunctionTemplateDecl* FTD = dyn_cast<clang::FunctionTemplateDecl>(*DI)) {\n                  funcTempList->Get(FTD);\n            }\n         }\n      }\n   }\n}\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to data members for TClass cl.\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfDataMembers.\n\nvoid TCling::CreateListOfDataMembers(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to methods for TClass cl.\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfFunctions.\n\nvoid TCling::CreateListOfMethods(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update the list of pointers to method for TClass cl\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfFunctions.\n\nvoid TCling::UpdateListOfMethods(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update the list of pointers to data members for TClass cl\n/// This is now a nop.  The creation and updating is handled in\n/// TListOfDataMembers.\n\nvoid TCling::UpdateListOfDataMembers(TClass* cl) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create list of pointers to method arguments for TMethod m.\n\nvoid TCling::CreateListOfMethodArgs(TFunction* m) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (m->fMethodArgs) {\n      return;\n   }\n   TList *arglist = new TList;\n   TClingMethodArgInfo t(fInterpreter, (TClingMethodInfo*)m->fInfo);\n   while (t.Next()) {\n      if (t.IsValid()) {\n         TClingMethodArgInfo* a = new TClingMethodArgInfo(t);\n         arglist->Add(new TMethodArg((MethodArgInfo_t*)a, m));\n      }\n   }\n   m->fMethodArgs = arglist;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate a TClass for the given class.\n/// Since the caller has already check the ClassInfo, let it give use the\n/// result (via the value of emulation) rather than recalculate it.\n\nTClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent /* = kFALSE */)\n{\n// For now the following line would lead to the (unwanted) instantiation\n// of class template.  This could/would need to be resurrected only if\n// we re-introduce so sort of automatic instantiation.   However this would\n// have to include carefull look at the template parameter to avoid\n// creating instance we can not really use (if the parameter are only forward\n// declaration or do not have all the necessary interfaces).\n\n   //   TClingClassInfo tci(fInterpreter, classname);\n   //   if (1 || !tci.IsValid()) {\n\n   Version_t version = 1;\n   if (TClassEdit::IsSTLCont(classname)) {\n      version = TClass::GetClass(\"TVirtualStreamerInfo\")->GetClassVersion();\n   }\n   TClass *cl = new TClass(classname, version, silent);\n   if (emulation) {\n      cl->SetBit(TClass::kIsEmulation);\n   } else {\n      // Set the class version if the class is versioned.\n      // Note that we cannot just call CLASS::Class_Version() as we might not have\n      // an execution engine (when invoked from rootcling).\n\n      // Do not call cl->GetClassVersion(), it has side effects!\n      Version_t oldvers = cl->fClassVersion;\n      if (oldvers == version && cl->GetClassInfo()) {\n         // We have a version and it might need an update.\n         Version_t newvers = oldvers;\n         TClingClassInfo* cli = (TClingClassInfo*)cl->GetClassInfo();\n         if (llvm::isa<clang::NamespaceDecl>(cli->GetDecl())) {\n            // Namespaces don't have class versions.\n            return cl;\n         }\n         TClingMethodInfo mi = cli->GetMethod(\"Class_Version\", \"\", 0 /*poffset*/,\n                                              ROOT::kExactMatch,\n                                              TClingClassInfo::kInThisScope);\n         if (!mi.IsValid()) {\n            if (cl->TestBit(TClass::kIsTObject)) {\n               Error(\"GenerateTClass\",\n                     \"Cannot find %s::Class_Version()! Class version might be wrong.\",\n                     cl->GetName());\n            }\n            return cl;\n         }\n         newvers = ROOT::TMetaUtils::GetClassVersion(llvm::dyn_cast<clang::RecordDecl>(cli->GetDecl()),\n                                                     *fInterpreter);\n         if (newvers == -1) {\n            // Didn't manage to determine the class version from the AST.\n            // Use runtime instead.\n            if ((mi.Property() & kIsStatic)\n                && !fInterpreter->isInSyntaxOnlyMode()) {\n               // This better be a static function.\n               TClingCallFunc callfunc(fInterpreter, *fNormalizedCtxt);\n               callfunc.SetFunc(&mi);\n               newvers = callfunc.ExecInt(0);\n            } else {\n               Error(\"GenerateTClass\",\n                     \"Cannot invoke %s::Class_Version()! Class version might be wrong.\",\n                     cl->GetName());\n            }\n         }\n         if (newvers != oldvers) {\n            cl->fClassVersion = newvers;\n            cl->fStreamerInfo->Expand(newvers + 2 + 10);\n         }\n      }\n   }\n\n   return cl;\n\n//   } else {\n//      return GenerateTClass(&tci,silent);\n//   }\n}\n\n#if 0\n////////////////////////////////////////////////////////////////////////////////\n\nstatic void GenerateTClass_GatherInnerIncludes(cling::Interpreter *interp, TString &includes,TClingClassInfo *info)\n{\n   includes += info->FileName();\n\n   const clang::ClassTemplateSpecializationDecl *templateCl\n      = llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(info->GetDecl());\n   if (templateCl) {\n      for(unsigned int i=0; i <  templateCl->getTemplateArgs().size(); ++i) {\n          const clang::TemplateArgument &arg( templateCl->getTemplateArgs().get(i) );\n          if (arg.getKind() == clang::TemplateArgument::Type) {\n             const clang::Type *uType = ROOT::TMetaUtils::GetUnderlyingType( arg.getAsType() );\n\n            if (!uType->isFundamentalType() && !uType->isEnumeralType()) {\n               // We really need a header file.\n               const clang::CXXRecordDecl *argdecl = uType->getAsCXXRecordDecl();\n               if (argdecl) {\n                  includes += \";\";\n                  TClingClassInfo subinfo(interp,*(argdecl->getASTContext().getRecordType(argdecl).getTypePtr()));\n                  GenerateTClass_GatherInnerIncludes(interp, includes, &subinfo);\n               } else {\n                  std::string Result;\n                  llvm::raw_string_ostream OS(Result);\n                  arg.print(argdecl->getASTContext().getPrintingPolicy(),OS);\n                  Warning(\"TCling::GenerateTClass\",\"Missing header file for %s\",OS.str().c_str());\n               }\n            }\n          }\n      }\n   }\n}\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate a TClass for the given class.\n\nTClass *TCling::GenerateTClass(ClassInfo_t *classinfo, Bool_t silent /* = kFALSE */)\n{\n   TClingClassInfo *info = (TClingClassInfo*)classinfo;\n   if (!info || !info->IsValid()) {\n      Fatal(\"GenerateTClass\",\"Requires a valid ClassInfo object\");\n      return 0;\n   }\n   // We are in the case where we have AST nodes for this class.\n   TClass *cl = 0;\n   std::string classname;\n   info->FullName(classname,*fNormalizedCtxt); // Could we use Name()?\n   if (TClassEdit::IsSTLCont(classname)) {\n#if 0\n      Info(\"GenerateTClass\",\"Will (try to) generate the compiled TClass for %s.\",classname.c_str());\n      // We need to build up the list of required headers, by\n      // looking at each template arguments.\n      TString includes;\n      GenerateTClass_GatherInnerIncludes(fInterpreter,includes,info);\n\n      if (0 == GenerateDictionary(classname.c_str(),includes)) {\n         // 0 means success.\n         cl = TClass::LoadClass(classnam.c_str(), silent);\n         if (cl == 0) {\n            Error(\"GenerateTClass\",\"Even though the dictionary generation for %s seemed successful we can't find the TClass bootstrap!\",classname.c_str());\n         }\n      }\n#endif\n      if (cl == 0) {\n         int version = TClass::GetClass(\"TVirtualStreamerInfo\")->GetClassVersion();\n         cl = new TClass(classinfo, version, 0, 0, -1, -1, silent);\n         cl->SetBit(TClass::kIsEmulation);\n      }\n   } else {\n      // For regular class, just create a TClass on the fly ...\n      // Not quite useful yet, but that what CINT used to do anyway.\n      cl = new TClass(classinfo, 1, 0, 0, -1, -1, silent);\n   }\n   // Add the new TClass to the map of declid and TClass*.\n   if (cl) {\n      TClass::AddClassToDeclIdMap(((TClingClassInfo*)classinfo)->GetDeclId(), cl);\n   }\n   return cl;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Generate the dictionary for the C++ classes listed in the first\n/// argument (in a semi-colon separated list).\n/// 'includes' contains a semi-colon separated list of file to\n/// #include in the dictionary.\n/// For example:\n/// ~~~ {.cpp}\n///    gInterpreter->GenerateDictionary(\"vector<vector<float> >;list<vector<float> >\",\"list;vector\");\n/// ~~~\n/// or\n/// ~~~ {.cpp}\n///    gInterpreter->GenerateDictionary(\"myclass\",\"myclass.h;myhelper.h\");\n/// ~~~\n\nInt_t TCling::GenerateDictionary(const char* classes, const char* includes /* = \"\" */, const char* /* options  = 0 */)\n{\n   if (classes == 0 || classes[0] == 0) {\n      Error(\"TCling::GenerateDictionary\", \"Cannot generate dictionary without passing classes.\");\n      return 0;\n   }\n   // Split the input list\n   std::vector<std::string> listClasses;\n   for (\n      const char* current = classes, *prev = classes;\n      *current != 0;\n      ++current\n   ) {\n      if (*current == ';') {\n         listClasses.push_back(std::string(prev, current - prev));\n         prev = current + 1;\n      }\n      else if (*(current + 1) == 0) {\n         listClasses.push_back(std::string(prev, current + 1 - prev));\n         prev = current + 1;\n      }\n   }\n   std::vector<std::string> listIncludes;\n   if (!includes)\n      includes = \"\";\n   for (\n      const char* current = includes, *prev = includes;\n      *current != 0;\n      ++current\n   ) {\n      if (*current == ';') {\n         listIncludes.push_back(std::string(prev, current - prev));\n         prev = current + 1;\n      }\n      else if (*(current + 1) == 0) {\n         listIncludes.push_back(std::string(prev, current + 1 - prev));\n         prev = current + 1;\n      }\n   }\n   // Generate the temporary dictionary file\n   return !TCling_GenerateDictionary(listClasses, listIncludes,\n      std::vector<std::string>(), std::vector<std::string>());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling Decl of global/static variable that is located\n/// at the address given by addr.\n\nTInterpreter::DeclId_t TCling::GetDataMember(ClassInfo_t *opaque_cl, const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t d;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n\n   if (cl) {\n      d = cl->GetDataMember(name);\n      // We check if the decl of the data member has an annotation which indicates\n      // an ioname.\n      // In case this is true, if the name requested is not the ioname, we\n      // return 0, as if the member did not exist. In some sense we override\n      // the information in the TClassInfo instance, isolating the typesystem in\n      // TClass from the one in the AST.\n      if (const ValueDecl* decl = (const ValueDecl*) d){\n         std::string ioName;\n         bool hasIoName = ROOT::TMetaUtils::ExtractAttrPropertyFromName(*decl,\"ioname\",ioName);\n         if (hasIoName && ioName != name) return 0;\n      }\n      return d;\n   }\n   // We are looking up for something on the TU scope.\n   // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That\n   // interface will actually construct iterators and walk over the decls on the global scope. In would return the first\n   // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch\n   // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which\n   // are only fulfilling ROOT's understanding for a Data Member.\n   // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something\n   // similar as below.\n   using namespace clang;\n   Sema& SemaR = fInterpreter->getSema();\n   DeclarationName DName = &SemaR.Context.Idents.get(name);\n\n   LookupResult R(SemaR, DName, SourceLocation(), Sema::LookupOrdinaryName,\n                  Sema::ForRedeclaration);\n\n   // Could trigger deserialization of decls.\n   cling::Interpreter::PushTransactionRAII RAII(fInterpreter);\n   cling::utils::Lookup::Named(&SemaR, R);\n\n   LookupResult::Filter F = R.makeFilter();\n   // Filter the data-member looking decls.\n   while (F.hasNext()) {\n      NamedDecl *D = F.next();\n      if (isa<VarDecl>(D) || isa<FieldDecl>(D) || isa<EnumConstantDecl>(D) ||\n          isa<IndirectFieldDecl>(D))\n         continue;\n      F.erase();\n   }\n   F.done();\n\n   if (R.isSingleResult())\n      return R.getFoundDecl();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling Decl of global/static variable that is located\n/// at the address given by addr.\n\nTInterpreter::DeclId_t TCling::GetEnum(TClass *cl, const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   const clang::Decl* possibleEnum = 0;\n   // FInd the context of the decl.\n   if (cl) {\n      TClingClassInfo *cci = (TClingClassInfo*)cl->GetClassInfo();\n      if (cci) {\n         const clang::DeclContext* dc = 0;\n         if (const clang::Decl* D = cci->GetDecl()) {\n            if (!(dc = dyn_cast<clang::NamespaceDecl>(D))) {\n               dc = dyn_cast<clang::RecordDecl>(D);\n            }\n         }\n         if (dc) {\n            // If it is a data member enum.\n            // Could trigger deserialization of decls.\n            cling::Interpreter::PushTransactionRAII RAII(fInterpreter);\n            possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name, dc);\n         } else {\n            Error(\"TCling::GetEnum\", \"DeclContext not found for %s .\\n\", name);\n         }\n      }\n   } else {\n      // If it is a global enum.\n      // Could trigger deserialization of decls.\n      cling::Interpreter::PushTransactionRAII RAII(fInterpreter);\n      possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name);\n   }\n   if (possibleEnum && (possibleEnum != (clang::Decl*)-1)\n       && isa<clang::EnumDecl>(possibleEnum)) {\n      return possibleEnum;\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a global value\n\nTInterpreter::DeclId_t TCling::GetDeclId( const llvm::GlobalValue *gv ) const\n{\n   if (!gv) return 0;\n\n   llvm::StringRef mangled_name = gv->getName();\n\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleName(mangled_name.str().c_str(), err);\n   if (err) {\n      if (err == -2) {\n         // It might simply be an unmangled global name.\n         DeclId_t d;\n         TClingClassInfo gcl(fInterpreter);\n         d = gcl.GetDataMember(mangled_name.str().c_str());\n         return d;\n      }\n      return 0;\n   }\n\n   std::string scopename(demangled_name_c);\n   free(demangled_name_c);\n\n   //\n   //  Separate out the class or namespace part of the\n   //  function name.\n   //\n   std::string dataname;\n\n   if (!strncmp(scopename.c_str(), \"typeinfo for \", sizeof(\"typeinfo for \")-1)) {\n      scopename.erase(0, sizeof(\"typeinfo for \")-1);\n   } else if (!strncmp(scopename.c_str(), \"vtable for \", sizeof(\"vtable for \")-1)) {\n      scopename.erase(0, sizeof(\"vtable for \")-1);\n   } else {\n      // See if it is a function\n      std::string::size_type pos = scopename.rfind('(');\n      if (pos != std::string::npos) {\n         return 0;\n      }\n      // Separate the scope and member name\n      pos = scopename.rfind(':');\n      if (pos != std::string::npos) {\n         if ((pos != 0) && (scopename[pos-1] == ':')) {\n            dataname = scopename.substr(pos+1);\n            scopename.erase(pos-1);\n         }\n      } else {\n         scopename.clear();\n         dataname = scopename;\n      }\n   }\n   //fprintf(stderr, \"name: '%s'\\n\", name.c_str());\n   // Now we have the class or namespace name, so do the lookup.\n\n\n   DeclId_t d;\n   if (scopename.size()) {\n      TClingClassInfo cl(fInterpreter,scopename.c_str());\n      d = cl.GetDataMember(dataname.c_str());\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      d = gcl.GetDataMember(dataname.c_str());\n   }\n   return d;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// NOT IMPLEMENTED.\n\nTInterpreter::DeclId_t TCling::GetDataMemberWithValue(const void *ptrvalue) const\n{\n   Error(\"GetDataMemberWithValue()\", \"not implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a data member with a given name.\n\nTInterpreter::DeclId_t TCling::GetDataMemberAtAddr(const void *addr) const\n{\n   // NOT IMPLEMENTED.\n   Error(\"GetDataMemberAtAddr()\", \"not implemented\");\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the cling mangled name for a method of a class with parameters\n/// params (params is a string of actual arguments, not formal ones). If the\n/// class is 0 the global function list will be searched.\n\nTString TCling::GetMangledName(TClass* cl, const char* method,\n                               const char* params, Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc func(fInterpreter,*fNormalizedCtxt);\n   if (cl) {\n      Long_t offset;\n      func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,\n         &offset);\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      Long_t offset;\n      func.SetFunc(&gcl, method, params, &offset);\n   }\n   TClingMethodInfo* mi = (TClingMethodInfo*) func.FactoryMethod();\n   if (!mi) return \"\";\n   TString mangled_name( mi->GetMangledName() );\n   delete mi;\n   return mangled_name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the cling mangled name for a method of a class with a certain\n/// prototype, i.e. \"char*,int,float\". If the class is 0 the global function\n/// list will be searched.\n\nTString TCling::GetMangledNameWithPrototype(TClass* cl, const char* method,\n                                            const char* proto, Bool_t objectIsConst /* = kFALSE */,\n                                            EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   if (cl) {\n      return ((TClingClassInfo*)cl->GetClassInfo())->\n         GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetMangledName();\n   }\n   TClingClassInfo gcl(fInterpreter);\n   return gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetMangledName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// parameters params (params is a string of actual arguments, not formal\n/// ones). If the class is 0 the global function list will be searched.\n\nvoid* TCling::GetInterfaceMethod(TClass* cl, const char* method,\n                                 const char* params, Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc func(fInterpreter,*fNormalizedCtxt);\n   if (cl) {\n      Long_t offset;\n      func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,\n                   &offset);\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      Long_t offset;\n      func.SetFunc(&gcl, method, params, &offset);\n   }\n   return (void*) func.InterfaceMethod();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain name.\n\nTInterpreter::DeclId_t TCling::GetFunction(ClassInfo_t *opaque_cl, const char* method)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethod(method).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      f = gcl.GetMethod(method).GetDeclId();\n   }\n   return f;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Insert overloads of name in cl to res.\n\nvoid TCling::GetFunctionOverloads(ClassInfo_t *cl, const char *funcname,\n                                  std::vector<DeclId_t>& res) const\n{\n   clang::Sema& S = fInterpreter->getSema();\n   clang::ASTContext& Ctx = S.Context;\n   const clang::Decl* CtxDecl\n      = cl ? (const clang::Decl*)((TClingClassInfo*)cl)->GetDeclId():\n      Ctx.getTranslationUnitDecl();\n   auto RecDecl = llvm::dyn_cast<const clang::RecordDecl>(CtxDecl);\n   const clang::DeclContext* DeclCtx = RecDecl;\n\n   if (!DeclCtx)\n      DeclCtx = dyn_cast<clang::NamespaceDecl>(CtxDecl);\n   if (!DeclCtx) return;\n\n   clang::DeclarationName DName;\n   // The DeclarationName is funcname, unless it's a ctor or dtor.\n   // FIXME: or operator or conversion! See enum clang::DeclarationName::NameKind.\n\n   if (RecDecl) {\n      if (RecDecl->getNameAsString() == funcname) {\n         clang::QualType QT = Ctx.getTypeDeclType(RecDecl);\n         DName = Ctx.DeclarationNames.getCXXConstructorName(Ctx.getCanonicalType(QT));\n      } else if (funcname[0] == '~' && RecDecl->getNameAsString() == funcname + 1) {\n         clang::QualType QT = Ctx.getTypeDeclType(RecDecl);\n         DName = Ctx.DeclarationNames.getCXXDestructorName(Ctx.getCanonicalType(QT));\n      } else {\n         DName = &Ctx.Idents.get(funcname);\n      }\n   } else {\n      DName = &Ctx.Idents.get(funcname);\n   }\n\n   clang::LookupResult R(S, DName, clang::SourceLocation(),\n                         Sema::LookupOrdinaryName, clang::Sema::ForRedeclaration);\n   S.LookupQualifiedName(R, const_cast<DeclContext*>(DeclCtx));\n   if (R.empty()) return;\n   R.resolveKind();\n   res.reserve(res.size() + (R.end() - R.begin()));\n   for (clang::LookupResult::iterator IR = R.begin(), ER = R.end();\n        IR != ER; ++IR) {\n      if (const clang::FunctionDecl* FD\n          = llvm::dyn_cast<const clang::FunctionDecl>(*IR)) {\n         if (!FD->getDescribedFunctionTemplate()) {\n            res.push_back(FD);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nvoid* TCling::GetInterfaceMethodWithPrototype(TClass* cl, const char* method,\n                                              const char* proto,\n                                              Bool_t objectIsConst /* = kFALSE */,\n                                              EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   void* f;\n   if (cl) {\n      f = ((TClingClassInfo*)cl->GetClassInfo())->\n         GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).InterfaceMethod(*fNormalizedCtxt);\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      f = gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).InterfaceMethod(*fNormalizedCtxt);\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling DeclId for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nTInterpreter::DeclId_t TCling::GetFunctionWithValues(ClassInfo_t *opaque_cl, const char* method,\n                                                     const char* params,\n                                                     Bool_t objectIsConst /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethodWithArgs(method, params, objectIsConst, 0 /*poffset*/).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      f = gcl.GetMethod(method, params, objectIsConst, 0 /*poffset*/).GetDeclId();\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain prototype, i.e. \"char*,int,float\". If the class is 0 the global\n/// function list will be searched.\n\nTInterpreter::DeclId_t TCling::GetFunctionWithPrototype(ClassInfo_t *opaque_cl, const char* method,\n                                                        const char* proto,\n                                                        Bool_t objectIsConst /* = kFALSE */,\n                                                        EFunctionMatchMode mode /* = kConversionMatch */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetDeclId();\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      f = gcl.GetMethod(method, proto, objectIsConst, 0 /*poffset*/, mode).GetDeclId();\n   }\n   return f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return pointer to cling interface function for a method of a class with\n/// a certain name.\n\nTInterpreter::DeclId_t TCling::GetFunctionTemplate(ClassInfo_t *opaque_cl, const char* name)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   DeclId_t f;\n   TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;\n   if (cl) {\n      f = cl->GetFunctionTemplate(name);\n   }\n   else {\n      TClingClassInfo gcl(fInterpreter);\n      f = gcl.GetFunctionTemplate(name);\n   }\n   return f;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The 'name' is known to the interpreter, this function returns\n/// the internal version of this name (usually just resolving typedefs)\n/// This is used in particular to synchronize between the name used\n/// by rootcling and by the run-time environment (TClass)\n/// Return 0 if the name is not known.\n\nvoid TCling::GetInterpreterTypeName(const char* name, std::string &output, Bool_t full)\n{\n   output.clear();\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   TClingClassInfo cl(fInterpreter, name);\n   if (!cl.IsValid()) {\n      return ;\n   }\n   if (full) {\n      cl.FullName(output,*fNormalizedCtxt);\n      return;\n   }\n   // Well well well, for backward compatibility we need to act a bit too\n   // much like CINT.\n   TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );\n   splitname.ShortType(output, TClassEdit::kDropStd );\n\n   return;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a global function with arguments params.\n///\n/// FIXME: The cint-based version of this code does not check if the\n///        SetFunc() call works, and does not do any real checking\n///        for errors from the Exec() call.  It did fetch the most\n///        recent cint security error and return that in error, but\n///        this does not really translate well to cling/clang.  We\n///        should enhance these interfaces so that we can report\n///        compilation and runtime errors properly.\n\nvoid TCling::Execute(const char* function, const char* params, int* error)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   TClingClassInfo cl(fInterpreter);\n   Long_t offset = 0L;\n   TClingCallFunc func(fInterpreter,*fNormalizedCtxt);\n   func.SetFunc(&cl, function, params, &offset);\n   func.Exec(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a method from class cl with arguments params.\n///\n/// FIXME: The cint-based version of this code does not check if the\n///        SetFunc() call works, and does not do any real checking\n///        for errors from the Exec() call.  It did fetch the most\n///        recent cint security error and return that in error, but\n///        this does not really translate well to cling/clang.  We\n///        should enhance these interfaces so that we can report\n///        compilation and runtime errors properly.\n\nvoid TCling::Execute(TObject* obj, TClass* cl, const char* method,\n                     const char* params, Bool_t objectIsConst, int* error)\n{\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   // If the actual class of this object inherits 2nd (or more) from TObject,\n   // 'obj' is unlikely to be the start of the object (as described by IsA()),\n   // hence gInterpreter->Execute will improperly correct the offset.\n   void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);\n   Long_t offset = 0L;\n   TClingCallFunc func(fInterpreter,*fNormalizedCtxt);\n   func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);\n   void* address = (void*)((Long_t)addr + offset);\n   func.Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::Execute(TObject* obj, TClass* cl, const char* method,\n                    const char* params, int* error)\n{\n   Execute(obj,cl,method,params,false,error);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a method from class cl with the arguments in array params\n/// (params[0] ... params[n] = array of TObjString parameters).\n/// Convert the TObjArray array of TObjString parameters to a character\n/// string of comma separated parameters.\n/// The parameters of type 'char' are enclosed in double quotes and all\n/// internal quotes are escaped.\n\nvoid TCling::Execute(TObject* obj, TClass* cl, TMethod* method,\n                     TObjArray* params, int* error)\n{\n   if (!method) {\n      Error(\"Execute\", \"No method was defined\");\n      return;\n   }\n   TList* argList = method->GetListOfMethodArgs();\n   // Check number of actual parameters against of expected formal ones\n\n   Int_t nparms = argList->LastIndex() + 1;\n   Int_t argc   = params ? params->GetEntries() : 0;\n\n   if (argc > nparms) {\n      Error(\"Execute\",\"Too many parameters to call %s, got %d but expected at most %d.\",method->GetName(),argc,nparms);\n      return;\n   }\n   if (nparms != argc) {\n     // Let's see if the 'missing' argument are all defaulted.\n     // if nparms==0 then either we stopped earlier either argc is also zero and we can't reach here.\n     assert(nparms > 0);\n\n     TMethodArg *arg = (TMethodArg *) argList->At( 0 );\n     if (arg && arg->GetDefault() && arg->GetDefault()[0]) {\n        // There is a default value for the first missing\n        // argument, so we are fine.\n     } else {\n        Int_t firstDefault = -1;\n        for (Int_t i = 0; i < nparms; i ++) {\n           arg = (TMethodArg *) argList->At( i );\n           if (arg && arg->GetDefault() && arg->GetDefault()[0]) {\n              firstDefault = i;\n              break;\n           }\n        }\n        if (firstDefault >= 0) {\n           Error(\"Execute\",\"Too few arguments to call %s, got only %d but expected at least %d and at most %d.\",method->GetName(),argc,firstDefault,nparms);\n        } else {\n           Error(\"Execute\",\"Too few arguments to call %s, got only %d but expected %d.\",method->GetName(),argc,nparms);\n        }\n        return;\n     }\n   }\n\n   const char* listpar = \"\";\n   TString complete(10);\n   if (params) {\n      // Create a character string of parameters from TObjArray\n      TIter next(params);\n      for (Int_t i = 0; i < argc; i ++) {\n         TMethodArg* arg = (TMethodArg*) argList->At(i);\n         TClingTypeInfo type(fInterpreter, arg->GetFullTypeName());\n         TObjString* nxtpar = (TObjString*) next();\n         if (i) {\n            complete += ',';\n         }\n         if (strstr(type.TrueName(*fNormalizedCtxt), \"char\")) {\n            TString chpar('\\\"');\n            chpar += (nxtpar->String()).ReplaceAll(\"\\\"\", \"\\\\\\\"\");\n            // At this point we have to check if string contains \\\\\"\n            // and apply some more sophisticated parser. Not implemented yet!\n            complete += chpar;\n            complete += '\\\"';\n         }\n         else {\n            complete += nxtpar->String();\n         }\n      }\n      listpar = complete.Data();\n   }\n\n   // And now execute it.\n   R__LOCKGUARD_CLING(gInterpreterMutex);\n   if (error) {\n      *error = TInterpreter::kNoError;\n   }\n   // If the actual class of this object inherits 2nd (or more) from TObject,\n   // 'obj' is unlikely to be the start of the object (as described by IsA()),\n   // hence gInterpreter->Execute will improperly correct the offset.\n   void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);\n   TClingCallFunc func(fInterpreter,*fNormalizedCtxt);\n   TClingMethodInfo *minfo = (TClingMethodInfo*)method->fInfo;\n   func.Init(*minfo);\n   func.SetArgs(listpar);\n   // Now calculate the 'this' pointer offset for the method\n   // when starting from the class described by cl.\n   const CXXMethodDecl * mdecl = dyn_cast<CXXMethodDecl>(minfo->GetMethodDecl());\n   Long_t offset = ((TClingClassInfo*)cl->GetClassInfo())->GetOffset(mdecl);\n   void* address = (void*)((Long_t)addr + offset);\n   func.Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ExecuteWithArgsAndReturn(TMethod* method, void* address,\n                                      const void* args[] /*=0*/,\n                                      int nargs /*=0*/,\n                                      void* ret/*= 0*/) const\n{\n   if (!method) {\n      Error(\"ExecuteWithArgsAndReturn\", \"No method was defined\");\n      return;\n   }\n\n   TClingMethodInfo* minfo = (TClingMethodInfo*) method->fInfo;\n   TClingCallFunc func(*minfo,*fNormalizedCtxt);\n   func.ExecWithArgsAndReturn(address, args, nargs, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Execute a cling macro.\n\nLong_t TCling::ExecuteMacro(const char* filename, EErrorCode* error)\n{\n   R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : 0);\n   fCurExecutingMacros.push_back(filename);\n   Long_t result = TApplication::ExecuteFile(filename, (int*)error);\n   fCurExecutingMacros.pop_back();\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the file name of the current un-included interpreted file.\n/// See the documentation for GetCurrentMacroName().\n\nconst char* TCling::GetTopLevelMacroName() const\n{\n   Warning(\"GetTopLevelMacroName\", \"Must change return type!\");\n   return fCurExecutingMacros.back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the file name of the currently interpreted file,\n/// included or not. Example to illustrate the difference between\n/// GetCurrentMacroName() and GetTopLevelMacroName():\n/// ~~~ {.cpp}\n///   void inclfile() {\n///   std::cout << \"In inclfile.C\" << std::endl;\n///   std::cout << \"  TCling::GetCurrentMacroName() returns  \" <<\n///      TCling::GetCurrentMacroName() << std::endl;\n///   std::cout << \"  TCling::GetTopLevelMacroName() returns \" <<\n///      TCling::GetTopLevelMacroName() << std::endl;\n///   }\n/// ~~~\n/// ~~~ {.cpp}\n///   void mymacro() {\n///   std::cout << \"In mymacro.C\" << std::endl;\n///   std::cout << \"  TCling::GetCurrentMacroName() returns  \" <<\n///      TCling::GetCurrentMacroName() << std::endl;\n///   std::cout << \"  TCling::GetTopLevelMacroName() returns \" <<\n///      TCling::GetTopLevelMacroName() << std::endl;\n///   std::cout << \"  Now calling inclfile...\" << std::endl;\n///   gInterpreter->ProcessLine(\".x inclfile.C\");;\n///   }\n/// ~~~\n/// Running mymacro.C will print:\n///\n/// ~~~ {.cpp}\n/// root [0] .x mymacro.C\n/// ~~~\n/// In mymacro.C\n/// ~~~ {.cpp}\n///   TCling::GetCurrentMacroName() returns  ./mymacro.C\n///   TCling::GetTopLevelMacroName() returns ./mymacro.C\n/// ~~~\n///   Now calling inclfile...\n/// In inclfile.h\n/// ~~~ {.cpp}\n///   TCling::GetCurrentMacroName() returns  inclfile.C\n///   TCling::GetTopLevelMacroName() returns ./mymacro.C\n/// ~~~\n\nconst char* TCling::GetCurrentMacroName() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,0)\n   Warning(\"GetCurrentMacroName\", \"Must change return type!\");\n#endif\n#endif\n   return fCurExecutingMacros.back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the absolute type of typeDesc.\n/// E.g.: typeDesc = \"class TNamed**\", returns \"TNamed\".\n/// You need to use the result immediately before it is being overwritten.\n\nconst char* TCling::TypeName(const char* typeDesc)\n{\n   TTHREAD_TLS(char*) t = 0;\n   TTHREAD_TLS(unsigned int) tlen = 0;\n\n   unsigned int dlen = strlen(typeDesc);\n   if (dlen > tlen) {\n      delete[] t;\n      t = new char[dlen + 1];\n      tlen = dlen;\n   }\n   const char* s, *template_start;\n   if (!strstr(typeDesc, \"(*)(\")) {\n      s = strchr(typeDesc, ' ');\n      template_start = strchr(typeDesc, '<');\n      if (!strcmp(typeDesc, \"long long\")) {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n      else if (!strncmp(typeDesc, \"unsigned \", s + 1 - typeDesc)) {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n      // s is the position of the second 'word' (if any)\n      // except in the case of templates where there will be a space\n      // just before any closing '>': eg.\n      //    TObj<std::vector<UShort_t,__malloc_alloc_template<0> > >*\n      else if (s && (template_start == 0 || (s < template_start))) {\n         strlcpy(t, s + 1, dlen + 1);\n      }\n      else {\n         strlcpy(t, typeDesc, dlen + 1);\n      }\n   }\n   else {\n      strlcpy(t, typeDesc, dlen + 1);\n   }\n   int l = strlen(t);\n   while (l > 0 && (t[l - 1] == '*' || t[l - 1] == '&')) {\n      t[--l] = 0;\n   }\n   return t;\n}\n\nstatic bool requiresRootMap(const char* rootmapfile, cling::Interpreter* interp)\n{\n   if (!rootmapfile || !*rootmapfile)\n      return true;\n\n   llvm::StringRef moduleName = llvm::sys::path::filename(rootmapfile);\n   moduleName.consume_front(\"lib\");\n   moduleName.consume_back(\".rootmap\");\n\n   Module *M = interp->getCI()->getPreprocessor().getHeaderSearchInfo().lookupModule(moduleName);\n\n   return !(M && interp->getSema().isModuleVisible(M));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Read and parse a rootmapfile in its new format, and return 0 in case of\n/// success, -1 if the file has already been read, and -3 in case its format\n/// is the old one (e.g. containing \"Library.ClassName\"), -4 in case of syntax\n/// error.\n\nint TCling::ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString)\n{\n   // For \"class \", \"namespace \", \"typedef \", \"header \", \"enum \", \"var \" respectively\n   const std::map<char, unsigned int> keyLenMap = {{'c',6},{'n',10},{'t',8},{'h',7},{'e',5},{'v',4}};\n\n   if (rootmapfile && *rootmapfile) {\n      std::string rootmapfileNoBackslash(rootmapfile);\n#ifdef _MSC_VER\n      std::replace(rootmapfileNoBackslash.begin(), rootmapfileNoBackslash.end(), '\\\\', '/');\n#endif\n      // Add content of a specific rootmap file\n      if (fRootmapFiles->FindObject(rootmapfileNoBackslash.c_str()))\n         return -1;\n\n      if (uniqueString)\n         uniqueString->Append(std::string(\"\\n#line 1 \\\"Forward declarations from \") + rootmapfileNoBackslash + \"\\\"\\n\");\n\n      std::ifstream file(rootmapfileNoBackslash);\n      std::string line; line.reserve(200);\n      std::string lib_name; line.reserve(100);\n      bool newFormat=false;\n      while (getline(file, line, '\\n')) {\n         if (!newFormat &&\n             (line.compare(0, 8, \"Library.\") == 0 || line.compare(0, 8, \"Declare.\") == 0)) {\n            file.close();\n            return -3; // old format\n         }\n         newFormat=true;\n\n         if (line.compare(0, 9, \"{ decls }\") == 0 && requiresRootMap(rootmapfile, fInterpreter)) {\n            // forward declarations\n\n            while (getline(file, line, '\\n')) {\n               if (line[0] == '[') break;\n               if (!uniqueString) {\n                  Error(\"ReadRootmapFile\", \"Cannot handle \\\"{ decls }\\\" sections in custom rootmap file %s\",\n                        rootmapfileNoBackslash.c_str());\n                  return -4;\n               }\n               uniqueString->Append(line);\n            }\n         }\n         const char firstChar=line[0];\n         if (firstChar == '[') {\n            // new section (library)\n            auto brpos = line.find(']');\n            if (brpos == string::npos) continue;\n            lib_name = line.substr(1, brpos-1);\n            size_t nspaces = 0;\n            while( lib_name[nspaces] == ' ' ) ++nspaces;\n            if (nspaces) lib_name.replace(0, nspaces, \"\");\n            if (gDebug > 3) {\n               TString lib_nameTstr(lib_name.c_str());\n               TObjArray* tokens = lib_nameTstr.Tokenize(\" \");\n               const char* lib = ((TObjString *)tokens->At(0))->GetName();\n               const char* wlib = gSystem->DynamicPathName(lib, kTRUE);\n               if (wlib) {\n                  Info(\"ReadRootmapFile\", \"new section for %s\", lib_nameTstr.Data());\n               }\n               else {\n                  Info(\"ReadRootmapFile\", \"section for %s (library does not exist)\", lib_nameTstr.Data());\n               }\n               delete[] wlib;\n               delete tokens;\n            }\n         }\n         else {\n            auto keyLenIt = keyLenMap.find(firstChar);\n            if (keyLenIt == keyLenMap.end()) continue;\n            unsigned int keyLen = keyLenIt->second;\n            // Do not make a copy, just start after the key\n            const char *keyname = line.c_str()+keyLen;\n            if (gDebug > 6)\n               Info(\"ReadRootmapFile\", \"class %s in %s\", keyname, lib_name.c_str());\n            TEnvRec* isThere = fMapfile->Lookup(keyname);\n            if (isThere){\n               if(lib_name != isThere->GetValue()){ // the same key for two different libs\n                  if (firstChar == 'n') {\n                     if (gDebug > 3)\n                        Info(\"ReadRootmapFile\", \"namespace %s found in %s is already in %s\",\n                           keyname, lib_name.c_str(), isThere->GetValue());\n                  } else if (firstChar == 'h'){ // it is a header: add the libname to the list of libs to be loaded.\n                     lib_name+=\" \";\n                     lib_name+=isThere->GetValue();\n                     fMapfile->SetValue(keyname, lib_name.c_str());\n                  }\n                  else if (!TClassEdit::IsSTLCont(keyname)) {\n                     Warning(\"ReadRootmapFile\", \"%s %s found in %s is already in %s\", line.substr(0, keyLen).c_str(),\n                           keyname, lib_name.c_str(), isThere->GetValue());\n                  }\n               } else { // the same key for the same lib\n                  if (gDebug > 3)\n                        Info(\"ReadRootmapFile\",\"Key %s was already defined for %s\", keyname, lib_name.c_str());\n               }\n\n            } else {\n               fMapfile->SetValue(keyname, lib_name.c_str());\n            }\n         }\n      }\n      file.close();\n   }\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create a resource table and read the (possibly) three resource files, i.e\n/// $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>), $HOME/<name> and\n/// ./<name>. ROOT always reads \".rootrc\" (in TROOT::InitSystem()). You can\n/// read additional user defined resource files by creating additional TEnv\n/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of\n/// the $HOME/<name> resource file will be skipped. This might be useful in\n/// case the home directory resides on an automounted remote file system\n/// and one wants to avoid the file system from being mounted.\n\nvoid TCling::InitRootmapFile(const char *name)\n{\n   Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);\n\n   fMapfile->SetRcName(name);\n\n   TString sname = \"system\";\n   sname += name;\n   char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);\n\n   Int_t ret = ReadRootmapFile(s);\n   if (ret == -3) // old format\n      fMapfile->ReadFile(s, kEnvGlobal);\n   delete [] s;\n   if (!gSystem->Getenv(\"ROOTENV_NO_HOME\")) {\n      s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);\n      ret = ReadRootmapFile(s);\n      if (ret == -3) // old format\n         fMapfile->ReadFile(s, kEnvUser);\n      delete [] s;\n      if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {\n         ret = ReadRootmapFile(name);\n         if (ret == -3) // old format\n            fMapfile->ReadFile(name, kEnvLocal);\n      }\n   } else {\n      ret = ReadRootmapFile(name);\n      if (ret == -3) // old format\n         fMapfile->ReadFile(name, kEnvLocal);\n   }\n   fMapfile->IgnoreDuplicates(ignore);\n}\n\n\nnamespace {\n   using namespace clang;\n\n   class ExtVisibleStorageAdder: public RecursiveASTVisitor<ExtVisibleStorageAdder>{\n      // This class is to be considered an helper for autoloading.\n      // It is a recursive visitor is used to inspect namespaces coming from\n      // forward declarations in rootmaps and to set the external visible\n      // storage flag for them.\n   public:\n      ExtVisibleStorageAdder(std::unordered_set<const NamespaceDecl*>& nsSet): fNSSet(nsSet) {};\n      bool VisitNamespaceDecl(NamespaceDecl* nsDecl) {\n         // We want to enable the external lookup for this namespace\n         // because it may shadow the lookup of other names contained\n         // in that namespace\n\n         nsDecl->setHasExternalVisibleStorage();\n         fNSSet.insert(nsDecl);\n         return true;\n      }\n   private:\n      std::unordered_set<const NamespaceDecl*>& fNSSet;\n\n   };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load map between class and library. If rootmapfile is specified a\n/// specific rootmap file can be added (typically used by ACLiC).\n/// In case of error -1 is returned, 0 otherwise.\n/// The interpreter uses this information to automatically load the shared\n/// library for a class (autoload mechanism), see the AutoLoad() methods below.\n\nInt_t TCling::LoadLibraryMap(const char* rootmapfile)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   // open the [system].rootmap files\n   if (!fMapfile) {\n      fMapfile = new TEnv();\n      fMapfile->IgnoreDuplicates(kTRUE);\n//       fMapNamespaces = new THashTable();\n//       fMapNamespaces->SetOwner();\n      fRootmapFiles = new TObjArray;\n      fRootmapFiles->SetOwner();\n      InitRootmapFile(\".rootmap\");\n   }\n   bool needsRootMap = true;\n   if (rootmapfile && *rootmapfile)\n      needsRootMap = requiresRootMap(rootmapfile, fInterpreter);\n\n   // Prepare a list of all forward declarations for cling\n   // For some experiments it is easily as big as 500k characters. To be on the\n   // safe side, we go for 1M.\n   TUniqueString uniqueString(1048576);\n\n   // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).\n   // A rootmap file must end with the string \".rootmap\".\n   TString ldpath = gSystem->GetDynamicPath();\n   if (ldpath != fRootmapLoadPath) {\n      fRootmapLoadPath = ldpath;\n#ifdef WIN32\n      TObjArray* paths = ldpath.Tokenize(\";\");\n#else\n      TObjArray* paths = ldpath.Tokenize(\":\");\n#endif\n      TString d;\n      for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {\n         d = ((TObjString *)paths->At(i))->GetString();\n         // check if directory already scanned\n         Int_t skip = 0;\n         for (Int_t j = 0; j < i; j++) {\n            TString pd = ((TObjString *)paths->At(j))->GetString();\n            if (pd == d) {\n               skip++;\n               break;\n            }\n         }\n         if (!skip) {\n            void* dirp = gSystem->OpenDirectory(d);\n            if (dirp) {\n               if (gDebug > 3) {\n                  Info(\"LoadLibraryMap\", \"%s\", d.Data());\n               }\n               const char* f1;\n               while ((f1 = gSystem->GetDirEntry(dirp))) {\n                  TString f = f1;\n                  if (f.EndsWith(\".rootmap\")) {\n                     TString p;\n                     p = d + \"/\" + f;\n                     if (!gSystem->AccessPathName(p, kReadPermission)) {\n                        if (!fRootmapFiles->FindObject(f) && f != \".rootmap\") {\n                           if (gDebug > 4) {\n                              Info(\"LoadLibraryMap\", \"   rootmap file: %s\", p.Data());\n                           }\n                           Int_t ret;\n                           if (needsRootMap)\n                              ret = ReadRootmapFile(p,&uniqueString);\n                           else\n                              ret = ReadRootmapFile(p);\n\n                           if (ret == 0)\n                              fRootmapFiles->Add(new TNamed(gSystem->BaseName(f), p.Data()));\n                           if (ret == -3) {\n                              // old format\n                              fMapfile->ReadFile(p, kEnvGlobal);\n                              fRootmapFiles->Add(new TNamed(f, p));\n                           }\n                        }\n                        // else {\n                        //    fprintf(stderr,\"Reject %s because %s is already there\\n\",p.Data(),f.Data());\n                        //    fRootmapFiles->FindObject(f)->ls();\n                        // }\n                     }\n                  }\n                  if (f.BeginsWith(\"rootmap\")) {\n                     TString p;\n                     p = d + \"/\" + f;\n                     FileStat_t stat;\n                     if (gSystem->GetPathInfo(p, stat) == 0 && R_ISREG(stat.fMode)) {\n                        Warning(\"LoadLibraryMap\", \"please rename %s to end with \\\".rootmap\\\"\", p.Data());\n                     }\n                  }\n               }\n            }\n            gSystem->FreeDirectory(dirp);\n         }\n      }\n      delete paths;\n      if (!fMapfile->GetTable()->GetEntries()) {\n         return -1;\n      }\n   }\n   if (rootmapfile && *rootmapfile) {\n      Int_t res;\n      if (needsRootMap)\n         res = ReadRootmapFile(rootmapfile, &uniqueString);\n      else\n         res = ReadRootmapFile(rootmapfile);\n      if (res == 0) {\n         //TString p = gSystem->ConcatFileName(gSystem->pwd(), rootmapfile);\n         //fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), p.Data()));\n         fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));\n      }\n      else if (res == -3) {\n         // old format\n         Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);\n         fMapfile->ReadFile(rootmapfile, kEnvGlobal);\n         fRootmapFiles->Add(new TNamed(gSystem->BaseName(rootmapfile), rootmapfile));\n         fMapfile->IgnoreDuplicates(ignore);\n      }\n   }\n   TEnvRec* rec;\n   TIter next(fMapfile->GetTable());\n   while ((rec = (TEnvRec*) next())) {\n      TString cls = rec->GetName();\n      if (!strncmp(cls.Data(), \"Library.\", 8) && cls.Length() > 8) {\n         // get the first lib from the list of lib and dependent libs\n         TString libs = rec->GetValue();\n         if (libs == \"\") {\n            continue;\n         }\n         TString delim(\" \");\n         TObjArray* tokens = libs.Tokenize(delim);\n         const char* lib = ((TObjString*)tokens->At(0))->GetName();\n         // convert \"@@\" to \"::\", we used \"@@\" because TEnv\n         // considers \"::\" a terminator\n         cls.Remove(0, 8);\n         cls.ReplaceAll(\"@@\", \"::\");\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         cls.ReplaceAll(\"-\", \" \");\n         if (gDebug > 6) {\n            const char* wlib = gSystem->DynamicPathName(lib, kTRUE);\n            if (wlib) {\n               Info(\"LoadLibraryMap\", \"class %s in %s\", cls.Data(), wlib);\n            }\n            else {\n               Info(\"LoadLibraryMap\", \"class %s in %s (library does not exist)\", cls.Data(), lib);\n            }\n            delete[] wlib;\n         }\n         // Fill in the namespace candidate list\n//          Ssiz_t last = cls.Last(':');\n//          if (last != kNPOS) {\n//             // Please note that the funny op overload does substring.\n//             TString namespaceCand = cls(0, last - 1);\n//             // This is a reference to a substring that lives in fMapfile\n//             if (!fMapNamespaces->FindObject(namespaceCand.Data()))\n//                fMapNamespaces->Add(new TNamed(namespaceCand.Data(), \"\"));\n//          }\n         delete tokens;\n      }\n      else if (!strncmp(cls.Data(), \"Declare.\", 8) && cls.Length() > 8) {\n         cls.Remove(0, 8);\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         cls.ReplaceAll(\"-\", \" \");\n         fInterpreter->declare(cls.Data());\n      }\n   }\n\n   // Process the forward declarations collected\n   cling::Transaction* T = nullptr;\n   auto compRes= fInterpreter->declare(uniqueString.Data(), &T);\n   assert(cling::Interpreter::kSuccess == compRes && \"A declaration in a rootmap could not be compiled\");\n\n   if (compRes!=cling::Interpreter::kSuccess){\n      Warning(\"LoadLibraryMap\",\n               \"Problems in %s declaring '%s' were encountered.\", rootmapfile, uniqueString.Data()) ;\n   }\n\n   if (T){\n      ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);\n      for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {\n         if (declIt->m_DGR.isSingleDecl()) {\n            if (Decl* D = declIt->m_DGR.getSingleDecl()) {\n               if (NamespaceDecl* NSD = dyn_cast<NamespaceDecl>(D)) {\n                  evsAdder.TraverseDecl(NSD);\n               }\n            }\n         }\n      }\n   }\n\n   // clear duplicates\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Scan again along the dynamic path for library maps. Entries for the loaded\n/// shared libraries are unloaded first. This can be useful after reseting\n/// the dynamic path through TSystem::SetDynamicPath()\n/// In case of error -1 is returned, 0 otherwise.\n\nInt_t TCling::RescanLibraryMap()\n{\n   UnloadAllSharedLibraryMaps();\n   LoadLibraryMap();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reload the library map entries coming from all the loaded shared libraries,\n/// after first unloading the current ones.\n/// In case of error -1 is returned, 0 otherwise.\n\nInt_t TCling::ReloadAllSharedLibraryMaps()\n{\n   const TString sharedLibLStr = GetSharedLibs();\n   const TObjArray* sharedLibL = sharedLibLStr.Tokenize(\" \");\n   const Int_t nrSharedLibs = sharedLibL->GetEntriesFast();\n   for (Int_t ilib = 0; ilib < nrSharedLibs; ilib++) {\n      const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();\n      const  TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);\n      const Int_t ret = UnloadLibraryMap(sharedLibBaseStr);\n      if (ret < 0) {\n         continue;\n      }\n      TString rootMapBaseStr = sharedLibBaseStr;\n      if (sharedLibBaseStr.EndsWith(\".dll\")) {\n         rootMapBaseStr.ReplaceAll(\".dll\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".DLL\")) {\n         rootMapBaseStr.ReplaceAll(\".DLL\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".so\")) {\n         rootMapBaseStr.ReplaceAll(\".so\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".sl\")) {\n         rootMapBaseStr.ReplaceAll(\".sl\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".dl\")) {\n         rootMapBaseStr.ReplaceAll(\".dl\", \"\");\n      }\n      else if (sharedLibBaseStr.EndsWith(\".a\")) {\n         rootMapBaseStr.ReplaceAll(\".a\", \"\");\n      }\n      else {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Unknown library type %s\", sharedLibBaseStr.Data());\n         delete sharedLibL;\n         return -1;\n      }\n      rootMapBaseStr += \".rootmap\";\n      const char* rootMap = gSystem->Which(gSystem->GetDynamicPath(), rootMapBaseStr);\n      if (!rootMap) {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Could not find rootmap %s in path\", rootMap);\n         delete[] rootMap;\n         delete sharedLibL;\n         return -1;\n      }\n      const Int_t status = LoadLibraryMap(rootMap);\n      if (status < 0) {\n         Error(\"ReloadAllSharedLibraryMaps\", \"Error loading map %s\", rootMap);\n         delete[] rootMap;\n         delete sharedLibL;\n         return -1;\n      }\n      delete[] rootMap;\n   }\n   delete sharedLibL;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unload the library map entries coming from all the loaded shared libraries.\n/// Returns 0 if succesful\n\nInt_t TCling::UnloadAllSharedLibraryMaps()\n{\n   const TString sharedLibLStr = GetSharedLibs();\n   const TObjArray* sharedLibL = sharedLibLStr.Tokenize(\" \");\n   for (Int_t ilib = 0; ilib < sharedLibL->GetEntriesFast(); ilib++) {\n      const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();\n      const  TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);\n      UnloadLibraryMap(sharedLibBaseStr);\n   }\n   delete sharedLibL;\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Unload library map entries coming from the specified library.\n/// Returns -1 in case no entries for the specified library were found,\n/// 0 otherwise.\n\nInt_t TCling::UnloadLibraryMap(const char* library)\n{\n   if (!fMapfile || !library || !*library) {\n      return 0;\n   }\n   TString libname(library);\n   Ssiz_t idx = libname.Last('.');\n   if (idx != kNPOS) {\n      libname.Remove(idx);\n   }\n   size_t len = libname.Length();\n   TEnvRec *rec;\n   TIter next(fMapfile->GetTable());\n   R__LOCKGUARD(gInterpreterMutex);\n   Int_t ret = 0;\n   while ((rec = (TEnvRec *) next())) {\n      TString cls = rec->GetName();\n      if (cls.Length() > 2) {\n         // get the first lib from the list of lib and dependent libs\n         TString libs = rec->GetValue();\n         if (libs == \"\") {\n            continue;\n         }\n         TString delim(\" \");\n         TObjArray* tokens = libs.Tokenize(delim);\n         const char* lib = ((TObjString *)tokens->At(0))->GetName();\n         if (!strncmp(cls.Data(), \"Library.\", 8) && cls.Length() > 8) {\n            // convert \"@@\" to \"::\", we used \"@@\" because TEnv\n            // considers \"::\" a terminator\n            cls.Remove(0, 8);\n            cls.ReplaceAll(\"@@\", \"::\");\n            // convert \"-\" to \" \", since class names may have\n            // blanks and TEnv considers a blank a terminator\n            cls.ReplaceAll(\"-\", \" \");\n         }\n         if (!strncmp(lib, libname.Data(), len)) {\n            if (fMapfile->GetTable()->Remove(rec) == 0) {\n               Error(\"UnloadLibraryMap\", \"entry for <%s, %s> not found in library map table\", cls.Data(), lib);\n               ret = -1;\n            }\n         }\n         delete tokens;\n      }\n   }\n   if (ret >= 0) {\n      TString library_rootmap(library);\n      if (!library_rootmap.EndsWith(\".rootmap\"))\n         library_rootmap.Append(\".rootmap\");\n      TNamed* mfile = 0;\n      while ((mfile = (TNamed *)fRootmapFiles->FindObject(library_rootmap))) {\n         fRootmapFiles->Remove(mfile);\n         delete mfile;\n      }\n      fRootmapFiles->Compress();\n   }\n   return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register the autoloading information for a class.\n/// libs is a space separated list of libraries.\n\nInt_t TCling::SetClassSharedLibs(const char *cls, const char *libs)\n{\n   if (!cls || !*cls)\n      return 0;\n\n   TString key = TString(\"Library.\") + cls;\n   // convert \"::\" to \"@@\", we used \"@@\" because TEnv\n   // considers \"::\" a terminator\n   key.ReplaceAll(\"::\", \"@@\");\n   // convert \"-\" to \" \", since class names may have\n   // blanks and TEnv considers a blank a terminator\n   key.ReplaceAll(\" \", \"-\");\n\n   R__LOCKGUARD(gInterpreterMutex);\n   if (!fMapfile) {\n      fMapfile = new TEnv();\n      fMapfile->IgnoreDuplicates(kTRUE);\n//       fMapNamespaces = new THashTable();\n//       fMapNamespaces->SetOwner();\n\n      fRootmapFiles = new TObjArray;\n      fRootmapFiles->SetOwner();\n\n      InitRootmapFile(\".rootmap\");\n   }\n   //fMapfile->SetValue(key, libs);\n   fMapfile->SetValue(cls, libs);\n   return 1;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Demangle the name (from the typeinfo) and then request the class\n/// via the usual name based interface (TClass::GetClass).\n\nTClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const\n{\n   int err = 0;\n   char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);\n   if (err) return 0;\n   TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);\n   free(demangled_name);\n   return theClass;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load library containing the specified class. Returns 0 in case of error\n/// and 1 in case if success.\n\nInt_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */)\n{\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);\n   if (err) {\n      return 0;\n   }\n\n   std::string demangled_name(demangled_name_c);\n   free(demangled_name_c);\n\n   // AutoLoad expects (because TClass::GetClass already prepares it that way) a\n   // shortened name.\n   TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );\n   splitname.ShortType(demangled_name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd);\n\n   // No need to worry about typedef, they aren't any ... but there are\n   // inlined namespaces ...\n\n   Int_t result = AutoLoad(demangled_name.c_str());\n   if (result == 0) {\n      demangled_name = TClassEdit::GetLong64_Name(demangled_name);\n      result = AutoLoad(demangled_name.c_str(), knowDictNotLoaded);\n   }\n\n   return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load library containing the specified class. Returns 0 in case of error\n/// and 1 in case if success.\n\nInt_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {\n      // The library is already loaded as the class's dictionary is known.\n      // Return success.\n      // Note: the name (cls) is expected to be normalized as it comes either\n      // from a callbacks (that can/should calculate the normalized name from the\n      // decl) or from TClass::GetClass (which does also calculate the normalized\n      // name).\n      return 1;\n   }\n\n   if (gDebug > 2) {\n      Info(\"TCling::AutoLoad\",\n           \"Trying to autoload for %s\", cls);\n   }\n\n   Int_t status = 0;\n   if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {\n      if (gDebug > 2) {\n         Info(\"TCling::AutoLoad\",\n              \"Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)\", cls);\n      }\n      return status;\n   }\n   if (!fAllowLibLoad) {\n      // Never load any library from rootcling/genreflex.\n      if (gDebug > 2) {\n         Info(\"TCling::AutoLoad\",\n              \"Explicitly disabled (the class name is %s)\", cls);\n      }\n      return 0;\n   }\n   // Prevent the recursion when the library dictionary are loaded.\n   Int_t oldvalue = SetClassAutoloading(false);\n   // Try using externally provided callback first.\n   if (fAutoLoadCallBack) {\n      int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);\n      if (success) {\n         SetClassAutoloading(oldvalue);\n         return success;\n      }\n   }\n   // lookup class to find list of dependent libraries\n   TString deplibs = GetClassSharedLibs(cls);\n   if (!deplibs.IsNull()) {\n      TString delim(\" \");\n      TObjArray* tokens = deplibs.Tokenize(delim);\n      for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {\n         const char* deplib = ((TObjString*)tokens->At(i))->GetName();\n         if (gROOT->LoadClass(cls, deplib) == 0) {\n            if (gDebug > 0) {\n               Info(\"TCling::AutoLoad\",\n                    \"loaded dependent library %s for %s\", deplib, cls);\n            }\n         }\n         else {\n            Error(\"TCling::AutoLoad\",\n                  \"failure loading dependent library %s for %s\",\n                  deplib, cls);\n         }\n      }\n      const char* lib = ((TObjString*)tokens->At(0))->GetName();\n      if (lib && lib[0]) {\n         if (gROOT->LoadClass(cls, lib) == 0) {\n            if (gDebug > 0) {\n               Info(\"TCling::AutoLoad\",\n                    \"loaded library %s for %s\", lib, cls);\n            }\n            status = 1;\n         }\n         else {\n            Error(\"TCling::AutoLoad\",\n                  \"failure loading library %s for %s\", lib, cls);\n         }\n      }\n      delete tokens;\n   }\n\n   SetClassAutoloading(oldvalue);\n   return status;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Parse the payload or header.\n\nstatic cling::Interpreter::CompilationResult ExecAutoParse(const char *what,\n                                                           Bool_t header,\n                                                           cling::Interpreter *interpreter)\n{\n   std::string code = gNonInterpreterClassDef ;\n   if (!header) {\n      // This is the complete header file content and not the\n      // name of a header.\n      code += what;\n\n   } else {\n      code += (\"#include \\\"\");\n      code += what;\n      code += \"\\\"\\n\";\n   }\n   code += (\"#ifdef __ROOTCLING__\\n\"\n            \"#undef __ROOTCLING__\\n\"\n            + gInterpreterClassDef +\n            \"#endif\");\n\n   cling::Interpreter::CompilationResult cr;\n   {\n      // scope within which diagnostics are de-activated\n      // For now we disable diagnostics because we saw them already at\n      // dictionary generation time. That won't be an issue with the PCMs.\n\n      Sema &SemaR = interpreter->getSema();\n      ROOT::Internal::ParsingStateRAII parsingStateRAII(interpreter->getParser(), SemaR);\n      clangDiagSuppr diagSuppr(SemaR.getDiagnostics());\n\n      #if defined(R__MUST_REVISIT)\n      #if R__MUST_REVISIT(6,2)\n      Warning(\"TCling::RegisterModule\",\"Diagnostics suppression should be gone by now.\");\n      #endif\n      #endif\n\n      cr = interpreter->parseForModule(code);\n   }\n   return cr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper routine for TCling::AutoParse implementing the actual call to the\n/// parser and looping over template parameters (if\n/// any) and when they don't have a registered header to autoparse,\n/// recurse over their template parameters.\n///\n/// Returns the number of header parsed.\n\nUInt_t TCling::AutoParseImplRecurse(const char *cls, bool topLevel)\n{\n   // We assume the lock has already been taken.\n   //    R__LOCKGUARD(gInterpreterMutex);\n\n   Int_t nHheadersParsed = 0;\n   unsigned long offset = 0;\n   if (strncmp(cls, \"const \", 6) == 0) {\n      offset = 6;\n   }\n\n   // Loop on the possible autoparse keys\n   bool skipFirstEntry = false;\n   std::vector<std::string> autoparseKeys;\n   if (strchr(cls, '<')) {\n      int nestedLoc = 0;\n      TClassEdit::GetSplit(cls + offset, autoparseKeys, nestedLoc, TClassEdit::kDropTrailStar);\n      // Check if we can skip the name of the template in the autoparses\n      // Take all the scopes one by one. If all of them are in the AST, we do not\n      // need to autoparse for that particular template.\n      if (!autoparseKeys.empty() && !autoparseKeys[0].empty()) {\n         // autoparseKeys[0] is empty when the input is not a template instance.\n         // The case strchr(cls, '<') != 0 but still not a template instance can\n         // happens 'just' for string (GetSplit replaces the template by the short name\n         // and then use that for thew splitting)\n         TString templateName(autoparseKeys[0]);\n         auto tokens = templateName.Tokenize(\"::\");\n         clang::NamedDecl* previousScopeAsNamedDecl = nullptr;\n         clang::DeclContext* previousScopeAsContext = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n         if (TClassEdit::IsStdClass(cls + offset))\n            previousScopeAsContext = fInterpreter->getSema().getStdNamespace();\n         auto nTokens = tokens->GetEntries();\n         for (Int_t tk = 0; tk < nTokens; ++tk) {\n            auto scopeObj = tokens->UncheckedAt(tk);\n            auto scopeName = ((TObjString*) scopeObj)->String().Data();\n            previousScopeAsNamedDecl = cling::utils::Lookup::Named(&fInterpreter->getSema(), scopeName, previousScopeAsContext);\n            // Check if we have multiple nodes in the AST with this name\n            if ((clang::NamedDecl*)-1 == previousScopeAsNamedDecl) break;\n            previousScopeAsContext = llvm::dyn_cast_or_null<clang::DeclContext>(previousScopeAsNamedDecl);\n            if (!previousScopeAsContext) break; // this is not a context\n         }\n         delete tokens;\n         // Now, let's check if the last scope, the template, has a definition, i.e. it's not a fwd decl\n         if ((clang::NamedDecl*)-1 != previousScopeAsNamedDecl) {\n            if (auto templateDecl = llvm::dyn_cast_or_null<clang::ClassTemplateDecl>(previousScopeAsNamedDecl)) {\n               if (auto templatedDecl = templateDecl->getTemplatedDecl()) {\n                  skipFirstEntry = templatedDecl->hasDefinition();\n               }\n            }\n         }\n\n      }\n   }\n   if (topLevel) autoparseKeys.emplace_back(cls);\n\n   for (const auto & apKeyStr : autoparseKeys) {\n      if (skipFirstEntry) {\n         skipFirstEntry=false;\n         continue;\n      }\n      if (apKeyStr.empty()) continue;\n      const char *apKey = apKeyStr.c_str();\n      std::size_t normNameHash(fStringHashFunction(apKey));\n      // If the class was not looked up\n      if (gDebug > 1) {\n         Info(\"TCling::AutoParse\",\n              \"Starting autoparse for %s\\n\", apKey);\n      }\n      if (fLookedUpClasses.insert(normNameHash).second) {\n         auto const &iter = fClassesHeadersMap.find(normNameHash);\n         if (iter != fClassesHeadersMap.end()) {\n            const cling::Transaction *T = fInterpreter->getCurrentTransaction();\n            fTransactionHeadersMap.insert({T,normNameHash});\n            auto const &hNamesPtrs = iter->second;\n            if (gDebug > 1) {\n               Info(\"TCling::AutoParse\",\n                    \"We can proceed for %s. We have %s headers.\", apKey, std::to_string(hNamesPtrs.size()).c_str());\n            }\n            for (auto & hName : hNamesPtrs) {\n               if (fParsedPayloadsAddresses.count(hName) == 1) continue;\n               if (0 != fPayloads.count(normNameHash)) {\n                  float initRSSval=0.f, initVSIZEval=0.f;\n                  (void) initRSSval; // Avoid unused var warning\n                  (void) initVSIZEval;\n                  if (gDebug > 0) {\n                     Info(\"AutoParse\",\n                          \"Parsing full payload for %s\", apKey);\n                     ProcInfo_t info;\n                     gSystem->GetProcInfo(&info);\n                     initRSSval = 1e-3*info.fMemResident;\n                     initVSIZEval = 1e-3*info.fMemVirtual;\n                  }\n                  auto cRes = ExecAutoParse(hName, kFALSE, fInterpreter);\n                  if (cRes != cling::Interpreter::kSuccess) {\n                     if (hName[0] == '\\n')\n                        Error(\"AutoParse\", \"Error parsing payload code for class %s with content:\\n%s\", apKey, hName);\n                  } else {\n                     fParsedPayloadsAddresses.insert(hName);\n                     nHheadersParsed++;\n                     if (gDebug > 0){\n                        ProcInfo_t info;\n                        gSystem->GetProcInfo(&info);\n                        float endRSSval = 1e-3*info.fMemResident;\n                        float endVSIZEval = 1e-3*info.fMemVirtual;\n                        Info(\"Autoparse\", \">>> RSS key %s - before %.3f MB - after %.3f MB - delta %.3f MB\", apKey, initRSSval, endRSSval, endRSSval-initRSSval);\n                        Info(\"Autoparse\", \">>> VSIZE key %s - before %.3f MB - after %.3f MB - delta %.3f MB\", apKey, initVSIZEval, endVSIZEval, endVSIZEval-initVSIZEval);\n                     }\n                  }\n               } else if (!IsLoaded(hName)) {\n                  if (gDebug > 0) {\n                     Info(\"AutoParse\",\n                          \"Parsing single header %s\", hName);\n                  }\n                  auto cRes = ExecAutoParse(hName, kTRUE, fInterpreter);\n                  if (cRes != cling::Interpreter::kSuccess) {\n                     Error(\"AutoParse\", \"Error parsing headerfile %s for class %s.\", hName, apKey);\n                  } else {\n                     nHheadersParsed++;\n                  }\n               }\n            }\n         }\n         else {\n            // There is no header registered for this class, if this a\n            // template, it will be instantiated if/when it is requested\n            // and if we do no load/parse its components we might end up\n            // not using an eventual specialization.\n            if (strchr(apKey, '<')) {\n               nHheadersParsed += AutoParseImplRecurse(apKey, false);\n            }\n         }\n      }\n   }\n\n   return nHheadersParsed;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Parse the headers relative to the class\n/// Returns 1 in case of success, 0 in case of failure\n\nInt_t TCling::AutoParse(const char *cls)\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   if (!fHeaderParsingOnDemand || fIsAutoParsingSuspended) {\n      if (fClingCallbacks->IsAutoloadingEnabled()) {\n         return AutoLoad(cls);\n      } else {\n         return 0;\n      }\n   }\n\n   if (gDebug > 1) {\n      Info(\"TCling::AutoParse\",\n           \"Trying to autoparse for %s\", cls);\n   }\n\n   // The catalogue of headers is in the dictionary\n   if (fClingCallbacks->IsAutoloadingEnabled()\n         && !gClassTable->GetDictNorm(cls)) {\n      // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).\n      ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),\n         fInterpreter->getSema());\n      AutoLoad(cls, true /*knowDictNotLoaded*/);\n   }\n\n   // Prevent the recursion when the library dictionary are loaded.\n   Int_t oldAutoloadValue = SetClassAutoloading(false);\n\n   // No recursive header parsing on demand; we require headers to be standalone.\n   SuspendAutoParsing autoParseRAII(this);\n\n   Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);\n\n   if (nHheadersParsed != 0) {\n      while (!fClassesToUpdate.empty()) {\n         TClass *oldcl = fClassesToUpdate.back().first;\n         if (oldcl->GetState() != TClass::kHasTClassInit) {\n            // if (gDebug > 2) Info(\"RegisterModule\", \"Forcing TClass init for %s\", oldcl->GetName());\n            DictFuncPtr_t dict = fClassesToUpdate.back().second;\n            fClassesToUpdate.pop_back();\n            // Calling func could manipulate the list so, let maintain the list\n            // then call the dictionary function.\n            TClass *ncl = dict();\n            if (ncl) ncl->PostLoadCheck();\n         } else {\n            fClassesToUpdate.pop_back();\n         }\n      }\n   }\n\n   SetClassAutoloading(oldAutoloadValue);\n\n   return nHheadersParsed > 0 ? 1 : 0;\n}\n\n// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.\n// Try to solve the problem by autoloading. Return true when autoloading success, return\n// false if not.\nbool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved)\n{\n   StringRef errMsg(errmessage);\n   if (errMsg.contains(\"undefined symbol: \")) {\n      std::string mangled_name = std::string(errMsg.split(\"undefined symbol: \").second);\n      void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);\n      cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n      if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess))\n        // Return success when LazyFunctionCreatorAutoload could find mangled_name\n        return true;\n   }\n\n   return false;\n}\n\n// This is a GNU implementation of hash used in bloom filter!\nstatic uint32_t GNUHash(StringRef S) {\n   uint32_t H = 5381;\n   for (uint8_t C : S)\n      H = (H << 5) + H + C;\n   return H;\n}\n\nstatic StringRef GetGnuHashSection(llvm::object::ObjectFile *file) {\n   for (auto S : file->sections()) {\n      StringRef name;\n      S.getName(name);\n      if (name == \".gnu.hash\") {\n         StringRef content;\n         S.getContents(content);\n         return content;\n      }\n   }\n   return \"\";\n}\n\n// Bloom filter. See https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2\n// for detailed desctiption. In short, there is a .gnu.hash section in so files which contains\n// bloomfilter hash value that we can compare with our mangled_name hash. This is a false positive\n// probability data structure and enables us to skip libraries which doesn't contain mangled_name definition!\n// PE and Mach-O files doesn't have .gnu.hash bloomfilter section, so this is a specific optimization for ELF.\n// This is fine because performance critical part (data centers) are running on Linux :)\nstatic bool LookupBloomFilter(llvm::object::ObjectFile *soFile, uint32_t hash) {\n   const int bits = 64;\n\n   StringRef contents = GetGnuHashSection(soFile);\n   if (contents.size() < 16)\n      // We need to search if the library doesn't have .gnu.hash section!\n      return true;\n   const char* hashContent = contents.data();\n\n   // See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ for .gnu.hash table layout.\n   uint32_t maskWords = *reinterpret_cast<const uint32_t *>(hashContent + 8);\n   uint32_t shift2 = *reinterpret_cast<const uint32_t *>(hashContent + 12);\n   uint32_t hash2 = hash >> shift2;\n   uint32_t n = (hash / bits) % maskWords;\n\n   const char *bloomfilter = hashContent + 16;\n   const char *hash_pos = bloomfilter + n*(bits/8); // * (Bits / 8)\n   uint64_t word = *reinterpret_cast<const uint64_t *>(hash_pos);\n   uint64_t bitmask = ( (1ULL << (hash % bits)) | (1ULL << (hash2 % bits)));\n   return  (bitmask & word) == bitmask;\n}\n\nstatic void* LazyFunctionCreatorAutoloadForModule(const std::string& mangled_name,\n                                                  cling::Interpreter *fInterpreter) {\n   using namespace llvm::object;\n   using namespace llvm::sys::path;\n   using namespace llvm::sys::fs;\n\n   R__LOCKGUARD(gInterpreterMutex);\n\n   static bool sFirstRun = true;\n   // sLibraies contains pair of sPaths[i] (eg. /home/foo/module) and library name (eg. libTMVA.so). The\n   // reason why we're separating sLibraries and sPaths is that we have a lot of\n   // dupulication in path, for example we have \"/home/foo/module-release/lib/libFoo.so\", \"/home/../libBar.so\", \"/home/../lib..\"\n   // and it's waste of memory to store the full path.\n   static std::vector< std::pair<uint32_t, std::string> > sLibraries;\n   static std::vector<StringRef> sPaths;\n\n   if (sFirstRun) {\n      TCling__FindLoadedLibraries(sLibraries, sPaths, *fInterpreter);\n      sFirstRun = false;\n   }\n\n   uint32_t hashedMangle = GNUHash(mangled_name);\n   // Iterate over files under this path. We want to get each \".so\" files\n   for (std::pair<uint32_t, std::string> &P : sLibraries) {\n      llvm::SmallString<400> Vec(sPaths[P.first]);\n      llvm::sys::path::append(Vec, StringRef(P.second));\n      std::string LibName = Vec.str();\n      auto SoFile = ObjectFile::createObjectFile(LibName);\n      if (SoFile) {\n         auto RealSoFile = SoFile.get().getBinary();\n\n         // Check Bloom filter. If false, it means that this library doesn't contain mangled_name defenition\n         if (!LookupBloomFilter(RealSoFile, hashedMangle))\n            continue;\n\n         auto Symbols = RealSoFile->symbols();\n         for (auto S : Symbols) {\n            uint32_t Flags = S.getFlags();\n            // DO NOT insert to table if symbol was undefined\n            if (Flags & SymbolRef::SF_Undefined)\n               continue;\n\n            // Note, we are at last resort and loading library based on a weak\n            // symbol is allowed. Otherwise, the JIT will issue an unresolved\n            // symbol error.\n            //\n            // There are other weak symbol kinds (marked as 'V') to denote\n            // typeinfo and vtables. It is unclear whether we should load such\n            // libraries or from which library we should resolve the symbol.\n            // We seem to not have a way to differentiate it from the symbol API.\n\n            llvm::Expected<StringRef> SymNameErr = S.getName();\n            if (!SymNameErr) {\n               Warning(\"LazyFunctionCreatorAutoloadForModule\", \"Failed to read symbol\");\n               continue;\n            }\n\n            if (SymNameErr.get() == mangled_name) {\n               if (gSystem->Load(LibName.c_str(), \"\", false) < 0)\n                  Error(\"LazyFunctionCreatorAutoloadForModule\", \"Failed to load library %s\", LibName.c_str());\n\n               // We want to delete a loaded library from sLibraries cache, because sLibraries is\n               // a vector of candidate libraries which might be loaded in the future.\n               sLibraries.erase(std::remove(sLibraries.begin(), sLibraries.end(), P), sLibraries.end());\n               void* addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(mangled_name.c_str());\n               return addr;\n            }\n         }\n      }\n   }\n   return nullptr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Autoload a library based on a missing symbol.\n\nvoid* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {\n   if (fCxxModulesEnabled)\n      return LazyFunctionCreatorAutoloadForModule(mangled_name, fInterpreter);\n\n   // First see whether the symbol is in the library that we are currently\n   // loading. It will have access to the symbols of its dependent libraries,\n   // thus checking \"back()\" is sufficient.\n   if (!fRegisterModuleDyLibs.empty()) {\n      if (void* addr = dlsym(fRegisterModuleDyLibs.back(),\n                             mangled_name.c_str())) {\n         return addr;\n      }\n   }\n\n   int err = 0;\n   char* demangled_name_c = TClassEdit::DemangleName(mangled_name.c_str(), err);\n   if (err) {\n      return 0;\n   }\n\n   std::string name(demangled_name_c);\n   free(demangled_name_c);\n\n   //fprintf(stderr, \"demangled name: '%s'\\n\", demangled_name);\n   //\n   //  Separate out the class or namespace part of the\n   //  function name.\n   //\n\n   std::string::size_type pos = name.find(\"__thiscall \");\n   if (pos != std::string::npos) {\n      name.erase(0, pos + sizeof(\"__thiscall \")-1);\n   }\n   pos = name.find(\"__cdecl \");\n   if (pos != std::string::npos) {\n      name.erase(0, pos + sizeof(\"__cdecl \")-1);\n   }\n   if (!strncmp(name.c_str(), \"typeinfo for \", sizeof(\"typeinfo for \")-1)) {\n      name.erase(0, sizeof(\"typeinfo for \")-1);\n   } else if (!strncmp(name.c_str(), \"vtable for \", sizeof(\"vtable for \")-1)) {\n      name.erase(0, sizeof(\"vtable for \")-1);\n   } else if (!strncmp(name.c_str(), \"operator\", sizeof(\"operator\")-1)\n              && !isalnum(name[sizeof(\"operator\")])) {\n     // operator...(A, B) - let's try with A!\n     name.erase(0, sizeof(\"operator\")-1);\n     pos = name.rfind('(');\n     if (pos != std::string::npos) {\n       name.erase(0, pos + 1);\n       pos = name.find(\",\");\n       if (pos != std::string::npos) {\n         // remove next arg up to end, leaving only the first argument type.\n         name.erase(pos);\n       }\n       pos = name.rfind(\" const\");\n       if (pos != std::string::npos) {\n         name.erase(pos, strlen(\" const\"));\n       }\n       while (!name.empty() && strchr(\"&*\", name.back()))\n         name.erase(name.length() - 1);\n     }\n   } else {\n      TClassEdit::FunctionSplitInfo fsi;\n      TClassEdit::SplitFunction(name, fsi);\n      name = fsi.fScopeName;\n   }\n   //fprintf(stderr, \"name: '%s'\\n\", name.c_str());\n   // Now we have the class or namespace name, so do the lookup.\n   TString libs = GetClassSharedLibs(name.c_str());\n   if (libs.IsNull()) {\n      // Not found in the map, all done.\n      return 0;\n   }\n   //fprintf(stderr, \"library: %s\\n\", iter->second.c_str());\n   // Now we have the name of the libraries to load, so load them.\n\n   TString lib;\n   Ssiz_t posLib = 0;\n   while (libs.Tokenize(lib, posLib)) {\n      if (gSystem->Load(lib, \"\", kFALSE /*system*/) < 0) {\n         // The library load failed, all done.\n         //fprintf(stderr, \"load failed: %s\\n\", errmsg.c_str());\n         return 0;\n      }\n   }\n\n   //fprintf(stderr, \"load succeeded.\\n\");\n   // Get the address of the function being called.\n   void* addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(mangled_name.c_str());\n   //fprintf(stderr, \"addr: %016lx\\n\", reinterpret_cast<unsigned long>(addr));\n   return addr;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TCling::IsAutoLoadNamespaceCandidate(const char* name)\n{\n//    if (fMapNamespaces){\n//       return fMapNamespaces->FindObject(name);\n//    }\n   return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBool_t TCling::IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl)\n{\n   return fNSFromRootmaps.count(nsDecl) != 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.\n\nvoid TCling::UpdateClassInfoWithDecl(const void* vTD)\n{\n   const NamedDecl* ND = static_cast<const NamedDecl*>(vTD);\n   const TagDecl* td = dyn_cast<TagDecl>(ND);\n   std::string name;\n   TagDecl* tdDef = 0;\n   if (td) {\n      tdDef = td->getDefinition();\n      // Let's pass the decl to the TClass only if it has a definition.\n      if (!tdDef) return;\n      td = tdDef;\n      ND = td;\n\n      if (llvm::isa<clang::FunctionDecl>(td->getDeclContext())) {\n         // Ignore declaration within a function.\n         return;\n      }\n      clang::QualType type( td->getTypeForDecl(), 0 );\n\n      auto declName=ND->getNameAsString();\n      if (!TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(declName.c_str())){\n//          printf (\"Impossible to find a TClassEntry in kNoInfo or kEmulated the decl of which would be called %s. Skip w/o building the normalized name.\\n\",declName );\n         return;\n      }\n\n      ROOT::TMetaUtils::GetNormalizedName(name, type, *fInterpreter, *fNormalizedCtxt);\n   } else {\n      name = ND->getNameAsString();\n   }\n\n   // Supposedly we are being called while something is being\n   // loaded ... let's now tell the autoloader to do the work\n   // yet another time.\n   int storedAutoloading = SetClassAutoloading(false);\n   // FIXME: There can be more than one TClass for a single decl.\n   // for example vector<double> and vector<Double32_t>\n   TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name.c_str());\n   if (cl && GetModTClasses().find(cl) == GetModTClasses().end()) {\n      TClingClassInfo* cci = ((TClingClassInfo*)cl->fClassInfo);\n      if (cci) {\n         // If we only had a forward declaration then update the\n         // TClingClassInfo with the definition if we have it now.\n         const TagDecl* tdOld = llvm::dyn_cast_or_null<TagDecl>(cci->GetDecl());\n         if (!tdOld || (tdDef && tdDef != tdOld)) {\n            cl->ResetCaches();\n            TClass::RemoveClassDeclId(cci->GetDeclId());\n            if (td) {\n               // It's a tag decl, not a namespace decl.\n               cci->Init(*cci->GetType());\n               TClass::AddClassToDeclIdMap(cci->GetDeclId(), cl);\n            }\n         }\n      } else if (!cl->TestBit(TClass::kLoading) && !cl->fHasRootPcmInfo) {\n         cl->ResetCaches();\n         // yes, this is almost a waste of time, but we do need to lookup\n         // the 'type' corresponding to the TClass anyway in order to\n         // preserve the opaque typedefs (Double32_t)\n         cl->fClassInfo = (ClassInfo_t *)new TClingClassInfo(fInterpreter, cl->GetName());\n         // We now need to update the state and bits.\n         if (cl->fState != TClass::kHasTClassInit) {\n            // if (!cl->fClassInfo->IsValid()) cl->fState = TClass::kForwardDeclared; else\n            cl->fState = TClass::kInterpreted;\n            cl->ResetBit(TClass::kIsEmulation);\n         }\n         TClass::AddClassToDeclIdMap(((TClingClassInfo*)(cl->fClassInfo))->GetDeclId(), cl);\n      }\n   }\n   SetClassAutoloading(storedAutoloading);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// No op: see TClingCallbacks\n\nvoid TCling::UpdateClassInfo(char* item, Long_t tagnum)\n{\n}\n\n//______________________________________________________________________________\n//FIXME: Factor out that function in TClass, because TClass does it already twice\nvoid TCling::UpdateClassInfoWork(const char* item)\n{\n   // This is a no-op as part of the API.\n   // TCling uses UpdateClassInfoWithDecl() instead.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Update all canvases at end the terminal input command.\n\nvoid TCling::UpdateAllCanvases()\n{\n   TIter next(gROOT->GetListOfCanvases());\n   TVirtualPad* canvas;\n   while ((canvas = (TVirtualPad*)next())) {\n      canvas->Update();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::UpdateListsOnCommitted(const cling::Transaction &T) {\n   std::set<TClass*> modifiedTClasses; // TClasses that require update after this transaction\n\n   // If the transaction does not contain anything we can return earlier.\n   if (!HandleNewTransaction(T)) return;\n\n   bool isTUTransaction = false;\n   if (!T.empty() && T.decls_begin() + 1 == T.decls_end() && !T.hasNestedTransactions()) {\n      clang::Decl* FirstDecl = *(T.decls_begin()->m_DGR.begin());\n      if (llvm::isa<clang::TranslationUnitDecl>(FirstDecl)) {\n         // The is the first transaction, we have to expose to meta\n         // what's already in the AST.\n         isTUTransaction = true;\n      }\n   }\n\n   std::set<const void*> TransactionDeclSet;\n   if (!isTUTransaction && T.decls_end() - T.decls_begin()) {\n      const clang::Decl* WrapperFD = T.getWrapperFD();\n      for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();\n          I != E; ++I) {\n         if (I->m_Call != cling::Transaction::kCCIHandleTopLevelDecl\n             && I->m_Call != cling::Transaction::kCCIHandleTagDeclDefinition)\n            continue;\n\n         for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),\n                 DE = I->m_DGR.end(); DI != DE; ++DI) {\n            if (*DI == WrapperFD)\n               continue;\n            TransactionDeclSet.insert(*DI);\n            ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);\n         }\n      }\n   }\n\n   // The above might trigger more decls to be deserialized.\n   // Thus the iteration over the deserialized decls must be last.\n   for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),\n           E = T.deserialized_decls_end(); I != E; ++I) {\n      for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),\n              DE = I->m_DGR.end(); DI != DE; ++DI)\n         if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {\n            //FIXME: HandleNewDecl should take DeclGroupRef\n            ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,\n                                             modifiedTClasses);\n         }\n   }\n\n\n   // When fully building the reflection info in TClass, a deserialization\n   // could be triggered, which may result in request for building the\n   // reflection info for the same TClass. This in turn will clear the caches\n   // for the TClass in-flight and cause null ptr derefs.\n   // FIXME: This is a quick fix, solving most of the issues. The actual\n   // question is: Shouldn't TClass provide a lock mechanism on update or lock\n   // itself until the update is done.\n   //\n   std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());\n   std::vector<TClass*>::iterator it;\n   it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),\n                       ((TCling*)gCling)->GetModTClasses().begin(),\n                       ((TCling*)gCling)->GetModTClasses().end(),\n                       modifiedTClassesDiff.begin());\n   modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());\n\n   // Lock the TClass for updates\n   ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),\n                                              modifiedTClassesDiff.end());\n   for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),\n           E = modifiedTClassesDiff.end(); I != E; ++I) {\n      // Make sure the TClass has not been deleted.\n      if (!gROOT->GetListOfClasses()->FindObject(*I)) {\n         continue;\n      }\n      // Could trigger deserialization of decls.\n      cling::Interpreter::PushTransactionRAII RAII(fInterpreter);\n      // Unlock the TClass for updates\n      ((TCling*)gCling)->GetModTClasses().erase(*I);\n\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Helper function to go through the members of a class or namespace and unload them.\n\nvoid TCling::UnloadClassMembers(TClass* cl, const clang::DeclContext* DC) {\n\n   TDataMember* var = 0;\n   TFunction* function = 0;\n   TEnum* e = 0;\n   TFunctionTemplate* functiontemplate = 0;\n   TListOfDataMembers* datamembers = (TListOfDataMembers*)cl->GetListOfDataMembers();\n   TListOfFunctions* functions = (TListOfFunctions*)cl->GetListOfMethods();\n   TListOfEnums* enums = (TListOfEnums*)cl->GetListOfEnums();\n   TListOfFunctionTemplates* functiontemplates = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates();\n   for (DeclContext::decl_iterator RI = DC->decls_begin(), RE = DC->decls_end(); RI != RE; ++RI) {\n      if (isa<VarDecl>(*RI) || isa<FieldDecl>(*RI)) {\n         const clang::ValueDecl* VD = dyn_cast<ValueDecl>(*RI);\n         var = (TDataMember*)datamembers->FindObject(VD->getNameAsString().c_str());\n         if (var) {\n            // Unload the global by setting the DataMemberInfo_t to 0\n            datamembers->Unload(var);\n            var->Update(0);\n         }\n      } else if (const FunctionDecl* FD = dyn_cast<FunctionDecl>(*RI)) {\n         function = (TFunction*)functions->FindObject(FD->getNameAsString().c_str());\n         if (function) {\n            functions->Unload(function);\n            function->Update(0);\n         }\n      } else if (const EnumDecl* ED = dyn_cast<EnumDecl>(*RI)) {\n         e = (TEnum*)enums->FindObject(ED->getNameAsString().c_str());\n         if (e) {\n            TIter iEnumConst(e->GetConstants());\n            while (TEnumConstant* enumConst = (TEnumConstant*)iEnumConst()) {\n               // Since the enum is already created and valid that ensures us that\n               // we have the enum constants created as well.\n               enumConst = (TEnumConstant*)datamembers->FindObject(enumConst->GetName());\n               if (enumConst && enumConst->IsValid()) {\n                  datamembers->Unload(enumConst);\n                  enumConst->Update(0);\n               }\n            }\n            enums->Unload(e);\n            e->Update(0);\n         }\n      } else if (const FunctionTemplateDecl* FTD = dyn_cast<FunctionTemplateDecl>(*RI)) {\n         functiontemplate = (TFunctionTemplate*)functiontemplates->FindObject(FTD->getNameAsString().c_str());\n         if (functiontemplate) {\n            functiontemplates->Unload(functiontemplate);\n            functiontemplate->Update(0);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::UpdateListsOnUnloaded(const cling::Transaction &T)\n{\n   HandleNewTransaction(T);\n\n   // Unload the objects from the lists and update the objects' state.\n   TListOfFunctions* functions = (TListOfFunctions*)gROOT->GetListOfGlobalFunctions();\n   TListOfFunctionTemplates* functiontemplates = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();\n   TListOfEnums* enums = (TListOfEnums*)gROOT->GetListOfEnums();\n   TListOfDataMembers* globals = (TListOfDataMembers*)gROOT->GetListOfGlobals();\n   cling::Transaction::const_nested_iterator iNested = T.nested_begin();\n   for(cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();\n       I != E; ++I) {\n      if (I->m_Call == cling::Transaction::kCCIHandleVTable)\n         continue;\n\n      if (I->m_Call == cling::Transaction::kCCINone) {\n         UpdateListsOnUnloaded(**iNested);\n         ++iNested;\n         continue;\n      }\n\n      for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),\n              DE = I->m_DGR.end(); DI != DE; ++DI) {\n\n         // Do not mark a decl as unloaded if we are going to keep it\n         // (because it comes from the pch) ...\n         if ( (*DI)->isFromASTFile() )\n            continue;\n\n         // Deal with global variables and global enum constants.\n         if (isa<VarDecl>(*DI) || isa<EnumConstantDecl>(*DI)) {\n            TObject *obj = globals->Find((TListOfDataMembers::DeclId_t)*DI);\n            if (globals->GetClass()) {\n               TDataMember* var = dynamic_cast<TDataMember*>(obj);\n               if (var && var->IsValid()) {\n                  // Unload the global by setting the DataMemberInfo_t to 0\n                  globals->Unload(var);\n                  var->Update(0);\n               }\n            } else {\n               TGlobal *g = dynamic_cast<TGlobal*>(obj);\n               if (g && g->IsValid()) {\n                  // Unload the global by setting the DataMemberInfo_t to 0\n                  globals->Unload(g);\n                  g->Update(0);\n               }\n            }\n         // Deal with global functions.\n         } else if (const FunctionDecl* FD = dyn_cast<FunctionDecl>(*DI)) {\n            TFunction* function = (TFunction*)functions->Find((TListOfFunctions::DeclId_t)FD);\n            if (function && function->IsValid()) {\n               functions->Unload(function);\n               function->Update(0);\n            }\n         // Deal with global function templates.\n         } else if (const FunctionTemplateDecl* FTD = dyn_cast<FunctionTemplateDecl>(*DI)) {\n            TFunctionTemplate* functiontemplate = (TFunctionTemplate*)functiontemplates->FindObject(FTD->getNameAsString().c_str());\n            if (functiontemplate) {\n               functiontemplates->Unload(functiontemplate);\n               functiontemplate->Update(0);\n            }\n         // Deal with global enums.\n         } else if (const EnumDecl* ED = dyn_cast<EnumDecl>(*DI)) {\n            if (TEnum* e = (TEnum*)enums->Find((TListOfEnums::DeclId_t)ED)) {\n               globals = (TListOfDataMembers*)gROOT->GetListOfGlobals();\n               TIter iEnumConst(e->GetConstants());\n               while (TEnumConstant* enumConst = (TEnumConstant*)iEnumConst()) {\n                  // Since the enum is already created and valid that ensures us that\n                  // we have the enum constants created as well.\n                  enumConst = (TEnumConstant*)globals->FindObject(enumConst->GetName());\n                  if (enumConst) {\n                     globals->Unload(enumConst);\n                     enumConst->Update(0);\n                  }\n               }\n               enums->Unload(e);\n               e->Update(0);\n            }\n         // Deal with classes. Unload the class and the data members will be not accessible anymore\n         // Cannot declare the members in a different declaration like redeclarable namespaces.\n         } else if (const clang::RecordDecl* RD = dyn_cast<RecordDecl>(*DI)) {\n            std::vector<TClass*> vectTClass;\n            // Only update the TClass if the definition is being unloaded.\n            if (RD->isCompleteDefinition()) {\n               if (TClass::GetClass(RD, vectTClass)) {\n                  for (std::vector<TClass*>::iterator CI = vectTClass.begin(), CE = vectTClass.end();\n                       CI != CE; ++CI) {\n                     UnloadClassMembers((*CI), RD);\n                     (*CI)->ResetClassInfo();\n                  }\n               }\n            }\n         // Deal with namespaces. Unload the members of the current redeclaration only.\n         } else if (const clang::NamespaceDecl* ND = dyn_cast<NamespaceDecl>(*DI)) {\n            std::vector<TClass*> vectTClass;\n            if (TClass::GetClass(ND->getCanonicalDecl(), vectTClass)) {\n               for (std::vector<TClass*>::iterator CI = vectTClass.begin(), CE = vectTClass.end();\n                    CI != CE; ++CI) {\n                  UnloadClassMembers((*CI), ND);\n                  if (ND->isOriginalNamespace()) {\n                     (*CI)->ResetClassInfo();\n                  }\n               }\n            }\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// If an autoparse was done during a transaction and that it is rolled back,\n// we need to make sure the next request for the same autoparse will be\n// honored.\nvoid TCling::TransactionRollback(const cling::Transaction &T) {\n   auto const &triter = fTransactionHeadersMap.find(&T);\n   if (triter != fTransactionHeadersMap.end()) {\n      std::size_t normNameHash = triter->second;\n\n      fLookedUpClasses.erase(normNameHash);\n\n      auto const &iter = fClassesHeadersMap.find(normNameHash);\n      if (iter != fClassesHeadersMap.end()) {\n         auto const &hNamesPtrs = iter->second;\n         for (auto &hName : hNamesPtrs) {\n            if (gDebug > 0) {\n               Info(\"TransactionRollback\",\n                    \"Restoring ability to autoaparse: %s\", hName);\n            }\n            fParsedPayloadsAddresses.erase(hName);\n         }\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::LibraryLoaded(const void* dyLibHandle, const char* canonicalName) {\n// UpdateListOfLoadedSharedLibraries();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::LibraryUnloaded(const void* dyLibHandle, const char* canonicalName) {\n   fPrevLoadedDynLibInfo = 0;\n   fSharedLibs = \"\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the list of shared libraries loaded into the process.\n\nconst char* TCling::GetSharedLibs()\n{\n   UpdateListOfLoadedSharedLibraries();\n   return fSharedLibs;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the list of shared libraries containing the code for class cls.\n/// The first library in the list is the one containing the class, the\n/// others are the libraries the first one depends on. Returns 0\n/// in case the library is not found.\n\nconst char* TCling::GetClassSharedLibs(const char* cls)\n{\n   if (!cls || !*cls) {\n      return 0;\n   }\n   // lookup class to find list of libraries\n   if (fMapfile) {\n      TEnvRec* libs_record = 0;\n      libs_record = fMapfile->Lookup(cls);\n      if (libs_record) {\n         const char* libs = libs_record->GetValue();\n         return (*libs) ? libs : 0;\n      }\n      else {\n         // Try the old format...\n         TString c = TString(\"Library.\") + cls;\n         // convert \"::\" to \"@@\", we used \"@@\" because TEnv\n         // considers \"::\" a terminator\n         c.ReplaceAll(\"::\", \"@@\");\n         // convert \"-\" to \" \", since class names may have\n         // blanks and TEnv considers a blank a terminator\n         c.ReplaceAll(\" \", \"-\");\n         // Use TEnv::Lookup here as the rootmap file must start with Library.\n         // and do not support using any stars (so we do not need to waste time\n         // with the search made by TEnv::GetValue).\n         TEnvRec* libs_record = 0;\n         libs_record = fMapfile->Lookup(c);\n         if (libs_record) {\n            const char* libs = libs_record->GetValue();\n            return (*libs) ? libs : 0;\n         }\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the list a libraries on which the specified lib depends. The\n/// returned string contains as first element the lib itself.\n/// Returns 0 in case the lib does not exist or does not have\n/// any dependencies.\n\nconst char* TCling::GetSharedLibDeps(const char* lib)\n{\n   if (!fMapfile || !lib || !lib[0]) {\n      return 0;\n   }\n   TString libname(lib);\n   Ssiz_t idx = libname.Last('.');\n   if (idx != kNPOS) {\n      libname.Remove(idx);\n   }\n   TEnvRec* rec;\n   TIter next(fMapfile->GetTable());\n   size_t len = libname.Length();\n   while ((rec = (TEnvRec*) next())) {\n      const char* libs = rec->GetValue();\n      if (!strncmp(libs, libname.Data(), len) && strlen(libs) >= len\n            && (!libs[len] || libs[len] == ' ' || libs[len] == '.')) {\n         return libs;\n      }\n   }\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If error messages are disabled, the interpreter should suppress its\n/// failures and warning messages from stdout.\n\nBool_t TCling::IsErrorMessagesEnabled() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"IsErrorMessagesEnabled\", \"Interface not available yet.\");\n#endif\n#endif\n   return kTRUE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If error messages are disabled, the interpreter should suppress its\n/// failures and warning messages from stdout. Return the previous state.\n\nBool_t TCling::SetErrorMessages(Bool_t enable)\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetErrorMessages\", \"Interface not available yet.\");\n#endif\n#endif\n   return TCling::IsErrorMessagesEnabled();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Refresh the list of include paths known to the interpreter and return it\n/// with -I prepended.\n\nconst char* TCling::GetIncludePath()\n{\n   R__LOCKGUARD(gInterpreterMutex);\n\n   fIncludePath = \"\";\n\n   llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.\n   //false - no system header, true - with flags.\n   fInterpreter->GetIncludePaths(includePaths, false, true);\n   if (const size_t nPaths = includePaths.size()) {\n      assert(!(nPaths & 1) && \"GetIncludePath, number of paths and options is not equal\");\n\n      for (size_t i = 0; i < nPaths; i += 2) {\n         if (i)\n            fIncludePath.Append(' ');\n         fIncludePath.Append(includePaths[i].c_str());\n\n         if (includePaths[i] != \"-I\")\n            fIncludePath.Append(' ');\n         fIncludePath.Append('\"');\n         fIncludePath.Append(includePaths[i + 1], includePaths[i + 1].length());\n         fIncludePath.Append('\"');\n      }\n   }\n\n   return fIncludePath;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the directory containing CINT's stl cintdlls.\n\nconst char* TCling::GetSTLIncludePath() const\n{\n   return \"\";\n}\n\n//______________________________________________________________________________\n//                      M I S C\n//______________________________________________________________________________\n\nint TCling::DisplayClass(FILE* /*fout*/, const char* /*name*/, int /*base*/, int /*start*/) const\n{\n   // Interface to cling function\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nint TCling::DisplayIncludePath(FILE *fout) const\n{\n   assert(fout != 0 && \"DisplayIncludePath, 'fout' parameter is null\");\n\n   llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.\n   //false - no system header, true - with flags.\n   fInterpreter->GetIncludePaths(includePaths, false, true);\n   if (const size_t nPaths = includePaths.size()) {\n      assert(!(nPaths & 1) && \"DisplayIncludePath, number of paths and options is not equal\");\n\n      std::string allIncludes(\"include path:\");\n      for (size_t i = 0; i < nPaths; i += 2) {\n         allIncludes += ' ';\n         allIncludes += includePaths[i];\n\n         if (includePaths[i] != \"-I\")\n            allIncludes += ' ';\n         allIncludes += includePaths[i + 1];\n      }\n\n      fprintf(fout, \"%s\\n\", allIncludes.c_str());\n   }\n\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid* TCling::FindSym(const char* entry) const\n{\n   return fInterpreter->getAddressOfGlobal(entry);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Let the interpreter issue a generic error, and set its error state.\n\nvoid TCling::GenericError(const char* error) const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"GenericError\",\"Interface not available yet.\");\n#endif\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// This routines used to return the address of the internal wrapper\n/// function (of the interpreter) that was used to call *all* the\n/// interpreted functions that were bytecode compiled (no longer\n/// interpreted line by line).  In Cling, there is no such\n/// wrapper function.\n/// In practice this routines was use to decipher whether the\n/// pointer returns by InterfaceMethod could be used to uniquely\n/// represent the function.  In Cling if the function is in a\n/// useable state (its compiled version is available), this is\n/// always the case.\n/// See TClass::GetMethod.\n\nLong_t TCling::GetExecByteCode() const\n{\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nint TCling::GetSecurityError() const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"GetSecurityError\", \"Interface not available yet.\");\n#endif\n#endif\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load a source file or library called path into the interpreter.\n\nint TCling::LoadFile(const char* path) const\n{\n   cling::Interpreter::CompilationResult compRes;\n   HandleInterpreterException(fMetaProcessor, TString::Format(\".L %s\", path), compRes, /*cling::Value*/0);\n   return compRes == cling::Interpreter::kFailure;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Load the declarations from text into the interpreter.\n/// Note that this cannot be (top level) statements; text must contain\n/// top level declarations.\n/// Returns true on success, false on failure.\n\nBool_t TCling::LoadText(const char* text) const\n{\n   return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nconst char* TCling::MapCppName(const char* name) const\n{\n   TTHREAD_TLS_DECL(std::string,buffer);\n   ROOT::TMetaUtils::GetCppName(buffer,name);\n   return buffer.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// [Place holder for Mutex Lock]\n/// Provide the interpreter with a way to\n/// acquire a lock used to protect critical section\n/// of its code (non-thread safe parts).\n\nvoid TCling::SetAlloclockfunc(void (* /* p */ )()) const\n{\n   // nothing to do for now.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// [Place holder for Mutex Unlock] Provide the interpreter with a way to\n/// release a lock used to protect critical section\n/// of its code (non-thread safe parts).\n\nvoid TCling::SetAllocunlockfunc(void (* /* p */ )()) const\n{\n   // nothing to do for now.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable/Disable the Autoloading of libraries.\n/// Returns the old value, i.e whether it was enabled or not.\n\nint TCling::SetClassAutoloading(int autoload) const\n{\n   if (!autoload && !fClingCallbacks) return false;\n   if (!fAllowLibLoad) return false;\n\n   assert(fClingCallbacks && \"We must have callbacks!\");\n   bool oldVal =  fClingCallbacks->IsAutoloadingEnabled();\n   fClingCallbacks->SetAutoloadingEnabled(autoload);\n   return oldVal;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Enable/Disable the Autoparsing of headers.\n/// Returns the old value, i.e whether it was enabled or not.\n\nint TCling::SetClassAutoparsing(int autoparse)\n{\n   bool oldVal = fHeaderParsingOnDemand;\n   fHeaderParsingOnDemand = autoparse;\n   return oldVal;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Suspend the Autoparsing of headers.\n/// Returns the old value, i.e whether it was suspended or not.\n\nBool_t TCling::SetSuspendAutoParsing(Bool_t value) {\n   Bool_t old = fIsAutoParsingSuspended;\n   fIsAutoParsingSuspended = value;\n   if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);\n   return old;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Set a callback to receive error messages.\n\nvoid TCling::SetErrmsgcallback(void* p) const\n{\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n   Warning(\"SetErrmsgcallback\", \"Interface not available yet.\");\n#endif\n#endif\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// Create / close a scope for temporaries. No-op for cling; use\n/// cling::Value instead.\n\nvoid TCling::SetTempLevel(int val) const\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::UnloadFile(const char* path) const\n{\n   cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();\n   std::string canonical = DLM->lookupLibrary(path);\n   if (canonical.empty()) {\n      canonical = path;\n   }\n   // Unload a shared library or a source file.\n   cling::Interpreter::CompilationResult compRes;\n   HandleInterpreterException(fMetaProcessor, Form(\".U %s\", canonical.c_str()), compRes, /*cling::Value*/0);\n   return compRes == cling::Interpreter::kFailure;\n}\n\nstd::unique_ptr<TInterpreterValue> TCling::MakeInterpreterValue() const {\n   return std::unique_ptr<TInterpreterValue>(new TClingValue);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// The call to Cling's tab complition.\n\nvoid TCling::CodeComplete(const std::string& line, size_t& cursor,\n                          std::vector<std::string>& completions)\n{\n   fInterpreter->codeComplete(line, cursor, completions);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Get the interpreter value corresponding to the statement.\nint TCling::Evaluate(const char* code, TInterpreterValue& value)\n{\n   auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());\n   auto compRes = fInterpreter->evaluate(code, *V);\n   return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::RegisterTemporary(const TInterpreterValue& value)\n{\n   using namespace cling;\n   const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());\n   RegisterTemporary(*V);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Register value as a temporary, extending its lifetime to that of the\n/// interpreter. This is needed for TCling's compatibility interfaces\n/// returning long - the address of the temporary objects.\n/// As such, \"simple\" types don't need to be stored; they are returned by\n/// value; only pointers / references / objects need to be stored.\n\nvoid TCling::RegisterTemporary(const cling::Value& value)\n{\n   if (value.isValid() && value.needsManagedAllocation()) {\n      R__LOCKGUARD(gInterpreterMutex);\n      fTemporaries->push_back(value);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// If the interpreter encounters Name, check whether that is an object ROOT\n/// could retrieve. To not re-read objects from disk, cache the name/object\n/// pair for a given LookupCtx.\n\nTObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx)\n{\n   // The call to FindSpecialObject might induces any kind of use\n   // of the interpreter ... (library loading, function calling, etc.)\n   // ... and we _know_ we are in the middle of parsing, so let's make\n   // sure to save the state and then restore it.\n\n   if (gDirectory) {\n      auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);\n      if (iSpecObjMap != fSpecialObjectMaps.end()) {\n         auto iSpecObj = iSpecObjMap->second.find(Name);\n         if (iSpecObj != iSpecObjMap->second.end()) {\n            LookupCtx = gDirectory;\n            return iSpecObj->second;\n         }\n      }\n   }\n\n   // Save state of the PP\n   Sema &SemaR = fInterpreter->getSema();\n   ASTContext& C = SemaR.getASTContext();\n   Preprocessor &PP = SemaR.getPreprocessor();\n   Parser& P = const_cast<Parser&>(fInterpreter->getParser());\n   Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);\n   Parser::ParserCurTokRestoreRAII savedCurToken(P);\n   // After we have saved the token reset the current one to something which\n   // is safe (semi colon usually means empty decl)\n   Token& Tok = const_cast<Token&>(P.getCurToken());\n   Tok.setKind(tok::semi);\n\n   // We can't PushDeclContext, because we go up and the routine that pops\n   // the DeclContext assumes that we drill down always.\n   // We have to be on the global context. At that point we are in a\n   // wrapper function so the parent context must be the global.\n   Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),\n                                          SemaR.TUScope);\n\n   TObject* specObj = gROOT->FindSpecialObject(Name, LookupCtx);\n   if (specObj) {\n      if (!LookupCtx) {\n         Error(\"GetObjectAddress\", \"Got a special object without LookupCtx!\");\n      } else {\n         fSpecialObjectMaps[LookupCtx][Name] = specObj;\n      }\n   }\n   return specObj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Inject function as a friend into klass.\n/// With function being f in void f() {new N::PrivKlass(); } this enables\n/// I/O of non-public classes.\n\nvoid TCling::AddFriendToClass(clang::FunctionDecl* function,\n                              clang::CXXRecordDecl* klass) const\n{\n   using namespace clang;\n   ASTContext& Ctx = klass->getASTContext();\n   FriendDecl::FriendUnion friendUnion(function);\n   // one dummy object for the source location\n   SourceLocation sl;\n   FriendDecl* friendDecl = FriendDecl::Create(Ctx, klass, sl, friendUnion, sl);\n   klass->pushFriendDecl(friendDecl);\n}\n\n//______________________________________________________________________________\n//\n//  DeclId getter.\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// CallFunc\n\nTInterpreter::DeclId_t TCling::GetDeclId(CallFunc_t* func) const\n{\n   if (func) return ((TClingCallFunc*)func)->GetDecl()->getCanonicalDecl();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a (almost) unique identifier of the declaration represented by the\n/// ClassInfo.  In ROOT, this identifier can point to more than one TClass\n/// when the underlying class is a template instance involving one of the\n/// opaque typedef.\n\nTInterpreter::DeclId_t TCling::GetDeclId(ClassInfo_t* cinfo) const\n{\n   if (cinfo) return ((TClingClassInfo*)cinfo)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// MethodInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(DataMemberInfo_t* data) const\n{\n   if (data) return ((TClingDataMemberInfo*)data)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// MethodInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(MethodInfo_t* method) const\n{\n   if (method) return ((TClingMethodInfo*)method)->GetDeclId();\n   return 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// TypedefInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(TypedefInfo_t* tinfo) const\n{\n   if (tinfo) return ((TClingTypedefInfo*)tinfo)->GetDecl()->getCanonicalDecl();\n   return 0;\n}\n\n//______________________________________________________________________________\n//\n//  CallFunc interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Delete(CallFunc_t* func) const\n{\n   delete (TClingCallFunc*) func;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Exec(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Exec(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Exec(CallFunc_t* func, void* address, TInterpreterValue& val) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Exec(address, &val);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ExecWithReturn(CallFunc_t* func, void* address, void* ret) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ExecWithReturn(address, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ExecWithArgsAndReturn(CallFunc_t* func, void* address,\n                                            const void* args[] /*=0*/,\n                                            int nargs /*=0*/,\n                                            void* ret/*=0*/) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ExecWithArgsAndReturn(address, args, nargs, ret);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::CallFunc_ExecInt(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecInt(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong64_t TCling::CallFunc_ExecInt64(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecInt64(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDouble_t TCling::CallFunc_ExecDouble(CallFunc_t* func, void* address) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->ExecDouble(address);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nCallFunc_t* TCling::CallFunc_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (CallFunc_t*) new TClingCallFunc(fInterpreter,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nCallFunc_t* TCling::CallFunc_FactoryCopy(CallFunc_t* func) const\n{\n   return (CallFunc_t*) new TClingCallFunc(*(TClingCallFunc*)func);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::CallFunc_FactoryMethod(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return (MethodInfo_t*) f->FactoryMethod();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_IgnoreExtraArgs(CallFunc_t* func, bool ignore) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->IgnoreExtraArgs(ignore);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_Init(CallFunc_t* func) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->Init();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::CallFunc_IsValid(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTInterpreter::CallFuncIFacePtr_t\nTCling::CallFunc_IFacePtr(CallFunc_t * func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   return f->IFacePtr();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_ResetArg(CallFunc_t* func) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->ResetArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Long_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, ULong_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Float_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Double_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, Long64_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArg(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArgArray(paramArr, nparam);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetArgs(CallFunc_t* func, const char* param) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   f->SetArgs(param);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* offset) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFunc(ci, method, params, offset);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, Long_t* offset) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFunc(ci, method, params, objectIsConst, offset);\n}\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingMethodInfo* minfo = (TClingMethodInfo*) info;\n   f->SetFunc(minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFuncProto(ci, method, proto, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   f->SetFuncProto(ci, method, proto, objectIsConst, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   llvm::SmallVector<clang::QualType, 4> funcProto;\n   for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();\n        iter != end; ++iter) {\n      funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );\n   }\n   f->SetFuncProto(ci, method, funcProto, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingCallFunc* f = (TClingCallFunc*) func;\n   TClingClassInfo* ci = (TClingClassInfo*) info;\n   llvm::SmallVector<clang::QualType, 4> funcProto;\n   for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();\n        iter != end; ++iter) {\n      funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );\n   }\n   f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);\n}\n\nstd::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const\n{\n   TClingCallFunc *f = (TClingCallFunc *)func;\n   std::string wrapper_name;\n   std::string wrapper;\n   f->get_wrapper_code(wrapper_name, wrapper);\n   return wrapper;\n}\n\n//______________________________________________________________________________\n//\n//  ClassInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return true if the entity pointed to by 'declid' is declared in\n/// the context described by 'info'.  If info is null, look into the\n/// global scope (translation unit scope).\n\nBool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const\n{\n   if (!declid) return kFALSE;\n\n   const clang::Decl *scope;\n   if (info) scope = ((TClingClassInfo*)info)->GetDecl();\n   else scope = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();\n\n   const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);\n   const clang::DeclContext *ctxt = clang::Decl::castToDeclContext(scope);\n   if (!decl || !ctxt) return kFALSE;\n   if (decl->getDeclContext()->Equals(ctxt))\n      return kTRUE;\n   else if (decl->getDeclContext()->isTransparentContext() &&\n            decl->getDeclContext()->getParent()->Equals(ctxt))\n      return kTRUE;\n   return kFALSE;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_ClassProperty(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->ClassProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Delete(ClassInfo_t* cinfo) const\n{\n   delete (TClingClassInfo*) cinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Delete(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Delete(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_DeleteArray(ClassInfo_t* cinfo, void* arena, bool dtorOnly) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->DeleteArray(arena, dtorOnly,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Destruct(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Destruct(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(Bool_t all) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (ClassInfo_t*) new TClingClassInfo(fInterpreter, all);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(ClassInfo_t* cinfo) const\n{\n   return (ClassInfo_t*) new TClingClassInfo(*(TClingClassInfo*)cinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t* TCling::ClassInfo_Factory(const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (ClassInfo_t*) new TClingClassInfo(fInterpreter, name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_GetMethodNArg(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst /* = false */, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->GetMethodNArg(method, proto, objectIsConst, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_HasDefaultConstructor(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->HasDefaultConstructor();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_HasMethod(ClassInfo_t* cinfo, const char* name) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->HasMethod(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Init(ClassInfo_t* cinfo, const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ClassInfo_Init(ClassInfo_t* cinfo, int tagnum) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TClinginfo->Init(tagnum);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsBase(ClassInfo_t* cinfo, const char* name) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsBase(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsEnum(const char* name) const\n{\n   return TClingClassInfo::IsEnum(fInterpreter, name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsLoaded(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsLoaded();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValid(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValidMethod(method, proto, false, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->IsValidMethod(method, proto, objectIsConst, offset, mode);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_Next(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, int n) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(n,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, int n, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(n, arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::ClassInfo_New(ClassInfo_t* cinfo, void* arena) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->New(arena,*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_Property(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::ClassInfo_Size(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_Tagnum(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Tagnum();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_FileName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->FileName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_FullName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   TTHREAD_TLS_DECL(std::string,output);\n   TClinginfo->FullName(output,*fNormalizedCtxt);\n   return output.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_Name(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_Title(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::ClassInfo_TmpltName(ClassInfo_t* cinfo) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return TClinginfo->TmpltName();\n}\n\n\n\n//______________________________________________________________________________\n//\n//  BaseClassInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::BaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const\n{\n   delete(TClingBaseClassInfo*) bcinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* cinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;\n   return (BaseClassInfo_t*) new TClingBaseClassInfo(fInterpreter, TClinginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nBaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* derived,\n   ClassInfo_t* base) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) derived;\n   TClingClassInfo* TClinginfoBase = (TClingClassInfo*) base;\n   return (BaseClassInfo_t*) new TClingBaseClassInfo(fInterpreter, TClinginfo, TClinginfoBase);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::BaseClassInfo_Next(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Next(onlyDirect);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) toBaseClassInfo;\n   return TClinginfo->Offset(address, isDerivedObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const\n{\n   TClingClassInfo* TClinginfo = (TClingClassInfo*) fromDerived;\n   TClingClassInfo* TClinginfoBase = (TClingClassInfo*) toBase;\n   // Offset to the class itself.\n   if (TClinginfo->GetDecl() == TClinginfoBase->GetDecl()) {\n      return 0;\n   }\n   return TClinginfo->GetBaseOffset(TClinginfoBase, address, isDerivedObject);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Property(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nClassInfo_t *TCling::BaseClassInfo_ClassInfo(BaseClassInfo_t *bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return (ClassInfo_t *)TClinginfo->GetBase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::BaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Tagnum();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   TTHREAD_TLS_DECL(std::string,output);\n   TClinginfo->FullName(output,*fNormalizedCtxt);\n   return output.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const\n{\n   TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) bcinfo;\n   return TClinginfo->TmpltName();\n}\n\n//______________________________________________________________________________\n//\n//  DataMemberInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_ArrayDim(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->ArrayDim();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::DataMemberInfo_Delete(DataMemberInfo_t* dminfo) const\n{\n   delete(TClingDataMemberInfo*) dminfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_Factory(ClassInfo_t* clinfo /*= 0*/) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingClassInfo* TClingclass_info = (TClingClassInfo*) clinfo;\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(fInterpreter, TClingclass_info);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_Factory(DeclId_t declid, ClassInfo_t* clinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   const clang::Decl* decl = reinterpret_cast<const clang::Decl*>(declid);\n   const clang::ValueDecl* vd = llvm::dyn_cast_or_null<clang::ValueDecl>(decl);\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(fInterpreter, vd, (TClingClassInfo*)clinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nDataMemberInfo_t* TCling::DataMemberInfo_FactoryCopy(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return (DataMemberInfo_t*) new TClingDataMemberInfo(*TClinginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::DataMemberInfo_IsValid(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->MaxIndex(dim);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_Next(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Offset();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_Property(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeSize();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->TypeTrueName(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_Name(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_Title(DataMemberInfo_t* dminfo) const\n{\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const\n{\n   TTHREAD_TLS_DECL(std::string,result);\n\n   TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;\n   result = TClinginfo->ValidArrayIndex().str();\n   return result.c_str();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::SetDeclAttr(DeclId_t declId, const char* attribute)\n{\n   Decl* decl = static_cast<Decl*>(const_cast<void*>(declId));\n   ASTContext &C = decl->getASTContext();\n   SourceRange commentRange; // this is a fake comment range\n   decl->addAttr( new (C) AnnotateAttr( commentRange, C, attribute, 0 ) );\n}\n\n//______________________________________________________________________________\n//\n// Function Template interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nstatic void ConstructorName(std::string &name, const clang::NamedDecl *decl,\n                            cling::Interpreter &interp,\n                            const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)\n{\n   const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());\n   if (!td) return;\n\n   clang::QualType qualType(td->getTypeForDecl(),0);\n   ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);\n   unsigned int level = 0;\n   for(size_t cursor = name.length()-1; cursor != 0; --cursor) {\n      if (name[cursor] == '>') ++level;\n      else if (name[cursor] == '<' && level) --level;\n      else if (level == 0 && name[cursor] == ':') {\n         name.erase(0,cursor+1);\n         break;\n      }\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::GetFunctionName(const clang::FunctionDecl *decl, std::string &output) const\n{\n   output.clear();\n   if (llvm::isa<clang::CXXConstructorDecl>(decl))\n   {\n      ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);\n\n   } else if (llvm::isa<clang::CXXDestructorDecl>(decl))\n   {\n      ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);\n      output.insert(output.begin(), '~');\n   } else {\n      llvm::raw_string_ostream stream(output);\n      auto printPolicy = decl->getASTContext().getPrintingPolicy();\n      // Don't trigger fopen of the source file to count lines:\n      printPolicy.AnonymousTagLocations = false;\n      decl->getNameForDiagnostic(stream, printPolicy, /*Qualified=*/false);\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return a unique identifier of the declaration represented by the\n/// FuncTempInfo\n\nTInterpreter::DeclId_t TCling::GetDeclId(FuncTempInfo_t *info) const\n{\n   return (DeclId_t)info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Delete the FuncTempInfo_t\n\nvoid   TCling::FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Construct a FuncTempInfo_t\n\nFuncTempInfo_t *TCling::FuncTempInfo_Factory(DeclId_t declid) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return (FuncTempInfo_t*)const_cast<void*>(declid);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Construct a FuncTempInfo_t\n\nFuncTempInfo_t *TCling::FuncTempInfo_FactoryCopy(FuncTempInfo_t *ft_info) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return (FuncTempInfo_t*)ft_info;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Check validity of a FuncTempInfo_t\n\nBool_t TCling::FuncTempInfo_IsValid(FuncTempInfo_t *t_info) const\n{\n   // Currently the address of ft_info is actually the decl itself,\n   // so we have nothing to do.\n\n   return t_info != 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the maximum number of template arguments of the\n/// function template described by ft_info.\n\nUInt_t TCling::FuncTempInfo_TemplateNargs(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n   const clang::FunctionTemplateDecl *ft = (const clang::FunctionTemplateDecl*)ft_info;\n   return ft->getTemplateParameters()->size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the number of required template arguments of the\n/// function template described by ft_info.\n\nUInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n   return ft->getTemplateParameters()->getMinRequiredArguments();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the property of the function template.\n\nLong_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const\n{\n   if (!ft_info) return 0;\n\n   long property = 0L;\n   property |= kIsCompiled;\n\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n\n   switch (ft->getAccess()) {\n      case clang::AS_public:\n         property |= kIsPublic;\n         break;\n      case clang::AS_protected:\n         property |= kIsProtected;\n         break;\n      case clang::AS_private:\n         property |= kIsPrivate;\n         break;\n      case clang::AS_none:\n         if (ft->getDeclContext()->isNamespace())\n            property |= kIsPublic;\n         break;\n      default:\n         // IMPOSSIBLE\n         break;\n   }\n\n   const clang::FunctionDecl *fd = ft->getTemplatedDecl();\n   if (const clang::CXXMethodDecl *md =\n       llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {\n      if (md->getTypeQualifiers() & clang::Qualifiers::Const) {\n         property |= kIsConstant | kIsConstMethod;\n      }\n      if (md->isVirtual()) {\n         property |= kIsVirtual;\n      }\n      if (md->isPure()) {\n         property |= kIsPureVirtual;\n      }\n      if (const clang::CXXConstructorDecl *cd =\n          llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {\n         if (cd->isExplicit()) {\n            property |= kIsExplicit;\n         }\n      }\n      else if (const clang::CXXConversionDecl *cd =\n               llvm::dyn_cast<clang::CXXConversionDecl>(md)) {\n         if (cd->isExplicit()) {\n            property |= kIsExplicit;\n         }\n      }\n   }\n   return property;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the name of this function template.\n\nvoid TCling::FuncTempInfo_Name(FuncTempInfo_t *ft_info, TString &output) const\n{\n   output.Clear();\n   if (!ft_info) return;\n   const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;\n   std::string buf;\n   GetFunctionName(ft->getTemplatedDecl(), buf);\n   output = buf;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Return the comments associates with this function template.\n\nvoid TCling::FuncTempInfo_Title(FuncTempInfo_t *ft_info, TString &output) const\n{\n   output.Clear();\n   if (!ft_info) return;\n   const clang::FunctionTemplateDecl *ft = (const clang::FunctionTemplateDecl*)ft_info;\n\n   // Iterate over the redeclarations, we can have multiple definitions in the\n   // redecl chain (came from merging of pcms).\n   if (const RedeclarableTemplateDecl *AnnotFD\n       = ROOT::TMetaUtils::GetAnnotatedRedeclarable((const RedeclarableTemplateDecl*)ft)) {\n      if (AnnotateAttr *A = AnnotFD->getAttr<AnnotateAttr>()) {\n         output = A->getAnnotation().str();\n         return;\n      }\n   }\n   if (!ft->isFromASTFile()) {\n      // Try to get the comment from the header file if present\n      // but not for decls from AST file, where rootcling would have\n      // created an annotation\n      output = ROOT::TMetaUtils::GetComment(*ft).str();\n   }\n}\n\n\n//______________________________________________________________________________\n//\n//  MethodInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n/// Interface to cling function\n\nvoid TCling::MethodInfo_Delete(MethodInfo_t* minfo) const\n{\n   delete(TClingMethodInfo*) minfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   info->CreateSignature(signature);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodInfo_t*) new TClingMethodInfo(fInterpreter);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory(ClassInfo_t* clinfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodInfo_t*) new TClingMethodInfo(fInterpreter, (TClingClassInfo*)clinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_Factory(DeclId_t declid) const\n{\n   const clang::Decl* decl = reinterpret_cast<const clang::Decl*>(declid);\n   R__LOCKGUARD(gInterpreterMutex);\n   const clang::FunctionDecl* fd = llvm::dyn_cast_or_null<clang::FunctionDecl>(decl);\n   return (MethodInfo_t*) new TClingMethodInfo(fInterpreter, fd);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodInfo_t* TCling::MethodInfo_FactoryCopy(MethodInfo_t* minfo) const\n{\n   return (MethodInfo_t*) new TClingMethodInfo(*(TClingMethodInfo*)minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid* TCling::MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->InterfaceMethod(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::MethodInfo_IsValid(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_NArg(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->NArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_NDefaultArg(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->NDefaultArg();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodInfo_Next(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodInfo_Property(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodInfo_ExtraProperty(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->ExtraProperty();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::MethodInfo_Type(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return (TypeInfo_t*)info->Type();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_GetMangledName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   TTHREAD_TLS_DECL(TString, mangled_name);\n   mangled_name = info->GetMangledName();\n   return mangled_name;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_GetPrototype(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->GetPrototype(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_Name(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Name(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_TypeName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstd::string TCling::MethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   if (info && info->IsValid())\n      return info->Type()->NormalizedName(*fNormalizedCtxt);\n   else\n      return \"\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodInfo_Title(MethodInfo_t* minfo) const\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   return info->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nauto TCling::MethodCallReturnType(TFunction *func) const -> EReturnType\n{\n   if (func) {\n      return MethodInfo_MethodCallReturnType(func->fInfo);\n   } else {\n      return EReturnType::kOther;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nauto TCling::MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const -> EReturnType\n{\n   TClingMethodInfo* info = (TClingMethodInfo*) minfo;\n   if (info && info->IsValid()) {\n      TClingTypeInfo *typeinfo = info->Type();\n      clang::QualType QT( typeinfo->GetQualType().getCanonicalType() );\n      if (QT->isEnumeralType()) {\n         return EReturnType::kLong;\n      } else if (QT->isPointerType()) {\n         // Look for char*\n         QT = llvm::cast<clang::PointerType>(QT)->getPointeeType();\n         if ( QT->isCharType() ) {\n            return EReturnType::kString;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else if ( QT->isFloatingType() ) {\n         int sz = typeinfo->Size();\n         if (sz == 4 || sz == 8) {\n            // Support only float and double.\n            return EReturnType::kDouble;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else if ( QT->isIntegerType() ) {\n         int sz = typeinfo->Size();\n         if (sz <= 8) {\n            // Support only up to long long ... but\n            // FIXME the TMethodCall::Execute only\n            // return long (4 bytes) ...\n            // The v5 implementation of TMethodCall::ReturnType\n            // was not making the distinction so we let it go\n            // as is for now, but we really need to upgrade\n            // TMethodCall::Execute ...\n            return EReturnType::kLong;\n         } else {\n            return EReturnType::kOther;\n         }\n      } else {\n         return EReturnType::kOther;\n      }\n   } else {\n      return EReturnType::kOther;\n   }\n}\n\n//______________________________________________________________________________\n//\n//  MethodArgInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const\n{\n   delete(TClingMethodArgInfo*) marginfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodArgInfo_t*) new TClingMethodArgInfo(fInterpreter);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_Factory(MethodInfo_t *minfo) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (MethodArgInfo_t*) new TClingMethodArgInfo(fInterpreter, (TClingMethodInfo*)minfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nMethodArgInfo_t* TCling::MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const\n{\n   return (MethodArgInfo_t*)\n          new TClingMethodArgInfo(*(TClingMethodArgInfo*)marginfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::MethodArgInfo_Next(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::MethodArgInfo_Property(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->DefaultValue();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_Name(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->TypeName();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstd::string TCling::MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* marginfo) const\n{\n   TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;\n   return info->Type()->NormalizedName(*fNormalizedCtxt);\n}\n\n//______________________________________________________________________________\n//\n//  TypeInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypeInfo_Delete(TypeInfo_t* tinfo) const\n{\n   delete (TClingTypeInfo*) tinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypeInfo_t*) new TClingTypeInfo(fInterpreter);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_Factory(const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypeInfo_t*) new TClingTypeInfo(fInterpreter, name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypeInfo_t* TCling::TypeInfo_FactoryCopy(TypeInfo_t* tinfo) const\n{\n   return (TypeInfo_t*) new TClingTypeInfo(*(TClingTypeInfo*)tinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypeInfo_Init(TypeInfo_t* tinfo, const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::TypeInfo_IsValid(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypeInfo_Name(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::TypeInfo_Property(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypeInfo_RefType(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->RefType();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypeInfo_Size(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypeInfo_TrueName(TypeInfo_t* tinfo) const\n{\n   TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;\n   return TClinginfo->TrueName(*fNormalizedCtxt);\n}\n\n\n//______________________________________________________________________________\n//\n//  TypedefInfo interface\n//\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypedefInfo_Delete(TypedefInfo_t* tinfo) const\n{\n   delete(TClingTypedefInfo*) tinfo;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_Factory() const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypedefInfo_t*) new TClingTypedefInfo(fInterpreter);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_Factory(const char *name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   return (TypedefInfo_t*) new TClingTypedefInfo(fInterpreter, name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nTypedefInfo_t* TCling::TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) const\n{\n   return (TypedefInfo_t*) new TClingTypedefInfo(*(TClingTypedefInfo*)tinfo);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::TypedefInfo_Init(TypedefInfo_t* tinfo,\n                              const char* name) const\n{\n   R__LOCKGUARD(gInterpreterMutex);\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   TClinginfo->Init(name);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nbool TCling::TypedefInfo_IsValid(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->IsValid();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nInt_t TCling::TypedefInfo_Next(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Next();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nLong_t TCling::TypedefInfo_Property(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Property();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nint TCling::TypedefInfo_Size(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Size();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_TrueName(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->TrueName(*fNormalizedCtxt);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_Name(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Name();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst char* TCling::TypedefInfo_Title(TypedefInfo_t* tinfo) const\n{\n   TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;\n   return TClinginfo->Title();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::SnapshotMutexState(ROOT::TVirtualRWMutex* mtx)\n{\n   if (!fInitialMutex.back()) {\n      if (fInitialMutex.back().fRecurseCount) {\n         Error(\"SnapshotMutexState\", \"fRecurseCount != 0 even though initial mutex state is unset!\");\n      }\n      fInitialMutex.back().fState = mtx->GetStateBefore();\n   }\n   // We will \"forget\" this lock once we backed out of all interpreter frames.\n   // Here we are entering one, so ++.\n   ++fInitialMutex.back().fRecurseCount;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid TCling::ForgetMutexState()\n{\n   if (!fInitialMutex.back())\n      return;\n   if (fInitialMutex.back().fRecurseCount == 0) {\n      Error(\"ForgetMutexState\", \"mutex state's recurse count already 0!\");\n   }\n   else if (--fInitialMutex.back().fRecurseCount == 0) {\n      // We have returned from all interpreter frames. Reset the initial lock state.\n      fInitialMutex.back().fState.reset();\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.\n\nvoid TCling::ApplyToInterpreterMutex(void *delta)\n{\n   R__ASSERT(!fInitialMutex.empty() && \"Inconsistent state of fInitialMutex!\");\n   if (gInterpreterMutex) {\n      if (delta) {\n         auto typedDelta = static_cast<TVirtualRWMutex::StateDelta *>(delta);\n         std::unique_ptr<TVirtualRWMutex::StateDelta> uniqueP{typedDelta};\n         gCoreMutex->Apply(std::move(uniqueP));\n      }\n   }\n   fInitialMutex.pop_back();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Reset the interpreter lock to the state it had before interpreter-related\n/// calls happened.\n\nvoid *TCling::RewindInterpreterMutex()\n{\n   if (fInitialMutex.back()) {\n      std::unique_ptr<TVirtualRWMutex::StateDelta> uniqueP = gCoreMutex->Rewind(*fInitialMutex.back().fState);\n      // Need to start a new recurse count.\n      fInitialMutex.emplace_back();\n      return uniqueP.release();\n   }\n   // Need to start a new recurse count.\n   fInitialMutex.emplace_back();\n   return nullptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/metacling/src/TClingCallbacks.cxx": "// @(#)root/core/meta:$Id$\n// Author: Vassil Vassilev   7/10/2012\n\n/*************************************************************************\n * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers.               *\n * All rights reserved.                                                  *\n *                                                                       *\n * For the licensing terms see $ROOTSYS/LICENSE.                         *\n * For the list of contributors see $ROOTSYS/README/CREDITS.             *\n *************************************************************************/\n\n#include \"TClingCallbacks.h\"\n\n#include \"cling/Interpreter/DynamicLibraryManager.h\"\n#include \"cling/Interpreter/Interpreter.h\"\n#include \"cling/Interpreter/InterpreterCallbacks.h\"\n#include \"cling/Interpreter/Transaction.h\"\n#include \"cling/Utils/AST.h\"\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Parse/Parser.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Scope.h\"\n\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n\n#include \"TClingUtils.h\"\n#include \"ClingRAII.h\"\n\nusing namespace clang;\nusing namespace cling;\nusing namespace ROOT::Internal;\n\nclass TObject;\n\n// Functions used to forward calls from code compiled with no-rtti to code\n// compiled with rtti.\nextern \"C\" {\n   void TCling__UpdateListsOnCommitted(const cling::Transaction&, Interpreter*);\n   void TCling__UpdateListsOnUnloaded(const cling::Transaction&);\n   void TCling__TransactionRollback(const cling::Transaction&);\n   void TCling__GetNormalizedContext(const ROOT::TMetaUtils::TNormalizedCtxt*&);\n   TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);\n   Decl* TCling__GetObjectDecl(TObject *obj);\n   int TCling__AutoLoadCallback(const char* className);\n   int TCling__AutoParseCallback(const char* className);\n   const char* TCling__GetClassSharedLibs(const char* className);\n//    int TCling__IsAutoLoadNamespaceCandidate(const char* name);\n   int TCling__IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* name);\n   int TCling__CompileMacro(const char *fileName, const char *options);\n   void TCling__SplitAclicMode(const char* fileName, std::string &mode,\n                  std::string &args, std::string &io, std::string &fname);\n   bool TCling__LibraryLoadingFailed(const std::string&, const std::string&, bool, bool);\n   void TCling__LibraryLoadedRTTI(const void* dyLibHandle,\n                                  llvm::StringRef canonicalName);\n   void TCling__LibraryUnloadedRTTI(const void* dyLibHandle,\n                                    llvm::StringRef canonicalName);\n   void TCling__PrintStackTrace();\n   void *TCling__ResetInterpreterMutex();\n   void TCling__RestoreInterpreterMutex(void *state);\n   void *TCling__LockCompilationDuringUserCodeExecution();\n   void TCling__UnlockCompilationDuringUserCodeExecution(void *state);\n   void TCling__FindLoadedLibraries(std::vector<std::pair<uint32_t, std::string>> &sLibraries,\n                                    std::vector<StringRef> &sPaths,\n                                    cling::Interpreter &interpreter);\n}\n\nTClingCallbacks::TClingCallbacks(cling::Interpreter* interp)\n   : InterpreterCallbacks(interp),\n     fLastLookupCtx(0), fROOTSpecialNamespace(0),\n     fFirstRun(true), fIsAutoloading(false), fIsAutoloadingRecursively(false),\n     fIsAutoParsingSuspended(false), fPPOldFlag(false), fPPChanged(false) {\n   Transaction* T = 0;\n   m_Interpreter->declare(\"namespace __ROOT_SpecialObjects{}\", &T);\n   fROOTSpecialNamespace = dyn_cast<NamespaceDecl>(T->getFirstDecl().getSingleDecl());\n}\n\n//pin the vtable here\nTClingCallbacks::~TClingCallbacks() {}\n\nvoid TClingCallbacks::InclusionDirective(clang::SourceLocation sLoc/*HashLoc*/,\n                                         const clang::Token &/*IncludeTok*/,\n                                         llvm::StringRef FileName,\n                                         bool /*IsAngled*/,\n                                         clang::CharSourceRange /*FilenameRange*/,\n                                         const clang::FileEntry *FE,\n                                         llvm::StringRef /*SearchPath*/,\n                                         llvm::StringRef /*RelativePath*/,\n                                         const clang::Module * Imported) {\n   // We found a module. Do not try to do anything else.\n   if (Imported) {\n      Sema &SemaR = m_Interpreter->getSema();\n      // FIXME: We should make the module visible at that point.\n      if (!SemaR.isModuleVisible(Imported))\n         ROOT::TMetaUtils::Info(\"TClingCallbacks::InclusionDirective\",\n                                \"Module %s resolved but not visible!\", Imported->Name.c_str());\n      else\n        return;\n   }\n\n   // Method called via Callbacks->InclusionDirective()\n   // in Preprocessor::HandleIncludeDirective(), invoked whenever an\n   // inclusion directive has been processed, and allowing us to try\n   // to autoload libraries using their header file name.\n   // Two strategies are tried:\n   // 1) The header name is looked for in the list of autoload keys\n   // 2) Heurists are applied to the header name to distill a classname.\n   //    For example try to autoload TGClient (libGui) when seeing #include \"TGClient.h\"\n   //    or TH1F in presence of TH1F.h.\n   // Strategy 2) is tried only if 1) fails.\n\n   bool isHeaderFile = FileName.endswith(\".h\") || FileName.endswith(\".hxx\") || FileName.endswith(\".hpp\");\n   if (!IsAutoloadingEnabled() || fIsAutoloadingRecursively || !isHeaderFile)\n      return;\n\n   std::string localString(FileName.str());\n\n   Sema &SemaR = m_Interpreter->getSema();\n   DeclarationName Name = &SemaR.getASTContext().Idents.get(localString.c_str());\n   LookupResult RHeader(SemaR, Name, sLoc, Sema::LookupOrdinaryName);\n\n   tryAutoParseInternal(localString, RHeader, SemaR.getCurScope(), FE);\n}\n\n// TCling__LibraryLoadingFailed is a function in TCling which handles errmessage\nbool TClingCallbacks::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem,\n    bool permanent, bool resolved) {\n  return TCling__LibraryLoadingFailed(errmessage, libStem, permanent, resolved);\n}\n\n// Preprocessor callbacks used to handle special cases like for example:\n// #include \"myMacro.C+\"\n//\nbool TClingCallbacks::FileNotFound(llvm::StringRef FileName,\n                                   llvm::SmallVectorImpl<char> &RecoveryPath) {\n   // Method called via Callbacks->FileNotFound(Filename, RecoveryPath)\n   // in Preprocessor::HandleIncludeDirective(), initially allowing to\n   // change the include path, and allowing us to compile code via ACLiC\n   // when specifying #include \"myfile.C+\", and suppressing the preprocessor\n   // error message:\n   // input_line_23:1:10: fatal error: 'myfile.C+' file not found\n\n   Preprocessor& PP = m_Interpreter->getCI()->getPreprocessor();\n\n   // remove any trailing \"\\n\n   std::string filename(FileName.str().substr(0,FileName.str().find_last_of('\"')));\n   std::string fname, mode, arguments, io;\n   // extract the filename and ACliC mode\n   TCling__SplitAclicMode(filename.c_str(), mode, arguments, io, fname);\n   if (mode.length() > 0) {\n      if (llvm::sys::fs::exists(fname)) {\n         // format the CompileMacro() option string\n         std::string options = \"k\";\n         if (mode.find(\"++\") != std::string::npos) options += \"f\";\n         if (mode.find(\"g\")  != std::string::npos) options += \"g\";\n         if (mode.find(\"O\")  != std::string::npos) options += \"O\";\n\n         // Save state of the preprocessor\n         Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);\n         Parser& P = const_cast<Parser&>(m_Interpreter->getParser());\n         // After we have saved the token reset the current one to\n         // something which is safe (semi colon usually means empty decl)\n         Token& Tok = const_cast<Token&>(P.getCurToken());\n         // We parsed 'include' token. We don't need to restore it, because\n         // we provide our own way of handling the entire #include \"file.c+\"\n         // Thus if we reverted the token back to the parser, we are in\n         // a trouble.\n         Tok.setKind(tok::semi);\n         // We can't PushDeclContext, because we go up and the routine that pops\n         // the DeclContext assumes that we drill down always.\n         // We have to be on the global context. At that point we are in a\n         // wrapper function so the parent context must be the global.\n         // This is needed to solve potential issues when using #include \"myFile.C+\"\n         // after a scope declaration like:\n         // void Check(TObject* obj) {\n         //   if (obj) cout << \"Found the referenced object\\n\";\n         //   else cout << \"Error: Could not find the referenced object\\n\";\n         // }\n         // #include \"A.C+\"\n         Sema& SemaR = m_Interpreter->getSema();\n         ASTContext& C = SemaR.getASTContext();\n         Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),\n                                                SemaR.TUScope);\n         int retcode = TCling__CompileMacro(fname.c_str(), options.c_str());\n         if (retcode) {\n            // compilation was successful, let's remember the original\n            // preprocessor \"include not found\" error suppression flag\n            if (!fPPChanged)\n               fPPOldFlag = PP.GetSuppressIncludeNotFoundError();\n            PP.SetSuppressIncludeNotFoundError(true);\n            fPPChanged = true;\n         }\n         return false;\n      }\n   }\n   if (fPPChanged) {\n      // restore the original preprocessor \"include not found\" error\n      // suppression flag\n      PP.SetSuppressIncludeNotFoundError(fPPOldFlag);\n      fPPChanged = false;\n   }\n   return false;\n}\n\n\nstatic bool topmostDCIsFunction(Scope* S) {\n   if (!S)\n      return false;\n\n   DeclContext* DC = S->getEntity();\n   // For DeclContext-less scopes like if (dyn_expr) {}\n   // Find the DC enclosing S.\n   while (!DC) {\n      S = S->getParent();\n      DC = S->getEntity();\n   }\n\n   // DynamicLookup only happens inside topmost functions:\n   clang::DeclContext* MaybeTU = DC;\n   while (MaybeTU && !isa<TranslationUnitDecl>(MaybeTU)) {\n      DC = MaybeTU;\n      MaybeTU = MaybeTU->getParent();\n   }\n   return isa<FunctionDecl>(DC);\n}\n\n// On a failed lookup we have to try to more things before issuing an error.\n// The symbol might need to be loaded by ROOT's autoloading mechanism or\n// it might be a ROOT special object.\n//\n// Try those first and if still failing issue the diagnostics.\n//\n// returns true when a declaration is found and no error should be emitted.\n//\nbool TClingCallbacks::LookupObject(LookupResult &R, Scope *S) {\n   // Don't do any extra work if an error that is not still recovered occurred.\n   if (m_Interpreter->getSema().getDiagnostics().hasErrorOccurred())\n      return false;\n\n   if (tryAutoParseInternal(R.getLookupName().getAsString(), R, S))\n      return true; // happiness.\n\n   // The remaining lookup routines only work on global scope functions\n   // (\"macros\"), not in classes, namespaces etc - anything that looks like\n   // it has seen any trace of software development.\n   if (!topmostDCIsFunction(S))\n      return false;\n\n   // If the autoload wasn't successful try ROOT specials.\n   if (tryFindROOTSpecialInternal(R, S))\n      return true;\n\n   // For backward-compatibility with CINT we must support stmts like:\n   // x = 4; y = new MyClass();\n   // I.e we should \"inject\" a C++11 auto keyword in front of \"x\" and \"y\"\n   // This has to have higher precedence than the dynamic scopes. It is claimed\n   // that if one assigns to a name and the lookup of that name fails if *must*\n   // auto keyword must be injected and the stmt evaluation must not be delayed\n   // until runtime.\n   // For now supported only at the prompt.\n   if (tryInjectImplicitAutoKeyword(R, S)) {\n      return true;\n   }\n\n   if (fIsAutoloadingRecursively)\n      return false;\n\n   // Finally try to resolve this name as a dynamic name, i.e delay its\n   // resolution for runtime.\n   return tryResolveAtRuntimeInternal(R, S);\n}\n\nbool TClingCallbacks::LookupObject(const DeclContext* DC, DeclarationName Name) {\n   if (!IsAutoloadingEnabled() || fIsAutoloadingRecursively) return false;\n\n   if (Name.getNameKind() != DeclarationName::Identifier) return false;\n\n\n\n   // Get the 'lookup' decl context.\n   // We need to cast away the constness because we will lookup items of this\n   // namespace/DeclContext\n   NamespaceDecl* NSD = dyn_cast<NamespaceDecl>(const_cast<DeclContext*>(DC));\n   if (!NSD)\n      return false;\n\n   if ( !TCling__IsAutoLoadNamespaceCandidate(NSD) )\n      return false;\n\n   const DeclContext* primaryDC = NSD->getPrimaryContext();\n   if (primaryDC != DC)\n      return false;\n\n   Sema &SemaR = m_Interpreter->getSema();\n   LookupResult R(SemaR, Name, SourceLocation(), Sema::LookupOrdinaryName);\n   R.suppressDiagnostics();\n   // We need the qualified name for TCling to find the right library.\n   std::string qualName\n      = NSD->getQualifiedNameAsString() + \"::\" + Name.getAsString();\n\n\n   // We want to avoid qualified lookups, because they are expensive and\n   // difficult to construct. This is why we *artificially* push a scope and\n   // a decl context, where Sema should do the lookup.\n   clang::Scope S(SemaR.TUScope, clang::Scope::DeclScope, SemaR.getDiagnostics());\n   S.setEntity(const_cast<DeclContext*>(DC));\n   Sema::ContextAndScopeRAII pushedDCAndS(SemaR, const_cast<DeclContext*>(DC), &S);\n\n   if (tryAutoParseInternal(qualName, R, SemaR.getCurScope())) {\n      llvm::SmallVector<NamedDecl*, 4> lookupResults;\n      for(LookupResult::iterator I = R.begin(), E = R.end(); I < E; ++I)\n         lookupResults.push_back(*I);\n      UpdateWithNewDecls(DC, Name, llvm::makeArrayRef(lookupResults.data(),\n                                                      lookupResults.size()));\n      return true;\n   }\n   return false;\n}\n\nbool TClingCallbacks::LookupObject(clang::TagDecl* Tag) {\n   // Clang needs Tag's complete definition. Can we parse it?\n   if (fIsAutoloadingRecursively || fIsAutoParsingSuspended) return false;\n\n   Sema &SemaR = m_Interpreter->getSema();\n\n   SourceLocation Loc = Tag->getLocation();\n   if (SemaR.getSourceManager().isInSystemHeader(Loc)) {\n      // We will not help the system headers, sorry.\n      return false;\n   }\n\n   for (auto ReRD: Tag->redecls()) {\n      // Don't autoparse a TagDecl while we are parsing its definition!\n      if (ReRD->isBeingDefined())\n         return false;\n   }\n\n\n   if (RecordDecl* RD = dyn_cast<RecordDecl>(Tag)) {\n      ASTContext& C = SemaR.getASTContext();\n      Parser& P = const_cast<Parser&>(m_Interpreter->getParser());\n\n      ParsingStateRAII raii(P,SemaR);\n\n      // Use the Normalized name for the autoload\n      std::string Name;\n      const ROOT::TMetaUtils::TNormalizedCtxt* tNormCtxt = NULL;\n      TCling__GetNormalizedContext(tNormCtxt);\n      ROOT::TMetaUtils::GetNormalizedName(Name,\n                                          C.getTypeDeclType(RD),\n                                          *m_Interpreter,\n                                          *tNormCtxt);\n      // Autoparse implies autoload\n      if (TCling__AutoParseCallback(Name.c_str())) {\n         // We have read it; remember that.\n         Tag->setHasExternalLexicalStorage(false);\n         return true;\n      }\n   }\n   return false;\n}\n\n\n// The symbol might be defined in the ROOT class autoloading map so we have to\n// try to autoload it first and do secondary lookup to try to find it.\n//\n// returns true when a declaration is found and no error should be emitted.\n// If FileEntry, this is a reacting on a #include and Name is the included\n// filename.\n//\nbool TClingCallbacks::tryAutoParseInternal(llvm::StringRef Name, LookupResult &R,\n                                           Scope *S, const FileEntry* FE /*=0*/) {\n   Sema &SemaR = m_Interpreter->getSema();\n\n   // Try to autoload first if autoloading is enabled\n   if (IsAutoloadingEnabled()) {\n     // Avoid tail chasing.\n     if (fIsAutoloadingRecursively)\n       return false;\n\n     // We should try autoload only for special lookup failures.\n     Sema::LookupNameKind kind = R.getLookupKind();\n     if (!(kind == Sema::LookupTagName || kind == Sema::LookupOrdinaryName\n           || kind == Sema::LookupNestedNameSpecifierName\n           || kind == Sema::LookupNamespaceName))\n        return false;\n\n     fIsAutoloadingRecursively = true;\n\n     bool lookupSuccess = false;\n     // Save state of the PP\n     Parser &P = const_cast<Parser &>(m_Interpreter->getParser());\n\n     ParsingStateRAII raii(P, SemaR);\n\n     // First see whether we have a fwd decl of this name.\n     // We shall only do that if lookup makes sense for it (!FE).\n     if (!FE) {\n        lookupSuccess = SemaR.LookupName(R, S);\n        if (lookupSuccess) {\n           if (R.isSingleResult()) {\n              if (isa<clang::RecordDecl>(R.getFoundDecl())) {\n                 // Good enough; RequireCompleteType() will tell us if we\n                 // need to auto parse.\n                 // But we might need to auto-load.\n                 TCling__AutoLoadCallback(Name.data());\n                 fIsAutoloadingRecursively = false;\n                 return true;\n              }\n           }\n        }\n     }\n\n     if (TCling__AutoParseCallback(Name.str().c_str())) {\n        // Shouldn't we pop more?\n        raii.fPushedDCAndS.pop();\n        raii.fCleanupRAII.pop();\n        lookupSuccess = FE || SemaR.LookupName(R, S);\n     } else if (FE && TCling__GetClassSharedLibs(Name.str().c_str())) {\n        // We are \"autoparsing\" a header, and the header was not parsed.\n        // But its library is known - so we do know about that header.\n        // Do the parsing explicitly here, while recursive autoloading is\n        // disabled.\n        std::string incl = \"#include \\\"\";\n        incl += FE->getName();\n        incl += '\"';\n        m_Interpreter->declare(incl);\n     }\n\n     fIsAutoloadingRecursively = false;\n\n     if (lookupSuccess)\n       return true;\n   }\n\n   return false;\n}\n\n// If cling cannot find a name it should ask ROOT before it issues an error.\n// If ROOT knows the name then it has to create a new variable with that name\n// and type in dedicated for that namespace (eg. __ROOT_SpecialObjects).\n// For example if the interpreter is looking for h in h-Draw(), this routine\n// will create\n// namespace __ROOT_SpecialObjects {\n//   THist* h = (THist*) the_address;\n// }\n//\n// Later if h is called again it again won't be found by the standart lookup\n// because it is in our hidden namespace (nobody should do using namespace\n// __ROOT_SpecialObjects). It caches the variable declarations and their\n// last address. If the newly found decl with the same name (h) has different\n// address than the cached one it goes directly at the address and updates it.\n//\n// returns true when declaration is found and no error should be emitted.\n//\nbool TClingCallbacks::tryFindROOTSpecialInternal(LookupResult &R, Scope *S) {\n   // User must be able to redefine the names that come from a file.\n   if (R.isForRedeclaration())\n      return false;\n   // If there is a result abort.\n   if (!R.empty())\n      return false;\n   const Sema::LookupNameKind LookupKind = R.getLookupKind();\n   if (LookupKind != Sema::LookupOrdinaryName)\n      return false;\n\n\n   Sema &SemaR = m_Interpreter->getSema();\n   ASTContext& C = SemaR.getASTContext();\n   Preprocessor &PP = SemaR.getPreprocessor();\n   DeclContext *CurDC = SemaR.CurContext;\n   DeclarationName Name = R.getLookupName();\n\n   // Make sure that the failed lookup comes from a function body.\n   if(!CurDC || !CurDC->isFunctionOrMethod())\n      return false;\n\n   // Save state of the PP, because TCling__GetObjectAddress may induce nested\n   // lookup.\n   Preprocessor::CleanupAndRestoreCacheRAII cleanupPPRAII(PP);\n   TObject *obj = TCling__GetObjectAddress(Name.getAsString().c_str(),\n                                           fLastLookupCtx);\n   cleanupPPRAII.pop(); // force restoring the cache\n\n   if (obj) {\n\n#if defined(R__MUST_REVISIT)\n#if R__MUST_REVISIT(6,2)\n      // Register the address in TCling::fgSetOfSpecials\n      // to speed-up the execution of TCling::RecursiveRemove when\n      // the object is not a special.\n      // See http://root.cern.ch/viewvc/trunk/core/meta/src/TCint.cxx?view=log#rev18109\n      if (!fgSetOfSpecials) {\n         fgSetOfSpecials = new std::set<TObject*>;\n      }\n      ((std::set<TObject*>*)fgSetOfSpecials)->insert((TObject*)*obj);\n#endif\n#endif\n\n     VarDecl *VD = cast_or_null<VarDecl>(utils::Lookup::Named(&SemaR, Name,\n                                                        fROOTSpecialNamespace));\n      if (VD) {\n         //TODO: Check for same types.\n         GlobalDecl GD(VD);\n         TObject **address = (TObject**)m_Interpreter->getAddressOfGlobal(GD);\n         // Since code was generated already we cannot rely on the initializer\n         // of the decl in the AST, however we will update that init so that it\n         // will be easier while debugging.\n         CStyleCastExpr *CStyleCast = cast<CStyleCastExpr>(VD->getInit());\n         Expr* newInit = utils::Synthesize::IntegerLiteralExpr(C, (uint64_t)obj);\n         CStyleCast->setSubExpr(newInit);\n\n         // The actual update happens here, directly in memory.\n         *address = obj;\n      }\n      else {\n         // Save state of the PP\n         Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);\n\n         const Decl *TD = TCling__GetObjectDecl(obj);\n         // We will declare the variable as pointer.\n         QualType QT = C.getPointerType(C.getTypeDeclType(cast<TypeDecl>(TD)));\n\n         VD = VarDecl::Create(C, fROOTSpecialNamespace, SourceLocation(),\n                              SourceLocation(), Name.getAsIdentifierInfo(), QT,\n                              /*TypeSourceInfo*/0, SC_None);\n         // Build an initializer\n         Expr* Init\n           = utils::Synthesize::CStyleCastPtrExpr(&SemaR, QT, (uint64_t)obj);\n         // Register the decl in our hidden special namespace\n         VD->setInit(Init);\n         fROOTSpecialNamespace->addDecl(VD);\n\n         cling::CompilationOptions CO;\n         CO.DeclarationExtraction = 0;\n         CO.ValuePrinting = CompilationOptions::VPDisabled;\n         CO.ResultEvaluation = 0;\n         CO.DynamicScoping = 0;\n         CO.Debug = 0;\n         CO.CodeGeneration = 1;\n\n         cling::Transaction* T = new cling::Transaction(CO, SemaR);\n         T->append(VD);\n         T->setState(cling::Transaction::kCompleted);\n\n         m_Interpreter->emitAllDecls(T);\n      }\n      assert(VD && \"Cannot be null!\");\n      R.addDecl(VD);\n      return true;\n   }\n\n   return false;\n}\n\nbool TClingCallbacks::tryResolveAtRuntimeInternal(LookupResult &R, Scope *S) {\n   if (!shouldResolveAtRuntime(R, S))\n      return false;\n\n   DeclarationName Name = R.getLookupName();\n   IdentifierInfo* II = Name.getAsIdentifierInfo();\n   SourceLocation Loc = R.getNameLoc();\n   Sema& SemaRef = R.getSema();\n   ASTContext& C = SemaRef.getASTContext();\n   DeclContext* TU = C.getTranslationUnitDecl();\n   assert(TU && \"Must not be null.\");\n\n   // DynamicLookup only happens inside wrapper functions:\n   clang::FunctionDecl* Wrapper = nullptr;\n   Scope* Cursor = S;\n   do {\n      DeclContext* DCCursor = Cursor->getEntity();\n      if (DCCursor == TU)\n         return false;\n      Wrapper = dyn_cast_or_null<FunctionDecl>(DCCursor);\n      if (Wrapper) {\n         if (utils::Analyze::IsWrapper(Wrapper)) {\n            break;\n         } else {\n            // Can't have a function inside the wrapper:\n            return false;\n         }\n      }\n   } while ((Cursor = Cursor->getParent()));\n\n   if (!Wrapper) {\n      // The parent of S wasn't the TU?!\n      return false;\n   }\n\n   VarDecl* Result = VarDecl::Create(C, TU, Loc, Loc, II, C.DependentTy,\n                                     /*TypeSourceInfo*/0, SC_None);\n\n   if (!Result) {\n      // We cannot handle the situation. Give up\n      return false;\n   }\n\n   // Annotate the decl to give a hint in cling. FIXME: Current implementation\n   // is a gross hack, because TClingCallbacks shouldn't know about\n   // EvaluateTSynthesizer at all!\n\n   SourceRange invalidRange;\n   Wrapper->addAttr(new (C) AnnotateAttr(invalidRange, C, \"__ResolveAtRuntime\", 0));\n\n   // Here we have the scope but we cannot do Sema::PushDeclContext, because\n   // on pop it will try to go one level up, which we don't want.\n   Sema::ContextRAII pushedDC(SemaRef, TU);\n   R.addDecl(Result);\n   //SemaRef.PushOnScopeChains(Result, SemaRef.TUScope, /*Add to ctx*/true);\n   // Say that we can handle the situation. Clang should try to recover\n   return true;\n}\n\nbool TClingCallbacks::shouldResolveAtRuntime(LookupResult& R, Scope* S) {\n   if (m_IsRuntime)\n     return false;\n\n   if (R.getLookupKind() != Sema::LookupOrdinaryName)\n      return false;\n\n   if (R.isForRedeclaration())\n      return false;\n\n   if (!R.empty())\n      return false;\n\n   const Transaction* T = getInterpreter()->getCurrentTransaction();\n   if (!T)\n      return false;\n   const cling::CompilationOptions& COpts = T->getCompilationOpts();\n   if (!COpts.DynamicScoping)\n      return false;\n\n   // FIXME: Figure out better way to handle:\n   // C++ [basic.lookup.classref]p1:\n   //   In a class member access expression (5.2.5), if the . or -> token is\n   //   immediately followed by an identifier followed by a <, the\n   //   identifier must be looked up to determine whether the < is the\n   //   beginning of a template argument list (14.2) or a less-than operator.\n   //   The identifier is first looked up in the class of the object\n   //   expression. If the identifier is not found, it is then looked up in\n   //   the context of the entire postfix-expression and shall name a class\n   //   or function template.\n   //\n   // We want to ignore object(.|->)member<template>\n   //if (R.getSema().PP.LookAhead(0).getKind() == tok::less)\n      // TODO: check for . or -> in the cached token stream\n   //   return false;\n\n   for (Scope* DepScope = S; DepScope; DepScope = DepScope->getParent()) {\n      if (DeclContext* Ctx = static_cast<DeclContext*>(DepScope->getEntity())) {\n         if (!Ctx->isDependentContext())\n            // For now we support only the prompt.\n            if (isa<FunctionDecl>(Ctx))\n               return true;\n      }\n   }\n\n   return false;\n}\n\nbool TClingCallbacks::tryInjectImplicitAutoKeyword(LookupResult &R, Scope *S) {\n   // Should be disabled with the dynamic scopes.\n   if (m_IsRuntime)\n      return false;\n\n   if (R.isForRedeclaration())\n      return false;\n\n   if (R.getLookupKind() != Sema::LookupOrdinaryName)\n      return false;\n\n   if (!isa<FunctionDecl>(R.getSema().CurContext))\n      return false;\n\n   {\n      // ROOT-8538: only top-most (function-level) scope is supported.\n      DeclContext* ScopeDC = S->getEntity();\n      if (!ScopeDC || !llvm::isa<FunctionDecl>(ScopeDC))\n         return false;\n\n      // Make sure that the failed lookup comes the prompt. Currently, we\n      // support only the prompt.\n      Scope* FnScope = S->getFnParent();\n      if (!FnScope)\n         return false;\n      auto FD = dyn_cast_or_null<FunctionDecl>(FnScope->getEntity());\n      if (!FD || !utils::Analyze::IsWrapper(FD))\n         return false;\n   }\n\n   Sema& SemaRef = R.getSema();\n   ASTContext& C = SemaRef.getASTContext();\n   DeclContext* DC = SemaRef.CurContext;\n   assert(DC && \"Must not be null.\");\n\n\n   Preprocessor& PP = R.getSema().getPreprocessor();\n   //Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);\n   //PP.EnableBacktrackAtThisPos();\n   if (PP.LookAhead(0).isNot(tok::equal)) {\n      //PP.Backtrack();\n      return false;\n   }\n   //PP.CommitBacktrackedTokens();\n   //cleanupRAII.pop();\n   DeclarationName Name = R.getLookupName();\n   IdentifierInfo* II = Name.getAsIdentifierInfo();\n   SourceLocation Loc = R.getNameLoc();\n   VarDecl* Result = VarDecl::Create(C, DC, Loc, Loc, II,\n                                     C.getAutoType(QualType(),\n                                                   clang::AutoTypeKeyword::Auto,\n                                                   /*IsDependent*/false),\n                                     /*TypeSourceInfo*/0, SC_None);\n\n   if (!Result) {\n      ROOT::TMetaUtils::Error(\"TClingCallbacks::tryInjectImplicitAutoKeyword\",\n                              \"Cannot create VarDecl\");\n      return false;\n   }\n\n   // Annotate the decl to give a hint in cling.\n   // FIXME: We should move this in cling, when we implement turning it on\n   // and off.\n   SourceRange invalidRange;\n   Result->addAttr(new (C) AnnotateAttr(invalidRange, C, \"__Auto\", 0));\n\n   R.addDecl(Result);\n   // Say that we can handle the situation. Clang should try to recover\n   return true;\n}\n\nvoid TClingCallbacks::Initialize() {\n   // Replay existing decls from the AST.\n   if (fFirstRun) {\n      // Before setting up the callbacks register what cling have seen during init.\n      Sema& SemaR = m_Interpreter->getSema();\n      cling::Transaction TPrev((cling::CompilationOptions(), SemaR));\n      TPrev.append(SemaR.getASTContext().getTranslationUnitDecl());\n      TCling__UpdateListsOnCommitted(TPrev, m_Interpreter);\n\n      fFirstRun = false;\n   }\n}\n\n// The callback is used to update the list of globals in ROOT.\n//\nvoid TClingCallbacks::TransactionCommitted(const Transaction &T) {\n   if (fFirstRun && T.empty())\n      Initialize();\n\n   TCling__UpdateListsOnCommitted(T, m_Interpreter);\n}\n\n// The callback is used to update the list of globals in ROOT.\n//\nvoid TClingCallbacks::TransactionUnloaded(const Transaction &T) {\n   if (T.empty())\n      return;\n\n   TCling__UpdateListsOnUnloaded(T);\n}\n\n// The callback is used to clear the autoparsing caches.\n//\nvoid TClingCallbacks::TransactionRollback(const Transaction &T) {\n   if (T.empty())\n      return;\n\n   TCling__TransactionRollback(T);\n}\n\nvoid TClingCallbacks::DeclDeserialized(const clang::Decl* D) {\n   if (const RecordDecl* RD = dyn_cast<RecordDecl>(D)) {\n      // FIXME: Our autoloading doesn't work (load the library) when the looked\n      // up decl is found in the PCH/PCM. We have to do that extra step, which\n      // loads the corresponding library when a decl was deserialized.\n      //\n      // Unfortunately we cannot do that with the current implementation,\n      // because the library load will pull in the header files of the library\n      // as well, even though they are in the PCH/PCM and available.\n      (void)RD;//TCling__AutoLoadCallback(RD->getNameAsString().c_str());\n   }\n}\n\nvoid TClingCallbacks::LibraryLoaded(const void* dyLibHandle,\n                                    llvm::StringRef canonicalName) {\n   TCling__LibraryLoadedRTTI(dyLibHandle, canonicalName);\n}\n\nvoid TClingCallbacks::LibraryUnloaded(const void* dyLibHandle,\n                                      llvm::StringRef canonicalName) {\n   TCling__LibraryUnloadedRTTI(dyLibHandle, canonicalName);\n}\n\nvoid TClingCallbacks::PrintStackTrace() {\n   TCling__PrintStackTrace();\n}\n\nvoid *TClingCallbacks::EnteringUserCode()\n{\n   // We can safely assume that if the lock exist already when we are in Cling code,\n   // then the lock has (or should been taken) already. Any action (that caused callers\n   // to take the lock) is halted during ProcessLine. So it is fair to unlock it.\n   return TCling__ResetInterpreterMutex();\n}\n\nvoid TClingCallbacks::ReturnedFromUserCode(void *stateInfo)\n{\n   TCling__RestoreInterpreterMutex(stateInfo);\n}\n\nvoid *TClingCallbacks::LockCompilationDuringUserCodeExecution()\n{\n   return TCling__LockCompilationDuringUserCodeExecution();\n}\n\nvoid TClingCallbacks::UnlockCompilationDuringUserCodeExecution(void *StateInfo)\n{\n   TCling__UnlockCompilationDuringUserCodeExecution(StateInfo);\n}\n\n// Extracted here to circumvent ODR clash between\n// std::Sp_counted_ptr_inplace<llvm::sys::fs::detail::DirIterState, std::allocator<llvm::sys::fs::detail::DirIterState>, (_gnu_cxx::_Lock_policy)2>::_M_get_deleter(std::type_info const&)\n// coming from a no-rtti and a rtti build in libstdc++ from GCC >= 8.1.\n// In its function body, rtti uses `arg0 == typeid(...)` protected by #ifdef __cpp_rtti. Depending\n// on which symbol (with or without rtti) the linker picks up, the argument `arg0` is a valid\n// type_info - or not, in which case this comparison crashes.\n// Circumvent this by removing the rtti-use of this function:\nvoid TCling__FindLoadedLibraries(std::vector<std::pair<uint32_t, std::string>> &sLibraries,\n                                 std::vector<StringRef> &sPaths,\n                                 cling::Interpreter &interpreter)\n{\n   // Store the information of path so that we don't have to iterate over the same path again and again.\n   std::unordered_set<std::string> alreadyLookedPath;\n   const clang::Preprocessor &PP = interpreter.getCI()->getPreprocessor();\n   const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();\n   const std::vector<std::string>& ModulePaths(HSOpts.PrebuiltModulePaths);\n   cling::DynamicLibraryManager* dyLibManager = interpreter.getDynamicLibraryManager();\n\n   // Take path here eg. \"/home/foo/module-release/lib/\"\n   for (const std::string& Path : ModulePaths) {\n      // Already searched?\n      auto it = alreadyLookedPath.insert(Path);\n      if (!it.second)\n         continue;\n      StringRef DirPath(Path);\n      // Skip current directory, because what we want to autoload is not a random shared libraries but libraries\n      // generated by ROOT. In fact, some tests were failing because of this as they have their custom shared libraries\n      // (which is not supposed to be autoloaded)\n      if (!llvm::sys::fs::is_directory(DirPath) || Path == \".\")\n         continue;\n\n      sPaths.push_back(Path);\n\n      std::error_code EC;\n      for (llvm::sys::fs::directory_iterator DirIt(DirPath, EC), DirEnd;\n            DirIt != DirEnd && !EC; DirIt.increment(EC)) {\n\n         std::string FileName(DirIt->path());\n         if (!llvm::sys::fs::is_directory(FileName) && llvm::sys::path::extension(FileName) == \".so\") {\n            // TCling::IsLoaded is incredibly slow!\n            // No need to check linked libraries, as this function is only invoked\n            // for symbols that cannot be found (neither by dlsym nor in the JIT).\n            if (dyLibManager->isLibraryLoaded(FileName.c_str()))\n               continue;\n            sLibraries.push_back(std::make_pair(sPaths.size() - 1, llvm::sys::path::filename(FileName)));\n         }\n      }\n   }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/net/http/civetweb/civetweb.c": "/* Copyright (c) 2013-2018 the Civetweb developers\n * Copyright (c) 2004-2013 Sergey Lyubka\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n#define GCC_VERSION                                                            \\\n\t(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#if GCC_VERSION >= 40500\n/* gcc diagnostic pragmas available */\n#define GCC_DIAGNOSTIC\n#endif\n#endif\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable unused macros warnings - not all defines are required\n * for all systems and all compilers. */\n#pragma GCC diagnostic ignored \"-Wunused-macros\"\n/* A padding warning is just plain useless */\n#pragma GCC diagnostic ignored \"-Wpadded\"\n#endif\n\n#if defined(__clang__) /* GCC does not (yet) support this pragma */\n/* We must set some flags for the headers we include. These flags\n * are reserved ids according to C99, so we need to disable a\n * warning for that. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n\n#if defined(_WIN32)\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005 */\n#endif\n#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */\n#define _WIN32_WINNT 0x0501\n#endif\n#else\n#if !defined(_GNU_SOURCE)\n#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */\n#endif\n#if defined(__linux__) && !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */\n#endif\n#if !defined(_LARGEFILE_SOURCE)\n#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */\n#endif\n#if !defined(_FILE_OFFSET_BITS)\n#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */\n#endif\n#if !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */\n#endif\n#if !defined(__STDC_LIMIT_MACROS)\n#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */\n#endif\n#if !defined(_DARWIN_UNLIMITED_SELECT)\n#define _DARWIN_UNLIMITED_SELECT\n#endif\n#if defined(__sun)\n#define __EXTENSIONS__  /* to expose flockfile and friends in stdio.h */\n#define __inline inline /* not recognized on older compiler versions */\n#endif\n#endif\n\n#if defined(__clang__)\n/* Enable reserved-id-macro warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\n#if defined(USE_LUA)\n#define USE_TIMERS\n#endif\n\n#if defined(_MSC_VER)\n/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */\n#pragma warning(disable : 4306)\n/* conditional expression is constant: introduced by FD_SET(..) */\n#pragma warning(disable : 4127)\n/* non-constant aggregate initializer: issued due to missing C99 support */\n#pragma warning(disable : 4204)\n/* padding added after data member */\n#pragma warning(disable : 4820)\n/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */\n#pragma warning(disable : 4668)\n/* no function prototype given: converting '()' to '(void)' */\n#pragma warning(disable : 4255)\n/* function has been selected for automatic inline expansion */\n#pragma warning(disable : 4711)\n#endif\n\n\n/* This code uses static_assert to check some conditions.\n * Unfortunately some compilers still do not support it, so we have a\n * replacement function here. */\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L\n#define mg_static_assert _Static_assert\n#elif defined(__cplusplus) && __cplusplus >= 201103L\n#define mg_static_assert static_assert\n#else\nchar static_assert_replacement[1];\n#define mg_static_assert(cond, txt)                                            \\\n\textern char static_assert_replacement[(cond) ? 1 : -1]\n#endif\n\nmg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,\n                 \"int data type size check\");\nmg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,\n                 \"pointer data type size check\");\nmg_static_assert(sizeof(void *) >= sizeof(int), \"data type size check\");\n\n\n/* Alternative queue is well tested and should be the new default */\n#if defined(NO_ALTERNATIVE_QUEUE)\n#if defined(ALTERNATIVE_QUEUE)\n#error \"Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE or none, but not both\"\n#endif\n#else\n#define ALTERNATIVE_QUEUE\n#endif\n\n\n/* DTL -- including winsock2.h works better if lean and mean */\n#if !defined(WIN32_LEAN_AND_MEAN)\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(__SYMBIAN32__)\n/* According to https://en.wikipedia.org/wiki/Symbian#History,\n * Symbian is no longer maintained since 2014-01-01.\n * Recent versions of CivetWeb are no longer tested for Symbian.\n * It makes no sense, to support an abandoned operating system.\n */\n#error \"Symbian is no longer maintained. CivetWeb no longer supports Symbian.\"\n#define NO_SSL /* SSL is not supported */\n#define NO_CGI /* CGI is not supported */\n#define PATH_MAX FILENAME_MAX\n#endif /* __SYMBIAN32__ */\n\n\n#if !defined(CIVETWEB_HEADER_INCLUDED)\n/* Include the header file here, so the CivetWeb interface is defined for the\n * entire implementation, including the following forward definitions. */\n#include \"civetweb.h\"\n#endif\n\n#if !defined(DEBUG_TRACE)\n#if defined(DEBUG)\nstatic void DEBUG_TRACE_FUNC(const char *func,\n                             unsigned line,\n                             PRINTF_FORMAT_STRING(const char *fmt),\n                             ...) PRINTF_ARGS(3, 4);\n\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tDEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__)\n\n#define NEED_DEBUG_TRACE_FUNC\n\n#else\n#define DEBUG_TRACE(fmt, ...)                                                  \\\n\tdo {                                                                       \\\n\t} while (0)\n#endif /* DEBUG */\n#endif /* DEBUG_TRACE */\n\n\n#if !defined(DEBUG_ASSERT)\n#if defined(DEBUG)\n#define DEBUG_ASSERT(cond)                                                     \\\n\tdo {                                                                       \\\n\t\tif (!(cond)) {                                                         \\\n\t\t\tDEBUG_TRACE(\"ASSERTION FAILED: %s\", #cond);                        \\\n\t\t\texit(2); /* Exit with error */                                     \\\n\t\t}                                                                      \\\n\t} while (0)\n#else\n#define DEBUG_ASSERT(cond)\n#endif /* DEBUG */\n#endif\n\n\n#if defined(__GNUC__) && defined(GCC_INSTRUMENTATION)\nvoid __cyg_profile_func_enter(void *this_fn, void *call_site)\n    __attribute__((no_instrument_function));\n\nvoid __cyg_profile_func_exit(void *this_fn, void *call_site)\n    __attribute__((no_instrument_function));\n\nvoid\n__cyg_profile_func_enter(void *this_fn, void *call_site)\n{\n\tif ((void *)this_fn != (void *)printf) {\n\t\tprintf(\"E %p %p\\n\", this_fn, call_site);\n\t}\n}\n\nvoid\n__cyg_profile_func_exit(void *this_fn, void *call_site)\n{\n\tif ((void *)this_fn != (void *)printf) {\n\t\tprintf(\"X %p %p\\n\", this_fn, call_site);\n\t}\n}\n#endif\n\n\n#if !defined(IGNORE_UNUSED_RESULT)\n#define IGNORE_UNUSED_RESULT(a) ((void)((a) && 1))\n#endif\n\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n\n/* GCC unused function attribute seems fundamentally broken.\n * Several attempts to tell the compiler \"THIS FUNCTION MAY BE USED\n * OR UNUSED\" for individual functions failed.\n * Either the compiler creates an \"unused-function\" warning if a\n * function is not marked with __attribute__((unused)).\n * On the other hand, if the function is marked with this attribute,\n * but is used, the compiler raises a completely idiotic\n * \"used-but-marked-unused\" warning - and\n *   #pragma GCC diagnostic ignored \"-Wused-but-marked-unused\"\n * raises error: unknown option after \"#pragma GCC diagnostic\".\n * Disable this warning completely, until the GCC guys sober up\n * again.\n */\n\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n\n#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */\n\n#else\n#define FUNCTION_MAY_BE_UNUSED\n#endif\n\n\n/* Some ANSI #includes are not available on Windows CE */\n#if !defined(_WIN32_WCE)\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#endif /* !_WIN32_WCE */\n\n\n#if defined(__clang__)\n/* When using -Weverything, clang does not accept it's own headers\n * in a release build configuration. Disable what is too much in\n * -Weverything. */\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#endif\n\n#if defined(__GNUC__) || defined(__MINGW32__)\n/* Who on earth came to the conclusion, using __DATE__ should rise\n * an \"expansion of date or time macro is not reproducible\"\n * warning. That's exactly what was intended by using this macro.\n * Just disable this nonsense warning. */\n\n/* And disabling them does not work either:\n * #pragma clang diagnostic ignored \"-Wno-error=date-time\"\n * #pragma clang diagnostic ignored \"-Wdate-time\"\n * So we just have to disable ALL warnings for some lines\n * of code.\n * This seems to be a known GCC bug, not resolved since 2012:\n * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431\n */\n#endif\n\n\n#if defined(__MACH__) /* Apple OSX section */\n\n#if defined(__clang__)\n#if (__clang_major__ == 3) && ((__clang_minor__ == 7) || (__clang_minor__ == 8))\n/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */\n#pragma clang diagnostic ignored \"-Wno-reserved-id-macro\"\n#pragma clang diagnostic ignored \"-Wno-keyword-macro\"\n#endif\n#endif\n\n#define CLOCK_MONOTONIC (1)\n#define CLOCK_REALTIME (2)\n\n#include <mach/clock.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n#include <sys/errno.h>\n#include <sys/time.h>\n\n/* clock_gettime is not implemented on OSX prior to 10.12 */\nstatic int\n_civet_clock_gettime(int clk_id, struct timespec *t)\n{\n\tmemset(t, 0, sizeof(*t));\n\tif (clk_id == CLOCK_REALTIME) {\n\t\tstruct timeval now;\n\t\tint rv = gettimeofday(&now, NULL);\n\t\tif (rv) {\n\t\t\treturn rv;\n\t\t}\n\t\tt->tv_sec = now.tv_sec;\n\t\tt->tv_nsec = now.tv_usec * 1000;\n\t\treturn 0;\n\n\t} else if (clk_id == CLOCK_MONOTONIC) {\n\t\tstatic uint64_t clock_start_time = 0;\n\t\tstatic mach_timebase_info_data_t timebase_ifo = {0, 0};\n\n\t\tuint64_t now = mach_absolute_time();\n\n\t\tif (clock_start_time == 0) {\n\t\t\tkern_return_t mach_status = mach_timebase_info(&timebase_ifo);\n\t\t\tDEBUG_ASSERT(mach_status == KERN_SUCCESS);\n\n\t\t\t/* appease \"unused variable\" warning for release builds */\n\t\t\t(void)mach_status;\n\n\t\t\tclock_start_time = now;\n\t\t}\n\n\t\tnow = (uint64_t)((double)(now - clock_start_time)\n\t\t                 * (double)timebase_ifo.numer\n\t\t                 / (double)timebase_ifo.denom);\n\n\t\tt->tv_sec = now / 1000000000;\n\t\tt->tv_nsec = now % 1000000000;\n\t\treturn 0;\n\t}\n\treturn -1; /* EINVAL - Clock ID is unknown */\n}\n\n/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */\n#if defined(__CLOCK_AVAILABILITY)\n/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be\n * declared but it may be NULL at runtime. So we need to check before using\n * it. */\nstatic int\n_civet_safe_clock_gettime(int clk_id, struct timespec *t)\n{\n\tif (clock_gettime) {\n\t\treturn clock_gettime(clk_id, t);\n\t}\n\treturn _civet_clock_gettime(clk_id, t);\n}\n#define clock_gettime _civet_safe_clock_gettime\n#else\n#define clock_gettime _civet_clock_gettime\n#endif\n\n#endif\n\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n/********************************************************************/\n/* CivetWeb configuration defines */\n/********************************************************************/\n\n/* Maximum number of threads that can be configured.\n * The number of threads actually created depends on the \"num_threads\"\n * configuration parameter, but this is the upper limit. */\n#if !defined(MAX_WORKER_THREADS)\n#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */\n#endif\n\n/* Timeout interval for select/poll calls.\n * The timeouts depend on \"*_timeout_ms\" configuration values, but long\n * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.\n * This reduces the time required to stop the server. */\n#if !defined(SOCKET_TIMEOUT_QUANTUM)\n#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */\n#endif\n\n/* Do not try to compress files smaller than this limit. */\n#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT)\n#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */\n#endif\n\n#if !defined(PASSWORDS_FILE_NAME)\n#define PASSWORDS_FILE_NAME \".htpasswd\"\n#endif\n\n/* Initial buffer size for all CGI environment variables. In case there is\n * not enough space, another block is allocated. */\n#if !defined(CGI_ENVIRONMENT_SIZE)\n#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */\n#endif\n\n/* Maximum number of environment variables. */\n#if !defined(MAX_CGI_ENVIR_VARS)\n#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */\n#endif\n\n/* General purpose buffer size. */\n#if !defined(MG_BUF_LEN) /* in bytes */\n#define MG_BUF_LEN (1024 * 8)\n#endif\n\n/* Size of the accepted socket queue (in case the old queue implementation\n * is used). */\n#if !defined(MGSQLEN)\n#define MGSQLEN (20) /* count */\n#endif\n\n\n/********************************************************************/\n\n/* Helper makros */\n#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n/* Standard defines */\n#if !defined(INT64_MAX)\n#define INT64_MAX (9223372036854775807)\n#endif\n\n#define SHUTDOWN_RD (0)\n#define SHUTDOWN_WR (1)\n#define SHUTDOWN_BOTH (2)\n\nmg_static_assert(MAX_WORKER_THREADS >= 1,\n                 \"worker threads must be a positive number\");\n\nmg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,\n                 \"size_t data type size check\");\n\n#if defined(_WIN32) /* WINDOWS include block */\n#include <windows.h>\n#include <winsock2.h> /* DTL add for SO_EXCLUSIVE */\n#include <ws2tcpip.h>\n\ntypedef const char *SOCK_OPT_TYPE;\n\n#if !defined(PATH_MAX)\n#define W_PATH_MAX (MAX_PATH)\n/* at most three UTF-8 chars per wchar_t */\n#define PATH_MAX (W_PATH_MAX * 3)\n#else\n#define W_PATH_MAX ((PATH_MAX + 2) / 3)\n#endif\n\nmg_static_assert(PATH_MAX >= 1, \"path length must be a positive number\");\n\n#if !defined(_IN_PORT_T)\n#if !defined(in_port_t)\n#define in_port_t u_short\n#endif\n#endif\n\n#if !defined(_WIN32_WCE)\n#include <direct.h>\n#include <io.h>\n#include <process.h>\n#else            /* _WIN32_WCE */\n#define NO_CGI   /* WinCE has no pipes */\n#define NO_POPEN /* WinCE has no popen */\n\ntypedef long off_t;\n\n#define errno ((int)(GetLastError()))\n#define strerror(x) (_ultoa(x, (char *)_alloca(sizeof(x) * 3), 10))\n#endif /* _WIN32_WCE */\n\n#define MAKEUQUAD(lo, hi)                                                      \\\n\t((uint64_t)(((uint32_t)(lo)) | ((uint64_t)((uint32_t)(hi))) << 32))\n#define RATE_DIFF (10000000) /* 100 nsecs */\n#define EPOCH_DIFF (MAKEUQUAD(0xd53e8000, 0x019db1de))\n#define SYS2UNIX_TIME(lo, hi)                                                  \\\n\t((time_t)((MAKEUQUAD((lo), (hi)) - EPOCH_DIFF) / RATE_DIFF))\n\n/* Visual Studio 6 does not know __func__ or __FUNCTION__\n * The rest of MS compilers use __FUNCTION__, not C99 __func__\n * Also use _strtoui64 on modern M$ compilers */\n#if defined(_MSC_VER)\n#if (_MSC_VER < 1300)\n#define STRX(x) #x\n#define STR(x) STRX(x)\n#define __func__ __FILE__ \":\" STR(__LINE__)\n#define strtoull(x, y, z) ((unsigned __int64)_atoi64(x))\n#define strtoll(x, y, z) (_atoi64(x))\n#else\n#define __func__ __FUNCTION__\n#define strtoull(x, y, z) (_strtoui64(x, y, z))\n#define strtoll(x, y, z) (_strtoi64(x, y, z))\n#endif\n#endif /* _MSC_VER */\n\n#define ERRNO ((int)(GetLastError()))\n#define NO_SOCKLEN_T\n\n#if defined(_WIN64) || defined(__MINGW64__)\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay64.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay64.dll\"\n#endif\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"ssleay32.dll\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libeay32.dll\"\n#endif\n#endif\n\n#define O_NONBLOCK (0)\n#if !defined(W_OK)\n#define W_OK (2) /* http://msdn.microsoft.com/en-us/library/1w06ktdy.aspx */\n#endif\n#if !defined(EWOULDBLOCK)\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#endif /* !EWOULDBLOCK */\n#define _POSIX_\n#define INT64_FMT \"I64d\"\n#define UINT64_FMT \"I64u\"\n\n#define WINCDECL __cdecl\n#define vsnprintf_impl _vsnprintf\n#define access _access\n#define mg_sleep(x) (Sleep(x))\n\n#define pipe(x) _pipe(x, MG_BUF_LEN, _O_BINARY)\n#if !defined(popen)\n#define popen(x, y) (_popen(x, y))\n#endif\n#if !defined(pclose)\n#define pclose(x) (_pclose(x))\n#endif\n#define close(x) (_close(x))\n#define dlsym(x, y) (GetProcAddress((HINSTANCE)(x), (y)))\n#define RTLD_LAZY (0)\n#define fseeko(x, y, z) ((_lseeki64(_fileno(x), (y), (z)) == -1) ? -1 : 0)\n#define fdopen(x, y) (_fdopen((x), (y)))\n#define write(x, y, z) (_write((x), (y), (unsigned)z))\n#define read(x, y, z) (_read((x), (y), (unsigned)z))\n#define flockfile(x) (EnterCriticalSection(&global_log_file_lock))\n#define funlockfile(x) (LeaveCriticalSection(&global_log_file_lock))\n#define sleep(x) (Sleep((x)*1000))\n#define rmdir(x) (_rmdir(x))\n#if defined(_WIN64) || !defined(__MINGW32__)\n/* Only MinGW 32 bit is missing this function */\n#define timegm(x) (_mkgmtime(x))\n#else\ntime_t timegm(struct tm *tm);\n#define NEED_TIMEGM\n#endif\n\n\n#if !defined(fileno)\n#define fileno(x) (_fileno(x))\n#endif /* !fileno MINGW #defines fileno */\n\ntypedef HANDLE pthread_mutex_t;\ntypedef DWORD pthread_key_t;\ntypedef HANDLE pthread_t;\ntypedef struct {\n\tCRITICAL_SECTION threadIdSec;\n\tstruct mg_workerTLS *waiting_thread; /* The chain of threads */\n} pthread_cond_t;\n\n#if !defined(__clockid_t_defined)\ntypedef DWORD clockid_t;\n#endif\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC (1)\n#endif\n#if !defined(CLOCK_REALTIME)\n#define CLOCK_REALTIME (2)\n#endif\n#if !defined(CLOCK_THREAD)\n#define CLOCK_THREAD (3)\n#endif\n#if !defined(CLOCK_PROCESS)\n#define CLOCK_PROCESS (4)\n#endif\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1900)\n#define _TIMESPEC_DEFINED\n#endif\n#if !defined(_TIMESPEC_DEFINED)\nstruct timespec {\n\ttime_t tv_sec; /* seconds */\n\tlong tv_nsec;  /* nanoseconds */\n};\n#endif\n\n#if !defined(WIN_PTHREADS_TIME_H)\n#define MUST_IMPLEMENT_CLOCK_GETTIME\n#endif\n\n#if defined(MUST_IMPLEMENT_CLOCK_GETTIME)\n#define clock_gettime mg_clock_gettime\nstatic int\nclock_gettime(clockid_t clk_id, struct timespec *tp)\n{\n\tFILETIME ft;\n\tULARGE_INTEGER li, li2;\n\tBOOL ok = FALSE;\n\tdouble d;\n\tstatic double perfcnt_per_sec = 0.0;\n\tstatic BOOL initialized = FALSE;\n\n\tif (!initialized) {\n\t\tQueryPerformanceFrequency((LARGE_INTEGER *)&li);\n\t\tperfcnt_per_sec = 1.0 / li.QuadPart;\n\t\tinitialized = TRUE;\n\t}\n\n\tif (tp) {\n\t\tmemset(tp, 0, sizeof(*tp));\n\n\t\tif (clk_id == CLOCK_REALTIME) {\n\n\t\t\t/* BEGIN: CLOCK_REALTIME = wall clock (date and time) */\n\t\t\tGetSystemTimeAsFileTime(&ft);\n\t\t\tli.LowPart = ft.dwLowDateTime;\n\t\t\tli.HighPart = ft.dwHighDateTime;\n\t\t\tli.QuadPart -= 116444736000000000; /* 1.1.1970 in filedate */\n\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_REALTIME */\n\n\t\t} else if (clk_id == CLOCK_MONOTONIC) {\n\n\t\t\t/* BEGIN: CLOCK_MONOTONIC = stopwatch (time differences) */\n\t\t\tQueryPerformanceCounter((LARGE_INTEGER *)&li);\n\t\t\td = li.QuadPart * perfcnt_per_sec;\n\t\t\ttp->tv_sec = (time_t)d;\n\t\t\td -= (double)tp->tv_sec;\n\t\t\ttp->tv_nsec = (long)(d * 1.0E9);\n\t\t\tok = TRUE;\n\t\t\t/* END: CLOCK_MONOTONIC */\n\n\t\t} else if (clk_id == CLOCK_THREAD) {\n\n\t\t\t/* BEGIN: CLOCK_THREAD = CPU usage of thread */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetThreadTimes(GetCurrentThread(),\n\t\t\t                   &t_create,\n\t\t\t                   &t_exit,\n\t\t\t                   &t_kernel,\n\t\t\t                   &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_THREAD */\n\n\t\t} else if (clk_id == CLOCK_PROCESS) {\n\n\t\t\t/* BEGIN: CLOCK_PROCESS = CPU usage of process */\n\t\t\tFILETIME t_create, t_exit, t_kernel, t_user;\n\t\t\tif (GetProcessTimes(GetCurrentProcess(),\n\t\t\t                    &t_create,\n\t\t\t                    &t_exit,\n\t\t\t                    &t_kernel,\n\t\t\t                    &t_user)) {\n\t\t\t\tli.LowPart = t_user.dwLowDateTime;\n\t\t\t\tli.HighPart = t_user.dwHighDateTime;\n\t\t\t\tli2.LowPart = t_kernel.dwLowDateTime;\n\t\t\t\tli2.HighPart = t_kernel.dwHighDateTime;\n\t\t\t\tli.QuadPart += li2.QuadPart;\n\t\t\t\ttp->tv_sec = (time_t)(li.QuadPart / 10000000);\n\t\t\t\ttp->tv_nsec = (long)(li.QuadPart % 10000000) * 100;\n\t\t\t\tok = TRUE;\n\t\t\t}\n\t\t\t/* END: CLOCK_PROCESS */\n\n\t\t} else {\n\n\t\t\t/* BEGIN: unknown clock */\n\t\t\t/* ok = FALSE; already set by init */\n\t\t\t/* END: unknown clock */\n\t\t}\n\t}\n\n\treturn ok ? 0 : -1;\n}\n#endif\n\n\n#define pid_t HANDLE /* MINGW typedefs pid_t to int. Using #define here. */\n\nstatic int pthread_mutex_lock(pthread_mutex_t *);\nstatic int pthread_mutex_unlock(pthread_mutex_t *);\nstatic void path_to_unicode(const struct mg_connection *conn,\n                            const char *path,\n                            wchar_t *wbuf,\n                            size_t wbuf_len);\n\n/* All file operations need to be rewritten to solve #246. */\n\nstruct mg_file;\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p);\n\n\n/* POSIX dirent interface */\nstruct dirent {\n\tchar d_name[PATH_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE handle;\n\tWIN32_FIND_DATAW info;\n\tstruct dirent result;\n} DIR;\n\n#if defined(_WIN32)\n#if !defined(HAVE_POLL)\nstruct pollfd {\n\tSOCKET fd;\n\tshort events;\n\tshort revents;\n};\n#endif\n#endif\n\n/* Mark required libraries */\n#if defined(_MSC_VER)\n#pragma comment(lib, \"Ws2_32.lib\")\n#endif\n\n#else /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n#include <arpa/inet.h>\n#include <inttypes.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <stdint.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\ntypedef const void *SOCK_OPT_TYPE;\n\n#if defined(ANDROID)\ntypedef unsigned short int in_port_t;\n#endif\n\n#include <dirent.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#define vsnprintf_impl vsnprintf\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n#include <dlfcn.h>\n#endif\n#include <pthread.h>\n#if defined(__MACH__)\n#define SSL_LIB \"libssl.dylib\"\n#define CRYPTO_LIB \"libcrypto.dylib\"\n#else\n#if !defined(SSL_LIB)\n#define SSL_LIB \"libssl.so\"\n#endif\n#if !defined(CRYPTO_LIB)\n#define CRYPTO_LIB \"libcrypto.so\"\n#endif\n#endif\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif /* O_BINARY */\n#define closesocket(a) (close(a))\n#define mg_mkdir(conn, path, mode) (mkdir(path, mode))\n#define mg_remove(conn, x) (remove(x))\n#define mg_sleep(x) (usleep((x)*1000))\n#define mg_opendir(conn, x) (opendir(x))\n#define mg_closedir(x) (closedir(x))\n#define mg_readdir(x) (readdir(x))\n#define ERRNO (errno)\n#define INVALID_SOCKET (-1)\n#define INT64_FMT PRId64\n#define UINT64_FMT PRIu64\ntypedef int SOCKET;\n#define WINCDECL\n\n#if defined(__hpux)\n/* HPUX 11 does not have monotonic, fall back to realtime */\n#if !defined(CLOCK_MONOTONIC)\n#define CLOCK_MONOTONIC CLOCK_REALTIME\n#endif\n\n/* HPUX defines socklen_t incorrectly as size_t which is 64bit on\n * Itanium.  Without defining _XOPEN_SOURCE or _XOPEN_SOURCE_EXTENDED\n * the prototypes use int* rather than socklen_t* which matches the\n * actual library expectation.  When called with the wrong size arg\n * accept() returns a zero client inet addr and check_acl() always\n * fails.  Since socklen_t is widely used below, just force replace\n * their typedef with int. - DTL\n */\n#define socklen_t int\n#endif /* hpux */\n\n#endif /* defined(_WIN32) - WINDOWS vs UNIX include block */\n\n/* Maximum queue length for pending connections. This value is passed as\n * parameter to the \"listen\" socket call. */\n#if !defined(SOMAXCONN)\n/* This symbol may be defined in winsock2.h so this must after that include */\n#define SOMAXCONN (100) /* in pending connections (count) */\n#endif\n\n/* In case our C library is missing \"timegm\", provide an implementation */\n#if defined(NEED_TIMEGM)\nstatic inline int\nis_leap(int y)\n{\n\treturn (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n}\n\nstatic inline int\ncount_leap(int y)\n{\n\treturn (y - 1969) / 4 - (y - 1901) / 100 + (y - 1601) / 400;\n}\n\ntime_t\ntimegm(struct tm *tm)\n{\n\tstatic const unsigned short ydays[] = {\n\t    0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\n\tint year = tm->tm_year + 1900;\n\tint mon = tm->tm_mon;\n\tint mday = tm->tm_mday - 1;\n\tint hour = tm->tm_hour;\n\tint min = tm->tm_min;\n\tint sec = tm->tm_sec;\n\n\tif (year < 1970 || mon < 0 || mon > 11 || mday < 0\n\t    || (mday >= ydays[mon + 1] - ydays[mon]\n\t                    + (mon == 1 && is_leap(year) ? 1 : 0))\n\t    || hour < 0 || hour > 23 || min < 0 || min > 59 || sec < 0 || sec > 60)\n\t\treturn -1;\n\n\ttime_t res = year - 1970;\n\tres *= 365;\n\tres += mday;\n\tres += ydays[mon] + (mon > 1 && is_leap(year) ? 1 : 0);\n\tres += count_leap(year);\n\n\tres *= 24;\n\tres += hour;\n\tres *= 60;\n\tres += min;\n\tres *= 60;\n\tres += sec;\n\treturn res;\n}\n#endif /* NEED_TIMEGM */\n\n\n/* va_copy should always be a macro, C99 and C++11 - DTL */\n#if !defined(va_copy)\n#define va_copy(x, y) ((x) = (y))\n#endif\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nstatic CRITICAL_SECTION global_log_file_lock;\n\nFUNCTION_MAY_BE_UNUSED\nstatic DWORD\npthread_self(void)\n{\n\treturn GetCurrentThreadId();\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_create(\n    pthread_key_t *key,\n    void (*_ignored)(void *) /* destructor not supported for Windows */\n)\n{\n\t(void)_ignored;\n\n\tif ((key != 0)) {\n\t\t*key = TlsAlloc();\n\t\treturn (*key != TLS_OUT_OF_INDEXES) ? 0 : -1;\n\t}\n\treturn -2;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_key_delete(pthread_key_t key)\n{\n\treturn TlsFree(key) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_setspecific(pthread_key_t key, void *value)\n{\n\treturn TlsSetValue(key, value) ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void *\npthread_getspecific(pthread_key_t key)\n{\n\treturn TlsGetValue(key);\n}\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\nstatic struct pthread_mutex_undefined_struct *pthread_mutex_attr = NULL;\n#else\nstatic pthread_mutexattr_t pthread_mutex_attr;\n#endif /* _WIN32 */\n\n\n#if defined(_WIN32_WCE)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic time_t\ntime(time_t *ptime)\n{\n\ttime_t t;\n\tSYSTEMTIME st;\n\tFILETIME ft;\n\n\tGetSystemTime(&st);\n\tSystemTimeToFileTime(&st, &ft);\n\tt = SYS2UNIX_TIME(ft.dwLowDateTime, ft.dwHighDateTime);\n\n\tif (ptime != NULL) {\n\t\t*ptime = t;\n\t}\n\n\treturn t;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime_s(const time_t *ptime, struct tm *ptm)\n{\n\tint64_t t = ((int64_t)*ptime) * RATE_DIFF + EPOCH_DIFF;\n\tFILETIME ft, lft;\n\tSYSTEMTIME st;\n\tTIME_ZONE_INFORMATION tzinfo;\n\n\tif (ptm == NULL) {\n\t\treturn NULL;\n\t}\n\n\t*(int64_t *)&ft = t;\n\tFileTimeToLocalFileTime(&ft, &lft);\n\tFileTimeToSystemTime(&lft, &st);\n\tptm->tm_year = st.wYear - 1900;\n\tptm->tm_mon = st.wMonth - 1;\n\tptm->tm_wday = st.wDayOfWeek;\n\tptm->tm_mday = st.wDay;\n\tptm->tm_hour = st.wHour;\n\tptm->tm_min = st.wMinute;\n\tptm->tm_sec = st.wSecond;\n\tptm->tm_yday = 0; /* hope nobody uses this */\n\tptm->tm_isdst =\n\t    (GetTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_DAYLIGHT) ? 1 : 0;\n\n\treturn ptm;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime_s(const time_t *ptime, struct tm *ptm)\n{\n\t/* FIXME(lsm): fix this. */\n\treturn localtime_s(ptime, ptm);\n}\n\n\nstatic int mg_atomic_inc(volatile int *addr);\nstatic struct tm tm_array[MAX_WORKER_THREADS];\nstatic int tm_index = 0;\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\nlocaltime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % (sizeof(tm_array) / sizeof(tm_array[0]));\n\treturn localtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct tm *\ngmtime(const time_t *ptime)\n{\n\tint i = mg_atomic_inc(&tm_index) % ARRAY_SIZE(tm_array);\n\treturn gmtime_s(ptime, tm_array + i);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic size_t\nstrftime(char *dst, size_t dst_size, const char *fmt, const struct tm *tm)\n{\n\t/* TODO: (void)mg_snprintf(NULL, dst, dst_size, \"implement strftime()\n\t * for WinCE\"); */\n\treturn 0;\n}\n\n#define _beginthreadex(psec, stack, func, prm, flags, ptid)                    \\\n\t(uintptr_t) CreateThread(psec, stack, func, prm, flags, ptid)\n\n#define remove(f) mg_remove(NULL, f)\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nrename(const char *a, const char *b)\n{\n\twchar_t wa[W_PATH_MAX];\n\twchar_t wb[W_PATH_MAX];\n\tpath_to_unicode(NULL, a, wa, ARRAY_SIZE(wa));\n\tpath_to_unicode(NULL, b, wb, ARRAY_SIZE(wb));\n\n\treturn MoveFileW(wa, wb) ? 0 : -1;\n}\n\n\nstruct stat {\n\tint64_t st_size;\n\ttime_t st_mtime;\n};\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nstat(const char *name, struct stat *st)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA attr;\n\ttime_t creation_time, write_time;\n\n\tpath_to_unicode(NULL, name, wbuf, ARRAY_SIZE(wbuf));\n\tmemset(&attr, 0, sizeof(attr));\n\n\tGetFileAttributesExW(wbuf, GetFileExInfoStandard, &attr);\n\tst->st_size =\n\t    (((int64_t)attr.nFileSizeHigh) << 32) + (int64_t)attr.nFileSizeLow;\n\n\twrite_time = SYS2UNIX_TIME(attr.ftLastWriteTime.dwLowDateTime,\n\t                           attr.ftLastWriteTime.dwHighDateTime);\n\tcreation_time = SYS2UNIX_TIME(attr.ftCreationTime.dwLowDateTime,\n\t                              attr.ftCreationTime.dwHighDateTime);\n\n\tif (creation_time > write_time) {\n\t\tst->st_mtime = creation_time;\n\t} else {\n\t\tst->st_mtime = write_time;\n\t}\n\treturn 0;\n}\n\n#define access(x, a) 1 /* not required anyway */\n\n/* WinCE-TODO: define stat, remove, rename, _rmdir, _lseeki64 */\n/* Values from errno.h in Windows SDK (Visual Studio). */\n#define EEXIST 17\n#define EACCES 13\n#define ENOENT 2\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif /* defined(_WIN32_WCE) */\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nstatic pthread_mutex_t global_lock_mutex;\n\n\n#if defined(_WIN32)\n/* Forward declaration for Windows */\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_lock(pthread_mutex_t *mutex);\n\nFUNCTION_MAY_BE_UNUSED\nstatic int pthread_mutex_unlock(pthread_mutex_t *mutex);\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_lock(void)\n{\n\t(void)pthread_mutex_lock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nmg_global_unlock(void)\n{\n\t(void)pthread_mutex_unlock(&global_lock_mutex);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_inc(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedIncrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (++(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_atomic_dec(volatile int *addr)\n{\n\tint ret;\n#if defined(_WIN32) && !defined(NO_ATOMICS)\n\t/* Depending on the SDK, this function uses either\n\t * (volatile unsigned int *) or (volatile LONG *),\n\t * so whatever you use, the other SDK is likely to raise a warning. */\n\tret = InterlockedDecrement((volatile long *)addr);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_sub_and_fetch(addr, 1);\n#else\n\tmg_global_lock();\n\tret = (--(*addr));\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n\n\n#if defined(USE_SERVER_STATS)\nstatic int64_t\nmg_atomic_add(volatile int64_t *addr, int64_t value)\n{\n\tint64_t ret;\n#if defined(_WIN64) && !defined(NO_ATOMICS)\n\tret = InterlockedAdd64(addr, value);\n#elif defined(__GNUC__)                                                        \\\n    && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0)))           \\\n    && !defined(NO_ATOMICS)\n\tret = __sync_add_and_fetch(addr, value);\n#else\n\tmg_global_lock();\n\t*addr += value;\n\tret = (*addr);\n\tmg_global_unlock();\n#endif\n\treturn ret;\n}\n#endif\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(USE_SERVER_STATS)\n\nstruct mg_memory_stat {\n\tvolatile int64_t totalMemUsed;\n\tvolatile int64_t maxMemUsed;\n\tvolatile int blockCount;\n};\n\n\nstatic struct mg_memory_stat *get_memory_stat(struct mg_context *ctx);\n\n\nstatic void *\nmg_malloc_ex(size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = malloc(size + 2 * sizeof(uintptr_t));\n\tvoid *memory = 0;\n\tstruct mg_memory_stat *mstat = get_memory_stat(ctx);\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (data) {\n\t\tint64_t mmem = mg_atomic_add(&mstat->totalMemUsed, (int64_t)size);\n\t\tif (mmem > mstat->maxMemUsed) {\n\t\t\t/* could use atomic compare exchange, but this\n\t\t\t * seems overkill for statistics data */\n\t\t\tmstat->maxMemUsed = mmem;\n\t\t}\n\n\t\tmg_atomic_inc(&mstat->blockCount);\n\t\t((uintptr_t *)data)[0] = size;\n\t\t((uintptr_t *)data)[1] = (uintptr_t)mstat;\n\t\tmemory = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t}\n\n#if defined(MEMORY_DEBUGGING)\n\tsprintf(mallocStr,\n\t        \"MEM: %p %5lu alloc   %7lu %4lu --- %s:%u\\n\",\n\t        memory,\n\t        (unsigned long)size,\n\t        (unsigned long)mstat->totalMemUsed,\n\t        (unsigned long)mstat->blockCount,\n\t        file,\n\t        line);\n#if defined(_WIN32)\n\tOutputDebugStringA(mallocStr);\n#else\n\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\n\treturn memory;\n}\n\n\nstatic void *\nmg_calloc_ex(size_t count,\n             size_t size,\n             struct mg_context *ctx,\n             const char *file,\n             unsigned line)\n{\n\tvoid *data = mg_malloc_ex(size * count, ctx, file, line);\n\n\tif (data) {\n\t\tmemset(data, 0, size * count);\n\t}\n\treturn data;\n}\n\n\nstatic void\nmg_free_ex(void *memory, const char *file, unsigned line)\n{\n\tvoid *data = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (memory) {\n\t\tuintptr_t size = ((uintptr_t *)data)[0];\n\t\tstruct mg_memory_stat *mstat =\n\t\t    (struct mg_memory_stat *)(((uintptr_t *)data)[1]);\n\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)size);\n\t\tmg_atomic_dec(&mstat->blockCount);\n#if defined(MEMORY_DEBUGGING)\n\t\tsprintf(mallocStr,\n\t\t        \"MEM: %p %5lu free    %7lu %4lu --- %s:%u\\n\",\n\t\t        memory,\n\t\t        (unsigned long)size,\n\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t        (unsigned long)mstat->blockCount,\n\t\t        file,\n\t\t        line);\n#if defined(_WIN32)\n\t\tOutputDebugStringA(mallocStr);\n#else\n\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\tfree(data);\n\t}\n}\n\n\nstatic void *\nmg_realloc_ex(void *memory,\n              size_t newsize,\n              struct mg_context *ctx,\n              const char *file,\n              unsigned line)\n{\n\tvoid *data;\n\tvoid *_realloc;\n\tuintptr_t oldsize;\n\n#if defined(MEMORY_DEBUGGING)\n\tchar mallocStr[256];\n#else\n\t(void)file;\n\t(void)line;\n#endif\n\n\tif (newsize) {\n\t\tif (memory) {\n\t\t\t/* Reallocate existing block */\n\t\t\tstruct mg_memory_stat *mstat;\n\t\t\tdata = (void *)(((char *)memory) - 2 * sizeof(uintptr_t));\n\t\t\toldsize = ((uintptr_t *)data)[0];\n\t\t\tmstat = (struct mg_memory_stat *)((uintptr_t *)data)[1];\n\t\t\t_realloc = realloc(data, newsize + 2 * sizeof(uintptr_t));\n\t\t\tif (_realloc) {\n\t\t\t\tdata = _realloc;\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, -(int64_t)oldsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-free  %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)oldsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\tmg_atomic_add(&mstat->totalMemUsed, (int64_t)newsize);\n#if defined(MEMORY_DEBUGGING)\n\t\t\t\tsprintf(mallocStr,\n\t\t\t\t        \"MEM: %p %5lu r-alloc %7lu %4lu --- %s:%u\\n\",\n\t\t\t\t        memory,\n\t\t\t\t        (unsigned long)newsize,\n\t\t\t\t        (unsigned long)mstat->totalMemUsed,\n\t\t\t\t        (unsigned long)mstat->blockCount,\n\t\t\t\t        file,\n\t\t\t\t        line);\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(mallocStr);\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", mallocStr);\n#endif\n#endif\n\t\t\t\t*(uintptr_t *)data = newsize;\n\t\t\t\tdata = (void *)(((char *)data) + 2 * sizeof(uintptr_t));\n\t\t\t} else {\n#if defined(MEMORY_DEBUGGING)\n#if defined(_WIN32)\n\t\t\t\tOutputDebugStringA(\"MEM: realloc failed\\n\");\n#else\n\t\t\t\tDEBUG_TRACE(\"%s\", \"MEM: realloc failed\\n\");\n#endif\n#endif\n\t\t\t\treturn _realloc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Allocate new block */\n\t\t\tdata = mg_malloc_ex(newsize, ctx, file, line);\n\t\t}\n\t} else {\n\t\t/* Free existing block */\n\t\tdata = 0;\n\t\tmg_free_ex(memory, file, line);\n\t}\n\n\treturn data;\n}\n\n#define mg_malloc(a) mg_malloc_ex(a, NULL, __FILE__, __LINE__)\n#define mg_calloc(a, b) mg_calloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_realloc(a, b) mg_realloc_ex(a, b, NULL, __FILE__, __LINE__)\n#define mg_free(a) mg_free_ex(a, __FILE__, __LINE__)\n\n#define mg_malloc_ctx(a, c) mg_malloc_ex(a, c, __FILE__, __LINE__)\n#define mg_calloc_ctx(a, b, c) mg_calloc_ex(a, b, c, __FILE__, __LINE__)\n#define mg_realloc_ctx(a, b, c) mg_realloc_ex(a, b, c, __FILE__, __LINE__)\n\n#else /* USE_SERVER_STATS */\n\nstatic __inline void *\nmg_malloc(size_t a)\n{\n\treturn malloc(a);\n}\n\nstatic __inline void *\nmg_calloc(size_t a, size_t b)\n{\n\treturn calloc(a, b);\n}\n\nstatic __inline void *\nmg_realloc(void *a, size_t b)\n{\n\treturn realloc(a, b);\n}\n\nstatic __inline void\nmg_free(void *a)\n{\n\tfree(a);\n}\n\n#define mg_malloc_ctx(a, c) mg_malloc(a)\n#define mg_calloc_ctx(a, b, c) mg_calloc(a, b)\n#define mg_realloc_ctx(a, b, c) mg_realloc(a, b)\n#define mg_free_ctx(a, c) mg_free(a)\n\n#endif /* USE_SERVER_STATS */\n\n\nstatic void mg_vsnprintf(const struct mg_connection *conn,\n                         int *truncated,\n                         char *buf,\n                         size_t buflen,\n                         const char *fmt,\n                         va_list ap);\n\nstatic void mg_snprintf(const struct mg_connection *conn,\n                        int *truncated,\n                        char *buf,\n                        size_t buflen,\n                        PRINTF_FORMAT_STRING(const char *fmt),\n                        ...) PRINTF_ARGS(5, 6);\n\n/* This following lines are just meant as a reminder to use the mg-functions\n * for memory management */\n#if defined(malloc)\n#undef malloc\n#endif\n#if defined(calloc)\n#undef calloc\n#endif\n#if defined(realloc)\n#undef realloc\n#endif\n#if defined(free)\n#undef free\n#endif\n#if defined(snprintf)\n#undef snprintf\n#endif\n#if defined(vsnprintf)\n#undef vsnprintf\n#endif\n#define malloc DO_NOT_USE_THIS_FUNCTION__USE_mg_malloc\n#define calloc DO_NOT_USE_THIS_FUNCTION__USE_mg_calloc\n#define realloc DO_NOT_USE_THIS_FUNCTION__USE_mg_realloc\n#define free DO_NOT_USE_THIS_FUNCTION__USE_mg_free\n#define snprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_snprintf\n#if defined(_WIN32)\n/* vsnprintf must not be used in any system,\n * but this define only works well for Windows. */\n#define vsnprintf DO_NOT_USE_THIS_FUNCTION__USE_mg_vsnprintf\n#endif\n\n\n/* mg_init_library counter */\nstatic int mg_init_library_called = 0;\n\n#if !defined(NO_SSL)\nstatic int mg_ssl_initialized = 0;\n#endif\n\nstatic pthread_key_t sTlsKey; /* Thread local storage index */\nstatic int thread_idx_max = 0;\n\n#if defined(MG_LEGACY_INTERFACE)\n#define MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE\n#endif\n\nstruct mg_workerTLS {\n\tint is_master;\n\tunsigned long thread_idx;\n#if defined(_WIN32)\n\tHANDLE pthread_cond_helper_mutex;\n\tstruct mg_workerTLS *next_waiting_thread;\n#endif\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tchar txtbuf[4];\n#endif\n};\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Get a unique thread ID as unsigned long, independent from the data type\n * of thread IDs defined by the operating system API.\n * If two calls to mg_current_thread_id  return the same value, they calls\n * are done from the same thread. If they return different values, they are\n * done from different threads. (Provided this function is used in the same\n * process context and threads are not repeatedly created and deleted, but\n * CivetWeb does not do that).\n * This function must match the signature required for SSL id callbacks:\n * CRYPTO_set_id_callback\n */\nFUNCTION_MAY_BE_UNUSED\nstatic unsigned long\nmg_current_thread_id(void)\n{\n#if defined(_WIN32)\n\treturn GetCurrentThreadId();\n#else\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* For every compiler, either \"sizeof(pthread_t) > sizeof(unsigned long)\"\n * or not, so one of the two conditions will be unreachable by construction.\n * Unfortunately the C standard does not define a way to check this at\n * compile time, since the #if preprocessor conditions can not use the sizeof\n * operator as an argument. */\n#endif\n\n\tif (sizeof(pthread_t) > sizeof(unsigned long)) {\n\t\t/* This is the problematic case for CRYPTO_set_id_callback:\n\t\t * The OS pthread_t can not be cast to unsigned long. */\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\t\tif (tls == NULL) {\n\t\t\t/* SSL called from an unknown thread: Create some thread index.\n\t\t\t */\n\t\t\ttls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));\n\t\t\ttls->is_master = -2; /* -2 means \"3rd party thread\" */\n\t\t\ttls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n\t\t\tpthread_setspecific(sTlsKey, tls);\n\t\t}\n\t\treturn tls->thread_idx;\n\t} else {\n\t\t/* pthread_t may be any data type, so a simple cast to unsigned long\n\t\t * can rise a warning/error, depending on the platform.\n\t\t * Here memcpy is used as an anything-to-anything cast. */\n\t\tunsigned long ret = 0;\n\t\tpthread_t t = pthread_self();\n\t\tmemcpy(&ret, &t, sizeof(pthread_t));\n\t\treturn ret;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic uint64_t\nmg_get_current_time_ns(void)\n{\n\tstruct timespec tsnow;\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\treturn (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n#if defined(__clang__)\n/* Show no warning in case system functions are not used. */\n#pragma clang diagnostic pop\n#endif\n\n\n#if defined(NEED_DEBUG_TRACE_FUNC)\nstatic void\nDEBUG_TRACE_FUNC(const char *func, unsigned line, const char *fmt, ...)\n{\n\tva_list args;\n\tuint64_t nsnow;\n\tstatic uint64_t nslast;\n\tstruct timespec tsnow;\n\n\t/* Get some operating system independent thread id */\n\tunsigned long thread_id = mg_current_thread_id();\n\n\tclock_gettime(CLOCK_REALTIME, &tsnow);\n\tnsnow = ((uint64_t)tsnow.tv_sec) * ((uint64_t)1000000000)\n\t        + ((uint64_t)tsnow.tv_nsec);\n\n\tif (!nslast) {\n\t\tnslast = nsnow;\n\t}\n\n\tflockfile(stdout);\n\tprintf(\"*** %lu.%09lu %12\" INT64_FMT \" %lu %s:%u: \",\n\t       (unsigned long)tsnow.tv_sec,\n\t       (unsigned long)tsnow.tv_nsec,\n\t       nsnow - nslast,\n\t       thread_id,\n\t       func,\n\t       line);\n\tva_start(args, fmt);\n\tvprintf(fmt, args);\n\tva_end(args);\n\tputchar('\\n');\n\tfflush(stdout);\n\tfunlockfile(stdout);\n\tnslast = nsnow;\n}\n#endif /* NEED_DEBUG_TRACE_FUNC */\n\n\n#define MD5_STATIC static\n#include \"md5.inl\"\n\n/* Darwin prior to 7.0 and Win32 do not have socklen_t */\n#if defined(NO_SOCKLEN_T)\ntypedef int socklen_t;\n#endif /* NO_SOCKLEN_T */\n\n#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */\n\n#if !defined(MSG_NOSIGNAL)\n#define MSG_NOSIGNAL (0)\n#endif\n\n\n#if defined(NO_SSL)\ntypedef struct SSL SSL; /* dummy for SSL argument to push/pull */\ntypedef struct SSL_CTX SSL_CTX;\n#else\n#if defined(NO_SSL_DL)\n#include <openssl/bn.h>\n#include <openssl/conf.h>\n#include <openssl/crypto.h>\n#include <openssl/dh.h>\n#include <openssl/engine.h>\n#include <openssl/err.h>\n#include <openssl/opensslv.h>\n#include <openssl/pem.h>\n#include <openssl/ssl.h>\n#include <openssl/tls1.h>\n#include <openssl/x509.h>\n\n#if defined(WOLFSSL_VERSION)\n/* Additional defines for WolfSSL, see\n * https://github.com/civetweb/civetweb/issues/583 */\n#include \"wolfssl_extras.inl\"\n#endif\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)\n/* If OpenSSL headers are included, automatically select the API version */\n#if !defined(OPENSSL_API_1_1)\n#define OPENSSL_API_1_1\n#endif\n#define OPENSSL_REMOVE_THREAD_STATE()\n#else\n#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL)\n#endif\n\n#else\n\n/* SSL loaded dynamically from DLL.\n * I put the prototypes here to be independent from OpenSSL source\n * installation. */\n\ntypedef struct ssl_st SSL;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct x509_store_ctx_st X509_STORE_CTX;\ntypedef struct x509_name X509_NAME;\ntypedef struct asn1_integer ASN1_INTEGER;\ntypedef struct bignum BIGNUM;\ntypedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;\ntypedef struct evp_md EVP_MD;\ntypedef struct x509 X509;\n\n\n#define SSL_CTRL_OPTIONS (32)\n#define SSL_CTRL_CLEAR_OPTIONS (77)\n#define SSL_CTRL_SET_ECDH_AUTO (94)\n\n#define OPENSSL_INIT_NO_LOAD_SSL_STRINGS 0x00100000L\n#define OPENSSL_INIT_LOAD_SSL_STRINGS 0x00200000L\n#define OPENSSL_INIT_LOAD_CRYPTO_STRINGS 0x00000002L\n\n#define SSL_VERIFY_NONE (0)\n#define SSL_VERIFY_PEER (1)\n#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT (2)\n#define SSL_VERIFY_CLIENT_ONCE (4)\n#define SSL_OP_ALL ((long)(0x80000BFFUL))\n#define SSL_OP_NO_SSLv2 (0x01000000L)\n#define SSL_OP_NO_SSLv3 (0x02000000L)\n#define SSL_OP_NO_TLSv1 (0x04000000L)\n#define SSL_OP_NO_TLSv1_2 (0x08000000L)\n#define SSL_OP_NO_TLSv1_1 (0x10000000L)\n#define SSL_OP_SINGLE_DH_USE (0x00100000L)\n#define SSL_OP_CIPHER_SERVER_PREFERENCE (0x00400000L)\n#define SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (0x00010000L)\n#define SSL_OP_NO_COMPRESSION (0x00020000L)\n\n#define SSL_CB_HANDSHAKE_START (0x10)\n#define SSL_CB_HANDSHAKE_DONE (0x20)\n\n#define SSL_ERROR_NONE (0)\n#define SSL_ERROR_SSL (1)\n#define SSL_ERROR_WANT_READ (2)\n#define SSL_ERROR_WANT_WRITE (3)\n#define SSL_ERROR_WANT_X509_LOOKUP (4)\n#define SSL_ERROR_SYSCALL (5) /* see errno */\n#define SSL_ERROR_ZERO_RETURN (6)\n#define SSL_ERROR_WANT_CONNECT (7)\n#define SSL_ERROR_WANT_ACCEPT (8)\n\n#define TLSEXT_TYPE_server_name (0)\n#define TLSEXT_NAMETYPE_host_name (0)\n#define SSL_TLSEXT_ERR_OK (0)\n#define SSL_TLSEXT_ERR_ALERT_WARNING (1)\n#define SSL_TLSEXT_ERR_ALERT_FATAL (2)\n#define SSL_TLSEXT_ERR_NOACK (3)\n\nstruct ssl_func {\n\tconst char *name;  /* SSL function name */\n\tvoid (*ptr)(void); /* Function pointer */\n};\n\n\n#if defined(OPENSSL_API_1_1)\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define TLS_server_method (*(SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define OPENSSL_init_ssl                                                       \\\n\t(*(int (*)(uint64_t opts,                                                  \\\n\t           const OPENSSL_INIT_SETTINGS *settings))ssl_sw[10]               \\\n\t      .ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[15].ptr)\n#define TLS_client_method (*(SSL_METHOD * (*)(void)) ssl_sw[16].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[17].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[18]      \\\n\t      .ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[19].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[20].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[21].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[22].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *)) ssl_sw[23].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[24].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *)) ssl_sw[25].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[26].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[27].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[28].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[29].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[30].ptr)\n#define SSL_CTX_set_options                                                    \\\n\t(*(unsigned long (*)(SSL_CTX *, unsigned long))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX * ctx, void (*callback)(const SSL *, int, int)))       \\\n\t      ssl_sw[32]                                                           \\\n\t          .ptr)\n#define SSL_get_ex_data (*(char *(*)(const SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *)) ssl_sw[37].ptr)\n#define SSL_ctrl (*(long (*)(SSL *, int, long, void *))ssl_sw[38].ptr)\n\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTRL_SET_TLSEXT_HOSTNAME 55\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n#define SSL_set_tlsext_host_name(ctx, arg)                                     \\\n\tSSL_ctrl(ctx, SSL_CTRL_SET_TLSEXT_HOSTNAME, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[0].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[1].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[2].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[3].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *)) crypto_sw[4].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *)) crypto_sw[5].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[6].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *)) crypto_sw[7].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[8].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[9]                                                         \\\n\t          .ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[10].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[11].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn)) crypto_sw[12].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[13].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[14].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n#define OPENSSL_REMOVE_THREAD_STATE()\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"TLS_server_method\", NULL},\n                                   {\"OPENSSL_init_ssl\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"TLS_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_options\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {\"SSL_ctrl\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#else\n\n#define SSL_free (*(void (*)(SSL *))ssl_sw[0].ptr)\n#define SSL_accept (*(int (*)(SSL *))ssl_sw[1].ptr)\n#define SSL_connect (*(int (*)(SSL *))ssl_sw[2].ptr)\n#define SSL_read (*(int (*)(SSL *, void *, int))ssl_sw[3].ptr)\n#define SSL_write (*(int (*)(SSL *, const void *, int))ssl_sw[4].ptr)\n#define SSL_get_error (*(int (*)(SSL *, int))ssl_sw[5].ptr)\n#define SSL_set_fd (*(int (*)(SSL *, SOCKET))ssl_sw[6].ptr)\n#define SSL_new (*(SSL * (*)(SSL_CTX *)) ssl_sw[7].ptr)\n#define SSL_CTX_new (*(SSL_CTX * (*)(SSL_METHOD *)) ssl_sw[8].ptr)\n#define SSLv23_server_method (*(SSL_METHOD * (*)(void)) ssl_sw[9].ptr)\n#define SSL_library_init (*(int (*)(void))ssl_sw[10].ptr)\n#define SSL_CTX_use_PrivateKey_file                                            \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[11].ptr)\n#define SSL_CTX_use_certificate_file                                           \\\n\t(*(int (*)(SSL_CTX *, const char *, int))ssl_sw[12].ptr)\n#define SSL_CTX_set_default_passwd_cb                                          \\\n\t(*(void (*)(SSL_CTX *, mg_callback_t))ssl_sw[13].ptr)\n#define SSL_CTX_free (*(void (*)(SSL_CTX *))ssl_sw[14].ptr)\n#define SSL_load_error_strings (*(void (*)(void))ssl_sw[15].ptr)\n#define SSL_CTX_use_certificate_chain_file                                     \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[16].ptr)\n#define SSLv23_client_method (*(SSL_METHOD * (*)(void)) ssl_sw[17].ptr)\n#define SSL_pending (*(int (*)(SSL *))ssl_sw[18].ptr)\n#define SSL_CTX_set_verify                                                     \\\n\t(*(void (*)(SSL_CTX *,                                                     \\\n\t            int,                                                           \\\n\t            int (*verify_callback)(int, X509_STORE_CTX *)))ssl_sw[19]      \\\n\t      .ptr)\n#define SSL_shutdown (*(int (*)(SSL *))ssl_sw[20].ptr)\n#define SSL_CTX_load_verify_locations                                          \\\n\t(*(int (*)(SSL_CTX *, const char *, const char *))ssl_sw[21].ptr)\n#define SSL_CTX_set_default_verify_paths (*(int (*)(SSL_CTX *))ssl_sw[22].ptr)\n#define SSL_CTX_set_verify_depth (*(void (*)(SSL_CTX *, int))ssl_sw[23].ptr)\n#define SSL_get_peer_certificate (*(X509 * (*)(SSL *)) ssl_sw[24].ptr)\n#define SSL_get_version (*(const char *(*)(SSL *))ssl_sw[25].ptr)\n#define SSL_get_current_cipher (*(SSL_CIPHER * (*)(SSL *)) ssl_sw[26].ptr)\n#define SSL_CIPHER_get_name                                                    \\\n\t(*(const char *(*)(const SSL_CIPHER *))ssl_sw[27].ptr)\n#define SSL_CTX_check_private_key (*(int (*)(SSL_CTX *))ssl_sw[28].ptr)\n#define SSL_CTX_set_session_id_context                                         \\\n\t(*(int (*)(SSL_CTX *, const unsigned char *, unsigned int))ssl_sw[29].ptr)\n#define SSL_CTX_ctrl (*(long (*)(SSL_CTX *, int, long, void *))ssl_sw[30].ptr)\n#define SSL_CTX_set_cipher_list                                                \\\n\t(*(int (*)(SSL_CTX *, const char *))ssl_sw[31].ptr)\n#define SSL_CTX_set_info_callback                                              \\\n\t(*(void (*)(SSL_CTX *, void (*callback)(const SSL *, int, int)))ssl_sw[32] \\\n\t      .ptr)\n#define SSL_get_ex_data (*(char *(*)(const SSL *, int))ssl_sw[33].ptr)\n#define SSL_set_ex_data (*(void (*)(SSL *, int, char *))ssl_sw[34].ptr)\n#define SSL_CTX_callback_ctrl                                                  \\\n\t(*(long (*)(SSL_CTX *, int, void (*)(void)))ssl_sw[35].ptr)\n#define SSL_get_servername                                                     \\\n\t(*(const char *(*)(const SSL *, int type))ssl_sw[36].ptr)\n#define SSL_set_SSL_CTX (*(SSL_CTX * (*)(SSL *, SSL_CTX *)) ssl_sw[37].ptr)\n#define SSL_ctrl (*(long (*)(SSL *, int, long, void *))ssl_sw[38].ptr)\n\n#define SSL_CTX_set_options(ctx, op)                                           \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_OPTIONS, (op), NULL)\n#define SSL_CTX_clear_options(ctx, op)                                         \\\n\tSSL_CTX_ctrl((ctx), SSL_CTRL_CLEAR_OPTIONS, (op), NULL)\n#define SSL_CTX_set_ecdh_auto(ctx, onoff)                                      \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_ECDH_AUTO, onoff, NULL)\n\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 53\n#define SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 54\n#define SSL_CTRL_SET_TLSEXT_HOSTNAME 55\n#define SSL_CTX_set_tlsext_servername_callback(ctx, cb)                        \\\n\tSSL_CTX_callback_ctrl(ctx,                                                 \\\n\t                      SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,                   \\\n\t                      (void (*)(void))cb)\n#define SSL_CTX_set_tlsext_servername_arg(ctx, arg)                            \\\n\tSSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, (void *)arg)\n#define SSL_set_tlsext_host_name(ctx, arg)                                     \\\n\tSSL_ctrl(ctx, SSL_CTRL_SET_TLSEXT_HOSTNAME, 0, (void *)arg)\n\n#define X509_get_notBefore(x) ((x)->cert_info->validity->notBefore)\n#define X509_get_notAfter(x) ((x)->cert_info->validity->notAfter)\n\n#define SSL_set_app_data(s, arg) (SSL_set_ex_data(s, 0, (char *)arg))\n#define SSL_get_app_data(s) (SSL_get_ex_data(s, 0))\n\n#define CRYPTO_num_locks (*(int (*)(void))crypto_sw[0].ptr)\n#define CRYPTO_set_locking_callback                                            \\\n\t(*(void (*)(void (*)(int, int, const char *, int)))crypto_sw[1].ptr)\n#define CRYPTO_set_id_callback                                                 \\\n\t(*(void (*)(unsigned long (*)(void)))crypto_sw[2].ptr)\n#define ERR_get_error (*(unsigned long (*)(void))crypto_sw[3].ptr)\n#define ERR_error_string (*(char *(*)(unsigned long, char *))crypto_sw[4].ptr)\n#define ERR_remove_state (*(void (*)(unsigned long))crypto_sw[5].ptr)\n#define ERR_free_strings (*(void (*)(void))crypto_sw[6].ptr)\n#define ENGINE_cleanup (*(void (*)(void))crypto_sw[7].ptr)\n#define CONF_modules_unload (*(void (*)(int))crypto_sw[8].ptr)\n#define CRYPTO_cleanup_all_ex_data (*(void (*)(void))crypto_sw[9].ptr)\n#define EVP_cleanup (*(void (*)(void))crypto_sw[10].ptr)\n#define X509_free (*(void (*)(X509 *))crypto_sw[11].ptr)\n#define X509_get_subject_name (*(X509_NAME * (*)(X509 *)) crypto_sw[12].ptr)\n#define X509_get_issuer_name (*(X509_NAME * (*)(X509 *)) crypto_sw[13].ptr)\n#define X509_NAME_oneline                                                      \\\n\t(*(char *(*)(X509_NAME *, char *, int))crypto_sw[14].ptr)\n#define X509_get_serialNumber (*(ASN1_INTEGER * (*)(X509 *)) crypto_sw[15].ptr)\n#define i2c_ASN1_INTEGER                                                       \\\n\t(*(int (*)(ASN1_INTEGER *, unsigned char **))crypto_sw[16].ptr)\n#define EVP_get_digestbyname                                                   \\\n\t(*(const EVP_MD *(*)(const char *))crypto_sw[17].ptr)\n#define EVP_Digest                                                             \\\n\t(*(int (*)(                                                                \\\n\t    const void *, size_t, void *, unsigned int *, const EVP_MD *, void *)) \\\n\t      crypto_sw[18]                                                        \\\n\t          .ptr)\n#define i2d_X509 (*(int (*)(X509 *, unsigned char **))crypto_sw[19].ptr)\n#define BN_bn2hex (*(char *(*)(const BIGNUM *a))crypto_sw[20].ptr)\n#define ASN1_INTEGER_to_BN                                                     \\\n\t(*(BIGNUM * (*)(const ASN1_INTEGER *ai, BIGNUM *bn)) crypto_sw[21].ptr)\n#define BN_free (*(void (*)(const BIGNUM *a))crypto_sw[22].ptr)\n#define CRYPTO_free (*(void (*)(void *addr))crypto_sw[23].ptr)\n\n#define OPENSSL_free(a) CRYPTO_free(a)\n\n/* use here ERR_remove_state,\n * while on some platforms function is not included into library due to\n * deprication */\n#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_state(0)\n\n/* init_ssl_ctx() function updates this array.\n * It loads SSL library dynamically and changes NULLs to the actual addresses\n * of respective functions. The macros above (like SSL_connect()) are really\n * just calling these functions indirectly via the pointer. */\nstatic struct ssl_func ssl_sw[] = {{\"SSL_free\", NULL},\n                                   {\"SSL_accept\", NULL},\n                                   {\"SSL_connect\", NULL},\n                                   {\"SSL_read\", NULL},\n                                   {\"SSL_write\", NULL},\n                                   {\"SSL_get_error\", NULL},\n                                   {\"SSL_set_fd\", NULL},\n                                   {\"SSL_new\", NULL},\n                                   {\"SSL_CTX_new\", NULL},\n                                   {\"SSLv23_server_method\", NULL},\n                                   {\"SSL_library_init\", NULL},\n                                   {\"SSL_CTX_use_PrivateKey_file\", NULL},\n                                   {\"SSL_CTX_use_certificate_file\", NULL},\n                                   {\"SSL_CTX_set_default_passwd_cb\", NULL},\n                                   {\"SSL_CTX_free\", NULL},\n                                   {\"SSL_load_error_strings\", NULL},\n                                   {\"SSL_CTX_use_certificate_chain_file\", NULL},\n                                   {\"SSLv23_client_method\", NULL},\n                                   {\"SSL_pending\", NULL},\n                                   {\"SSL_CTX_set_verify\", NULL},\n                                   {\"SSL_shutdown\", NULL},\n                                   {\"SSL_CTX_load_verify_locations\", NULL},\n                                   {\"SSL_CTX_set_default_verify_paths\", NULL},\n                                   {\"SSL_CTX_set_verify_depth\", NULL},\n                                   {\"SSL_get_peer_certificate\", NULL},\n                                   {\"SSL_get_version\", NULL},\n                                   {\"SSL_get_current_cipher\", NULL},\n                                   {\"SSL_CIPHER_get_name\", NULL},\n                                   {\"SSL_CTX_check_private_key\", NULL},\n                                   {\"SSL_CTX_set_session_id_context\", NULL},\n                                   {\"SSL_CTX_ctrl\", NULL},\n                                   {\"SSL_CTX_set_cipher_list\", NULL},\n                                   {\"SSL_CTX_set_info_callback\", NULL},\n                                   {\"SSL_get_ex_data\", NULL},\n                                   {\"SSL_set_ex_data\", NULL},\n                                   {\"SSL_CTX_callback_ctrl\", NULL},\n                                   {\"SSL_get_servername\", NULL},\n                                   {\"SSL_set_SSL_CTX\", NULL},\n                                   {\"SSL_ctrl\", NULL},\n                                   {NULL, NULL}};\n\n\n/* Similar array as ssl_sw. These functions could be located in different\n * lib. */\nstatic struct ssl_func crypto_sw[] = {{\"CRYPTO_num_locks\", NULL},\n                                      {\"CRYPTO_set_locking_callback\", NULL},\n                                      {\"CRYPTO_set_id_callback\", NULL},\n                                      {\"ERR_get_error\", NULL},\n                                      {\"ERR_error_string\", NULL},\n                                      {\"ERR_remove_state\", NULL},\n                                      {\"ERR_free_strings\", NULL},\n                                      {\"ENGINE_cleanup\", NULL},\n                                      {\"CONF_modules_unload\", NULL},\n                                      {\"CRYPTO_cleanup_all_ex_data\", NULL},\n                                      {\"EVP_cleanup\", NULL},\n                                      {\"X509_free\", NULL},\n                                      {\"X509_get_subject_name\", NULL},\n                                      {\"X509_get_issuer_name\", NULL},\n                                      {\"X509_NAME_oneline\", NULL},\n                                      {\"X509_get_serialNumber\", NULL},\n                                      {\"i2c_ASN1_INTEGER\", NULL},\n                                      {\"EVP_get_digestbyname\", NULL},\n                                      {\"EVP_Digest\", NULL},\n                                      {\"i2d_X509\", NULL},\n                                      {\"BN_bn2hex\", NULL},\n                                      {\"ASN1_INTEGER_to_BN\", NULL},\n                                      {\"BN_free\", NULL},\n                                      {\"CRYPTO_free\", NULL},\n                                      {NULL, NULL}};\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL_DL */\n#endif /* NO_SSL */\n\n\n#if !defined(NO_CACHING)\nstatic const char *month_names[] = {\"Jan\",\n                                    \"Feb\",\n                                    \"Mar\",\n                                    \"Apr\",\n                                    \"May\",\n                                    \"Jun\",\n                                    \"Jul\",\n                                    \"Aug\",\n                                    \"Sep\",\n                                    \"Oct\",\n                                    \"Nov\",\n                                    \"Dec\"};\n#endif /* !NO_CACHING */\n\n/* Unified socket address. For IPv6 support, add IPv6 address structure in\n * the\n * union u. */\nunion usa {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in sin;\n#if defined(USE_IPV6)\n\tstruct sockaddr_in6 sin6;\n#endif\n};\n\n/* Describes a string (chunk of memory). */\nstruct vec {\n\tconst char *ptr;\n\tsize_t len;\n};\n\nstruct mg_file_stat {\n\t/* File properties filled by mg_stat: */\n\tuint64_t size;\n\ttime_t last_modified;\n\tint is_directory; /* Set to 1 if mg_stat is called for a directory */\n\tint is_gzipped;   /* Set to 1 if the content is gzipped, in which\n\t                   * case we need a \"Content-Eencoding: gzip\" header */\n\tint location;     /* 0 = nowhere, 1 = on disk, 2 = in memory */\n};\n\nstruct mg_file_in_memory {\n\tchar *p;\n\tuint32_t pos;\n\tchar mode;\n};\n\nstruct mg_file_access {\n\t/* File properties filled by mg_fopen: */\n\tFILE *fp;\n#if defined(MG_USE_OPEN_FILE)\n\t/* TODO (low): Remove obsolete \"file in memory\" implementation.\n\t * In an \"early 2017\" discussion at Google groups\n\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t * we decided to get rid of this feature (after some fade-out\n\t * phase). */\n\tconst char *membuf;\n#endif\n};\n\nstruct mg_file {\n\tstruct mg_file_stat stat;\n\tstruct mg_file_access access;\n};\n\n#if defined(MG_USE_OPEN_FILE)\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{(uint64_t)0, (time_t)0, 0, 0, 0},                                     \\\n\t\t{                                                                      \\\n\t\t\t(FILE *)NULL, (const char *)NULL                                   \\\n\t\t}                                                                      \\\n\t}\n\n#else\n\n#define STRUCT_FILE_INITIALIZER                                                \\\n\t{                                                                          \\\n\t\t{(uint64_t)0, (time_t)0, 0, 0, 0},                                     \\\n\t\t{                                                                      \\\n\t\t\t(FILE *)NULL                                                       \\\n\t\t}                                                                      \\\n\t}\n\n#endif\n\n\n/* Describes listening socket, or socket which was accept()-ed by the master\n * thread and queued for future handling by the worker thread. */\nstruct socket {\n\tSOCKET sock;             /* Listening socket */\n\tunion usa lsa;           /* Local socket address */\n\tunion usa rsa;           /* Remote socket address */\n\tunsigned char is_ssl;    /* Is port SSL-ed */\n\tunsigned char ssl_redir; /* Is port supposed to redirect everything to SSL\n\t                          * port */\n\tunsigned char in_use;    /* Is valid */\n};\n\n\n/* Enum const for all options must be in sync with\n * static struct mg_option config_options[]\n * This is tested in the unit test (test/private.c)\n * \"Private Config Options\"\n */\nenum {\n\t/* Once for each server */\n\tLISTENING_PORTS,\n\tNUM_THREADS,\n\tRUN_AS_USER,\n\tCONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the\n\t                     * socket option typedef TCP_NODELAY. */\n\tMAX_REQUEST_SIZE,\n\tLINGER_TIMEOUT,\n#if defined(__linux__)\n\tALLOW_SENDFILE_CALL,\n#endif\n#if defined(_WIN32)\n\tCASE_SENSITIVE_FILES,\n#endif\n\tTHROTTLE,\n\tACCESS_LOG_FILE,\n\tERROR_LOG_FILE,\n\tENABLE_KEEP_ALIVE,\n\tREQUEST_TIMEOUT,\n\tKEEP_ALIVE_TIMEOUT,\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_TIMEOUT,\n\tENABLE_WEBSOCKET_PING_PONG,\n#endif\n\tDECODE_URL,\n#if defined(USE_LUA)\n\tLUA_BACKGROUND_SCRIPT,\n\tLUA_BACKGROUND_SCRIPT_PARAMS,\n#endif\n#if defined(USE_TIMERS)\n\tCGI_TIMEOUT,\n#endif\n\n\t/* Once for each domain */\n\tDOCUMENT_ROOT,\n\tCGI_EXTENSIONS,\n\tCGI_ENVIRONMENT,\n\tPUT_DELETE_PASSWORDS_FILE,\n\tCGI_INTERPRETER,\n\tPROTECT_URI,\n\tAUTHENTICATION_DOMAIN,\n\tENABLE_AUTH_DOMAIN_CHECK,\n\tSSI_EXTENSIONS,\n\tENABLE_DIRECTORY_LISTING,\n\tGLOBAL_PASSWORDS_FILE,\n\tINDEX_FILES,\n\tACCESS_CONTROL_LIST,\n\tEXTRA_MIME_TYPES,\n\tSSL_CERTIFICATE,\n\tSSL_CERTIFICATE_CHAIN,\n\tURL_REWRITE_PATTERN,\n\tHIDE_FILES,\n\tSSL_DO_VERIFY_PEER,\n\tSSL_CA_PATH,\n\tSSL_CA_FILE,\n\tSSL_VERIFY_DEPTH,\n\tSSL_DEFAULT_VERIFY_PATHS,\n\tSSL_CIPHER_LIST,\n\tSSL_PROTOCOL_VERSION,\n\tSSL_SHORT_TRUST,\n\n#if defined(USE_LUA)\n\tLUA_PRELOAD_FILE,\n\tLUA_SCRIPT_EXTENSIONS,\n\tLUA_SERVER_PAGE_EXTENSIONS,\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\tLUA_DEBUG_PARAMS,\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n\tDUKTAPE_SCRIPT_EXTENSIONS,\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tWEBSOCKET_ROOT,\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tLUA_WEBSOCKET_EXTENSIONS,\n#endif\n\n\tACCESS_CONTROL_ALLOW_ORIGIN,\n\tACCESS_CONTROL_ALLOW_METHODS,\n\tACCESS_CONTROL_ALLOW_HEADERS,\n\tERROR_PAGES,\n#if !defined(NO_CACHING)\n\tSTATIC_FILE_MAX_AGE,\n#endif\n#if !defined(NO_SSL)\n\tSTRICT_HTTPS_MAX_AGE,\n#endif\n\tADDITIONAL_HEADER,\n\tALLOW_INDEX_SCRIPT_SUB_RES,\n\n\tNUM_OPTIONS\n};\n\n\n/* Config option name, config types, default value.\n * Must be in the same order as the enum const above.\n */\nstatic const struct mg_option config_options[] = {\n\n    /* Once for each server */\n    {\"listening_ports\", MG_CONFIG_TYPE_STRING_LIST, \"8080\"},\n    {\"num_threads\", MG_CONFIG_TYPE_NUMBER, \"50\"},\n    {\"run_as_user\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"tcp_nodelay\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"max_request_size\", MG_CONFIG_TYPE_NUMBER, \"16384\"},\n    {\"linger_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#if defined(__linux__)\n    {\"allow_sendfile_call\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#endif\n#if defined(_WIN32)\n    {\"case_sensitive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"throttle\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"access_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"error_log_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"enable_keep_alive\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n    {\"request_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"30000\"},\n    {\"keep_alive_timeout_ms\", MG_CONFIG_TYPE_NUMBER, \"500\"},\n#if defined(USE_WEBSOCKET)\n    {\"websocket_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n    {\"enable_websocket_ping_pong\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n#endif\n    {\"decode_url\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n#if defined(USE_LUA)\n    {\"lua_background_script\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_background_script_params\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n#endif\n#if defined(USE_TIMERS)\n    {\"cgi_timeout_ms\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n\n    /* Once for each domain */\n    {\"document_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"cgi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.cgi$|**.pl$|**.php$\"},\n    {\"cgi_environment\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"put_delete_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"cgi_interpreter\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"protect_uri\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"authentication_domain\", MG_CONFIG_TYPE_STRING, \"mydomain.com\"},\n    {\"enable_auth_domain_check\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssi_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.shtml$|**.shtm$\"},\n    {\"enable_directory_listing\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"global_auth_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"index_files\",\n     MG_CONFIG_TYPE_STRING_LIST,\n#if defined(USE_LUA)\n     \"index.xhtml,index.html,index.htm,\"\n     \"index.lp,index.lsp,index.lua,index.cgi,\"\n     \"index.shtml,index.php\"},\n#else\n     \"index.xhtml,index.html,index.htm,index.cgi,index.shtml,index.php\"},\n#endif\n    {\"access_control_list\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"extra_mime_types\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"ssl_certificate\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_certificate_chain\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"url_rewrite_patterns\", MG_CONFIG_TYPE_STRING_LIST, NULL},\n    {\"hide_files_patterns\", MG_CONFIG_TYPE_EXT_PATTERN, NULL},\n\n    {\"ssl_verify_peer\", MG_CONFIG_TYPE_YES_NO_OPTIONAL, \"no\"},\n\n    {\"ssl_ca_path\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n    {\"ssl_ca_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"ssl_verify_depth\", MG_CONFIG_TYPE_NUMBER, \"9\"},\n    {\"ssl_default_verify_paths\", MG_CONFIG_TYPE_BOOLEAN, \"yes\"},\n    {\"ssl_cipher_list\", MG_CONFIG_TYPE_STRING, NULL},\n    {\"ssl_protocol_version\", MG_CONFIG_TYPE_NUMBER, \"0\"},\n    {\"ssl_short_trust\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n#if defined(USE_LUA)\n    {\"lua_preload_file\", MG_CONFIG_TYPE_FILE, NULL},\n    {\"lua_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n    {\"lua_server_page_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lp$|**.lsp$\"},\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n    {\"lua_debug\", MG_CONFIG_TYPE_STRING, NULL},\n#endif\n#endif\n#if defined(USE_DUKTAPE)\n    /* The support for duktape is still in alpha version state.\n     * The name of this config option might change. */\n    {\"duktape_script_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.ssjs$\"},\n#endif\n\n#if defined(USE_WEBSOCKET)\n    {\"websocket_root\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#endif\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n    {\"lua_websocket_pattern\", MG_CONFIG_TYPE_EXT_PATTERN, \"**.lua$\"},\n#endif\n    {\"access_control_allow_origin\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_methods\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"access_control_allow_headers\", MG_CONFIG_TYPE_STRING, \"*\"},\n    {\"error_pages\", MG_CONFIG_TYPE_DIRECTORY, NULL},\n#if !defined(NO_CACHING)\n    {\"static_file_max_age\", MG_CONFIG_TYPE_NUMBER, \"3600\"},\n#endif\n#if !defined(NO_SSL)\n    {\"strict_transport_security_max_age\", MG_CONFIG_TYPE_NUMBER, NULL},\n#endif\n    {\"additional_header\", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},\n    {\"allow_index_script_resource\", MG_CONFIG_TYPE_BOOLEAN, \"no\"},\n\n    {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};\n\n\n/* Check if the config_options and the corresponding enum have compatible\n * sizes. */\nmg_static_assert((sizeof(config_options) / sizeof(config_options[0]))\n                     == (NUM_OPTIONS + 1),\n                 \"config_options and enum not sync\");\n\n\nenum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };\n\n\nstruct mg_handler_info {\n\t/* Name/Pattern of the URI. */\n\tchar *uri;\n\tsize_t uri_len;\n\n\t/* handler type */\n\tint handler_type;\n\n\t/* Handler for http/https or authorization requests. */\n\tmg_request_handler handler;\n\tunsigned int refcount;\n\tpthread_mutex_t refcount_mutex; /* Protects refcount */\n\tpthread_cond_t\n\t    refcount_cond; /* Signaled when handler refcount is decremented */\n\n\t/* Handler for ws/wss (websocket) requests. */\n\tmg_websocket_connect_handler connect_handler;\n\tmg_websocket_ready_handler ready_handler;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\n\t/* accepted subprotocols for ws/wss requests. */\n\tstruct mg_websocket_subprotocols *subprotocols;\n\n\t/* Handler for authorization requests */\n\tmg_authorization_handler auth_handler;\n\n\t/* User supplied argument for the handler function. */\n\tvoid *cbdata;\n\n\t/* next handler in a linked list */\n\tstruct mg_handler_info *next;\n};\n\n\nenum {\n\tCONTEXT_INVALID,\n\tCONTEXT_SERVER,\n\tCONTEXT_HTTP_CLIENT,\n\tCONTEXT_WS_CLIENT\n};\n\n\nstruct mg_domain_context {\n\tSSL_CTX *ssl_ctx;                 /* SSL context */\n\tchar *config[NUM_OPTIONS];        /* Civetweb configuration parameters */\n\tstruct mg_handler_info *handlers; /* linked list of uri handlers */\n\n\t/* Server nonce */\n\tuint64_t auth_nonce_mask;  /* Mask for all nonce values */\n\tunsigned long nonce_count; /* Used nonces, used for authentication */\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\t/* linked list of shared lua websockets */\n\tstruct mg_shared_lua_websocket_list *shared_lua_websockets;\n#endif\n\n\t/* Linked list of domains */\n\tstruct mg_domain_context *next;\n};\n\n\nstruct mg_context {\n\n\t/* Part 1 - Physical context:\n\t * This holds threads, ports, timeouts, ...\n\t * set for the entire server, independent from the\n\t * addressed hostname.\n\t */\n\n\t/* Connection related */\n\tint context_type; /* See CONTEXT_* above */\n\n\tstruct socket *listening_sockets;\n\tstruct pollfd *listening_socket_fds;\n\tunsigned int num_listening_sockets;\n\n\tstruct mg_connection *worker_connections; /* The connection struct, pre-\n\t                                           * allocated for each worker */\n\n#if defined(USE_SERVER_STATS)\n\tint active_connections;\n\tint max_connections;\n\tint64_t total_connections;\n\tint64_t total_requests;\n\tint64_t total_data_read;\n\tint64_t total_data_written;\n#endif\n\n\t/* Thread related */\n\tvolatile int stop_flag;       /* Should we stop event loop */\n\tpthread_mutex_t thread_mutex; /* Protects (max|num)_threads */\n\n\tpthread_t masterthreadid; /* The master thread ID */\n\tunsigned int\n\t    cfg_worker_threads;      /* The number of configured worker threads. */\n\tpthread_t *worker_threadids; /* The worker thread IDs */\n\n/* Connection to thread dispatching */\n#if defined(ALTERNATIVE_QUEUE)\n\tstruct socket *client_socks;\n\tvoid **client_wait_events;\n#else\n\tstruct socket queue[MGSQLEN]; /* Accepted sockets */\n\tvolatile int sq_head;         /* Head of the socket queue */\n\tvolatile int sq_tail;         /* Tail of the socket queue */\n\tpthread_cond_t sq_full;       /* Signaled when socket is produced */\n\tpthread_cond_t sq_empty;      /* Signaled when socket is consumed */\n#endif\n\n\t/* Memory related */\n\tunsigned int max_request_size; /* The max request size */\n\n#if defined(USE_SERVER_STATS)\n\tstruct mg_memory_stat ctx_memory;\n#endif\n\n\t/* Operating system related */\n\tchar *systemName;  /* What operating system is running */\n\ttime_t start_time; /* Server start time, used for authentication\n\t                    * and for diagnstics. */\n\n#if defined(USE_TIMERS)\n\tstruct ttimers *timers;\n#endif\n\n/* Lua specific: Background operations and shared websockets */\n#if defined(USE_LUA)\n\tvoid *lua_background_state;\n#endif\n\n\t/* Server nonce */\n\tpthread_mutex_t nonce_mutex; /* Protects nonce_count */\n\n\t/* Server callbacks */\n\tstruct mg_callbacks callbacks; /* User-defined callback function */\n\tvoid *user_data;               /* User-defined data */\n\n\t/* Part 2 - Logical domain:\n\t * This holds hostname, TLS certificate, document root, ...\n\t * set for a domain hosted at the server.\n\t * There may be multiple domains hosted at one physical server.\n\t * The default domain \"dd\" is the first element of a list of\n\t * domains.\n\t */\n\tstruct mg_domain_context dd; /* default domain */\n};\n\n\n#if defined(USE_SERVER_STATS)\nstatic struct mg_memory_stat mg_common_memory = {0, 0, 0};\n\nstatic struct mg_memory_stat *\nget_memory_stat(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\treturn &(ctx->ctx_memory);\n\t}\n\treturn &mg_common_memory;\n}\n#endif\n\nenum {\n\tCONNECTION_TYPE_INVALID,\n\tCONNECTION_TYPE_REQUEST,\n\tCONNECTION_TYPE_RESPONSE\n};\n\nstruct mg_connection {\n\tint connection_type; /* see CONNECTION_TYPE_* above */\n\n\tstruct mg_request_info request_info;\n\tstruct mg_response_info response_info;\n\n\tstruct mg_context *phys_ctx;\n\tstruct mg_domain_context *dom_ctx;\n\n#if defined(USE_SERVER_STATS)\n\tint conn_state; /* 0 = undef, numerical value may change in different\n\t                 * versions. For the current definition, see\n\t                 * mg_get_connection_info_impl */\n#endif\n\n\tconst char *host;         /* Host (HTTP/1.1 header or SNI) */\n\tSSL *ssl;                 /* SSL descriptor */\n\tSSL_CTX *client_ssl_ctx;  /* SSL context for client connections */\n\tstruct socket client;     /* Connected client */\n\ttime_t conn_birth_time;   /* Time (wall clock) when connection was\n\t                           * established */\n\tstruct timespec req_time; /* Time (since system start) when the request\n\t                           * was received */\n\tint64_t num_bytes_sent;   /* Total bytes sent to client */\n\tint64_t content_len;      /* Content-Length header value */\n\tint64_t consumed_content; /* How many bytes of content have been read */\n\tint is_chunked;           /* Transfer-Encoding is chunked:\n\t                           * 0 = not chunked,\n\t                           * 1 = chunked, do data read yet,\n\t                           * 2 = chunked, some data read,\n\t                           * 3 = chunked, all data read\n\t                           */\n\tsize_t chunk_remainder;   /* Unread data from the last chunk */\n\tchar *buf;                /* Buffer for received data */\n\tchar *path_info;          /* PATH_INFO part of the URL */\n\n\tint must_close;       /* 1 if connection must be closed */\n\tint accept_gzip;      /* 1 if gzip encoding is accepted */\n\tint in_error_handler; /* 1 if in handler for user defined error\n\t                       * pages */\n#if defined(USE_WEBSOCKET)\n\tint in_websocket_handling; /* 1 if in read_websocket */\n#endif\n\tint handled_requests; /* Number of requests handled by this connection\n\t                       */\n\tint buf_size;         /* Buffer size */\n\tint request_len;      /* Size of the request + headers in a buffer */\n\tint data_len;         /* Total size of data in a buffer */\n\tint status_code;      /* HTTP reply status code, e.g. 200 */\n\tint throttle;         /* Throttling, bytes/sec. <= 0 means no\n\t                       * throttle */\n\n\ttime_t last_throttle_time;   /* Last time throttled data was sent */\n\tint64_t last_throttle_bytes; /* Bytes sent this second */\n\tpthread_mutex_t mutex;       /* Used by mg_(un)lock_connection to ensure\n\t                              * atomic transmissions for websockets */\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tvoid *lua_websocket_state; /* Lua_State for a websocket connection */\n#endif\n\n\tint thread_index; /* Thread index within ctx */\n};\n\n\n/* Directory entry */\nstruct de {\n\tstruct mg_connection *conn;\n\tchar *file_name;\n\tstruct mg_file_stat file;\n};\n\n\n#if defined(USE_WEBSOCKET)\nstatic int is_websocket_protocol(const struct mg_connection *conn);\n#else\n#define is_websocket_protocol(conn) (0)\n#endif\n\n\n#define mg_cry_internal(conn, fmt, ...)                                        \\\n\tmg_cry_internal_wrap(conn, __func__, __LINE__, fmt, __VA_ARGS__)\n\nstatic void mg_cry_internal_wrap(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 ...) PRINTF_ARGS(4, 5);\n\n\n#if !defined(NO_THREAD_NAME)\n#if defined(_WIN32) && defined(_MSC_VER)\n/* Set the thread name for debugging purposes in Visual Studio\n * http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n */\n#pragma pack(push, 8)\ntypedef struct tagTHREADNAME_INFO {\n\tDWORD dwType;     /* Must be 0x1000. */\n\tLPCSTR szName;    /* Pointer to name (in user addr space). */\n\tDWORD dwThreadID; /* Thread ID (-1=caller thread). */\n\tDWORD dwFlags;    /* Reserved for future use, must be zero. */\n} THREADNAME_INFO;\n#pragma pack(pop)\n\n#elif defined(__linux__)\n\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#if defined(ALTERNATIVE_QUEUE)\n#include <sys/eventfd.h>\n#endif /* ALTERNATIVE_QUEUE */\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void *\nevent_create(void)\n{\n\tint evhdl = eventfd(0, EFD_CLOEXEC);\n\tint *ret;\n\n\tif (evhdl == -1) {\n\t\t/* Linux uses -1 on error, Windows NULL. */\n\t\t/* However, Linux does not return 0 on success either. */\n\t\treturn 0;\n\t}\n\n\tret = (int *)mg_malloc(sizeof(int));\n\tif (ret) {\n\t\t*ret = evhdl;\n\t} else {\n\t\t(void)close(evhdl);\n\t}\n\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tuint64_t u;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)read(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\t(void)u; /* the value is not required */\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tuint64_t u = 1;\n\tint evhdl, s;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\ts = (int)write(evhdl, &u, sizeof(u));\n\tif (s != sizeof(u)) {\n\t\t/* error */\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tint evhdl;\n\n\tif (!eventhdl) {\n\t\t/* error */\n\t\treturn;\n\t}\n\tevhdl = *(int *)eventhdl;\n\n\tclose(evhdl);\n\tmg_free(eventhdl);\n}\n\n\n#endif\n\n#endif\n\n\n#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE)\n\nstruct posix_event {\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n};\n\n\nstatic void *\nevent_create(void)\n{\n\tstruct posix_event *ret = mg_malloc(sizeof(struct posix_event));\n\tif (ret == 0) {\n\t\t/* out of memory */\n\t\treturn 0;\n\t}\n\tif (0 != pthread_mutex_init(&(ret->mutex), NULL)) {\n\t\t/* pthread mutex not available */\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\tif (0 != pthread_cond_init(&(ret->cond), NULL)) {\n\t\t/* pthread cond not available */\n\t\tpthread_mutex_destroy(&(ret->mutex));\n\t\tmg_free(ret);\n\t\treturn 0;\n\t}\n\treturn (void *)ret;\n}\n\n\nstatic int\nevent_wait(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_wait(&(ev->cond), &(ev->mutex));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic int\nevent_signal(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_mutex_lock(&(ev->mutex));\n\tpthread_cond_signal(&(ev->cond));\n\tpthread_mutex_unlock(&(ev->mutex));\n\treturn 1;\n}\n\n\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tstruct posix_event *ev = (struct posix_event *)eventhdl;\n\tpthread_cond_destroy(&(ev->cond));\n\tpthread_mutex_destroy(&(ev->mutex));\n\tmg_free(ev);\n}\n#endif\n\n\nstatic void\nmg_set_thread_name(const char *name)\n{\n\tchar threadName[16 + 1]; /* 16 = Max. thread length in Linux/OSX/.. */\n\n\tmg_snprintf(\n\t    NULL, NULL, threadName, sizeof(threadName), \"civetweb-%s\", name);\n\n#if defined(_WIN32)\n#if defined(_MSC_VER)\n\t/* Windows and Visual Studio Compiler */\n\t__try {\n\t\tTHREADNAME_INFO info;\n\t\tinfo.dwType = 0x1000;\n\t\tinfo.szName = threadName;\n\t\tinfo.dwThreadID = ~0U;\n\t\tinfo.dwFlags = 0;\n\n\t\tRaiseException(0x406D1388,\n\t\t               0,\n\t\t               sizeof(info) / sizeof(ULONG_PTR),\n\t\t               (ULONG_PTR *)&info);\n\t} __except (EXCEPTION_EXECUTE_HANDLER) {\n\t}\n#elif defined(__MINGW32__)\n/* No option known to set thread name for MinGW */\n#endif\n#elif defined(_GNU_SOURCE) && defined(__GLIBC__)                               \\\n    && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 12)))\n/* pthread_setname_np first appeared in glibc in version 2.12*/\n#if defined(__MACH__)\n\t/* OS X only current thread name can be changed */\n\t(void)pthread_setname_np(threadName);\n#else\n\t(void)pthread_setname_np(pthread_self(), threadName);\n#endif\n#elif defined(__linux__)\n\t/* on linux we can use the old prctl function */\n\t(void)prctl(PR_SET_NAME, threadName, 0, 0, 0);\n#endif\n}\n#else /* !defined(NO_THREAD_NAME) */\nvoid\nmg_set_thread_name(const char *threadName)\n{\n}\n#endif\n\n\n#if defined(MG_LEGACY_INTERFACE)\nconst char **\nmg_get_valid_option_names(void)\n{\n\t/* This function is deprecated. Use mg_get_valid_options instead. */\n\tstatic const char\n\t    *data[2 * sizeof(config_options) / sizeof(config_options[0])] = {0};\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdata[i * 2] = config_options[i].name;\n\t\tdata[i * 2 + 1] = config_options[i].default_value;\n\t}\n\n\treturn data;\n}\n#endif\n\n\nconst struct mg_option *\nmg_get_valid_options(void)\n{\n\treturn config_options;\n}\n\n\n/* Do not open file (used in is_file_in_memory) */\n#define MG_FOPEN_MODE_NONE (0)\n\n/* Open file for read only access */\n#define MG_FOPEN_MODE_READ (1)\n\n/* Open file for writing, create and overwrite */\n#define MG_FOPEN_MODE_WRITE (2)\n\n/* Open file for writing, create and append */\n#define MG_FOPEN_MODE_APPEND (4)\n\n\n/* If a file is in memory, set all \"stat\" members and the membuf pointer of\n * output filep and return 1, otherwise return 0 and don't modify anything.\n */\nstatic int\nopen_file_in_memory(const struct mg_connection *conn,\n                    const char *path,\n                    struct mg_file *filep,\n                    int mode)\n{\n#if defined(MG_USE_OPEN_FILE)\n\n\tsize_t size = 0;\n\tconst char *buf = NULL;\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tif ((mode != MG_FOPEN_MODE_NONE) && (mode != MG_FOPEN_MODE_READ)) {\n\t\treturn 0;\n\t}\n\n\tif (conn->phys_ctx->callbacks.open_file) {\n\t\tbuf = conn->phys_ctx->callbacks.open_file(conn, path, &size);\n\t\tif (buf != NULL) {\n\t\t\tif (filep == NULL) {\n\t\t\t\t/* This is a file in memory, but we cannot store the\n\t\t\t\t * properties\n\t\t\t\t * now.\n\t\t\t\t * Called from \"is_file_in_memory\" function. */\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* NOTE: override filep->size only on success. Otherwise, it\n\t\t\t * might\n\t\t\t * break constructs like if (!mg_stat() || !mg_fopen()) ... */\n\t\t\tfilep->access.membuf = buf;\n\t\t\tfilep->access.fp = NULL;\n\n\t\t\t/* Size was set by the callback */\n\t\t\tfilep->stat.size = size;\n\n\t\t\t/* Assume the data may change during runtime by setting\n\t\t\t * last_modified = now */\n\t\t\tfilep->stat.last_modified = time(NULL);\n\n\t\t\tfilep->stat.is_directory = 0;\n\t\t\tfilep->stat.is_gzipped = 0;\n\t\t}\n\t}\n\n\treturn (buf != NULL);\n\n#else\n\t(void)conn;\n\t(void)path;\n\t(void)filep;\n\t(void)mode;\n\n\treturn 0;\n\n#endif\n}\n\n\nstatic int\nis_file_in_memory(const struct mg_connection *conn, const char *path)\n{\n\treturn open_file_in_memory(conn, path, NULL, MG_FOPEN_MODE_NONE);\n}\n\n\nstatic int\nis_file_opened(const struct mg_file_access *fileacc)\n{\n\tif (!fileacc) {\n\t\treturn 0;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\treturn (fileacc->membuf != NULL) || (fileacc->fp != NULL);\n#else\n\treturn (fileacc->fp != NULL);\n#endif\n}\n\n\nstatic int mg_stat(const struct mg_connection *conn,\n                   const char *path,\n                   struct mg_file_stat *filep);\n\n\n/* mg_fopen will open a file either in memory or on the disk.\n * The input parameter path is a string in UTF-8 encoding.\n * The input parameter mode is MG_FOPEN_MODE_*\n * On success, either fp or membuf will be set in the output\n * struct file. All status members will also be set.\n * The function returns 1 on success, 0 on error. */\nstatic int\nmg_fopen(const struct mg_connection *conn,\n         const char *path,\n         int mode,\n         struct mg_file *filep)\n{\n\tint found;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tfilep->access.fp = NULL;\n#if defined(MG_USE_OPEN_FILE)\n\tfilep->access.membuf = NULL;\n#endif\n\n\tif (!is_file_in_memory(conn, path)) {\n\n\t\t/* filep is initialized in mg_stat: all fields with memset to,\n\t\t * some fields like size and modification date with values */\n\t\tfound = mg_stat(conn, path, &(filep->stat));\n\n\t\tif ((mode == MG_FOPEN_MODE_READ) && (!found)) {\n\t\t\t/* file does not exist and will not be created */\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\t{\n\t\t\twchar_t wbuf[W_PATH_MAX];\n\t\t\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\t\t\tswitch (mode) {\n\t\t\tcase MG_FOPEN_MODE_READ:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"rb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"wb\");\n\t\t\t\tbreak;\n\t\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\t\tfilep->access.fp = _wfopen(wbuf, L\"ab\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\t/* Linux et al already use unicode. No need to convert. */\n\t\tswitch (mode) {\n\t\tcase MG_FOPEN_MODE_READ:\n\t\t\tfilep->access.fp = fopen(path, \"r\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_WRITE:\n\t\t\tfilep->access.fp = fopen(path, \"w\");\n\t\t\tbreak;\n\t\tcase MG_FOPEN_MODE_APPEND:\n\t\t\tfilep->access.fp = fopen(path, \"a\");\n\t\t\tbreak;\n\t\t}\n\n#endif\n\t\tif (!found) {\n\t\t\t/* File did not exist before fopen was called.\n\t\t\t * Maybe it has been created now. Get stat info\n\t\t\t * like creation time now. */\n\t\t\tfound = mg_stat(conn, path, &(filep->stat));\n\t\t\t(void)found;\n\t\t}\n\n\t\t/* file is on disk */\n\t\treturn (filep->access.fp != NULL);\n\n\t} else {\n#if defined(MG_USE_OPEN_FILE)\n\t\t/* is_file_in_memory returned true */\n\t\tif (open_file_in_memory(conn, path, filep, mode)) {\n\t\t\t/* file is in memory */\n\t\t\treturn (filep->access.membuf != NULL);\n\t\t}\n#endif\n\t}\n\n\t/* Open failed */\n\treturn 0;\n}\n\n\n/* return 0 on success, just like fclose */\nstatic int\nmg_fclose(struct mg_file_access *fileacc)\n{\n\tint ret = -1;\n\tif (fileacc != NULL) {\n\t\tif (fileacc->fp != NULL) {\n\t\t\tret = fclose(fileacc->fp);\n#if defined(MG_USE_OPEN_FILE)\n\t\t} else if (fileacc->membuf != NULL) {\n\t\t\tret = 0;\n#endif\n\t\t}\n\t\t/* reset all members of fileacc */\n\t\tmemset(fileacc, 0, sizeof(*fileacc));\n\t}\n\treturn ret;\n}\n\n\nstatic void\nmg_strlcpy(register char *dst, register const char *src, size_t n)\n{\n\tfor (; *src != '\\0' && n > 1; n--) {\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n}\n\n\nstatic int\nlowercase(const char *s)\n{\n\treturn tolower(*(const unsigned char *)s);\n}\n\n\nint\nmg_strncasecmp(const char *s1, const char *s2, size_t len)\n{\n\tint diff = 0;\n\n\tif (len > 0) {\n\t\tdo {\n\t\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t\t} while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\t}\n\n\treturn diff;\n}\n\n\nint\nmg_strcasecmp(const char *s1, const char *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = lowercase(s1++) - lowercase(s2++);\n\t} while (diff == 0 && s1[-1] != '\\0');\n\n\treturn diff;\n}\n\n\nstatic char *\nmg_strndup_ctx(const char *ptr, size_t len, struct mg_context *ctx)\n{\n\tchar *p;\n\t(void)ctx; /* Avoid Visual Studio warning if USE_SERVER_STATS is not\n\t            * defined */\n\n\tif ((p = (char *)mg_malloc_ctx(len + 1, ctx)) != NULL) {\n\t\tmg_strlcpy(p, ptr, len + 1);\n\t}\n\n\treturn p;\n}\n\n\nstatic char *\nmg_strdup_ctx(const char *str, struct mg_context *ctx)\n{\n\treturn mg_strndup_ctx(str, strlen(str), ctx);\n}\n\nstatic char *\nmg_strdup(const char *str)\n{\n\treturn mg_strndup_ctx(str, strlen(str), NULL);\n}\n\n\nstatic const char *\nmg_strcasestr(const char *big_str, const char *small_str)\n{\n\tsize_t i, big_len = strlen(big_str), small_len = strlen(small_str);\n\n\tif (big_len >= small_len) {\n\t\tfor (i = 0; i <= (big_len - small_len); i++) {\n\t\t\tif (mg_strncasecmp(big_str + i, small_str, small_len) == 0) {\n\t\t\t\treturn big_str + i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/* Return null terminated string of given maximum length.\n * Report errors if length is exceeded. */\nstatic void\nmg_vsnprintf(const struct mg_connection *conn,\n             int *truncated,\n             char *buf,\n             size_t buflen,\n             const char *fmt,\n             va_list ap)\n{\n\tint n, ok;\n\n\tif (buflen == 0) {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\treturn;\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n/* Using fmt as a non-literal is intended here, since it is mostly called\n * indirectly by mg_snprintf */\n#endif\n\n\tn = (int)vsnprintf_impl(buf, buflen, fmt, ap);\n\tok = (n >= 0) && ((size_t)n < buflen);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\tif (ok) {\n\t\tif (truncated) {\n\t\t\t*truncated = 0;\n\t\t}\n\t} else {\n\t\tif (truncated) {\n\t\t\t*truncated = 1;\n\t\t}\n\t\tmg_cry_internal(conn,\n\t\t                \"truncating vsnprintf buffer: [%.*s]\",\n\t\t                (int)((buflen > 200) ? 200 : (buflen - 1)),\n\t\t                buf);\n\t\tn = (int)buflen - 1;\n\t}\n\tbuf[n] = '\\0';\n}\n\n\nstatic void\nmg_snprintf(const struct mg_connection *conn,\n            int *truncated,\n            char *buf,\n            size_t buflen,\n            const char *fmt,\n            ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tmg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);\n\tva_end(ap);\n}\n\n\nstatic int\nget_option_index(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tif (strcmp(config_options[i].name, name) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nconst char *\nmg_get_option(const struct mg_context *ctx, const char *name)\n{\n\tint i;\n\tif ((i = get_option_index(name)) == -1) {\n\t\treturn NULL;\n\t} else if (!ctx || ctx->dd.config[i] == NULL) {\n\t\treturn \"\";\n\t} else {\n\t\treturn ctx->dd.config[i];\n\t}\n}\n\n#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly\n\nstruct mg_context *\nmg_get_context(const struct mg_connection *conn)\n{\n\treturn (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);\n}\n\n\nvoid *\nmg_get_user_data(const struct mg_context *ctx)\n{\n\treturn (ctx == NULL) ? NULL : ctx->user_data;\n}\n\n\nvoid\nmg_set_user_connection_data(struct mg_connection *conn, void *data)\n{\n\tif (conn != NULL) {\n\t\tconn->request_info.conn_data = data;\n\t}\n}\n\n\nvoid *\nmg_get_user_connection_data(const struct mg_connection *conn)\n{\n\tif (conn != NULL) {\n\t\treturn conn->request_info.conn_data;\n\t}\n\treturn NULL;\n}\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Deprecated: Use mg_get_server_ports instead. */\nsize_t\nmg_get_ports(const struct mg_context *ctx, size_t size, int *ports, int *ssl)\n{\n\tsize_t i;\n\tif (!ctx) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < size && i < ctx->num_listening_sockets; i++) {\n\t\tssl[i] = ctx->listening_sockets[i].is_ssl;\n\t\tports[i] =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t}\n\treturn i;\n}\n#endif\n\n\nint\nmg_get_server_ports(const struct mg_context *ctx,\n                    int size,\n                    struct mg_server_ports *ports)\n{\n\tint i, cnt = 0;\n\n\tif (size <= 0) {\n\t\treturn -1;\n\t}\n\tmemset(ports, 0, sizeof(*ports) * (size_t)size);\n\tif (!ctx) {\n\t\treturn -1;\n\t}\n\tif (!ctx->listening_sockets) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {\n\n\t\tports[cnt].port =\n#if defined(USE_IPV6)\n\t\t    (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6)\n\t\t        ? ntohs(ctx->listening_sockets[i].lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        ntohs(ctx->listening_sockets[i].lsa.sin.sin_port);\n\t\tports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;\n\t\tports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;\n\n\t\tif (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {\n\t\t\t/* IPv4 */\n\t\t\tports[cnt].protocol = 1;\n\t\t\tcnt++;\n\t\t} else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {\n\t\t\t/* IPv6 */\n\t\t\tports[cnt].protocol = 3;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\n\nstatic void\nsockaddr_to_string(char *buf, size_t len, const union usa *usa)\n{\n\tbuf[0] = '\\0';\n\n\tif (!usa) {\n\t\treturn;\n\t}\n\n\tif (usa->sa.sa_family == AF_INET) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#if defined(USE_IPV6)\n\telse if (usa->sa.sa_family == AF_INET6) {\n\t\tgetnameinfo(&usa->sa,\n\t\t            sizeof(usa->sin6),\n\t\t            buf,\n\t\t            (unsigned)len,\n\t\t            NULL,\n\t\t            0,\n\t\t            NI_NUMERICHOST);\n\t}\n#endif\n}\n\n\n/* Convert time_t to a string. According to RFC2616, Sec 14.18, this must be\n * included in all responses other than 100, 101, 5xx. */\nstatic void\ngmt_time_string(char *buf, size_t buf_len, time_t *t)\n{\n#if !defined(REENTRANT_TIME)\n\tstruct tm *tm;\n\n\ttm = ((t != NULL) ? gmtime(t) : NULL);\n\tif (tm != NULL) {\n#else\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n\n\tif (t != NULL) {\n\t\tgmtime_r(t, tm);\n#endif\n\t\tstrftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", tm);\n\t} else {\n\t\tmg_strlcpy(buf, \"Thu, 01 Jan 1970 00:00:00 GMT\", buf_len);\n\t\tbuf[buf_len - 1] = '\\0';\n\t}\n}\n\n\n/* difftime for struct timespec. Return value is in seconds. */\nstatic double\nmg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)\n{\n\treturn (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9\n\t       + (double)(ts_now->tv_sec - ts_before->tv_sec);\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl)\nstatic void mg_cry_internal_impl(const struct mg_connection *conn,\n                                 const char *func,\n                                 unsigned line,\n                                 const char *fmt,\n                                 va_list ap);\n#include \"external_mg_cry_internal_impl.inl\"\n#else\n\n/* Print error message to the opened error log stream. */\nstatic void\nmg_cry_internal_impl(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     va_list ap)\n{\n\tchar buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];\n\tstruct mg_file fi;\n\ttime_t timestamp;\n\n\t/* Unused, in the RELEASE build */\n\t(void)func;\n\t(void)line;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\tIGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n\n\tbuf[sizeof(buf) - 1] = 0;\n\n\tDEBUG_TRACE(\"mg_cry called from %s:%u: %s\", func, line, buf);\n\n\tif (!conn) {\n\t\tputs(buf);\n\t\treturn;\n\t}\n\n\t/* Do not lock when getting the callback value, here and below.\n\t * I suppose this is fine, since function cannot disappear in the\n\t * same way string option can. */\n\tif ((conn->phys_ctx->callbacks.log_message == NULL)\n\t    || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {\n\n\t\tif (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {\n\t\t\tif (mg_fopen(conn,\n\t\t\t             conn->dom_ctx->config[ERROR_LOG_FILE],\n\t\t\t             MG_FOPEN_MODE_APPEND,\n\t\t\t             &fi)\n\t\t\t    == 0) {\n\t\t\t\tfi.access.fp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\n\t\tif (fi.access.fp != NULL) {\n\t\t\tflockfile(fi.access.fp);\n\t\t\ttimestamp = time(NULL);\n\n\t\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\t\t\tfprintf(fi.access.fp,\n\t\t\t        \"[%010lu] [error] [client %s] \",\n\t\t\t        (unsigned long)timestamp,\n\t\t\t        src_addr);\n\n\t\t\tif (conn->request_info.request_method != NULL) {\n\t\t\t\tfprintf(fi.access.fp,\n\t\t\t\t        \"%s %s: \",\n\t\t\t\t        conn->request_info.request_method,\n\t\t\t\t        conn->request_info.request_uri\n\t\t\t\t            ? conn->request_info.request_uri\n\t\t\t\t            : \"\");\n\t\t\t}\n\n\t\t\tfprintf(fi.access.fp, \"%s\", buf);\n\t\t\tfputc('\\n', fi.access.fp);\n\t\t\tfflush(fi.access.fp);\n\t\t\tfunlockfile(fi.access.fp);\n\t\t\t(void)mg_fclose(&fi.access); /* Ignore errors. We can't call\n\t\t\t                              * mg_cry here anyway ;-) */\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\nstatic void\nmg_cry_internal_wrap(const struct mg_connection *conn,\n                     const char *func,\n                     unsigned line,\n                     const char *fmt,\n                     ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, func, line, fmt, ap);\n\tva_end(ap);\n}\n\n\nvoid\nmg_cry(const struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tmg_cry_internal_impl(conn, \"user\", 0, fmt, ap);\n\tva_end(ap);\n}\n\n\n#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal\n\n\n/* Return fake connection structure. Used for logging, if connection\n * is not applicable at the moment of logging. */\nstatic struct mg_connection *\nfc(struct mg_context *ctx)\n{\n\tstatic struct mg_connection fake_connection;\n\tfake_connection.phys_ctx = ctx;\n\tfake_connection.dom_ctx = &(ctx->dd);\n\treturn &fake_connection;\n}\n\n\nconst char *\nmg_version(void)\n{\n\treturn CIVETWEB_VERSION;\n}\n\n\nconst struct mg_request_info *\nmg_get_request_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE)\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\tchar txt[16];\n\t\tstruct mg_workerTLS *tls =\n\t\t    (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\n\t\tsprintf(txt, \"%03i\", conn->response_info.status_code);\n\t\tif (strlen(txt) == 3) {\n\t\t\tmemcpy(tls->txtbuf, txt, 4);\n\t\t} else {\n\t\t\tstrcpy(tls->txtbuf, \"ERR\");\n\t\t}\n\n\t\t((struct mg_connection *)conn)->request_info.local_uri =\n\t\t    ((struct mg_connection *)conn)->request_info.request_uri =\n\t\t        tls->txtbuf; /* use thread safe buffer */\n\n\t\t((struct mg_connection *)conn)->request_info.num_headers =\n\t\t    conn->response_info.num_headers;\n\t\tmemcpy(((struct mg_connection *)conn)->request_info.http_headers,\n\t\t       conn->response_info.http_headers,\n\t\t       sizeof(conn->response_info.http_headers));\n\t} else\n#endif\n\t    if (conn->connection_type != CONNECTION_TYPE_REQUEST) {\n\t\treturn NULL;\n\t}\n\treturn &conn->request_info;\n}\n\n\nconst struct mg_response_info *\nmg_get_response_info(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\tif (conn->connection_type != CONNECTION_TYPE_RESPONSE) {\n\t\treturn NULL;\n\t}\n\treturn &conn->response_info;\n}\n\n\nstatic const char *\nget_proto_name(const struct mg_connection *conn)\n{\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n/* Depending on USE_WEBSOCKET and NO_SSL, some oft the protocols might be\n * not supported. Clang raises an \"unreachable code\" warning for parts of ?:\n * unreachable, but splitting into four different #ifdef clauses here is more\n * complicated.\n */\n#endif\n\n\tconst struct mg_request_info *ri = &conn->request_info;\n\n\tconst char *proto =\n\t    (is_websocket_protocol(conn) ? (ri->is_ssl ? \"wss\" : \"ws\")\n\t                                 : (ri->is_ssl ? \"https\" : \"http\"));\n\n\treturn proto;\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n}\n\n\nint\nmg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen)\n{\n\tif ((buflen < 1) || (buf == 0) || (conn == 0)) {\n\t\treturn -1;\n\t} else {\n\n\t\tint truncated = 0;\n\t\tconst struct mg_request_info *ri = &conn->request_info;\n\n\t\tconst char *proto = get_proto_name(conn);\n\n\t\tif (ri->local_uri == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((ri->request_uri != NULL)\n\t\t    && (0 != strcmp(ri->local_uri, ri->request_uri))) {\n\t\t\t/* The request uri is different from the local uri.\n\t\t\t * This is usually if an absolute URI, including server\n\t\t\t * name has been provided. */\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s\",\n\t\t\t            proto,\n\t\t\t            ri->request_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\t} else {\n\n\t\t\t/* The common case is a relative URI, so we have to\n\t\t\t * construct an absolute URI from server name and port */\n\n#if defined(USE_IPV6)\n\t\t\tint is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);\n\t\t\tint port = is_ipv6 ? htons(conn->client.lsa.sin6.sin6_port)\n\t\t\t                   : htons(conn->client.lsa.sin.sin_port);\n#else\n\t\t\tint port = htons(conn->client.lsa.sin.sin_port);\n#endif\n\t\t\tint def_port = ri->is_ssl ? 443 : 80;\n\t\t\tint auth_domain_check_enabled =\n\t\t\t    conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]\n\t\t\t    && (!mg_strcasecmp(\n\t\t\t           conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\"));\n\t\t\tconst char *server_domain =\n\t\t\t    conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\n\t\t\tchar portstr[16];\n\t\t\tchar server_ip[48];\n\n\t\t\tif (port != def_port) {\n\t\t\t\tsprintf(portstr, \":%u\", (unsigned)port);\n\t\t\t} else {\n\t\t\t\tportstr[0] = 0;\n\t\t\t}\n\n\t\t\tif (!auth_domain_check_enabled || !server_domain) {\n\n\t\t\t\tsockaddr_to_string(server_ip,\n\t\t\t\t                   sizeof(server_ip),\n\t\t\t\t                   &conn->client.lsa);\n\n\t\t\t\tserver_domain = server_ip;\n\t\t\t}\n\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            buf,\n\t\t\t            buflen,\n\t\t\t            \"%s://%s%s%s\",\n\t\t\t            proto,\n\t\t\t            server_domain,\n\t\t\t            portstr,\n\t\t\t            ri->local_uri);\n\t\t\tif (truncated) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/* Skip the characters until one of the delimiters characters found.\n * 0-terminate resulting word. Skip the delimiter and following whitespaces.\n * Advance pointer to buffer to the next word. Return found 0-terminated\n * word.\n * Delimiters can be quoted with quotechar. */\nstatic char *\nskip_quoted(char **buf,\n            const char *delimiters,\n            const char *whitespace,\n            char quotechar)\n{\n\tchar *p, *begin_word, *end_word, *end_whitespace;\n\n\tbegin_word = *buf;\n\tend_word = begin_word + strcspn(begin_word, delimiters);\n\n\t/* Check for quotechar */\n\tif (end_word > begin_word) {\n\t\tp = end_word - 1;\n\t\twhile (*p == quotechar) {\n\t\t\t/* While the delimiter is quoted, look for the next delimiter.\n\t\t\t */\n\t\t\t/* This happens, e.g., in calls from parse_auth_header,\n\t\t\t * if the user name contains a \" character. */\n\n\t\t\t/* If there is anything beyond end_word, copy it. */\n\t\t\tif (*end_word != '\\0') {\n\t\t\t\tsize_t end_off = strcspn(end_word + 1, delimiters);\n\t\t\t\tmemmove(p, end_word, end_off + 1);\n\t\t\t\tp += end_off; /* p must correspond to end_word - 1 */\n\t\t\t\tend_word += end_off + 1;\n\t\t\t} else {\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (p++; p < end_word; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\n\tif (*end_word == '\\0') {\n\t\t*buf = end_word;\n\t} else {\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t\tend_whitespace = end_word + strspn(&end_word[1], whitespace) + 1;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t\tfor (p = end_word; p < end_whitespace; p++) {\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\t*buf = end_whitespace;\n\t}\n\n\treturn begin_word;\n}\n\n\n/* Return HTTP header value, or NULL if not found. */\nstatic const char *\nget_header(const struct mg_header *hdr, int num_hdr, const char *name)\n{\n\tint i;\n\tfor (i = 0; i < num_hdr; i++) {\n\t\tif (!mg_strcasecmp(name, hdr[i].name)) {\n\t\t\treturn hdr[i].value;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n#if defined(USE_WEBSOCKET)\n/* Retrieve requested HTTP header multiple values, and return the number of\n * found occurrences */\nstatic int\nget_req_headers(const struct mg_request_info *ri,\n                const char *name,\n                const char **output,\n                int output_max_size)\n{\n\tint i;\n\tint cnt = 0;\n\tif (ri) {\n\t\tfor (i = 0; i < ri->num_headers && cnt < output_max_size; i++) {\n\t\t\tif (!mg_strcasecmp(name, ri->http_headers[i].name)) {\n\t\t\t\toutput[cnt++] = ri->http_headers[i].value;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n#endif\n\n\nconst char *\nmg_get_header(const struct mg_connection *conn, const char *name)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn get_header(conn->request_info.http_headers,\n\t\t                  conn->request_info.num_headers,\n\t\t                  name);\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn get_header(conn->response_info.http_headers,\n\t\t                  conn->response_info.num_headers,\n\t\t                  name);\n\t}\n\treturn NULL;\n}\n\n\nstatic const char *\nget_http_version(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn NULL;\n\t}\n\n\tif (conn->connection_type == CONNECTION_TYPE_REQUEST) {\n\t\treturn conn->request_info.http_version;\n\t}\n\tif (conn->connection_type == CONNECTION_TYPE_RESPONSE) {\n\t\treturn conn->response_info.http_version;\n\t}\n\treturn NULL;\n}\n\n\n/* A helper function for traversing a comma separated list of values.\n * It returns a list pointer shifted to the next value, or NULL if the end\n * of the list found.\n * Value is stored in val vector. If value has form \"x=y\", then eq_val\n * vector is initialized to point to the \"y\" part, and val vector length\n * is adjusted to point only to \"x\". */\nstatic const char *\nnext_option(const char *list, struct vec *val, struct vec *eq_val)\n{\n\tint end;\n\nreparse:\n\tif (val == NULL || list == NULL || *list == '\\0') {\n\t\t/* End of the list */\n\t\treturn NULL;\n\t}\n\n\t/* Skip over leading LWS */\n\twhile (*list == ' ' || *list == '\\t')\n\t\tlist++;\n\n\tval->ptr = list;\n\tif ((list = strchr(val->ptr, ',')) != NULL) {\n\t\t/* Comma found. Store length and shift the list ptr */\n\t\tval->len = ((size_t)(list - val->ptr));\n\t\tlist++;\n\t} else {\n\t\t/* This value is the last one */\n\t\tlist = val->ptr + strlen(val->ptr);\n\t\tval->len = ((size_t)(list - val->ptr));\n\t}\n\n\t/* Adjust length for trailing LWS */\n\tend = (int)val->len - 1;\n\twhile (end >= 0 && ((val->ptr[end] == ' ') || (val->ptr[end] == '\\t')))\n\t\tend--;\n\tval->len = (size_t)(end + 1);\n\n\tif (val->len == 0) {\n\t\t/* Ignore any empty entries. */\n\t\tgoto reparse;\n\t}\n\n\tif (eq_val != NULL) {\n\t\t/* Value has form \"x=y\", adjust pointers and lengths\n\t\t * so that val points to \"x\", and eq_val points to \"y\". */\n\t\teq_val->len = 0;\n\t\teq_val->ptr = (const char *)memchr(val->ptr, '=', val->len);\n\t\tif (eq_val->ptr != NULL) {\n\t\t\teq_val->ptr++; /* Skip over '=' character */\n\t\t\teq_val->len = ((size_t)(val->ptr - eq_val->ptr)) + val->len;\n\t\t\tval->len = ((size_t)(eq_val->ptr - val->ptr)) - 1;\n\t\t}\n\t}\n\n\treturn list;\n}\n\n\n/* A helper function for checking if a comma separated list of values\n * contains\n * the given option (case insensitvely).\n * 'header' can be NULL, in which case false is returned. */\nstatic int\nheader_has_option(const char *header, const char *option)\n{\n\tstruct vec opt_vec;\n\tstruct vec eq_vec;\n\n\tDEBUG_ASSERT(option != NULL);\n\tDEBUG_ASSERT(option[0] != '\\0');\n\n\twhile ((header = next_option(header, &opt_vec, &eq_vec)) != NULL) {\n\t\tif (mg_strncasecmp(option, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/* Perform case-insensitive match of string against pattern */\nstatic ptrdiff_t\nmatch_prefix(const char *pattern, size_t pattern_len, const char *str)\n{\n\tconst char *or_str;\n\tptrdiff_t i, j, len, res;\n\n\tif ((or_str = (const char *)memchr(pattern, '|', pattern_len)) != NULL) {\n\t\tres = match_prefix(pattern, (size_t)(or_str - pattern), str);\n\t\treturn (res > 0) ? res\n\t\t                 : match_prefix(or_str + 1,\n\t\t                                (size_t)((pattern + pattern_len)\n\t\t                                         - (or_str + 1)),\n\t\t                                str);\n\t}\n\n\tfor (i = 0, j = 0; (i < (ptrdiff_t)pattern_len); i++, j++) {\n\t\tif ((pattern[i] == '?') && (str[j] != '\\0')) {\n\t\t\tcontinue;\n\t\t} else if (pattern[i] == '$') {\n\t\t\treturn (str[j] == '\\0') ? j : -1;\n\t\t} else if (pattern[i] == '*') {\n\t\t\ti++;\n\t\t\tif (pattern[i] == '*') {\n\t\t\t\ti++;\n\t\t\t\tlen = strlen(str + j);\n\t\t\t} else {\n\t\t\t\tlen = strcspn(str + j, \"/\");\n\t\t\t}\n\t\t\tif (i == (ptrdiff_t)pattern_len) {\n\t\t\t\treturn j + len;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tres = match_prefix(pattern + i, pattern_len - i, str + j + len);\n\t\t\t} while (res == -1 && len-- > 0);\n\t\t\treturn (res == -1) ? -1 : j + res + len;\n\t\t} else if (lowercase(&pattern[i]) != lowercase(&str[j])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (ptrdiff_t)j;\n}\n\n\n/* HTTP 1.1 assumes keep alive if \"Connection:\" header is not set\n * This function must tolerate situations when connection info is not\n * set up, for example if request parsing failed. */\nstatic int\nshould_keep_alive(const struct mg_connection *conn)\n{\n\tconst char *http_version;\n\tconst char *header;\n\n\t/* First satisfy needs of the server */\n\tif ((conn == NULL) || conn->must_close) {\n\t\t/* Close, if civetweb framework needs to close */\n\t\treturn 0;\n\t}\n\n\tif (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\") != 0) {\n\t\t/* Close, if keep alive is not enabled */\n\t\treturn 0;\n\t}\n\n\t/* Check explicit wish of the client */\n\theader = mg_get_header(conn, \"Connection\");\n\tif (header) {\n\t\t/* If there is a connection header from the client, obey */\n\t\tif (header_has_option(header, \"keep-alive\")) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Use default of the standard */\n\thttp_version = get_http_version(conn);\n\tif (http_version && (0 == strcmp(http_version, \"1.1\"))) {\n\t\t/* HTTP 1.1 default is keep alive */\n\t\treturn 1;\n\t}\n\n\t/* HTTP 1.0 (and earlier) default is to close the connection */\n\treturn 0;\n}\n\n\nstatic int\nshould_decode_url(const struct mg_connection *conn)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\treturn (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], \"yes\") == 0);\n}\n\n\nstatic const char *\nsuggest_connection_header(const struct mg_connection *conn)\n{\n\treturn should_keep_alive(conn) ? \"keep-alive\" : \"close\";\n}\n\n\nstatic int\nsend_no_cache_header(struct mg_connection *conn)\n{\n\t/* Send all current and obsolete cache opt-out directives. */\n\treturn mg_printf(conn,\n\t                 \"Cache-Control: no-cache, no-store, \"\n\t                 \"must-revalidate, private, max-age=0\\r\\n\"\n\t                 \"Pragma: no-cache\\r\\n\"\n\t                 \"Expires: 0\\r\\n\");\n}\n\n\nstatic int\nsend_static_cache_header(struct mg_connection *conn)\n{\n#if !defined(NO_CACHING)\n\t/* Read the server config to check how long a file may be cached.\n\t * The configuration is in seconds. */\n\tint max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);\n\tif (max_age <= 0) {\n\t\t/* 0 means \"do not cache\". All values <0 are reserved\n\t\t * and may be used differently in the future. */\n\t\t/* If a file should not be cached, do not only send\n\t\t * max-age=0, but also pragmas and Expires headers. */\n\t\treturn send_no_cache_header(conn);\n\t}\n\n\t/* Use \"Cache-Control: max-age\" instead of \"Expires\" header.\n\t * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */\n\t/* See also https://www.mnot.net/cache_docs/ */\n\t/* According to RFC 2616, Section 14.21, caching times should not exceed\n\t * one year. A year with 365 days corresponds to 31536000 seconds, a\n\t * leap\n\t * year to 31622400 seconds. For the moment, we just send whatever has\n\t * been configured, still the behavior for >1 year should be considered\n\t * as undefined. */\n\treturn mg_printf(conn, \"Cache-Control: max-age=%u\\r\\n\", (unsigned)max_age);\n#else  /* NO_CACHING */\n\treturn send_no_cache_header(conn);\n#endif /* !NO_CACHING */\n}\n\n\nstatic int\nsend_additional_header(struct mg_connection *conn)\n{\n\tint i = 0;\n\tconst char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];\n\n#if !defined(NO_SSL)\n\tif (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {\n\t\tint max_age = atoi(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);\n\t\tif (max_age >= 0) {\n\t\t\ti += mg_printf(conn,\n\t\t\t               \"Strict-Transport-Security: max-age=%u\\r\\n\",\n\t\t\t               (unsigned)max_age);\n\t\t}\n\t}\n#endif\n\n\tif (header && header[0]) {\n\t\ti += mg_printf(conn, \"%s\\r\\n\", header);\n\t}\n\n\treturn i;\n}\n\n\nstatic void handle_file_based_request(struct mg_connection *conn,\n                                      const char *path,\n                                      struct mg_file *filep);\n\n\nconst char *\nmg_get_response_code_text(const struct mg_connection *conn, int response_code)\n{\n\t/* See IANA HTTP status code assignment:\n\t * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\t */\n\n\tswitch (response_code) {\n\t/* RFC2616 Section 10.1 - Informational 1xx */\n\tcase 100:\n\t\treturn \"Continue\"; /* RFC2616 Section 10.1.1 */\n\tcase 101:\n\t\treturn \"Switching Protocols\"; /* RFC2616 Section 10.1.2 */\n\tcase 102:\n\t\treturn \"Processing\"; /* RFC2518 Section 10.1 */\n\n\t/* RFC2616 Section 10.2 - Successful 2xx */\n\tcase 200:\n\t\treturn \"OK\"; /* RFC2616 Section 10.2.1 */\n\tcase 201:\n\t\treturn \"Created\"; /* RFC2616 Section 10.2.2 */\n\tcase 202:\n\t\treturn \"Accepted\"; /* RFC2616 Section 10.2.3 */\n\tcase 203:\n\t\treturn \"Non-Authoritative Information\"; /* RFC2616 Section 10.2.4 */\n\tcase 204:\n\t\treturn \"No Content\"; /* RFC2616 Section 10.2.5 */\n\tcase 205:\n\t\treturn \"Reset Content\"; /* RFC2616 Section 10.2.6 */\n\tcase 206:\n\t\treturn \"Partial Content\"; /* RFC2616 Section 10.2.7 */\n\tcase 207:\n\t\treturn \"Multi-Status\"; /* RFC2518 Section 10.2, RFC4918 Section 11.1\n\t\t                        */\n\tcase 208:\n\t\treturn \"Already Reported\"; /* RFC5842 Section 7.1 */\n\n\tcase 226:\n\t\treturn \"IM used\"; /* RFC3229 Section 10.4.1 */\n\n\t/* RFC2616 Section 10.3 - Redirection 3xx */\n\tcase 300:\n\t\treturn \"Multiple Choices\"; /* RFC2616 Section 10.3.1 */\n\tcase 301:\n\t\treturn \"Moved Permanently\"; /* RFC2616 Section 10.3.2 */\n\tcase 302:\n\t\treturn \"Found\"; /* RFC2616 Section 10.3.3 */\n\tcase 303:\n\t\treturn \"See Other\"; /* RFC2616 Section 10.3.4 */\n\tcase 304:\n\t\treturn \"Not Modified\"; /* RFC2616 Section 10.3.5 */\n\tcase 305:\n\t\treturn \"Use Proxy\"; /* RFC2616 Section 10.3.6 */\n\tcase 307:\n\t\treturn \"Temporary Redirect\"; /* RFC2616 Section 10.3.8 */\n\tcase 308:\n\t\treturn \"Permanent Redirect\"; /* RFC7238 Section 3 */\n\n\t/* RFC2616 Section 10.4 - Client Error 4xx */\n\tcase 400:\n\t\treturn \"Bad Request\"; /* RFC2616 Section 10.4.1 */\n\tcase 401:\n\t\treturn \"Unauthorized\"; /* RFC2616 Section 10.4.2 */\n\tcase 402:\n\t\treturn \"Payment Required\"; /* RFC2616 Section 10.4.3 */\n\tcase 403:\n\t\treturn \"Forbidden\"; /* RFC2616 Section 10.4.4 */\n\tcase 404:\n\t\treturn \"Not Found\"; /* RFC2616 Section 10.4.5 */\n\tcase 405:\n\t\treturn \"Method Not Allowed\"; /* RFC2616 Section 10.4.6 */\n\tcase 406:\n\t\treturn \"Not Acceptable\"; /* RFC2616 Section 10.4.7 */\n\tcase 407:\n\t\treturn \"Proxy Authentication Required\"; /* RFC2616 Section 10.4.8 */\n\tcase 408:\n\t\treturn \"Request Time-out\"; /* RFC2616 Section 10.4.9 */\n\tcase 409:\n\t\treturn \"Conflict\"; /* RFC2616 Section 10.4.10 */\n\tcase 410:\n\t\treturn \"Gone\"; /* RFC2616 Section 10.4.11 */\n\tcase 411:\n\t\treturn \"Length Required\"; /* RFC2616 Section 10.4.12 */\n\tcase 412:\n\t\treturn \"Precondition Failed\"; /* RFC2616 Section 10.4.13 */\n\tcase 413:\n\t\treturn \"Request Entity Too Large\"; /* RFC2616 Section 10.4.14 */\n\tcase 414:\n\t\treturn \"Request-URI Too Large\"; /* RFC2616 Section 10.4.15 */\n\tcase 415:\n\t\treturn \"Unsupported Media Type\"; /* RFC2616 Section 10.4.16 */\n\tcase 416:\n\t\treturn \"Requested range not satisfiable\"; /* RFC2616 Section 10.4.17\n\t\t                                           */\n\tcase 417:\n\t\treturn \"Expectation Failed\"; /* RFC2616 Section 10.4.18 */\n\n\tcase 421:\n\t\treturn \"Misdirected Request\"; /* RFC7540 Section 9.1.2 */\n\tcase 422:\n\t\treturn \"Unproccessable entity\"; /* RFC2518 Section 10.3, RFC4918\n\t\t                                 * Section 11.2 */\n\tcase 423:\n\t\treturn \"Locked\"; /* RFC2518 Section 10.4, RFC4918 Section 11.3 */\n\tcase 424:\n\t\treturn \"Failed Dependency\"; /* RFC2518 Section 10.5, RFC4918\n\t\t                             * Section 11.4 */\n\n\tcase 426:\n\t\treturn \"Upgrade Required\"; /* RFC 2817 Section 4 */\n\n\tcase 428:\n\t\treturn \"Precondition Required\"; /* RFC 6585, Section 3 */\n\tcase 429:\n\t\treturn \"Too Many Requests\"; /* RFC 6585, Section 4 */\n\n\tcase 431:\n\t\treturn \"Request Header Fields Too Large\"; /* RFC 6585, Section 5 */\n\n\tcase 451:\n\t\treturn \"Unavailable For Legal Reasons\"; /* draft-tbray-http-legally-restricted-status-05,\n\t\t                                         * Section 3 */\n\n\t/* RFC2616 Section 10.5 - Server Error 5xx */\n\tcase 500:\n\t\treturn \"Internal Server Error\"; /* RFC2616 Section 10.5.1 */\n\tcase 501:\n\t\treturn \"Not Implemented\"; /* RFC2616 Section 10.5.2 */\n\tcase 502:\n\t\treturn \"Bad Gateway\"; /* RFC2616 Section 10.5.3 */\n\tcase 503:\n\t\treturn \"Service Unavailable\"; /* RFC2616 Section 10.5.4 */\n\tcase 504:\n\t\treturn \"Gateway Time-out\"; /* RFC2616 Section 10.5.5 */\n\tcase 505:\n\t\treturn \"HTTP Version not supported\"; /* RFC2616 Section 10.5.6 */\n\tcase 506:\n\t\treturn \"Variant Also Negotiates\"; /* RFC 2295, Section 8.1 */\n\tcase 507:\n\t\treturn \"Insufficient Storage\"; /* RFC2518 Section 10.6, RFC4918\n\t\t                                * Section 11.5 */\n\tcase 508:\n\t\treturn \"Loop Detected\"; /* RFC5842 Section 7.1 */\n\n\tcase 510:\n\t\treturn \"Not Extended\"; /* RFC 2774, Section 7 */\n\tcase 511:\n\t\treturn \"Network Authentication Required\"; /* RFC 6585, Section 6 */\n\n\t/* Other status codes, not shown in the IANA HTTP status code\n\t * assignment.\n\t * E.g., \"de facto\" standards due to common use, ... */\n\tcase 418:\n\t\treturn \"I am a teapot\"; /* RFC2324 Section 2.3.2 */\n\tcase 419:\n\t\treturn \"Authentication Timeout\"; /* common use */\n\tcase 420:\n\t\treturn \"Enhance Your Calm\"; /* common use */\n\tcase 440:\n\t\treturn \"Login Timeout\"; /* common use */\n\tcase 509:\n\t\treturn \"Bandwidth Limit Exceeded\"; /* common use */\n\n\tdefault:\n\t\t/* This error code is unknown. This should not happen. */\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Unknown HTTP response code: %u\",\n\t\t\t                response_code);\n\t\t}\n\n\t\t/* Return at least a category according to RFC 2616 Section 10. */\n\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t/* Unknown informational status code */\n\t\t\treturn \"Information\";\n\t\t}\n\t\tif (response_code >= 200 && response_code < 300) {\n\t\t\t/* Unknown success code */\n\t\t\treturn \"Success\";\n\t\t}\n\t\tif (response_code >= 300 && response_code < 400) {\n\t\t\t/* Unknown redirection code */\n\t\t\treturn \"Redirection\";\n\t\t}\n\t\tif (response_code >= 400 && response_code < 500) {\n\t\t\t/* Unknown request error code */\n\t\t\treturn \"Client Error\";\n\t\t}\n\t\tif (response_code >= 500 && response_code < 600) {\n\t\t\t/* Unknown server error code */\n\t\t\treturn \"Server Error\";\n\t\t}\n\n\t\t/* Response code not even within reasonable range */\n\t\treturn \"\";\n\t}\n}\n\n\nstatic int\nmg_send_http_error_impl(struct mg_connection *conn,\n                        int status,\n                        const char *fmt,\n                        va_list args)\n{\n\tchar errmsg_buf[MG_BUF_LEN];\n\tchar path_buf[PATH_MAX];\n\tva_list ap;\n\tint len, i, page_handler_found, scope, truncated, has_body;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *error_handler = NULL;\n\tstruct mg_file error_page_file = STRUCT_FILE_INITIALIZER;\n\tconst char *error_page_file_ext, *tstr;\n\tint handled_by_callback = 0;\n\n\tconst char *status_text = mg_get_response_code_text(conn, status);\n\n\tif ((conn == NULL) || (fmt == NULL)) {\n\t\treturn -2;\n\t}\n\n\t/* Set status (for log) */\n\tconn->status_code = status;\n\n\t/* Errors 1xx, 204 and 304 MUST NOT send a body */\n\thas_body = ((status > 199) && (status != 204) && (status != 304));\n\n\t/* Prepare message in buf, if required */\n\tif (has_body\n\t    || (!conn->in_error_handler\n\t        && (conn->phys_ctx->callbacks.http_error != NULL))) {\n\t\t/* Store error message in errmsg_buf */\n\t\tva_copy(ap, args);\n\t\tmg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);\n\t\tva_end(ap);\n\t\t/* In a debug build, print all html errors */\n\t\tDEBUG_TRACE(\"Error %i - [%s]\", status, errmsg_buf);\n\t}\n\n\t/* If there is a http_error callback, call it.\n\t * But don't do it recursively, if callback calls mg_send_http_error again.\n\t */\n\tif (!conn->in_error_handler\n\t    && (conn->phys_ctx->callbacks.http_error != NULL)) {\n\t\t/* Mark in_error_handler to avoid recursion and call user callback. */\n\t\tconn->in_error_handler = 1;\n\t\thandled_by_callback =\n\t\t    (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf)\n\t\t     == 0);\n\t\tconn->in_error_handler = 0;\n\t}\n\n\tif (!handled_by_callback) {\n\t\t/* Check for recursion */\n\t\tif (conn->in_error_handler) {\n\t\t\tDEBUG_TRACE(\n\t\t\t    \"Recursion when handling error %u - fall back to default\",\n\t\t\t    status);\n\t\t} else {\n\t\t\t/* Send user defined error pages, if defined */\n\t\t\terror_handler = conn->dom_ctx->config[ERROR_PAGES];\n\t\t\terror_page_file_ext = conn->dom_ctx->config[INDEX_FILES];\n\t\t\tpage_handler_found = 0;\n\n\t\t\tif (error_handler != NULL) {\n\t\t\t\tfor (scope = 1; (scope <= 3) && !page_handler_found; scope++) {\n\t\t\t\t\tswitch (scope) {\n\t\t\t\t\tcase 1: /* Handler for specific error, e.g. 404 error */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%03u.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: /* Handler for error group, e.g., 5xx error\n\t\t\t\t\t         * handler\n\t\t\t\t\t         * for all server errors (500-599) */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror%01uxx.\",\n\t\t\t\t\t\t            error_handler,\n\t\t\t\t\t\t            status / 100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* Handler for all errors */\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            path_buf,\n\t\t\t\t\t\t            sizeof(path_buf) - 32,\n\t\t\t\t\t\t            \"%serror.\",\n\t\t\t\t\t\t            error_handler);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* String truncation in buf may only occur if\n\t\t\t\t\t * error_handler is too long. This string is\n\t\t\t\t\t * from the config, not from a client. */\n\t\t\t\t\t(void)truncated;\n\n\t\t\t\t\tlen = (int)strlen(path_buf);\n\n\t\t\t\t\ttstr = strchr(error_page_file_ext, '.');\n\n\t\t\t\t\twhile (tstr) {\n\t\t\t\t\t\tfor (i = 1;\n\t\t\t\t\t\t     (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');\n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t\t * (i < 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t\t * ==> (i + len) < sizeof(path_buf) */\n\t\t\t\t\t\t\tpath_buf[len + i - 1] = tstr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* buffer overrun is not possible here, since\n\t\t\t\t\t\t * (i <= 32) && (len < sizeof(path_buf) - 32)\n\t\t\t\t\t\t * ==> (i + len) <= sizeof(path_buf) */\n\t\t\t\t\t\tpath_buf[len + i - 1] = 0;\n\n\t\t\t\t\t\tif (mg_stat(conn, path_buf, &error_page_file.stat)) {\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - found\",\n\t\t\t\t\t\t\t            path_buf);\n\t\t\t\t\t\t\tpage_handler_found = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDEBUG_TRACE(\"Check error page %s - not found\",\n\t\t\t\t\t\t            path_buf);\n\n\t\t\t\t\t\ttstr = strchr(tstr + i, '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page_handler_found) {\n\t\t\t\tconn->in_error_handler = 1;\n\t\t\t\thandle_file_based_request(conn, path_buf, &error_page_file);\n\t\t\t\tconn->in_error_handler = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* No custom error page. Send default error page. */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t\tconn->must_close = 1;\n\t\tmg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", status, status_text);\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tif (has_body) {\n\t\t\tmg_printf(conn,\n\t\t\t          \"%s\",\n\t\t\t          \"Content-Type: text/plain; charset=utf-8\\r\\n\");\n\t\t}\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Connection: close\\r\\n\\r\\n\",\n\t\t          date);\n\n\t\t/* HTTP responses 1xx, 204 and 304 MUST NOT send a body */\n\t\tif (has_body) {\n\t\t\t/* For other errors, send a generic error message. */\n\t\t\tmg_printf(conn, \"Error %d: %s\\n\", status, status_text);\n\t\t\tmg_write(conn, errmsg_buf, strlen(errmsg_buf));\n\n\t\t} else {\n\t\t\t/* No body allowed. Close the connection. */\n\t\t\tDEBUG_TRACE(\"Error %i\", status);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint\nmg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = mg_send_http_error_impl(conn, status, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\n\nint\nmg_send_http_ok(struct mg_connection *conn,\n                const char *mime_type,\n                long long content_length)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((mime_type == NULL) || (*mime_type == 0)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Content-Type: %s\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\",\n\t          mime_type,\n\t          date,\n\t          suggest_connection_header(conn));\n\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tif (content_length < 0) {\n\t\tmg_printf(conn, \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n\t} else {\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: %\" UINT64_FMT \"\\r\\n\\r\\n\",\n\t\t          (uint64_t)content_length);\n\t}\n\n\treturn 0;\n}\n\n\nint\nmg_send_http_redirect(struct mg_connection *conn,\n                      const char *target_url,\n                      int redirect_code)\n{\n\t/* Send a 30x redirect response.\n\t *\n\t * Redirect types (status codes):\n\t *\n\t * Status | Perm/Temp | Method              | Version\n\t *   301  | permanent | POST->GET undefined | HTTP/1.0\n\t *   302  | temporary | POST->GET undefined | HTTP/1.0\n\t *   303  | temporary | always use GET      | HTTP/1.1\n\t *   307  | temporary | always keep method  | HTTP/1.1\n\t *   308  | permanent | always keep method  | HTTP/1.1\n\t */\n\tconst char *redirect_text;\n\tint ret;\n\tsize_t content_len = 0;\n\tchar reply[MG_BUF_LEN];\n\n\t/* In case redirect_code=0, use 307. */\n\tif (redirect_code == 0) {\n\t\tredirect_code = 307;\n\t}\n\n\t/* In case redirect_code is none of the above, return error. */\n\tif ((redirect_code != 301) && (redirect_code != 302)\n\t    && (redirect_code != 303) && (redirect_code != 307)\n\t    && (redirect_code != 308)) {\n\t\t/* Parameter error */\n\t\treturn -2;\n\t}\n\n\t/* Get proper text for response code */\n\tredirect_text = mg_get_response_code_text(conn, redirect_code);\n\n\t/* If target_url is not defined, redirect to \"/\". */\n\tif ((target_url == NULL) || (*target_url == 0)) {\n\t\ttarget_url = \"/\";\n\t}\n\n#if defined(MG_SEND_REDIRECT_BODY)\n\t/* TODO: condition name? */\n\n\t/* Prepare a response body with a hyperlink.\n\t *\n\t * According to RFC2616 (and RFC1945 before):\n\t * Unless the request method was HEAD, the entity of the\n\t * response SHOULD contain a short hypertext note with a hyperlink to\n\t * the new URI(s).\n\t *\n\t * However, this response body is not useful in M2M communication.\n\t * Probably the original reason in the RFC was, clients not supporting\n\t * a 30x HTTP redirect could still show the HTML page and let the user\n\t * press the link. Since current browsers support 30x HTTP, the additional\n\t * HTML body does not seem to make sense anymore.\n\t *\n\t * The new RFC7231 (Section 6.4) does no longer recommend it (\"SHOULD\"),\n\t * but it only notes:\n\t * The server's response payload usually contains a short\n\t * hypertext note with a hyperlink to the new URI(s).\n\t *\n\t * Deactivated by default. If you need the 30x body, set the define.\n\t */\n\tmg_snprintf(\n\t    conn,\n\t    NULL /* ignore truncation */,\n\t    reply,\n\t    sizeof(reply),\n\t    \"<html><head>%s</head><body><a href=\\\"%s\\\">%s</a></body></html>\",\n\t    redirect_text,\n\t    target_url,\n\t    target_url);\n\tcontent_len = strlen(reply);\n#else\n\treply[0] = 0;\n#endif\n\n\t/* Do not send any additional header. For all other options,\n\t * including caching, there are suitable defaults. */\n\tret = mg_printf(conn,\n\t                \"HTTP/1.1 %i %s\\r\\n\"\n\t                \"Location: %s\\r\\n\"\n\t                \"Content-Length: %u\\r\\n\"\n\t                \"Connection: %s\\r\\n\\r\\n\",\n\t                redirect_code,\n\t                redirect_text,\n\t                target_url,\n\t                (unsigned int)content_len,\n\t                suggest_connection_header(conn));\n\n\t/* Send response body */\n\tif (ret > 0) {\n\t\t/* ... unless it is a HEAD request */\n\t\tif (0 != strcmp(conn->request_info.request_method, \"HEAD\")) {\n\t\t\tret = mg_write(conn, reply, content_len);\n\t\t}\n\t}\n\n\treturn (ret > 0) ? ret : -1;\n}\n\n\n#if defined(_WIN32)\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_init(pthread_mutex_t *mutex, void *unused)\n{\n\t(void)unused;\n\t*mutex = CreateMutex(NULL, FALSE, NULL);\n\treturn (*mutex == NULL) ? -1 : 0;\n}\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_destroy(pthread_mutex_t *mutex)\n{\n\treturn (CloseHandle(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\treturn (WaitForSingleObject(*mutex, (DWORD)INFINITE) == WAIT_OBJECT_0) ? 0\n\t                                                                       : -1;\n}\n\n\n#if defined(ENABLE_UNUSED_PTHREAD_FUNCTIONS)\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_trylock(pthread_mutex_t *mutex)\n{\n\tswitch (WaitForSingleObject(*mutex, 0)) {\n\tcase WAIT_OBJECT_0:\n\t\treturn 0;\n\tcase WAIT_TIMEOUT:\n\t\treturn -2; /* EBUSY */\n\t}\n\treturn -1;\n}\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\treturn (ReleaseMutex(*mutex) == 0) ? -1 : 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_init(pthread_cond_t *cv, const void *unused)\n{\n\t(void)unused;\n\tInitializeCriticalSection(&cv->threadIdSec);\n\tcv->waiting_thread = NULL;\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_timedwait(pthread_cond_t *cv,\n                       pthread_mutex_t *mutex,\n                       FUNCTION_MAY_BE_UNUSED const struct timespec *abstime)\n{\n\tstruct mg_workerTLS **ptls,\n\t    *tls = (struct mg_workerTLS *)pthread_getspecific(sTlsKey);\n\tint ok;\n\tint64_t nsnow, nswaitabs, nswaitrel;\n\tDWORD mswaitrel;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\t/* Add this thread to cv's waiting list */\n\tptls = &cv->waiting_thread;\n\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread)\n\t\t;\n\ttls->next_waiting_thread = NULL;\n\t*ptls = tls;\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\tif (abstime) {\n\t\tnsnow = mg_get_current_time_ns();\n\t\tnswaitabs =\n\t\t    (((int64_t)abstime->tv_sec) * 1000000000) + abstime->tv_nsec;\n\t\tnswaitrel = nswaitabs - nsnow;\n\t\tif (nswaitrel < 0) {\n\t\t\tnswaitrel = 0;\n\t\t}\n\t\tmswaitrel = (DWORD)(nswaitrel / 1000000);\n\t} else {\n\t\tmswaitrel = (DWORD)INFINITE;\n\t}\n\n\tpthread_mutex_unlock(mutex);\n\tok = (WAIT_OBJECT_0\n\t      == WaitForSingleObject(tls->pthread_cond_helper_mutex, mswaitrel));\n\tif (!ok) {\n\t\tok = 1;\n\t\tEnterCriticalSection(&cv->threadIdSec);\n\t\tptls = &cv->waiting_thread;\n\t\tfor (; *ptls != NULL; ptls = &(*ptls)->next_waiting_thread) {\n\t\t\tif (*ptls == tls) {\n\t\t\t\t*ptls = tls->next_waiting_thread;\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tLeaveCriticalSection(&cv->threadIdSec);\n\t\tif (ok) {\n\t\t\tWaitForSingleObject(tls->pthread_cond_helper_mutex,\n\t\t\t                    (DWORD)INFINITE);\n\t\t}\n\t}\n\t/* This thread has been removed from cv's waiting list */\n\tpthread_mutex_lock(mutex);\n\n\treturn ok ? 0 : -1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex)\n{\n\treturn pthread_cond_timedwait(cv, mutex, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_signal(pthread_cond_t *cv)\n{\n\tHANDLE wkup = NULL;\n\tBOOL ok = FALSE;\n\n\tEnterCriticalSection(&cv->threadIdSec);\n\tif (cv->waiting_thread) {\n\t\twkup = cv->waiting_thread->pthread_cond_helper_mutex;\n\t\tcv->waiting_thread = cv->waiting_thread->next_waiting_thread;\n\n\t\tok = SetEvent(wkup);\n\t\tDEBUG_ASSERT(ok);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn ok ? 0 : 1;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_broadcast(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\twhile (cv->waiting_thread) {\n\t\tpthread_cond_signal(cv);\n\t}\n\tLeaveCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npthread_cond_destroy(pthread_cond_t *cv)\n{\n\tEnterCriticalSection(&cv->threadIdSec);\n\tDEBUG_ASSERT(cv->waiting_thread == NULL);\n\tLeaveCriticalSection(&cv->threadIdSec);\n\tDeleteCriticalSection(&cv->threadIdSec);\n\n\treturn 0;\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\nFUNCTION_MAY_BE_UNUSED\nstatic void *\nevent_create(void)\n{\n\treturn (void *)CreateEvent(NULL, FALSE, FALSE, NULL);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_wait(void *eventhdl)\n{\n\tint res = WaitForSingleObject((HANDLE)eventhdl, (DWORD)INFINITE);\n\treturn (res == WAIT_OBJECT_0);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nevent_signal(void *eventhdl)\n{\n\treturn (int)SetEvent((HANDLE)eventhdl);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic void\nevent_destroy(void *eventhdl)\n{\n\tCloseHandle((HANDLE)eventhdl);\n}\n#endif\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\n/* For Windows, change all slashes to backslashes in path names. */\nstatic void\nchange_slashes_to_backslashes(char *path)\n{\n\tint i;\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == '/') {\n\t\t\tpath[i] = '\\\\';\n\t\t}\n\n\t\t/* remove double backslash (check i > 0 to preserve UNC paths,\n\t\t * like \\\\server\\file.txt) */\n\t\tif ((path[i] == '\\\\') && (i > 0)) {\n\t\t\twhile ((path[i + 1] == '\\\\') || (path[i + 1] == '/')) {\n\t\t\t\t(void)memmove(path + i + 1, path + i + 2, strlen(path + i + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_wcscasecmp(const wchar_t *s1, const wchar_t *s2)\n{\n\tint diff;\n\n\tdo {\n\t\tdiff = tolower(*s1) - tolower(*s2);\n\t\ts1++;\n\t\ts2++;\n\t} while ((diff == 0) && (s1[-1] != '\\0'));\n\n\treturn diff;\n}\n\n\n/* Encode 'path' which is assumed UTF-8 string, into UNICODE string.\n * wbuf and wbuf_len is a target buffer and its length. */\nstatic void\npath_to_unicode(const struct mg_connection *conn,\n                const char *path,\n                wchar_t *wbuf,\n                size_t wbuf_len)\n{\n\tchar buf[PATH_MAX], buf2[PATH_MAX];\n\twchar_t wbuf2[W_PATH_MAX + 1];\n\tDWORD long_len, err;\n\tint (*fcompare)(const wchar_t *, const wchar_t *) = mg_wcscasecmp;\n\n\tmg_strlcpy(buf, path, sizeof(buf));\n\tchange_slashes_to_backslashes(buf);\n\n\t/* Convert to Unicode and back. If doubly-converted string does not\n\t * match the original, something is fishy, reject. */\n\tmemset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n\tMultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);\n\tWideCharToMultiByte(\n\t    CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);\n\tif (strcmp(buf, buf2) != 0) {\n\t\twbuf[0] = L'\\0';\n\t}\n\n\t/* Windows file systems are not case sensitive, but you can still use\n\t * uppercase and lowercase letters (on all modern file systems).\n\t * The server can check if the URI uses the same upper/lowercase\n\t * letters an the file system, effectively making Windows servers\n\t * case sensitive (like Linux servers are). It is still not possible\n\t * to use two files with the same name in different cases on Windows\n\t * (like /a and /A) - this would be possible in Linux.\n\t * As a default, Windows is not case sensitive, but the case sensitive\n\t * file name check can be activated by an additional configuration. */\n\tif (conn) {\n\t\tif (conn->dom_ctx->config[CASE_SENSITIVE_FILES]\n\t\t    && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],\n\t\t                      \"yes\")) {\n\t\t\t/* Use case sensitive compare function */\n\t\t\tfcompare = wcscmp;\n\t\t}\n\t}\n\t(void)conn; /* conn is currently unused */\n\n#if !defined(_WIN32_WCE)\n\t/* Only accept a full file path, not a Windows short (8.3) path. */\n\tmemset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));\n\tlong_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);\n\tif (long_len == 0) {\n\t\terr = GetLastError();\n\t\tif (err == ERROR_FILE_NOT_FOUND) {\n\t\t\t/* File does not exist. This is not always a problem here. */\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {\n\t\t/* Short name is used. */\n\t\twbuf[0] = L'\\0';\n\t}\n#else\n\t(void)long_len;\n\t(void)wbuf2;\n\t(void)err;\n\n\tif (strchr(path, '~')) {\n\t\twbuf[0] = L'\\0';\n\t}\n#endif\n}\n\n\n/* Windows happily opens files with some garbage at the end of file name.\n * For example, fopen(\"a.cgi    \", \"r\") on Windows successfully opens\n * \"a.cgi\", despite one would expect an error back.\n * This function returns non-0 if path ends with some garbage. */\nstatic int\npath_cannot_disclose_cgi(const char *path)\n{\n\tstatic const char *allowed_last_characters = \"_-\";\n\tint last = path[strlen(path) - 1];\n\treturn isalnum(last) || strchr(allowed_last_characters, last) != NULL;\n}\n\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tWIN32_FILE_ATTRIBUTE_DATA info;\n\ttime_t creation_time;\n\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\t\t/* filep->is_directory = 0; filep->gzipped = 0; .. already done by\n\t\t * memset */\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->location = 2;\n\t\t/* TODO: for 1.10: restructure how files in memory are handled */\n\n\t\t/* The \"file in memory\" feature is a candidate for deletion.\n\t\t * Please join the discussion at\n\t\t * https://groups.google.com/forum/#!topic/civetweb/h9HT4CmeYqI\n\t\t */\n\n\t\tfilep->last_modified = time(NULL); /* TODO */\n\t\t/* last_modified = now ... assumes the file may change during\n\t\t * runtime,\n\t\t * so every mg_fopen call may return different data */\n\t\t/* last_modified = conn->phys_ctx.start_time;\n\t\t * May be used it the data does not change during runtime. This\n\t\t * allows\n\t\t * browser caching. Since we do not know, we have to assume the file\n\t\t * in memory may change. */\n\t\treturn 1;\n\t}\n\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\tif (GetFileAttributesExW(wbuf, GetFileExInfoStandard, &info) != 0) {\n\t\tfilep->size = MAKEUQUAD(info.nFileSizeLow, info.nFileSizeHigh);\n\t\tfilep->last_modified =\n\t\t    SYS2UNIX_TIME(info.ftLastWriteTime.dwLowDateTime,\n\t\t                  info.ftLastWriteTime.dwHighDateTime);\n\n\t\t/* On Windows, the file creation time can be higher than the\n\t\t * modification time, e.g. when a file is copied.\n\t\t * Since the Last-Modified timestamp is used for caching\n\t\t * it should be based on the most recent timestamp. */\n\t\tcreation_time = SYS2UNIX_TIME(info.ftCreationTime.dwLowDateTime,\n\t\t                              info.ftCreationTime.dwHighDateTime);\n\t\tif (creation_time > filep->last_modified) {\n\t\t\tfilep->last_modified = creation_time;\n\t\t}\n\n\t\tfilep->is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;\n\t\t/* If file name is fishy, reset the file structure and return\n\t\t * error.\n\t\t * Note it is important to reset, not just return the error, cause\n\t\t * functions like is_file_opened() check the struct. */\n\t\tif (!filep->is_directory && !path_cannot_disclose_cgi(path)) {\n\t\t\tmemset(filep, 0, sizeof(*filep));\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nmg_remove(const struct mg_connection *conn, const char *path)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn DeleteFileW(wbuf) ? 0 : -1;\n}\n\n\nstatic int\nmg_mkdir(const struct mg_connection *conn, const char *path, int mode)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)mode;\n\tpath_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));\n\treturn CreateDirectoryW(wbuf, NULL) ? 0 : -1;\n}\n\n\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\n/* Implementation of POSIX opendir/closedir/readdir for Windows. */\nFUNCTION_MAY_BE_UNUSED\nstatic DIR *\nmg_opendir(const struct mg_connection *conn, const char *name)\n{\n\tDIR *dir = NULL;\n\twchar_t wpath[W_PATH_MAX];\n\tDWORD attrs;\n\n\tif (name == NULL) {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t} else if ((dir = (DIR *)mg_malloc(sizeof(*dir))) == NULL) {\n\t\tSetLastError(ERROR_NOT_ENOUGH_MEMORY);\n\t} else {\n\t\tpath_to_unicode(conn, name, wpath, ARRAY_SIZE(wpath));\n\t\tattrs = GetFileAttributesW(wpath);\n\t\tif ((wcslen(wpath) + 2 < ARRAY_SIZE(wpath)) && (attrs != 0xFFFFFFFF)\n\t\t    && ((attrs & FILE_ATTRIBUTE_DIRECTORY) != 0)) {\n\t\t\t(void)wcscat(wpath, L\"\\\\*\");\n\t\t\tdir->handle = FindFirstFileW(wpath, &dir->info);\n\t\t\tdir->result.d_name[0] = '\\0';\n\t\t} else {\n\t\t\tmg_free(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\treturn dir;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\nmg_closedir(DIR *dir)\n{\n\tint result = 0;\n\n\tif (dir != NULL) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE)\n\t\t\tresult = FindClose(dir->handle) ? 0 : -1;\n\n\t\tmg_free(dir);\n\t} else {\n\t\tresult = -1;\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic struct dirent *\nmg_readdir(DIR *dir)\n{\n\tstruct dirent *result = 0;\n\n\tif (dir) {\n\t\tif (dir->handle != INVALID_HANDLE_VALUE) {\n\t\t\tresult = &dir->result;\n\t\t\t(void)WideCharToMultiByte(CP_UTF8,\n\t\t\t                          0,\n\t\t\t                          dir->info.cFileName,\n\t\t\t                          -1,\n\t\t\t                          result->d_name,\n\t\t\t                          sizeof(result->d_name),\n\t\t\t                          NULL,\n\t\t\t                          NULL);\n\n\t\t\tif (!FindNextFileW(dir->handle, &dir->info)) {\n\t\t\t\t(void)FindClose(dir->handle);\n\t\t\t\tdir->handle = INVALID_HANDLE_VALUE;\n\t\t\t}\n\n\t\t} else {\n\t\t\tSetLastError(ERROR_FILE_NOT_FOUND);\n\t\t}\n\t} else {\n\t\tSetLastError(ERROR_BAD_ARGUMENTS);\n\t}\n\n\treturn result;\n}\n\n\n#if !defined(HAVE_POLL)\n#define POLLIN (1)  /* Data ready - read will not block. */\n#define POLLPRI (2) /* Priority data ready. */\n#define POLLOUT (4) /* Send queue not full - write will not block. */\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\npoll(struct pollfd *pfd, unsigned int n, int milliseconds)\n{\n\tstruct timeval tv;\n\tfd_set rset;\n\tfd_set wset;\n\tunsigned int i;\n\tint result;\n\tSOCKET maxfd = 0;\n\n\tmemset(&tv, 0, sizeof(tv));\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\tFD_ZERO(&rset);\n\tFD_ZERO(&wset);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (pfd[i].events & POLLIN) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &rset);\n\t\t} else if (pfd[i].events & POLLOUT) {\n\t\t\tFD_SET((SOCKET)pfd[i].fd, &wset);\n\t\t}\n\t\tpfd[i].revents = 0;\n\n\t\tif (pfd[i].fd > maxfd) {\n\t\t\tmaxfd = pfd[i].fd;\n\t\t}\n\t}\n\n\tif ((result = select((int)maxfd + 1, &rset, &wset, NULL, &tv)) > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (FD_ISSET(pfd[i].fd, &rset)) {\n\t\t\t\tpfd[i].revents |= POLLIN;\n\t\t\t}\n\t\t\tif (FD_ISSET(pfd[i].fd, &wset)) {\n\t\t\t\tpfd[i].revents |= POLLOUT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We should subtract the time used in select from remaining\n\t * \"milliseconds\", in particular if called from mg_poll with a\n\t * timeout quantum.\n\t * Unfortunately, the remaining time is not stored in \"tv\" in all\n\t * implementations, so the result in \"tv\" must be considered undefined.\n\t * See http://man7.org/linux/man-pages/man2/select.2.html */\n\n\treturn result;\n}\n#endif /* HAVE_POLL */\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic void\nset_close_on_exec(SOCKET sock, struct mg_connection *conn /* may be null */)\n{\n\t(void)conn; /* Unused. */\n#if defined(_WIN32_WCE)\n\t(void)sock;\n#else\n\t(void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);\n#endif\n}\n\n\nint\nmg_start_thread(mg_thread_func_t f, void *p)\n{\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size, e.g.\n\t * -DUSE_STACK_SIZE=16384\n\t */\n\treturn ((_beginthread((void(__cdecl *)(void *))f, USE_STACK_SIZE, p)\n\t         == ((uintptr_t)(-1L)))\n\t            ? -1\n\t            : 0);\n#else\n\treturn (\n\t    (_beginthread((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L)))\n\t        ? -1\n\t        : 0);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(unsigned(__stdcall *f)(void *),\n                        void *p,\n                        pthread_t *threadidptr)\n{\n\tuintptr_t uip;\n\tHANDLE threadhandle;\n\tint result = -1;\n\n\tuip = _beginthreadex(NULL, 0, (unsigned(__stdcall *)(void *))f, p, 0, NULL);\n\tthreadhandle = (HANDLE)uip;\n\tif ((uip != (uintptr_t)(-1L)) && (threadidptr != NULL)) {\n\t\t*threadidptr = threadhandle;\n\t\tresult = 0;\n\t}\n\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\tDWORD dwevent;\n\n\tresult = -1;\n\tdwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);\n\tif (dwevent == WAIT_FAILED) {\n\t\tDEBUG_TRACE(\"WaitForSingleObject() failed, error %d\", ERRNO);\n\t} else {\n\t\tif (dwevent == WAIT_OBJECT_0) {\n\t\t\tCloseHandle(threadid);\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n#if !defined(NO_SSL_DL) && !defined(NO_SSL)\n/* If SSL is loaded dynamically, dlopen/dlclose is required. */\n/* Create substitutes for POSIX functions in Win32. */\n\n#if defined(GCC_DIAGNOSTIC)\n/* Show no warning in case system functions are not used. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#endif\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic HANDLE\ndlopen(const char *dll_name, int flags)\n{\n\twchar_t wbuf[W_PATH_MAX];\n\t(void)flags;\n\tpath_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));\n\treturn LoadLibraryW(wbuf);\n}\n\n\nFUNCTION_MAY_BE_UNUSED\nstatic int\ndlclose(void *handle)\n{\n\tint result;\n\n\tif (FreeLibrary((HMODULE)handle) != 0) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable unused function warning again */\n#pragma GCC diagnostic pop\n#endif\n\n#endif\n\n\n#if !defined(NO_CGI)\n#define SIGKILL (0)\n\n\nstatic int\nkill(pid_t pid, int sig_num)\n{\n\t(void)TerminateProcess((HANDLE)pid, (UINT)sig_num);\n\t(void)CloseHandle((HANDLE)pid);\n\treturn 0;\n}\n\n\n#if !defined(WNOHANG)\n#define WNOHANG (1)\n#endif\n\n\nstatic pid_t\nwaitpid(pid_t pid, int *status, int flags)\n{\n\tDWORD timeout = INFINITE;\n\tDWORD waitres;\n\n\t(void)status; /* Currently not used by any client here */\n\n\tif ((flags | WNOHANG) == WNOHANG) {\n\t\ttimeout = 0;\n\t}\n\n\twaitres = WaitForSingleObject((HANDLE)pid, timeout);\n\tif (waitres == WAIT_OBJECT_0) {\n\t\treturn pid;\n\t}\n\tif (waitres == WAIT_TIMEOUT) {\n\t\treturn 0;\n\t}\n\treturn (pid_t)-1;\n}\n\n\nstatic void\ntrim_trailing_whitespaces(char *s)\n{\n\tchar *e = s + strlen(s) - 1;\n\twhile ((e > s) && isspace(*(unsigned char *)e)) {\n\t\t*e-- = '\\0';\n\t}\n}\n\n\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tHANDLE me;\n\tchar *p, *interp, full_interp[PATH_MAX], full_dir[PATH_MAX],\n\t    cmdline[PATH_MAX], buf[PATH_MAX];\n\tint truncated;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi = {0};\n\n\t(void)envp;\n\n\tmemset(&si, 0, sizeof(si));\n\tsi.cb = sizeof(si);\n\n\tsi.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n\tsi.wShowWindow = SW_HIDE;\n\n\tme = GetCurrentProcess();\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdin[0]),\n\t                me,\n\t                &si.hStdInput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fdout[1]),\n\t                me,\n\t                &si.hStdOutput,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\tDuplicateHandle(me,\n\t                (HANDLE)_get_osfhandle(fderr[1]),\n\t                me,\n\t                &si.hStdError,\n\t                0,\n\t                TRUE,\n\t                DUPLICATE_SAME_ACCESS);\n\n\t/* Mark handles that should not be inherited. See\n\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx\n\t */\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\tSetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),\n\t                     HANDLE_FLAG_INHERIT,\n\t                     0);\n\n\t/* If CGI file is a script, try to read the interpreter line */\n\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\tif (interp == NULL) {\n\t\tbuf[0] = buf[1] = '\\0';\n\n\t\t/* Read the first line of the script into the buffer */\n\t\tmg_snprintf(\n\t\t    conn, &truncated, cmdline, sizeof(cmdline), \"%s/%s\", dir, prog);\n\n\t\tif (truncated) {\n\t\t\tpi.hProcess = (pid_t)-1;\n\t\t\tgoto spawn_cleanup;\n\t\t}\n\n\t\tif (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tp = (char *)file.access.membuf;\n#else\n\t\t\tp = (char *)NULL;\n#endif\n\t\t\tmg_fgets(buf, sizeof(buf), &file, &p);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\t}\n\n\t\tif ((buf[0] == '#') && (buf[1] == '!')) {\n\t\t\ttrim_trailing_whitespaces(buf + 2);\n\t\t} else {\n\t\t\tbuf[2] = '\\0';\n\t\t}\n\t\tinterp = buf + 2;\n\t}\n\n\tif (interp[0] != '\\0') {\n\t\tGetFullPathNameA(interp, sizeof(full_interp), full_interp, NULL);\n\t\tinterp = full_interp;\n\t}\n\tGetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);\n\n\tif (interp[0] != '\\0') {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\" \\\"%s\\\\%s\\\"\",\n\t\t            interp,\n\t\t            full_dir,\n\t\t            prog);\n\t} else {\n\t\tmg_snprintf(conn,\n\t\t            &truncated,\n\t\t            cmdline,\n\t\t            sizeof(cmdline),\n\t\t            \"\\\"%s\\\\%s\\\"\",\n\t\t            full_dir,\n\t\t            prog);\n\t}\n\n\tif (truncated) {\n\t\tpi.hProcess = (pid_t)-1;\n\t\tgoto spawn_cleanup;\n\t}\n\n\tDEBUG_TRACE(\"Running [%s]\", cmdline);\n\tif (CreateProcessA(NULL,\n\t                   cmdline,\n\t                   NULL,\n\t                   NULL,\n\t                   TRUE,\n\t                   CREATE_NEW_PROCESS_GROUP,\n\t                   envblk,\n\t                   NULL,\n\t                   &si,\n\t                   &pi)\n\t    == 0) {\n\t\tmg_cry_internal(\n\t\t    conn, \"%s: CreateProcess(%s): %ld\", __func__, cmdline, (long)ERRNO);\n\t\tpi.hProcess = (pid_t)-1;\n\t\t/* goto spawn_cleanup; */\n\t}\n\nspawn_cleanup:\n\t(void)CloseHandle(si.hStdOutput);\n\t(void)CloseHandle(si.hStdError);\n\t(void)CloseHandle(si.hStdInput);\n\tif (pi.hThread != NULL) {\n\t\t(void)CloseHandle(pi.hThread);\n\t}\n\n\treturn (pid_t)pi.hProcess;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 0;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tunsigned long non_blocking = 1;\n\treturn ioctlsocket(sock, (long)FIONBIO, &non_blocking);\n}\n\n#else\n\nstatic int\nmg_stat(const struct mg_connection *conn,\n        const char *path,\n        struct mg_file_stat *filep)\n{\n\tstruct stat st;\n\tif (!filep) {\n\t\treturn 0;\n\t}\n\tmemset(filep, 0, sizeof(*filep));\n\n\tif (conn && is_file_in_memory(conn, path)) {\n\n\t\t/* Quick fix (for 1.9.x): */\n\t\t/* mg_stat must fill all fields, also for files in memory */\n\t\tstruct mg_file tmp_file = STRUCT_FILE_INITIALIZER;\n\t\topen_file_in_memory(conn, path, &tmp_file, MG_FOPEN_MODE_NONE);\n\t\tfilep->size = tmp_file.stat.size;\n\t\tfilep->last_modified = time(NULL);\n\t\tfilep->location = 2;\n\t\t/* TODO: remove legacy \"files in memory\" feature */\n\n\t\treturn 1;\n\t}\n\n\tif (0 == stat(path, &st)) {\n\t\tfilep->size = (uint64_t)(st.st_size);\n\t\tfilep->last_modified = st.st_mtime;\n\t\tfilep->is_directory = S_ISDIR(st.st_mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nset_close_on_exec(SOCKET fd, struct mg_connection *conn /* may be null */)\n{\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {\n\t\tif (conn) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nint\nmg_start_thread(mg_thread_func_t func, void *param)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\t(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\n\treturn result;\n}\n\n\n/* Start a thread storing the thread context. */\nstatic int\nmg_start_thread_with_id(mg_thread_func_t func,\n                        void *param,\n                        pthread_t *threadidptr)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\tint result;\n\n\t(void)pthread_attr_init(&attr);\n\n#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1)\n\t/* Compile-time option to control stack size,\n\t * e.g. -DUSE_STACK_SIZE=16384 */\n\t(void)pthread_attr_setstacksize(&attr, USE_STACK_SIZE);\n#endif /* defined(USE_STACK_SIZE) && USE_STACK_SIZE > 1 */\n\n\tresult = pthread_create(&thread_id, &attr, func, param);\n\tpthread_attr_destroy(&attr);\n\tif ((result == 0) && (threadidptr != NULL)) {\n\t\t*threadidptr = thread_id;\n\t}\n\treturn result;\n}\n\n\n/* Wait for a thread to finish. */\nstatic int\nmg_join_thread(pthread_t threadid)\n{\n\tint result;\n\n\tresult = pthread_join(threadid, NULL);\n\treturn result;\n}\n\n\n#if !defined(NO_CGI)\nstatic pid_t\nspawn_process(struct mg_connection *conn,\n              const char *prog,\n              char *envblk,\n              char *envp[],\n              int fdin[2],\n              int fdout[2],\n              int fderr[2],\n              const char *dir)\n{\n\tpid_t pid;\n\tconst char *interp;\n\n\t(void)envblk;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif ((pid = fork()) == -1) {\n\t\t/* Parent */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Creating CGI process\\nfork(): %s\",\n\t\t                   strerror(ERRNO));\n\t} else if (pid == 0) {\n\t\t/* Child */\n\t\tif (chdir(dir) != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn, \"%s: chdir(%s): %s\", __func__, dir, strerror(ERRNO));\n\t\t} else if (dup2(fdin[0], 0) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 0): %s\",\n\t\t\t                __func__,\n\t\t\t                fdin[0],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fdout[1], 1) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 1): %s\",\n\t\t\t                __func__,\n\t\t\t                fdout[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else if (dup2(fderr[1], 2) == -1) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: dup2(%d, 2): %s\",\n\t\t\t                __func__,\n\t\t\t                fderr[1],\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\t/* Keep stderr and stdout in two different pipes.\n\t\t\t * Stdout will be sent back to the client,\n\t\t\t * stderr should go into a server error log. */\n\t\t\t(void)close(fdin[0]);\n\t\t\t(void)close(fdout[1]);\n\t\t\t(void)close(fderr[1]);\n\n\t\t\t/* Close write end fdin and read end fdout and fderr */\n\t\t\t(void)close(fdin[1]);\n\t\t\t(void)close(fdout[0]);\n\t\t\t(void)close(fderr[0]);\n\n\t\t\t/* After exec, all signal handlers are restored to their default\n\t\t\t * values, with one exception of SIGCHLD. According to\n\t\t\t * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler\n\t\t\t * will leave unchanged after exec if it was set to be ignored.\n\t\t\t * Restore it to default action. */\n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\n\t\t\tinterp = conn->dom_ctx->config[CGI_INTERPRETER];\n\t\t\tif (interp == NULL) {\n\t\t\t\t(void)execle(prog, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t} else {\n\t\t\t\t(void)execle(interp, interp, prog, NULL, envp);\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: execle(%s %s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                interp,\n\t\t\t\t                prog,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn pid;\n}\n#endif /* !NO_CGI */\n\n\nstatic int\nset_non_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nset_blocking_mode(SOCKET sock)\n{\n\tint flags = fcntl(sock, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn -1;\n\t}\n\n\tif (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif /* _WIN32 / else */\n\n/* End of initial operating system specific define block. */\n\n\n/* Get a random number (independent of C rand function) */\nstatic uint64_t\nget_random(void)\n{\n\tstatic uint64_t lfsr = 0; /* Linear feedback shift register */\n\tstatic uint64_t lcg = 0;  /* Linear congruential generator */\n\tuint64_t now = mg_get_current_time_ns();\n\n\tif (lfsr == 0) {\n\t\t/* lfsr will be only 0 if has not been initialized,\n\t\t * so this code is called only once. */\n\t\tlfsr = mg_get_current_time_ns();\n\t\tlcg = mg_get_current_time_ns();\n\t} else {\n\t\t/* Get the next step of both random number generators. */\n\t\tlfsr = (lfsr >> 1)\n\t\t       | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1)\n\t\t          << 63);\n\t\tlcg = lcg * 6364136223846793005LL + 1442695040888963407LL;\n\t}\n\n\t/* Combining two pseudo-random number generators and a high resolution\n\t * part\n\t * of the current server time will make it hard (impossible?) to guess\n\t * the\n\t * next number. */\n\treturn (lfsr ^ lcg ^ now);\n}\n\n\nstatic int\nmg_poll(struct pollfd *pfd,\n        unsigned int n,\n        int milliseconds,\n        volatile int *stop_server)\n{\n\t/* Call poll, but only for a maximum time of a few seconds.\n\t * This will allow to stop the server after some seconds, instead\n\t * of having to wait for a long socket timeout. */\n\tint ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n\tdo {\n\t\tint result;\n\n\t\tif (*stop_server) {\n\t\t\t/* Shut down signal */\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((milliseconds >= 0) && (milliseconds < ms_now)) {\n\t\t\tms_now = milliseconds;\n\t\t}\n\n\t\tresult = poll(pfd, n, ms_now);\n\t\tif (result != 0) {\n\t\t\t/* Poll returned either success (1) or error (-1).\n\t\t\t * Forward both to the caller. */\n\t\t\treturn result;\n\t\t}\n\n\t\t/* Poll returned timeout (0). */\n\t\tif (milliseconds > 0) {\n\t\t\tmilliseconds -= ms_now;\n\t\t}\n\n\t} while (milliseconds != 0);\n\n\t/* timeout: return 0 */\n\treturn 0;\n}\n\n\n/* Write data to the IO channel - opened file descriptor, socket or SSL\n * descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully written\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npush_inner(struct mg_context *ctx,\n           FILE *fp,\n           SOCKET sock,\n           SSL *ssl,\n           const char *buf,\n           int len,\n           double timeout)\n{\n\tuint64_t start = 0, now = 0, timeout_ns = 0;\n\tint n, err;\n\tunsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n\n\tif (timeout > 0) {\n\t\tnow = mg_get_current_time_ns();\n\t\tstart = now;\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\tif (ctx == NULL) {\n\t\treturn -2;\n\t}\n\n#if defined(NO_SSL)\n\tif (ssl) {\n\t\treturn -2;\n\t}\n#endif\n\n\t/* Try to read until it succeeds, fails, times out, or the server\n\t * shuts down. */\n\tfor (;;) {\n\n#if !defined(NO_SSL)\n\t\tif (ssl != NULL) {\n\t\t\tn = SSL_write(ssl, buf, len);\n\t\t\tif (n <= 0) {\n\t\t\t\terr = SSL_get_error(ssl, n);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (n == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tn = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_write() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else\n#endif\n\t\t    if (fp != NULL) {\n\t\t\tn = (int)fwrite(buf, 1, (size_t)len, fp);\n\t\t\tif (ferror(fp)) {\n\t\t\t\tn = -1;\n\t\t\t\terr = ERRNO;\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);\n\t\t\terr = (n < 0) ? ERRNO : 0;\n#if defined(_WIN32)\n\t\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#else\n\t\t\tif (err == EWOULDBLOCK) {\n\t\t\t\terr = 0;\n\t\t\t\tn = 0;\n\t\t\t}\n#endif\n\t\t\tif (n < 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\n\t\tif ((n > 0) || ((n == 0) && (len == 0))) {\n\t\t\t/* some data has been read, or no data was requested */\n\t\t\treturn n;\n\t\t}\n\t\tif (n < 0) {\n\t\t\t/* socket error - check errno */\n\t\t\tDEBUG_TRACE(\"send() failed, error %d\", err);\n\n\t\t\t/* TODO (mid): error handling depending on the error code.\n\t\t\t * These codes are different between Windows and Linux.\n\t\t\t * Currently there is no problem with failing send calls,\n\t\t\t * if there is a reproducible situation, it should be\n\t\t\t * investigated in detail.\n\t\t\t */\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* Only in case n=0 (timeout), repeat calling the write function */\n\n\t\t/* If send failed, wait before retry */\n\t\tif (fp != NULL) {\n\t\t\t/* For files, just wait a fixed time.\n\t\t\t * Maybe it helps, maybe not. */\n\t\t\tmg_sleep(5);\n\t\t} else {\n\t\t\t/* For sockets, wait for the socket using poll */\n\t\t\tstruct pollfd pfd[1];\n\t\t\tint pollres;\n\n\t\t\tpfd[0].fd = sock;\n\t\t\tpfd[0].events = POLLOUT;\n\t\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\t\t\tif (ctx->stop_flag) {\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif (pollres > 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout > 0) {\n\t\t\tnow = mg_get_current_time_ns();\n\t\t\tif ((now - start) > timeout_ns) {\n\t\t\t\t/* Timeout */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t(void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not\n\t              used */\n\n\treturn -1;\n}\n\n\nstatic int64_t\npush_all(struct mg_context *ctx,\n         FILE *fp,\n         SOCKET sock,\n         SSL *ssl,\n         const char *buf,\n         int64_t len)\n{\n\tdouble timeout = -1.0;\n\tint64_t n, nwritten = 0;\n\n\tif (ctx == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (ctx->dd.config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\twhile ((len > 0) && (ctx->stop_flag == 0)) {\n\t\tn = push_inner(ctx, fp, sock, ssl, buf + nwritten, (int)len, timeout);\n\t\tif (n < 0) {\n\t\t\tif (nwritten == 0) {\n\t\t\t\tnwritten = n; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to write */\n\t\t} else {\n\t\t\tnwritten += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nwritten;\n}\n\n\n/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.\n * Return value:\n *  >=0 .. number of bytes successfully read\n *   -1 .. timeout\n *   -2 .. error\n */\nstatic int\npull_inner(FILE *fp,\n           struct mg_connection *conn,\n           char *buf,\n           int len,\n           double timeout)\n{\n\tint nread, err = 0;\n\n#if defined(_WIN32)\n\ttypedef int len_t;\n#else\n\ttypedef size_t len_t;\n#endif\n#if !defined(NO_SSL)\n\tint ssl_pending;\n#endif\n\n\t/* We need an additional wait loop around this, because in some cases\n\t * with TLSwe may get data from the socket but not from SSL_read.\n\t * In this case we need to repeat at least once.\n\t */\n\n\tif (fp != NULL) {\n#if !defined(_WIN32_WCE)\n\t\t/* Use read() instead of fread(), because if we're reading from the\n\t\t * CGI pipe, fread() may block until IO buffer is filled up. We\n\t\t * cannot afford to block and must pass all read bytes immediately\n\t\t * to the client. */\n\t\tnread = (int)read(fileno(fp), buf, (size_t)len);\n#else\n\t\t/* WinCE does not support CGI pipes */\n\t\tnread = (int)fread(buf, 1, (size_t)len, fp);\n#endif\n\t\terr = (nread < 0) ? ERRNO : 0;\n\t\tif ((nread == 0) && (len > 0)) {\n\t\t\t/* Should get data, but got EOL */\n\t\t\treturn -2;\n\t\t}\n\n#if !defined(NO_SSL)\n\t} else if ((conn->ssl != NULL)\n\t           && ((ssl_pending = SSL_pending(conn->ssl)) > 0)) {\n\t\t/* We already know there is no more data buffered in conn->buf\n\t\t * but there is more available in the SSL layer. So don't poll\n\t\t * conn->client.sock yet. */\n\t\tif (ssl_pending > len) {\n\t\t\tssl_pending = len;\n\t\t}\n\t\tnread = SSL_read(conn->ssl, buf, ssl_pending);\n\t\tif (nread <= 0) {\n\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\terr = ERRNO;\n\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tnread = 0;\n\t\t\t} else {\n\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\terr = 0;\n\t\t}\n\n\t} else if (conn->ssl != NULL) {\n\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = SSL_read(conn->ssl, buf, len);\n\t\t\tif (nread <= 0) {\n\t\t\t\terr = SSL_get_error(conn->ssl, nread);\n\t\t\t\tif ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {\n\t\t\t\t\terr = ERRNO;\n\t\t\t\t} else if ((err == SSL_ERROR_WANT_READ)\n\t\t\t\t           || (err == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\t\tnread = 0;\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG_TRACE(\"SSL_read() failed, error %d\", err);\n\t\t\t\t\treturn -2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = 0;\n\t\t\t}\n\n\t\t} else if (pollres < 0) {\n\t\t\t/* Error */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n#endif\n\n\t} else {\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\n\t\tpfd[0].fd = conn->client.sock;\n\t\tpfd[0].events = POLLIN;\n\t\tpollres = mg_poll(pfd,\n\t\t                  1,\n\t\t                  (int)(timeout * 1000.0),\n\t\t                  &(conn->phys_ctx->stop_flag));\n\t\tif (conn->phys_ctx->stop_flag) {\n\t\t\treturn -2;\n\t\t}\n\t\tif (pollres > 0) {\n\t\t\tnread = (int)recv(conn->client.sock, buf, (len_t)len, 0);\n\t\t\terr = (nread < 0) ? ERRNO : 0;\n\t\t\tif (nread <= 0) {\n\t\t\t\t/* shutdown of the socket at client side */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} else if (pollres < 0) {\n\t\t\t/* error callint poll */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/* pollres = 0 means timeout */\n\t\t\tnread = 0;\n\t\t}\n\t}\n\n\tif (conn->phys_ctx->stop_flag) {\n\t\treturn -2;\n\t}\n\n\tif ((nread > 0) || ((nread == 0) && (len == 0))) {\n\t\t/* some data has been read, or no data was requested */\n\t\treturn nread;\n\t}\n\n\tif (nread < 0) {\n/* socket error - check errno */\n#if defined(_WIN32)\n\t\tif (err == WSAEWOULDBLOCK) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* standard case if called from close_socket_gracefully */\n\t\t\treturn -2;\n\t\t} else if (err == WSAETIMEDOUT) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* timeout is handled by the while loop  */\n\t\t\treturn 0;\n\t\t} else if (err == WSAECONNABORTED) {\n\t\t\t/* See https://www.chilkatsoft.com/p/p_299.asp */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#else\n\t\t/* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,\n\t\t * if the timeout is reached and if the socket was set to non-\n\t\t * blocking in close_socket_gracefully, so we can not distinguish\n\t\t * here. We have to wait for the timeout in both cases for now.\n\t\t */\n\t\tif ((err == EAGAIN) || (err == EWOULDBLOCK) || (err == EINTR)) {\n\t\t\t/* TODO (low): check if this is still required */\n\t\t\t/* EAGAIN/EWOULDBLOCK:\n\t\t\t * standard case if called from close_socket_gracefully\n\t\t\t * => should return -1 */\n\t\t\t/* or timeout occurred\n\t\t\t * => the code must stay in the while loop */\n\n\t\t\t/* EINTR can be generated on a socket with a timeout set even\n\t\t\t * when SA_RESTART is effective for all relevant signals\n\t\t\t * (see signal(7)).\n\t\t\t * => stay in the while loop */\n\t\t} else {\n\t\t\tDEBUG_TRACE(\"recv() failed, error %d\", err);\n\t\t\treturn -2;\n\t\t}\n#endif\n\t}\n\n\t/* Timeout occurred, but no data available. */\n\treturn -1;\n}\n\n\nstatic int\npull_all(FILE *fp, struct mg_connection *conn, char *buf, int len)\n{\n\tint n, nread = 0;\n\tdouble timeout = -1.0;\n\tuint64_t start_time = 0, now = 0, timeout_ns = 0;\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\tif (timeout >= 0.0) {\n\t\tstart_time = mg_get_current_time_ns();\n\t\ttimeout_ns = (uint64_t)(timeout * 1.0E9);\n\t}\n\n\twhile ((len > 0) && (conn->phys_ctx->stop_flag == 0)) {\n\t\tn = pull_inner(fp, conn, buf + nread, len, timeout);\n\t\tif (n == -2) {\n\t\t\tif (nread == 0) {\n\t\t\t\tnread = -1; /* Propagate the error */\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == -1) {\n\t\t\t/* timeout */\n\t\t\tif (timeout >= 0.0) {\n\t\t\t\tnow = mg_get_current_time_ns();\n\t\t\t\tif ((now - start_time) <= timeout_ns) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (n == 0) {\n\t\t\tbreak; /* No more data to read */\n\t\t} else {\n\t\t\tconn->consumed_content += n;\n\t\t\tnread += n;\n\t\t\tlen -= n;\n\t\t}\n\t}\n\n\treturn nread;\n}\n\n\nstatic void\ndiscard_unread_request_data(struct mg_connection *conn)\n{\n\tchar buf[MG_BUF_LEN];\n\tsize_t to_read;\n\tint nread;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tto_read = sizeof(buf);\n\n\tif (conn->is_chunked) {\n\t\t/* Chunked encoding: 3=chunk read completely\n\t\t * completely */\n\t\twhile (conn->is_chunked != 3) {\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* Not chunked: content length is known */\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tif (to_read\n\t\t\t    > (size_t)(conn->content_len - conn->consumed_content)) {\n\t\t\t\tto_read = (size_t)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\n\t\t\tnread = mg_read(conn, buf, to_read);\n\t\t\tif (nread <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nmg_read_inner(struct mg_connection *conn, void *buf, size_t len)\n{\n\tint64_t n, buffered_len, nread;\n\tint64_t len64 =\n\t    (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is\n\t                                                 * int, we may not read more\n\t                                                 * bytes */\n\tconst char *body;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* If Content-Length is not set for a request with body data\n\t * (e.g., a PUT or POST request), we do not know in advance\n\t * how much data should be read. */\n\tif (conn->consumed_content == 0) {\n\t\tif (conn->is_chunked == 1) {\n\t\t\tconn->content_len = len64;\n\t\t\tconn->is_chunked = 2;\n\t\t} else if (conn->content_len == -1) {\n\t\t\t/* The body data is completed when the connection\n\t\t\t * is closed. */\n\t\t\tconn->content_len = INT64_MAX;\n\t\t\tconn->must_close = 1;\n\t\t}\n\t}\n\n\tnread = 0;\n\tif (conn->consumed_content < conn->content_len) {\n\t\t/* Adjust number of bytes to read. */\n\t\tint64_t left_to_read = conn->content_len - conn->consumed_content;\n\t\tif (left_to_read < len64) {\n\t\t\t/* Do not read more than the total content length of the\n\t\t\t * request.\n\t\t\t */\n\t\t\tlen64 = left_to_read;\n\t\t}\n\n\t\t/* Return buffered data */\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\t\tif (buffered_len > 0) {\n\t\t\tif (len64 < buffered_len) {\n\t\t\t\tbuffered_len = len64;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tmemcpy(buf, body, (size_t)buffered_len);\n\t\t\tlen64 -= buffered_len;\n\t\t\tconn->consumed_content += buffered_len;\n\t\t\tnread += buffered_len;\n\t\t\tbuf = (char *)buf + buffered_len;\n\t\t}\n\n\t\t/* We have returned all buffered data. Read new data from the remote\n\t\t * socket.\n\t\t */\n\t\tif ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {\n\t\t\tnread += n;\n\t\t} else {\n\t\t\tnread = ((nread > 0) ? nread : n);\n\t\t}\n\t}\n\treturn (int)nread;\n}\n\n\nstatic char\nmg_getc(struct mg_connection *conn)\n{\n\tchar c;\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\tif (mg_read_inner(conn, &c, 1) <= 0) {\n\t\treturn (char)0;\n\t}\n\treturn c;\n}\n\n\nint\nmg_read(struct mg_connection *conn, void *buf, size_t len)\n{\n\tif (len > INT_MAX) {\n\t\tlen = INT_MAX;\n\t}\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->is_chunked) {\n\t\tsize_t all_read = 0;\n\n\t\twhile (len > 0) {\n\t\t\tif (conn->is_chunked == 3) {\n\t\t\t\t/* No more data left to read */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (conn->chunk_remainder) {\n\t\t\t\t/* copy from the remainder of the last received chunk */\n\t\t\t\tlong read_ret;\n\t\t\t\tsize_t read_now =\n\t\t\t\t    ((conn->chunk_remainder > len) ? (len)\n\t\t\t\t                                   : (conn->chunk_remainder));\n\n\t\t\t\tconn->content_len += (int)read_now;\n\t\t\t\tread_ret =\n\t\t\t\t    mg_read_inner(conn, (char *)buf + all_read, read_now);\n\n\t\t\t\tif (read_ret < 1) {\n\t\t\t\t\t/* read error */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tall_read += (size_t)read_ret;\n\t\t\t\tconn->chunk_remainder -= (size_t)read_ret;\n\t\t\t\tlen -= (size_t)read_ret;\n\n\t\t\t\tif (conn->chunk_remainder == 0) {\n\t\t\t\t\t/* Add data bytes in the current chunk have been read,\n\t\t\t\t\t * so we are expecting \\r\\n now. */\n\t\t\t\t\tchar x1, x2;\n\t\t\t\t\tconn->content_len += 2;\n\t\t\t\t\tx1 = mg_getc(conn);\n\t\t\t\t\tx2 = mg_getc(conn);\n\t\t\t\t\tif ((x1 != '\\r') || (x2 != '\\n')) {\n\t\t\t\t\t\t/* Protocol violation */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* fetch a new chunk */\n\t\t\t\tint i = 0;\n\t\t\t\tchar lenbuf[64];\n\t\t\t\tchar *end = 0;\n\t\t\t\tunsigned long chunkSize = 0;\n\n\t\t\t\tfor (i = 0; i < ((int)sizeof(lenbuf) - 1); i++) {\n\t\t\t\t\tconn->content_len++;\n\t\t\t\t\tlenbuf[i] = mg_getc(conn);\n\t\t\t\t\tif ((i > 0) && (lenbuf[i] == '\\r')\n\t\t\t\t\t    && (lenbuf[i - 1] != '\\r')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((i > 1) && (lenbuf[i] == '\\n')\n\t\t\t\t\t    && (lenbuf[i - 1] == '\\r')) {\n\t\t\t\t\t\tlenbuf[i + 1] = 0;\n\t\t\t\t\t\tchunkSize = strtoul(lenbuf, &end, 16);\n\t\t\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\t\t\t/* regular end of content */\n\t\t\t\t\t\t\tconn->is_chunked = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isxdigit(lenbuf[i])) {\n\t\t\t\t\t\t/* illegal character for chunk length */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((end == NULL) || (*end != '\\r')) {\n\t\t\t\t\t/* chunksize not set correctly */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (chunkSize == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->chunk_remainder = chunkSize;\n\t\t\t}\n\t\t}\n\n\t\treturn (int)all_read;\n\t}\n\treturn mg_read_inner(conn, buf, len);\n}\n\n\nint\nmg_write(struct mg_connection *conn, const void *buf, size_t len)\n{\n\ttime_t now;\n\tint64_t n, total, allowed;\n\n\tif (conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (conn->throttle > 0) {\n\t\tif ((now = time(NULL)) != conn->last_throttle_time) {\n\t\t\tconn->last_throttle_time = now;\n\t\t\tconn->last_throttle_bytes = 0;\n\t\t}\n\t\tallowed = conn->throttle - conn->last_throttle_bytes;\n\t\tif (allowed > (int64_t)len) {\n\t\t\tallowed = (int64_t)len;\n\t\t}\n\t\tif ((total = push_all(conn->phys_ctx,\n\t\t                      NULL,\n\t\t                      conn->client.sock,\n\t\t                      conn->ssl,\n\t\t                      (const char *)buf,\n\t\t                      (int64_t)allowed))\n\t\t    == allowed) {\n\t\t\tbuf = (const char *)buf + total;\n\t\t\tconn->last_throttle_bytes += total;\n\t\t\twhile ((total < (int64_t)len) && (conn->phys_ctx->stop_flag == 0)) {\n\t\t\t\tallowed = (conn->throttle > ((int64_t)len - total))\n\t\t\t\t              ? (int64_t)len - total\n\t\t\t\t              : conn->throttle;\n\t\t\t\tif ((n = push_all(conn->phys_ctx,\n\t\t\t\t                  NULL,\n\t\t\t\t                  conn->client.sock,\n\t\t\t\t                  conn->ssl,\n\t\t\t\t                  (const char *)buf,\n\t\t\t\t                  (int64_t)allowed))\n\t\t\t\t    != allowed) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t\tconn->last_throttle_bytes = allowed;\n\t\t\t\tconn->last_throttle_time = time(NULL);\n\t\t\t\tbuf = (const char *)buf + n;\n\t\t\t\ttotal += n;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttotal = push_all(conn->phys_ctx,\n\t\t                 NULL,\n\t\t                 conn->client.sock,\n\t\t                 conn->ssl,\n\t\t                 (const char *)buf,\n\t\t                 (int64_t)len);\n\t}\n\tif (total > 0) {\n\t\tconn->num_bytes_sent += total;\n\t}\n\treturn (int)total;\n}\n\n\n/* Send a chunk, if \"Transfer-Encoding: chunked\" is used */\nint\nmg_send_chunk(struct mg_connection *conn,\n              const char *chunk,\n              unsigned int chunk_len)\n{\n\tchar lenbuf[16];\n\tsize_t lenbuf_len;\n\tint ret;\n\tint t;\n\n\t/* First store the length information in a text buffer. */\n\tsprintf(lenbuf, \"%x\\r\\n\", chunk_len);\n\tlenbuf_len = strlen(lenbuf);\n\n\t/* Then send length information, chunk and terminating \\r\\n. */\n\tret = mg_write(conn, lenbuf, lenbuf_len);\n\tif (ret != (int)lenbuf_len) {\n\t\treturn -1;\n\t}\n\tt = ret;\n\n\tret = mg_write(conn, chunk, chunk_len);\n\tif (ret != (int)chunk_len) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\tret = mg_write(conn, \"\\r\\n\", 2);\n\tif (ret != 2) {\n\t\treturn -1;\n\t}\n\tt += ret;\n\n\treturn t;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* This block forwards format strings to printf implementations,\n * so we need to disable the format-nonliteral warning. */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\n/* Alternative alloc_vprintf() for non-compliant C runtimes */\nstatic int\nalloc_vprintf2(char **buf, const char *fmt, va_list ap)\n{\n\tva_list ap_copy;\n\tsize_t size = MG_BUF_LEN / 4;\n\tint len = -1;\n\n\t*buf = NULL;\n\twhile (len < 0) {\n\t\tif (*buf) {\n\t\t\tmg_free(*buf);\n\t\t}\n\n\t\tsize *= 4;\n\t\t*buf = (char *)mg_malloc(size);\n\t\tif (!*buf) {\n\t\t\tbreak;\n\t\t}\n\n\t\tva_copy(ap_copy, ap);\n\t\tlen = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\t\t(*buf)[size - 1] = 0;\n\t}\n\n\treturn len;\n}\n\n\n/* Print message to buffer. If buffer is large enough to hold the message,\n * return buffer. If buffer is to small, allocate large enough buffer on\n * heap,\n * and return allocated buffer. */\nstatic int\nalloc_vprintf(char **out_buf,\n              char *prealloc_buf,\n              size_t prealloc_size,\n              const char *fmt,\n              va_list ap)\n{\n\tva_list ap_copy;\n\tint len;\n\n\t/* Windows is not standard-compliant, and vsnprintf() returns -1 if\n\t * buffer is too small. Also, older versions of msvcrt.dll do not have\n\t * _vscprintf().  However, if size is 0, vsnprintf() behaves correctly.\n\t * Therefore, we make two passes: on first pass, get required message\n\t * length.\n\t * On second pass, actually print the message. */\n\tva_copy(ap_copy, ap);\n\tlen = vsnprintf_impl(NULL, 0, fmt, ap_copy);\n\tva_end(ap_copy);\n\n\tif (len < 0) {\n\t\t/* C runtime is not standard compliant, vsnprintf() returned -1.\n\t\t * Switch to alternative code path that uses incremental\n\t\t * allocations.\n\t\t */\n\t\tva_copy(ap_copy, ap);\n\t\tlen = alloc_vprintf2(out_buf, fmt, ap_copy);\n\t\tva_end(ap_copy);\n\n\t} else if ((size_t)(len) >= prealloc_size) {\n\t\t/* The pre-allocated buffer not large enough. */\n\t\t/* Allocate a new buffer. */\n\t\t*out_buf = (char *)mg_malloc((size_t)(len) + 1);\n\t\tif (!*out_buf) {\n\t\t\t/* Allocation failed. Return -1 as \"out of memory\" error. */\n\t\t\treturn -1;\n\t\t}\n\t\t/* Buffer allocation successful. Store the string there. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\n\t} else {\n\t\t/* The pre-allocated buffer is large enough.\n\t\t * Use it to store the string and return the address. */\n\t\tva_copy(ap_copy, ap);\n\t\tIGNORE_UNUSED_RESULT(\n\t\t    vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));\n\t\tva_end(ap_copy);\n\t\t*out_buf = prealloc_buf;\n\t}\n\n\treturn len;\n}\n\n\n#if defined(GCC_DIAGNOSTIC)\n/* Enable format-nonliteral warning again. */\n#pragma GCC diagnostic pop\n#endif\n\n\nstatic int\nmg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap)\n{\n\tchar mem[MG_BUF_LEN];\n\tchar *buf = NULL;\n\tint len;\n\n\tif ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {\n\t\tlen = mg_write(conn, buf, (size_t)len);\n\t}\n\tif ((buf != mem) && (buf != NULL)) {\n\t\tmg_free(buf);\n\t}\n\n\treturn len;\n}\n\n\nint\nmg_printf(struct mg_connection *conn, const char *fmt, ...)\n{\n\tva_list ap;\n\tint result;\n\n\tva_start(ap, fmt);\n\tresult = mg_vprintf(conn, fmt, ap);\n\tva_end(ap);\n\n\treturn result;\n}\n\n\nint\nmg_url_decode(const char *src,\n              int src_len,\n              char *dst,\n              int dst_len,\n              int is_form_url_encoded)\n{\n\tint i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? (x - '0') : (x - 'W'))\n\n\tfor (i = j = 0; (i < src_len) && (j < (dst_len - 1)); i++, j++) {\n\t\tif ((i < src_len - 2) && (src[i] == '%')\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 1))\n\t\t    && isxdigit(*(const unsigned char *)(src + i + 2))) {\n\t\t\ta = tolower(*(const unsigned char *)(src + i + 1));\n\t\t\tb = tolower(*(const unsigned char *)(src + i + 2));\n\t\t\tdst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));\n\t\t\ti += 2;\n\t\t} else if (is_form_url_encoded && (src[i] == '+')) {\n\t\t\tdst[j] = ' ';\n\t\t} else {\n\t\t\tdst[j] = src[i];\n\t\t}\n\t}\n\n\tdst[j] = '\\0'; /* Null-terminate the destination */\n\n\treturn (i >= src_len) ? j : -1;\n}\n\n\nint\nmg_get_var(const char *data,\n           size_t data_len,\n           const char *name,\n           char *dst,\n           size_t dst_len)\n{\n\treturn mg_get_var2(data, data_len, name, dst, dst_len, 0);\n}\n\n\nint\nmg_get_var2(const char *data,\n            size_t data_len,\n            const char *name,\n            char *dst,\n            size_t dst_len,\n            size_t occurrence)\n{\n\tconst char *p, *e, *s;\n\tsize_t name_len;\n\tint len;\n\n\tif ((dst == NULL) || (dst_len == 0)) {\n\t\tlen = -2;\n\t} else if ((data == NULL) || (name == NULL) || (data_len == 0)) {\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\t} else {\n\t\tname_len = strlen(name);\n\t\te = data + data_len;\n\t\tlen = -1;\n\t\tdst[0] = '\\0';\n\n\t\t/* data is \"var1=val1&var2=val2...\". Find variable first */\n\t\tfor (p = data; p + name_len < e; p++) {\n\t\t\tif (((p == data) || (p[-1] == '&')) && (p[name_len] == '=')\n\t\t\t    && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {\n\t\t\t\t/* Point p to variable value */\n\t\t\t\tp += name_len + 1;\n\n\t\t\t\t/* Point s to the end of the value */\n\t\t\t\ts = (const char *)memchr(p, '&', (size_t)(e - p));\n\t\t\t\tif (s == NULL) {\n\t\t\t\t\ts = e;\n\t\t\t\t}\n\t\t\t\tDEBUG_ASSERT(s >= p);\n\t\t\t\tif (s < p) {\n\t\t\t\t\treturn -3;\n\t\t\t\t}\n\n\t\t\t\t/* Decode variable into destination buffer */\n\t\t\t\tlen = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);\n\n\t\t\t\t/* Redirect error code from -1 to -2 (destination buffer too\n\t\t\t\t * small). */\n\t\t\t\tif (len == -1) {\n\t\t\t\t\tlen = -2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn len;\n}\n\n\n/* HCP24: some changes to compare hole var_name */\nint\nmg_get_cookie(const char *cookie_header,\n              const char *var_name,\n              char *dst,\n              size_t dst_size)\n{\n\tconst char *s, *p, *end;\n\tint name_len, len = -1;\n\n\tif ((dst == NULL) || (dst_size == 0)) {\n\t\treturn -2;\n\t}\n\n\tdst[0] = '\\0';\n\tif ((var_name == NULL) || ((s = cookie_header) == NULL)) {\n\t\treturn -1;\n\t}\n\n\tname_len = (int)strlen(var_name);\n\tend = s + strlen(s);\n\tfor (; (s = mg_strcasestr(s, var_name)) != NULL; s += name_len) {\n\t\tif (s[name_len] == '=') {\n\t\t\t/* HCP24: now check is it a substring or a full cookie name */\n\t\t\tif ((s == cookie_header) || (s[-1] == ' ')) {\n\t\t\t\ts += name_len + 1;\n\t\t\t\tif ((p = strchr(s, ' ')) == NULL) {\n\t\t\t\t\tp = end;\n\t\t\t\t}\n\t\t\t\tif (p[-1] == ';') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((*s == '\"') && (p[-1] == '\"') && (p > s + 1)) {\n\t\t\t\t\ts++;\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tif ((size_t)(p - s) < dst_size) {\n\t\t\t\t\tlen = (int)(p - s);\n\t\t\t\t\tmg_strlcpy(dst, s, (size_t)len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlen = -3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn len;\n}\n\n\n#if defined(USE_WEBSOCKET) || defined(USE_LUA)\nstatic void\nbase64_encode(const unsigned char *src, int src_len, char *dst)\n{\n\tstatic const char *b64 =\n\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tint i, j, a, b, c;\n\n\tfor (i = j = 0; i < src_len; i += 3) {\n\t\ta = src[i];\n\t\tb = ((i + 1) >= src_len) ? 0 : src[i + 1];\n\t\tc = ((i + 2) >= src_len) ? 0 : src[i + 2];\n\n\t\tdst[j++] = b64[a >> 2];\n\t\tdst[j++] = b64[((a & 3) << 4) | (b >> 4)];\n\t\tif (i + 1 < src_len) {\n\t\t\tdst[j++] = b64[(b & 15) << 2 | (c >> 6)];\n\t\t}\n\t\tif (i + 2 < src_len) {\n\t\t\tdst[j++] = b64[c & 63];\n\t\t}\n\t}\n\twhile (j % 4 != 0) {\n\t\tdst[j++] = '=';\n\t}\n\tdst[j++] = '\\0';\n}\n#endif\n\n\n#if defined(USE_LUA)\nstatic unsigned char\nb64reverse(char letter)\n{\n\tif ((letter >= 'A') && (letter <= 'Z')) {\n\t\treturn letter - 'A';\n\t}\n\tif ((letter >= 'a') && (letter <= 'z')) {\n\t\treturn letter - 'a' + 26;\n\t}\n\tif ((letter >= '0') && (letter <= '9')) {\n\t\treturn letter - '0' + 52;\n\t}\n\tif (letter == '+') {\n\t\treturn 62;\n\t}\n\tif (letter == '/') {\n\t\treturn 63;\n\t}\n\tif (letter == '=') {\n\t\treturn 255; /* normal end */\n\t}\n\treturn 254; /* error */\n}\n\n\nstatic int\nbase64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len)\n{\n\tint i;\n\tunsigned char a, b, c, d;\n\n\t*dst_len = 0;\n\n\tfor (i = 0; i < src_len; i += 4) {\n\t\ta = b64reverse(src[i]);\n\t\tif (a >= 254) {\n\t\t\treturn i;\n\t\t}\n\n\t\tb = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);\n\t\tif (b >= 254) {\n\t\t\treturn i + 1;\n\t\t}\n\n\t\tc = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);\n\t\tif (c == 254) {\n\t\t\treturn i + 2;\n\t\t}\n\n\t\td = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);\n\t\tif (d == 254) {\n\t\t\treturn i + 3;\n\t\t}\n\n\t\tdst[(*dst_len)++] = (a << 2) + (b >> 4);\n\t\tif (c != 255) {\n\t\t\tdst[(*dst_len)++] = (b << 4) + (c >> 2);\n\t\t\tif (d != 255) {\n\t\t\t\tdst[(*dst_len)++] = (c << 6) + d;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\n\nstatic int\nis_put_or_delete_method(const struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tconst char *s = conn->request_info.request_method;\n\t\treturn (s != NULL)\n\t\t       && (!strcmp(s, \"PUT\") || !strcmp(s, \"DELETE\")\n\t\t           || !strcmp(s, \"MKCOL\") || !strcmp(s, \"PATCH\"));\n\t}\n\treturn 0;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nextention_matches_script(\n    struct mg_connection *conn, /* in: request (must be valid) */\n    const char *filename        /* in: filename  (must be valid) */\n)\n{\n#if !defined(NO_CGI)\n\tif (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_LUA)\n\tif (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n#if defined(USE_DUKTAPE)\n\tif (match_prefix(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t                 strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t                 filename)\n\t    > 0) {\n\t\treturn 1;\n\t}\n#endif\n\t/* filename and conn could be unused, if all preocessor conditions\n\t * are false (no script language supported). */\n\t(void)filename;\n\t(void)conn;\n\n\treturn 0;\n}\n\n\n/* For given directory path, substitute it to valid index file.\n * Return 1 if index file has been found, 0 if not found.\n * If the file is found, it's stats is returned in stp. */\nstatic int\nsubstitute_index_file(struct mg_connection *conn,\n                      char *path,\n                      size_t path_len,\n                      struct mg_file_stat *filestat)\n{\n\tconst char *list = conn->dom_ctx->config[INDEX_FILES];\n\tstruct vec filename_vec;\n\tsize_t n = strlen(path);\n\tint found = 0;\n\n\t/* The 'path' given to us points to the directory. Remove all trailing\n\t * directory separator characters from the end of the path, and\n\t * then append single directory separator character. */\n\twhile ((n > 0) && (path[n - 1] == '/')) {\n\t\tn--;\n\t}\n\tpath[n] = '/';\n\n\t/* Traverse index files list. For each entry, append it to the given\n\t * path and see if the file exists. If it exists, break the loop */\n\twhile ((list = next_option(list, &filename_vec, NULL)) != NULL) {\n\t\t/* Ignore too long entries that may overflow path buffer */\n\t\tif ((filename_vec.len + 1) > (path_len - (n + 1))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Prepare full path to the index file */\n\t\tmg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);\n\n\t\t/* Does it exist? */\n\t\tif (mg_stat(conn, path, filestat)) {\n\t\t\t/* Yes it does, break the loop */\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If no index file exists, restore directory path */\n\tif (!found) {\n\t\tpath[n] = '\\0';\n\t}\n\n\treturn found;\n}\n#endif\n\n\nstatic void\ninterpret_uri(struct mg_connection *conn, /* in/out: request (must be valid) */\n              char *filename,             /* out: filename */\n              size_t filename_buf_len,    /* in: size of filename buffer */\n              struct mg_file_stat *filestat, /* out: file status structure */\n              int *is_found,                 /* out: file found (directly) */\n              int *is_script_resource,       /* out: handled by a script? */\n              int *is_websocket_request,     /* out: websocket connetion? */\n              int *is_put_or_delete_request  /* out: put/delete a file? */\n)\n{\n\tchar const *accept_encoding;\n\n#if !defined(NO_FILES)\n\tconst char *uri = conn->request_info.local_uri;\n\tconst char *root = conn->dom_ctx->config[DOCUMENT_ROOT];\n\tconst char *rewrite;\n\tstruct vec a, b;\n\tptrdiff_t match_len;\n\tchar gz_path[PATH_MAX];\n\tint truncated;\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\tchar *tmp_str;\n\tsize_t tmp_str_len, sep_pos;\n\tint allow_substitute_script_subresources;\n#endif\n#else\n\t(void)filename_buf_len; /* unused if NO_FILES is defined */\n#endif\n\n\t/* Step 1: Set all initially unknown outputs to zero */\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\n\t/* Step 2: Check if the request attempts to modify the file system */\n\t*is_put_or_delete_request = is_put_or_delete_method(conn);\n\n/* Step 3: Check if it is a websocket request, and modify the document\n * root if required */\n#if defined(USE_WEBSOCKET)\n\t*is_websocket_request = is_websocket_protocol(conn);\n#if !defined(NO_FILES)\n\tif (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {\n\t\troot = conn->dom_ctx->config[WEBSOCKET_ROOT];\n\t}\n#endif /* !NO_FILES */\n#else  /* USE_WEBSOCKET */\n\t*is_websocket_request = 0;\n#endif /* USE_WEBSOCKET */\n\n\t/* Step 4: Check if gzip encoded response is allowed */\n\tconn->accept_gzip = 0;\n\tif ((accept_encoding = mg_get_header(conn, \"Accept-Encoding\")) != NULL) {\n\t\tif (strstr(accept_encoding, \"gzip\") != NULL) {\n\t\t\tconn->accept_gzip = 1;\n\t\t}\n\t}\n\n#if !defined(NO_FILES)\n\t/* Step 5: If there is no root directory, don't look for files. */\n\t/* Note that root == NULL is a regular use case here. This occurs,\n\t * if all requests are handled by callbacks, so the WEBSOCKET_ROOT\n\t * config is not required. */\n\tif (root == NULL) {\n\t\t/* all file related outputs have already been set to 0, just return\n\t\t */\n\t\treturn;\n\t}\n\n\t/* Step 6: Determine the local file path from the root path and the\n\t * request uri. */\n\t/* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift\n\t * part of the path one byte on the right. */\n\tmg_snprintf(\n\t    conn, &truncated, filename, filename_buf_len - 1, \"%s%s\", root, uri);\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 7: URI rewriting */\n\trewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];\n\twhile ((rewrite = next_option(rewrite, &a, &b)) != NULL) {\n\t\tif ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            filename,\n\t\t\t            filename_buf_len - 1,\n\t\t\t            \"%.*s%s\",\n\t\t\t            (int)b.len,\n\t\t\t            b.ptr,\n\t\t\t            uri + match_len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (truncated) {\n\t\tgoto interpret_cleanup;\n\t}\n\n\t/* Step 8: Check if the file exists at the server */\n\t/* Local file path and name, corresponding to requested URI\n\t * is now stored in \"filename\" variable. */\n\tif (mg_stat(conn, filename, filestat)) {\n\t\tint uri_len = (int)strlen(uri);\n\t\tint is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');\n\n\t\t/* 8.1: File exists. */\n\t\t*is_found = 1;\n\n\t\t/* 8.2: Check if it is a script type. */\n\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t/* The request addresses a CGI resource, Lua script or\n\t\t\t * server-side javascript.\n\t\t\t * The URI corresponds to the script itself (like\n\t\t\t * /path/script.cgi), and there is no additional resource\n\t\t\t * path (like /path/script.cgi/something).\n\t\t\t * Requests that modify (replace or delete) a resource, like\n\t\t\t * PUT and DELETE requests, should replace/delete the script\n\t\t\t * file.\n\t\t\t * Requests that read or write from/to a resource, like GET and\n\t\t\t * POST requests, should call the script and return the\n\t\t\t * generated response. */\n\t\t\t*is_script_resource = (!*is_put_or_delete_request);\n\t\t}\n\n\t\t/* 8.3: If the request target is a directory, there could be\n\t\t * a substitute file (index.html, index.cgi, ...). */\n\t\tif (filestat->is_directory && is_uri_end_slash) {\n\t\t\t/* Use a local copy here, since substitute_index_file will\n\t\t\t * change the content of the file status */\n\t\t\tstruct mg_file_stat tmp_filestat;\n\t\t\tmemset(&tmp_filestat, 0, sizeof(tmp_filestat));\n\n\t\t\tif (substitute_index_file(\n\t\t\t        conn, filename, filename_buf_len, &tmp_filestat)) {\n\n\t\t\t\t/* Substitute file found. Copy stat to the output, then\n\t\t\t\t * check if the file is a script file */\n\t\t\t\t*filestat = tmp_filestat;\n\n\t\t\t\tif (extention_matches_script(conn, filename)) {\n\t\t\t\t\t/* Substitute file is a script file */\n\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* Substitute file is a regular file */\n\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t*is_found = (mg_stat(conn, filename, filestat) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If there is no substitute file, the server could return\n\t\t\t * a directory listing in a later step */\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Step 9: Check for zipped files: */\n\t/* If we can't find the actual file, look for the file\n\t * with the same name but a .gz extension. If we find it,\n\t * use that and set the gzipped flag in the file struct\n\t * to indicate that the response need to have the content-\n\t * encoding: gzip header.\n\t * We can only do this if the browser declares support. */\n\tif (conn->accept_gzip) {\n\t\tmg_snprintf(\n\t\t    conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", filename);\n\n\t\tif (truncated) {\n\t\t\tgoto interpret_cleanup;\n\t\t}\n\n\t\tif (mg_stat(conn, gz_path, filestat)) {\n\t\t\tif (filestat) {\n\t\t\t\tfilestat->is_gzipped = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t}\n\t\t\t/* Currently gz files can not be scripts. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE)\n\t/* Step 10: Script resources may handle sub-resources */\n\t/* Support PATH_INFO for CGI scripts. */\n\ttmp_str_len = strlen(filename);\n\ttmp_str = (char *)mg_malloc_ctx(tmp_str_len + PATH_MAX + 1, conn->phys_ctx);\n\tif (!tmp_str) {\n\t\t/* Out of memory */\n\t\tgoto interpret_cleanup;\n\t}\n\tmemcpy(tmp_str, filename, tmp_str_len + 1);\n\n\t/* Check config, if index scripts may have sub-resources */\n\tallow_substitute_script_subresources =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ALLOW_INDEX_SCRIPT_SUB_RES],\n\t                   \"yes\");\n\n\tsep_pos = tmp_str_len;\n\twhile (sep_pos > 0) {\n\t\tsep_pos--;\n\t\tif (tmp_str[sep_pos] == '/') {\n\t\t\tint is_script = 0, does_exist = 0;\n\n\t\t\ttmp_str[sep_pos] = 0;\n\t\t\tif (tmp_str[0]) {\n\t\t\t\tis_script = extention_matches_script(conn, tmp_str);\n\t\t\t\tdoes_exist = mg_stat(conn, tmp_str, filestat);\n\t\t\t}\n\n\t\t\tif (does_exist && is_script) {\n\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\tmemmove(filename + sep_pos + 2,\n\t\t\t\t        filename + sep_pos + 1,\n\t\t\t\t        strlen(filename + sep_pos + 1) + 1);\n\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\tfilename[sep_pos + 1] = '/';\n\t\t\t\t*is_script_resource = 1;\n\t\t\t\t*is_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (allow_substitute_script_subresources) {\n\t\t\t\tif (substitute_index_file(\n\t\t\t\t        conn, tmp_str, tmp_str_len + PATH_MAX, filestat)) {\n\n\t\t\t\t\t/* some intermediate directory has an index file */\n\t\t\t\t\tif (extention_matches_script(conn, tmp_str)) {\n\n\t\t\t\t\t\tchar *tmp_str2;\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute script %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* this index file is a script */\n\t\t\t\t\t\ttmp_str2 = mg_strdup_ctx(filename + sep_pos + 1,\n\t\t\t\t\t\t                         conn->phys_ctx);\n\t\t\t\t\t\tmg_snprintf(conn,\n\t\t\t\t\t\t            &truncated,\n\t\t\t\t\t\t            filename,\n\t\t\t\t\t\t            filename_buf_len,\n\t\t\t\t\t\t            \"%s//%s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            tmp_str2);\n\t\t\t\t\t\tmg_free(tmp_str2);\n\n\t\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t\tmg_free(tmp_str);\n\t\t\t\t\t\t\tgoto interpret_cleanup;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsep_pos = strlen(tmp_str);\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = filename + sep_pos + 1;\n\t\t\t\t\t\t*is_script_resource = 1;\n\t\t\t\t\t\t*is_found = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tDEBUG_TRACE(\"Substitute file %s serving path %s\",\n\t\t\t\t\t\t            tmp_str,\n\t\t\t\t\t\t            filename);\n\n\t\t\t\t\t\t/* non-script files will not have sub-resources */\n\t\t\t\t\t\tfilename[sep_pos] = 0;\n\t\t\t\t\t\tconn->path_info = 0;\n\t\t\t\t\t\t*is_script_resource = 0;\n\t\t\t\t\t\t*is_found = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp_str[sep_pos] = '/';\n\t\t}\n\t}\n\n\tmg_free(tmp_str);\n\n#endif /* !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE) */\n#endif /* !defined(NO_FILES) */\n\treturn;\n\n#if !defined(NO_FILES)\n/* Reset all outputs */\ninterpret_cleanup:\n\tmemset(filestat, 0, sizeof(*filestat));\n\t*filename = 0;\n\t*is_found = 0;\n\t*is_script_resource = 0;\n\t*is_websocket_request = 0;\n\t*is_put_or_delete_request = 0;\n#endif /* !defined(NO_FILES) */\n}\n\n\n/* Check whether full request is buffered. Return:\n * -1  if request or response is malformed\n *  0  if request or response is not yet fully buffered\n * >0  actual request length, including last \\r\\n\\r\\n */\nstatic int\nget_http_header_len(const char *buf, int buflen)\n{\n\tint i;\n\tfor (i = 0; i < buflen; i++) {\n\t\t/* Do an unsigned comparison in some conditions below */\n\t\tconst unsigned char c = ((const unsigned char *)buf)[i];\n\n\t\tif ((c < 128) && ((char)c != '\\r') && ((char)c != '\\n')\n\t\t    && !isprint(c)) {\n\t\t\t/* abort scan as soon as one malformed character is found */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (i < buflen - 1) {\n\t\t\tif ((buf[i] == '\\n') && (buf[i + 1] == '\\n')) {\n\t\t\t\t/* Two newline, no carriage return - not standard compliant,\n\t\t\t\t * but\n\t\t\t\t * it\n\t\t\t\t * should be accepted */\n\t\t\t\treturn i + 2;\n\t\t\t}\n\t\t}\n\n\t\tif (i < buflen - 3) {\n\t\t\tif ((buf[i] == '\\r') && (buf[i + 1] == '\\n') && (buf[i + 2] == '\\r')\n\t\t\t    && (buf[i + 3] == '\\n')) {\n\t\t\t\t/* Two \\r\\n - standard compliant */\n\t\t\t\treturn i + 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n#if !defined(NO_CACHING)\n/* Convert month to the month number. Return -1 on error, or month number */\nstatic int\nget_month_index(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(month_names); i++) {\n\t\tif (!strcmp(s, month_names[i])) {\n\t\t\treturn (int)i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nstatic time_t\nparse_date_string(const char *datetime)\n{\n\tchar month_str[32] = {0};\n\tint second, minute, hour, day, month, year;\n\ttime_t result = (time_t)0;\n\tstruct tm tm;\n\n\tif ((sscanf(datetime,\n\t            \"%d/%3s/%d %d:%d:%d\",\n\t            &day,\n\t            month_str,\n\t            &year,\n\t            &hour,\n\t            &minute,\n\t            &second)\n\t     == 6)\n\t    || (sscanf(datetime,\n\t               \"%d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)\n\t    || (sscanf(datetime,\n\t               \"%*3s, %d %3s %d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)\n\t    || (sscanf(datetime,\n\t               \"%d-%3s-%d %d:%d:%d\",\n\t               &day,\n\t               month_str,\n\t               &year,\n\t               &hour,\n\t               &minute,\n\t               &second)\n\t        == 6)) {\n\t\tmonth = get_month_index(month_str);\n\t\tif ((month >= 0) && (year >= 1970)) {\n\t\t\tmemset(&tm, 0, sizeof(tm));\n\t\t\ttm.tm_year = year - 1900;\n\t\t\ttm.tm_mon = month;\n\t\t\ttm.tm_mday = day;\n\t\t\ttm.tm_hour = hour;\n\t\t\ttm.tm_min = minute;\n\t\t\ttm.tm_sec = second;\n\t\t\tresult = timegm(&tm);\n\t\t}\n\t}\n\n\treturn result;\n}\n#endif /* !NO_CACHING */\n\n\n/* Protect against directory disclosure attack by removing '..',\n * excessive '/' and '\\' characters */\nstatic void\nremove_double_dots_and_double_slashes(char *s)\n{\n\tchar *p = s;\n\n\twhile ((s[0] == '.') && (s[1] == '.')) {\n\t\ts++;\n\t}\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif ((s[-1] == '/') || (s[-1] == '\\\\')) {\n\t\t\t/* Skip all following slashes, backslashes and double-dots */\n\t\t\twhile (s[0] != '\\0') {\n\t\t\t\tif ((s[0] == '/') || (s[0] == '\\\\')) {\n\t\t\t\t\ts++;\n\t\t\t\t} else if ((s[0] == '.') && (s[1] == '.')) {\n\t\t\t\t\ts += 2;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*p = '\\0';\n}\n\n\nstatic const struct {\n\tconst char *extension;\n\tsize_t ext_len;\n\tconst char *mime_type;\n} builtin_mime_types[] = {\n    /* IANA registered MIME types\n     * (http://www.iana.org/assignments/media-types)\n     * application types */\n    {\".doc\", 4, \"application/msword\"},\n    {\".eps\", 4, \"application/postscript\"},\n    {\".exe\", 4, \"application/octet-stream\"},\n    {\".js\", 3, \"application/javascript\"},\n    {\".json\", 5, \"application/json\"},\n    {\".pdf\", 4, \"application/pdf\"},\n    {\".ps\", 3, \"application/postscript\"},\n    {\".rtf\", 4, \"application/rtf\"},\n    {\".xhtml\", 6, \"application/xhtml+xml\"},\n    {\".xsl\", 4, \"application/xml\"},\n    {\".xslt\", 5, \"application/xml\"},\n\n    /* fonts */\n    {\".ttf\", 4, \"application/font-sfnt\"},\n    {\".cff\", 4, \"application/font-sfnt\"},\n    {\".otf\", 4, \"application/font-sfnt\"},\n    {\".aat\", 4, \"application/font-sfnt\"},\n    {\".sil\", 4, \"application/font-sfnt\"},\n    {\".pfr\", 4, \"application/font-tdpfr\"},\n    {\".woff\", 5, \"application/font-woff\"},\n\n    /* audio */\n    {\".mp3\", 4, \"audio/mpeg\"},\n    {\".oga\", 4, \"audio/ogg\"},\n    {\".ogg\", 4, \"audio/ogg\"},\n\n    /* image */\n    {\".gif\", 4, \"image/gif\"},\n    {\".ief\", 4, \"image/ief\"},\n    {\".jpeg\", 5, \"image/jpeg\"},\n    {\".jpg\", 4, \"image/jpeg\"},\n    {\".jpm\", 4, \"image/jpm\"},\n    {\".jpx\", 4, \"image/jpx\"},\n    {\".png\", 4, \"image/png\"},\n    {\".svg\", 4, \"image/svg+xml\"},\n    {\".tif\", 4, \"image/tiff\"},\n    {\".tiff\", 5, \"image/tiff\"},\n\n    /* model */\n    {\".wrl\", 4, \"model/vrml\"},\n\n    /* text */\n    {\".css\", 4, \"text/css\"},\n    {\".csv\", 4, \"text/csv\"},\n    {\".htm\", 4, \"text/html\"},\n    {\".html\", 5, \"text/html\"},\n    {\".sgm\", 4, \"text/sgml\"},\n    {\".shtm\", 5, \"text/html\"},\n    {\".shtml\", 6, \"text/html\"},\n    {\".txt\", 4, \"text/plain\"},\n    {\".xml\", 4, \"text/xml\"},\n\n    /* video */\n    {\".mov\", 4, \"video/quicktime\"},\n    {\".mp4\", 4, \"video/mp4\"},\n    {\".mpeg\", 5, \"video/mpeg\"},\n    {\".mpg\", 4, \"video/mpeg\"},\n    {\".ogv\", 4, \"video/ogg\"},\n    {\".qt\", 3, \"video/quicktime\"},\n\n    /* not registered types\n     * (http://reference.sitepoint.com/html/mime-types-full,\n     * http://www.hansenb.pdx.edu/DMKB/dict/tutorials/mime_typ.php, ..) */\n    {\".arj\", 4, \"application/x-arj-compressed\"},\n    {\".gz\", 3, \"application/x-gunzip\"},\n    {\".rar\", 4, \"application/x-arj-compressed\"},\n    {\".swf\", 4, \"application/x-shockwave-flash\"},\n    {\".tar\", 4, \"application/x-tar\"},\n    {\".tgz\", 4, \"application/x-tar-gz\"},\n    {\".torrent\", 8, \"application/x-bittorrent\"},\n    {\".ppt\", 4, \"application/x-mspowerpoint\"},\n    {\".xls\", 4, \"application/x-msexcel\"},\n    {\".zip\", 4, \"application/x-zip-compressed\"},\n    {\".aac\",\n     4,\n     \"audio/aac\"}, /* http://en.wikipedia.org/wiki/Advanced_Audio_Coding */\n    {\".aif\", 4, \"audio/x-aif\"},\n    {\".m3u\", 4, \"audio/x-mpegurl\"},\n    {\".mid\", 4, \"audio/x-midi\"},\n    {\".ra\", 3, \"audio/x-pn-realaudio\"},\n    {\".ram\", 4, \"audio/x-pn-realaudio\"},\n    {\".wav\", 4, \"audio/x-wav\"},\n    {\".bmp\", 4, \"image/bmp\"},\n    {\".ico\", 4, \"image/x-icon\"},\n    {\".pct\", 4, \"image/x-pct\"},\n    {\".pict\", 5, \"image/pict\"},\n    {\".rgb\", 4, \"image/x-rgb\"},\n    {\".webm\", 5, \"video/webm\"}, /* http://en.wikipedia.org/wiki/WebM */\n    {\".asf\", 4, \"video/x-ms-asf\"},\n    {\".avi\", 4, \"video/x-msvideo\"},\n    {\".m4v\", 4, \"video/x-m4v\"},\n    {NULL, 0, NULL}};\n\n\nconst char *\nmg_get_builtin_mime_type(const char *path)\n{\n\tconst char *ext;\n\tsize_t i, path_len;\n\n\tpath_len = strlen(path);\n\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text = path + (path_len - builtin_mime_types[i].ext_len);\n\t\tif ((path_len > builtin_mime_types[i].ext_len)\n\t\t    && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {\n\t\t\treturn builtin_mime_types[i].mime_type;\n\t\t}\n\t}\n\n\treturn \"text/plain\";\n}\n\n\n/* Look at the \"path\" extension and figure what mime type it has.\n * Store mime type in the vector. */\nstatic void\nget_mime_type(struct mg_connection *conn, const char *path, struct vec *vec)\n{\n\tstruct vec ext_vec, mime_vec;\n\tconst char *list, *ext;\n\tsize_t path_len;\n\n\tpath_len = strlen(path);\n\n\tif ((conn == NULL) || (vec == NULL)) {\n\t\tif (vec != NULL) {\n\t\t\tmemset(vec, '\\0', sizeof(struct vec));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Scan user-defined mime types first, in case user wants to\n\t * override default mime types. */\n\tlist = conn->dom_ctx->config[EXTRA_MIME_TYPES];\n\twhile ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {\n\t\t/* ext now points to the path suffix */\n\t\text = path + path_len - ext_vec.len;\n\t\tif (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {\n\t\t\t*vec = mime_vec;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvec->ptr = mg_get_builtin_mime_type(path);\n\tvec->len = strlen(vec->ptr);\n}\n\n\n/* Stringify binary data. Output buffer must be twice as big as input,\n * because each byte takes 2 bytes in string representation */\nstatic void\nbin2str(char *to, const unsigned char *p, size_t len)\n{\n\tstatic const char *hex = \"0123456789abcdef\";\n\n\tfor (; len--; p++) {\n\t\t*to++ = hex[p[0] >> 4];\n\t\t*to++ = hex[p[0] & 0x0f];\n\t}\n\t*to = '\\0';\n}\n\n\n/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.\n */\nchar *\nmg_md5(char buf[33], ...)\n{\n\tmd5_byte_t hash[16];\n\tconst char *p;\n\tva_list ap;\n\tmd5_state_t ctx;\n\n\tmd5_init(&ctx);\n\n\tva_start(ap, buf);\n\twhile ((p = va_arg(ap, const char *)) != NULL) {\n\t\tmd5_append(&ctx, (const md5_byte_t *)p, strlen(p));\n\t}\n\tva_end(ap);\n\n\tmd5_finish(&ctx, hash);\n\tbin2str(buf, hash, sizeof(hash));\n\treturn buf;\n}\n\n\n/* Check the user's password, return 1 if OK */\nstatic int\ncheck_password(const char *method,\n               const char *ha1,\n               const char *uri,\n               const char *nonce,\n               const char *nc,\n               const char *cnonce,\n               const char *qop,\n               const char *response)\n{\n\tchar ha2[32 + 1], expected_response[32 + 1];\n\n\t/* Some of the parameters may be NULL */\n\tif ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL)\n\t    || (qop == NULL) || (response == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */\n\tif (strlen(response) != 32) {\n\t\treturn 0;\n\t}\n\n\tmg_md5(ha2, method, \":\", uri, NULL);\n\tmg_md5(expected_response,\n\t       ha1,\n\t       \":\",\n\t       nonce,\n\t       \":\",\n\t       nc,\n\t       \":\",\n\t       cnonce,\n\t       \":\",\n\t       qop,\n\t       \":\",\n\t       ha2,\n\t       NULL);\n\n\treturn mg_strcasecmp(response, expected_response) == 0;\n}\n\n\n/* Use the global passwords file, if specified by auth_gpass option,\n * or search for .htpasswd in the requested directory. */\nstatic void\nopen_auth_file(struct mg_connection *conn,\n               const char *path,\n               struct mg_file *filep)\n{\n\tif ((conn != NULL) && (conn->dom_ctx != NULL)) {\n\t\tchar name[PATH_MAX];\n\t\tconst char *p, *e,\n\t\t    *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tint truncated;\n\n\t\tif (gpass != NULL) {\n\t\t\t/* Use global passwords file */\n\t\t\tif (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Use mg_cry_internal here, since gpass has been configured. */\n\t\t\t\tmg_cry_internal(conn, \"fopen(%s): %s\", gpass, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t\t/* Important: using local struct mg_file to test path for\n\t\t\t * is_directory flag. If filep is used, mg_stat() makes it\n\t\t\t * appear as if auth file was opened.\n\t\t\t * TODO(mid): Check if this is still required after rewriting\n\t\t\t * mg_stat */\n\t\t} else if (mg_stat(conn, path, &filep->stat)\n\t\t           && filep->stat.is_directory) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%s/%s\",\n\t\t\t            path,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\t/* Try to find .htpasswd in requested directory. */\n\t\t\tfor (p = path, e = p + strlen(p) - 1; e > p; e--) {\n\t\t\t\tif (e[0] == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            name,\n\t\t\t            sizeof(name),\n\t\t\t            \"%.*s/%s\",\n\t\t\t            (int)(e - p),\n\t\t\t            p,\n\t\t\t            PASSWORDS_FILE_NAME);\n\n\t\t\tif (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {\n#if defined(DEBUG)\n\t\t\t\t/* Don't use mg_cry_internal here, but only a trace, since this\n\t\t\t\t * is\n\t\t\t\t * a typical case. It will occur for every directory\n\t\t\t\t * without a password file. */\n\t\t\t\tDEBUG_TRACE(\"fopen(%s): %s\", name, strerror(ERRNO));\n#endif\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/* Parsed Authorization header */\nstruct ah {\n\tchar *user, *uri, *cnonce, *response, *qop, *nc, *nonce;\n};\n\n\n/* Return 1 on success. Always initializes the ah structure. */\nstatic int\nparse_auth_header(struct mg_connection *conn,\n                  char *buf,\n                  size_t buf_size,\n                  struct ah *ah)\n{\n\tchar *name, *value, *s;\n\tconst char *auth_header;\n\tuint64_t nonce;\n\n\tif (!ah || !conn) {\n\t\treturn 0;\n\t}\n\n\t(void)memset(ah, 0, sizeof(*ah));\n\tif (((auth_header = mg_get_header(conn, \"Authorization\")) == NULL)\n\t    || mg_strncasecmp(auth_header, \"Digest \", 7) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* Make modifiable copy of the auth header */\n\t(void)mg_strlcpy(buf, auth_header + 7, buf_size);\n\ts = buf;\n\n\t/* Parse authorization header */\n\tfor (;;) {\n\t\t/* Gobble initial spaces */\n\t\twhile (isspace(*(unsigned char *)s)) {\n\t\t\ts++;\n\t\t}\n\t\tname = skip_quoted(&s, \"=\", \" \", 0);\n\t\t/* Value is either quote-delimited, or ends at first comma or space.\n\t\t */\n\t\tif (s[0] == '\\\"') {\n\t\t\ts++;\n\t\t\tvalue = skip_quoted(&s, \"\\\"\", \" \", '\\\\');\n\t\t\tif (s[0] == ',') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = skip_quoted(&s, \", \", \" \", 0); /* IE uses commas, FF uses\n\t\t\t                                        * spaces */\n\t\t}\n\t\tif (*name == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strcmp(name, \"username\")) {\n\t\t\tah->user = value;\n\t\t} else if (!strcmp(name, \"cnonce\")) {\n\t\t\tah->cnonce = value;\n\t\t} else if (!strcmp(name, \"response\")) {\n\t\t\tah->response = value;\n\t\t} else if (!strcmp(name, \"uri\")) {\n\t\t\tah->uri = value;\n\t\t} else if (!strcmp(name, \"qop\")) {\n\t\t\tah->qop = value;\n\t\t} else if (!strcmp(name, \"nc\")) {\n\t\t\tah->nc = value;\n\t\t} else if (!strcmp(name, \"nonce\")) {\n\t\t\tah->nonce = value;\n\t\t}\n\t}\n\n#if !defined(NO_NONCE_CHECK)\n\t/* Read the nonce from the response. */\n\tif (ah->nonce == NULL) {\n\t\treturn 0;\n\t}\n\ts = NULL;\n\tnonce = strtoull(ah->nonce, &s, 10);\n\tif ((s == NULL) || (*s != 0)) {\n\t\treturn 0;\n\t}\n\n\t/* Convert the nonce from the client to a number. */\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\n\t/* The converted number corresponds to the time the nounce has been\n\t * created. This should not be earlier than the server start. */\n\t/* Server side nonce check is valuable in all situations but one:\n\t * if the server restarts frequently, but the client should not see\n\t * that, so the server should accept nonces from previous starts. */\n\t/* However, the reasonable default is to not accept a nonce from a\n\t * previous start, so if anyone changed the access rights between\n\t * two restarts, a new login is required. */\n\tif (nonce < (uint64_t)conn->phys_ctx->start_time) {\n\t\t/* nonce is from a previous start of the server and no longer valid\n\t\t * (replay attack?) */\n\t\treturn 0;\n\t}\n\t/* Check if the nonce is too high, so it has not (yet) been used by the\n\t * server. */\n\tif (nonce >= ((uint64_t)conn->phys_ctx->start_time\n\t              + conn->dom_ctx->nonce_count)) {\n\t\treturn 0;\n\t}\n#else\n\t(void)nonce;\n#endif\n\n\t/* CGI needs it as REMOTE_USER */\n\tif (ah->user != NULL) {\n\t\tconn->request_info.remote_user =\n\t\t    mg_strdup_ctx(ah->user, conn->phys_ctx);\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic const char *\nmg_fgets(char *buf, size_t size, struct mg_file *filep, char **p)\n{\n#if defined(MG_USE_OPEN_FILE)\n\tconst char *eof;\n\tsize_t len;\n\tconst char *memend;\n#else\n\t(void)p; /* parameter is unused */\n#endif\n\n\tif (!filep) {\n\t\treturn NULL;\n\t}\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (*p != NULL)) {\n\t\tmemend = (const char *)&filep->access.membuf[filep->stat.size];\n\t\t/* Search for \\n from p till the end of stream */\n\t\teof = (char *)memchr(*p, '\\n', (size_t)(memend - *p));\n\t\tif (eof != NULL) {\n\t\t\teof += 1; /* Include \\n */\n\t\t} else {\n\t\t\teof = memend; /* Copy remaining data */\n\t\t}\n\t\tlen =\n\t\t    ((size_t)(eof - *p) > (size - 1)) ? (size - 1) : (size_t)(eof - *p);\n\t\tmemcpy(buf, *p, len);\n\t\tbuf[len] = '\\0';\n\t\t*p += len;\n\t\treturn len ? eof : NULL;\n\t} else /* filep->access.fp block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgets(buf, (int)size, filep->access.fp);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n/* Define the initial recursion depth for procesesing htpasswd files that\n * include other htpasswd\n * (or even the same) files.  It is not difficult to provide a file or files\n * s.t. they force civetweb\n * to infinitely recurse and then crash.\n */\n#define INITIAL_DEPTH 9\n#if INITIAL_DEPTH <= 0\n#error Bad INITIAL_DEPTH for recursion, set to at least 1\n#endif\n\nstruct read_auth_file_struct {\n\tstruct mg_connection *conn;\n\tstruct ah ah;\n\tconst char *domain;\n\tchar buf[256 + 256 + 40];\n\tconst char *f_user;\n\tconst char *f_domain;\n\tconst char *f_ha1;\n};\n\n\nstatic int\nread_auth_file(struct mg_file *filep,\n               struct read_auth_file_struct *workdata,\n               int depth)\n{\n\tchar *p = NULL /* init if MG_USE_OPEN_FILE is not set */;\n\tint is_authorized = 0;\n\tstruct mg_file fp;\n\tsize_t l;\n\n\tif (!filep || !workdata || (0 == depth)) {\n\t\treturn 0;\n\t}\n\n/* Loop over passwords file */\n#if defined(MG_USE_OPEN_FILE)\n\tp = (char *)filep->access.membuf;\n#endif\n\twhile (mg_fgets(workdata->buf, sizeof(workdata->buf), filep, &p) != NULL) {\n\t\tl = strlen(workdata->buf);\n\t\twhile (l > 0) {\n\t\t\tif (isspace(workdata->buf[l - 1])\n\t\t\t    || iscntrl(workdata->buf[l - 1])) {\n\t\t\t\tl--;\n\t\t\t\tworkdata->buf[l] = 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (l < 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_user = workdata->buf;\n\n\t\tif (workdata->f_user[0] == ':') {\n\t\t\t/* user names may not contain a ':' and may not be empty,\n\t\t\t * so lines starting with ':' may be used for a special purpose\n\t\t\t */\n\t\t\tif (workdata->f_user[1] == '#') {\n\t\t\t\t/* :# is a comment */\n\t\t\t\tcontinue;\n\t\t\t} else if (!strncmp(workdata->f_user + 1, \"include=\", 8)) {\n\t\t\t\tif (mg_fopen(workdata->conn,\n\t\t\t\t             workdata->f_user + 9,\n\t\t\t\t             MG_FOPEN_MODE_READ,\n\t\t\t\t             &fp)) {\n\t\t\t\t\tis_authorized = read_auth_file(&fp, workdata, depth - 1);\n\t\t\t\t\t(void)mg_fclose(\n\t\t\t\t\t    &fp.access); /* ignore error on read only file */\n\n\t\t\t\t\t/* No need to continue processing files once we have a\n\t\t\t\t\t * match, since nothing will reset it back\n\t\t\t\t\t * to 0.\n\t\t\t\t\t */\n\t\t\t\t\tif (is_authorized) {\n\t\t\t\t\t\treturn is_authorized;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t\t\t                \"%s: cannot open authorization file: %s\",\n\t\t\t\t\t                __func__,\n\t\t\t\t\t                workdata->buf);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* everything is invalid for the moment (might change in the\n\t\t\t * future) */\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tworkdata->f_domain = strchr(workdata->f_user, ':');\n\t\tif (workdata->f_domain == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_domain) = 0;\n\t\t(workdata->f_domain)++;\n\n\t\tworkdata->f_ha1 = strchr(workdata->f_domain, ':');\n\t\tif (workdata->f_ha1 == NULL) {\n\t\t\tmg_cry_internal(workdata->conn,\n\t\t\t                \"%s: syntax error in authorization file: %s\",\n\t\t\t                __func__,\n\t\t\t                workdata->buf);\n\t\t\tcontinue;\n\t\t}\n\t\t*(char *)(workdata->f_ha1) = 0;\n\t\t(workdata->f_ha1)++;\n\n\t\tif (!strcmp(workdata->ah.user, workdata->f_user)\n\t\t    && !strcmp(workdata->domain, workdata->f_domain)) {\n\t\t\treturn check_password(workdata->conn->request_info.request_method,\n\t\t\t                      workdata->f_ha1,\n\t\t\t                      workdata->ah.uri,\n\t\t\t                      workdata->ah.nonce,\n\t\t\t                      workdata->ah.nc,\n\t\t\t                      workdata->ah.cnonce,\n\t\t\t                      workdata->ah.qop,\n\t\t\t                      workdata->ah.response);\n\t\t}\n\t}\n\n\treturn is_authorized;\n}\n\n\n/* Authorize against the opened passwords file. Return 1 if authorized. */\nstatic int\nauthorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)\n{\n\tstruct read_auth_file_struct workdata;\n\tchar buf[MG_BUF_LEN];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&workdata, 0, sizeof(workdata));\n\tworkdata.conn = conn;\n\n\tif (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {\n\t\treturn 0;\n\t}\n\n\tif (realm) {\n\t\tworkdata.domain = realm;\n\t} else {\n\t\tworkdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\treturn read_auth_file(filep, &workdata, INITIAL_DEPTH);\n}\n\n\n/* Public function to check http digest authentication header */\nint\nmg_check_digest_access_authentication(struct mg_connection *conn,\n                                      const char *realm,\n                                      const char *filename)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint auth;\n\n\tif (!conn || !filename) {\n\t\treturn -1;\n\t}\n\tif (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -2;\n\t}\n\n\tauth = authorize(conn, &file, realm);\n\n\tmg_fclose(&file.access);\n\n\treturn auth;\n}\n\n\n/* Return 1 if request is authorised, 0 otherwise. */\nstatic int\ncheck_authorization(struct mg_connection *conn, const char *path)\n{\n\tchar fname[PATH_MAX];\n\tstruct vec uri_vec, filename_vec;\n\tconst char *list;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tint authorized = 1, truncated;\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn 0;\n\t}\n\n\tlist = conn->dom_ctx->config[PROTECT_URI];\n\twhile ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {\n\t\tif (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            &truncated,\n\t\t\t            fname,\n\t\t\t            sizeof(fname),\n\t\t\t            \"%.*s\",\n\t\t\t            (int)filename_vec.len,\n\t\t\t            filename_vec.ptr);\n\n\t\t\tif (truncated\n\t\t\t    || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: cannot open %s: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                fname,\n\t\t\t\t                strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!is_file_opened(&file.access)) {\n\t\topen_auth_file(conn, path, &file);\n\t}\n\n\tif (is_file_opened(&file.access)) {\n\t\tauthorized = authorize(conn, &file, NULL);\n\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t}\n\n\treturn authorized;\n}\n\n\n/* Internal function. Assumes conn is valid */\nstatic void\nsend_authorization_request(struct mg_connection *conn, const char *realm)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tuint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);\n\n\tif (!realm) {\n\t\trealm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t}\n\n\t(void)pthread_mutex_lock(&conn->phys_ctx->nonce_mutex);\n\tnonce += conn->dom_ctx->nonce_count;\n\t++conn->dom_ctx->nonce_count;\n\t(void)pthread_mutex_unlock(&conn->phys_ctx->nonce_mutex);\n\n\tnonce ^= conn->dom_ctx->auth_nonce_mask;\n\tconn->status_code = 401;\n\tconn->must_close = 1;\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tmg_printf(conn, \"HTTP/1.1 401 Unauthorized\\r\\n\");\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"WWW-Authenticate: Digest qop=\\\"auth\\\", realm=\\\"%s\\\", \"\n\t          \"nonce=\\\"%\" UINT64_FMT \"\\\"\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn),\n\t          realm,\n\t          nonce);\n}\n\n\n/* Interface function. Parameters are provided by the user, so do\n * at least some basic checks.\n */\nint\nmg_send_digest_access_authentication_request(struct mg_connection *conn,\n                                             const char *realm)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tsend_authorization_request(conn, realm);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nis_authorized_for_put(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];\n\t\tint ret = 0;\n\n\t\tif (passfile != NULL\n\t\t    && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {\n\t\t\tret = authorize(conn, &file, NULL);\n\t\t\t(void)mg_fclose(&file.access); /* ignore error on read only file */\n\t\t}\n\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n#endif\n\n\nint\nmg_modify_passwords_file(const char *fname,\n                         const char *domain,\n                         const char *user,\n                         const char *pass)\n{\n\tint found, i;\n\tchar line[512], u[512] = \"\", d[512] = \"\", ha1[33], tmp[PATH_MAX + 8];\n\tFILE *fp, *fp2;\n\n\tfound = 0;\n\tfp = fp2 = NULL;\n\n\t/* Regard empty password as no password - remove user record. */\n\tif ((pass != NULL) && (pass[0] == '\\0')) {\n\t\tpass = NULL;\n\t}\n\n\t/* Other arguments must not be empty */\n\tif ((fname == NULL) || (domain == NULL) || (user == NULL)) {\n\t\treturn 0;\n\t}\n\n\t/* Using the given file format, user name and domain must not contain\n\t * ':'\n\t */\n\tif (strchr(user, ':') != NULL) {\n\t\treturn 0;\n\t}\n\tif (strchr(domain, ':') != NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Do not allow control characters like newline in user name and domain.\n\t * Do not allow excessively long names either. */\n\tfor (i = 0; ((i < 255) && (user[i] != 0)); i++) {\n\t\tif (iscntrl(user[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (user[i]) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; ((i < 255) && (domain[i] != 0)); i++) {\n\t\tif (iscntrl(domain[i])) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (domain[i]) {\n\t\treturn 0;\n\t}\n\n\t/* The maximum length of the path to the password file is limited */\n\tif ((strlen(fname) + 4) >= PATH_MAX) {\n\t\treturn 0;\n\t}\n\n\t/* Create a temporary file name. Length has been checked before. */\n\tstrcpy(tmp, fname);\n\tstrcat(tmp, \".tmp\");\n\n\t/* Create the file if does not exist */\n\t/* Use of fopen here is OK, since fname is only ASCII */\n\tif ((fp = fopen(fname, \"a+\")) != NULL) {\n\t\t(void)fclose(fp);\n\t}\n\n\t/* Open the given file and temporary file */\n\tif ((fp = fopen(fname, \"r\")) == NULL) {\n\t\treturn 0;\n\t} else if ((fp2 = fopen(tmp, \"w+\")) == NULL) {\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\n\t/* Copy the stuff to temporary file */\n\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\tif (sscanf(line, \"%255[^:]:%255[^:]:%*s\", u, d) != 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tu[255] = 0;\n\t\td[255] = 0;\n\n\t\tif (!strcmp(u, user) && !strcmp(d, domain)) {\n\t\t\tfound++;\n\t\t\tif (pass != NULL) {\n\t\t\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\t\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(fp2, \"%s\", line);\n\t\t}\n\t}\n\n\t/* If new user, just add it */\n\tif (!found && (pass != NULL)) {\n\t\tmg_md5(ha1, user, \":\", domain, \":\", pass, NULL);\n\t\tfprintf(fp2, \"%s:%s:%s\\n\", user, domain, ha1);\n\t}\n\n\t/* Close files */\n\tfclose(fp);\n\tfclose(fp2);\n\n\t/* Put the temp file in place of real file */\n\tIGNORE_UNUSED_RESULT(remove(fname));\n\tIGNORE_UNUSED_RESULT(rename(tmp, fname));\n\n\treturn 1;\n}\n\n\nstatic int\nis_valid_port(unsigned long port)\n{\n\treturn (port <= 0xffff);\n}\n\n\nstatic int\nmg_inet_pton(int af, const char *src, void *dst, size_t dstlen)\n{\n\tstruct addrinfo hints, *res, *ressave;\n\tint func_ret = 0;\n\tint gai_ret;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = af;\n\n\tgai_ret = getaddrinfo(src, NULL, &hints, &res);\n\tif (gai_ret != 0) {\n\t\t/* gai_strerror could be used to convert gai_ret to a string */\n\t\t/* POSIX return values: see\n\t\t * http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html\n\t\t */\n\t\t/* Windows return values: see\n\t\t * https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520%28v=vs.85%29.aspx\n\t\t */\n\t\treturn 0;\n\t}\n\n\tressave = res;\n\n\twhile (res) {\n\t\tif (dstlen >= (size_t)res->ai_addrlen) {\n\t\t\tmemcpy(dst, res->ai_addr, res->ai_addrlen);\n\t\t\tfunc_ret = 1;\n\t\t}\n\t\tres = res->ai_next;\n\t}\n\n\tfreeaddrinfo(ressave);\n\treturn func_ret;\n}\n\n\nstatic int\nconnect_socket(struct mg_context *ctx /* may be NULL */,\n               const char *host,\n               int port,\n               int use_ssl,\n               char *ebuf,\n               size_t ebuf_len,\n               SOCKET *sock /* output: socket, must not be NULL */,\n               union usa *sa /* output: socket address, must not be NULL  */\n)\n{\n\tint ip_ver = 0;\n\tint conn_ret = -1;\n\tint ret;\n\t*sock = INVALID_SOCKET;\n\tmemset(sa, 0, sizeof(*sa));\n\n\tif (ebuf_len > 0) {\n\t\t*ebuf = 0;\n\t}\n\n\tif (host == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"NULL host\");\n\t\treturn 0;\n\t}\n\n\tif ((port <= 0) || !is_valid_port((unsigned)port)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"invalid port\");\n\t\treturn 0;\n\t}\n\n#if !defined(NO_SSL)\n#if !defined(NO_SSL_DL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl && (TLS_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n#else\n\tif (use_ssl && (SSLv23_client_method == NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"SSL is not initialized\");\n\t\treturn 0;\n\t}\n\n#endif /* OPENSSL_API_1_1 */\n#else\n\t(void)use_ssl;\n#endif /* NO_SSL_DL */\n#else\n\t(void)use_ssl;\n#endif /* !defined(NO_SSL) */\n\n\tif (mg_inet_pton(AF_INET, host, &sa->sin, sizeof(sa->sin))) {\n\t\tsa->sin.sin_family = AF_INET;\n\t\tsa->sin.sin_port = htons((uint16_t)port);\n\t\tip_ver = 4;\n#if defined(USE_IPV6)\n\t} else if (mg_inet_pton(AF_INET6, host, &sa->sin6, sizeof(sa->sin6))) {\n\t\tsa->sin6.sin6_family = AF_INET6;\n\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\tip_ver = 6;\n\t} else if (host[0] == '[') {\n\t\t/* While getaddrinfo on Windows will work with [::1],\n\t\t * getaddrinfo on Linux only works with ::1 (without []). */\n\t\tsize_t l = strlen(host + 1);\n\t\tchar *h = (l > 1) ? mg_strdup_ctx(host + 1, ctx) : NULL;\n\t\tif (h) {\n\t\t\th[l - 1] = 0;\n\t\t\tif (mg_inet_pton(AF_INET6, h, &sa->sin6, sizeof(sa->sin6))) {\n\t\t\t\tsa->sin6.sin6_family = AF_INET6;\n\t\t\t\tsa->sin6.sin6_port = htons((uint16_t)port);\n\t\t\t\tip_ver = 6;\n\t\t\t}\n\t\t\tmg_free(h);\n\t\t}\n#endif\n\t}\n\n\tif (ip_ver == 0) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"host not found\");\n\t\treturn 0;\n\t}\n\n\tif (ip_ver == 4) {\n\t\t*sock = socket(PF_INET, SOCK_STREAM, 0);\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t*sock = socket(PF_INET6, SOCK_STREAM, 0);\n\t}\n#endif\n\n\tif (*sock == INVALID_SOCKET) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"socket(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn 0;\n\t}\n\n\tif (0 != set_non_blocking_mode(*sock)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Cannot set socket to non-blocking: %s\",\n\t\t            strerror(ERRNO));\n\t\tclosesocket(*sock);\n\t\t*sock = INVALID_SOCKET;\n\t\treturn 0;\n\t}\n\n\tset_close_on_exec(*sock, fc(ctx));\n\n\tif (ip_ver == 4) {\n\t\t/* connected with IPv4 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin),\n\t\t                   sizeof(sa->sin));\n\t}\n#if defined(USE_IPV6)\n\telse if (ip_ver == 6) {\n\t\t/* connected with IPv6 */\n\t\tconn_ret = connect(*sock,\n\t\t                   (struct sockaddr *)((void *)&sa->sin6),\n\t\t                   sizeof(sa->sin6));\n\t}\n#endif\n\n#if defined(_WIN32)\n\tif (conn_ret != 0) {\n\t\tDWORD err = WSAGetLastError(); /* could return WSAEWOULDBLOCK */\n\t\tconn_ret = (int)err;\n#if !defined(EINPROGRESS)\n#define EINPROGRESS (WSAEWOULDBLOCK) /* Winsock equivalent */\n#endif                               /* if !defined(EINPROGRESS) */\n\t}\n#endif\n\n\tif ((conn_ret != 0) && (conn_ret != EINPROGRESS)) {\n\t\t/* Data for getsockopt */\n\t\tint sockerr = -1;\n\t\tvoid *psockerr = &sockerr;\n\n#if defined(_WIN32)\n\t\tint len = (int)sizeof(sockerr);\n#else\n\t\tsocklen_t len = (socklen_t)sizeof(sockerr);\n#endif\n\n\t\t/* Data for poll */\n\t\tstruct pollfd pfd[1];\n\t\tint pollres;\n\t\tint ms_wait = 10000; /* 10 second timeout */\n\n\t\t/* For a non-blocking socket, the connect sequence is:\n\t\t * 1) call connect (will not block)\n\t\t * 2) wait until the socket is ready for writing (select or poll)\n\t\t * 3) check connection state with getsockopt\n\t\t */\n\t\tpfd[0].fd = *sock;\n\t\tpfd[0].events = POLLOUT;\n\t\tpollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));\n\n\t\tif (pollres != 1) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): timeout\",\n\t\t\t            host,\n\t\t\t            port);\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);\n#else\n\t\tret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);\n#endif\n\n\t\tif ((ret != 0) || (sockerr != 0)) {\n\t\t\t/* Not connected */\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"connect(%s:%d): error %s\",\n\t\t\t            host,\n\t\t\t            port,\n\t\t\t            strerror(sockerr));\n\t\t\tclosesocket(*sock);\n\t\t\t*sock = INVALID_SOCKET;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nint\nmg_url_encode(const char *src, char *dst, size_t dst_len)\n{\n\tstatic const char *dont_escape = \"._-$,;~()\";\n\tstatic const char *hex = \"0123456789abcdef\";\n\tchar *pos = dst;\n\tconst char *end = dst + dst_len - 1;\n\n\tfor (; ((*src != '\\0') && (pos < end)); src++, pos++) {\n\t\tif (isalnum(*(const unsigned char *)src)\n\t\t    || (strchr(dont_escape, *(const unsigned char *)src) != NULL)) {\n\t\t\t*pos = *src;\n\t\t} else if (pos + 2 < end) {\n\t\t\tpos[0] = '%';\n\t\t\tpos[1] = hex[(*(const unsigned char *)src) >> 4];\n\t\t\tpos[2] = hex[(*(const unsigned char *)src) & 0xf];\n\t\t\tpos += 2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*pos = '\\0';\n\treturn (*src == '\\0') ? (int)(pos - dst) : -1;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprint_dir_entry(struct de *de)\n{\n\tsize_t hrefsize;\n\tchar *href;\n\tchar size[64], mod[64];\n#if defined(REENTRANT_TIME)\n\tstruct tm _tm;\n\tstruct tm *tm = &_tm;\n#else\n\tstruct tm *tm;\n#endif\n\n\threfsize = PATH_MAX * 3; /* worst case */\n\thref = (char *)mg_malloc(hrefsize);\n\tif (href == NULL) {\n\t\treturn -1;\n\t}\n\tif (de->file.is_directory) {\n\t\tmg_snprintf(de->conn,\n\t\t            NULL, /* Buffer is big enough */\n\t\t            size,\n\t\t            sizeof(size),\n\t\t            \"%s\",\n\t\t            \"[DIRECTORY]\");\n\t} else {\n\t\t/* We use (signed) cast below because MSVC 6 compiler cannot\n\t\t * convert unsigned __int64 to double. Sigh. */\n\t\tif (de->file.size < 1024) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%d\",\n\t\t\t            (int)de->file.size);\n\t\t} else if (de->file.size < 0x100000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fk\",\n\t\t\t            (double)de->file.size / 1024.0);\n\t\t} else if (de->file.size < 0x40000000) {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fM\",\n\t\t\t            (double)de->file.size / 1048576);\n\t\t} else {\n\t\t\tmg_snprintf(de->conn,\n\t\t\t            NULL, /* Buffer is big enough */\n\t\t\t            size,\n\t\t\t            sizeof(size),\n\t\t\t            \"%.1fG\",\n\t\t\t            (double)de->file.size / 1073741824);\n\t\t}\n\t}\n\n\t/* Note: mg_snprintf will not cause a buffer overflow above.\n\t * So, string truncation checks are not required here. */\n\n#if defined(REENTRANT_TIME)\n\tlocaltime_r(&de->file.last_modified, tm);\n#else\n\ttm = localtime(&de->file.last_modified);\n#endif\n\tif (tm != NULL) {\n\t\tstrftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", tm);\n\t} else {\n\t\tmg_strlcpy(mod, \"01-Jan-1970 00:00\", sizeof(mod));\n\t\tmod[sizeof(mod) - 1] = '\\0';\n\t}\n\tmg_url_encode(de->file_name, href, hrefsize);\n\tmg_printf(de->conn,\n\t          \"<tr><td><a href=\\\"%s%s%s\\\">%s%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          de->conn->request_info.local_uri,\n\t          href,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          de->file_name,\n\t          de->file.is_directory ? \"/\" : \"\",\n\t          mod,\n\t          size);\n\tmg_free(href);\n\treturn 0;\n}\n\n\n/* This function is called from send_directory() and used for\n * sorting directory entries by size, or name, or modification time.\n * On windows, __cdecl specification is needed in case if project is built\n * with __stdcall convention. qsort always requires __cdels callback. */\nstatic int WINCDECL\ncompare_dir_entries(const void *p1, const void *p2)\n{\n\tif (p1 && p2) {\n\t\tconst struct de *a = (const struct de *)p1, *b = (const struct de *)p2;\n\t\tconst char *query_string = a->conn->request_info.query_string;\n\t\tint cmp_result = 0;\n\n\t\tif (query_string == NULL) {\n\t\t\tquery_string = \"na\";\n\t\t}\n\n\t\tif (a->file.is_directory && !b->file.is_directory) {\n\t\t\treturn -1; /* Always put directories on top */\n\t\t} else if (!a->file.is_directory && b->file.is_directory) {\n\t\t\treturn 1; /* Always put directories on top */\n\t\t} else if (*query_string == 'n') {\n\t\t\tcmp_result = strcmp(a->file_name, b->file_name);\n\t\t} else if (*query_string == 's') {\n\t\t\tcmp_result = (a->file.size == b->file.size)\n\t\t\t                 ? 0\n\t\t\t                 : ((a->file.size > b->file.size) ? 1 : -1);\n\t\t} else if (*query_string == 'd') {\n\t\t\tcmp_result =\n\t\t\t    (a->file.last_modified == b->file.last_modified)\n\t\t\t        ? 0\n\t\t\t        : ((a->file.last_modified > b->file.last_modified) ? 1\n\t\t\t                                                           : -1);\n\t\t}\n\n\t\treturn (query_string[1] == 'd') ? -cmp_result : cmp_result;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nmust_hide_file(struct mg_connection *conn, const char *path)\n{\n\tif (conn && conn->dom_ctx) {\n\t\tconst char *pw_pattern = \"**\" PASSWORDS_FILE_NAME \"$\";\n\t\tconst char *pattern = conn->dom_ctx->config[HIDE_FILES];\n\t\treturn (match_prefix(pw_pattern, strlen(pw_pattern), path) > 0)\n\t\t       || ((pattern != NULL)\n\t\t           && (match_prefix(pattern, strlen(pattern), path) > 0));\n\t}\n\treturn 0;\n}\n\n\nstatic int\nscan_directory(struct mg_connection *conn,\n               const char *dir,\n               void *data,\n               int (*cb)(struct de *, void *))\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir and hidden files */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")\n\t\t\t    || must_hide_file(conn, dp->d_name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* If the path is not complete, skip processing. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t}\n\t\t\tde.file_name = dp->d_name;\n\t\t\tcb(&de, data);\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\t}\n\treturn 1;\n}\n\n\n#if !defined(NO_FILES)\nstatic int\nremove_directory(struct mg_connection *conn, const char *dir)\n{\n\tchar path[PATH_MAX];\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tstruct de de;\n\tint truncated;\n\tint ok = 1;\n\n\tif ((dirp = mg_opendir(conn, dir)) == NULL) {\n\t\treturn 0;\n\t} else {\n\t\tde.conn = conn;\n\n\t\twhile ((dp = mg_readdir(dirp)) != NULL) {\n\t\t\t/* Do not show current dir (but show hidden files as they will\n\t\t\t * also be removed) */\n\t\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmg_snprintf(\n\t\t\t    conn, &truncated, path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n\n\t\t\t/* If we don't memset stat structure to zero, mtime will have\n\t\t\t * garbage and strftime() will segfault later on in\n\t\t\t * print_dir_entry(). memset is required only if mg_stat()\n\t\t\t * fails. For more details, see\n\t\t\t * http://code.google.com/p/mongoose/issues/detail?id=79 */\n\t\t\tmemset(&de.file, 0, sizeof(de.file));\n\n\t\t\tif (truncated) {\n\t\t\t\t/* Do not delete anything shorter */\n\t\t\t\tok = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!mg_stat(conn, path, &de.file)) {\n\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                path,\n\t\t\t\t                strerror(ERRNO));\n\t\t\t\tok = 0;\n\t\t\t}\n\n\t\t\tif (de.file.is_directory) {\n\t\t\t\tif (remove_directory(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* This will fail file is the file is in memory */\n\t\t\t\tif (mg_remove(conn, path) == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void)mg_closedir(dirp);\n\n\t\tIGNORE_UNUSED_RESULT(rmdir(dir));\n\t}\n\n\treturn ok;\n}\n#endif\n\n\nstruct dir_scan_data {\n\tstruct de *entries;\n\tunsigned int num_entries;\n\tunsigned int arr_size;\n};\n\n\n/* Behaves like realloc(), but frees original pointer on failure */\nstatic void *\nrealloc2(void *ptr, size_t size)\n{\n\tvoid *new_ptr = mg_realloc(ptr, size);\n\tif (new_ptr == NULL) {\n\t\tmg_free(ptr);\n\t}\n\treturn new_ptr;\n}\n\n\nstatic int\ndir_scan_callback(struct de *de, void *data)\n{\n\tstruct dir_scan_data *dsd = (struct dir_scan_data *)data;\n\n\tif ((dsd->entries == NULL) || (dsd->num_entries >= dsd->arr_size)) {\n\t\tdsd->arr_size *= 2;\n\t\tdsd->entries =\n\t\t    (struct de *)realloc2(dsd->entries,\n\t\t                          dsd->arr_size * sizeof(dsd->entries[0]));\n\t}\n\tif (dsd->entries == NULL) {\n\t\t/* TODO(lsm, low): propagate an error to the caller */\n\t\tdsd->num_entries = 0;\n\t} else {\n\t\tdsd->entries[dsd->num_entries].file_name = mg_strdup(de->file_name);\n\t\tdsd->entries[dsd->num_entries].file = de->file;\n\t\tdsd->entries[dsd->num_entries].conn = de->conn;\n\t\tdsd->num_entries++;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_directory_request(struct mg_connection *conn, const char *dir)\n{\n\tunsigned int i;\n\tint sort_direction;\n\tstruct dir_scan_data data = {NULL, 0, 128};\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!scan_directory(conn, dir, &data, dir_scan_callback)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open directory\\nopendir(%s): %s\",\n\t\t                   dir,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tsort_direction = ((conn->request_info.query_string != NULL)\n\t                  && (conn->request_info.query_string[1] == 'd'))\n\t                     ? 'a'\n\t                     : 'd';\n\n\tconn->must_close = 1;\n\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: close\\r\\n\"\n\t          \"Content-Type: text/html; charset=utf-8\\r\\n\\r\\n\",\n\t          date);\n\tmg_printf(conn,\n\t          \"<html><head><title>Index of %s</title>\"\n\t          \"<style>th {text-align: left;}</style></head>\"\n\t          \"<body><h1>Index of %s</h1><pre><table cellpadding=\\\"0\\\">\"\n\t          \"<tr><th><a href=\\\"?n%c\\\">Name</a></th>\"\n\t          \"<th><a href=\\\"?d%c\\\">Modified</a></th>\"\n\t          \"<th><a href=\\\"?s%c\\\">Size</a></th></tr>\"\n\t          \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\",\n\t          conn->request_info.local_uri,\n\t          conn->request_info.local_uri,\n\t          sort_direction,\n\t          sort_direction,\n\t          sort_direction);\n\n\t/* Print first entry - link to a parent directory */\n\tmg_printf(conn,\n\t          \"<tr><td><a href=\\\"%s%s\\\">%s</a></td>\"\n\t          \"<td>&nbsp;%s</td><td>&nbsp;&nbsp;%s</td></tr>\\n\",\n\t          conn->request_info.local_uri,\n\t          \"..\",\n\t          \"Parent directory\",\n\t          \"-\",\n\t          \"-\");\n\n\t/* Sort and print directory entries */\n\tif (data.entries != NULL) {\n\t\tqsort(data.entries,\n\t\t      (size_t)data.num_entries,\n\t\t      sizeof(data.entries[0]),\n\t\t      compare_dir_entries);\n\t\tfor (i = 0; i < data.num_entries; i++) {\n\t\t\tprint_dir_entry(&data.entries[i]);\n\t\t\tmg_free(data.entries[i].file_name);\n\t\t}\n\t\tmg_free(data.entries);\n\t}\n\n\tmg_printf(conn, \"%s\", \"</table></body></html>\");\n\tconn->status_code = 200;\n}\n\n\n/* Send len bytes from the opened file to the client. */\nstatic void\nsend_file_data(struct mg_connection *conn,\n               struct mg_file *filep,\n               int64_t offset,\n               int64_t len)\n{\n\tchar buf[MG_BUF_LEN];\n\tint to_read, num_read, num_written;\n\tint64_t size;\n\n\tif (!filep || !conn) {\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tsize = (filep->stat.size > INT64_MAX) ? INT64_MAX\n\t                                      : (int64_t)(filep->stat.size);\n\toffset = (offset < 0) ? 0 : ((offset > size) ? size : offset);\n\n#if defined(MG_USE_OPEN_FILE)\n\tif ((len > 0) && (filep->access.membuf != NULL) && (size > 0)) {\n\t\t/* file stored in memory */\n\t\tif (len > size - offset) {\n\t\t\tlen = size - offset;\n\t\t}\n\t\tmg_write(conn, filep->access.membuf + offset, (size_t)len);\n\t} else /* else block below */\n#endif\n\t    if (len > 0 && filep->access.fp != NULL) {\n/* file stored on disk */\n#if defined(__linux__)\n\t\t/* sendfile is only available for Linux */\n\t\tif ((conn->ssl == 0) && (conn->throttle == 0)\n\t\t    && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],\n\t\t                       \"yes\"))) {\n\t\t\toff_t sf_offs = (off_t)offset;\n\t\t\tssize_t sf_sent;\n\t\t\tint sf_file = fileno(filep->access.fp);\n\t\t\tint loop_cnt = 0;\n\n\t\t\tdo {\n\t\t\t\t/* 2147479552 (0x7FFFF000) is a limit found by experiment on\n\t\t\t\t * 64 bit Linux (2^31 minus one memory page of 4k?). */\n\t\t\t\tsize_t sf_tosend =\n\t\t\t\t    (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);\n\t\t\t\tsf_sent =\n\t\t\t\t    sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);\n\t\t\t\tif (sf_sent > 0) {\n\t\t\t\t\tlen -= sf_sent;\n\t\t\t\t\toffset += sf_sent;\n\t\t\t\t} else if (loop_cnt == 0) {\n\t\t\t\t\t/* This file can not be sent using sendfile.\n\t\t\t\t\t * This might be the case for pseudo-files in the\n\t\t\t\t\t * /sys/ and /proc/ file system.\n\t\t\t\t\t * Use the regular user mode copy code instead. */\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (sf_sent == 0) {\n\t\t\t\t\t/* No error, but 0 bytes sent. May be EOF? */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tloop_cnt++;\n\n\t\t\t} while ((len > 0) && (sf_sent >= 0));\n\n\t\t\tif (sf_sent > 0) {\n\t\t\t\treturn; /* OK */\n\t\t\t}\n\n\t\t\t/* sf_sent<0 means error, thus fall back to the classic way */\n\t\t\t/* This is always the case, if sf_file is not a \"normal\" file,\n\t\t\t * e.g., for sending data from the output of a CGI process. */\n\t\t\toffset = (int64_t)sf_offs;\n\t\t}\n#endif\n\t\tif ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fseeko() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    500,\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Unable to access file at requested position.\");\n\t\t} else {\n\t\t\twhile (len > 0) {\n\t\t\t\t/* Calculate how much to read from the file in the buffer */\n\t\t\t\tto_read = sizeof(buf);\n\t\t\t\tif ((int64_t)to_read > len) {\n\t\t\t\t\tto_read = (int)len;\n\t\t\t\t}\n\n\t\t\t\t/* Read from file, exit the loop on error */\n\t\t\t\tif ((num_read =\n\t\t\t\t         (int)fread(buf, 1, (size_t)to_read, filep->access.fp))\n\t\t\t\t    <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Send read bytes to the client, exit the loop on error */\n\t\t\t\tif ((num_written = mg_write(conn, buf, (size_t)num_read))\n\t\t\t\t    != num_read) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Both read and were successful, adjust counters */\n\t\t\t\tlen -= num_written;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int\nparse_range_header(const char *header, int64_t *a, int64_t *b)\n{\n\treturn sscanf(header, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n}\n\n\nstatic void\nconstruct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)\n{\n\tif ((filestat != NULL) && (buf != NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* All calls to construct_etag use 64 byte buffer */\n\t\t            buf,\n\t\t            buf_len,\n\t\t            \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n\t\t            (unsigned long)filestat->last_modified,\n\t\t            filestat->size);\n\t}\n}\n\n\nstatic void\nfclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn)\n{\n\tif (filep != NULL && filep->fp != NULL) {\n#if defined(_WIN32)\n\t\t(void)conn; /* Unused. */\n#else\n\t\tif (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n#endif\n\t}\n}\n\n\n#if defined(USE_ZLIB)\n#include \"mod_zlib.inl\"\n#endif\n\n\nstatic void\nhandle_static_file_request(struct mg_connection *conn,\n                           const char *path,\n                           struct mg_file *filep,\n                           const char *mime_type,\n                           const char *additional_headers)\n{\n\tchar date[64], lm[64], etag[64];\n\tchar range[128]; /* large enough, so there will be no overflow */\n\tconst char *msg = \"OK\", *hdr;\n\ttime_t curtime = time(NULL);\n\tint64_t cl, r1, r2;\n\tstruct vec mime_vec;\n\tint n, truncated;\n\tchar gz_path[PATH_MAX];\n\tconst char *encoding = \"\";\n\tconst char *cors1, *cors2, *cors3;\n\tint is_head_request;\n\n#if defined(USE_ZLIB)\n\t/* Compression is allowed, unless there is a reason not to use compression.\n\t * If the file is already compressed, too small or a \"range\" request was\n\t * made, on the fly compression is not possible. */\n\tint allow_on_the_fly_compression = 1;\n#endif\n\n\tif ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tis_head_request = !strcmp(conn->request_info.request_method, \"HEAD\");\n\n\tif (mime_type == NULL) {\n\t\tget_mime_type(conn, path, &mime_vec);\n\t} else {\n\t\tmime_vec.ptr = mime_type;\n\t\tmime_vec.len = strlen(mime_type);\n\t}\n\tif (filep->stat.size > INT64_MAX) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: File size is too large to send\\n%\" INT64_FMT,\n\t\t                   filep->stat.size);\n\t\treturn;\n\t}\n\tcl = (int64_t)filep->stat.size;\n\tconn->status_code = 200;\n\trange[0] = '\\0';\n\n#if defined(USE_ZLIB)\n\t/* if this file is in fact a pre-gzipped file, rewrite its filename\n\t * it's important to rewrite the filename after resolving\n\t * the mime type from it, to preserve the actual file's type */\n\tif (!conn->accept_gzip) {\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\tif (filep->stat.is_gzipped) {\n\t\tmg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), \"%s.gz\", path);\n\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: Path of zipped file too long (%s)\",\n\t\t\t                   path);\n\t\t\treturn;\n\t\t}\n\n\t\tpath = gz_path;\n\t\tencoding = \"Content-Encoding: gzip\\r\\n\";\n\n#if defined(USE_ZLIB)\n\t\t/* File is already compressed. No \"on the fly\" compression. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot open file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&filep->access, conn);\n\n\t/* If \"Range\" request was made: parse header, send only selected part\n\t * of the file. */\n\tr1 = r2 = 0;\n\thdr = mg_get_header(conn, \"Range\");\n\tif ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)\n\t    && (r1 >= 0) && (r2 >= 0)) {\n\t\t/* actually, range requests don't play well with a pre-gzipped\n\t\t * file (since the range is specified in the uncompressed space) */\n\t\tif (filep->stat.is_gzipped) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn,\n\t\t\t    416, /* 416 = Range Not Satisfiable */\n\t\t\t    \"%s\",\n\t\t\t    \"Error: Range requests in gzipped files are not supported\");\n\t\t\t(void)mg_fclose(\n\t\t\t    &filep->access); /* ignore error on read only file */\n\t\t\treturn;\n\t\t}\n\t\tconn->status_code = 206;\n\t\tcl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* range buffer is big enough */\n\t\t            range,\n\t\t            sizeof(range),\n\t\t            \"Content-Range: bytes \"\n\t\t            \"%\" INT64_FMT \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n\t\t            r1,\n\t\t            r1 + cl - 1,\n\t\t            filep->stat.size);\n\t\tmsg = \"Partial Content\";\n\n#if defined(USE_ZLIB)\n\t\t/* Do not compress ranges. */\n\t\tallow_on_the_fly_compression = 0;\n#endif\n\t}\n\n/* Do not compress small files. Small files do not benefit from file\n * compression, but there is still some overhead. */\n#if defined(USE_ZLIB)\n\tif (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {\n\t\t/* File is below the size limit. */\n\t\tallow_on_the_fly_compression = 0;\n\t}\n#endif\n\n\t/* Standard CORS header */\n\thdr = mg_get_header(conn, \"Origin\");\n\tif (hdr) {\n\t\t/* Cross-origin resource sharing (CORS), see\n\t\t * http://www.html5rocks.com/en/tutorials/cors/,\n\t\t * http://www.html5rocks.com/static/images/cors_server_flowchart.png\n\t\t * -\n\t\t * preflight is not supported for files. */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\t/* Prepare Etag, Date, Last-Modified headers. Must be in UTC,\n\t * according to\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3 */\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t/* Send header */\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"%s%s%s\" /* CORS */\n\t                \"Date: %s\\r\\n\"\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Content-Type: %.*s\\r\\n\"\n\t                \"Connection: %s\\r\\n\",\n\t                conn->status_code,\n\t                msg,\n\t                cors1,\n\t                cors2,\n\t                cors3,\n\t                date,\n\t                lm,\n\t                etag,\n\t                (int)mime_vec.len,\n\t                mime_vec.ptr,\n\t                suggest_connection_header(conn));\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\n#if defined(USE_ZLIB)\n\t/* On the fly compression allowed */\n\tif (allow_on_the_fly_compression) {\n\t\t/* For on the fly compression, we don't know the content size in\n\t\t * advance, so we have to use chunked encoding */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Encoding: gzip\\r\\n\"\n\t\t                \"Transfer-Encoding: chunked\\r\\n\");\n\t} else\n#endif\n\t{\n\t\t/* Without on-the-fly compression, we know the content-length\n\t\t * and we can use ranges (with on-the-fly compression we cannot).\n\t\t * So we send these response headers only in this case. */\n\t\t(void)mg_printf(conn,\n\t\t                \"Content-Length: %\" INT64_FMT \"\\r\\n\"\n\t\t                \"Accept-Ranges: bytes\\r\\n\"\n\t\t                \"%s\" /* range */\n\t\t                \"%s\" /* encoding */,\n\t\t                cl,\n\t\t                range,\n\t\t                encoding);\n\t}\n\n\t/* The previous code must not add any header starting with X- to make\n\t * sure no one of the additional_headers is included twice */\n\tif (additional_headers != NULL) {\n\t\t(void)mg_printf(conn,\n\t\t                \"%.*s\\r\\n\\r\\n\",\n\t\t                (int)strlen(additional_headers),\n\t\t                additional_headers);\n\t} else {\n\t\t(void)mg_printf(conn, \"\\r\\n\");\n\t}\n\n\tif (!is_head_request) {\n#if defined(USE_ZLIB)\n\t\tif (allow_on_the_fly_compression) {\n\t\t\t/* Compress and send */\n\t\t\tsend_compressed_data(conn, filep);\n\t\t} else\n#endif\n\t\t{\n\t\t\t/* Send file directly */\n\t\t\tsend_file_data(conn, filep, r1, cl);\n\t\t}\n\t}\n\t(void)mg_fclose(&filep->access); /* ignore error on read only file */\n}\n\n\nint\nmg_send_file_body(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\treturn -1;\n\t}\n\tfclose_on_exec(&file.access, conn);\n\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\treturn 0;                      /* >= 0 for OK */\n}\n\n\n#if !defined(NO_CACHING)\n/* Return True if we should reply 304 Not Modified. */\nstatic int\nis_not_modified(const struct mg_connection *conn,\n                const struct mg_file_stat *filestat)\n{\n\tchar etag[64];\n\tconst char *ims = mg_get_header(conn, \"If-Modified-Since\");\n\tconst char *inm = mg_get_header(conn, \"If-None-Match\");\n\tconstruct_etag(etag, sizeof(etag), filestat);\n\n\treturn ((inm != NULL) && !mg_strcasecmp(etag, inm))\n\t       || ((ims != NULL)\n\t           && (filestat->last_modified <= parse_date_string(ims)));\n}\n\nstatic void\nhandle_not_modified_static_file_request(struct mg_connection *conn,\n                                        struct mg_file *filep)\n{\n\tchar date[64], lm[64], etag[64];\n\ttime_t curtime = time(NULL);\n\n\tif ((conn == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\tconn->status_code = 304;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tgmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);\n\tconstruct_etag(etag, sizeof(etag), &filep->stat);\n\n\t(void)mg_printf(conn,\n\t                \"HTTP/1.1 %d %s\\r\\n\"\n\t                \"Date: %s\\r\\n\",\n\t                conn->status_code,\n\t                mg_get_response_code_text(conn, conn->status_code),\n\t                date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\t(void)mg_printf(conn,\n\t                \"Last-Modified: %s\\r\\n\"\n\t                \"Etag: %s\\r\\n\"\n\t                \"Connection: %s\\r\\n\"\n\t                \"\\r\\n\",\n\t                lm,\n\t                etag,\n\t                suggest_connection_header(conn));\n}\n#endif\n\n\nvoid\nmg_send_file(struct mg_connection *conn, const char *path)\n{\n\tmg_send_mime_file2(conn, path, NULL, NULL);\n}\n\n\nvoid\nmg_send_mime_file(struct mg_connection *conn,\n                  const char *path,\n                  const char *mime_type)\n{\n\tmg_send_mime_file2(conn, path, mime_type, NULL);\n}\n\n\nvoid\nmg_send_mime_file2(struct mg_connection *conn,\n                   const char *path,\n                   const char *mime_type,\n                   const char *additional_headers)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (!conn) {\n\t\t/* No conn */\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n#if !defined(NO_CACHING)\n\t\tif (is_not_modified(conn, &file.stat)) {\n\t\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\t\thandle_not_modified_static_file_request(conn, &file);\n\t\t} else\n#endif /* NO_CACHING */\n\t\t    if (file.stat.is_directory) {\n\t\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t\t                   \"yes\")) {\n\t\t\t\thandle_directory_request(conn, path);\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   403,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Error: Directory listing denied\");\n\t\t\t}\n\t\t} else {\n\t\t\thandle_static_file_request(\n\t\t\t    conn, path, &file, mime_type, additional_headers);\n\t\t}\n\t} else {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Error: File not found\");\n\t}\n}\n\n\n/* For a given PUT path, create all intermediate subdirectories.\n * Return  0  if the path itself is a directory.\n * Return  1  if the path leads to a file.\n * Return -1  for if the path is too long.\n * Return -2  if path can not be created.\n */\nstatic int\nput_dir(struct mg_connection *conn, const char *path)\n{\n\tchar buf[PATH_MAX];\n\tconst char *s, *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint res = 1;\n\n\tfor (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {\n\t\tlen = (size_t)(p - path);\n\t\tif (len >= sizeof(buf)) {\n\t\t\t/* path too long */\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf, path, len);\n\t\tbuf[len] = '\\0';\n\n\t\t/* Try to create intermediate directory */\n\t\tDEBUG_TRACE(\"mkdir(%s)\", buf);\n\t\tif (!mg_stat(conn, buf, &file.stat) && mg_mkdir(conn, buf, 0755) != 0) {\n\t\t\t/* path does not exixt and can not be created */\n\t\t\tres = -2;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Is path itself a directory? */\n\t\tif (p[1] == '\\0') {\n\t\t\tres = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nstatic void\nremove_bad_file(const struct mg_connection *conn, const char *path)\n{\n\tint r = mg_remove(conn, path);\n\tif (r != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Cannot remove invalid file %s\",\n\t\t                __func__,\n\t\t                path);\n\t}\n}\n\n\nlong long\nmg_store_body(struct mg_connection *conn, const char *path)\n{\n\tchar buf[MG_BUF_LEN];\n\tlong long len = 0;\n\tint ret, n;\n\tstruct mg_file fi;\n\n\tif (conn->consumed_content != 0) {\n\t\tmg_cry_internal(conn, \"%s: Contents already consumed\", __func__);\n\t\treturn -11;\n\t}\n\n\tret = put_dir(conn, path);\n\tif (ret < 0) {\n\t\t/* -1 for path too long,\n\t\t * -2 for path can not be created. */\n\t\treturn ret;\n\t}\n\tif (ret != 1) {\n\t\t/* Return 0 means, path itself is a directory. */\n\t\treturn 0;\n\t}\n\n\tif (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {\n\t\treturn -12;\n\t}\n\n\tret = mg_read(conn, buf, sizeof(buf));\n\twhile (ret > 0) {\n\t\tn = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);\n\t\tif (n != ret) {\n\t\t\t(void)mg_fclose(\n\t\t\t    &fi.access); /* File is bad and will be removed anyway. */\n\t\t\tremove_bad_file(conn, path);\n\t\t\treturn -13;\n\t\t}\n\t\tlen += ret;\n\t\tret = mg_read(conn, buf, sizeof(buf));\n\t}\n\n\t/* File is open for writing. If fclose fails, there was probably an\n\t * error flushing the buffer to disk, so the file on disk might be\n\t * broken. Delete it and return an error to the caller. */\n\tif (mg_fclose(&fi.access) != 0) {\n\t\tremove_bad_file(conn, path);\n\t\treturn -14;\n\t}\n\n\treturn len;\n}\n\n\n/* Parse a buffer:\n * Forward the string pointer till the end of a word, then\n * terminate it and forward till the begin of the next word.\n */\nstatic int\nskip_to_end_of_word_and_terminate(char **ppw, int eol)\n{\n\t/* Forward until a space is found - use isgraph here */\n\t/* See http://www.cplusplus.com/reference/cctype/ */\n\twhile (isgraph(**ppw)) {\n\t\t(*ppw)++;\n\t}\n\n\t/* Check end of word */\n\tif (eol) {\n\t\t/* must be a end of line */\n\t\tif ((**ppw != '\\r') && (**ppw != '\\n')) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* must be a end of a word, but not a line */\n\t\tif (**ppw != ' ') {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Terminate and forward to the next word */\n\tdo {\n\t\t**ppw = 0;\n\t\t(*ppw)++;\n\t} while ((**ppw) && isspace(**ppw));\n\n\t/* Check after term */\n\tif (!eol) {\n\t\t/* if it's not the end of line, there must be a next word */\n\t\tif (!isgraph(**ppw)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* ok */\n\treturn 1;\n}\n\n\n/* Parse HTTP headers from the given buffer, advance buf pointer\n * to the point where parsing stopped.\n * All parameters must be valid pointers (not NULL).\n * Return <0 on error. */\nstatic int\nparse_http_headers(char **buf, struct mg_header hdr[MG_MAX_HEADERS])\n{\n\tint i;\n\tint num_headers = 0;\n\n\tfor (i = 0; i < (int)MG_MAX_HEADERS; i++) {\n\t\tchar *dp = *buf;\n\t\twhile ((*dp != ':') && (*dp >= 33) && (*dp <= 126)) {\n\t\t\tdp++;\n\t\t}\n\t\tif (dp == *buf) {\n\t\t\t/* End of headers reached. */\n\t\t\tbreak;\n\t\t}\n\t\tif (*dp != ':') {\n\t\t\t/* This is not a valid field. */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* End of header key (*dp == ':') */\n\t\t/* Truncate here and set the key name */\n\t\t*dp = 0;\n\t\thdr[i].name = *buf;\n\t\tdo {\n\t\t\tdp++;\n\t\t} while (*dp == ' ');\n\n\t\t/* The rest of the line is the value */\n\t\thdr[i].value = dp;\n\t\t*buf = dp + strcspn(dp, \"\\r\\n\");\n\t\tif (((*buf)[0] != '\\r') || ((*buf)[1] != '\\n')) {\n\t\t\t*buf = NULL;\n\t\t}\n\n\t\tnum_headers = i + 1;\n\t\tif (*buf) {\n\t\t\t(*buf)[0] = 0;\n\t\t\t(*buf)[1] = 0;\n\t\t\t*buf += 2;\n\t\t} else {\n\t\t\t*buf = dp;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((*buf)[0] == '\\r') {\n\t\t\t/* This is the end of the header */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn num_headers;\n}\n\n\nstruct mg_http_method_info {\n\tconst char *name;\n\tint request_has_body;\n\tint response_has_body;\n\tint is_safe;\n\tint is_idempotent;\n\tint is_cacheable;\n};\n\n\n/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */\nstatic struct mg_http_method_info http_methods[] = {\n    /* HTTP (RFC 2616) */\n    {\"GET\", 0, 1, 1, 1, 1},\n    {\"POST\", 1, 1, 0, 0, 0},\n    {\"PUT\", 1, 0, 0, 1, 0},\n    {\"DELETE\", 0, 0, 0, 1, 0},\n    {\"HEAD\", 0, 0, 1, 1, 1},\n    {\"OPTIONS\", 0, 0, 1, 1, 0},\n    {\"CONNECT\", 1, 1, 0, 0, 0},\n    /* TRACE method (RFC 2616) is not supported for security reasons */\n\n    /* PATCH method (RFC 5789) */\n    {\"PATCH\", 1, 0, 0, 0, 0},\n    /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */\n\n    /* WEBDAV (RFC 2518) */\n    {\"PROPFIND\", 0, 1, 1, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * Some PROPFIND results MAY be cached, with care,\n     * as there is no cache validation mechanism for\n     * most properties. This method is both safe and\n     * idempotent (see Section 9.1 of [RFC2616]). */\n    {\"MKCOL\", 0, 0, 0, 1, 0},\n    /* http://www.webdav.org/specs/rfc4918.html, 9.1:\n     * When MKCOL is invoked without a request body,\n     * the newly created collection SHOULD have no\n     * members. A MKCOL request message may contain\n     * a message body. The precise behavior of a MKCOL\n     * request when the body is present is undefined,\n     * ... ==> We do not support MKCOL with body data.\n     * This method is idempotent, but not safe (see\n     * Section 9.1 of [RFC2616]). Responses to this\n     * method MUST NOT be cached. */\n\n    /* Unsupported WEBDAV Methods: */\n    /* PROPPATCH, COPY, MOVE, LOCK, UNLOCK (RFC 2518) */\n    /* + 11 methods from RFC 3253 */\n    /* ORDERPATCH (RFC 3648) */\n    /* ACL (RFC 3744) */\n    /* SEARCH (RFC 5323) */\n    /* + MicroSoft extensions\n     * https://msdn.microsoft.com/en-us/library/aa142917.aspx */\n\n    /* REPORT method (RFC 3253) */\n    {\"REPORT\", 1, 1, 1, 1, 1},\n    /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */\n    /* It was defined for WEBDAV in RFC 3253, Sec. 3.6\n     * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems\n     * to be useful for REST in case a \"GET request with body\" is\n     * required. */\n\n    {NULL, 0, 0, 0, 0, 0}\n    /* end of list */\n};\n\n\nstatic const struct mg_http_method_info *\nget_http_method_info(const char *method)\n{\n\t/* Check if the method is known to the server. The list of all known\n\t * HTTP methods can be found here at\n\t * http://www.iana.org/assignments/http-methods/http-methods.xhtml\n\t */\n\tconst struct mg_http_method_info *m = http_methods;\n\n\twhile (m->name) {\n\t\tif (!strcmp(m->name, method)) {\n\t\t\treturn m;\n\t\t}\n\t\tm++;\n\t}\n\treturn NULL;\n}\n\n\nstatic int\nis_valid_http_method(const char *method)\n{\n\treturn (get_http_method_info(method) != NULL);\n}\n\n\n/* Parse HTTP request, fill in mg_request_info structure.\n * This function modifies the buffer by NUL-terminating\n * HTTP request components, header names and header values.\n * Parameters:\n *   buf (in/out): pointer to the HTTP header to parse and split\n *   len (in): length of HTTP header buffer\n *   re (out): parsed header as mg_request_info\n * buf and ri must be valid pointers (not NULL), len>0.\n * Returns <0 on error. */\nstatic int\nparse_http_request(char *buf, int len, struct mg_request_info *ri)\n{\n\tint request_length;\n\tint init_skip = 0;\n\n\t/* Reset attributes. DO NOT TOUCH is_ssl, remote_addr,\n\t * remote_port */\n\tri->remote_user = ri->request_method = ri->request_uri = ri->http_version =\n\t    NULL;\n\tri->num_headers = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\trequest_length = get_http_header_len(buf, len);\n\tif (request_length <= 0) {\n\t\treturn request_length;\n\t}\n\tbuf[request_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word has to be the HTTP method */\n\tri->request_method = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid http method */\n\tif (!is_valid_http_method(ri->request_method)) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the URI */\n\tri->request_uri = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Next would be the HTTP version */\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 1) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(ri->http_version, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version += 5;\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn request_length + init_skip;\n}\n\n\nstatic int\nparse_http_response(char *buf, int len, struct mg_response_info *ri)\n{\n\tint response_length;\n\tint init_skip = 0;\n\tchar *tmp, *tmp2;\n\tlong l;\n\n\t/* Initialize elements. */\n\tri->http_version = ri->status_text = NULL;\n\tri->num_headers = ri->status_code = 0;\n\n\t/* RFC says that all initial whitespaces should be ingored */\n\t/* This included all leading \\r and \\n (isspace) */\n\t/* See table: http://www.cplusplus.com/reference/cctype/ */\n\twhile ((len > 0) && isspace(*(unsigned char *)buf)) {\n\t\tbuf++;\n\t\tlen--;\n\t\tinit_skip++;\n\t}\n\n\tif (len == 0) {\n\t\t/* Incomplete request */\n\t\treturn 0;\n\t}\n\n\t/* Control characters are not allowed, including zero */\n\tif (iscntrl(*(unsigned char *)buf)) {\n\t\treturn -1;\n\t}\n\n\t/* Find end of HTTP header */\n\tresponse_length = get_http_header_len(buf, len);\n\tif (response_length <= 0) {\n\t\treturn response_length;\n\t}\n\tbuf[response_length - 1] = '\\0';\n\n\tif ((*buf == 0) || (*buf == '\\r') || (*buf == '\\n')) {\n\t\treturn -1;\n\t}\n\n\t/* The first word is the HTTP version */\n\t/* Check for a valid HTTP version key */\n\tif (strncmp(buf, \"HTTP/\", 5) != 0) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tbuf += 5;\n\tif (!isgraph(buf[0])) {\n\t\t/* Invalid request */\n\t\treturn -1;\n\t}\n\tri->http_version = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\t/* The second word is the status as a number */\n\ttmp = buf;\n\n\tif (skip_to_end_of_word_and_terminate(&buf, 0) <= 0) {\n\t\treturn -1;\n\t}\n\n\tl = strtol(tmp, &tmp2, 10);\n\tif ((l < 100) || (l >= 1000) || ((tmp2 - tmp) != 3) || (*tmp2 != 0)) {\n\t\t/* Everything else but a 3 digit code is invalid */\n\t\treturn -1;\n\t}\n\tri->status_code = (int)l;\n\n\t/* The rest of the line is the status text */\n\tri->status_text = buf;\n\n\t/* Find end of status text */\n\t/* isgraph or isspace = isprint */\n\twhile (isprint(*buf)) {\n\t\tbuf++;\n\t}\n\tif ((*buf != '\\r') && (*buf != '\\n')) {\n\t\treturn -1;\n\t}\n\t/* Terminate string and forward buf to next line */\n\tdo {\n\t\t*buf = 0;\n\t\tbuf++;\n\t} while ((*buf) && isspace(*buf));\n\n\n\t/* Parse all HTTP headers */\n\tri->num_headers = parse_http_headers(&buf, ri->http_headers);\n\tif (ri->num_headers < 0) {\n\t\t/* Error while parsing headers */\n\t\treturn -1;\n\t}\n\n\treturn response_length + init_skip;\n}\n\n\n/* Keep reading the input (either opened file descriptor fd, or socket sock,\n * or SSL descriptor ssl) into buffer buf, until \\r\\n\\r\\n appears in the\n * buffer (which marks the end of HTTP request). Buffer buf may already\n * have some data. The length of the data is stored in nread.\n * Upon every read operation, increase nread by the number of bytes read. */\nstatic int\nread_message(FILE *fp,\n             struct mg_connection *conn,\n             char *buf,\n             int bufsiz,\n             int *nread)\n{\n\tint request_len, n = 0;\n\tstruct timespec last_action_time;\n\tdouble request_timeout;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tmemset(&last_action_time, 0, sizeof(last_action_time));\n\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\t/* value of request_timeout is in seconds, config in milliseconds */\n\t\trequest_timeout = atof(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t} else {\n\t\trequest_timeout = -1.0;\n\t}\n\tif (conn->handled_requests > 0) {\n\t\tif (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {\n\t\t\trequest_timeout =\n\t\t\t    atof(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) / 1000.0;\n\t\t}\n\t}\n\n\trequest_len = get_http_header_len(buf, *nread);\n\n\t/* first time reading from this connection */\n\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\n\twhile (request_len == 0) {\n\t\t/* Full request not yet received */\n\t\tif (conn->phys_ctx->stop_flag != 0) {\n\t\t\t/* Server is to be stopped. */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*nread >= bufsiz) {\n\t\t\t/* Request too long */\n\t\t\treturn -2;\n\t\t}\n\n\t\tn = pull_inner(\n\t\t    fp, conn, buf + *nread, bufsiz - *nread, request_timeout);\n\t\tif (n == -2) {\n\t\t\t/* Receive error */\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0) {\n\t\t\t*nread += n;\n\t\t\trequest_len = get_http_header_len(buf, *nread);\n\t\t} else {\n\t\t\trequest_len = 0;\n\t\t}\n\n\t\tif ((request_len == 0) && (request_timeout >= 0)) {\n\t\t\tif (mg_difftimespec(&last_action_time, &(conn->req_time))\n\t\t\t    > request_timeout) {\n\t\t\t\t/* Timeout */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &last_action_time);\n\t\t}\n\t}\n\n\treturn request_len;\n}\n\n\n#if !defined(NO_CGI) || !defined(NO_FILES)\nstatic int\nforward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl)\n{\n\tconst char *expect, *body;\n\tchar buf[MG_BUF_LEN];\n\tint to_read, nread, success = 0;\n\tint64_t buffered_len;\n\tdouble timeout = -1.0;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\tif (conn->dom_ctx->config[REQUEST_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\texpect = mg_get_header(conn, \"Expect\");\n\tDEBUG_ASSERT(fp != NULL);\n\tif (!fp) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: NULL File\");\n\t\treturn 0;\n\t}\n\n\tif ((conn->content_len == -1) && (!conn->is_chunked)) {\n\t\t/* Content length is not specified by the client. */\n\t\tmg_send_http_error(conn,\n\t\t                   411,\n\t\t                   \"%s\",\n\t\t                   \"Error: Client did not specify content length\");\n\t} else if ((expect != NULL)\n\t           && (mg_strcasecmp(expect, \"100-continue\") != 0)) {\n\t\t/* Client sent an \"Expect: xyz\" header and xyz is not 100-continue.\n\t\t */\n\t\tmg_send_http_error(conn,\n\t\t                   417,\n\t\t                   \"Error: Can not fulfill expectation %s\",\n\t\t                   expect);\n\t} else {\n\t\tif (expect != NULL) {\n\t\t\t(void)mg_printf(conn, \"%s\", \"HTTP/1.1 100 Continue\\r\\n\\r\\n\");\n\t\t\tconn->status_code = 100;\n\t\t} else {\n\t\t\tconn->status_code = 200;\n\t\t}\n\n\t\tbuffered_len = (int64_t)(conn->data_len) - (int64_t)conn->request_len\n\t\t               - conn->consumed_content;\n\n\t\tDEBUG_ASSERT(buffered_len >= 0);\n\t\tDEBUG_ASSERT(conn->consumed_content == 0);\n\n\t\tif ((buffered_len < 0) || (conn->consumed_content != 0)) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Error: Size mismatch\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (buffered_len > 0) {\n\t\t\tif ((int64_t)buffered_len > conn->content_len) {\n\t\t\t\tbuffered_len = (int)conn->content_len;\n\t\t\t}\n\t\t\tbody = conn->buf + conn->request_len + conn->consumed_content;\n\t\t\tpush_all(\n\t\t\t    conn->phys_ctx, fp, sock, ssl, body, (int64_t)buffered_len);\n\t\t\tconn->consumed_content += buffered_len;\n\t\t}\n\n\t\tnread = 0;\n\t\twhile (conn->consumed_content < conn->content_len) {\n\t\t\tto_read = sizeof(buf);\n\t\t\tif ((int64_t)to_read > conn->content_len - conn->consumed_content) {\n\t\t\t\tto_read = (int)(conn->content_len - conn->consumed_content);\n\t\t\t}\n\t\t\tnread = pull_inner(NULL, conn, buf, to_read, timeout);\n\t\t\tif (nread == -2) {\n\t\t\t\t/* error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nread > 0) {\n\t\t\t\tif (push_all(conn->phys_ctx, fp, sock, ssl, buf, nread)\n\t\t\t\t    != nread) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconn->consumed_content += nread;\n\t\t}\n\n\t\tif (conn->consumed_content == conn->content_len) {\n\t\t\tsuccess = (nread >= 0);\n\t\t}\n\n\t\t/* Each error code path in this function must send an error */\n\t\tif (!success) {\n\t\t\t/* NOTE: Maybe some data has already been sent. */\n\t\t\t/* TODO (low): If some data has been sent, a correct error\n\t\t\t * reply can no longer be sent, so just close the connection */\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"\");\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif\n\n\n#if defined(USE_TIMERS)\n\n#define TIMER_API static\n#include \"timer.inl\"\n\n#endif /* USE_TIMERS */\n\n\n#if !defined(NO_CGI)\n/* This structure helps to create an environment for the spawned CGI\n * program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these\n * VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf. */\nstruct cgi_environment {\n\tstruct mg_connection *conn;\n\t/* Data block */\n\tchar *buf;      /* Environment buffer */\n\tsize_t buflen;  /* Space available in buf */\n\tsize_t bufused; /* Space taken in buf */\n\t                /* Index block */\n\tchar **var;     /* char **envp */\n\tsize_t varlen;  /* Number of variables available in var */\n\tsize_t varused; /* Number of variables stored in var */\n};\n\n\nstatic void addenv(struct cgi_environment *env,\n                   PRINTF_FORMAT_STRING(const char *fmt),\n                   ...) PRINTF_ARGS(2, 3);\n\n/* Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array. Assumes env != NULL and fmt != NULL. */\nstatic void\naddenv(struct cgi_environment *env, const char *fmt, ...)\n{\n\tsize_t n, space;\n\tint truncated = 0;\n\tchar *added;\n\tva_list ap;\n\n\t/* Calculate how much space is left in the buffer */\n\tspace = (env->buflen - env->bufused);\n\n\t/* Calculate an estimate for the required space */\n\tn = strlen(fmt) + 2 + 128;\n\n\tdo {\n\t\tif (space <= n) {\n\t\t\t/* Allocate new buffer */\n\t\t\tn = env->buflen + CGI_ENVIRONMENT_SIZE;\n\t\t\tadded = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);\n\t\t\tif (!added) {\n\t\t\t\t/* Out of memory */\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    env->conn,\n\t\t\t\t    \"%s: Cannot allocate memory for CGI variable [%s]\",\n\t\t\t\t    __func__,\n\t\t\t\t    fmt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tenv->buf = added;\n\t\t\tenv->buflen = n;\n\t\t\tspace = (env->buflen - env->bufused);\n\t\t}\n\n\t\t/* Make a pointer to the free space int the buffer */\n\t\tadded = env->buf + env->bufused;\n\n\t\t/* Copy VARIABLE=VALUE\\0 string into the free space */\n\t\tva_start(ap, fmt);\n\t\tmg_vsnprintf(env->conn, &truncated, added, (size_t)space, fmt, ap);\n\t\tva_end(ap);\n\n\t\t/* Do not add truncated strings to the environment */\n\t\tif (truncated) {\n\t\t\t/* Reallocate the buffer */\n\t\t\tspace = 0;\n\t\t\tn = 1;\n\t\t}\n\t} while (truncated);\n\n\t/* Calculate number of bytes added to the environment */\n\tn = strlen(added) + 1;\n\tenv->bufused += n;\n\n\t/* Now update the variable index */\n\tspace = (env->varlen - env->varused);\n\tif (space < 2) {\n\t\tmg_cry_internal(env->conn,\n\t\t                \"%s: Cannot register CGI variable [%s]\",\n\t\t                __func__,\n\t\t                fmt);\n\t\treturn;\n\t}\n\n\t/* Append a pointer to the added string into the envp array */\n\tenv->var[env->varused] = added;\n\tenv->varused++;\n}\n\n/* Return 0 on success, non-zero if an error occurs. */\n\nstatic int\nprepare_cgi_environment(struct mg_connection *conn,\n                        const char *prog,\n                        struct cgi_environment *env)\n{\n\tconst char *s;\n\tstruct vec var_vec;\n\tchar *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];\n\tint i, truncated, uri_len;\n\n\tif ((conn == NULL) || (prog == NULL) || (env == NULL)) {\n\t\treturn -1;\n\t}\n\n\tenv->conn = conn;\n\tenv->buflen = CGI_ENVIRONMENT_SIZE;\n\tenv->bufused = 0;\n\tenv->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);\n\tif (env->buf == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental buffer\",\n\t\t                __func__);\n\t\treturn -1;\n\t}\n\tenv->varlen = MAX_CGI_ENVIR_VARS;\n\tenv->varused = 0;\n\tenv->var =\n\t    (char **)mg_malloc_ctx(env->buflen * sizeof(char *), conn->phys_ctx);\n\tif (env->var == NULL) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: Not enough memory for environmental variables\",\n\t\t                __func__);\n\t\tmg_free(env->buf);\n\t\treturn -1;\n\t}\n\n\taddenv(env, \"SERVER_NAME=%s\", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);\n\taddenv(env, \"SERVER_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"DOCUMENT_ROOT=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\taddenv(env, \"SERVER_SOFTWARE=CivetWeb/%s\", mg_version());\n\n\t/* Prepare the environment block */\n\taddenv(env, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n\taddenv(env, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n\taddenv(env, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin6.sin6_port));\n\t} else\n#endif\n\t{\n\t\taddenv(env, \"SERVER_PORT=%d\", ntohs(conn->client.lsa.sin.sin_port));\n\t}\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\taddenv(env, \"REMOTE_ADDR=%s\", src_addr);\n\n\taddenv(env, \"REQUEST_METHOD=%s\", conn->request_info.request_method);\n\taddenv(env, \"REMOTE_PORT=%d\", conn->request_info.remote_port);\n\n\taddenv(env, \"REQUEST_URI=%s\", conn->request_info.request_uri);\n\taddenv(env, \"LOCAL_URI=%s\", conn->request_info.local_uri);\n\n\t/* SCRIPT_NAME */\n\turi_len = (int)strlen(conn->request_info.local_uri);\n\tif (conn->path_info == NULL) {\n\t\tif (conn->request_info.local_uri[uri_len - 1] != '/') {\n\t\t\t/* URI: /path_to_script/script.cgi */\n\t\t\taddenv(env, \"SCRIPT_NAME=%s\", conn->request_info.local_uri);\n\t\t} else {\n\t\t\t/* URI: /path_to_script/ ... using index.cgi */\n\t\t\tconst char *index_file = strrchr(prog, '/');\n\t\t\tif (index_file) {\n\t\t\t\taddenv(env,\n\t\t\t\t       \"SCRIPT_NAME=%s%s\",\n\t\t\t\t       conn->request_info.local_uri,\n\t\t\t\t       index_file + 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* URI: /path_to_script/script.cgi/path_info */\n\t\taddenv(env,\n\t\t       \"SCRIPT_NAME=%.*s\",\n\t\t       uri_len - (int)strlen(conn->path_info),\n\t\t       conn->request_info.local_uri);\n\t}\n\n\taddenv(env, \"SCRIPT_FILENAME=%s\", prog);\n\tif (conn->path_info == NULL) {\n\t\taddenv(env, \"PATH_TRANSLATED=%s\", conn->dom_ctx->config[DOCUMENT_ROOT]);\n\t} else {\n\t\taddenv(env,\n\t\t       \"PATH_TRANSLATED=%s%s\",\n\t\t       conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t       conn->path_info);\n\t}\n\n\taddenv(env, \"HTTPS=%s\", (conn->ssl == NULL) ? \"off\" : \"on\");\n\n\tif ((s = mg_get_header(conn, \"Content-Type\")) != NULL) {\n\t\taddenv(env, \"CONTENT_TYPE=%s\", s);\n\t}\n\tif (conn->request_info.query_string != NULL) {\n\t\taddenv(env, \"QUERY_STRING=%s\", conn->request_info.query_string);\n\t}\n\tif ((s = mg_get_header(conn, \"Content-Length\")) != NULL) {\n\t\taddenv(env, \"CONTENT_LENGTH=%s\", s);\n\t}\n\tif ((s = getenv(\"PATH\")) != NULL) {\n\t\taddenv(env, \"PATH=%s\", s);\n\t}\n\tif (conn->path_info != NULL) {\n\t\taddenv(env, \"PATH_INFO=%s\", conn->path_info);\n\t}\n\n\tif (conn->status_code > 0) {\n\t\t/* CGI error handler should show the status code */\n\t\taddenv(env, \"STATUS=%d\", conn->status_code);\n\t}\n\n#if defined(_WIN32)\n\tif ((s = getenv(\"COMSPEC\")) != NULL) {\n\t\taddenv(env, \"COMSPEC=%s\", s);\n\t}\n\tif ((s = getenv(\"SYSTEMROOT\")) != NULL) {\n\t\taddenv(env, \"SYSTEMROOT=%s\", s);\n\t}\n\tif ((s = getenv(\"SystemDrive\")) != NULL) {\n\t\taddenv(env, \"SystemDrive=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles=%s\", s);\n\t}\n\tif ((s = getenv(\"ProgramFiles(x86)\")) != NULL) {\n\t\taddenv(env, \"ProgramFiles(x86)=%s\", s);\n\t}\n#else\n\tif ((s = getenv(\"LD_LIBRARY_PATH\")) != NULL) {\n\t\taddenv(env, \"LD_LIBRARY_PATH=%s\", s);\n\t}\n#endif /* _WIN32 */\n\n\tif ((s = getenv(\"PERLLIB\")) != NULL) {\n\t\taddenv(env, \"PERLLIB=%s\", s);\n\t}\n\n\tif (conn->request_info.remote_user != NULL) {\n\t\taddenv(env, \"REMOTE_USER=%s\", conn->request_info.remote_user);\n\t\taddenv(env, \"%s\", \"AUTH_TYPE=Digest\");\n\t}\n\n\t/* Add all headers as HTTP_* variables */\n\tfor (i = 0; i < conn->request_info.num_headers; i++) {\n\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  http_var_name,\n\t\t                  sizeof(http_var_name),\n\t\t                  \"HTTP_%s\",\n\t\t                  conn->request_info.http_headers[i].name);\n\n\t\tif (truncated) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s: HTTP header variable too long [%s]\",\n\t\t\t                __func__,\n\t\t\t                conn->request_info.http_headers[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Convert variable name into uppercase, and change - to _ */\n\t\tfor (p = http_var_name; *p != '\\0'; p++) {\n\t\t\tif (*p == '-') {\n\t\t\t\t*p = '_';\n\t\t\t}\n\t\t\t*p = (char)toupper(*(unsigned char *)p);\n\t\t}\n\n\t\taddenv(env,\n\t\t       \"%s=%s\",\n\t\t       http_var_name,\n\t\t       conn->request_info.http_headers[i].value);\n\t}\n\n\t/* Add user-specified variables */\n\ts = conn->dom_ctx->config[CGI_ENVIRONMENT];\n\twhile ((s = next_option(s, &var_vec, NULL)) != NULL) {\n\t\taddenv(env, \"%.*s\", (int)var_vec.len, var_vec.ptr);\n\t}\n\n\tenv->var[env->varused] = NULL;\n\tenv->buf[env->bufused] = '\\0';\n\n\treturn 0;\n}\n\n\n/* Data for CGI process control: PID and number of references */\nstruct process_control_data {\n\tpid_t pid;\n\tint references;\n};\n\nstatic int\nabort_process(void *data)\n{\n\t/* Waitpid checks for child status and won't work for a pid that does not\n\t * identify a child of the current process. Thus, if the pid is reused,\n\t * we will not affect a different process. */\n\tstruct process_control_data *proc = (struct process_control_data *)data;\n\tint status = 0;\n\tint refs;\n\tpid_t ret_pid;\n\n\tret_pid = waitpid(proc->pid, &status, WNOHANG);\n\tif ((ret_pid != (pid_t)-1) && (status == 0)) {\n\t\t/* Stop child process */\n\t\tDEBUG_TRACE(\"CGI timer: Stop child process %p\\n\", proc->pid);\n\t\tkill(proc->pid, SIGABRT);\n\n\t\t/* Wait until process is terminated (don't leave zombies) */\n\t\twhile (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */\n\t\t\t;\n\t} else {\n\t\tDEBUG_TRACE(\"CGI timer: Child process %p already stopped\\n\", proc->pid);\n\t}\n\t/* Dec reference counter */\n\trefs = mg_atomic_dec(&proc->references);\n\tif (refs == 0) {\n\t\t/* no more references - free data */\n\t\tmg_free(data);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_cgi_request(struct mg_connection *conn, const char *prog)\n{\n\tchar *buf;\n\tsize_t buflen;\n\tint headers_len, data_len, i, truncated;\n\tint fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};\n\tconst char *status, *status_text, *connection_state;\n\tchar *pbuf, dir[PATH_MAX], *p;\n\tstruct mg_request_info ri;\n\tstruct cgi_environment blk;\n\tFILE *in = NULL, *out = NULL, *err = NULL;\n\tstruct mg_file fout = STRUCT_FILE_INITIALIZER;\n\tpid_t pid = (pid_t)-1;\n\tstruct process_control_data *proc = NULL;\n\n#if defined(USE_TIMERS)\n\tdouble cgi_timeout = -1.0;\n\tif (conn->dom_ctx->config[CGI_TIMEOUT]) {\n\t\t/* Get timeout in seconds */\n\t\tcgi_timeout = atof(conn->dom_ctx->config[CGI_TIMEOUT]) * 0.001;\n\t}\n#endif\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tbuf = NULL;\n\tbuflen = conn->phys_ctx->max_request_size;\n\ti = prepare_cgi_environment(conn, prog, &blk);\n\tif (i != 0) {\n\t\tblk.buf = NULL;\n\t\tblk.var = NULL;\n\t\tgoto done;\n\t}\n\n\t/* CGI must be executed in its own directory. 'dir' must point to the\n\t * directory containing executable program, 'p' must point to the\n\t * executable program name relative to 'dir'. */\n\t(void)mg_snprintf(conn, &truncated, dir, sizeof(dir), \"%s\", prog);\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Path too long\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: %s\", \"CGI path too long\");\n\t\tgoto done;\n\t}\n\n\tif ((p = strrchr(dir, '/')) != NULL) {\n\t\t*p++ = '\\0';\n\t} else {\n\t\tdir[0] = '.';\n\t\tdir[1] = '\\0';\n\t\tp = (char *)prog;\n\t}\n\n\tif ((pipe(fdin) != 0) || (pipe(fdout) != 0) || (pipe(fderr) != 0)) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not create CGI pipes: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot create CGI pipe: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tproc = (struct process_control_data *)\n\t    mg_malloc_ctx(sizeof(struct process_control_data), conn->phys_ctx);\n\tif (proc == NULL) {\n\t\tmg_cry_internal(conn, \"Error: CGI program \\\"%s\\\": Out or memory\", prog);\n\t\tmg_send_http_error(conn, 500, \"Error: Out of memory [%s]\", prog);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: spawn %s %s\\n\", dir, p);\n\tpid = spawn_process(conn, p, blk.buf, blk.var, fdin, fdout, fderr, dir);\n\n\tif (pid == (pid_t)-1) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Can not spawn CGI process: %s\",\n\t\t    prog,\n\t\t    status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot spawn CGI process [%s]: %s\",\n\t\t                   prog,\n\t\t                   status);\n\t\tmg_free(proc);\n\t\tproc = NULL;\n\t\tgoto done;\n\t}\n\n\t/* Store data in shared process_control_data */\n\tproc->pid = pid;\n\tproc->references = 1;\n\n#if defined(USE_TIMERS)\n\tif (cgi_timeout > 0.0) {\n\t\tproc->references = 2;\n\n\t\t// Start a timer for CGI\n\t\ttimer_add(conn->phys_ctx,\n\t\t          cgi_timeout /* in seconds */,\n\t\t          0.0,\n\t\t          1,\n\t\t          abort_process,\n\t\t          (void *)proc);\n\t}\n#endif\n\n\t/* Make sure child closes all pipe descriptors. It must dup them to 0,1 */\n\tset_close_on_exec((SOCKET)fdin[0], conn);  /* stdin read */\n\tset_close_on_exec((SOCKET)fdin[1], conn);  /* stdin write */\n\tset_close_on_exec((SOCKET)fdout[0], conn); /* stdout read */\n\tset_close_on_exec((SOCKET)fdout[1], conn); /* stdout write */\n\tset_close_on_exec((SOCKET)fderr[0], conn); /* stderr read */\n\tset_close_on_exec((SOCKET)fderr[1], conn); /* stderr write */\n\n\t/* Parent closes only one side of the pipes.\n\t * If we don't mark them as closed, close() attempt before\n\t * return from this function throws an exception on Windows.\n\t * Windows does not like when closed descriptor is closed again. */\n\t(void)close(fdin[0]);\n\t(void)close(fdout[1]);\n\t(void)close(fderr[1]);\n\tfdin[0] = fdout[1] = fderr[1] = -1;\n\n\tif ((in = fdopen(fdin[1], \"wb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdin: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdin\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((out = fdopen(fdout[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stdout: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fdout\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tif ((err = fdopen(fderr[0], \"rb\")) == NULL) {\n\t\tstatus = strerror(ERRNO);\n\t\tmg_cry_internal(conn,\n\t\t                \"Error: CGI program \\\"%s\\\": Can not open stderr: %s\",\n\t\t                prog,\n\t\t                status);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: CGI can not open fderr\\nfopen: %s\",\n\t\t                   status);\n\t\tgoto done;\n\t}\n\n\tsetbuf(in, NULL);\n\tsetbuf(out, NULL);\n\tsetbuf(err, NULL);\n\tfout.access.fp = out;\n\n\tif ((conn->request_info.content_length != 0) || (conn->is_chunked)) {\n\t\tDEBUG_TRACE(\"CGI: send body data (%lli)\\n\",\n\t\t            (signed long long)conn->request_info.content_length);\n\n\t\t/* This is a POST/PUT request, or another request with body data. */\n\t\tif (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {\n\t\t\t/* Error sending the body data */\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"Error: CGI program \\\"%s\\\": Forward body data failed\",\n\t\t\t    prog);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Close so child gets an EOF. */\n\tfclose(in);\n\tin = NULL;\n\tfdin[1] = -1;\n\n\t/* Now read CGI reply into a buffer. We need to set correct\n\t * status code, thus we need to see all HTTP headers first.\n\t * Do not send anything back to client, until we buffer in all\n\t * HTTP headers. */\n\tdata_len = 0;\n\tbuf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);\n\tif (buf == NULL) {\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Not enough memory for CGI buffer (%u bytes)\",\n\t\t                   (unsigned int)buflen);\n\t\tmg_cry_internal(\n\t\t    conn,\n\t\t    \"Error: CGI program \\\"%s\\\": Not enough memory for buffer (%u \"\n\t\t    \"bytes)\",\n\t\t    prog,\n\t\t    (unsigned int)buflen);\n\t\tgoto done;\n\t}\n\n\tDEBUG_TRACE(\"CGI: %s\", \"wait for response\");\n\theaders_len = read_message(out, conn, buf, (int)buflen, &data_len);\n\tDEBUG_TRACE(\"CGI: response: %li\", (signed long)headers_len);\n\n\tif (headers_len <= 0) {\n\n\t\t/* Could not parse the CGI response. Check if some error message on\n\t\t * stderr. */\n\t\ti = pull_all(err, conn, buf, (int)buflen);\n\t\tif (i > 0) {\n\t\t\t/* CGI program explicitly sent an error */\n\t\t\t/* Write the error message to the internal log */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program \\\"%s\\\" sent error \"\n\t\t\t                \"message: [%.*s]\",\n\t\t\t                prog,\n\t\t\t                i,\n\t\t\t                buf);\n\t\t\t/* Don't send the error message back to the client */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program \\\"%s\\\" failed.\",\n\t\t\t                   prog);\n\t\t} else {\n\t\t\t/* CGI program did not explicitly send an error, but a broken\n\t\t\t * respon header */\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error: CGI program sent malformed or too big \"\n\t\t\t                \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                (unsigned)buflen,\n\t\t\t                data_len,\n\t\t\t                buf);\n\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   500,\n\t\t\t                   \"Error: CGI program sent malformed or too big \"\n\t\t\t                   \"(>%u bytes) HTTP headers: [%.*s]\",\n\t\t\t                   (unsigned)buflen,\n\t\t\t                   data_len,\n\t\t\t                   buf);\n\t\t}\n\n\t\t/* in both cases, abort processing CGI */\n\t\tgoto done;\n\t}\n\n\tpbuf = buf;\n\tbuf[headers_len - 1] = '\\0';\n\tri.num_headers = parse_http_headers(&pbuf, ri.http_headers);\n\n\t/* Make up and send the status line */\n\tstatus_text = \"OK\";\n\tif ((status = get_header(ri.http_headers, ri.num_headers, \"Status\"))\n\t    != NULL) {\n\t\tconn->status_code = atoi(status);\n\t\tstatus_text = status;\n\t\twhile (isdigit(*(const unsigned char *)status_text)\n\t\t       || *status_text == ' ') {\n\t\t\tstatus_text++;\n\t\t}\n\t} else if (get_header(ri.http_headers, ri.num_headers, \"Location\")\n\t           != NULL) {\n\t\tconn->status_code = 307;\n\t} else {\n\t\tconn->status_code = 200;\n\t}\n\tconnection_state =\n\t    get_header(ri.http_headers, ri.num_headers, \"Connection\");\n\tif (!header_has_option(connection_state, \"keep-alive\")) {\n\t\tconn->must_close = 1;\n\t}\n\n\tDEBUG_TRACE(\"CGI: response %u %s\", conn->status_code, status_text);\n\n\t(void)mg_printf(conn, \"HTTP/1.1 %d %s\\r\\n\", conn->status_code, status_text);\n\n\t/* Send headers */\n\tfor (i = 0; i < ri.num_headers; i++) {\n\t\tmg_printf(conn,\n\t\t          \"%s: %s\\r\\n\",\n\t\t          ri.http_headers[i].name,\n\t\t          ri.http_headers[i].value);\n\t}\n\tmg_write(conn, \"\\r\\n\", 2);\n\n\t/* Send chunk of data that may have been read after the headers */\n\tmg_write(conn, buf + headers_len, (size_t)(data_len - headers_len));\n\n\t/* Read the rest of CGI output and send to the client */\n\tDEBUG_TRACE(\"CGI: %s\", \"forward all data\");\n\tsend_file_data(conn, &fout, 0, INT64_MAX);\n\tDEBUG_TRACE(\"CGI: %s\", \"all data sent\");\n\ndone:\n\tmg_free(blk.var);\n\tmg_free(blk.buf);\n\n\tif (pid != (pid_t)-1) {\n\t\tabort_process((void *)proc);\n\t}\n\n\tif (fdin[0] != -1) {\n\t\tclose(fdin[0]);\n\t}\n\tif (fdout[1] != -1) {\n\t\tclose(fdout[1]);\n\t}\n\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else if (fdin[1] != -1) {\n\t\tclose(fdin[1]);\n\t}\n\n\tif (out != NULL) {\n\t\tfclose(out);\n\t} else if (fdout[0] != -1) {\n\t\tclose(fdout[0]);\n\t}\n\n\tif (err != NULL) {\n\t\tfclose(err);\n\t} else if (fderr[0] != -1) {\n\t\tclose(fderr[0]);\n\t}\n\n\tif (buf != NULL) {\n\t\tmg_free(buf);\n\t}\n}\n#endif /* !NO_CGI */\n\n\n#if !defined(NO_FILES)\nstatic void\nmkcol(struct mg_connection *conn, const char *path)\n{\n\tint rc, body_len;\n\tstruct de de;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* TODO (mid): Check the mg_send_http_error situations in this function\n\t */\n\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: mg_stat(%s) failed: %s\",\n\t\t                __func__,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t}\n\n\tif (de.file.last_modified) {\n\t\t/* TODO (mid): This check does not seem to make any sense ! */\n\t\t/* TODO (mid): Add a webdav unit test first, before changing\n\t\t * anything here. */\n\t\tmg_send_http_error(\n\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tbody_len = conn->data_len - conn->request_len;\n\tif (body_len > 0) {\n\t\tmg_send_http_error(\n\t\t    conn, 415, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\treturn;\n\t}\n\n\trc = mg_mkdir(conn, path, 0755);\n\n\tif (rc == 0) {\n\t\tconn->status_code = 201;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d Created\\r\\n\"\n\t\t          \"Date: %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          date);\n\t\tsend_static_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          suggest_connection_header(conn));\n\t} else {\n\t\tif (errno == EEXIST) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 405, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == EACCES) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 403, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else if (errno == ENOENT) {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 409, \"Error: mkcol(%s): %s\", path, strerror(ERRNO));\n\t\t} else {\n\t\t\tmg_send_http_error(\n\t\t\t    conn, 500, \"fopen(%s): %s\", path, strerror(ERRNO));\n\t\t}\n\t}\n}\n\n\nstatic void\nput_file(struct mg_connection *conn, const char *path)\n{\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tconst char *range;\n\tint64_t r1, r2;\n\tint rc;\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\tif (mg_stat(conn, path, &file.stat)) {\n\t\t/* File already exists */\n\t\tconn->status_code = 200;\n\n\t\tif (file.stat.is_directory) {\n\t\t\t/* This is an already existing directory,\n\t\t\t * so there is nothing to do for the server. */\n\t\t\trc = 0;\n\n\t\t} else {\n\t\t\t/* File exists and is not a directory. */\n\t\t\t/* Can it be replaced? */\n\n#if defined(MG_USE_OPEN_FILE)\n\t\t\tif (file.access.membuf != NULL) {\n\t\t\t\t/* This is an \"in-memory\" file, that can not be replaced */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   405,\n\t\t\t\t                   \"Error: Put not possible\\nReplacing %s \"\n\t\t\t\t                   \"is not supported\",\n\t\t\t\t                   path);\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\t/* Check if the server may write this file */\n\t\t\tif (access(path, W_OK) == 0) {\n\t\t\t\t/* Access granted */\n\t\t\t\tconn->status_code = 200;\n\t\t\t\trc = 1;\n\t\t\t} else {\n\t\t\t\tmg_send_http_error(\n\t\t\t\t    conn,\n\t\t\t\t    403,\n\t\t\t\t    \"Error: Put not possible\\nReplacing %s is not allowed\",\n\t\t\t\t    path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* File should be created */\n\t\tconn->status_code = 201;\n\t\trc = put_dir(conn, path);\n\t}\n\n\tif (rc == 0) {\n\t\t/* put_dir returns 0 if path is a directory */\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t\t          conn->status_code,\n\t\t          mg_get_response_code_text(NULL, conn->status_code));\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\n\t\t/* Request to create a directory has been fulfilled successfully.\n\t\t * No need to put a file. */\n\t\treturn;\n\t}\n\n\tif (rc == -1) {\n\t\t/* put_dir returns -1 if the path is too long */\n\t\tmg_send_http_error(conn,\n\t\t                   414,\n\t\t                   \"Error: Path too long\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tif (rc == -2) {\n\t\t/* put_dir returns -2 if the directory can not be created */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create directory\\nput_dir(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\t/* A file should be created or overwritten. */\n\t/* Currently CivetWeb does not nead read+write access. */\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file)\n\t    || file.access.fp == NULL) {\n\t\t(void)mg_fclose(&file.access);\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Can not create file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t\treturn;\n\t}\n\n\tfclose_on_exec(&file.access, conn);\n\trange = mg_get_header(conn, \"Content-Range\");\n\tr1 = r2 = 0;\n\tif ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {\n\t\tconn->status_code = 206; /* Partial content */\n\t\tfseeko(file.access.fp, r1, SEEK_SET);\n\t}\n\n\tif (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {\n\t\t/* forward_body_data failed.\n\t\t * The error code has already been sent to the client,\n\t\t * and conn->status_code is already set. */\n\t\t(void)mg_fclose(&file.access);\n\t\treturn;\n\t}\n\n\tif (mg_fclose(&file.access) != 0) {\n\t\t/* fclose failed. This might have different reasons, but a likely\n\t\t * one is \"no space on disk\", http 507. */\n\t\tconn->status_code = 507;\n\t}\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 %d %s\\r\\n\",\n\t          conn->status_code,\n\t          mg_get_response_code_text(NULL, conn->status_code));\n\tsend_no_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Date: %s\\r\\n\"\n\t          \"Content-Length: 0\\r\\n\"\n\t          \"Connection: %s\\r\\n\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n}\n\n\nstatic void\ndelete_file(struct mg_connection *conn, const char *path)\n{\n\tstruct de de;\n\tmemset(&de.file, 0, sizeof(de.file));\n\tif (!mg_stat(conn, path, &de.file)) {\n\t\t/* mg_stat returns 0 if the file does not exist */\n\t\tmg_send_http_error(conn,\n\t\t                   404,\n\t\t                   \"Error: Cannot delete file\\nFile %s not found\",\n\t\t                   path);\n\t\treturn;\n\t}\n\n#if 0 /* Ignore if a file in memory is inside a folder */\n        if (de.access.membuf != NULL) {\n                /* the file is cached in memory */\n                mg_send_http_error(\n                    conn,\n                    405,\n                    \"Error: Delete not possible\\nDeleting %s is not supported\",\n                    path);\n                return;\n        }\n#endif\n\n\tif (de.file.is_directory) {\n\t\tif (remove_directory(conn, path)) {\n\t\t\t/* Delete is successful: Return 204 without content. */\n\t\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t\t} else {\n\t\t\t/* Delete is not successful: Return 500 (Server error). */\n\t\t\tmg_send_http_error(conn, 500, \"Error: Could not delete %s\", path);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an existing file (not a directory).\n\t * Check if write permission is granted. */\n\tif (access(path, W_OK) != 0) {\n\t\t/* File is read only */\n\t\tmg_send_http_error(\n\t\t    conn,\n\t\t    403,\n\t\t    \"Error: Delete not possible\\nDeleting %s is not allowed\",\n\t\t    path);\n\t\treturn;\n\t}\n\n\t/* Try to delete it. */\n\tif (mg_remove(conn, path) == 0) {\n\t\t/* Delete was successful: Return 204 without content. */\n\t\tmg_send_http_error(conn, 204, \"%s\", \"\");\n\t} else {\n\t\t/* Delete not successful (file locked). */\n\t\tmg_send_http_error(conn,\n\t\t                   423,\n\t\t                   \"Error: Cannot delete file\\nremove(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t}\n}\n#endif /* !NO_FILES */\n\n\nstatic void\nsend_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);\n\n\nstatic void\ndo_ssi_include(struct mg_connection *conn,\n               const char *ssi,\n               char *tag,\n               int include_level)\n{\n\tchar file_name[MG_BUF_LEN], path[512], *p;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tsize_t len;\n\tint truncated = 0;\n\n\tif (conn == NULL) {\n\t\treturn;\n\t}\n\n\t/* sscanf() is safe here, since send_ssi_file() also uses buffer\n\t * of size MG_BUF_LEN to get the tag. So strlen(tag) is\n\t * always < MG_BUF_LEN. */\n\tif (sscanf(tag, \" virtual=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver root */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn,\n\t\t                  &truncated,\n\t\t                  path,\n\t\t                  sizeof(path),\n\t\t                  \"%s/%s\",\n\t\t                  conn->dom_ctx->config[DOCUMENT_ROOT],\n\t\t                  file_name);\n\n\t} else if (sscanf(tag, \" abspath=\\\"%511[^\\\"]\\\"\", file_name) == 1) {\n\t\t/* File name is relative to the webserver working directory\n\t\t * or it is absolute system path */\n\t\tfile_name[511] = 0;\n\t\t(void)\n\t\t    mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", file_name);\n\n\t} else if ((sscanf(tag, \" file=\\\"%511[^\\\"]\\\"\", file_name) == 1)\n\t           || (sscanf(tag, \" \\\"%511[^\\\"]\\\"\", file_name) == 1)) {\n\t\t/* File name is relative to the currect document */\n\t\tfile_name[511] = 0;\n\t\t(void)mg_snprintf(conn, &truncated, path, sizeof(path), \"%s\", ssi);\n\n\t\tif (!truncated) {\n\t\t\tif ((p = strrchr(path, '/')) != NULL) {\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t\tlen = strlen(path);\n\t\t\t(void)mg_snprintf(conn,\n\t\t\t                  &truncated,\n\t\t\t                  path + len,\n\t\t\t                  sizeof(path) - len,\n\t\t\t                  \"%s\",\n\t\t\t                  file_name);\n\t\t}\n\n\t} else {\n\t\tmg_cry_internal(conn, \"Bad SSI #include: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (truncated) {\n\t\tmg_cry_internal(conn, \"SSI #include path length overflow: [%s]\", tag);\n\t\treturn;\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot open SSI #include: [%s]: fopen(%s): %s\",\n\t\t                tag,\n\t\t                path,\n\t\t                strerror(ERRNO));\n\t} else {\n\t\tfclose_on_exec(&file.access, conn);\n\t\tif (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t\t                 strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t\t                 path)\n\t\t    > 0) {\n\t\t\tsend_ssi_file(conn, path, &file, include_level + 1);\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t}\n\t\t(void)mg_fclose(&file.access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_POPEN)\nstatic void\ndo_ssi_exec(struct mg_connection *conn, char *tag)\n{\n\tchar cmd[1024] = \"\";\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {\n\t\tmg_cry_internal(conn, \"Bad SSI #exec: [%s]\", tag);\n\t} else {\n\t\tcmd[1023] = 0;\n\t\tif ((file.access.fp = popen(cmd, \"r\")) == NULL) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Cannot SSI #exec: [%s]: %s\",\n\t\t\t                cmd,\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t\tpclose(file.access.fp);\n\t\t}\n\t}\n}\n#endif /* !NO_POPEN */\n\n\nstatic int\nmg_fgetc(struct mg_file *filep, int offset)\n{\n\t(void)offset; /* unused in case MG_USE_OPEN_FILE is set */\n\n\tif (filep == NULL) {\n\t\treturn EOF;\n\t}\n#if defined(MG_USE_OPEN_FILE)\n\tif ((filep->access.membuf != NULL) && (offset >= 0)\n\t    && (((unsigned int)(offset)) < filep->stat.size)) {\n\t\treturn ((const unsigned char *)filep->access.membuf)[offset];\n\t} else /* else block below */\n#endif\n\t    if (filep->access.fp != NULL) {\n\t\treturn fgetc(filep->access.fp);\n\t} else {\n\t\treturn EOF;\n\t}\n}\n\n\nstatic void\nsend_ssi_file(struct mg_connection *conn,\n              const char *path,\n              struct mg_file *filep,\n              int include_level)\n{\n\tchar buf[MG_BUF_LEN];\n\tint ch, offset, len, in_tag, in_ssi_tag;\n\n\tif (include_level > 10) {\n\t\tmg_cry_internal(conn, \"SSI #include level is too deep (%s)\", path);\n\t\treturn;\n\t}\n\n\tin_tag = in_ssi_tag = len = offset = 0;\n\n\t/* Read file, byte by byte, and look for SSI include tags */\n\twhile ((ch = mg_fgetc(filep, offset++)) != EOF) {\n\n\t\tif (in_tag) {\n\t\t\t/* We are in a tag, either SSI tag or html tag */\n\n\t\t\tif (ch == '>') {\n\t\t\t\t/* Tag is closing */\n\t\t\t\tbuf[len++] = '>';\n\n\t\t\t\tif (in_ssi_tag) {\n\t\t\t\t\t/* Handle SSI tag */\n\t\t\t\t\tbuf[len] = 0;\n\n\t\t\t\t\tif ((len > 12) && !memcmp(buf + 5, \"include\", 7)) {\n\t\t\t\t\t\tdo_ssi_include(conn, path, buf + 12, include_level + 1);\n#if !defined(NO_POPEN)\n\t\t\t\t\t} else if ((len > 9) && !memcmp(buf + 5, \"exec\", 4)) {\n\t\t\t\t\t\tdo_ssi_exec(conn, buf + 9);\n#endif /* !NO_POPEN */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmg_cry_internal(conn,\n\t\t\t\t\t\t                \"%s: unknown SSI \"\n\t\t\t\t\t\t                \"command: \\\"%s\\\"\",\n\t\t\t\t\t\t                path,\n\t\t\t\t\t\t                buf);\n\t\t\t\t\t}\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_ssi_tag = in_tag = 0;\n\n\t\t\t\t} else {\n\t\t\t\t\t/* Not an SSI tag */\n\t\t\t\t\t/* Flush buffer */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tin_tag = 0;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* Tag is still open */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\n\t\t\t\tif ((len == 5) && !memcmp(buf, \"<!--#\", 5)) {\n\t\t\t\t\t/* All SSI tags start with <!--# */\n\t\t\t\t\tin_ssi_tag = 1;\n\t\t\t\t}\n\n\t\t\t\tif ((len + 2) > (int)sizeof(buf)) {\n\t\t\t\t\t/* Tag to long for buffer */\n\t\t\t\t\tmg_cry_internal(conn, \"%s: tag is too large\", path);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t/* We are not in a tag yet. */\n\t\t\tif (ch == '<') {\n\t\t\t\t/* Tag is opening */\n\t\t\t\tin_tag = 1;\n\n\t\t\t\tif (len > 0) {\n\t\t\t\t\t/* Flush current buffer.\n\t\t\t\t\t * Buffer is filled with \"len\" bytes. */\n\t\t\t\t\t(void)mg_write(conn, buf, (size_t)len);\n\t\t\t\t}\n\t\t\t\t/* Store the < */\n\t\t\t\tlen = 1;\n\t\t\t\tbuf[0] = '<';\n\n\t\t\t} else {\n\t\t\t\t/* No Tag */\n\t\t\t\t/* Add data to buffer */\n\t\t\t\tbuf[len++] = (char)(ch & 0xff);\n\t\t\t\t/* Flush if buffer is full */\n\t\t\t\tif (len == (int)sizeof(buf)) {\n\t\t\t\t\tmg_write(conn, buf, (size_t)len);\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send the rest of buffered data */\n\tif (len > 0) {\n\t\tmg_write(conn, buf, (size_t)len);\n\t}\n}\n\n\nstatic void\nhandle_ssi_file_request(struct mg_connection *conn,\n                        const char *path,\n                        struct mg_file *filep)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\tconst char *cors1, *cors2, *cors3;\n\n\tif ((conn == NULL) || (path == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tif (mg_get_header(conn, \"Origin\")) {\n\t\t/* Cross-origin resource sharing (CORS). */\n\t\tcors1 = \"Access-Control-Allow-Origin: \";\n\t\tcors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tcors3 = \"\\r\\n\";\n\t} else {\n\t\tcors1 = cors2 = cors3 = \"\";\n\t}\n\n\tif (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {\n\t\t/* File exists (precondition for calling this function),\n\t\t * but can not be opened by the server. */\n\t\tmg_send_http_error(conn,\n\t\t                   500,\n\t\t                   \"Error: Cannot read file\\nfopen(%s): %s\",\n\t\t                   path,\n\t\t                   strerror(ERRNO));\n\t} else {\n\t\tconn->must_close = 1;\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tfclose_on_exec(&filep->access, conn);\n\t\tmg_printf(conn, \"HTTP/1.1 200 OK\\r\\n\");\n\t\tsend_no_cache_header(conn);\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn,\n\t\t          \"%s%s%s\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          \"Content-Type: text/html\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\\r\\n\",\n\t\t          cors1,\n\t\t          cors2,\n\t\t          cors3,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_ssi_file(conn, path, filep, 0);\n\t\t(void)mg_fclose(&filep->access); /* Ignore errors for readonly files */\n\t}\n}\n\n\n#if !defined(NO_FILES)\nstatic void\nsend_options(struct mg_connection *conn)\n{\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\tconn->status_code = 200;\n\tconn->must_close = 1;\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\t/* We do not set a \"Cache-Control\" header here, but leave the default.\n\t * Since browsers do not send an OPTIONS request, we can not test the\n\t * effect anyway. */\n\tmg_printf(conn,\n\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t          \"Date: %s\\r\\n\"\n\t          \"Connection: %s\\r\\n\"\n\t          \"Allow: GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, \"\n\t          \"PROPFIND, MKCOL\\r\\n\"\n\t          \"DAV: 1\\r\\n\",\n\t          date,\n\t          suggest_connection_header(conn));\n\tsend_additional_header(conn);\n\tmg_printf(conn, \"\\r\\n\");\n}\n\n\n/* Writes PROPFIND properties for a collection element */\nstatic void\nprint_props(struct mg_connection *conn,\n            const char *uri,\n            struct mg_file_stat *filep)\n{\n\tchar mtime[64];\n\n\tif ((conn == NULL) || (uri == NULL) || (filep == NULL)) {\n\t\treturn;\n\t}\n\n\tgmt_time_string(mtime, sizeof(mtime), &filep->last_modified);\n\tmg_printf(conn,\n\t          \"<d:response>\"\n\t          \"<d:href>%s</d:href>\"\n\t          \"<d:propstat>\"\n\t          \"<d:prop>\"\n\t          \"<d:resourcetype>%s</d:resourcetype>\"\n\t          \"<d:getcontentlength>%\" INT64_FMT \"</d:getcontentlength>\"\n\t          \"<d:getlastmodified>%s</d:getlastmodified>\"\n\t          \"</d:prop>\"\n\t          \"<d:status>HTTP/1.1 200 OK</d:status>\"\n\t          \"</d:propstat>\"\n\t          \"</d:response>\\n\",\n\t          uri,\n\t          filep->is_directory ? \"<d:collection/>\" : \"\",\n\t          filep->size,\n\t          mtime);\n}\n\n\nstatic int\nprint_dav_dir_entry(struct de *de, void *data)\n{\n\tchar href[PATH_MAX];\n\tint truncated;\n\n\tstruct mg_connection *conn = (struct mg_connection *)data;\n\tif (!de || !conn) {\n\t\treturn -1;\n\t}\n\tmg_snprintf(conn,\n\t            &truncated,\n\t            href,\n\t            sizeof(href),\n\t            \"%s%s\",\n\t            conn->request_info.local_uri,\n\t            de->file_name);\n\n\tif (!truncated) {\n\t\tsize_t href_encoded_size;\n\t\tchar *href_encoded;\n\n\t\thref_encoded_size = PATH_MAX * 3; /* worst case */\n\t\thref_encoded = (char *)mg_malloc(href_encoded_size);\n\t\tif (href_encoded == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tmg_url_encode(href, href_encoded, href_encoded_size);\n\t\tprint_props(conn, href_encoded, &de->file);\n\t\tmg_free(href_encoded);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nhandle_propfind(struct mg_connection *conn,\n                const char *path,\n                struct mg_file_stat *filep)\n{\n\tconst char *depth = mg_get_header(conn, \"Depth\");\n\tchar date[64];\n\ttime_t curtime = time(NULL);\n\n\tgmt_time_string(date, sizeof(date), &curtime);\n\n\tif (!conn || !path || !filep || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tconn->must_close = 1;\n\tconn->status_code = 207;\n\tmg_printf(conn,\n\t          \"HTTP/1.1 207 Multi-Status\\r\\n\"\n\t          \"Date: %s\\r\\n\",\n\t          date);\n\tsend_static_cache_header(conn);\n\tsend_additional_header(conn);\n\tmg_printf(conn,\n\t          \"Connection: %s\\r\\n\"\n\t          \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\",\n\t          suggest_connection_header(conn));\n\n\tmg_printf(conn,\n\t          \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n\t          \"<d:multistatus xmlns:d='DAV:'>\\n\");\n\n\t/* Print properties for the requested resource itself */\n\tprint_props(conn, conn->request_info.local_uri, filep);\n\n\t/* If it is a directory, print directory entries too if Depth is not 0\n\t */\n\tif (filep->is_directory\n\t    && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t                      \"yes\")\n\t    && ((depth == NULL) || (strcmp(depth, \"0\") != 0))) {\n\t\tscan_directory(conn, path, conn, &print_dav_dir_entry);\n\t}\n\n\tmg_printf(conn, \"%s\\n\", \"</d:multistatus>\");\n}\n#endif\n\nvoid\nmg_lock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_lock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_unlock_connection(struct mg_connection *conn)\n{\n\tif (conn) {\n\t\t(void)pthread_mutex_unlock(&conn->mutex);\n\t}\n}\n\nvoid\nmg_lock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_lock(&ctx->nonce_mutex);\n\t}\n}\n\nvoid\nmg_unlock_context(struct mg_context *ctx)\n{\n\tif (ctx) {\n\t\t(void)pthread_mutex_unlock(&ctx->nonce_mutex);\n\t}\n}\n\n\n#if defined(USE_LUA)\n#include \"mod_lua.inl\"\n#endif /* USE_LUA */\n\n#if defined(USE_DUKTAPE)\n#include \"mod_duktape.inl\"\n#endif /* USE_DUKTAPE */\n\n#if defined(USE_WEBSOCKET)\n\n#if !defined(NO_SSL_DL)\n#define SHA_API static\n#include \"sha1.inl\"\n#endif\n\nstatic int\nsend_websocket_handshake(struct mg_connection *conn, const char *websock_key)\n{\n\tstatic const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\tchar buf[100], sha[20], b64_sha[sizeof(sha) * 2];\n\tSHA_CTX sha_ctx;\n\tint truncated;\n\n\t/* Calculate Sec-WebSocket-Accept reply from Sec-WebSocket-Key. */\n\tmg_snprintf(conn, &truncated, buf, sizeof(buf), \"%s%s\", websock_key, magic);\n\tif (truncated) {\n\t\tconn->must_close = 1;\n\t\treturn 0;\n\t}\n\n\tDEBUG_TRACE(\"%s\", \"Send websocket handshake\");\n\n\tSHA1_Init(&sha_ctx);\n\tSHA1_Update(&sha_ctx, (unsigned char *)buf, (uint32_t)strlen(buf));\n\tSHA1_Final((unsigned char *)sha, &sha_ctx);\n\tbase64_encode((unsigned char *)sha, sizeof(sha), b64_sha);\n\tmg_printf(conn,\n\t          \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n\t          \"Upgrade: websocket\\r\\n\"\n\t          \"Connection: Upgrade\\r\\n\"\n\t          \"Sec-WebSocket-Accept: %s\\r\\n\",\n\t          b64_sha);\n\tif (conn->request_info.acceptedWebSocketSubprotocol) {\n\t\tmg_printf(conn,\n\t\t          \"Sec-WebSocket-Protocol: %s\\r\\n\\r\\n\",\n\t\t          conn->request_info.acceptedWebSocketSubprotocol);\n\t} else {\n\t\tmg_printf(conn, \"%s\", \"\\r\\n\");\n\t}\n\n\treturn 1;\n}\n\n\n#if !defined(MG_MAX_UNANSWERED_PING)\n/* Configuration of the maximum number of websocket PINGs that might\n * stay unanswered before the connection is considered broken.\n * Note: The name of this define may still change (until it is\n * defined as a compile parameter in a documentation).\n */\n#define MG_MAX_UNANSWERED_PING (5)\n#endif\n\n\nstatic void\nread_websocket(struct mg_connection *conn,\n               mg_websocket_data_handler ws_data_handler,\n               void *callback_data)\n{\n\t/* Pointer to the beginning of the portion of the incoming websocket\n\t * message queue.\n\t * The original websocket upgrade request is never removed, so the queue\n\t * begins after it. */\n\tunsigned char *buf = (unsigned char *)conn->buf + conn->request_len;\n\tint n, error, exit_by_callback;\n\tint ret;\n\n\t/* body_len is the length of the entire queue in bytes\n\t * len is the length of the current message\n\t * data_len is the length of the current message's data payload\n\t * header_len is the length of the current message's header */\n\tsize_t i, len, mask_len = 0, header_len, body_len;\n\tuint64_t data_len = 0;\n\n\t/* \"The masking key is a 32-bit value chosen at random by the client.\"\n\t * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5\n\t */\n\tunsigned char mask[4];\n\n\t/* data points to the place where the message is stored when passed to\n\t * the websocket_data callback.  This is either mem on the stack, or a\n\t * dynamically allocated buffer if it is too large. */\n\tunsigned char mem[4096];\n\tunsigned char mop; /* mask flag and opcode */\n\n\n\t/* Variables used for connection monitoring */\n\tdouble timeout = -1.0;\n\tint enable_ping_pong = 0;\n\tint ping_count = 0;\n\n\tif (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {\n\t\tenable_ping_pong =\n\t\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],\n\t\t                   \"yes\");\n\t}\n\n\tif (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {\n\t\ttimeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;\n\t}\n\tif ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {\n\t\ttimeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;\n\t}\n\n\t/* Enter data processing loop */\n\tDEBUG_TRACE(\"Websocket connection %s:%u start data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n\tconn->in_websocket_handling = 1;\n\tmg_set_thread_name(\"wsock\");\n\n\t/* Loop continuously, reading messages from the socket, invoking the\n\t * callback, and waiting repeatedly until an error occurs. */\n\twhile (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\theader_len = 0;\n\t\tDEBUG_ASSERT(conn->data_len >= conn->request_len);\n\t\tif ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {\n\t\t\tlen = buf[1] & 127;\n\t\t\tmask_len = (buf[1] & 128) ? 4 : 0;\n\t\t\tif ((len < 126) && (body_len >= mask_len)) {\n\t\t\t\t/* inline 7-bit length field */\n\t\t\t\tdata_len = len;\n\t\t\t\theader_len = 2 + mask_len;\n\t\t\t} else if ((len == 126) && (body_len >= (4 + mask_len))) {\n\t\t\t\t/* 16-bit length field */\n\t\t\t\theader_len = 4 + mask_len;\n\t\t\t\tdata_len = ((((size_t)buf[2]) << 8) + buf[3]);\n\t\t\t} else if (body_len >= (10 + mask_len)) {\n\t\t\t\t/* 64-bit length field */\n\t\t\t\tuint32_t l1, l2;\n\t\t\t\tmemcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */\n\t\t\t\tmemcpy(&l2, &buf[6], 4);\n\t\t\t\theader_len = 10 + mask_len;\n\t\t\t\tdata_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);\n\n\t\t\t\tif (data_len > (uint64_t)0x7FFF0000ul) {\n\t\t\t\t\t/* no can do */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((header_len > 0) && (body_len >= header_len)) {\n\t\t\t/* Allocate space to hold websocket payload */\n\t\t\tunsigned char *data = mem;\n\n\t\t\tif ((size_t)data_len > (size_t)sizeof(mem)) {\n\t\t\t\tdata = (unsigned char *)mg_malloc_ctx((size_t)data_len,\n\t\t\t\t                                      conn->phys_ctx);\n\t\t\t\tif (data == NULL) {\n\t\t\t\t\t/* Allocation failed, exit the loop and then close the\n\t\t\t\t\t * connection */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"websocket out of memory; closing connection\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Copy the mask before we shift the queue and destroy it */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tmemcpy(mask, buf + header_len - mask_len, sizeof(mask));\n\t\t\t} else {\n\t\t\t\tmemset(mask, 0, sizeof(mask));\n\t\t\t}\n\n\t\t\t/* Read frame payload from the first message in the queue into\n\t\t\t * data and advance the queue by moving the memory in place. */\n\t\t\tDEBUG_ASSERT(body_len >= header_len);\n\t\t\tif (data_len + (uint64_t)header_len > (uint64_t)body_len) {\n\t\t\t\tmop = buf[0]; /* current mask and opcode */\n\t\t\t\t/* Overflow case */\n\t\t\t\tlen = body_len - header_len;\n\t\t\t\tmemcpy(data, buf + header_len, len);\n\t\t\t\terror = 0;\n\t\t\t\twhile ((uint64_t)len < data_len) {\n\t\t\t\t\tn = pull_inner(NULL,\n\t\t\t\t\t               conn,\n\t\t\t\t\t               (char *)(data + len),\n\t\t\t\t\t               (int)(data_len - len),\n\t\t\t\t\t               timeout);\n\t\t\t\t\tif (n <= -2) {\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (n > 0) {\n\t\t\t\t\t\tlen += (size_t)n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Timeout: should retry */\n\t\t\t\t\t\t/* TODO: retry condition */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    conn,\n\t\t\t\t\t    \"%s\",\n\t\t\t\t\t    \"Websocket pull failed; closing connection\");\n\t\t\t\t\tif (data != mem) {\n\t\t\t\t\t\tmg_free(data);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconn->data_len = conn->request_len;\n\n\t\t\t} else {\n\n\t\t\t\tmop = buf[0]; /* current mask and opcode, overwritten by\n\t\t\t\t               * memmove() */\n\n\t\t\t\t/* Length of the message being read at the front of the\n\t\t\t\t * queue. Cast to 31 bit is OK, since we limited\n\t\t\t\t * data_len before. */\n\t\t\t\tlen = (size_t)data_len + header_len;\n\n\t\t\t\t/* Copy the data payload into the data pointer for the\n\t\t\t\t * callback. Cast to 31 bit is OK, since we\n\t\t\t\t * limited data_len */\n\t\t\t\tmemcpy(data, buf + header_len, (size_t)data_len);\n\n\t\t\t\t/* Move the queue forward len bytes */\n\t\t\t\tmemmove(buf, buf + len, body_len - len);\n\n\t\t\t\t/* Mark the queue as advanced */\n\t\t\t\tconn->data_len -= (int)len;\n\t\t\t}\n\n\t\t\t/* Apply mask if necessary */\n\t\t\tif (mask_len > 0) {\n\t\t\t\tfor (i = 0; i < (size_t)data_len; i++) {\n\t\t\t\t\tdata[i] ^= mask[i & 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texit_by_callback = 0;\n\t\t\tif (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {\n\t\t\t\t/* filter PONG messages */\n\t\t\t\tDEBUG_TRACE(\"PONG from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t/* No unanwered PINGs left */\n\t\t\t\tping_count = 0;\n\t\t\t} else if (enable_ping_pong\n\t\t\t           && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {\n\t\t\t\t/* reply PING messages */\n\t\t\t\tDEBUG_TRACE(\"Reply PING from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t                         MG_WEBSOCKET_OPCODE_PONG,\n\t\t\t\t                         (char *)data,\n\t\t\t\t                         (size_t)data_len);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\tDEBUG_TRACE(\"Reply PONG failed (%i)\", ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* Exit the loop if callback signals to exit (server side),\n\t\t\t\t * or \"connection close\" opcode received (client side). */\n\t\t\t\tif ((ws_data_handler != NULL)\n\t\t\t\t    && !ws_data_handler(conn,\n\t\t\t\t                        mop,\n\t\t\t\t                        (char *)data,\n\t\t\t\t                        (size_t)data_len,\n\t\t\t\t                        callback_data)) {\n\t\t\t\t\texit_by_callback = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* It a buffer has been allocated, free it again */\n\t\t\tif (data != mem) {\n\t\t\t\tmg_free(data);\n\t\t\t}\n\n\t\t\tif (exit_by_callback) {\n\t\t\t\tDEBUG_TRACE(\"Callback requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {\n\t\t\t\t/* Opcode == 8, connection close */\n\t\t\t\tDEBUG_TRACE(\"Message requests to close connection from %s:%u\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Not breaking the loop, process next websocket frame. */\n\t\t} else {\n\t\t\t/* Read from the socket into the next available location in the\n\t\t\t * message queue. */\n\t\t\tn = pull_inner(NULL,\n\t\t\t               conn,\n\t\t\t               conn->buf + conn->data_len,\n\t\t\t               conn->buf_size - conn->data_len,\n\t\t\t               timeout);\n\t\t\tif (n <= -2) {\n\t\t\t\t/* Error, no bytes read */\n\t\t\t\tDEBUG_TRACE(\"PULL from %s:%u failed\",\n\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n > 0) {\n\t\t\t\tconn->data_len += n;\n\t\t\t\t/* Reset open PING count */\n\t\t\t\tping_count = 0;\n\t\t\t} else {\n\t\t\t\tif (!conn->phys_ctx->stop_flag && !conn->must_close) {\n\t\t\t\t\tif (ping_count > MG_MAX_UNANSWERED_PING) {\n\t\t\t\t\t\t/* Stop sending PING */\n\t\t\t\t\t\tDEBUG_TRACE(\"Too many (%i) unanswered ping from %s:%u \"\n\t\t\t\t\t\t            \"- closing connection\",\n\t\t\t\t\t\t            ping_count,\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (enable_ping_pong) {\n\t\t\t\t\t\t/* Send Websocket PING message */\n\t\t\t\t\t\tDEBUG_TRACE(\"PING to %s:%u\",\n\t\t\t\t\t\t            conn->request_info.remote_addr,\n\t\t\t\t\t\t            conn->request_info.remote_port);\n\t\t\t\t\t\tret = mg_websocket_write(conn,\n\t\t\t\t\t\t                         MG_WEBSOCKET_OPCODE_PING,\n\t\t\t\t\t\t                         NULL,\n\t\t\t\t\t\t                         0);\n\n\t\t\t\t\t\tif (ret <= 0) {\n\t\t\t\t\t\t\t/* Error: send failed */\n\t\t\t\t\t\t\tDEBUG_TRACE(\"Send PING failed (%i)\", ret);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tping_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Timeout: should retry */\n\t\t\t\t/* TODO: get timeout def */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Leave data processing loop */\n\tmg_set_thread_name(\"worker\");\n\tconn->in_websocket_handling = 0;\n\tDEBUG_TRACE(\"Websocket connection %s:%u left data processing loop\",\n\t            conn->request_info.remote_addr,\n\t            conn->request_info.remote_port);\n}\n\n\nstatic int\nmg_websocket_write_exec(struct mg_connection *conn,\n                        int opcode,\n                        const char *data,\n                        size_t dataLen,\n                        uint32_t masking_key)\n{\n\tunsigned char header[14];\n\tsize_t headerLen;\n\tint retval;\n\n#if defined(GCC_DIAGNOSTIC)\n/* Disable spurious conversion warning for GCC */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\n\theader[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n\n\t/* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */\n\tif (dataLen < 126) {\n\t\t/* inline 7-bit length field */\n\t\theader[1] = (unsigned char)dataLen;\n\t\theaderLen = 2;\n\t} else if (dataLen <= 0xFFFF) {\n\t\t/* 16-bit length field */\n\t\tuint16_t len = htons((uint16_t)dataLen);\n\t\theader[1] = 126;\n\t\tmemcpy(header + 2, &len, 2);\n\t\theaderLen = 4;\n\t} else {\n\t\t/* 64-bit length field */\n\t\tuint32_t len1 = htonl((uint32_t)((uint64_t)dataLen >> 32));\n\t\tuint32_t len2 = htonl((uint32_t)(dataLen & 0xFFFFFFFFu));\n\t\theader[1] = 127;\n\t\tmemcpy(header + 2, &len1, 4);\n\t\tmemcpy(header + 6, &len2, 4);\n\t\theaderLen = 10;\n\t}\n\n\tif (masking_key) {\n\t\t/* add mask */\n\t\theader[1] |= 0x80;\n\t\tmemcpy(header + headerLen, &masking_key, 4);\n\t\theaderLen += 4;\n\t}\n\n\t/* Note that POSIX/Winsock's send() is threadsafe\n\t * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid\n\t * but mongoose's mg_printf/mg_write is not (because of the loop in\n\t * push(), although that is only a problem if the packet is large or\n\t * outgoing buffer is full). */\n\n\t/* TODO: Check if this lock should be moved to user land.\n\t * Currently the server sets this lock for websockets, but\n\t * not for any other connection. It must be set for every\n\t * conn read/written by more than one thread, no matter if\n\t * it is a websocket or regular connection. */\n\t(void)mg_lock_connection(conn);\n\n\tretval = mg_write(conn, header, headerLen);\n\tif (retval != (int)headerLen) {\n\t\t/* Did not send complete header */\n\t\tretval = -1;\n\t} else {\n\t\tif (dataLen > 0) {\n\t\t\tretval = mg_write(conn, data, dataLen);\n\t\t}\n\t\t/* if dataLen == 0, the header length (2) is returned */\n\t}\n\n\t/* TODO: Remove this unlock as well, when lock is removed. */\n\tmg_unlock_connection(conn);\n\n\treturn retval;\n}\n\nint\nmg_websocket_write(struct mg_connection *conn,\n                   int opcode,\n                   const char *data,\n                   size_t dataLen)\n{\n\treturn mg_websocket_write_exec(conn, opcode, data, dataLen, 0);\n}\n\n\nstatic void\nmask_data(const char *in, size_t in_len, uint32_t masking_key, char *out)\n{\n\tsize_t i = 0;\n\n\ti = 0;\n\tif ((in_len > 3) && ((ptrdiff_t)in % 4) == 0) {\n\t\t/* Convert in 32 bit words, if data is 4 byte aligned */\n\t\twhile (i < (in_len - 3)) {\n\t\t\t*(uint32_t *)(void *)(out + i) =\n\t\t\t    *(uint32_t *)(void *)(in + i) ^ masking_key;\n\t\t\ti += 4;\n\t\t}\n\t}\n\tif (i != in_len) {\n\t\t/* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/\n\t\twhile (i < in_len) {\n\t\t\t*(uint8_t *)(void *)(out + i) =\n\t\t\t    *(uint8_t *)(void *)(in + i)\n\t\t\t    ^ *(((uint8_t *)&masking_key) + (i % 4));\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nint\nmg_websocket_client_write(struct mg_connection *conn,\n                          int opcode,\n                          const char *data,\n                          size_t dataLen)\n{\n\tint retval = -1;\n\tchar *masked_data =\n\t    (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);\n\tuint32_t masking_key = 0;\n\n\tif (masked_data == NULL) {\n\t\t/* Return -1 in an error case */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s\",\n\t\t                \"Cannot allocate buffer for masked websocket response: \"\n\t\t                \"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\t/* Get a masking key - but not 0 */\n\t\tmasking_key = (uint32_t)get_random();\n\t} while (masking_key == 0);\n\n\tmask_data(data, dataLen, masking_key, masked_data);\n\n\tretval = mg_websocket_write_exec(\n\t    conn, opcode, masked_data, dataLen, masking_key);\n\tmg_free(masked_data);\n\n\treturn retval;\n}\n\n\nstatic void\nhandle_websocket_request(struct mg_connection *conn,\n                         const char *path,\n                         int is_callback_resource,\n                         struct mg_websocket_subprotocols *subprotocols,\n                         mg_websocket_connect_handler ws_connect_handler,\n                         mg_websocket_ready_handler ws_ready_handler,\n                         mg_websocket_data_handler ws_data_handler,\n                         mg_websocket_close_handler ws_close_handler,\n                         void *cbData)\n{\n\tconst char *websock_key = mg_get_header(conn, \"Sec-WebSocket-Key\");\n\tconst char *version = mg_get_header(conn, \"Sec-WebSocket-Version\");\n\tptrdiff_t lua_websock = 0;\n\n#if !defined(USE_LUA)\n\t(void)path;\n#endif\n\n\t/* Step 1: Check websocket protocol version. */\n\t/* Step 1.1: Check Sec-WebSocket-Key. */\n\tif (!websock_key) {\n\t\t/* The RFC standard version (https://tools.ietf.org/html/rfc6455)\n\t\t * requires a Sec-WebSocket-Key header.\n\t\t */\n\t\t/* It could be the hixie draft version\n\t\t * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).\n\t\t */\n\t\tconst char *key1 = mg_get_header(conn, \"Sec-WebSocket-Key1\");\n\t\tconst char *key2 = mg_get_header(conn, \"Sec-WebSocket-Key2\");\n\t\tchar key3[8];\n\n\t\tif ((key1 != NULL) && (key2 != NULL)) {\n\t\t\t/* This version uses 8 byte body data in a GET request */\n\t\t\tconn->content_len = 8;\n\t\t\tif (8 == mg_read(conn, key3, 8)) {\n\t\t\t\t/* This is the hixie version */\n\t\t\t\tmg_send_http_error(conn,\n\t\t\t\t                   426,\n\t\t\t\t                   \"%s\",\n\t\t\t\t                   \"Protocol upgrade to RFC 6455 required\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* This is an unknown version */\n\t\tmg_send_http_error(conn, 400, \"%s\", \"Malformed websocket request\");\n\t\treturn;\n\t}\n\n\t/* Step 1.2: Check websocket protocol version. */\n\t/* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */\n\tif ((version == NULL) || (strcmp(version, \"13\") != 0)) {\n\t\t/* Reject wrong versions */\n\t\tmg_send_http_error(conn, 426, \"%s\", \"Protocol upgrade required\");\n\t\treturn;\n\t}\n\n\t/* Step 1.3: Could check for \"Host\", but we do not really nead this\n\t * value for anything, so just ignore it. */\n\n\t/* Step 2: If a callback is responsible, call it. */\n\tif (is_callback_resource) {\n\t\t/* Step 2.1 check and select subprotocol */\n\t\tconst char *protocols[64]; // max 64 headers\n\t\tint nbSubprotocolHeader = get_req_headers(&conn->request_info,\n\t\t                                          \"Sec-WebSocket-Protocol\",\n\t\t                                          protocols,\n\t\t                                          64);\n\t\tif ((nbSubprotocolHeader > 0) && subprotocols) {\n\t\t\tint cnt = 0;\n\t\t\tint idx;\n\t\t\tunsigned long len;\n\t\t\tconst char *sep, *curSubProtocol,\n\t\t\t    *acceptedWebSocketSubprotocol = NULL;\n\n\n\t\t\t/* look for matching subprotocol */\n\t\t\tdo {\n\t\t\t\tconst char *protocol = protocols[cnt];\n\n\t\t\t\tdo {\n\t\t\t\t\tsep = strchr(protocol, ',');\n\t\t\t\t\tcurSubProtocol = protocol;\n\t\t\t\t\tlen = sep ? (unsigned long)(sep - protocol)\n\t\t\t\t\t          : (unsigned long)strlen(protocol);\n\t\t\t\t\twhile (sep && isspace(*++sep))\n\t\t\t\t\t\t; // ignore leading whitespaces\n\t\t\t\t\tprotocol = sep;\n\n\n\t\t\t\t\tfor (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {\n\t\t\t\t\t\tif ((strlen(subprotocols->subprotocols[idx]) == len)\n\t\t\t\t\t\t    && (strncmp(curSubProtocol,\n\t\t\t\t\t\t                subprotocols->subprotocols[idx],\n\t\t\t\t\t\t                len)\n\t\t\t\t\t\t        == 0)) {\n\t\t\t\t\t\t\tacceptedWebSocketSubprotocol =\n\t\t\t\t\t\t\t    subprotocols->subprotocols[idx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (sep && !acceptedWebSocketSubprotocol);\n\t\t\t} while (++cnt < nbSubprotocolHeader\n\t\t\t         && !acceptedWebSocketSubprotocol);\n\n\t\t\tconn->request_info.acceptedWebSocketSubprotocol =\n\t\t\t    acceptedWebSocketSubprotocol;\n\n\t\t} else if (nbSubprotocolHeader > 0) {\n\t\t\t/* keep legacy behavior */\n\t\t\tconst char *protocol = protocols[0];\n\n\t\t\t/* The protocol is a comma separated list of names. */\n\t\t\t/* The server must only return one value from this list. */\n\t\t\t/* First check if it is a list or just a single value. */\n\t\t\tconst char *sep = strrchr(protocol, ',');\n\t\t\tif (sep == NULL) {\n\t\t\t\t/* Just a single protocol -> accept it. */\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = protocol;\n\t\t\t} else {\n\t\t\t\t/* Multiple protocols -> accept the last one. */\n\t\t\t\t/* This is just a quick fix if the client offers multiple\n\t\t\t\t * protocols. The handler should have a list of accepted\n\t\t\t\t * protocols on his own\n\t\t\t\t * and use it to select one protocol among those the client\n\t\t\t\t * has\n\t\t\t\t * offered.\n\t\t\t\t */\n\t\t\t\twhile (isspace(*++sep)) {\n\t\t\t\t\t; /* ignore leading whitespaces */\n\t\t\t\t}\n\t\t\t\tconn->request_info.acceptedWebSocketSubprotocol = sep;\n\t\t\t}\n\t\t}\n\n\t\tif ((ws_connect_handler != NULL)\n\t\t    && (ws_connect_handler(conn, cbData) != 0)) {\n\t\t\t/* C callback has returned non-zero, do not proceed with\n\t\t\t * handshake.\n\t\t\t */\n\t\t\t/* Note that C callbacks are no longer called when Lua is\n\t\t\t * responsible, so C can no longer filter callbacks for Lua. */\n\t\t\treturn;\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Step 3: No callback. Check if Lua is responsible. */\n\telse {\n\t\t/* Step 3.1: Check if Lua is responsible. */\n\t\tif (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {\n\t\t\tlua_websock = match_prefix(\n\t\t\t    conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS],\n\t\t\t    strlen(conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]),\n\t\t\t    path);\n\t\t}\n\n\t\tif (lua_websock) {\n\t\t\t/* Step 3.2: Lua is responsible: call it. */\n\t\t\tconn->lua_websocket_state = lua_websocket_new(path, conn);\n\t\t\tif (!conn->lua_websocket_state) {\n\t\t\t\t/* Lua rejected the new client */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t/* Step 4: Check if there is a responsible websocket handler. */\n\tif (!is_callback_resource && !lua_websock) {\n\t\t/* There is no callback, and Lua is not responsible either. */\n\t\t/* Reply with a 404 Not Found. We are still at a standard\n\t\t * HTTP request here, before the websocket handshake, so\n\t\t * we can still send standard HTTP error replies. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* Step 5: The websocket connection has been accepted */\n\tif (!send_websocket_handshake(conn, websock_key)) {\n\t\tmg_send_http_error(conn, 500, \"%s\", \"Websocket handshake failed\");\n\t\treturn;\n\t}\n\n\t/* Step 6: Call the ready handler */\n\tif (is_callback_resource) {\n\t\tif (ws_ready_handler != NULL) {\n\t\t\tws_ready_handler(conn, cbData);\n\t\t}\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tif (!lua_websocket_ready(conn, conn->lua_websocket_state)) {\n\t\t\t/* the ready handler returned false */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\n\t/* Step 7: Enter the read loop */\n\tif (is_callback_resource) {\n\t\tread_websocket(conn, ws_data_handler, cbData);\n#if defined(USE_LUA)\n\t} else if (lua_websock) {\n\t\tread_websocket(conn, lua_websocket_data, conn->lua_websocket_state);\n#endif\n\t}\n\n\t/* Step 8: Call the close handler */\n\tif (ws_close_handler) {\n\t\tws_close_handler(conn, cbData);\n\t}\n}\n\n\nstatic int\nis_websocket_protocol(const struct mg_connection *conn)\n{\n\tconst char *upgrade, *connection;\n\n\t/* A websocket protocoll has the following HTTP headers:\n\t *\n\t * Connection: Upgrade\n\t * Upgrade: Websocket\n\t */\n\n\tupgrade = mg_get_header(conn, \"Upgrade\");\n\tif (upgrade == NULL) {\n\t\treturn 0; /* fail early, don't waste time checking other header\n\t\t           * fields\n\t\t           */\n\t}\n\tif (!mg_strcasestr(upgrade, \"websocket\")) {\n\t\treturn 0;\n\t}\n\n\tconnection = mg_get_header(conn, \"Connection\");\n\tif (connection == NULL) {\n\t\treturn 0;\n\t}\n\tif (!mg_strcasestr(connection, \"upgrade\")) {\n\t\treturn 0;\n\t}\n\n\t/* The headers \"Host\", \"Sec-WebSocket-Key\", \"Sec-WebSocket-Protocol\" and\n\t * \"Sec-WebSocket-Version\" are also required.\n\t * Don't check them here, since even an unsupported websocket protocol\n\t * request still IS a websocket request (in contrast to a standard HTTP\n\t * request). It will fail later in handle_websocket_request.\n\t */\n\n\treturn 1;\n}\n#endif /* !USE_WEBSOCKET */\n\n\nstatic int\nisbyte(int n)\n{\n\treturn (n >= 0) && (n <= 255);\n}\n\n\nstatic int\nparse_net(const char *spec, uint32_t *net, uint32_t *mask)\n{\n\tint n, a, b, c, d, slash = 32, len = 0;\n\n\tif (((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5)\n\t     || (sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4))\n\t    && isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && (slash >= 0)\n\t    && (slash < 33)) {\n\t\tlen = n;\n\t\t*net = ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8)\n\t\t       | (uint32_t)d;\n\t\t*mask = slash ? (0xffffffffU << (32 - slash)) : 0;\n\t}\n\n\treturn len;\n}\n\n\nstatic int\nset_throttle(const char *spec, uint32_t remote_ip, const char *uri)\n{\n\tint throttle = 0;\n\tstruct vec vec, val;\n\tuint32_t net, mask;\n\tchar mult;\n\tdouble v;\n\n\twhile ((spec = next_option(spec, &vec, &val)) != NULL) {\n\t\tmult = ',';\n\t\tif ((val.ptr == NULL) || (sscanf(val.ptr, \"%lf%c\", &v, &mult) < 1)\n\t\t    || (v < 0)\n\t\t    || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm')\n\t\t        && (mult != ','))) {\n\t\t\tcontinue;\n\t\t}\n\t\tv *= (lowercase(&mult) == 'k')\n\t\t         ? 1024\n\t\t         : ((lowercase(&mult) == 'm') ? 1048576 : 1);\n\t\tif (vec.len == 1 && vec.ptr[0] == '*') {\n\t\t\tthrottle = (int)v;\n\t\t} else if (parse_net(vec.ptr, &net, &mask) > 0) {\n\t\t\tif ((remote_ip & mask) == net) {\n\t\t\t\tthrottle = (int)v;\n\t\t\t}\n\t\t} else if (match_prefix(vec.ptr, vec.len, uri) > 0) {\n\t\t\tthrottle = (int)v;\n\t\t}\n\t}\n\n\treturn throttle;\n}\n\n\nstatic uint32_t\nget_remote_ip(const struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\treturn ntohl(*(const uint32_t *)&conn->client.rsa.sin.sin_addr);\n}\n\n\n/* The mg_upload function is superseeded by mg_handle_form_request. */\n#include \"handle_form.inl\"\n\n\n#if defined(MG_LEGACY_INTERFACE)\n/* Implement the deprecated mg_upload function by calling the new\n * mg_handle_form_request function. While mg_upload could only handle\n * HTML forms sent as POST request in multipart/form-data format\n * containing only file input elements, mg_handle_form_request can\n * handle all form input elements and all standard request methods. */\nstruct mg_upload_user_data {\n\tstruct mg_connection *conn;\n\tconst char *destination_dir;\n\tint num_uploaded_files;\n};\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_found(const char *key,\n                      const char *filename,\n                      char *path,\n                      size_t pathlen,\n                      void *user_data)\n{\n\tint truncated = 0;\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)key;\n\n\tif (!filename) {\n\t\tmg_cry_internal(fud->conn, \"%s: No filename set\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\tmg_snprintf(fud->conn,\n\t            &truncated,\n\t            path,\n\t            pathlen - 1,\n\t            \"%s/%s\",\n\t            fud->destination_dir,\n\t            filename);\n\tif (truncated) {\n\t\tmg_cry_internal(fud->conn, \"%s: File path too long\", __func__);\n\t\treturn FORM_FIELD_STORAGE_ABORT;\n\t}\n\treturn FORM_FIELD_STORAGE_STORE;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_get(const char *key,\n                    const char *value,\n                    size_t value_size,\n                    void *user_data)\n{\n\t/* Function should never be called */\n\t(void)key;\n\t(void)value;\n\t(void)value_size;\n\t(void)user_data;\n\n\treturn 0;\n}\n\n\n/* Helper function for deprecated mg_upload. */\nstatic int\nmg_upload_field_stored(const char *path, long long file_size, void *user_data)\n{\n\tstruct mg_upload_user_data *fud = (struct mg_upload_user_data *)user_data;\n\t(void)file_size;\n\n\tfud->num_uploaded_files++;\n\tfud->conn->phys_ctx->callbacks.upload(fud->conn, path);\n\n\treturn 0;\n}\n\n\n/* Deprecated function mg_upload - use mg_handle_form_request instead. */\nint\nmg_upload(struct mg_connection *conn, const char *destination_dir)\n{\n\tstruct mg_upload_user_data fud = {conn, destination_dir, 0};\n\tstruct mg_form_data_handler fdh = {mg_upload_field_found,\n\t                                   mg_upload_field_get,\n\t                                   mg_upload_field_stored,\n\t                                   0};\n\tint ret;\n\n\tfdh.user_data = (void *)&fud;\n\tret = mg_handle_form_request(conn, &fdh);\n\n\tif (ret < 0) {\n\t\tmg_cry_internal(conn, \"%s: Error while parsing the request\", __func__);\n\t}\n\n\treturn fud.num_uploaded_files;\n}\n#endif\n\n\nstatic int\nget_first_ssl_listener_index(const struct mg_context *ctx)\n{\n\tunsigned int i;\n\tint idx = -1;\n\tif (ctx) {\n\t\tfor (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {\n\t\t\tidx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;\n\t\t}\n\t}\n\treturn idx;\n}\n\n\n/* Return host (without port) */\n/* Use mg_free to free the result */\nstatic const char *\nalloc_get_host(struct mg_connection *conn)\n{\n\tchar buf[1025];\n\tsize_t buflen = sizeof(buf);\n\tconst char *host_header = get_header(conn->request_info.http_headers,\n\t                                     conn->request_info.num_headers,\n\t                                     \"Host\");\n\tchar *host;\n\n\tif (host_header != NULL) {\n\t\tchar *pos;\n\n\t\t/* Create a local copy of the \"Host\" header, since it might be\n\t\t * modified here. */\n\t\tmg_strlcpy(buf, host_header, buflen);\n\t\tbuf[buflen - 1] = '\\0';\n\t\thost = buf;\n\t\twhile (isspace(*host)) {\n\t\t\thost++;\n\t\t}\n\n\t\t/* If the \"Host\" is an IPv6 address, like [::1], parse until ]\n\t\t * is found. */\n\t\tif (*host == '[') {\n\t\t\tpos = strchr(host, ']');\n\t\t\tif (!pos) {\n\t\t\t\t/* Malformed hostname starts with '[', but no ']' found */\n\t\t\t\tDEBUG_TRACE(\"%s\", \"Host name format error '[' without ']'\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* terminate after ']' */\n\t\t\tpos[1] = 0;\n\t\t} else {\n\t\t\t/* Otherwise, a ':' separates hostname and port number */\n\t\t\tpos = strchr(host, ':');\n\t\t\tif (pos != NULL) {\n\t\t\t\t*pos = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tif (conn->ssl) {\n\t\t\t/* This is a HTTPS connection, maybe we have a hostname\n\t\t\t * from SNI (set in ssl_servername_callback). */\n\t\t\tconst char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\t\tif (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {\n\t\t\t\t/* We are not using the default domain */\n\t\t\t\tif (mg_strcasecmp(host, sslhost)) {\n\t\t\t\t\t/* Mismatch between SNI domain and HTTP domain */\n\t\t\t\t\tDEBUG_TRACE(\"Host mismatch: SNI: %s, HTTPS: %s\",\n\t\t\t\t\t            sslhost,\n\t\t\t\t\t            host);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDEBUG_TRACE(\"HTTPS Host: %s\", host);\n\n\t\t} else {\n\t\t\tstruct mg_domain_context *dom = &(conn->phys_ctx->dd);\n\t\t\twhile (dom) {\n\t\t\t\tif (!mg_strcasecmp(host, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t\t\t/* Found matching domain */\n\t\t\t\t\tDEBUG_TRACE(\"HTTP domain %s found\",\n\t\t\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\n\t\t\t\t\t/* TODO: Check if this is a HTTP or HTTPS domain */\n\t\t\t\t\tconn->dom_ctx = dom;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdom = dom->next;\n\t\t\t}\n\n\t\t\tDEBUG_TRACE(\"HTTP Host: %s\", host);\n\t\t}\n\n\t} else {\n\t\tsockaddr_to_string(buf, buflen, &conn->client.lsa);\n\t\thost = buf;\n\n\t\tDEBUG_TRACE(\"IP: %s\", host);\n\t}\n\n\treturn mg_strdup_ctx(host, conn->phys_ctx);\n}\n\n\nstatic void\nredirect_to_https_port(struct mg_connection *conn, int ssl_index)\n{\n\tchar target_url[MG_BUF_LEN];\n\tint truncated = 0;\n\n\tconn->must_close = 1;\n\n\t/* Send host, port, uri and (if it exists) ?query_string */\n\tif (conn->host) {\n\n\t\t/* Use \"308 Permanent Redirect\" */\n\t\tint redirect_code = 308;\n\n\t\t/* Create target URL */\n\t\tmg_snprintf(\n\t\t    conn,\n\t\t    &truncated,\n\t\t    target_url,\n\t\t    sizeof(target_url),\n\t\t    \"https://%s:%d%s%s%s\",\n\n\t\t    conn->host,\n#if defined(USE_IPV6)\n\t\t    (conn->phys_ctx->listening_sockets[ssl_index].lsa.sa.sa_family\n\t\t     == AF_INET6)\n\t\t        ? (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                         .lsa.sin6.sin6_port)\n\t\t        :\n#endif\n\t\t        (int)ntohs(conn->phys_ctx->listening_sockets[ssl_index]\n\t\t                       .lsa.sin.sin_port),\n\t\t    conn->request_info.local_uri,\n\t\t    (conn->request_info.query_string == NULL) ? \"\" : \"?\",\n\t\t    (conn->request_info.query_string == NULL)\n\t\t        ? \"\"\n\t\t        : conn->request_info.query_string);\n\n\t\t/* Check overflow in location buffer (will not occur if MG_BUF_LEN\n\t\t * is used as buffer size) */\n\t\tif (truncated) {\n\t\t\tmg_send_http_error(conn, 500, \"%s\", \"Redirect URL too long\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Use redirect helper function */\n\t\tmg_send_http_redirect(conn, target_url, redirect_code);\n\t}\n}\n\n\nstatic void\nhandler_info_acquire(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount++;\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_release(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\thandler_info->refcount--;\n\tpthread_cond_signal(&handler_info->refcount_cond);\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nhandler_info_wait_unused(struct mg_handler_info *handler_info)\n{\n\tpthread_mutex_lock(&handler_info->refcount_mutex);\n\twhile (handler_info->refcount) {\n\t\tpthread_cond_wait(&handler_info->refcount_cond,\n\t\t                  &handler_info->refcount_mutex);\n\t}\n\tpthread_mutex_unlock(&handler_info->refcount_mutex);\n}\n\n\nstatic void\nmg_set_handler_type(struct mg_context *phys_ctx,\n                    struct mg_domain_context *dom_ctx,\n                    const char *uri,\n                    int handler_type,\n                    int is_delete_request,\n                    mg_request_handler handler,\n                    struct mg_websocket_subprotocols *subprotocols,\n                    mg_websocket_connect_handler connect_handler,\n                    mg_websocket_ready_handler ready_handler,\n                    mg_websocket_data_handler data_handler,\n                    mg_websocket_close_handler close_handler,\n                    mg_authorization_handler auth_handler,\n                    void *cbdata)\n{\n\tstruct mg_handler_info *tmp_rh, **lastref;\n\tsize_t urilen = strlen(uri);\n\n\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || connect_handler != NULL\n\t\t             || ready_handler != NULL || data_handler != NULL\n\t\t             || close_handler != NULL);\n\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (connect_handler == NULL)\n\t\t    && (ready_handler == NULL) && (data_handler == NULL)\n\t\t    && (close_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else if (handler_type == REQUEST_HANDLER) {\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL && close_handler == NULL);\n\t\tDEBUG_ASSERT(is_delete_request || (handler != NULL));\n\t\tDEBUG_ASSERT(auth_handler == NULL);\n\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (auth_handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t} else { /* AUTH_HANDLER */\n\t\tDEBUG_ASSERT(handler == NULL);\n\t\tDEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL\n\t\t             && data_handler == NULL && close_handler == NULL);\n\t\tDEBUG_ASSERT(auth_handler != NULL);\n\t\tif (handler != NULL) {\n\t\t\treturn;\n\t\t}\n\t\tif ((connect_handler != NULL) || (ready_handler != NULL)\n\t\t    || (data_handler != NULL) || (close_handler != NULL)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!is_delete_request && (auth_handler == NULL)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!phys_ctx || !dom_ctx) {\n\t\treturn;\n\t}\n\n\tmg_lock_context(phys_ctx);\n\n\t/* first try to find an existing handler */\n\tlastref = &(dom_ctx->handlers);\n\tfor (tmp_rh = dom_ctx->handlers; tmp_rh != NULL; tmp_rh = tmp_rh->next) {\n\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\tif (!is_delete_request) {\n\t\t\t\t\t/* update existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before updating */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more use -> Update it */\n\t\t\t\t\t\ttmp_rh->handler = handler;\n\t\t\t\t\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\ttmp_rh->subprotocols = subprotocols;\n\t\t\t\t\t\ttmp_rh->connect_handler = connect_handler;\n\t\t\t\t\t\ttmp_rh->ready_handler = ready_handler;\n\t\t\t\t\t\ttmp_rh->data_handler = data_handler;\n\t\t\t\t\t\ttmp_rh->close_handler = close_handler;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\ttmp_rh->auth_handler = auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\ttmp_rh->cbdata = cbdata;\n\t\t\t\t} else {\n\t\t\t\t\t/* remove existing handler */\n\t\t\t\t\tif (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t/* Wait for end of use before removing */\n\t\t\t\t\t\thandler_info_wait_unused(tmp_rh);\n\n\t\t\t\t\t\t/* Ok, the handler is no more used -> Destroy resources\n\t\t\t\t\t\t */\n\t\t\t\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\t\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\t\t\t}\n\t\t\t\t\t*lastref = tmp_rh->next;\n\t\t\t\t\tmg_free(tmp_rh->uri);\n\t\t\t\t\tmg_free(tmp_rh);\n\t\t\t\t}\n\t\t\t\tmg_unlock_context(phys_ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlastref = &(tmp_rh->next);\n\t}\n\n\tif (is_delete_request) {\n\t\t/* no handler to set, this was a remove request to a non-existing\n\t\t * handler */\n\t\tmg_unlock_context(phys_ctx);\n\t\treturn;\n\t}\n\n\ttmp_rh =\n\t    (struct mg_handler_info *)mg_calloc_ctx(sizeof(struct mg_handler_info),\n\t                                            1,\n\t                                            phys_ctx);\n\tif (tmp_rh == NULL) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri = mg_strdup_ctx(uri, phys_ctx);\n\tif (!tmp_rh->uri) {\n\t\tmg_unlock_context(phys_ctx);\n\t\tmg_free(tmp_rh);\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot create new request handler struct, OOM\");\n\t\treturn;\n\t}\n\ttmp_rh->uri_len = urilen;\n\tif (handler_type == REQUEST_HANDLER) {\n\t\t/* Init refcount mutex and condition */\n\t\tif (0 != pthread_mutex_init(&tmp_rh->refcount_mutex, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount mutex\");\n\t\t\treturn;\n\t\t}\n\t\tif (0 != pthread_cond_init(&tmp_rh->refcount_cond, NULL)) {\n\t\t\tmg_unlock_context(phys_ctx);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t\tmg_free(tmp_rh);\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Cannot init refcount cond\");\n\t\t\treturn;\n\t\t}\n\t\ttmp_rh->refcount = 0;\n\t\ttmp_rh->handler = handler;\n\t} else if (handler_type == WEBSOCKET_HANDLER) {\n\t\ttmp_rh->subprotocols = subprotocols;\n\t\ttmp_rh->connect_handler = connect_handler;\n\t\ttmp_rh->ready_handler = ready_handler;\n\t\ttmp_rh->data_handler = data_handler;\n\t\ttmp_rh->close_handler = close_handler;\n\t} else { /* AUTH_HANDLER */\n\t\ttmp_rh->auth_handler = auth_handler;\n\t}\n\ttmp_rh->cbdata = cbdata;\n\ttmp_rh->handler_type = handler_type;\n\ttmp_rh->next = NULL;\n\n\t*lastref = tmp_rh;\n\tmg_unlock_context(phys_ctx);\n}\n\n\nvoid\nmg_set_request_handler(struct mg_context *ctx,\n                       const char *uri,\n                       mg_request_handler handler,\n                       void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    REQUEST_HANDLER,\n\t                    handler == NULL,\n\t                    handler,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler(struct mg_context *ctx,\n                         const char *uri,\n                         mg_websocket_connect_handler connect_handler,\n                         mg_websocket_ready_handler ready_handler,\n                         mg_websocket_data_handler data_handler,\n                         mg_websocket_close_handler close_handler,\n                         void *cbdata)\n{\n\tmg_set_websocket_handler_with_subprotocols(ctx,\n\t                                           uri,\n\t                                           NULL,\n\t                                           connect_handler,\n\t                                           ready_handler,\n\t                                           data_handler,\n\t                                           close_handler,\n\t                                           cbdata);\n}\n\n\nvoid\nmg_set_websocket_handler_with_subprotocols(\n    struct mg_context *ctx,\n    const char *uri,\n    struct mg_websocket_subprotocols *subprotocols,\n    mg_websocket_connect_handler connect_handler,\n    mg_websocket_ready_handler ready_handler,\n    mg_websocket_data_handler data_handler,\n    mg_websocket_close_handler close_handler,\n    void *cbdata)\n{\n\tint is_delete_request = (connect_handler == NULL) && (ready_handler == NULL)\n\t                        && (data_handler == NULL)\n\t                        && (close_handler == NULL);\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    WEBSOCKET_HANDLER,\n\t                    is_delete_request,\n\t                    NULL,\n\t                    subprotocols,\n\t                    connect_handler,\n\t                    ready_handler,\n\t                    data_handler,\n\t                    close_handler,\n\t                    NULL,\n\t                    cbdata);\n}\n\n\nvoid\nmg_set_auth_handler(struct mg_context *ctx,\n                    const char *uri,\n                    mg_request_handler handler,\n                    void *cbdata)\n{\n\tmg_set_handler_type(ctx,\n\t                    &(ctx->dd),\n\t                    uri,\n\t                    AUTH_HANDLER,\n\t                    handler == NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    NULL,\n\t                    handler,\n\t                    cbdata);\n}\n\n\nstatic int\nget_request_handler(struct mg_connection *conn,\n                    int handler_type,\n                    mg_request_handler *handler,\n                    struct mg_websocket_subprotocols **subprotocols,\n                    mg_websocket_connect_handler *connect_handler,\n                    mg_websocket_ready_handler *ready_handler,\n                    mg_websocket_data_handler *data_handler,\n                    mg_websocket_close_handler *close_handler,\n                    mg_authorization_handler *auth_handler,\n                    void **cbdata,\n                    struct mg_handler_info **handler_info)\n{\n\tconst struct mg_request_info *request_info = mg_get_request_info(conn);\n\tif (request_info) {\n\t\tconst char *uri = request_info->local_uri;\n\t\tsize_t urilen = strlen(uri);\n\t\tstruct mg_handler_info *tmp_rh;\n\n\t\tif (!conn || !conn->phys_ctx || !conn->dom_ctx) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tmg_lock_context(conn->phys_ctx);\n\n\t\t/* first try for an exact match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* next try for a partial match, we will accept uri/something */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif ((tmp_rh->uri_len < urilen) && (uri[tmp_rh->uri_len] == '/')\n\t\t\t\t    && (memcmp(tmp_rh->uri, uri, tmp_rh->uri_len) == 0)) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* finally try for pattern match */\n\t\tfor (tmp_rh = conn->dom_ctx->handlers; tmp_rh != NULL;\n\t\t     tmp_rh = tmp_rh->next) {\n\t\t\tif (tmp_rh->handler_type == handler_type) {\n\t\t\t\tif (match_prefix(tmp_rh->uri, tmp_rh->uri_len, uri) > 0) {\n\t\t\t\t\tif (handler_type == WEBSOCKET_HANDLER) {\n\t\t\t\t\t\t*subprotocols = tmp_rh->subprotocols;\n\t\t\t\t\t\t*connect_handler = tmp_rh->connect_handler;\n\t\t\t\t\t\t*ready_handler = tmp_rh->ready_handler;\n\t\t\t\t\t\t*data_handler = tmp_rh->data_handler;\n\t\t\t\t\t\t*close_handler = tmp_rh->close_handler;\n\t\t\t\t\t} else if (handler_type == REQUEST_HANDLER) {\n\t\t\t\t\t\t*handler = tmp_rh->handler;\n\t\t\t\t\t\t/* Acquire handler and give it back */\n\t\t\t\t\t\thandler_info_acquire(tmp_rh);\n\t\t\t\t\t\t*handler_info = tmp_rh;\n\t\t\t\t\t} else { /* AUTH_HANDLER */\n\t\t\t\t\t\t*auth_handler = tmp_rh->auth_handler;\n\t\t\t\t\t}\n\t\t\t\t\t*cbdata = tmp_rh->cbdata;\n\t\t\t\t\tmg_unlock_context(conn->phys_ctx);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmg_unlock_context(conn->phys_ctx);\n\t}\n\treturn 0; /* none found */\n}\n\n\n/* Check if the script file is in a path, allowed for script files.\n * This can be used if uploading files is possible not only for the server\n * admin, and the upload mechanism does not check the file extension.\n */\nstatic int\nis_in_script_path(const struct mg_connection *conn, const char *path)\n{\n\t/* TODO (Feature): Add config value for allowed script path.\n\t * Default: All allowed. */\n\t(void)conn;\n\t(void)path;\n\treturn 1;\n}\n\n\n#if defined(USE_WEBSOCKET) && defined(MG_LEGACY_INTERFACE)\nstatic int\ndeprecated_websocket_connect_wrapper(const struct mg_connection *conn,\n                                     void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_connect) {\n\t\treturn pcallbacks->websocket_connect(conn);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 0;\n}\n\n\nstatic void\ndeprecated_websocket_ready_wrapper(struct mg_connection *conn, void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_ready) {\n\t\tpcallbacks->websocket_ready(conn);\n\t}\n}\n\n\nstatic int\ndeprecated_websocket_data_wrapper(struct mg_connection *conn,\n                                  int bits,\n                                  char *data,\n                                  size_t len,\n                                  void *cbdata)\n{\n\tstruct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;\n\tif (pcallbacks->websocket_data) {\n\t\treturn pcallbacks->websocket_data(conn, bits, data, len);\n\t}\n\t/* No handler set - assume \"OK\" */\n\treturn 1;\n}\n#endif\n\n\n/* This is the heart of the Civetweb's logic.\n * This function is called when the request is read, parsed and validated,\n * and Civetweb must decide what action to take: serve a file, or\n * a directory, or call embedded function, etcetera. */\nstatic void\nhandle_request(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tchar path[PATH_MAX];\n\tint uri_len, ssl_index;\n\tint is_found = 0, is_script_resource = 0, is_websocket_request = 0,\n\t    is_put_or_delete_request = 0, is_callback_resource = 0;\n\tint i;\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\tmg_request_handler callback_handler = NULL;\n\tstruct mg_handler_info *handler_info = NULL;\n\tstruct mg_websocket_subprotocols *subprotocols;\n\tmg_websocket_connect_handler ws_connect_handler = NULL;\n\tmg_websocket_ready_handler ws_ready_handler = NULL;\n\tmg_websocket_data_handler ws_data_handler = NULL;\n\tmg_websocket_close_handler ws_close_handler = NULL;\n\tvoid *callback_data = NULL;\n\tmg_authorization_handler auth_handler = NULL;\n\tvoid *auth_callback_data = NULL;\n\tint handler_type;\n\ttime_t curtime = time(NULL);\n\tchar date[64];\n\n\tpath[0] = 0;\n\n\t/* 1. get the request url */\n\t/* 1.1. split into url and query string */\n\tif ((conn->request_info.query_string = strchr(ri->request_uri, '?'))\n\t    != NULL) {\n\t\t*((char *)conn->request_info.query_string++) = '\\0';\n\t}\n\n\t/* 1.2. do a https redirect, if required. Do not decode URIs yet. */\n\tif (!conn->client.is_ssl && conn->client.ssl_redir) {\n\t\tssl_index = get_first_ssl_listener_index(conn->phys_ctx);\n\t\tif (ssl_index >= 0) {\n\t\t\tredirect_to_https_port(conn, ssl_index);\n\t\t} else {\n\t\t\t/* A http to https forward port has been specified,\n\t\t\t * but no https port to forward to. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   503,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: SSL forward not configured properly\");\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Can not redirect to SSL, no SSL port available\");\n\t\t}\n\t\treturn;\n\t}\n\turi_len = (int)strlen(ri->local_uri);\n\n\t/* 1.3. decode url (if config says so) */\n\tif (should_decode_url(conn)) {\n\t\tmg_url_decode(\n\t\t    ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);\n\t}\n\n\t/* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is\n\t * not possible */\n\tremove_double_dots_and_double_slashes((char *)ri->local_uri);\n\n\t/* step 1. completed, the url is known now */\n\turi_len = (int)strlen(ri->local_uri);\n\tDEBUG_TRACE(\"URL: %s\", ri->local_uri);\n\n\t/* 2. if this ip has limited speed, set it for this connection */\n\tconn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],\n\t                              get_remote_ip(conn),\n\t                              ri->local_uri);\n\n\t/* 3. call a \"handle everything\" callback, if registered */\n\tif (conn->phys_ctx->callbacks.begin_request != NULL) {\n\t\t/* Note that since V1.7 the \"begin_request\" function is called\n\t\t * before an authorization check. If an authorization check is\n\t\t * required, use a request_handler instead. */\n\t\ti = conn->phys_ctx->callbacks.begin_request(conn);\n\t\tif (i > 0) {\n\t\t\t/* callback already processed the request. Store the\n\t\t\t   return value as a status code for the access log. */\n\t\t\tconn->status_code = i;\n\t\t\tdiscard_unread_request_data(conn);\n\t\t\treturn;\n\t\t} else if (i == 0) {\n\t\t\t/* civetweb should process the request */\n\t\t} else {\n\t\t\t/* unspecified - may change with the next version */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request not yet handled by a handler or redirect, so the request\n\t * is processed here */\n\n\t/* 4. Check for CORS preflight requests and handle them (if configured).\n\t * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\t */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* Send a response to CORS preflights only if\n\t\t * access_control_allow_methods is not NULL and not an empty string.\n\t\t * In this case, scripts can still handle CORS. */\n\t\tconst char *cors_meth_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];\n\t\tconst char *cors_orig_cfg =\n\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];\n\t\tconst char *cors_origin =\n\t\t    get_header(ri->http_headers, ri->num_headers, \"Origin\");\n\t\tconst char *cors_acrm = get_header(ri->http_headers,\n\t\t                                   ri->num_headers,\n\t\t                                   \"Access-Control-Request-Method\");\n\n\t\t/* Todo: check if cors_origin is in cors_orig_cfg.\n\t\t * Or, let the client check this. */\n\n\t\tif ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0)\n\t\t    && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0)\n\t\t    && (cors_origin != NULL) && (cors_acrm != NULL)) {\n\t\t\t/* This is a valid CORS preflight, and the server is configured\n\t\t\t * to\n\t\t\t * handle it automatically. */\n\t\t\tconst char *cors_acrh =\n\t\t\t    get_header(ri->http_headers,\n\t\t\t               ri->num_headers,\n\t\t\t               \"Access-Control-Request-Headers\");\n\n\t\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\t\tmg_printf(conn,\n\t\t\t          \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\t          \"Date: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Origin: %s\\r\\n\"\n\t\t\t          \"Access-Control-Allow-Methods: %s\\r\\n\"\n\t\t\t          \"Content-Length: 0\\r\\n\"\n\t\t\t          \"Connection: %s\\r\\n\",\n\t\t\t          date,\n\t\t\t          cors_orig_cfg,\n\t\t\t          ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),\n\t\t\t          suggest_connection_header(conn));\n\n\t\t\tif (cors_acrh != NULL) {\n\t\t\t\t/* CORS request is asking for additional headers */\n\t\t\t\tconst char *cors_hdr_cfg =\n\t\t\t\t    conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];\n\n\t\t\t\tif ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {\n\t\t\t\t\t/* Allow only if access_control_allow_headers is\n\t\t\t\t\t * not NULL and not an empty string. If this\n\t\t\t\t\t * configuration is set to *, allow everything.\n\t\t\t\t\t * Otherwise this configuration must be a list\n\t\t\t\t\t * of allowed HTTP header names. */\n\t\t\t\t\tmg_printf(conn,\n\t\t\t\t\t          \"Access-Control-Allow-Headers: %s\\r\\n\",\n\t\t\t\t\t          ((cors_hdr_cfg[0] == '*') ? cors_acrh\n\t\t\t\t\t                                    : cors_hdr_cfg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg_printf(conn, \"Access-Control-Max-Age: 60\\r\\n\");\n\n\t\t\tmg_printf(conn, \"\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 5. interpret the url to find out how the request must be handled\n\t */\n\t/* 5.1. first test, if the request targets the regular http(s)://\n\t * protocol namespace or the websocket ws(s):// protocol namespace.\n\t */\n\tis_websocket_request = is_websocket_protocol(conn);\n#if defined(USE_WEBSOCKET)\n\thandler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;\n#else\n\thandler_type = REQUEST_HANDLER;\n#endif /* defined(USE_WEBSOCKET) */\n\t/* 5.2. check if the request will be handled by a callback */\n\tif (get_request_handler(conn,\n\t                        handler_type,\n\t                        &callback_handler,\n\t                        &subprotocols,\n\t                        &ws_connect_handler,\n\t                        &ws_ready_handler,\n\t                        &ws_data_handler,\n\t                        &ws_close_handler,\n\t                        NULL,\n\t                        &callback_data,\n\t                        &handler_info)) {\n\t\t/* 5.2.1. A callback will handle this request. All requests\n\t\t * handled\n\t\t * by a callback have to be considered as requests to a script\n\t\t * resource. */\n\t\tis_callback_resource = 1;\n\t\tis_script_resource = 1;\n\t\tis_put_or_delete_request = is_put_or_delete_method(conn);\n\t} else {\n\tno_callback_resource:\n\n\t\t/* 5.2.2. No callback is responsible for this request. The URI\n\t\t * addresses a file based resource (static content or Lua/cgi\n\t\t * scripts in the file system). */\n\t\tis_callback_resource = 0;\n\t\tinterpret_uri(conn,\n\t\t              path,\n\t\t              sizeof(path),\n\t\t              &file.stat,\n\t\t              &is_found,\n\t\t              &is_script_resource,\n\t\t              &is_websocket_request,\n\t\t              &is_put_or_delete_request);\n\t}\n\n\t/* 6. authorization check */\n\t/* 6.1. a custom authorization handler is installed */\n\tif (get_request_handler(conn,\n\t                        AUTH_HANDLER,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        NULL,\n\t                        &auth_handler,\n\t                        &auth_callback_data,\n\t                        NULL)) {\n\t\tif (!auth_handler(conn, auth_callback_data)) {\n\t\t\treturn;\n\t\t}\n\t} else if (is_put_or_delete_request && !is_script_resource\n\t           && !is_callback_resource) {\n/* 6.2. this request is a PUT/DELETE to a real file */\n/* 6.2.1. thus, the server must have real files */\n#if defined(NO_FILES)\n\t\tif (1) {\n#else\n\t\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n#endif\n\t\t\t/* This server does not have any real files, thus the\n\t\t\t * PUT/DELETE methods are not valid. */\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   405,\n\t\t\t                   \"%s method not allowed\",\n\t\t\t                   conn->request_info.request_method);\n\t\t\treturn;\n\t\t}\n\n#if !defined(NO_FILES)\n\t\t/* 6.2.2. Check if put authorization for static files is\n\t\t * available.\n\t\t */\n\t\tif (!is_authorized_for_put(conn)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t} else {\n\t\t/* 6.3. This is either a OPTIONS, GET, HEAD or POST request,\n\t\t * or it is a PUT or DELETE request to a resource that does not\n\t\t * correspond to a file. Check authorization. */\n\t\tif (!check_authorization(conn, path)) {\n\t\t\tsend_authorization_request(conn, NULL);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* request is authorized or does not need authorization */\n\n\t/* 7. check if there are request handlers for this uri */\n\tif (is_callback_resource) {\n\t\tif (!is_websocket_request) {\n\t\t\ti = callback_handler(conn, callback_data);\n\n\t\t\t/* Callback handler will not be used anymore. Release it */\n\t\t\thandler_info_release(handler_info);\n\n\t\t\tif (i > 0) {\n\t\t\t\t/* Do nothing, callback has served the request. Store\n\t\t\t\t * then return value as status code for the log and discard\n\t\t\t\t * all data from the client not used by the callback. */\n\t\t\t\tconn->status_code = i;\n\t\t\t\tdiscard_unread_request_data(conn);\n\t\t\t} else {\n\t\t\t\t/* The handler did NOT handle the request. */\n\t\t\t\t/* Some proper reactions would be:\n\t\t\t\t * a) close the connections without sending anything\n\t\t\t\t * b) send a 404 not found\n\t\t\t\t * c) try if there is a file matching the URI\n\t\t\t\t * It would be possible to do a, b or c in the callback\n\t\t\t\t * implementation, and return 1 - we cannot do anything\n\t\t\t\t * here, that is not possible in the callback.\n\t\t\t\t *\n\t\t\t\t * TODO: What would be the best reaction here?\n\t\t\t\t * (Note: The reaction may change, if there is a better\n\t\t\t\t *idea.)\n\t\t\t\t */\n\n\t\t\t\t/* For the moment, use option c: We look for a proper file,\n\t\t\t\t * but since a file request is not always a script resource,\n\t\t\t\t * the authorization check might be different. */\n\t\t\t\tinterpret_uri(conn,\n\t\t\t\t              path,\n\t\t\t\t              sizeof(path),\n\t\t\t\t              &file.stat,\n\t\t\t\t              &is_found,\n\t\t\t\t              &is_script_resource,\n\t\t\t\t              &is_websocket_request,\n\t\t\t\t              &is_put_or_delete_request);\n\t\t\t\tcallback_handler = NULL;\n\n\t\t\t\t/* Here we are at a dead end:\n\t\t\t\t * According to URI matching, a callback should be\n\t\t\t\t * responsible for handling the request,\n\t\t\t\t * we called it, but the callback declared itself\n\t\t\t\t * not responsible.\n\t\t\t\t * We use a goto here, to get out of this dead end,\n\t\t\t\t * and continue with the default handling.\n\t\t\t\t * A goto here is simpler and better to understand\n\t\t\t\t * than some curious loop. */\n\t\t\t\tgoto no_callback_resource;\n\t\t\t}\n\t\t} else {\n#if defined(USE_WEBSOCKET)\n\t\t\thandle_websocket_request(conn,\n\t\t\t                         path,\n\t\t\t                         is_callback_resource,\n\t\t\t                         subprotocols,\n\t\t\t                         ws_connect_handler,\n\t\t\t                         ws_ready_handler,\n\t\t\t                         ws_data_handler,\n\t\t\t                         ws_close_handler,\n\t\t\t                         callback_data);\n#endif\n\t\t}\n\t\treturn;\n\t}\n\n/* 8. handle websocket requests */\n#if defined(USE_WEBSOCKET)\n\tif (is_websocket_request) {\n\t\tif (is_script_resource) {\n\n\t\t\tif (is_in_script_path(conn, path)) {\n\t\t\t\t/* Websocket Lua script */\n\t\t\t\thandle_websocket_request(conn,\n\t\t\t\t                         path,\n\t\t\t\t                         0 /* Lua Script */,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         NULL,\n\t\t\t\t                         conn->phys_ctx->user_data);\n\t\t\t} else {\n\t\t\t\t/* Script was in an illegal path */\n\t\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t\t}\n\t\t} else {\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\thandle_websocket_request(\n\t\t\t    conn,\n\t\t\t    path,\n\t\t\t    !is_script_resource /* could be deprecated global callback */,\n\t\t\t    NULL,\n\t\t\t    deprecated_websocket_connect_wrapper,\n\t\t\t    deprecated_websocket_ready_wrapper,\n\t\t\t    deprecated_websocket_data_wrapper,\n\t\t\t    NULL,\n\t\t\t    conn->phys_ctx->user_data);\n#else\n\t\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n#endif\n\t\t}\n\t\treturn;\n\t} else\n#endif\n\n#if defined(NO_FILES)\n\t\t/* 9a. In case the server uses only callbacks, this uri is\n\t\t * unknown.\n\t\t * Then, all request handling ends here. */\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\n#else\n\t/* 9b. This request is either for a static file or resource handled\n\t * by a script file. Thus, a DOCUMENT_ROOT must exist. */\n\tif (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not Found\");\n\t\treturn;\n\t}\n\n\t/* 10. Request is handled by a script */\n\tif (is_script_resource) {\n\t\thandle_file_based_request(conn, path, &file);\n\t\treturn;\n\t}\n\n\t/* 11. Handle put/delete/mkcol requests */\n\tif (is_put_or_delete_request) {\n\t\t/* 11.1. PUT method */\n\t\tif (!strcmp(ri->request_method, \"PUT\")) {\n\t\t\tput_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.2. DELETE method */\n\t\tif (!strcmp(ri->request_method, \"DELETE\")) {\n\t\t\tdelete_file(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.3. MKCOL method */\n\t\tif (!strcmp(ri->request_method, \"MKCOL\")) {\n\t\t\tmkcol(conn, path);\n\t\t\treturn;\n\t\t}\n\t\t/* 11.4. PATCH method\n\t\t * This method is not supported for static resources,\n\t\t * only for scripts (Lua, CGI) and callbacks. */\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 11. File does not exist, or it was configured that it should be\n\t * hidden */\n\tif (!is_found || (must_hide_file(conn, path))) {\n\t\tmg_send_http_error(conn, 404, \"%s\", \"Not found\");\n\t\treturn;\n\t}\n\n\t/* 12. Directory uris should end with a slash */\n\tif (file.stat.is_directory && (uri_len > 0)\n\t    && (ri->local_uri[uri_len - 1] != '/')) {\n\t\tgmt_time_string(date, sizeof(date), &curtime);\n\t\tmg_printf(conn,\n\t\t          \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n\t\t          \"Location: %s/\\r\\n\"\n\t\t          \"Date: %s\\r\\n\"\n\t\t          /* \"Cache-Control: private\\r\\n\" (= default) */\n\t\t          \"Content-Length: 0\\r\\n\"\n\t\t          \"Connection: %s\\r\\n\",\n\t\t          ri->request_uri,\n\t\t          date,\n\t\t          suggest_connection_header(conn));\n\t\tsend_additional_header(conn);\n\t\tmg_printf(conn, \"\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* 13. Handle other methods than GET/HEAD */\n\t/* 13.1. Handle PROPFIND */\n\tif (!strcmp(ri->request_method, \"PROPFIND\")) {\n\t\thandle_propfind(conn, path, &file.stat);\n\t\treturn;\n\t}\n\t/* 13.2. Handle OPTIONS for files */\n\tif (!strcmp(ri->request_method, \"OPTIONS\")) {\n\t\t/* This standard handler is only used for real files.\n\t\t * Scripts should support the OPTIONS method themselves, to allow a\n\t\t * maximum flexibility.\n\t\t * Lua and CGI scripts may fully support CORS this way (including\n\t\t * preflights). */\n\t\tsend_options(conn);\n\t\treturn;\n\t}\n\t/* 13.3. everything but GET and HEAD (e.g. POST) */\n\tif ((0 != strcmp(ri->request_method, \"GET\"))\n\t    && (0 != strcmp(ri->request_method, \"HEAD\"))) {\n\t\tmg_send_http_error(conn,\n\t\t                   405,\n\t\t                   \"%s method not allowed\",\n\t\t                   conn->request_info.request_method);\n\t\treturn;\n\t}\n\n\t/* 14. directories */\n\tif (file.stat.is_directory) {\n\t\t/* Substitute files have already been handled above. */\n\t\t/* Here we can either generate and send a directory listing,\n\t\t * or send an \"access denied\" error. */\n\t\tif (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],\n\t\t                   \"yes\")) {\n\t\t\thandle_directory_request(conn, path);\n\t\t} else {\n\t\t\tmg_send_http_error(conn,\n\t\t\t                   403,\n\t\t\t                   \"%s\",\n\t\t\t                   \"Error: Directory listing denied\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/* 15. read a normal file with GET or HEAD */\n\thandle_file_based_request(conn, path, &file);\n#endif /* !defined(NO_FILES) */\n}\n\n\nstatic void\nhandle_file_based_request(struct mg_connection *conn,\n                          const char *path,\n                          struct mg_file *file)\n{\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (0) {\n#if defined(USE_LUA)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS]),\n\t               path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua server page: an SSI like page containing mostly plain\n\t\t\t * html\n\t\t\t * code\n\t\t\t * plus some tags with server generated contents. */\n\t\t\thandle_lsp_request(conn, path, file, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n\n\t} else if (match_prefix(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],\n\t                        strlen(\n\t                            conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Lua in-server module script: a CGI like script used to\n\t\t\t * generate\n\t\t\t * the\n\t\t\t * entire reply. */\n\t\t\tmg_exec_lua_script(conn, path, NULL);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t} else if (match_prefix(\n\t               conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],\n\t               strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS]),\n\t               path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* Call duktape to generate the page */\n\t\t\tmg_exec_duktape_script(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif\n#if !defined(NO_CGI)\n\t} else if (match_prefix(conn->dom_ctx->config[CGI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[CGI_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\t/* CGI scripts may support all HTTP methods */\n\t\t\thandle_cgi_request(conn, path);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#endif /* !NO_CGI */\n\t} else if (match_prefix(conn->dom_ctx->config[SSI_EXTENSIONS],\n\t                        strlen(conn->dom_ctx->config[SSI_EXTENSIONS]),\n\t                        path)\n\t           > 0) {\n\t\tif (is_in_script_path(conn, path)) {\n\t\t\thandle_ssi_file_request(conn, path, file);\n\t\t} else {\n\t\t\t/* Script was in an illegal path */\n\t\t\tmg_send_http_error(conn, 403, \"%s\", \"Forbidden\");\n\t\t}\n#if !defined(NO_CACHING)\n\t} else if ((!conn->in_error_handler)\n\t           && is_not_modified(conn, &file->stat)) {\n\t\t/* Send 304 \"Not Modified\" - this must not send any body data */\n\t\thandle_not_modified_static_file_request(conn, file);\n#endif /* !NO_CACHING */\n\t} else {\n\t\thandle_static_file_request(conn, path, file, NULL, NULL);\n\t}\n}\n\n\nstatic void\nclose_all_listening_sockets(struct mg_context *ctx)\n{\n\tunsigned int i;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\tclosesocket(ctx->listening_sockets[i].sock);\n\t\tctx->listening_sockets[i].sock = INVALID_SOCKET;\n\t}\n\tmg_free(ctx->listening_sockets);\n\tctx->listening_sockets = NULL;\n\tmg_free(ctx->listening_socket_fds);\n\tctx->listening_socket_fds = NULL;\n}\n\n\n/* Valid listening port specification is: [ip_address:]port[s]\n * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s\n * Examples for IPv6: [::]:80, [::1]:80,\n *   [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s\n *   see https://tools.ietf.org/html/rfc3513#section-2.2\n * In order to bind to both, IPv4 and IPv6, you can either add\n * both ports using 8080,[::]:8080, or the short form +8080.\n * Both forms differ in detail: 8080,[::]:8080 create two sockets,\n * one only accepting IPv4 the other only IPv6. +8080 creates\n * one socket accepting IPv4 and IPv6. Depending on the IPv6\n * environment, they might work differently, or might not work\n * at all - it must be tested what options work best in the\n * relevant network environment.\n */\nstatic int\nparse_port_string(const struct vec *vec, struct socket *so, int *ip_version)\n{\n\tunsigned int a, b, c, d, port;\n\tint ch, len;\n\tconst char *cb;\n#if defined(USE_IPV6)\n\tchar buf[100] = {0};\n#endif\n\n\t/* MacOS needs that. If we do not zero it, subsequent bind() will fail.\n\t * Also, all-zeroes in the socket address means binding to all addresses\n\t * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */\n\tmemset(so, 0, sizeof(*so));\n\tso->lsa.sin.sin_family = AF_INET;\n\t*ip_version = 0;\n\n\t/* Initialize port and len as invalid. */\n\tport = 0;\n\tlen = 0;\n\n\t/* Test for different ways to format this string */\n\tif (sscanf(vec->ptr, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len)\n\t    == 5) {\n\t\t/* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n\t\tso->lsa.sin.sin_addr.s_addr =\n\t\t    htonl((a << 24) | (b << 16) | (c << 8) | d);\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n#if defined(USE_IPV6)\n\t} else if (sscanf(vec->ptr, \"[%49[^]]]:%u%n\", buf, &port, &len) == 2\n\t           && mg_inet_pton(\n\t                  AF_INET6, buf, &so->lsa.sin6, sizeof(so->lsa.sin6))) {\n\t\t/* IPv6 address, examples: see above */\n\t\t/* so->lsa.sin6.sin6_family = AF_INET6; already set by mg_inet_pton\n\t\t */\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 6;\n#endif\n\n\t} else if ((vec->ptr[0] == '+')\n\t           && (sscanf(vec->ptr + 1, \"%u%n\", &port, &len) == 1)) {\n\n\t\t/* Port is specified with a +, bind to IPv6 and IPv4, INADDR_ANY */\n\t\t/* Add 1 to len for the + character we skipped before */\n\t\tlen++;\n\n#if defined(USE_IPV6)\n\t\t/* Set socket family to IPv6, do not use IPV6_V6ONLY */\n\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\tso->lsa.sin6.sin6_port = htons((uint16_t)port);\n\t\t*ip_version = 4 + 6;\n#else\n\t\t/* Bind to IPv4 only, since IPv6 is not built in. */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n#endif\n\n\t} else if (sscanf(vec->ptr, \"%u%n\", &port, &len) == 1) {\n\t\t/* If only port is specified, bind to IPv4, INADDR_ANY */\n\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t*ip_version = 4;\n\n\t} else if ((cb = strchr(vec->ptr, ':')) != NULL) {\n\t\t/* String could be a hostname. This check algotithm\n\t\t * will only work for RFC 952 compliant hostnames,\n\t\t * starting with a letter, containing only letters,\n\t\t * digits and hyphen ('-'). Newer specs may allow\n\t\t * more, but this is not guaranteed here, since it\n\t\t * may interfere with rules for port option lists. */\n\n\t\t/* According to RFC 1035, hostnames are restricted to 255 characters\n\t\t * in total (63 between two dots). */\n\t\tchar hostname[256];\n\t\tsize_t hostnlen = (size_t)(cb - vec->ptr);\n\n\t\tif (hostnlen >= sizeof(hostname)) {\n\t\t\t/* This would be invalid in any case */\n\t\t\t*ip_version = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(hostname, vec->ptr, hostnlen);\n\t\thostname[hostnlen] = 0;\n\n\t\tif (mg_inet_pton(\n\t\t        AF_INET, vec->ptr, &so->lsa.sin, sizeof(so->lsa.sin))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 4;\n\t\t\t\tso->lsa.sin.sin_family = AF_INET;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#if defined(USE_IPV6)\n\t\t} else if (mg_inet_pton(AF_INET6,\n\t\t                        vec->ptr,\n\t\t                        &so->lsa.sin6,\n\t\t                        sizeof(so->lsa.sin6))) {\n\t\t\tif (sscanf(cb + 1, \"%u%n\", &port, &len) == 1) {\n\t\t\t\t*ip_version = 6;\n\t\t\t\tso->lsa.sin6.sin6_family = AF_INET6;\n\t\t\t\tso->lsa.sin.sin_port = htons((uint16_t)port);\n\t\t\t\tlen += (int)(hostnlen + 1);\n\t\t\t} else {\n\t\t\t\tport = 0;\n\t\t\t\tlen = 0;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t} else {\n\t\t/* Parsing failure. */\n\t}\n\n\t/* sscanf and the option splitting code ensure the following condition\n\t */\n\tif ((len < 0) && ((unsigned)len > (unsigned)vec->len)) {\n\t\t*ip_version = 0;\n\t\treturn 0;\n\t}\n\tch = vec->ptr[len]; /* Next character after the port number */\n\tso->is_ssl = (ch == 's');\n\tso->ssl_redir = (ch == 'r');\n\n\t/* Make sure the port is valid and vector ends with 's', 'r' or ',' */\n\tif (is_valid_port(port)\n\t    && ((ch == '\\0') || (ch == 's') || (ch == 'r') || (ch == ','))) {\n\t\treturn 1;\n\t}\n\n\t/* Reset ip_version to 0 if there is an error */\n\t*ip_version = 0;\n\treturn 0;\n}\n\n\n/* Is there any SSL port in use? */\nstatic int\nis_ssl_port_used(const char *ports)\n{\n\tif (ports) {\n\t\t/* There are several different allowed syntax variants:\n\t\t * - \"80\" for a single port using every network interface\n\t\t * - \"localhost:80\" for a single port using only localhost\n\t\t * - \"80,localhost:8080\" for two ports, one bound to localhost\n\t\t * - \"80,127.0.0.1:8084,[::1]:8086\" for three ports, one bound\n\t\t *   to IPv4 localhost, one to IPv6 localhost\n\t\t * - \"+80\" use port 80 for IPv4 and IPv6\n\t\t * - \"+80r,+443s\" port 80 (HTTP) is a redirect to port 443 (HTTPS),\n\t\t *   for both: IPv4 and IPv4\n\t\t * - \"+443s,localhost:8080\" port 443 (HTTPS) for every interface,\n\t\t *   additionally port 8080 bound to localhost connections\n\t\t *\n\t\t * If we just look for 's' anywhere in the string, \"localhost:80\"\n\t\t * will be detected as SSL (false positive).\n\t\t * Looking for 's' after a digit may cause false positives in\n\t\t * \"my24service:8080\".\n\t\t * Looking from 's' backward if there are only ':' and numbers\n\t\t * before will not work for \"24service:8080\" (non SSL, port 8080)\n\t\t * or \"24s\" (SSL, port 24).\n\t\t *\n\t\t * Remark: Initially hostnames were not allowed to start with a\n\t\t * digit (according to RFC 952), this was allowed later (RFC 1123,\n\t\t * Section 2.1).\n\t\t *\n\t\t * To get this correct, the entire string must be parsed as a whole,\n\t\t * reading it as a list element for element and parsing with an\n\t\t * algorithm equivalent to parse_port_string.\n\t\t *\n\t\t * In fact, we use local interface names here, not arbitrary hostnames,\n\t\t * so in most cases the only name will be \"localhost\".\n\t\t *\n\t\t * So, for now, we use this simple algorithm, that may still return\n\t\t * a false positive in bizarre cases.\n\t\t */\n\t\tint i;\n\t\tint portslen = (int)strlen(ports);\n\t\tchar prevIsNumber = 0;\n\n\t\tfor (i = 0; i < portslen; i++) {\n\t\t\tif (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (ports[i] >= '0' && ports[i] <= '9') {\n\t\t\t\tprevIsNumber = 1;\n\t\t\t} else {\n\t\t\t\tprevIsNumber = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_ports_option(struct mg_context *phys_ctx)\n{\n\tconst char *list;\n\tint on = 1;\n#if defined(USE_IPV6)\n\tint off = 0;\n#endif\n\tstruct vec vec;\n\tstruct socket so, *ptr;\n\n\tstruct pollfd *pfd;\n\tunion usa usa;\n\tsocklen_t len;\n\tint ip_version;\n\n\tint portsTotal = 0;\n\tint portsOk = 0;\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tmemset(&so, 0, sizeof(so));\n\tmemset(&usa, 0, sizeof(usa));\n\tlen = sizeof(usa);\n\tlist = phys_ctx->dd.config[LISTENING_PORTS];\n\n\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\n\t\tportsTotal++;\n\n\t\tif (!parse_port_string(&vec, &so, &ip_version)) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"%.*s: invalid port spec (entry %i). Expecting list of: %s\",\n\t\t\t    (int)vec.len,\n\t\t\t    vec.ptr,\n\t\t\t    portsTotal,\n\t\t\t    \"[IP_ADDRESS:]PORT[s|r]\");\n\t\t\tcontinue;\n\t\t}\n\n#if !defined(NO_SSL)\n\t\tif (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot add SSL socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tif ((so.sock = socket(so.lsa.sa.sa_family, SOCK_STREAM, 6))\n\t\t    == INVALID_SOCKET) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot create socket (entry %i)\",\n\t\t\t                portsTotal);\n\t\t\tcontinue;\n\t\t}\n\n#if defined(_WIN32)\n\t\t/* Windows SO_REUSEADDR lets many procs binds to a\n\t\t * socket, SO_EXCLUSIVEADDRUSE makes the bind fail\n\t\t * if someone already has the socket -- DTL */\n\t\t/* NOTE: If SO_EXCLUSIVEADDRUSE is used,\n\t\t * Windows might need a few seconds before\n\t\t * the same port can be used again in the\n\t\t * same process, so a short Sleep may be\n\t\t * required between mg_stop and mg_start.\n\t\t */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_EXCLUSIVEADDRUSE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)\",\n\t\t\t    portsTotal);\n\t\t}\n#else\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_REUSEADDR,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\n\t\t\t/* Set reuse option, but don't abort on errors. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot set socket option SO_REUSEADDR (entry %i)\",\n\t\t\t                portsTotal);\n\t\t}\n#endif\n\n\t\tif (ip_version > 4) {\n/* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */\n#if defined(USE_IPV6)\n\t\t\tif (ip_version > 6) {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&off,\n\t\t\t\t                  sizeof(off))\n\t\t\t\t           != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=off (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (so.lsa.sa.sa_family == AF_INET6\n\t\t\t\t    && setsockopt(so.sock,\n\t\t\t\t                  IPPROTO_IPV6,\n\t\t\t\t                  IPV6_V6ONLY,\n\t\t\t\t                  (void *)&on,\n\t\t\t\t                  sizeof(on))\n\t\t\t\t           != 0) {\n\n\t\t\t\t\t/* Set IPv6 only option, but don't abort on errors. */\n\t\t\t\t\tmg_cry_internal(\n\t\t\t\t\t    fc(phys_ctx),\n\t\t\t\t\t    \"cannot set socket option IPV6_V6ONLY=on (entry %i)\",\n\t\t\t\t\t    portsTotal);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"IPv6 not available\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (so.lsa.sa.sa_family == AF_INET) {\n\n\t\t\tlen = sizeof(so.lsa.sin);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#if defined(USE_IPV6)\n\t\telse if (so.lsa.sa.sa_family == AF_INET6) {\n\n\t\t\tlen = sizeof(so.lsa.sin6);\n\t\t\tif (bind(so.sock, &so.lsa.sa, len) != 0) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"cannot bind to IPv6 %.*s: %d (%s)\",\n\t\t\t\t                (int)vec.len,\n\t\t\t\t                vec.ptr,\n\t\t\t\t                (int)ERRNO,\n\t\t\t\t                strerror(errno));\n\t\t\t\tclosesocket(so.sock);\n\t\t\t\tso.sock = INVALID_SOCKET;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(phys_ctx),\n\t\t\t    \"cannot bind: address family not supported (entry %i)\",\n\t\t\t    portsTotal);\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (listen(so.sock, SOMAXCONN) != 0) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"cannot listen to %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                (int)ERRNO,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((getsockname(so.sock, &(usa.sa), &len) != 0)\n\t\t    || (usa.sa.sa_family != so.lsa.sa.sa_family)) {\n\n\t\t\tint err = (int)ERRNO;\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"call to getsockname failed %.*s: %d (%s)\",\n\t\t\t                (int)vec.len,\n\t\t\t                vec.ptr,\n\t\t\t                err,\n\t\t\t                strerror(errno));\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n/* Update lsa port in case of random free ports */\n#if defined(USE_IPV6)\n\t\tif (so.lsa.sa.sa_family == AF_INET6) {\n\t\t\tso.lsa.sin6.sin6_port = usa.sin6.sin6_port;\n\t\t} else\n#endif\n\t\t{\n\t\t\tso.lsa.sin.sin_port = usa.sin.sin_port;\n\t\t}\n\n\t\tif ((ptr = (struct socket *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_sockets,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_sockets[0]),\n\t\t                        phys_ctx))\n\t\t    == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pfd = (struct pollfd *)\n\t\t         mg_realloc_ctx(phys_ctx->listening_socket_fds,\n\t\t                        (phys_ctx->num_listening_sockets + 1)\n\t\t                            * sizeof(phys_ctx->listening_socket_fds[0]),\n\t\t                        phys_ctx))\n\t\t    == NULL) {\n\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", \"Out of memory\");\n\t\t\tclosesocket(so.sock);\n\t\t\tso.sock = INVALID_SOCKET;\n\t\t\tmg_free(ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_close_on_exec(so.sock, fc(phys_ctx));\n\t\tphys_ctx->listening_sockets = ptr;\n\t\tphys_ctx->listening_sockets[phys_ctx->num_listening_sockets] = so;\n\t\tphys_ctx->listening_socket_fds = pfd;\n\t\tphys_ctx->num_listening_sockets++;\n\t\tportsOk++;\n\t}\n\n\tif (portsOk != portsTotal) {\n\t\tclose_all_listening_sockets(phys_ctx);\n\t\tportsOk = 0;\n\t}\n\n\treturn portsOk;\n}\n\n\nstatic const char *\nheader_val(const struct mg_connection *conn, const char *header)\n{\n\tconst char *header_value;\n\n\tif ((header_value = mg_get_header(conn, header)) == NULL) {\n\t\treturn \"-\";\n\t} else {\n\t\treturn header_value;\n\t}\n}\n\n\n#if defined(MG_EXTERNAL_FUNCTION_log_access)\nstatic void log_access(const struct mg_connection *conn);\n#include \"external_log_access.inl\"\n#else\n\nstatic void\nlog_access(const struct mg_connection *conn)\n{\n\tconst struct mg_request_info *ri;\n\tstruct mg_file fi;\n\tchar date[64], src_addr[IP_ADDR_STR_LEN];\n\tstruct tm *tm;\n\n\tconst char *referer;\n\tconst char *user_agent;\n\n\tchar buf[4096];\n\n\tif (!conn || !conn->dom_ctx) {\n\t\treturn;\n\t}\n\n\tif (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {\n\t\tif (mg_fopen(conn,\n\t\t             conn->dom_ctx->config[ACCESS_LOG_FILE],\n\t\t             MG_FOPEN_MODE_APPEND,\n\t\t             &fi)\n\t\t    == 0) {\n\t\t\tfi.access.fp = NULL;\n\t\t}\n\t} else {\n\t\tfi.access.fp = NULL;\n\t}\n\n\t/* Log is written to a file and/or a callback. If both are not set,\n\t * executing the rest of the function is pointless. */\n\tif ((fi.access.fp == NULL)\n\t    && (conn->phys_ctx->callbacks.log_access == NULL)) {\n\t\treturn;\n\t}\n\n\ttm = localtime(&conn->conn_birth_time);\n\tif (tm != NULL) {\n\t\tstrftime(date, sizeof(date), \"%d/%b/%Y:%H:%M:%S %z\", tm);\n\t} else {\n\t\tmg_strlcpy(date, \"01/Jan/1970:00:00:00 +0000\", sizeof(date));\n\t\tdate[sizeof(date) - 1] = '\\0';\n\t}\n\n\tri = &conn->request_info;\n\n\tsockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);\n\treferer = header_val(conn, \"Referer\");\n\tuser_agent = header_val(conn, \"User-Agent\");\n\n\tmg_snprintf(conn,\n\t            NULL, /* Ignore truncation in access log */\n\t            buf,\n\t            sizeof(buf),\n\t            \"%s - %s [%s] \\\"%s %s%s%s HTTP/%s\\\" %d %\" INT64_FMT \" %s %s\",\n\t            src_addr,\n\t            (ri->remote_user == NULL) ? \"-\" : ri->remote_user,\n\t            date,\n\t            ri->request_method ? ri->request_method : \"-\",\n\t            ri->request_uri ? ri->request_uri : \"-\",\n\t            ri->query_string ? \"?\" : \"\",\n\t            ri->query_string ? ri->query_string : \"\",\n\t            ri->http_version,\n\t            conn->status_code,\n\t            conn->num_bytes_sent,\n\t            referer,\n\t            user_agent);\n\n\tif (conn->phys_ctx->callbacks.log_access) {\n\t\tconn->phys_ctx->callbacks.log_access(conn, buf);\n\t}\n\n\tif (fi.access.fp) {\n\t\tint ok = 1;\n\t\tflockfile(fi.access.fp);\n\t\tif (fprintf(fi.access.fp, \"%s\\n\", buf) < 1) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (fflush(fi.access.fp) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tfunlockfile(fi.access.fp);\n\t\tif (mg_fclose(&fi.access) != 0) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (!ok) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Error writing log file %s\",\n\t\t\t                conn->dom_ctx->config[ACCESS_LOG_FILE]);\n\t\t}\n\t}\n}\n\n#endif /* Externally provided function */\n\n\n/* Verify given socket address against the ACL.\n * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.\n */\nstatic int\ncheck_acl(struct mg_context *phys_ctx, uint32_t remote_ip)\n{\n\tint allowed, flag;\n\tuint32_t net, mask;\n\tstruct vec vec;\n\n\tif (phys_ctx) {\n\t\tconst char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];\n\n\t\t/* If any ACL is set, deny by default */\n\t\tallowed = (list == NULL) ? '+' : '-';\n\n\t\twhile ((list = next_option(list, &vec, NULL)) != NULL) {\n\t\t\tflag = vec.ptr[0];\n\t\t\tif ((flag != '+' && flag != '-')\n\t\t\t    || (parse_net(&vec.ptr[1], &net, &mask) == 0)) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: subnet must be [+|-]x.x.x.x[/x]\",\n\t\t\t\t                __func__);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (net == (remote_ip & mask)) {\n\t\t\t\tallowed = flag;\n\t\t\t}\n\t\t}\n\n\t\treturn allowed == '+';\n\t}\n\treturn -1;\n}\n\n\n#if !defined(_WIN32)\nstatic int\nset_uid_option(struct mg_context *phys_ctx)\n{\n\tint success = 0;\n\n\tif (phys_ctx) {\n\t\t/* We are currently running as curr_uid. */\n\t\tconst uid_t curr_uid = getuid();\n\t\t/* If set, we want to run as run_as_user. */\n\t\tconst char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];\n\t\tconst struct passwd *to_pw = NULL;\n\n\t\tif (run_as_user != NULL && (to_pw = getpwnam(run_as_user)) == NULL) {\n\t\t\t/* run_as_user does not exist on the system. We can't proceed\n\t\t\t * further. */\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: unknown user [%s]\",\n\t\t\t                __func__,\n\t\t\t                run_as_user);\n\t\t} else if (run_as_user == NULL || curr_uid == to_pw->pw_uid) {\n\t\t\t/* There was either no request to change user, or we're already\n\t\t\t * running as run_as_user. Nothing else to do.\n\t\t\t */\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* Valid change request.  */\n\t\t\tif (setgid(to_pw->pw_gid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setgroups(0, NULL) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setgroups(): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                strerror(errno));\n\t\t\t} else if (setuid(to_pw->pw_uid) == -1) {\n\t\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t\t                \"%s: setuid(%s): %s\",\n\t\t\t\t                __func__,\n\t\t\t\t                run_as_user,\n\t\t\t\t                strerror(errno));\n\t\t\t} else {\n\t\t\t\tsuccess = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn success;\n}\n#endif /* !_WIN32 */\n\n\nstatic void\ntls_dtor(void *key)\n{\n\tstruct mg_workerTLS *tls = (struct mg_workerTLS *)key;\n\t/* key == pthread_getspecific(sTlsKey); */\n\n\tif (tls) {\n\t\tif (tls->is_master == 2) {\n\t\t\ttls->is_master = -3; /* Mark memory as dead */\n\t\t\tmg_free(tls);\n\t\t}\n\t}\n\tpthread_setspecific(sTlsKey, NULL);\n}\n\n\n#if !defined(NO_SSL)\n\nstatic int ssl_use_pem_file(struct mg_context *phys_ctx,\n                            struct mg_domain_context *dom_ctx,\n                            const char *pem,\n                            const char *chain);\nstatic const char *ssl_error(void);\n\n\nstatic int\nrefresh_trust(struct mg_connection *conn)\n{\n\tstatic int reload_lock = 0;\n\tstatic long int data_check = 0;\n\tvolatile int *p_reload_lock = (volatile int *)&reload_lock;\n\n\tstruct stat cert_buf;\n\tlong int t;\n\tconst char *pem;\n\tconst char *chain;\n\tint should_verify_peer;\n\n\tif ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {\n\t\t/* If peem is NULL and conn->phys_ctx->callbacks.init_ssl is not,\n\t\t * refresh_trust still can not work. */\n\t\treturn 0;\n\t}\n\tchain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\t/* pem is not NULL here */\n\t\tchain = pem;\n\t}\n\tif (*chain == 0) {\n\t\tchain = NULL;\n\t}\n\n\tt = data_check;\n\tif (stat(pem, &cert_buf) != -1) {\n\t\tt = (long int)cert_buf.st_mtime;\n\t}\n\n\tif (data_check != t) {\n\t\tdata_check = t;\n\n\t\tshould_verify_peer = 0;\n\t\tif (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\t\tif (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\")\n\t\t\t    == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t} else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t\t                         \"optional\")\n\t\t\t           == 0) {\n\t\t\t\tshould_verify_peer = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (should_verify_peer) {\n\t\t\tchar *ca_path = conn->dom_ctx->config[SSL_CA_PATH];\n\t\t\tchar *ca_file = conn->dom_ctx->config[SSL_CA_FILE];\n\t\t\tif (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,\n\t\t\t                                  ca_file,\n\t\t\t                                  ca_path)\n\t\t\t    != 1) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(conn->phys_ctx),\n\t\t\t\t    \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t\t    \"ssl_verify_peer requires setting \"\n\t\t\t\t    \"either ssl_ca_path or ssl_ca_file. Is any of them \"\n\t\t\t\t    \"present in \"\n\t\t\t\t    \"the .conf file?\",\n\t\t\t\t    ssl_error());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (1 == mg_atomic_inc(p_reload_lock)) {\n\t\t\tif (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain)\n\t\t\t    == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*p_reload_lock = 0;\n\t\t}\n\t}\n\t/* lock while cert is reloading */\n\twhile (*p_reload_lock) {\n\t\tsleep(1);\n\t}\n\n\treturn 1;\n}\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic pthread_mutex_t *ssl_mutexes;\n#endif /* OPENSSL_API_1_1 */\n\nstatic int\nsslize(struct mg_connection *conn,\n       SSL_CTX *s,\n       int (*func)(SSL *),\n       volatile int *stop_server,\n       const struct mg_client_options *client_options)\n{\n\tint ret, err;\n\tint short_trust;\n\tunsigned i;\n\n\tif (!conn) {\n\t\treturn 0;\n\t}\n\n\tshort_trust =\n\t    (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL)\n\t    && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], \"yes\") == 0);\n\n\tif (short_trust) {\n\t\tint trust_ret = refresh_trust(conn);\n\t\tif (!trust_ret) {\n\t\t\treturn trust_ret;\n\t\t}\n\t}\n\n\tconn->ssl = SSL_new(s);\n\tif (conn->ssl == NULL) {\n\t\treturn 0;\n\t}\n\tSSL_set_app_data(conn->ssl, (char *)conn);\n\n\tret = SSL_set_fd(conn->ssl, conn->client.sock);\n\tif (ret != 1) {\n\t\terr = SSL_get_error(conn->ssl, ret);\n\t\tmg_cry_internal(conn, \"SSL error %i, destroying SSL context\", err);\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\treturn 0;\n\t}\n\n\tif (client_options) {\n\t\tif (client_options->host_name) {\n\t\t\tSSL_set_tlsext_host_name(conn->ssl, client_options->host_name);\n\t\t}\n\t}\n\n\t/* SSL functions may fail and require to be called again:\n\t * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html\n\t * Here \"func\" could be SSL_connect or SSL_accept. */\n\tfor (i = 16; i <= 1024; i *= 2) {\n\t\tret = func(conn->ssl);\n\t\tif (ret != 1) {\n\t\t\terr = SSL_get_error(conn->ssl, ret);\n\t\t\tif ((err == SSL_ERROR_WANT_CONNECT)\n\t\t\t    || (err == SSL_ERROR_WANT_ACCEPT)\n\t\t\t    || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE)\n\t\t\t    || (err == SSL_ERROR_WANT_X509_LOOKUP)) {\n\t\t\t\t/* Need to retry the function call \"later\".\n\t\t\t\t * See https://linux.die.net/man/3/ssl_get_error\n\t\t\t\t * This is typical for non-blocking sockets. */\n\t\t\t\tif (*stop_server) {\n\t\t\t\t\t/* Don't wait if the server is going to be stopped. */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmg_sleep(i);\n\n\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t/* This is an IO error. Look at errno. */\n\t\t\t\terr = errno;\n\t\t\t\tmg_cry_internal(conn, \"SSL syscall error %i\", err);\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t/* This is an SSL specific error, e.g. SSL_ERROR_SSL */\n\t\t\t\tmg_cry_internal(conn, \"sslize error: %s\", ssl_error());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\t/* success */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != 1) {\n\t\tSSL_free(conn->ssl);\n\t\tconn->ssl = NULL;\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n/* Return OpenSSL error message (from CRYPTO lib) */\nstatic const char *\nssl_error(void)\n{\n\tunsigned long err;\n\terr = ERR_get_error();\n\treturn ((err == 0) ? \"\" : ERR_error_string(err, NULL));\n}\n\n\nstatic int\nhexdump2string(void *mem, int memlen, char *buf, int buflen)\n{\n\tint i;\n\tconst char hexdigit[] = \"0123456789abcdef\";\n\n\tif ((memlen <= 0) || (buflen <= 0)) {\n\t\treturn 0;\n\t}\n\tif (buflen < (3 * memlen)) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < memlen; i++) {\n\t\tif (i > 0) {\n\t\t\tbuf[3 * i - 1] = ' ';\n\t\t}\n\t\tbuf[3 * i] = hexdigit[(((uint8_t *)mem)[i] >> 4) & 0xF];\n\t\tbuf[3 * i + 1] = hexdigit[((uint8_t *)mem)[i] & 0xF];\n\t}\n\tbuf[3 * memlen - 1] = 0;\n\n\treturn 1;\n}\n\n\nstatic void\nssl_get_client_cert_info(struct mg_connection *conn)\n{\n\tX509 *cert = SSL_get_peer_certificate(conn->ssl);\n\tif (cert) {\n\t\tchar str_subject[1024];\n\t\tchar str_issuer[1024];\n\t\tchar str_finger[1024];\n\t\tunsigned char buf[256];\n\t\tchar *str_serial = NULL;\n\t\tunsigned int ulen;\n\t\tint ilen;\n\t\tunsigned char *tmp_buf;\n\t\tunsigned char *tmp_p;\n\n\t\t/* Handle to algorithm used for fingerprint */\n\t\tconst EVP_MD *digest = EVP_get_digestbyname(\"sha1\");\n\n\t\t/* Get Subject and issuer */\n\t\tX509_NAME *subj = X509_get_subject_name(cert);\n\t\tX509_NAME *iss = X509_get_issuer_name(cert);\n\n\t\t/* Get serial number */\n\t\tASN1_INTEGER *serial = X509_get_serialNumber(cert);\n\n\t\t/* Translate serial number to a hex string */\n\t\tBIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);\n\t\tstr_serial = BN_bn2hex(serial_bn);\n\t\tBN_free(serial_bn);\n\n\t\t/* Translate subject and issuer to a string */\n\t\t(void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));\n\t\t(void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));\n\n\t\t/* Calculate SHA1 fingerprint and store as a hex string */\n\t\tulen = 0;\n\n\t\t/* ASN1_digest is deprecated. Do the calculation manually,\n\t\t * using EVP_Digest. */\n\t\tilen = i2d_X509(cert, NULL);\n\t\ttmp_buf = (ilen > 0)\n\t\t              ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,\n\t\t                                               conn->phys_ctx)\n\t\t              : NULL;\n\t\tif (tmp_buf) {\n\t\t\ttmp_p = tmp_buf;\n\t\t\t(void)i2d_X509(cert, &tmp_p);\n\t\t\tif (!EVP_Digest(\n\t\t\t        tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {\n\t\t\t\tulen = 0;\n\t\t\t}\n\t\t\tmg_free(tmp_buf);\n\t\t}\n\n\t\tif (!hexdump2string(\n\t\t        buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {\n\t\t\t*str_finger = 0;\n\t\t}\n\n\t\tconn->request_info.client_cert = (struct mg_client_cert *)\n\t\t    mg_malloc_ctx(sizeof(struct mg_client_cert), conn->phys_ctx);\n\t\tif (conn->request_info.client_cert) {\n\t\t\tconn->request_info.client_cert->peer_cert = (void *)cert;\n\t\t\tconn->request_info.client_cert->subject =\n\t\t\t    mg_strdup_ctx(str_subject, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->issuer =\n\t\t\t    mg_strdup_ctx(str_issuer, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->serial =\n\t\t\t    mg_strdup_ctx(str_serial, conn->phys_ctx);\n\t\t\tconn->request_info.client_cert->finger =\n\t\t\t    mg_strdup_ctx(str_finger, conn->phys_ctx);\n\t\t} else {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"%s\",\n\t\t\t                \"Out of memory: Cannot allocate memory for client \"\n\t\t\t                \"certificate\");\n\t\t}\n\n\t\t/* Strings returned from bn_bn2hex must be freed using OPENSSL_free,\n\t\t * see https://linux.die.net/man/3/bn_bn2hex */\n\t\tOPENSSL_free(str_serial);\n\t}\n}\n\n\n#if defined(OPENSSL_API_1_1)\n#else\nstatic void\nssl_locking_callback(int mode, int mutex_num, const char *file, int line)\n{\n\t(void)line;\n\t(void)file;\n\n\tif (mode & 1) {\n\t\t/* 1 is CRYPTO_LOCK */\n\t\t(void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);\n\t} else {\n\t\t(void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);\n\t}\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n#if !defined(NO_SSL_DL)\nstatic void *\nload_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)\n{\n\tunion {\n\t\tvoid *p;\n\t\tvoid (*fp)(void);\n\t} u;\n\tvoid *dll_handle;\n\tstruct ssl_func *fp;\n\tint ok;\n\tint truncated = 0;\n\n\tif ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s: cannot load %s\",\n\t\t            __func__,\n\t\t            dll_name);\n\t\treturn NULL;\n\t}\n\n\tok = 1;\n\tfor (fp = sw; fp->name != NULL; fp++) {\n#if defined(_WIN32)\n\t\t/* GetProcAddress() returns pointer to function */\n\t\tu.fp = (void (*)(void))dlsym(dll_handle, fp->name);\n#else\n\t\t/* dlsym() on UNIX returns void *. ISO C forbids casts of data\n\t\t * pointers to function pointers. We need to use a union to make a\n\t\t * cast. */\n\t\tu.p = dlsym(dll_handle, fp->name);\n#endif /* _WIN32 */\n\t\tif (u.fp == NULL) {\n\t\t\tif (ok) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            &truncated,\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: %s: cannot find %s\",\n\t\t\t\t            __func__,\n\t\t\t\t            dll_name,\n\t\t\t\t            fp->name);\n\t\t\t\tok = 0;\n\t\t\t} else {\n\t\t\t\tsize_t cur_len = strlen(ebuf);\n\t\t\t\tif (!truncated) {\n\t\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t\t            &truncated,\n\t\t\t\t\t            ebuf + cur_len,\n\t\t\t\t\t            ebuf_len - cur_len - 3,\n\t\t\t\t\t            \", %s\",\n\t\t\t\t\t            fp->name);\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\t/* If truncated, add \"...\" */\n\t\t\t\t\t\tstrcat(ebuf, \"...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Debug:\n\t\t\t * printf(\"Missing function: %s\\n\", fp->name); */\n\t\t} else {\n\t\t\tfp->ptr = u.fp;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\t(void)dlclose(dll_handle);\n\t\treturn NULL;\n\t}\n\n\treturn dll_handle;\n}\n\n\nstatic void *ssllib_dll_handle;    /* Store the ssl library handle. */\nstatic void *cryptolib_dll_handle; /* Store the crypto library handle. */\n\n#endif /* NO_SSL_DL */\n\n\n#if defined(SSL_ALREADY_INITIALIZED)\nstatic int cryptolib_users = 1; /* Reference counter for crypto library. */\n#else\nstatic int cryptolib_users = 0; /* Reference counter for crypto library. */\n#endif\n\n\nstatic int\ninitialize_ssl(char *ebuf, size_t ebuf_len)\n{\n#if defined(OPENSSL_API_1_1)\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n#else /* not OPENSSL_API_1_1 */\n\tint i, num_locks;\n\tsize_t size;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = 0;\n\t}\n\n#if !defined(NO_SSL_DL)\n\tif (!cryptolib_dll_handle) {\n\t\tcryptolib_dll_handle = load_dll(ebuf, ebuf_len, CRYPTO_LIB, crypto_sw);\n\t\tif (!cryptolib_dll_handle) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: error loading library %s\",\n\t\t\t            __func__,\n\t\t\t            CRYPTO_LIB);\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n\tif (mg_atomic_inc(&cryptolib_users) > 1) {\n\t\treturn 1;\n\t}\n\n\t/* Initialize locking callbacks, needed for thread safety.\n\t * http://www.openssl.org/support/faq.html#PROG1\n\t */\n\tnum_locks = CRYPTO_num_locks();\n\tif (num_locks < 0) {\n\t\tnum_locks = 0;\n\t}\n\tsize = sizeof(pthread_mutex_t) * ((size_t)(num_locks));\n\n\t/* allocate mutex array, if required */\n\tif (num_locks == 0) {\n\t\t/* No mutex array required */\n\t\tssl_mutexes = NULL;\n\t} else {\n\t\t/* Mutex array required - allocate it */\n\t\tssl_mutexes = (pthread_mutex_t *)mg_malloc(size);\n\n\t\t/* Check OOM */\n\t\tif (ssl_mutexes == NULL) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s: cannot allocate mutexes: %s\",\n\t\t\t            __func__,\n\t\t\t            ssl_error());\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* initialize mutex array */\n\t\tfor (i = 0; i < num_locks; i++) {\n\t\t\tif (0 != pthread_mutex_init(&ssl_mutexes[i], &pthread_mutex_attr)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"%s: error initializing mutex %i of %i\",\n\t\t\t\t            __func__,\n\t\t\t\t            i,\n\t\t\t\t            num_locks);\n\t\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\t\tmg_free(ssl_mutexes);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tCRYPTO_set_locking_callback(&ssl_locking_callback);\n\tCRYPTO_set_id_callback(&mg_current_thread_id);\n#endif /* OPENSSL_API_1_1 */\n\n#if !defined(NO_SSL_DL)\n\tif (!ssllib_dll_handle) {\n\t\tssllib_dll_handle = load_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw);\n\t\tif (!ssllib_dll_handle) {\n#if !defined(OPENSSL_API_1_1)\n\t\t\tmg_free(ssl_mutexes);\n#endif\n\t\t\tDEBUG_TRACE(\"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif /* NO_SSL_DL */\n\n#if defined(OPENSSL_API_1_1)\n\t/* Initialize SSL library */\n\tOPENSSL_init_ssl(0, NULL);\n\tOPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS\n\t                     | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\n\t                 NULL);\n#else\n\t/* Initialize SSL library */\n\tSSL_library_init();\n\tSSL_load_error_strings();\n#endif\n\n\treturn 1;\n}\n\n\nstatic int\nssl_use_pem_file(struct mg_context *phys_ctx,\n                 struct mg_domain_context *dom_ctx,\n                 const char *pem,\n                 const char *chain)\n{\n\tif (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open certificate file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\t/* could use SSL_CTX_set_default_passwd_cb_userdata */\n\tif (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: cannot open private key file %s: %s\",\n\t\t                __func__,\n\t\t                pem,\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n\n\tif (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"%s: certificate and private key do not match: %s\",\n\t\t                __func__,\n\t\t                pem);\n\t\treturn 0;\n\t}\n\n\t/* In contrast to OpenSSL, wolfSSL does not support certificate\n\t * chain files that contain private keys and certificates in\n\t * SSL_CTX_use_certificate_chain_file.\n\t * The CivetWeb-Server used pem-Files that contained both information.\n\t * In order to make wolfSSL work, it is split in two files.\n\t * One file that contains key and certificate used by the server and\n\t * an optional chain file for the ssl stack.\n\t */\n\tif (chain) {\n\t\tif (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"%s: cannot use certificate chain file %s: %s\",\n\t\t\t                __func__,\n\t\t\t                pem,\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\n#if defined(OPENSSL_API_1_1)\nstatic unsigned long\nssl_get_protocol(int version_id)\n{\n\tlong unsigned ret = (long unsigned)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#else\nstatic long\nssl_get_protocol(int version_id)\n{\n\tlong ret = (long)SSL_OP_ALL;\n\tif (version_id > 0)\n\t\tret |= SSL_OP_NO_SSLv2;\n\tif (version_id > 1)\n\t\tret |= SSL_OP_NO_SSLv3;\n\tif (version_id > 2)\n\t\tret |= SSL_OP_NO_TLSv1;\n\tif (version_id > 3)\n\t\tret |= SSL_OP_NO_TLSv1_1;\n\treturn ret;\n}\n#endif /* OPENSSL_API_1_1 */\n\n\n/* SSL callback documentation:\n * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html\n * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3)\n * https://linux.die.net/man/3/ssl_set_info_callback */\n/* Note: There is no \"const\" for the first argument in the documentation\n * examples, however some (maybe most, but not all) headers of OpenSSL versions\n * / OpenSSL compatibility layers have it. Having a different definition will\n * cause a warning in C and an error in C++. Use \"const SSL *\", while\n * automatical conversion from \"SSL *\" works for all compilers, but not other\n * way around */\nstatic void\nssl_info_callback(const SSL *ssl, int what, int ret)\n{\n\t(void)ret;\n\n\tif (what & SSL_CB_HANDSHAKE_START) {\n\t\tSSL_get_app_data(ssl);\n\t}\n\tif (what & SSL_CB_HANDSHAKE_DONE) {\n\t\t/* TODO: check for openSSL 1.1 */\n\t\t//#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001\n\t\t// ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;\n\t}\n}\n\n\nstatic int\nssl_servername_callback(SSL *ssl, int *ad, void *arg)\n{\n\tstruct mg_context *ctx = (struct mg_context *)arg;\n\tstruct mg_domain_context *dom =\n\t    (struct mg_domain_context *)ctx ? &(ctx->dd) : NULL;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\t/* We used an aligned pointer in SSL_set_app_data */\n\tstruct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\tconst char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n\n\t(void)ad;\n\n\tif ((ctx == NULL) || (conn->phys_ctx == ctx)) {\n\t\tDEBUG_TRACE(\"%s\", \"internal error - assertion failed\");\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\t/* Old clients (Win XP) will not support SNI. Then, there\n\t * is no server name available in the request - we can\n\t * only work with the default certificate.\n\t * Multiple HTTPS hosts on one IP+port are only possible\n\t * with a certificate containing all alternative names.\n\t */\n\tif ((servername == NULL) || (*servername == 0)) {\n\t\tDEBUG_TRACE(\"%s\", \"SSL connection not supporting SNI\");\n\t\tconn->dom_ctx = &(ctx->dd);\n\t\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t}\n\n\tDEBUG_TRACE(\"TLS connection to host %s\", servername);\n\n\twhile (dom) {\n\t\tif (!mg_strcasecmp(servername, dom->config[AUTHENTICATION_DOMAIN])) {\n\n\t\t\t/* Found matching domain */\n\t\t\tDEBUG_TRACE(\"TLS domain %s found\",\n\t\t\t            dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tSSL_set_SSL_CTX(ssl, dom->ssl_ctx);\n\t\t\tconn->dom_ctx = dom;\n\t\t\treturn SSL_TLSEXT_ERR_OK;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\t/* Default domain */\n\tDEBUG_TRACE(\"TLS default domain %s used\",\n\t            ctx->dd.config[AUTHENTICATION_DOMAIN]);\n\tconn->dom_ctx = &(ctx->dd);\n\tSSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);\n\treturn SSL_TLSEXT_ERR_OK;\n}\n\n\n/* Setup SSL CTX as required by CivetWeb */\nstatic int\ninit_ssl_ctx_impl(struct mg_context *phys_ctx,\n                  struct mg_domain_context *dom_ctx,\n                  const char *pem,\n                  const char *chain)\n{\n\tint callback_ret;\n\tint should_verify_peer;\n\tint peer_certificate_optional;\n\tconst char *ca_path;\n\tconst char *ca_file;\n\tint use_default_verify_paths;\n\tint verify_depth;\n\tstruct timespec now_mt;\n\tmd5_byte_t ssl_context_id[16];\n\tmd5_state_t md5state;\n\tint protocol_ver;\n\n#if defined(OPENSSL_API_1_1)\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#else\n\tif ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL_CTX_new (server) error: %s\",\n\t\t                ssl_error());\n\t\treturn 0;\n\t}\n#endif /* OPENSSL_API_1_1 */\n\n\tSSL_CTX_clear_options(dom_ctx->ssl_ctx,\n\t                      SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1\n\t                          | SSL_OP_NO_TLSv1_1);\n\tprotocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx,\n\t                    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n\tSSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);\n#if !defined(NO_SSL_DL)\n\tSSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);\n#endif /* NO_SSL_DL */\n\n\t/* In SSL documentation examples callback defined without const specifier\n\t * 'void (*)(SSL *, int, int)'   See:\n\t * https://www.openssl.org/docs/man1.0.2/ssl/ssl.html\n\t * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html\n\t * But in the source code const SSL is used:\n\t * 'void (*)(const SSL *, int, int)' See:\n\t * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173\n\t * Problem about wrong documentation described, but not resolved:\n\t * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526\n\t * Wrong const cast ignored on C or can be suppressed by compiler flags.\n\t * But when compiled with modern C++ compiler, correct const should be\n\t * provided\n\t */\n\tSSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);\n\n\tSSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,\n\t                                       ssl_servername_callback);\n\tSSL_CTX_set_tlsext_servername_arg(dom_ctx->ssl_ctx, phys_ctx);\n\n\t/* If a callback has been specified, call it. */\n\tcallback_ret = (phys_ctx->callbacks.init_ssl == NULL)\n\t                   ? 0\n\t                   : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,\n\t                                                   phys_ctx->user_data));\n\n\t/* If callback returns 0, civetweb sets up the SSL certificate.\n\t * If it returns 1, civetweb assumes the calback already did this.\n\t * If it returns -1, initializing ssl fails. */\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"SSL callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t}\n\tif (callback_ret > 0) {\n\t\t/* Callback did everything. */\n\t\treturn 1;\n\t}\n\n\t/* Use some combination of start time, domain and port as a SSL\n\t * context ID. This should be unique on the current machine. */\n\tmd5_init(&md5state);\n\tclock_gettime(CLOCK_MONOTONIC, &now_mt);\n\tmd5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],\n\t           strlen(phys_ctx->dd.config[LISTENING_PORTS]));\n\tmd5_append(&md5state,\n\t           (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],\n\t           strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));\n\tmd5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));\n\tmd5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));\n\tmd5_finish(&md5state, ssl_context_id);\n\n\tSSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,\n\t                               (unsigned char *)ssl_context_id,\n\t                               sizeof(ssl_context_id));\n\n\tif (pem != NULL) {\n\t\tif (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Should we support client certificates? */\n\t/* Default is \"no\". */\n\tshould_verify_peer = 0;\n\tpeer_certificate_optional = 0;\n\tif (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {\n\t\tif (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], \"yes\") == 0) {\n\t\t\t/* Yes, they are mandatory */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 0;\n\t\t} else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],\n\t\t                         \"optional\")\n\t\t           == 0) {\n\t\t\t/* Yes, they are optional */\n\t\t\tshould_verify_peer = 1;\n\t\t\tpeer_certificate_optional = 1;\n\t\t}\n\t}\n\n\tuse_default_verify_paths =\n\t    (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL)\n\t    && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], \"yes\")\n\t        == 0);\n\n\tif (should_verify_peer) {\n\t\tca_path = dom_ctx->config[SSL_CA_PATH];\n\t\tca_file = dom_ctx->config[SSL_CA_FILE];\n\t\tif (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path)\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_load_verify_locations error: %s \"\n\t\t\t                \"ssl_verify_peer requires setting \"\n\t\t\t                \"either ssl_ca_path or ssl_ca_file. \"\n\t\t\t                \"Is any of them present in the \"\n\t\t\t                \".conf file?\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (peer_certificate_optional) {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(dom_ctx->ssl_ctx,\n\t\t\t                   SSL_VERIFY_PEER\n\t\t\t                       | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n\t\t\t                   NULL);\n\t\t}\n\n\t\tif (use_default_verify_paths\n\t\t    && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_default_verify_paths error: %s\",\n\t\t\t                ssl_error());\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dom_ctx->config[SSL_VERIFY_DEPTH]) {\n\t\t\tverify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);\n\t\t\tSSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);\n\t\t}\n\t}\n\n\tif (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {\n\t\tif (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,\n\t\t                            dom_ctx->config[SSL_CIPHER_LIST])\n\t\t    != 1) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"SSL_CTX_set_cipher_list error: %s\",\n\t\t\t                ssl_error());\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/* Check if SSL is required.\n * If so, dynamically load SSL library\n * and set up ctx->ssl_ctx pointer. */\nstatic int\ninit_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tvoid *ssl_ctx = 0;\n\tint callback_ret;\n\tconst char *pem;\n\tconst char *chain;\n\tchar ebuf[128];\n\n\tif (!phys_ctx) {\n\t\treturn 0;\n\t}\n\n\tif (!dom_ctx) {\n\t\tdom_ctx = &(phys_ctx->dd);\n\t}\n\n\tif (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {\n\t\t/* No SSL port is set. No need to setup SSL. */\n\t\treturn 1;\n\t}\n\n\t/* Check for external SSL_CTX */\n\tcallback_ret =\n\t    (phys_ctx->callbacks.external_ssl_ctx == NULL)\n\t        ? 0\n\t        : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,\n\t                                                phys_ctx->user_data));\n\n\tif (callback_ret < 0) {\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"external_ssl_ctx callback returned error: %i\",\n\t\t                callback_ret);\n\t\treturn 0;\n\t} else if (callback_ret > 0) {\n\t\tdom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;\n\t\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\t/* else: external_ssl_ctx does not exist or returns 0,\n\t * CivetWeb should continue initializing SSL */\n\n\t/* If PEM file is not specified and the init_ssl callback\n\t * is not specified, setup will fail. */\n\tif (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL)\n\t    && (phys_ctx->callbacks.init_ssl == NULL)) {\n\t\t/* No certificate and no callback:\n\t\t * Essential data to set up TLS is missing.\n\t\t */\n\t\tmg_cry_internal(fc(phys_ctx),\n\t\t                \"Initializing SSL failed: -%s is not set\",\n\t\t                config_options[SSL_CERTIFICATE].name);\n\t\treturn 0;\n\t}\n\n\tchain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];\n\tif (chain == NULL) {\n\t\tchain = pem;\n\t}\n\tif ((chain != NULL) && (*chain == 0)) {\n\t\tchain = NULL;\n\t}\n\n\tif (!initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\tmg_cry_internal(fc(phys_ctx), \"%s\", ebuf);\n\t\treturn 0;\n\t}\n\n\treturn init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);\n}\n\n\nstatic void\nuninitialize_ssl(void)\n{\n#if defined(OPENSSL_API_1_1)\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCONF_modules_unload(1);\n#else\n\tint i;\n\n\tif (mg_atomic_dec(&cryptolib_users) == 0) {\n\n\t\t/* Shutdown according to\n\t\t * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup\n\t\t * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl\n\t\t */\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tENGINE_cleanup();\n\t\tCONF_modules_unload(1);\n\t\tERR_free_strings();\n\t\tEVP_cleanup();\n\t\tCRYPTO_cleanup_all_ex_data();\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++) {\n\t\t\tpthread_mutex_destroy(&ssl_mutexes[i]);\n\t\t}\n\t\tmg_free(ssl_mutexes);\n\t\tssl_mutexes = NULL;\n#endif /* OPENSSL_API_1_1 */\n\t}\n}\n#endif /* !NO_SSL */\n\n\nstatic int\nset_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx)\n{\n\tif (phys_ctx) {\n\t\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\t\tconst char *path;\n\t\tif (!dom_ctx) {\n\t\t\tdom_ctx = &(phys_ctx->dd);\n\t\t}\n\t\tpath = dom_ctx->config[GLOBAL_PASSWORDS_FILE];\n\t\tif ((path != NULL) && !mg_stat(fc(phys_ctx), path, &file.stat)) {\n\t\t\tmg_cry_internal(fc(phys_ctx),\n\t\t\t                \"Cannot open %s: %s\",\n\t\t\t                path,\n\t\t\t                strerror(ERRNO));\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nset_acl_option(struct mg_context *phys_ctx)\n{\n\treturn check_acl(phys_ctx, (uint32_t)0x7f000001UL) != -1;\n}\n\n\nstatic void\nreset_per_request_attributes(struct mg_connection *conn)\n{\n\tif (!conn) {\n\t\treturn;\n\t}\n\tconn->connection_type =\n\t    CONNECTION_TYPE_INVALID; /* Not yet a valid request/response */\n\n\tconn->num_bytes_sent = conn->consumed_content = 0;\n\n\tconn->path_info = NULL;\n\tconn->status_code = -1;\n\tconn->content_len = -1;\n\tconn->is_chunked = 0;\n\tconn->must_close = 0;\n\tconn->request_len = 0;\n\tconn->throttle = 0;\n\tconn->data_len = 0;\n\tconn->chunk_remainder = 0;\n\tconn->accept_gzip = 0;\n\n\tconn->response_info.content_length = conn->request_info.content_length = -1;\n\tconn->response_info.http_version = conn->request_info.http_version = NULL;\n\tconn->response_info.num_headers = conn->request_info.num_headers = 0;\n\tconn->response_info.status_text = NULL;\n\tconn->response_info.status_code = 0;\n\n\tconn->request_info.remote_user = NULL;\n\tconn->request_info.request_method = NULL;\n\tconn->request_info.request_uri = NULL;\n\tconn->request_info.local_uri = NULL;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* Legacy before split into local_uri and request_uri */\n\tconn->request_info.uri = NULL;\n#endif\n}\n\n\n#if 0\n/* Note: set_sock_timeout is not required for non-blocking sockets.\n * Leave this function here (commented out) for reference until\n * CivetWeb 1.9 is tested, and the tests confirme this function is\n * no longer required.\n*/\nstatic int\nset_sock_timeout(SOCKET sock, int milliseconds)\n{\n        int r0 = 0, r1, r2;\n\n#if defined(_WIN32)\n        /* Windows specific */\n\n        DWORD tv = (DWORD)milliseconds;\n\n#else\n        /* Linux, ... (not Windows) */\n\n        struct timeval tv;\n\n/* TCP_USER_TIMEOUT/RFC5482 (http://tools.ietf.org/html/rfc5482):\n * max. time waiting for the acknowledged of TCP data before the connection\n * will be forcefully closed and ETIMEDOUT is returned to the application.\n * If this option is not set, the default timeout of 20-30 minutes is used.\n*/\n/* #define TCP_USER_TIMEOUT (18) */\n\n#if defined(TCP_USER_TIMEOUT)\n        unsigned int uto = (unsigned int)milliseconds;\n        r0 = setsockopt(sock, 6, TCP_USER_TIMEOUT, (const void *)&uto, sizeof(uto));\n#endif\n\n        memset(&tv, 0, sizeof(tv));\n        tv.tv_sec = milliseconds / 1000;\n        tv.tv_usec = (milliseconds * 1000) % 1000000;\n\n#endif /* _WIN32 */\n\n        r1 = setsockopt(\n            sock, SOL_SOCKET, SO_RCVTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n        r2 = setsockopt(\n            sock, SOL_SOCKET, SO_SNDTIMEO, (SOCK_OPT_TYPE)&tv, sizeof(tv));\n\n        return r0 || r1 || r2;\n}\n#endif\n\n\nstatic int\nset_tcp_nodelay(SOCKET sock, int nodelay_on)\n{\n\tif (setsockopt(sock,\n\t               IPPROTO_TCP,\n\t               TCP_NODELAY,\n\t               (SOCK_OPT_TYPE)&nodelay_on,\n\t               sizeof(nodelay_on))\n\t    != 0) {\n\t\t/* Error */\n\t\treturn 1;\n\t}\n\t/* OK */\n\treturn 0;\n}\n\n\nstatic void\nclose_socket_gracefully(struct mg_connection *conn)\n{\n#if defined(_WIN32)\n\tchar buf[MG_BUF_LEN];\n\tint n;\n#endif\n\tstruct linger linger;\n\tint error_code = 0;\n\tint linger_timeout = -2;\n\tsocklen_t opt_len = sizeof(error_code);\n\n\tif (!conn) {\n\t\treturn;\n\t}\n\n\t/* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:\n\t * \"Note that enabling a nonzero timeout on a nonblocking socket\n\t * is not recommended.\", so set it to blocking now */\n\tset_blocking_mode(conn->client.sock);\n\n\t/* Send FIN to the client */\n\tshutdown(conn->client.sock, SHUTDOWN_WR);\n\n\n#if defined(_WIN32)\n\t/* Read and discard pending incoming data. If we do not do that and\n\t * close\n\t * the socket, the data in the send buffer may be discarded. This\n\t * behaviour is seen on Windows, when client keeps sending data\n\t * when server decides to close the connection; then when client\n\t * does recv() it gets no data back. */\n\tdo {\n\t\tn = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);\n\t} while (n > 0);\n#endif\n\n\tif (conn->dom_ctx->config[LINGER_TIMEOUT]) {\n\t\tlinger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);\n\t}\n\n\t/* Set linger option according to configuration */\n\tif (linger_timeout >= 0) {\n\t\t/* Set linger option to avoid socket hanging out after close. This\n\t\t * prevent ephemeral port exhaust problem under high QPS. */\n\t\tlinger.l_onoff = 1;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n\t\t/* Data type of linger structure elements may differ,\n\t\t * so we don't know what cast we need here.\n\t\t * Disable type conversion warnings. */\n\n\t\tlinger.l_linger = (linger_timeout + 999) / 1000;\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t} else {\n\t\tlinger.l_onoff = 0;\n\t\tlinger.l_linger = 0;\n\t}\n\n\tif (linger_timeout < -1) {\n\t\t/* Default: don't configure any linger */\n\t} else if (getsockopt(conn->client.sock,\n\t                      SOL_SOCKET,\n\t                      SO_ERROR,\n#if defined(_WIN32) /* WinSock uses different data type here */\n\t                      (char *)&error_code,\n#else\n\t                      &error_code,\n#endif\n\t                      &opt_len)\n\t           != 0) {\n\t\t/* Cannot determine if socket is already closed. This should\n\t\t * not occur and never did in a test. Log an error message\n\t\t * and continue. */\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t} else if (error_code == ECONNRESET) {\n\t\t/* Socket already closed by client/peer, close socket without linger\n\t\t */\n\t} else {\n\n\t\t/* Set linger timeout */\n\t\tif (setsockopt(conn->client.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_LINGER,\n\t\t               (char *)&linger,\n\t\t               sizeof(linger))\n\t\t    != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    conn,\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    linger.l_onoff,\n\t\t\t    linger.l_linger,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\t}\n\n\t/* Now we know that our FIN is ACK-ed, safe to close */\n\tclosesocket(conn->client.sock);\n\tconn->client.sock = INVALID_SOCKET;\n}\n\n\nstatic void\nclose_connection(struct mg_connection *conn)\n{\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 6; /* to close */\n#endif\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tif (conn->lua_websocket_state) {\n\t\tlua_websocket_close(conn, conn->lua_websocket_state);\n\t\tconn->lua_websocket_state = NULL;\n\t}\n#endif\n\n\tmg_lock_connection(conn);\n\n\t/* Set close flag, so keep-alive loops will stop */\n\tconn->must_close = 1;\n\n\t/* call the connection_close callback if assigned */\n\tif (conn->phys_ctx->callbacks.connection_close != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tconn->phys_ctx->callbacks.connection_close(conn);\n\t\t}\n\t}\n\n\t/* Reset user data, after close callback is called.\n\t * Do not reuse it. If the user needs a destructor,\n\t * it must be done in the connection_close callback. */\n\tmg_set_user_connection_data(conn, NULL);\n\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 7; /* closing */\n#endif\n\n#if !defined(NO_SSL)\n\tif (conn->ssl != NULL) {\n\t\t/* Run SSL_shutdown twice to ensure completely close SSL connection\n\t\t */\n\t\tSSL_shutdown(conn->ssl);\n\t\tSSL_free(conn->ssl);\n\t\tOPENSSL_REMOVE_THREAD_STATE();\n\t\tconn->ssl = NULL;\n\t}\n#endif\n\tif (conn->client.sock != INVALID_SOCKET) {\n\t\tclose_socket_gracefully(conn);\n\t\tconn->client.sock = INVALID_SOCKET;\n\t}\n\n\tif (conn->host) {\n\t\tmg_free((void *)conn->host);\n\t\tconn->host = NULL;\n\t}\n\n\tmg_unlock_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 8; /* closed */\n#endif\n}\n\n\nvoid\nmg_close_connection(struct mg_connection *conn)\n{\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *client_ctx = NULL;\n#endif /* defined(USE_WEBSOCKET) */\n\n\tif ((conn == NULL) || (conn->phys_ctx == NULL)) {\n\t\treturn;\n\t}\n\n#if defined(USE_WEBSOCKET)\n\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\tif (conn->in_websocket_handling) {\n\t\t\t/* Set close flag, so the server thread can exit. */\n\t\t\tconn->must_close = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {\n\n\t\tunsigned int i;\n\n\t\t/* ws/wss client */\n\t\tclient_ctx = conn->phys_ctx;\n\n\t\t/* client context: loops must end */\n\t\tclient_ctx->stop_flag = 1;\n\t\tconn->must_close = 1;\n\n\t\t/* We need to get the client thread out of the select/recv call\n\t\t * here. */\n\t\t/* Since we use a sleep quantum of some seconds to check for recv\n\t\t * timeouts, we will just wait a few seconds in mg_join_thread. */\n\n\t\t/* join worker thread */\n\t\tfor (i = 0; i < client_ctx->cfg_worker_threads; i++) {\n\t\t\tif (client_ctx->worker_threadids[i] != 0) {\n\t\t\t\tmg_join_thread(client_ctx->worker_threadids[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n\n\tclose_connection(conn);\n\n#if !defined(NO_SSL)\n\tif (conn->client_ssl_ctx != NULL) {\n\t\tSSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);\n\t}\n#endif\n\n#if defined(USE_WEBSOCKET)\n\tif (client_ctx != NULL) {\n\t\t/* free context */\n\t\tmg_free(client_ctx->worker_threadids);\n\t\tmg_free(client_ctx);\n\t\t(void)pthread_mutex_destroy(&conn->mutex);\n\t\tmg_free(conn);\n\t} else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {\n\t\tmg_free(conn);\n\t}\n#else\n\tif (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) { /* Client */\n\t\tmg_free(conn);\n\t}\n#endif /* defined(USE_WEBSOCKET) */\n}\n\n\n/* Only for memory statistics */\nstatic struct mg_context common_client_context;\n\n\nstatic struct mg_connection *\nmg_connect_client_impl(const struct mg_client_options *client_options,\n                       int use_ssl,\n                       char *ebuf,\n                       size_t ebuf_len)\n{\n\tstruct mg_connection *conn = NULL;\n\tSOCKET sock;\n\tunion usa sa;\n\tstruct sockaddr *psa;\n\tsocklen_t len;\n\n\tunsigned max_req_size =\n\t    (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);\n\n\t/* Size of structures, aligned to 8 bytes */\n\tsize_t conn_size = ((sizeof(struct mg_connection) + 7) >> 3) << 3;\n\tsize_t ctx_size = ((sizeof(struct mg_context) + 7) >> 3) << 3;\n\n\tconn = (struct mg_connection *)mg_calloc_ctx(\n\t    1, conn_size + ctx_size + max_req_size, &common_client_context);\n\n\tif (conn == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"calloc(): %s\",\n\t\t            strerror(ERRNO));\n\t\treturn NULL;\n\t}\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wcast-align\"\n#endif /* defined(GCC_DIAGNOSTIC) */\n\t/* conn_size is aligned to 8 bytes */\n\n\tconn->phys_ctx = (struct mg_context *)(((char *)conn) + conn_size);\n\n#if defined(GCC_DIAGNOSTIC)\n#pragma GCC diagnostic pop\n#endif /* defined(GCC_DIAGNOSTIC) */\n\n\tconn->buf = (((char *)conn) + conn_size + ctx_size);\n\tconn->buf_size = (int)max_req_size;\n\tconn->phys_ctx->context_type = CONTEXT_HTTP_CLIENT;\n\tconn->dom_ctx = &(conn->phys_ctx->dd);\n\n\tif (!connect_socket(&common_client_context,\n\t                    client_options->host,\n\t                    client_options->port,\n\t                    use_ssl,\n\t                    ebuf,\n\t                    ebuf_len,\n\t                    &sock,\n\t                    &sa)) {\n\t\t/* ebuf is set by connect_socket,\n\t\t * free all memory and return NULL; */\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n#if !defined(NO_SSL)\n#if defined(OPENSSL_API_1_1)\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#else\n\tif (use_ssl\n\t    && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))\n\t           == NULL) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"SSL_CTX_new error\");\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n#endif /* OPENSSL_API_1_1 */\n#endif /* NO_SSL */\n\n\n#if defined(USE_IPV6)\n\tlen = (sa.sa.sa_family == AF_INET) ? sizeof(conn->client.rsa.sin)\n\t                                   : sizeof(conn->client.rsa.sin6);\n\tpsa = (sa.sa.sa_family == AF_INET)\n\t          ? (struct sockaddr *)&(conn->client.rsa.sin)\n\t          : (struct sockaddr *)&(conn->client.rsa.sin6);\n#else\n\tlen = sizeof(conn->client.rsa.sin);\n\tpsa = (struct sockaddr *)&(conn->client.rsa.sin);\n#endif\n\n\tconn->client.sock = sock;\n\tconn->client.lsa = sa;\n\n\tif (getsockname(sock, psa, &len) != 0) {\n\t\tmg_cry_internal(conn,\n\t\t                \"%s: getsockname() failed: %s\",\n\t\t                __func__,\n\t\t                strerror(ERRNO));\n\t}\n\n\tconn->client.is_ssl = use_ssl ? 1 : 0;\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"Can not create mutex\");\n#if !defined(NO_SSL)\n\t\tSSL_CTX_free(conn->client_ssl_ctx);\n#endif\n\t\tclosesocket(sock);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\n#if !defined(NO_SSL)\n\tif (use_ssl) {\n\t\tcommon_client_context.dd.ssl_ctx = conn->client_ssl_ctx;\n\n\t\t/* TODO: Check ssl_verify_peer and ssl_ca_path here.\n\t\t * SSL_CTX_set_verify call is needed to switch off server\n\t\t * certificate checking, which is off by default in OpenSSL and\n\t\t * on in yaSSL. */\n\t\t/* TODO: SSL_CTX_set_verify(conn->client_ssl_ctx,\n\t\t * SSL_VERIFY_PEER, verify_ssl_server); */\n\n\t\tif (client_options->client_cert) {\n\t\t\tif (!ssl_use_pem_file(&common_client_context,\n\t\t\t                      &(common_client_context.dd),\n\t\t\t                      client_options->client_cert,\n\t\t\t                      NULL)) {\n\t\t\t\tmg_snprintf(NULL,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            ebuf_len,\n\t\t\t\t            \"Can not use SSL client certificate\");\n\t\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\t\tclosesocket(sock);\n\t\t\t\tmg_free(conn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (client_options->server_cert) {\n\t\t\tSSL_CTX_load_verify_locations(conn->client_ssl_ctx,\n\t\t\t                              client_options->server_cert,\n\t\t\t                              NULL);\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\n\t\tif (!sslize(conn,\n\t\t            conn->client_ssl_ctx,\n\t\t            SSL_connect,\n\t\t            &(conn->phys_ctx->stop_flag),\n\t\t            client_options)) {\n\t\t\tmg_snprintf(NULL,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"SSL connection error\");\n\t\t\tSSL_CTX_free(conn->client_ssl_ctx);\n\t\t\tclosesocket(sock);\n\t\t\tmg_free(conn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\tif (0 != set_non_blocking_mode(sock)) {\n\t\tmg_cry_internal(conn,\n\t\t                \"Cannot set non-blocking mode for client %s:%i\",\n\t\t                client_options->host,\n\t\t                client_options->port);\n\t}\n\n\treturn conn;\n}\n\n\nCIVETWEB_API struct mg_connection *\nmg_connect_client_secure(const struct mg_client_options *client_options,\n                         char *error_buffer,\n                         size_t error_buffer_size)\n{\n\treturn mg_connect_client_impl(client_options,\n\t                              1,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstruct mg_connection *\nmg_connect_client(const char *host,\n                  int port,\n                  int use_ssl,\n                  char *error_buffer,\n                  size_t error_buffer_size)\n{\n\tstruct mg_client_options opts;\n\tmemset(&opts, 0, sizeof(opts));\n\topts.host = host;\n\topts.port = port;\n\treturn mg_connect_client_impl(&opts,\n\t                              use_ssl,\n\t                              error_buffer,\n\t                              error_buffer_size);\n}\n\n\nstatic const struct {\n\tconst char *proto;\n\tsize_t proto_len;\n\tunsigned default_port;\n} abs_uri_protocols[] = {{\"http://\", 7, 80},\n                         {\"https://\", 8, 443},\n                         {\"ws://\", 5, 80},\n                         {\"wss://\", 6, 443},\n                         {NULL, 0, 0}};\n\n\n/* Check if the uri is valid.\n * return 0 for invalid uri,\n * return 1 for *,\n * return 2 for relative uri,\n * return 3 for absolute uri without port,\n * return 4 for absolute uri with port */\nstatic int\nget_uri_type(const char *uri)\n{\n\tint i;\n\tconst char *hostend, *portbegin;\n\tchar *portend;\n\tunsigned long port;\n\n\t/* According to the HTTP standard\n\t * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2\n\t * URI can be an asterisk (*) or should start with slash (relative uri),\n\t * or it should start with the protocol (absolute uri). */\n\tif ((uri[0] == '*') && (uri[1] == '\\0')) {\n\t\t/* asterisk */\n\t\treturn 1;\n\t}\n\n\t/* Valid URIs according to RFC 3986\n\t * (https://www.ietf.org/rfc/rfc3986.txt)\n\t * must only contain reserved characters :/?#[]@!$&'()*+,;=\n\t * and unreserved characters A-Z a-z 0-9 and -._~\n\t * and % encoded symbols.\n\t */\n\tfor (i = 0; uri[i] != 0; i++) {\n\t\tif (uri[i] < 33) {\n\t\t\t/* control characters and spaces are invalid */\n\t\t\treturn 0;\n\t\t}\n\t\tif (uri[i] > 126) {\n\t\t\t/* non-ascii characters must be % encoded */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tswitch (uri[i]) {\n\t\t\tcase '\"':  /* 34 */\n\t\t\tcase '<':  /* 60 */\n\t\t\tcase '>':  /* 62 */\n\t\t\tcase '\\\\': /* 92 */\n\t\t\tcase '^':  /* 94 */\n\t\t\tcase '`':  /* 96 */\n\t\t\tcase '{':  /* 123 */\n\t\t\tcase '|':  /* 124 */\n\t\t\tcase '}':  /* 125 */\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\t/* character is ok */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* A relative uri starts with a / character */\n\tif (uri[0] == '/') {\n\t\t/* relative uri */\n\t\treturn 2;\n\t}\n\n\t/* It could be an absolute uri: */\n\t/* This function only checks if the uri is valid, not if it is\n\t * addressing the current server. So civetweb can also be used\n\t * as a proxy server. */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len)\n\t\t    == 0) {\n\n\t\t\thostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');\n\t\t\tif (!portbegin) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\tif ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n/* Return NULL or the relative uri at the current server */\nstatic const char *\nget_rel_url_at_current_server(const char *uri, const struct mg_connection *conn)\n{\n\tconst char *server_domain;\n\tsize_t server_domain_len;\n\tsize_t request_domain_len = 0;\n\tunsigned long port = 0;\n\tint i, auth_domain_check_enabled;\n\tconst char *hostbegin = NULL;\n\tconst char *hostend = NULL;\n\tconst char *portbegin;\n\tchar *portend;\n\n\tauth_domain_check_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], \"yes\");\n\n\t/* DNS is case insensitive, so use case insensitive string compare here\n\t */\n\tfor (i = 0; abs_uri_protocols[i].proto != NULL; i++) {\n\t\tif (mg_strncasecmp(uri,\n\t\t                   abs_uri_protocols[i].proto,\n\t\t                   abs_uri_protocols[i].proto_len)\n\t\t    == 0) {\n\n\t\t\thostbegin = uri + abs_uri_protocols[i].proto_len;\n\t\t\thostend = strchr(hostbegin, '/');\n\t\t\tif (!hostend) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tportbegin = strchr(hostbegin, ':');\n\t\t\tif ((!portbegin) || (portbegin > hostend)) {\n\t\t\t\tport = abs_uri_protocols[i].default_port;\n\t\t\t\trequest_domain_len = (size_t)(hostend - hostbegin);\n\t\t\t} else {\n\t\t\t\tport = strtoul(portbegin + 1, &portend, 10);\n\t\t\t\tif ((portend != hostend) || (port <= 0)\n\t\t\t\t    || !is_valid_port(port)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\trequest_domain_len = (size_t)(portbegin - hostbegin);\n\t\t\t}\n\t\t\t/* protocol found, port set */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!port) {\n\t\t/* port remains 0 if the protocol is not found */\n\t\treturn 0;\n\t}\n\n/* Check if the request is directed to a different server. */\n/* First check if the port is the same (IPv4 and IPv6). */\n#if defined(USE_IPV6)\n\tif (conn->client.lsa.sa.sa_family == AF_INET6) {\n\t\tif (ntohs(conn->client.lsa.sin6.sin6_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tif (ntohs(conn->client.lsa.sin.sin_port) != port) {\n\t\t\t/* Request is directed to a different port */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Finally check if the server corresponds to the authentication\n\t * domain of the server (the server domain).\n\t * Allow full matches (like http://mydomain.com/path/file.ext), and\n\t * allow subdomain matches (like http://www.mydomain.com/path/file.ext),\n\t * but do not allow substrings (like\n\t * http://notmydomain.com/path/file.ext\n\t * or http://mydomain.com.fake/path/file.ext).\n\t */\n\tif (auth_domain_check_enabled) {\n\t\tserver_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];\n\t\tserver_domain_len = strlen(server_domain);\n\t\tif ((server_domain_len == 0) || (hostbegin == NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((request_domain_len == server_domain_len)\n\t\t    && (!memcmp(server_domain, hostbegin, server_domain_len))) {\n\t\t\t/* Request is directed to this server - full name match. */\n\t\t} else {\n\t\t\tif (request_domain_len < (server_domain_len + 2)) {\n\t\t\t\t/* Request is directed to another server: The server name\n\t\t\t\t * is longer than the request name.\n\t\t\t\t * Drop this case here to avoid overflows in the\n\t\t\t\t * following checks. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (hostbegin[request_domain_len - server_domain_len - 1] != '.') {\n\t\t\t\t/* Request is directed to another server: It could be a\n\t\t\t\t * substring\n\t\t\t\t * like notmyserver.com */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (0\n\t\t\t    != memcmp(server_domain,\n\t\t\t              hostbegin + request_domain_len - server_domain_len,\n\t\t\t              server_domain_len)) {\n\t\t\t\t/* Request is directed to another server:\n\t\t\t\t * The server name is different. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hostend;\n}\n\n\nstatic int\nget_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\t*err = 0;\n\n\treset_per_request_attributes(conn);\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Internal error\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\t/* Set the time the request was received. This value should be used for\n\t * timeouts. */\n\tclock_gettime(CLOCK_MONOTONIC, &(conn->req_time));\n\n\tconn->request_len =\n\t    read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);\n\tDEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);\n\tif ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Invalid message size\");\n\t\t*err = 500;\n\t\treturn 0;\n\t}\n\n\tif ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Message too large\");\n\t\t*err = 413;\n\t\treturn 0;\n\t}\n\n\tif (conn->request_len <= 0) {\n\t\tif (conn->data_len > 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Malformed message\");\n\t\t\t*err = 400;\n\t\t} else {\n\t\t\t/* Server did not recv anything -> just close the connection */\n\t\t\tconn->must_close = 1;\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"No data received\");\n\t\t\t*err = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic int\nget_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_request(conn->buf, conn->buf_size, &conn->request_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid request */\n\n\t/* Is there a \"host\" ? */\n\tconn->host = alloc_get_host(conn);\n\tif (!conn->host) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad request: Host mismatch\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->request_info.http_headers,\n\t                     conn->request_info.num_headers,\n\t                     \"Content-Length\"))\n\t    != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the request info. */\n\t\tconn->request_info.content_length = conn->content_len;\n\t} else if ((cl = get_header(conn->request_info.http_headers,\n\t                            conn->request_info.num_headers,\n\t                            \"Transfer-Encoding\"))\n\t               != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconst struct mg_http_method_info *meth =\n\t\t    get_http_method_info(conn->request_info.request_method);\n\t\tif (!meth) {\n\t\t\t/* No valid HTTP method */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\tif (meth->request_has_body) {\n\t\t\t/* POST or PUT request without content length set */\n\t\t\tconn->content_len = -1; /* unknown content length */\n\t\t} else {\n\t\t\t/* Other request */\n\t\t\tconn->content_len = 0; /* No content */\n\t\t}\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_REQUEST; /* Valid request */\n\treturn 1;\n}\n\n\n/* conn is assumed to be valid in this internal function */\nstatic int\nget_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)\n{\n\tconst char *cl;\n\tif (!get_message(conn, ebuf, ebuf_len, err)) {\n\t\treturn 0;\n\t}\n\n\tif (parse_http_response(conn->buf, conn->buf_size, &conn->response_info)\n\t    <= 0) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Bad response\");\n\t\t*err = 400;\n\t\treturn 0;\n\t}\n\n\t/* Message is a valid response */\n\n\t/* Do we know the content length? */\n\tif ((cl = get_header(conn->response_info.http_headers,\n\t                     conn->response_info.num_headers,\n\t                     \"Content-Length\"))\n\t    != NULL) {\n\t\t/* Request/response has content length set */\n\t\tchar *endptr = NULL;\n\t\tconn->content_len = strtoll(cl, &endptr, 10);\n\t\tif (endptr == cl) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Bad request\");\n\t\t\t*err = 411;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Publish the content length back to the response info. */\n\t\tconn->response_info.content_length = conn->content_len;\n\n\t\t/* TODO: check if it is still used in response_info */\n\t\tconn->request_info.content_length = conn->content_len;\n\n\t} else if ((cl = get_header(conn->response_info.http_headers,\n\t                            conn->response_info.num_headers,\n\t                            \"Transfer-Encoding\"))\n\t               != NULL\n\t           && !mg_strcasecmp(cl, \"chunked\")) {\n\t\tconn->is_chunked = 1;\n\t\tconn->content_len = -1; /* unknown content length */\n\t} else {\n\t\tconn->content_len = -1; /* unknown content length */\n\t}\n\n\tconn->connection_type = CONNECTION_TYPE_RESPONSE; /* Valid response */\n\treturn 1;\n}\n\n\nint\nmg_get_response(struct mg_connection *conn,\n                char *ebuf,\n                size_t ebuf_len,\n                int timeout)\n{\n\tint err, ret;\n\tchar txt[32]; /* will not overflow */\n\tchar *save_timeout;\n\tchar *new_timeout;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tif (!conn) {\n\t\tmg_snprintf(conn,\n\t\t            NULL, /* No truncation check for ebuf */\n\t\t            ebuf,\n\t\t            ebuf_len,\n\t\t            \"%s\",\n\t\t            \"Parameter error\");\n\t\treturn -1;\n\t}\n\n\t/* Implementation of API function for HTTP clients */\n\tsave_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];\n\n\tif (timeout >= 0) {\n\t\tmg_snprintf(conn, NULL, txt, sizeof(txt), \"%i\", timeout);\n\t\tnew_timeout = txt;\n\t\t/* Not required for non-blocking sockets.\n\t\tset_sock_timeout(conn->client.sock, timeout);\n\t\t*/\n\t} else {\n\t\tnew_timeout = NULL;\n\t}\n\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;\n\tret = get_response(conn, ebuf, ebuf_len, &err);\n\tconn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;\n\n#if defined(MG_LEGACY_INTERFACE)\n\t/* TODO: 1) uri is deprecated;\n\t *       2) here, ri.uri is the http response code */\n\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\tconn->request_info.local_uri = conn->request_info.request_uri;\n\n\t/* TODO (mid): Define proper return values - maybe return length?\n\t * For the first test use <0 for error and >0 for OK */\n\treturn (ret == 0) ? -1 : +1;\n}\n\n\nstruct mg_connection *\nmg_download(const char *host,\n            int port,\n            int use_ssl,\n            char *ebuf,\n            size_t ebuf_len,\n            const char *fmt,\n            ...)\n{\n\tstruct mg_connection *conn;\n\tva_list ap;\n\tint i;\n\tint reqerr;\n\n\tif (ebuf_len > 0) {\n\t\tebuf[0] = '\\0';\n\t}\n\n\tva_start(ap, fmt);\n\n\t/* open a connection */\n\tconn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);\n\n\tif (conn != NULL) {\n\t\ti = mg_vprintf(conn, fmt, ap);\n\t\tif (i <= 0) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            ebuf_len,\n\t\t\t            \"%s\",\n\t\t\t            \"Error sending request\");\n\t\t} else {\n\t\t\tget_response(conn, ebuf, ebuf_len, &reqerr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* TODO: 1) uri is deprecated;\n\t\t\t *       2) here, ri.uri is the http response code */\n\t\t\tconn->request_info.uri = conn->request_info.request_uri;\n#endif\n\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t}\n\t}\n\n\t/* if an error occurred, close the connection */\n\tif ((ebuf[0] != '\\0') && (conn != NULL)) {\n\t\tmg_close_connection(conn);\n\t\tconn = NULL;\n\t}\n\n\tva_end(ap);\n\treturn conn;\n}\n\n\nstruct websocket_client_thread_data {\n\tstruct mg_connection *conn;\n\tmg_websocket_data_handler data_handler;\n\tmg_websocket_close_handler close_handler;\n\tvoid *callback_data;\n};\n\n\n#if defined(USE_WEBSOCKET)\n#if defined(_WIN32)\nstatic unsigned __stdcall websocket_client_thread(void *data)\n#else\nstatic void *\nwebsocket_client_thread(void *data)\n#endif\n{\n\tstruct websocket_client_thread_data *cdata =\n\t    (struct websocket_client_thread_data *)data;\n\n#if !defined(_WIN32)\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n#endif\n\n\tmg_set_thread_name(\"ws-clnt\");\n\n\tif (cdata->conn->phys_ctx) {\n\t\tif (cdata->conn->phys_ctx->callbacks.init_thread) {\n\t\t\t/* 3 indicates a websocket client thread */\n\t\t\t/* TODO: check if conn->phys_ctx can be set */\n\t\t\tcdata->conn->phys_ctx->callbacks.init_thread(cdata->conn->phys_ctx,\n\t\t\t                                             3);\n\t\t}\n\t}\n\n\tread_websocket(cdata->conn, cdata->data_handler, cdata->callback_data);\n\n\tDEBUG_TRACE(\"%s\", \"Websocket client thread exited\\n\");\n\n\tif (cdata->close_handler != NULL) {\n\t\tcdata->close_handler(cdata->conn, cdata->callback_data);\n\t}\n\n\t/* The websocket_client context has only this thread. If it runs out,\n\t   set the stop_flag to 2 (= \"stopped\"). */\n\tcdata->conn->phys_ctx->stop_flag = 2;\n\n\tmg_free((void *)cdata);\n\n#if defined(_WIN32)\n\treturn 0;\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n\nstruct mg_connection *\nmg_connect_websocket_client(const char *host,\n                            int port,\n                            int use_ssl,\n                            char *error_buffer,\n                            size_t error_buffer_size,\n                            const char *path,\n                            const char *origin,\n                            mg_websocket_data_handler data_func,\n                            mg_websocket_close_handler close_func,\n                            void *user_data)\n{\n\tstruct mg_connection *conn = NULL;\n\n#if defined(USE_WEBSOCKET)\n\tstruct mg_context *newctx = NULL;\n\tstruct websocket_client_thread_data *thread_data;\n\tstatic const char *magic = \"x3JJHMbDL1EzLkh9GBhXDw==\";\n\tstatic const char *handshake_req;\n\n\tif (origin != NULL) {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"Origin: %s\\r\\n\"\n\t\t                \"\\r\\n\";\n\t} else {\n\t\thandshake_req = \"GET %s HTTP/1.1\\r\\n\"\n\t\t                \"Host: %s\\r\\n\"\n\t\t                \"Upgrade: websocket\\r\\n\"\n\t\t                \"Connection: Upgrade\\r\\n\"\n\t\t                \"Sec-WebSocket-Key: %s\\r\\n\"\n\t\t                \"Sec-WebSocket-Version: 13\\r\\n\"\n\t\t                \"\\r\\n\";\n\t}\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n#endif\n\n\t/* Establish the client connection and request upgrade */\n\tconn = mg_download(host,\n\t                   port,\n\t                   use_ssl,\n\t                   error_buffer,\n\t                   error_buffer_size,\n\t                   handshake_req,\n\t                   path,\n\t                   host,\n\t                   magic,\n\t                   origin);\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n\t/* Connection object will be null if something goes wrong */\n\tif (conn == NULL) {\n\t\tif (!*error_buffer) {\n\t\t\t/* There should be already an error message */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected error\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (conn->response_info.status_code != 101) {\n\t\t/* We sent an \"upgrade\" request. For a correct websocket\n\t\t * protocol handshake, we expect a \"101 Continue\" response.\n\t\t * Otherwise it is a protocol violation. Maybe the HTTP\n\t\t * Server does not know websockets. */\n\t\tif (!*error_buffer) {\n\t\t\t/* set an error, if not yet set */\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            error_buffer,\n\t\t\t            error_buffer_size,\n\t\t\t            \"Unexpected server reply\");\n\t\t}\n\n\t\tDEBUG_TRACE(\"Websocket client connect error: %s\\r\\n\", error_buffer);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\t/* For client connections, mg_context is fake. Since we need to set a\n\t * callback function, we need to create a copy and modify it. */\n\tnewctx = (struct mg_context *)mg_malloc(sizeof(struct mg_context));\n\tif (!newctx) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(newctx, conn->phys_ctx, sizeof(struct mg_context));\n\tnewctx->user_data = user_data;\n\tnewctx->context_type = CONTEXT_WS_CLIENT; /* ws/wss client context */\n\tnewctx->cfg_worker_threads = 1; /* one worker thread will be created */\n\tnewctx->worker_threadids =\n\t    (pthread_t *)mg_calloc_ctx(newctx->cfg_worker_threads,\n\t                               sizeof(pthread_t),\n\t                               newctx);\n\n\tconn->phys_ctx = newctx;\n\tconn->dom_ctx = &(newctx->dd);\n\n\tthread_data = (struct websocket_client_thread_data *)\n\t    mg_calloc_ctx(sizeof(struct websocket_client_thread_data), 1, newctx);\n\tif (!thread_data) {\n\t\tDEBUG_TRACE(\"%s\\r\\n\", \"Out of memory\");\n\t\tmg_free(newctx);\n\t\tmg_free(conn);\n\t\treturn NULL;\n\t}\n\n\tthread_data->conn = conn;\n\tthread_data->data_handler = data_func;\n\tthread_data->close_handler = close_func;\n\tthread_data->callback_data = user_data;\n\n\t/* Start a thread to read the websocket client connection\n\t * This thread will automatically stop when mg_disconnect is\n\t * called on the client connection */\n\tif (mg_start_thread_with_id(websocket_client_thread,\n\t                            (void *)thread_data,\n\t                            newctx->worker_threadids)\n\t    != 0) {\n\t\tmg_free((void *)thread_data);\n\t\tmg_free((void *)newctx->worker_threadids);\n\t\tmg_free((void *)newctx);\n\t\tmg_free((void *)conn);\n\t\tconn = NULL;\n\t\tDEBUG_TRACE(\"%s\",\n\t\t            \"Websocket client connect thread could not be started\\r\\n\");\n\t}\n\n#else\n\t/* Appease \"unused parameter\" warnings */\n\t(void)host;\n\t(void)port;\n\t(void)use_ssl;\n\t(void)error_buffer;\n\t(void)error_buffer_size;\n\t(void)path;\n\t(void)origin;\n\t(void)user_data;\n\t(void)data_func;\n\t(void)close_func;\n#endif\n\n\treturn conn;\n}\n\n\n/* Prepare connection data structure */\nstatic void\ninit_connection(struct mg_connection *conn)\n{\n\t/* Is keep alive allowed by the server */\n\tint keep_alive_enabled =\n\t    !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], \"yes\");\n\n\tif (!keep_alive_enabled) {\n\t\tconn->must_close = 1;\n\t}\n\n\t/* Important: on new connection, reset the receiving buffer. Credit\n\t * goes to crule42. */\n\tconn->data_len = 0;\n\tconn->handled_requests = 0;\n\tmg_set_user_connection_data(conn, NULL);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 2; /* init */\n#endif\n\n\t/* call the init_connection callback if assigned */\n\tif (conn->phys_ctx->callbacks.init_connection != NULL) {\n\t\tif (conn->phys_ctx->context_type == CONTEXT_SERVER) {\n\t\t\tvoid *conn_data = NULL;\n\t\t\tconn->phys_ctx->callbacks.init_connection(conn, &conn_data);\n\t\t\tmg_set_user_connection_data(conn, conn_data);\n\t\t}\n\t}\n}\n\n\n/* Process a connection - may handle multiple requests\n * using the same connection.\n * Must be called with a valid connection (conn  and\n * conn->phys_ctx must be valid).\n */\nstatic void\nprocess_new_connection(struct mg_connection *conn)\n{\n\tstruct mg_request_info *ri = &conn->request_info;\n\tint keep_alive, discard_len;\n\tchar ebuf[100];\n\tconst char *hostend;\n\tint reqerr, uri_type;\n\n#if defined(USE_SERVER_STATS)\n\tint mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));\n\tmg_atomic_add(&(conn->phys_ctx->total_connections), 1);\n\tif (mcon > (conn->phys_ctx->max_connections)) {\n\t\t/* could use atomic compare exchange, but this\n\t\t * seems overkill for statistics data */\n\t\tconn->phys_ctx->max_connections = mcon;\n\t}\n#endif\n\n\tinit_connection(conn);\n\n\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t            conn->request_info.remote_addr);\n\n\t/* Loop over multiple requests sent using the same connection\n\t * (while \"keep alive\"). */\n\tdo {\n\n\t\tDEBUG_TRACE(\"calling get_request (%i times for this connection)\",\n\t\t            conn->handled_requests + 1);\n\n#if defined(USE_SERVER_STATS)\n\t\tconn->conn_state = 3; /* ready */\n#endif\n\n\t\tif (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {\n\t\t\t/* The request sent by the client could not be understood by\n\t\t\t * the server, or it was incomplete or a timeout. Send an\n\t\t\t * error message and close the connection. */\n\t\t\tif (reqerr > 0) {\n\t\t\t\tDEBUG_ASSERT(ebuf[0] != '\\0');\n\t\t\t\tmg_send_http_error(conn, reqerr, \"%s\", ebuf);\n\t\t\t}\n\t\t} else if (strcmp(ri->http_version, \"1.0\")\n\t\t           && strcmp(ri->http_version, \"1.1\")) {\n\t\t\tmg_snprintf(conn,\n\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t            ebuf,\n\t\t\t            sizeof(ebuf),\n\t\t\t            \"Bad HTTP version: [%s]\",\n\t\t\t            ri->http_version);\n\t\t\tmg_send_http_error(conn, 505, \"%s\", ebuf);\n\t\t}\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\turi_type = get_uri_type(conn->request_info.request_uri);\n\t\t\tswitch (uri_type) {\n\t\t\tcase 1:\n\t\t\t\t/* Asterisk */\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/* relative uri */\n\t\t\t\tconn->request_info.local_uri = conn->request_info.request_uri;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\t/* absolute uri (with/without port) */\n\t\t\t\thostend = get_rel_url_at_current_server(\n\t\t\t\t    conn->request_info.request_uri, conn);\n\t\t\t\tif (hostend) {\n\t\t\t\t\tconn->request_info.local_uri = hostend;\n\t\t\t\t} else {\n\t\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmg_snprintf(conn,\n\t\t\t\t            NULL, /* No truncation check for ebuf */\n\t\t\t\t            ebuf,\n\t\t\t\t            sizeof(ebuf),\n\t\t\t\t            \"Invalid URI\");\n\t\t\t\tmg_send_http_error(conn, 400, \"%s\", ebuf);\n\t\t\t\tconn->request_info.local_uri = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t\t/* Legacy before split into local_uri and request_uri */\n\t\t\tconn->request_info.uri = conn->request_info.local_uri;\n#endif\n\t\t}\n\n\t\tDEBUG_TRACE(\"http: %s, error: %s\",\n\t\t            (ri->http_version ? ri->http_version : \"none\"),\n\t\t            (ebuf[0] ? ebuf : \"none\"));\n\n\t\tif (ebuf[0] == '\\0') {\n\t\t\tif (conn->request_info.local_uri) {\n\n/* handle request to local server */\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 4; /* processing */\n#endif\n\t\t\t\thandle_request(conn);\n\n#if defined(USE_SERVER_STATS)\n\t\t\t\tconn->conn_state = 5; /* processed */\n\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_read),\n\t\t\t\t              conn->consumed_content);\n\t\t\t\tmg_atomic_add(&(conn->phys_ctx->total_data_written),\n\t\t\t\t              conn->num_bytes_sent);\n#endif\n\n\t\t\t\tDEBUG_TRACE(\"%s\", \"handle_request done\");\n\n\t\t\t\tif (conn->phys_ctx->callbacks.end_request != NULL) {\n\t\t\t\t\tconn->phys_ctx->callbacks.end_request(conn,\n\t\t\t\t\t                                      conn->status_code);\n\t\t\t\t\tDEBUG_TRACE(\"%s\", \"end_request callback done\");\n\t\t\t\t}\n\t\t\t\tlog_access(conn);\n\t\t\t} else {\n\t\t\t\t/* TODO: handle non-local request (PROXY) */\n\t\t\t\tconn->must_close = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tconn->must_close = 1;\n\t\t}\n\n\t\tif (ri->remote_user != NULL) {\n\t\t\tmg_free((void *)ri->remote_user);\n\t\t\t/* Important! When having connections with and without auth\n\t\t\t * would cause double free and then crash */\n\t\t\tri->remote_user = NULL;\n\t\t}\n\n\t\t/* NOTE(lsm): order is important here. should_keep_alive() call\n\t\t * is using parsed request, which will be invalid after\n\t\t * memmove's below.\n\t\t * Therefore, memorize should_keep_alive() result now for later\n\t\t * use in loop exit condition. */\n\t\tkeep_alive = (conn->phys_ctx->stop_flag == 0) && should_keep_alive(conn)\n\t\t             && (conn->content_len >= 0);\n\n\n\t\t/* Discard all buffered data for this request */\n\t\tdiscard_len = ((conn->content_len >= 0) && (conn->request_len > 0)\n\t\t               && ((conn->request_len + conn->content_len)\n\t\t                   < (int64_t)conn->data_len))\n\t\t                  ? (int)(conn->request_len + conn->content_len)\n\t\t                  : conn->data_len;\n\t\tDEBUG_ASSERT(discard_len >= 0);\n\t\tif (discard_len < 0) {\n\t\t\tDEBUG_TRACE(\"internal error: discard_len = %li\",\n\t\t\t            (long int)discard_len);\n\t\t\tbreak;\n\t\t}\n\t\tconn->data_len -= discard_len;\n\t\tif (conn->data_len > 0) {\n\t\t\tDEBUG_TRACE(\"discard_len = %lu\", (long unsigned)discard_len);\n\t\t\tmemmove(conn->buf, conn->buf + discard_len, (size_t)conn->data_len);\n\t\t}\n\n\t\tDEBUG_ASSERT(conn->data_len >= 0);\n\t\tDEBUG_ASSERT(conn->data_len <= conn->buf_size);\n\n\t\tif ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {\n\t\t\tDEBUG_TRACE(\"internal error: data_len = %li, buf_size = %li\",\n\t\t\t            (long int)conn->data_len,\n\t\t\t            (long int)conn->buf_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tconn->handled_requests++;\n\n\t} while (keep_alive);\n\n\tDEBUG_TRACE(\"Done processing connection from %s (%f sec)\",\n\t            conn->request_info.remote_addr,\n\t            difftime(time(NULL), conn->conn_birth_time));\n\n\tclose_connection(conn);\n\n#if defined(USE_SERVER_STATS)\n\tmg_atomic_add(&(conn->phys_ctx->total_requests), conn->handled_requests);\n\tmg_atomic_dec(&(conn->phys_ctx->active_connections));\n#endif\n}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n\tunsigned int i;\n\n\twhile (!ctx->stop_flag) {\n\t\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\t\t/* find a free worker slot and signal it */\n\t\t\tif (ctx->client_socks[i].in_use == 0) {\n\t\t\t\tctx->client_socks[i] = *sp;\n\t\t\t\tctx->client_socks[i].in_use = 1;\n\t\t\t\tevent_signal(ctx->client_wait_events[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* queue is full */\n\t\tmg_sleep(1);\n\t}\n}\n\n\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\tctx->client_socks[thread_index].in_use = 0;\n\tevent_wait(ctx->client_wait_events[thread_index]);\n\t*sp = ctx->client_socks[thread_index];\n\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\treturn !ctx->stop_flag;\n}\n\n#else /* ALTERNATIVE_QUEUE */\n\n/* Worker threads take accepted socket from the queue */\nstatic int\nconsume_socket(struct mg_context *ctx, struct socket *sp, int thread_index)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\n\t(void)thread_index;\n\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\tDEBUG_TRACE(\"%s\", \"going idle\");\n\n\t/* If the queue is empty, wait. We're idle at this point. */\n\twhile ((ctx->sq_head == ctx->sq_tail) && (ctx->stop_flag == 0)) {\n\t\tpthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);\n\t}\n\n\t/* If we're stopping, sq_head may be equal to sq_tail. */\n\tif (ctx->sq_head > ctx->sq_tail) {\n\t\t/* Copy socket from the queue and increment tail */\n\t\t*sp = ctx->queue[ctx->sq_tail % QUEUE_SIZE(ctx)];\n\t\tctx->sq_tail++;\n\n\t\tDEBUG_TRACE(\"grabbed socket %d, going busy\", sp ? sp->sock : -1);\n\n\t\t/* Wrap pointers if needed */\n\t\twhile (ctx->sq_tail > QUEUE_SIZE(ctx)) {\n\t\t\tctx->sq_tail -= QUEUE_SIZE(ctx);\n\t\t\tctx->sq_head -= QUEUE_SIZE(ctx);\n\t\t}\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_empty);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\treturn !ctx->stop_flag;\n#undef QUEUE_SIZE\n}\n\n\n/* Master thread adds accepted socket to a queue */\nstatic void\nproduce_socket(struct mg_context *ctx, const struct socket *sp)\n{\n#define QUEUE_SIZE(ctx) ((int)(ARRAY_SIZE(ctx->queue)))\n\tif (!ctx) {\n\t\treturn;\n\t}\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n\n\t/* If the queue is full, wait */\n\twhile ((ctx->stop_flag == 0)\n\t       && (ctx->sq_head - ctx->sq_tail >= QUEUE_SIZE(ctx))) {\n\t\t(void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);\n\t}\n\n\tif (ctx->sq_head - ctx->sq_tail < QUEUE_SIZE(ctx)) {\n\t\t/* Copy socket to the queue and increment head */\n\t\tctx->queue[ctx->sq_head % QUEUE_SIZE(ctx)] = *sp;\n\t\tctx->sq_head++;\n\t\tDEBUG_TRACE(\"queued socket %d\", sp ? sp->sock : -1);\n\t}\n\n\t(void)pthread_cond_signal(&ctx->sq_full);\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n#undef QUEUE_SIZE\n}\n#endif /* ALTERNATIVE_QUEUE */\n\n\nstruct worker_thread_args {\n\tstruct mg_context *ctx;\n\tint index;\n};\n\n\nstatic void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Internal error: Invalid worker index %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t                (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->phys_ctx = ctx;\n\tconn->dom_ctx = &(ctx->dd); /* Use default domain and default host */\n\tconn->host = NULL;          /* until we have more information. */\n\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\tif (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {\n\t\tmg_free(conn->buf);\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Cannot create mutex\");\n\t\treturn NULL;\n\t}\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n#if defined(ALTERNATIVE_QUEUE)\n\twhile ((ctx->stop_flag == 0)\n\t       && consume_socket(ctx, &conn->client, conn->thread_index)) {\n#else\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n#endif\n\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#if !defined(NO_SSL)\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->dom_ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->phys_ctx->stop_flag),\n\t\t\t           NULL)) {\n\t\t\t\t/* conn->dom_ctx is set in get_request */\n\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\t/* Free certificate memory */\n\t\t\t\t\tX509_free(\n\t\t\t\t\t    (X509 *)conn->request_info.client_cert->peer_cert);\n\t\t\t\t\tconn->request_info.client_cert->peer_cert = 0;\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* make sure the connection is cleaned up on SSL failure */\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall worker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nworker_thread(void *thread_func_param)\n{\n\tstruct worker_thread_args *pwta =\n\t    (struct worker_thread_args *)thread_func_param;\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tworker_thread_run(pwta);\n\tmg_free(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\n/* This is an internal function, thus all arguments are expected to be\n * valid - a NULL check is not required. */\nstatic void\naccept_new_connection(const struct socket *listener, struct mg_context *ctx)\n{\n\tstruct socket so;\n\tchar src_addr[IP_ADDR_STR_LEN];\n\tsocklen_t len = sizeof(so.rsa);\n\tint on = 1;\n\n\tif ((so.sock = accept(listener->sock, &so.rsa.sa, &len))\n\t    == INVALID_SOCKET) {\n\t} else if (!check_acl(ctx, ntohl(*(uint32_t *)&so.rsa.sin.sin_addr))) {\n\t\tsockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s: %s is not allowed to connect\",\n\t\t                __func__,\n\t\t                src_addr);\n\t\tclosesocket(so.sock);\n\t} else {\n\t\t/* Put so socket structure into the queue */\n\t\tDEBUG_TRACE(\"Accepted socket %d\", (int)so.sock);\n\t\tset_close_on_exec(so.sock, fc(ctx));\n\t\tso.is_ssl = listener->is_ssl;\n\t\tso.ssl_redir = listener->ssl_redir;\n\t\tif (getsockname(so.sock, &so.lsa.sa, &len) != 0) {\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"%s: getsockname() failed: %s\",\n\t\t\t                __func__,\n\t\t\t                strerror(ERRNO));\n\t\t}\n\n\t\t/* Set TCP keep-alive. This is needed because if HTTP-level\n\t\t * keep-alive\n\t\t * is enabled, and client resets the connection, server won't get\n\t\t * TCP FIN or RST and will keep the connection open forever. With\n\t\t * TCP keep-alive, next keep-alive handshake will figure out that\n\t\t * the client is down and will close the server end.\n\t\t * Thanks to Igor Klopov who suggested the patch. */\n\t\tif (setsockopt(so.sock,\n\t\t               SOL_SOCKET,\n\t\t               SO_KEEPALIVE,\n\t\t               (SOCK_OPT_TYPE)&on,\n\t\t               sizeof(on))\n\t\t    != 0) {\n\t\t\tmg_cry_internal(\n\t\t\t    fc(ctx),\n\t\t\t    \"%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s\",\n\t\t\t    __func__,\n\t\t\t    strerror(ERRNO));\n\t\t}\n\n\t\t/* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced\n\t\t * to effectively fill up the underlying IP packet payload and\n\t\t * reduce the overhead of sending lots of small buffers. However\n\t\t * this hurts the server's throughput (ie. operations per second)\n\t\t * when HTTP 1.1 persistent connections are used and the responses\n\t\t * are relatively small (eg. less than 1400 bytes).\n\t\t */\n\t\tif ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL)\n\t\t    && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], \"1\"))) {\n\t\t\tif (set_tcp_nodelay(so.sock, 1) != 0) {\n\t\t\t\tmg_cry_internal(\n\t\t\t\t    fc(ctx),\n\t\t\t\t    \"%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s\",\n\t\t\t\t    __func__,\n\t\t\t\t    strerror(ERRNO));\n\t\t\t}\n\t\t}\n\n\t\t/* We are using non-blocking sockets. Thus, the\n\t\t * set_sock_timeout(so.sock, timeout);\n\t\t * call is no longer required. */\n\n\t\t/* The \"non blocking\" property should already be\n\t\t * inherited from the parent socket. Set it for\n\t\t * non-compliant socket implementations. */\n\t\tset_non_blocking_mode(so.sock);\n\n\t\tso.in_use = 0;\n\t\tproduce_socket(ctx, &so);\n\t}\n}\n\n\nstatic void\nmaster_thread_run(void *thread_func_param)\n{\n\tstruct mg_context *ctx = (struct mg_context *)thread_func_param;\n\tstruct mg_workerTLS tls;\n\tstruct pollfd *pfd;\n\tunsigned int i;\n\tunsigned int workerthreadcount;\n\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\tmg_set_thread_name(\"master\");\n\n/* Increase priority of the master thread */\n#if defined(_WIN32)\n\tSetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);\n#elif defined(USE_MASTER_THREAD_PRIORITY)\n\tint min_prio = sched_get_priority_min(SCHED_RR);\n\tint max_prio = sched_get_priority_max(SCHED_RR);\n\tif ((min_prio >= 0) && (max_prio >= 0)\n\t    && ((USE_MASTER_THREAD_PRIORITY) <= max_prio)\n\t    && ((USE_MASTER_THREAD_PRIORITY) >= min_prio)) {\n\t\tstruct sched_param sched_param = {0};\n\t\tsched_param.sched_priority = (USE_MASTER_THREAD_PRIORITY);\n\t\tpthread_setschedparam(pthread_self(), SCHED_RR, &sched_param);\n\t}\n#endif\n\n/* Initialize thread local storage */\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\ttls.is_master = 1;\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* Callback for the master thread (type 0) */\n\t\tctx->callbacks.init_thread(ctx, 0);\n\t}\n\n\t/* Server starts *now* */\n\tctx->start_time = time(NULL);\n\n\t/* Start the server */\n\tpfd = ctx->listening_socket_fds;\n\twhile (ctx->stop_flag == 0) {\n\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\tpfd[i].fd = ctx->listening_sockets[i].sock;\n\t\t\tpfd[i].events = POLLIN;\n\t\t}\n\n\t\tif (poll(pfd, ctx->num_listening_sockets, 200) > 0) {\n\t\t\tfor (i = 0; i < ctx->num_listening_sockets; i++) {\n\t\t\t\t/* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the\n\t\t\t\t * successful poll, and POLLIN is defined as\n\t\t\t\t * (POLLRDNORM | POLLRDBAND)\n\t\t\t\t * Therefore, we're checking pfd[i].revents & POLLIN, not\n\t\t\t\t * pfd[i].revents == POLLIN. */\n\t\t\t\tif ((ctx->stop_flag == 0) && (pfd[i].revents & POLLIN)) {\n\t\t\t\t\taccept_new_connection(&ctx->listening_sockets[i], ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Here stop_flag is 1 - Initiate shutdown. */\n\tDEBUG_TRACE(\"%s\", \"stopping workers\");\n\n\t/* Stop signal received: somebody called mg_stop. Quit. */\n\tclose_all_listening_sockets(ctx);\n\n\t/* Wakeup workers that are waiting for connections to handle. */\n\t(void)pthread_mutex_lock(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tevent_signal(ctx->client_wait_events[i]);\n\n\t\t/* Since we know all sockets, we can shutdown the connections. */\n\t\tif (ctx->client_socks[i].in_use) {\n\t\t\tshutdown(ctx->client_socks[i].sock, SHUTDOWN_BOTH);\n\t\t}\n\t}\n#else\n\tpthread_cond_broadcast(&ctx->sq_full);\n#endif\n\t(void)pthread_mutex_unlock(&ctx->thread_mutex);\n\n\t/* Join all worker threads to avoid leaking threads. */\n\tworkerthreadcount = ctx->cfg_worker_threads;\n\tfor (i = 0; i < workerthreadcount; i++) {\n\t\tif (ctx->worker_threadids[i] != 0) {\n\t\t\tmg_join_thread(ctx->worker_threadids[i]);\n\t\t}\n\t}\n\n#if defined(USE_LUA)\n\t/* Free Lua state of lua background task */\n\tif (ctx->lua_background_state) {\n\t\tlua_State *lstate = (lua_State *)ctx->lua_background_state;\n\t\tlua_getglobal(lstate, LUABACKGROUNDPARAMS);\n\t\tif (lua_istable(lstate, -1)) {\n\t\t\treg_boolean(lstate, \"shutdown\", 1);\n\t\t\tlua_pop(lstate, 1);\n\t\t\tmg_sleep(2);\n\t\t}\n\t\tlua_close(lstate);\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\n#if defined(_WIN32)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_setspecific(sTlsKey, NULL);\n\n\t/* Signal mg_stop() that we're done.\n\t * WARNING: This must be the very last thing this\n\t * thread does, as ctx becomes invalid after this line. */\n\tctx->stop_flag = 2;\n}\n\n\n/* Threads have different return types on Windows and Unix. */\n#if defined(_WIN32)\nstatic unsigned __stdcall master_thread(void *thread_func_param)\n{\n\tmaster_thread_run(thread_func_param);\n\treturn 0;\n}\n#else\nstatic void *\nmaster_thread(void *thread_func_param)\n{\n\tstruct sigaction sa;\n\n\t/* Ignore SIGPIPE */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_IGN;\n\tsigaction(SIGPIPE, &sa, NULL);\n\n\tmaster_thread_run(thread_func_param);\n\treturn NULL;\n}\n#endif /* _WIN32 */\n\n\nstatic void\nfree_context(struct mg_context *ctx)\n{\n\tint i;\n\tstruct mg_handler_info *tmp_rh;\n\n\tif (ctx == NULL) {\n\t\treturn;\n\t}\n\n\tif (ctx->callbacks.exit_context) {\n\t\tctx->callbacks.exit_context(ctx);\n\t}\n\n\t/* All threads exited, no sync is needed. Destroy thread mutex and\n\t * condvars\n\t */\n\t(void)pthread_mutex_destroy(&ctx->thread_mutex);\n#if defined(ALTERNATIVE_QUEUE)\n\tmg_free(ctx->client_socks);\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tevent_destroy(ctx->client_wait_events[i]);\n\t}\n\tmg_free(ctx->client_wait_events);\n#else\n\t(void)pthread_cond_destroy(&ctx->sq_empty);\n\t(void)pthread_cond_destroy(&ctx->sq_full);\n#endif\n\n\t/* Destroy other context global data structures mutex */\n\t(void)pthread_mutex_destroy(&ctx->nonce_mutex);\n\n#if defined(USE_TIMERS)\n\ttimers_exit(ctx);\n#endif\n\n\t/* Deallocate config parameters */\n\tfor (i = 0; i < NUM_OPTIONS; i++) {\n\t\tif (ctx->dd.config[i] != NULL) {\n#if defined(_MSC_VER)\n#pragma warning(suppress : 6001)\n#endif\n\t\t\tmg_free(ctx->dd.config[i]);\n\t\t}\n\t}\n\n\t/* Deallocate request handlers */\n\twhile (ctx->dd.handlers) {\n\t\ttmp_rh = ctx->dd.handlers;\n\t\tctx->dd.handlers = tmp_rh->next;\n\t\tif (tmp_rh->handler_type == REQUEST_HANDLER) {\n\t\t\tpthread_cond_destroy(&tmp_rh->refcount_cond);\n\t\t\tpthread_mutex_destroy(&tmp_rh->refcount_mutex);\n\t\t}\n\t\tmg_free(tmp_rh->uri);\n\t\tmg_free(tmp_rh);\n\t}\n\n#if !defined(NO_SSL)\n\t/* Deallocate SSL context */\n\tif (ctx->dd.ssl_ctx != NULL) {\n\t\tvoid *ssl_ctx = (void *)ctx->dd.ssl_ctx;\n\t\tint callback_ret =\n\t\t    (ctx->callbacks.external_ssl_ctx == NULL)\n\t\t        ? 0\n\t\t        : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));\n\n\t\tif (callback_ret == 0) {\n\t\t\tSSL_CTX_free(ctx->dd.ssl_ctx);\n\t\t}\n\t\t/* else: ignore error and ommit SSL_CTX_free in case\n\t\t * callback_ret is 1 */\n\t}\n#endif /* !NO_SSL */\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_threadids != NULL) {\n\t\tmg_free(ctx->worker_threadids);\n\t}\n\n\t/* Deallocate worker thread ID array */\n\tif (ctx->worker_connections != NULL) {\n\t\tmg_free(ctx->worker_connections);\n\t}\n\n\t/* deallocate system name string */\n\tmg_free(ctx->systemName);\n\n\t/* Deallocate context itself */\n\tmg_free(ctx);\n}\n\n\nvoid\nmg_stop(struct mg_context *ctx)\n{\n\tpthread_t mt;\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\t/* We don't use a lock here. Calling mg_stop with the same ctx from\n\t * two threads is not allowed. */\n\tmt = ctx->masterthreadid;\n\tif (mt == 0) {\n\t\treturn;\n\t}\n\n\tctx->masterthreadid = 0;\n\n\t/* Set stop flag, so all threads know they have to exit. */\n\tctx->stop_flag = 1;\n\n\t/* Wait until everything has stopped. */\n\twhile (ctx->stop_flag != 2) {\n\t\t(void)mg_sleep(10);\n\t}\n\n\tmg_join_thread(mt);\n\tfree_context(ctx);\n\n#if defined(_WIN32)\n\t(void)WSACleanup();\n#endif /* _WIN32 */\n}\n\n\nstatic void\nget_system_name(char **sysName)\n{\n#if defined(_WIN32)\n#if !defined(__SYMBIAN32__)\n#if defined(_WIN32_WCE)\n\t*sysName = mg_strdup(\"WinCE\");\n#else\n\tchar name[128];\n\tDWORD dwVersion = 0;\n\tDWORD dwMajorVersion = 0;\n\tDWORD dwMinorVersion = 0;\n\tDWORD dwBuild = 0;\n\tBOOL wowRet, isWoW = FALSE;\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\tdwBuild = ((dwVersion < 0x80000000) ? (DWORD)(HIWORD(dwVersion)) : 0);\n\t(void)dwBuild;\n\n\twowRet = IsWow64Process(GetCurrentProcess(), &isWoW);\n\n\tsprintf(name,\n\t        \"Windows %u.%u%s\",\n\t        (unsigned)dwMajorVersion,\n\t        (unsigned)dwMinorVersion,\n\t        (wowRet ? (isWoW ? \" (WoW64)\" : \"\") : \" (?)\"));\n\n\t*sysName = mg_strdup(name);\n#endif\n#else\n\t*sysName = mg_strdup(\"Symbian\");\n#endif\n#else\n\tstruct utsname name;\n\tmemset(&name, 0, sizeof(name));\n\tuname(&name);\n\t*sysName = mg_strdup(name.sysname);\n#endif\n}\n\n\nstruct mg_context *\nmg_start(const struct mg_callbacks *callbacks,\n         void *user_data,\n         const char **options)\n{\n\tstruct mg_context *ctx;\n\tconst char *name, *value, *default_value;\n\tint idx, ok, workerthreadcount;\n\tunsigned int i;\n\tint itmp;\n\tvoid (*exit_callback)(const struct mg_context *ctx) = 0;\n\n\tstruct mg_workerTLS tls;\n\n#if defined(_WIN32)\n\tWSADATA data;\n\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32  */\n\n\t/* Allocate context and initialize reasonable general case defaults. */\n\tif ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* Random number generator will initialize at the first call */\n\tctx->dd.auth_nonce_mask =\n\t    (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);\n\n\tif (mg_init_library_called == 0) {\n\t\t/* Legacy INIT, if mg_start is called without mg_init_library.\n\t\t * Note: This may cause a memory leak */\n\t\tconst char *ports_option =\n\t\t    config_options[LISTENING_PORTS].default_value;\n\n\t\tif (options) {\n\t\t\tconst char **run_options = options;\n\t\t\tconst char *optname = config_options[LISTENING_PORTS].name;\n\n\t\t\t/* Try to find the \"listening_ports\" option */\n\t\t\twhile (*run_options) {\n\t\t\t\tif (!strcmp(*run_options, optname)) {\n\t\t\t\t\tports_option = run_options[1];\n\t\t\t\t}\n\t\t\t\trun_options += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (is_ssl_port_used(ports_option)) {\n\t\t\t/* Initialize with SSL support */\n\t\t\tmg_init_library(MG_FEATURES_TLS);\n\t\t} else {\n\t\t\t/* Initialize without SSL support */\n\t\t\tmg_init_library(MG_FEATURES_DEFAULT);\n\t\t}\n\t}\n\n\ttls.is_master = -1;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32)\n\ttls.pthread_cond_helper_mutex = NULL;\n#endif\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));\n#if !defined(ALTERNATIVE_QUEUE)\n\tok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));\n\tok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));\n#endif\n\tok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));\n\tif (!ok) {\n\t\t/* Fatal error - abort start. However, this situation should never\n\t\t * occur in practice. */\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Cannot initialize thread synchronization objects\");\n\t\tmg_free(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (callbacks) {\n\t\tctx->callbacks = *callbacks;\n\t\texit_callback = callbacks->exit_context;\n\t\tctx->callbacks.exit_context = 0;\n\t}\n\tctx->user_data = user_data;\n\tctx->dd.handlers = NULL;\n\tctx->dd.next = NULL;\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tctx->dd.shared_lua_websockets = NULL;\n#endif\n\n\t/* Store options */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ctx->dd.config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(ctx->dd.config[idx]);\n\t\t}\n\t\tctx->dd.config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Set default value if needed */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = config_options[i].default_value;\n\t\tif ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {\n\t\t\tctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\t/* Request size option */\n\titmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);\n\tif (itmp < 1024) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"max_request_size too small\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->max_request_size = (unsigned)itmp;\n\n\t/* Worker thread count option */\n\tworkerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);\n\n\tif (workerthreadcount > MAX_WORKER_THREADS) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Too many worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tif (workerthreadcount <= 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Invalid number of worker threads\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n/* Document root */\n#if defined(NO_FILES)\n\tif (ctx->dd.config[DOCUMENT_ROOT] != NULL) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Document root must not be set\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\tget_system_name(&ctx->systemName);\n\n#if defined(USE_LUA)\n\t/* If a Lua background script has been configured, start it. */\n\tif (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {\n\t\tchar ebuf[256];\n\t\tstruct vec opt_vec;\n\t\tstruct vec eq_vec;\n\t\tconst char *sparams;\n\t\tlua_State *state = mg_prepare_lua_context_script(\n\t\t    ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));\n\t\tif (!state) {\n\t\t\tmg_cry_internal(fc(ctx), \"lua_background_script error: %s\", ebuf);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\tctx->lua_background_state = (void *)state;\n\n\t\tlua_newtable(state);\n\t\treg_boolean(state, \"shutdown\", 0);\n\n\t\tsparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];\n\n\t\twhile ((sparams = next_option(sparams, &opt_vec, &eq_vec)) != NULL) {\n\t\t\treg_llstring(\n\t\t\t    state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);\n\t\t\tif (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlua_setglobal(state, LUABACKGROUNDPARAMS);\n\n\t} else {\n\t\tctx->lua_background_state = 0;\n\t}\n#endif\n\n\t/* NOTE(lsm): order is important here. SSL certificates must\n\t * be initialized before listening ports. UID must be set last. */\n\tif (!set_gpass_option(ctx, NULL) ||\n#if !defined(NO_SSL)\n\t    !init_ssl_ctx(ctx, NULL) ||\n#endif\n\t    !set_ports_option(ctx) ||\n#if !defined(_WIN32)\n\t    !set_uid_option(ctx) ||\n#endif\n\t    !set_acl_option(ctx)) {\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));\n\tctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                                   sizeof(pthread_t),\n\t                                                   ctx);\n\n\tif (ctx->worker_threadids == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread ID array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\tctx->worker_connections =\n\t    (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,\n\t                                          sizeof(struct mg_connection),\n\t                                          ctx);\n\tif (ctx->worker_connections == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker thread connection array\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\n#if defined(ALTERNATIVE_QUEUE)\n\tctx->client_wait_events =\n\t    (void **)mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),\n\t                           ctx->cfg_worker_threads,\n\t                           ctx);\n\tif (ctx->client_wait_events == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker event array\");\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tctx->client_socks =\n\t    (struct socket *)mg_calloc_ctx(sizeof(ctx->client_socks[0]),\n\t                                   ctx->cfg_worker_threads,\n\t                                   ctx);\n\tif (ctx->client_socks == NULL) {\n\t\tmg_cry_internal(fc(ctx),\n\t\t                \"%s\",\n\t\t                \"Not enough memory for worker socket array\");\n\t\tmg_free(ctx->client_wait_events);\n\t\tmg_free(ctx->worker_threadids);\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {\n\t\tctx->client_wait_events[i] = event_create();\n\t\tif (ctx->client_wait_events[i] == 0) {\n\t\t\tmg_cry_internal(fc(ctx), \"Error creating worker event %i\", i);\n\t\t\twhile (i > 0) {\n\t\t\t\ti--;\n\t\t\t\tevent_destroy(ctx->client_wait_events[i]);\n\t\t\t}\n\t\t\tmg_free(ctx->client_socks);\n\t\t\tmg_free(ctx->client_wait_events);\n\t\t\tmg_free(ctx->worker_threadids);\n\t\t\tfree_context(ctx);\n\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\n#if defined(USE_TIMERS)\n\tif (timers_init(ctx) != 0) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"Error creating timers\");\n\t\tfree_context(ctx);\n\t\tpthread_setspecific(sTlsKey, NULL);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Context has been created - init user libraries */\n\tif (ctx->callbacks.init_context) {\n\t\tctx->callbacks.init_context(ctx);\n\t}\n\tctx->callbacks.exit_context = exit_callback;\n\tctx->context_type = CONTEXT_SERVER; /* server context */\n\n\t/* Start master (listening) thread */\n\tmg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);\n\n\t/* Start worker threads */\n\tfor (i = 0; i < ctx->cfg_worker_threads; i++) {\n\t\tstruct worker_thread_args *wta = (struct worker_thread_args *)\n\t\t    mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);\n\t\tif (wta) {\n\t\t\twta->ctx = ctx;\n\t\t\twta->index = (int)i;\n\t\t}\n\n\t\tif ((wta == NULL)\n\t\t    || (mg_start_thread_with_id(worker_thread,\n\t\t                                wta,\n\t\t                                &ctx->worker_threadids[i])\n\t\t        != 0)) {\n\n\t\t\t/* thread was not created */\n\t\t\tif (wta != NULL) {\n\t\t\t\tmg_free(wta);\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot start worker thread %i: error %ld\",\n\t\t\t\t                i + 1,\n\t\t\t\t                (long)ERRNO);\n\t\t\t} else {\n\t\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t\t                \"Cannot create threads: error %ld\",\n\t\t\t\t                (long)ERRNO);\n\t\t\t\tfree_context(ctx);\n\t\t\t\tpthread_setspecific(sTlsKey, NULL);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpthread_setspecific(sTlsKey, NULL);\n\treturn ctx;\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Add an additional domain to an already running web server. */\nint\nmg_start_domain(struct mg_context *ctx, const char **options)\n{\n\tconst char *name;\n\tconst char *value;\n\tconst char *default_value;\n\tstruct mg_domain_context *new_dom;\n\tstruct mg_domain_context *dom;\n\tint idx, i;\n\n\tif ((ctx == NULL) || (ctx->stop_flag != 0) || (options == NULL)) {\n\t\treturn -1;\n\t}\n\n\tnew_dom = (struct mg_domain_context *)\n\t    mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);\n\n\tif (!new_dom) {\n\t\t/* Out of memory */\n\t\treturn -6;\n\t}\n\n\t/* Store options - TODO: unite duplicate code */\n\twhile (options && (name = *options++) != NULL) {\n\t\tif ((idx = get_option_index(name)) == -1) {\n\t\t\tmg_cry_internal(fc(ctx), \"Invalid option: %s\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t} else if ((value = *options++) == NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"%s: option value cannot be NULL\", name);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -2;\n\t\t}\n\t\tif (new_dom->config[idx] != NULL) {\n\t\t\tmg_cry_internal(fc(ctx), \"warning: %s: duplicate option\", name);\n\t\t\tmg_free(new_dom->config[idx]);\n\t\t}\n\t\tnew_dom->config[idx] = mg_strdup_ctx(value, ctx);\n\t\tDEBUG_TRACE(\"[%s] -> [%s]\", name, value);\n\t}\n\n\t/* Authentication domain is mandatory */\n\t/* TODO: Maybe use a new option hostname? */\n\tif (!new_dom->config[AUTHENTICATION_DOMAIN]) {\n\t\tmg_cry_internal(fc(ctx), \"%s\", \"authentication domain required\");\n\t\tmg_free(new_dom);\n\t\treturn -4;\n\t}\n\n\t/* Set default value if needed. Take the config value from\n\t * ctx as a default value. */\n\tfor (i = 0; config_options[i].name != NULL; i++) {\n\t\tdefault_value = ctx->dd.config[i];\n\t\tif ((new_dom->config[i] == NULL) && (default_value != NULL)) {\n\t\t\tnew_dom->config[i] = mg_strdup_ctx(default_value, ctx);\n\t\t}\n\t}\n\n\tnew_dom->handlers = NULL;\n\tnew_dom->next = NULL;\n\tnew_dom->nonce_count = 0;\n\tnew_dom->auth_nonce_mask =\n\t    (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);\n\n#if defined(USE_LUA) && defined(USE_WEBSOCKET)\n\tnew_dom->shared_lua_websockets = NULL;\n#endif\n\n\tif (!init_ssl_ctx(ctx, new_dom)) {\n\t\t/* Init SSL failed */\n\t\tmg_free(new_dom);\n\t\treturn -3;\n\t}\n\n\t/* Add element to linked list. */\n\tmg_lock_context(ctx);\n\n\tidx = 0;\n\tdom = &(ctx->dd);\n\tfor (;;) {\n\t\tif (!strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],\n\t\t                dom->config[AUTHENTICATION_DOMAIN])) {\n\t\t\t/* Domain collision */\n\t\t\tmg_cry_internal(fc(ctx),\n\t\t\t                \"domain %s already in use\",\n\t\t\t                new_dom->config[AUTHENTICATION_DOMAIN]);\n\t\t\tmg_free(new_dom);\n\t\t\treturn -5;\n\t\t}\n\n\t\t/* Count number of domains */\n\t\tidx++;\n\n\t\tif (dom->next == NULL) {\n\t\t\tdom->next = new_dom;\n\t\t\tbreak;\n\t\t}\n\t\tdom = dom->next;\n\t}\n\n\tmg_unlock_context(ctx);\n\n\t/* Return domain number */\n\treturn idx;\n}\n#endif\n\n\n/* Feature check API function */\nunsigned\nmg_check_feature(unsigned feature)\n{\n\tstatic const unsigned feature_set = 0\n/* Set bits for available features according to API documentation.\n * This bit mask is created at compile time, according to the active\n * preprocessor defines. It is a single const value at runtime. */\n#if !defined(NO_FILES)\n\t                                    | MG_FEATURES_FILES\n#endif\n#if !defined(NO_SSL)\n\t                                    | MG_FEATURES_SSL\n#endif\n#if !defined(NO_CGI)\n\t                                    | MG_FEATURES_CGI\n#endif\n#if defined(USE_IPV6)\n\t                                    | MG_FEATURES_IPV6\n#endif\n#if defined(USE_WEBSOCKET)\n\t                                    | MG_FEATURES_WEBSOCKET\n#endif\n#if defined(USE_LUA)\n\t                                    | MG_FEATURES_LUA\n#endif\n#if defined(USE_DUKTAPE)\n\t                                    | MG_FEATURES_SSJS\n#endif\n#if !defined(NO_CACHING)\n\t                                    | MG_FEATURES_CACHE\n#endif\n#if defined(USE_SERVER_STATS)\n\t                                    | MG_FEATURES_STATS\n#endif\n#if defined(USE_ZLIB)\n\t                                    | MG_FEATURES_COMPRESSION\n#endif\n\n/* Set some extra bits not defined in the API documentation.\n * These bits may change without further notice. */\n#if defined(MG_LEGACY_INTERFACE)\n\t                                    | 0x00008000u\n#endif\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n\t                                    | 0x00004000u\n#endif\n#if defined(MEMORY_DEBUGGING)\n\t                                    | 0x00001000u\n#endif\n#if defined(USE_TIMERS)\n\t                                    | 0x00020000u\n#endif\n#if !defined(NO_NONCE_CHECK)\n\t                                    | 0x00040000u\n#endif\n#if !defined(NO_POPEN)\n\t                                    | 0x00080000u\n#endif\n\t    ;\n\treturn (feature & feature_set);\n}\n\n\n/* strcat with additional NULL check to avoid clang scan-build warning. */\n#define strcat0(a, b)                                                          \\\n\t{                                                                          \\\n\t\tif ((a != NULL) && (b != NULL)) {                                      \\\n\t\t\tstrcat(a, b);                                                      \\\n\t\t}                                                                      \\\n\t}\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_system_info_impl(char *buffer, int buflen)\n{\n\tchar block[256];\n\tint system_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tsystem_info_length += (int)strlen(block);\n\tif (system_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Server version */\n\t{\n\t\tconst char *version = mg_version();\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"version\\\" : \\\"%s\\\",%s\",\n\t\t            version,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* System info */\n\t{\n#if defined(_WIN32)\n\t\tDWORD dwVersion = 0;\n\t\tDWORD dwMajorVersion = 0;\n\t\tDWORD dwMinorVersion = 0;\n\t\tSYSTEM_INFO si;\n\n\t\tGetSystemInfo(&si);\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n/* GetVersion was declared deprecated */\n#pragma warning(disable : 4996)\n#endif\n\t\tdwVersion = GetVersion();\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n\t\tdwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\t\tdwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"Windows %u.%u\\\",%s\",\n\t\t            (unsigned)dwMajorVersion,\n\t\t            (unsigned)dwMinorVersion,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"cpu\\\" : \\\"type %u, cores %u, mask %x\\\",%s\",\n\t\t            (unsigned)si.wProcessorArchitecture,\n\t\t            (unsigned)si.dwNumberOfProcessors,\n\t\t            (unsigned)si.dwActiveProcessorMask,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tstruct utsname name;\n\t\tmemset(&name, 0, sizeof(name));\n\t\tuname(&name);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"os\\\" : \\\"%s %s (%s) - %s\\\",%s\",\n\t\t            name.sysname,\n\t\t            name.version,\n\t\t            name.release,\n\t\t            name.machine,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Features */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"features\\\" : %lu,%s\"\n\t\t            \"\\\"feature_list\\\" : \\\"Server:%s%s%s%s%s%s%s%s%s\\\",%s\",\n\t\t            (unsigned long)mg_check_feature(0xFFFFFFFFu),\n\t\t            eol,\n\t\t            mg_check_feature(MG_FEATURES_FILES) ? \" Files\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSL) ? \" HTTPS\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CGI) ? \" CGI\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_IPV6) ? \" IPv6\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_WEBSOCKET) ? \" WebSockets\"\n\t\t                                                    : \"\",\n\t\t            mg_check_feature(MG_FEATURES_LUA) ? \" Lua\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_SSJS) ? \" JavaScript\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_CACHE) ? \" Cache\" : \"\",\n\t\t            mg_check_feature(MG_FEATURES_STATS) ? \" Stats\" : \"\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n#if defined(USE_LUA)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"lua_version\\\" : \\\"%u (%s)\\\",%s\",\n\t\t            (unsigned)LUA_VERSION_NUM,\n\t\t            LUA_RELEASE,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n#if defined(USE_DUKTAPE)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"javascript\\\" : \\\"Duktape %u.%u.%u\\\",%s\",\n\t\t            (unsigned)DUK_VERSION / 10000,\n\t\t            ((unsigned)DUK_VERSION / 100) % 100,\n\t\t            (unsigned)DUK_VERSION % 100,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Build date */\n\t{\n#if defined(GCC_DIAGNOSTIC)\n#if GCC_VERSION >= 50000\n#pragma GCC diagnostic push\n/* Disable bogus compiler warning -Wdate-time */\n#pragma GCC diagnostic ignored \"-Wdate-time\"\n#endif\n#endif\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"build\\\" : \\\"%s\\\",%s\",\n\t\t            __DATE__,\n\t\t            eol);\n\n#if defined(GCC_DIAGNOSTIC)\n#if GCC_VERSION >= 50000\n#pragma GCC diagnostic pop\n#endif\n#endif\n\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\n\t/* Compiler information */\n\t/* http://sourceforge.net/p/predef/wiki/Compilers/ */\n\t{\n#if defined(_MSC_VER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MSC: %u (%u)\\\",%s\",\n\t\t            (unsigned)_MSC_VER,\n\t\t            (unsigned)_MSC_FULL_VER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW64__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW64: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW64_VERSION_MAJOR,\n\t\t            (unsigned)__MINGW64_VERSION_MINOR,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__MINGW32__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"MinGW32: %u.%u\\\",%s\",\n\t\t            (unsigned)__MINGW32_MAJOR_VERSION,\n\t\t            (unsigned)__MINGW32_MINOR_VERSION,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__clang__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"clang: %u.%u.%u (%s)\\\",%s\",\n\t\t            __clang_major__,\n\t\t            __clang_minor__,\n\t\t            __clang_patchlevel__,\n\t\t            __clang_version__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__GNUC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"gcc: %u.%u.%u\\\",%s\",\n\t\t            (unsigned)__GNUC__,\n\t\t            (unsigned)__GNUC_MINOR__,\n\t\t            (unsigned)__GNUC_PATCHLEVEL__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__INTEL_COMPILER)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Intel C/C++: %u\\\",%s\",\n\t\t            (unsigned)__INTEL_COMPILER,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__BORLANDC__)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Borland C: 0x%x\\\",%s\",\n\t\t            (unsigned)__BORLANDC__,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#elif defined(__SUNPRO_C)\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"Solaris: 0x%x\\\",%s\",\n\t\t            (unsigned)__SUNPRO_C,\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#else\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"compiler\\\" : \\\"other\\\",%s\",\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n#endif\n\t}\n\n\t/* Determine 32/64 bit data mode.\n\t * see https://en.wikipedia.org/wiki/64-bit_computing */\n\t{\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data_model\\\" : \\\"int:%u/%u/%u/%u, float:%u/%u/%u, \"\n\t\t            \"char:%u/%u, \"\n\t\t            \"ptr:%u, size:%u, time:%u\\\"%s\",\n\t\t            (unsigned)sizeof(short),\n\t\t            (unsigned)sizeof(int),\n\t\t            (unsigned)sizeof(long),\n\t\t            (unsigned)sizeof(long long),\n\t\t            (unsigned)sizeof(float),\n\t\t            (unsigned)sizeof(double),\n\t\t            (unsigned)sizeof(long double),\n\t\t            (unsigned)sizeof(char),\n\t\t            (unsigned)sizeof(wchar_t),\n\t\t            (unsigned)sizeof(void *),\n\t\t            (unsigned)sizeof(size_t),\n\t\t            (unsigned)sizeof(time_t),\n\t\t            eol);\n\t\tsystem_info_length += (int)strlen(block);\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (system_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tsystem_info_length += reserved_len;\n\n\treturn system_info_length;\n}\n\n\n#if defined(USE_SERVER_STATS)\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_context_info_impl(const struct mg_context *ctx, char *buffer, int buflen)\n\n{\n\tchar block[256];\n\tint context_info_length = 0;\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\tstruct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tcontext_info_length += (int)strlen(block);\n\tif (context_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\tif (ms) { /* <-- should be always true */\n\t\t/* Memory information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"memory\\\" : {%s\"\n\t\t            \"\\\"blocks\\\" : %i,%s\"\n\t\t            \"\\\"used\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"maxUsed\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"}%s%s\",\n\t\t            eol,\n\t\t            ms->blockCount,\n\t\t            eol,\n\t\t            ms->totalMemUsed,\n\t\t            eol,\n\t\t            ms->maxMemUsed,\n\t\t            eol,\n\t\t            (ctx ? \",\" : \"\"),\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\tif (ctx) {\n\t\t/* Declare all variables at begin of the block, to comply\n\t\t * with old C standards. */\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = ctx->start_time;\n\t\ttime_t now = time(NULL);\n\n\t\t/* Connections information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connections\\\" : {%s\"\n\t\t            \"\\\"active\\\" : %i,%s\"\n\t\t            \"\\\"maxActive\\\" : %i,%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->active_connections,\n\t\t            eol,\n\t\t            ctx->max_connections,\n\t\t            eol,\n\t\t            ctx->total_connections,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Requests information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"requests\\\" : {%s\"\n\t\t            \"\\\"total\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Data information */\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \"%s,\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ctx->total_data_read,\n\t\t            eol,\n\t\t            ctx->total_data_written,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\n\t\t/* Execution time information */\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"}%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tcontext_info_length += (int)strlen(block);\n\t\tif (context_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (context_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tcontext_info_length += reserved_len;\n\n\treturn context_info_length;\n}\n#endif\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\n/* Get connection information. It can be printed or stored by the caller.\n * Return the size of available information. */\nstatic int\nmg_get_connection_info_impl(const struct mg_context *ctx,\n                            int idx,\n                            char *buffer,\n                            int buflen)\n{\n\tconst struct mg_connection *conn;\n\tconst struct mg_request_info *ri;\n\tchar block[256];\n\tint connection_info_length = 0;\n\tint state = 0;\n\tconst char *state_str = \"unknown\";\n\n#if defined(_WIN32)\n\tconst char *eol = \"\\r\\n\";\n#else\n\tconst char *eol = \"\\n\";\n#endif\n\n\tconst char *eoobj = \"}\";\n\tint reserved_len = (int)strlen(eoobj) + (int)strlen(eol);\n\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\tbuflen = 0;\n\t} else {\n\t\t*buffer = 0;\n\t}\n\n\tif ((ctx == NULL) || (idx < 0)) {\n\t\t/* Parameter error */\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)idx >= ctx->cfg_worker_threads) {\n\t\t/* Out of range */\n\t\treturn 0;\n\t}\n\n\t/* Take connection [idx]. This connection is not locked in\n\t * any way, so some other thread might use it. */\n\tconn = (ctx->worker_connections) + idx;\n\n\t/* Initialize output string */\n\tmg_snprintf(NULL, NULL, block, sizeof(block), \"{%s\", eol);\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Init variables */\n\tri = &(conn->request_info);\n\n#if defined(USE_SERVER_STATS)\n\tstate = conn->conn_state;\n\n\t/* State as string */\n\tswitch (state) {\n\tcase 0:\n\t\tstate_str = \"undefined\";\n\t\tbreak;\n\tcase 1:\n\t\tstate_str = \"not used\";\n\t\tbreak;\n\tcase 2:\n\t\tstate_str = \"init\";\n\t\tbreak;\n\tcase 3:\n\t\tstate_str = \"ready\";\n\t\tbreak;\n\tcase 4:\n\t\tstate_str = \"processing\";\n\t\tbreak;\n\tcase 5:\n\t\tstate_str = \"processed\";\n\t\tbreak;\n\tcase 6:\n\t\tstate_str = \"to close\";\n\t\tbreak;\n\tcase 7:\n\t\tstate_str = \"closing\";\n\t\tbreak;\n\tcase 8:\n\t\tstate_str = \"closed\";\n\t\tbreak;\n\tcase 9:\n\t\tstate_str = \"done\";\n\t\tbreak;\n\t}\n#endif\n\n\t/* Connection info */\n\tif ((state >= 3) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"connection\\\" : {%s\"\n\t\t            \"\\\"remote\\\" : {%s\"\n\t\t            \"\\\"protocol\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"addr\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"port\\\" : %u%s\"\n\t\t            \"},%s\"\n\t\t            \"\\\"handled_requests\\\" : %u%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            eol,\n\t\t            get_proto_name(conn),\n\t\t            eol,\n\t\t            ri->remote_addr,\n\t\t            eol,\n\t\t            ri->remote_port,\n\t\t            eol,\n\t\t            eol,\n\t\t            conn->handled_requests,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Request info */\n\tif ((state >= 4) && (state < 6)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"request_info\\\" : {%s\"\n\t\t            \"\\\"method\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"uri\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"query\\\" : %s%s%s%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->request_method,\n\t\t            eol,\n\t\t            ri->request_uri,\n\t\t            eol,\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            ri->query_string ? ri->query_string : \"null\",\n\t\t            ri->query_string ? \"\\\"\" : \"\",\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Execution time information */\n\tif ((state >= 2) && (state < 9)) {\n\t\tchar start_time_str[64] = {0};\n\t\tchar now_str[64] = {0};\n\t\ttime_t start_time = conn->conn_birth_time;\n\t\ttime_t now = time(NULL);\n\n\t\tgmt_time_string(start_time_str,\n\t\t                sizeof(start_time_str) - 1,\n\t\t                &start_time);\n\t\tgmt_time_string(now_str, sizeof(now_str) - 1, &now);\n\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"time\\\" : {%s\"\n\t\t            \"\\\"uptime\\\" : %.0f,%s\"\n\t\t            \"\\\"start\\\" : \\\"%s\\\",%s\"\n\t\t            \"\\\"now\\\" : \\\"%s\\\"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            difftime(now, start_time),\n\t\t            eol,\n\t\t            start_time_str,\n\t\t            eol,\n\t\t            now_str,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Remote user name */\n\tif ((ri->remote_user) && (state < 9)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"user\\\" : {%s\"\n\t\t            \"\\\"name\\\" : \\\"%s\\\",%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            ri->remote_user,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* Data block */\n\tif (state >= 3) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL,\n\t\t            block,\n\t\t            sizeof(block),\n\t\t            \"\\\"data\\\" : {%s\"\n\t\t            \"\\\"read\\\" : %\" INT64_FMT \",%s\"\n\t\t            \"\\\"written\\\" : %\" INT64_FMT \"%s\"\n\t\t            \"},%s\",\n\t\t            eol,\n\t\t            conn->consumed_content,\n\t\t            eol,\n\t\t            conn->num_bytes_sent,\n\t\t            eol,\n\t\t            eol);\n\n\t\tconnection_info_length += (int)strlen(block);\n\t\tif (connection_info_length + reserved_len < buflen) {\n\t\t\tstrcat0(buffer, block);\n\t\t}\n\t}\n\n\t/* State */\n\tmg_snprintf(NULL,\n\t            NULL,\n\t            block,\n\t            sizeof(block),\n\t            \"\\\"state\\\" : \\\"%s\\\"%s\",\n\t            state_str,\n\t            eol);\n\n\tconnection_info_length += (int)strlen(block);\n\tif (connection_info_length + reserved_len < buflen) {\n\t\tstrcat0(buffer, block);\n\t}\n\n\t/* Terminate string */\n\tif ((buflen > 0) && buffer && buffer[0]) {\n\t\tif (connection_info_length < buflen) {\n\t\t\tstrcat0(buffer, eoobj);\n\t\t\tstrcat0(buffer, eol);\n\t\t}\n\t}\n\tconnection_info_length += reserved_len;\n\n\treturn connection_info_length;\n}\n#endif\n\n\n/* Get system information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_system_info(char *buffer, int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_system_info_impl(NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_system_info_impl(buffer, buflen);\n\t}\n}\n\n\n/* Get context information. It can be printed or stored by the caller.\n * Return the size of available information. */\nint\nmg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen)\n{\n#if defined(USE_SERVER_STATS)\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_context_info_impl(ctx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_context_info_impl(ctx, buffer, buflen);\n\t}\n#else\n\t(void)ctx;\n\tif ((buffer != NULL) && (buflen > 0)) {\n\t\tbuffer[0] = 0;\n\t}\n\treturn 0;\n#endif\n}\n\n\n#if defined(MG_EXPERIMENTAL_INTERFACES)\nint\nmg_get_connection_info(const struct mg_context *ctx,\n                       int idx,\n                       char *buffer,\n                       int buflen)\n{\n\tif ((buffer == NULL) || (buflen < 1)) {\n\t\treturn mg_get_connection_info_impl(ctx, idx, NULL, 0);\n\t} else {\n\t\t/* Reset buffer, so we can always use strcat. */\n\t\tbuffer[0] = 0;\n\t\treturn mg_get_connection_info_impl(ctx, idx, buffer, buflen);\n\t}\n}\n#endif\n\n\n/* Initialize this library. This function does not need to be thread safe.\n */\nunsigned\nmg_init_library(unsigned features)\n{\n#if !defined(NO_SSL)\n\tchar ebuf[128];\n#endif\n\n\tunsigned features_to_init = mg_check_feature(features & 0xFFu);\n\tunsigned features_inited = features_to_init;\n\n\tif (mg_init_library_called <= 0) {\n\t\t/* Not initialized yet */\n\t\tif (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmg_global_lock();\n\n\tif (mg_init_library_called <= 0) {\n\t\tif (0 != pthread_key_create(&sTlsKey, tls_dtor)) {\n\t\t\t/* Fatal error - abort start. However, this situation should\n\t\t\t * never occur in practice. */\n\t\t\tmg_global_unlock();\n\t\t\treturn 0;\n\t\t}\n\n#if defined(_WIN32)\n\t\tInitializeCriticalSection(&global_log_file_lock);\n#endif\n#if !defined(_WIN32)\n\t\tpthread_mutexattr_init(&pthread_mutex_attr);\n\t\tpthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n#endif\n\n#if defined(USE_LUA)\n\t\tlua_init_optional_libraries();\n#endif\n\t}\n\n\tmg_global_unlock();\n\n#if !defined(NO_SSL)\n\tif (features_to_init & MG_FEATURES_SSL) {\n\t\tif (!mg_ssl_initialized) {\n\t\t\tif (initialize_ssl(ebuf, sizeof(ebuf))) {\n\t\t\t\tmg_ssl_initialized = 1;\n\t\t\t} else {\n\t\t\t\t(void)ebuf;\n\t\t\t\tDEBUG_TRACE(\"Initializing SSL failed: %s\", ebuf);\n\t\t\t\tfeatures_inited &= ~((unsigned)(MG_FEATURES_SSL));\n\t\t\t}\n\t\t} else {\n\t\t\t/* ssl already initialized */\n\t\t}\n\t}\n#endif\n\n\t/* Start WinSock for Windows */\n\tmg_global_lock();\n\tif (mg_init_library_called <= 0) {\n#if defined(_WIN32)\n\t\tWSADATA data;\n\t\tWSAStartup(MAKEWORD(2, 2), &data);\n#endif /* _WIN32 */\n\t\tmg_init_library_called = 1;\n\t} else {\n\t\tmg_init_library_called++;\n\t}\n\tmg_global_unlock();\n\n\treturn features_inited;\n}\n\n\n/* Un-initialize this library. */\nunsigned\nmg_exit_library(void)\n{\n\tif (mg_init_library_called <= 0) {\n\t\treturn 0;\n\t}\n\n\tmg_global_lock();\n\n\tmg_init_library_called--;\n\tif (mg_init_library_called == 0) {\n#if defined(_WIN32)\n\t\t(void)WSACleanup();\n#endif /* _WIN32  */\n#if !defined(NO_SSL)\n\t\tif (mg_ssl_initialized) {\n\t\t\tuninitialize_ssl();\n\t\t\tmg_ssl_initialized = 0;\n\t\t}\n#endif\n\n#if defined(_WIN32)\n\t\t(void)DeleteCriticalSection(&global_log_file_lock);\n#endif /* _WIN32 */\n#if !defined(_WIN32)\n\t\t(void)pthread_mutexattr_destroy(&pthread_mutex_attr);\n#endif\n\n\t\t(void)pthread_key_delete(sTlsKey);\n\n#if defined(USE_LUA)\n\t\tlua_exit_optional_libraries();\n#endif\n\n\t\tmg_global_unlock();\n\t\t(void)pthread_mutex_destroy(&global_lock_mutex);\n\t\treturn 1;\n\t}\n\n\tmg_global_unlock();\n\treturn 1;\n}\n\n\n/* End of civetweb.c */\n",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/glew/src/glew.c": "/*\n** The OpenGL Extension Wrangler Library\n** Copyright (C) 2002-2008, Milan Ikits <milan ikits[]ieee org>\n** Copyright (C) 2002-2008, Marcelo E. Magallon <mmagallo[]debian org>\n** Copyright (C) 2002, Lev Povalahev\n** All rights reserved.\n**\n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are met:\n**\n** * Redistributions of source code must retain the above copyright notice,\n**   this list of conditions and the following disclaimer.\n** * Redistributions in binary form must reproduce the above copyright notice,\n**   this list of conditions and the following disclaimer in the documentation\n**   and/or other materials provided with the distribution.\n** * The name of the author may be used to endorse or promote products\n**   derived from this software without specific prior written permission.\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n** ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n** LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n** INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n** CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n** THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* ROOT additions begin */\n#include \"RConfigure.h\"\n\n#define GLEW_BUILD\n\n#if defined(__APPLE__) && !defined(R__HAS_COCOA)\n#  define GLEW_APPLE_GLX\n#endif\n\n/* ROOT additions end */\n\n\n#include <GL/glew.h>\n\n#if defined(_WIN32)\n#  include <GL/wglew.h>\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n#  include <GL/glxew.h>\n#endif\n\n\n/*\n * Define glewGetContext and related helper macros.\n */\n#ifdef GLEW_MX\n#  define glewGetContext() ctx\n#  ifdef _WIN32\n#    define GLEW_CONTEXT_ARG_DEF_INIT GLEWContext* ctx\n#    define GLEW_CONTEXT_ARG_VAR_INIT ctx\n#    define wglewGetContext() ctx\n#    define WGLEW_CONTEXT_ARG_DEF_INIT WGLEWContext* ctx\n#    define WGLEW_CONTEXT_ARG_DEF_LIST WGLEWContext* ctx\n#  else /* _WIN32 */\n#    define GLEW_CONTEXT_ARG_DEF_INIT void\n#    define GLEW_CONTEXT_ARG_VAR_INIT\n#    define glxewGetContext() ctx\n#    define GLXEW_CONTEXT_ARG_DEF_INIT void\n#    define GLXEW_CONTEXT_ARG_DEF_LIST GLXEWContext* ctx\n#  endif /* _WIN32 */\n#  define GLEW_CONTEXT_ARG_DEF_LIST GLEWContext* ctx\n#else /* GLEW_MX */\n#  define GLEW_CONTEXT_ARG_DEF_INIT void\n#  define GLEW_CONTEXT_ARG_VAR_INIT\n#  define GLEW_CONTEXT_ARG_DEF_LIST void\n#  define WGLEW_CONTEXT_ARG_DEF_INIT void\n#  define WGLEW_CONTEXT_ARG_DEF_LIST void\n#  define GLXEW_CONTEXT_ARG_DEF_INIT void\n#  define GLXEW_CONTEXT_ARG_DEF_LIST void\n#endif /* GLEW_MX */\n\n#if defined(__APPLE__)\n#include <AvailabilityMacros.h>\n#if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)\n#define USE_APPLE_LEGACY_NSSYMBOL\n#include <mach-o/dyld.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid* NSGLGetProcAddress (const GLubyte *name)\n{\n  static const struct mach_header* image = NULL;\n  NSSymbol symbol;\n  char* symbolName;\n  if (NULL == image)\n  {\n    image = NSAddImage(\"/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL\", NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n  }\n  /* prepend a '_' for the Unix C symbol mangling convention */\n  symbolName = malloc(strlen((const char*)name) + 2);\n  strcpy(symbolName+1, (const char*)name);\n  symbolName[0] = '_';\n  symbol = NULL;\n  /* if (NSIsSymbolNameDefined(symbolName))\n   symbol = NSLookupAndBindSymbol(symbolName); */\n  symbol = image ? NSLookupSymbolInImage(image, symbolName, NSLOOKUPSYMBOLINIMAGE_OPTION_BIND | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR) : NULL;\n  free(symbolName);\n  return symbol ? NSAddressOfSymbol(symbol) : NULL;\n}\n#endif /* MAC_OS_X_VERSION_10_3 */\n#endif /* __APPLE__ */\n\n#if defined(__sgi) || defined (__sun) || (defined(__APPLE__) && !defined(USE_APPLE_LEGACY_NSSYMBOL))\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid* dlGetProcAddress (const GLubyte* name)\n{\n  static void* h = NULL;\n  static void* gpa;\n\n  if (h == NULL)\n  {\n    if ((h = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL)) == NULL) return NULL;\n    gpa = dlsym(h, \"glXGetProcAddress\");\n  }\n\n  if (gpa != NULL)\n    return ((void*(*)(const GLubyte*))gpa)(name);\n  else\n    return dlsym(h, (const char*)name);\n}\n#endif /* __sgi || __sun || __APPLE__ && !USE_APPLE_LEGACY_NSSYMBOL */\n\n/*\n * Define glewGetProcAddress.\n */\n#if defined(_WIN32)\n#  define glewGetProcAddress(name) wglGetProcAddress((LPCSTR)name)\n#else\n#  if defined(__APPLE__)\n#    if defined USE_APPLE_LEGACY_NSSYMBOL\n#      define glewGetProcAddress(name) NSGLGetProcAddress(name)\n#    else\n#      define glewGetProcAddress(name) dlGetProcAddress(name)\n#    endif\n#  else\n#    if defined(__sgi) || defined(__sun)\n#      define glewGetProcAddress(name) dlGetProcAddress(name)\n#    else /* __linux */\n#      define glewGetProcAddress(name) (*glXGetProcAddressARB)(name)\n#    endif\n#  endif\n#endif\n\n/*\n * Define GLboolean const cast.\n */\n#define CONST_CAST(x) (*(GLboolean*)&x)\n\n/*\n * GLEW, just like OpenGL or GLU, does not rely on the standard C library.\n * These functions implement the functionality required in this file.\n */\nstatic GLuint _glewStrLen (const GLubyte* s)\n{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0') i++;\n  return i;\n}\n\nstatic GLuint _glewStrCLen (const GLubyte* s, GLubyte c)\n{\n  GLuint i=0;\n  if (s == NULL) return 0;\n  while (s[i] != '\\0' && s[i] != c) i++;\n  return (s[i] == '\\0' || s[i] == c) ? i : 0;\n}\n\nstatic GLboolean _glewStrSame (const GLubyte* a, const GLubyte* b, GLuint n)\n{\n  GLuint i=0;\n  if(a == NULL || b == NULL)\n    return (a == NULL && b == NULL && n == 0) ? GL_TRUE : GL_FALSE;\n  while (i < n && a[i] != '\\0' && b[i] != '\\0' && a[i] == b[i]) i++;\n  return i == n ? GL_TRUE : GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame1 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  while (*na > 0 && (**a == ' ' || **a == '\\n' || **a == '\\r' || **a == '\\t'))\n  {\n    (*a)++;\n    (*na)--;\n  }\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n     if(i == nb)\n     {\n        *a = *a + nb;\n        *na = *na - nb;\n        return GL_TRUE;\n     }\n  }\n  return GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame2 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n     if(i == nb)\n     {\n        *a = *a + nb;\n        *na = *na - nb;\n        return GL_TRUE;\n     }\n  }\n  return GL_FALSE;\n}\n\nstatic GLboolean _glewStrSame3 (GLubyte** a, GLuint* na, const GLubyte* b, GLuint nb)\n{\n  if(*na >= nb)\n  {\n    GLuint i=0;\n    while (i < nb && (*a)+i != NULL && b+i != NULL && (*a)[i] == b[i]) i++;\n    if (i == nb && (*na == nb || (*a)[i] == ' ' || (*a)[i] == '\\n' || (*a)[i] == '\\r' || (*a)[i] == '\\t'))\n    {\n      *a = *a + nb;\n      *na = *na - nb;\n      return GL_TRUE;\n    }\n  }\n  return GL_FALSE;\n}\n\n#if !defined(_WIN32) || !defined(GLEW_MX)\n\nPFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D = NULL;\nPFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements = NULL;\nPFNGLTEXIMAGE3DPROC __glewTexImage3D = NULL;\nPFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D = NULL;\n\nPFNGLACTIVETEXTUREPROC __glewActiveTexture = NULL;\nPFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture = NULL;\nPFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D = NULL;\nPFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D = NULL;\nPFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D = NULL;\nPFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage = NULL;\nPFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd = NULL;\nPFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf = NULL;\nPFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd = NULL;\nPFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf = NULL;\nPFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d = NULL;\nPFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv = NULL;\nPFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f = NULL;\nPFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv = NULL;\nPFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i = NULL;\nPFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv = NULL;\nPFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s = NULL;\nPFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv = NULL;\nPFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d = NULL;\nPFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv = NULL;\nPFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f = NULL;\nPFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv = NULL;\nPFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i = NULL;\nPFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv = NULL;\nPFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s = NULL;\nPFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv = NULL;\nPFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d = NULL;\nPFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv = NULL;\nPFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f = NULL;\nPFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv = NULL;\nPFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i = NULL;\nPFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv = NULL;\nPFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s = NULL;\nPFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv = NULL;\nPFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d = NULL;\nPFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv = NULL;\nPFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f = NULL;\nPFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv = NULL;\nPFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i = NULL;\nPFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv = NULL;\nPFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s = NULL;\nPFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv = NULL;\nPFNGLSAMPLECOVERAGEPROC __glewSampleCoverage = NULL;\n\nPFNGLBLENDCOLORPROC __glewBlendColor = NULL;\nPFNGLBLENDEQUATIONPROC __glewBlendEquation = NULL;\nPFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate = NULL;\nPFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer = NULL;\nPFNGLFOGCOORDDPROC __glewFogCoordd = NULL;\nPFNGLFOGCOORDDVPROC __glewFogCoorddv = NULL;\nPFNGLFOGCOORDFPROC __glewFogCoordf = NULL;\nPFNGLFOGCOORDFVPROC __glewFogCoordfv = NULL;\nPFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays = NULL;\nPFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements = NULL;\nPFNGLPOINTPARAMETERFPROC __glewPointParameterf = NULL;\nPFNGLPOINTPARAMETERFVPROC __glewPointParameterfv = NULL;\nPFNGLPOINTPARAMETERIPROC __glewPointParameteri = NULL;\nPFNGLPOINTPARAMETERIVPROC __glewPointParameteriv = NULL;\nPFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b = NULL;\nPFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv = NULL;\nPFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d = NULL;\nPFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv = NULL;\nPFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f = NULL;\nPFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv = NULL;\nPFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i = NULL;\nPFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv = NULL;\nPFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s = NULL;\nPFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv = NULL;\nPFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub = NULL;\nPFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv = NULL;\nPFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui = NULL;\nPFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv = NULL;\nPFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us = NULL;\nPFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv = NULL;\nPFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer = NULL;\nPFNGLWINDOWPOS2DPROC __glewWindowPos2d = NULL;\nPFNGLWINDOWPOS2DVPROC __glewWindowPos2dv = NULL;\nPFNGLWINDOWPOS2FPROC __glewWindowPos2f = NULL;\nPFNGLWINDOWPOS2FVPROC __glewWindowPos2fv = NULL;\nPFNGLWINDOWPOS2IPROC __glewWindowPos2i = NULL;\nPFNGLWINDOWPOS2IVPROC __glewWindowPos2iv = NULL;\nPFNGLWINDOWPOS2SPROC __glewWindowPos2s = NULL;\nPFNGLWINDOWPOS2SVPROC __glewWindowPos2sv = NULL;\nPFNGLWINDOWPOS3DPROC __glewWindowPos3d = NULL;\nPFNGLWINDOWPOS3DVPROC __glewWindowPos3dv = NULL;\nPFNGLWINDOWPOS3FPROC __glewWindowPos3f = NULL;\nPFNGLWINDOWPOS3FVPROC __glewWindowPos3fv = NULL;\nPFNGLWINDOWPOS3IPROC __glewWindowPos3i = NULL;\nPFNGLWINDOWPOS3IVPROC __glewWindowPos3iv = NULL;\nPFNGLWINDOWPOS3SPROC __glewWindowPos3s = NULL;\nPFNGLWINDOWPOS3SVPROC __glewWindowPos3sv = NULL;\n\nPFNGLBEGINQUERYPROC __glewBeginQuery = NULL;\nPFNGLBINDBUFFERPROC __glewBindBuffer = NULL;\nPFNGLBUFFERDATAPROC __glewBufferData = NULL;\nPFNGLBUFFERSUBDATAPROC __glewBufferSubData = NULL;\nPFNGLDELETEBUFFERSPROC __glewDeleteBuffers = NULL;\nPFNGLDELETEQUERIESPROC __glewDeleteQueries = NULL;\nPFNGLENDQUERYPROC __glewEndQuery = NULL;\nPFNGLGENBUFFERSPROC __glewGenBuffers = NULL;\nPFNGLGENQUERIESPROC __glewGenQueries = NULL;\nPFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv = NULL;\nPFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv = NULL;\nPFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData = NULL;\nPFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv = NULL;\nPFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv = NULL;\nPFNGLGETQUERYIVPROC __glewGetQueryiv = NULL;\nPFNGLISBUFFERPROC __glewIsBuffer = NULL;\nPFNGLISQUERYPROC __glewIsQuery = NULL;\nPFNGLMAPBUFFERPROC __glewMapBuffer = NULL;\nPFNGLUNMAPBUFFERPROC __glewUnmapBuffer = NULL;\n\nPFNGLATTACHSHADERPROC __glewAttachShader = NULL;\nPFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation = NULL;\nPFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate = NULL;\nPFNGLCOMPILESHADERPROC __glewCompileShader = NULL;\nPFNGLCREATEPROGRAMPROC __glewCreateProgram = NULL;\nPFNGLCREATESHADERPROC __glewCreateShader = NULL;\nPFNGLDELETEPROGRAMPROC __glewDeleteProgram = NULL;\nPFNGLDELETESHADERPROC __glewDeleteShader = NULL;\nPFNGLDETACHSHADERPROC __glewDetachShader = NULL;\nPFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray = NULL;\nPFNGLDRAWBUFFERSPROC __glewDrawBuffers = NULL;\nPFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray = NULL;\nPFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib = NULL;\nPFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform = NULL;\nPFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders = NULL;\nPFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation = NULL;\nPFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog = NULL;\nPFNGLGETPROGRAMIVPROC __glewGetProgramiv = NULL;\nPFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog = NULL;\nPFNGLGETSHADERSOURCEPROC __glewGetShaderSource = NULL;\nPFNGLGETSHADERIVPROC __glewGetShaderiv = NULL;\nPFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation = NULL;\nPFNGLGETUNIFORMFVPROC __glewGetUniformfv = NULL;\nPFNGLGETUNIFORMIVPROC __glewGetUniformiv = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv = NULL;\nPFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv = NULL;\nPFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv = NULL;\nPFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv = NULL;\nPFNGLISPROGRAMPROC __glewIsProgram = NULL;\nPFNGLISSHADERPROC __glewIsShader = NULL;\nPFNGLLINKPROGRAMPROC __glewLinkProgram = NULL;\nPFNGLSHADERSOURCEPROC __glewShaderSource = NULL;\nPFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate = NULL;\nPFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate = NULL;\nPFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate = NULL;\nPFNGLUNIFORM1FPROC __glewUniform1f = NULL;\nPFNGLUNIFORM1FVPROC __glewUniform1fv = NULL;\nPFNGLUNIFORM1IPROC __glewUniform1i = NULL;\nPFNGLUNIFORM1IVPROC __glewUniform1iv = NULL;\nPFNGLUNIFORM2FPROC __glewUniform2f = NULL;\nPFNGLUNIFORM2FVPROC __glewUniform2fv = NULL;\nPFNGLUNIFORM2IPROC __glewUniform2i = NULL;\nPFNGLUNIFORM2IVPROC __glewUniform2iv = NULL;\nPFNGLUNIFORM3FPROC __glewUniform3f = NULL;\nPFNGLUNIFORM3FVPROC __glewUniform3fv = NULL;\nPFNGLUNIFORM3IPROC __glewUniform3i = NULL;\nPFNGLUNIFORM3IVPROC __glewUniform3iv = NULL;\nPFNGLUNIFORM4FPROC __glewUniform4f = NULL;\nPFNGLUNIFORM4FVPROC __glewUniform4fv = NULL;\nPFNGLUNIFORM4IPROC __glewUniform4i = NULL;\nPFNGLUNIFORM4IVPROC __glewUniform4iv = NULL;\nPFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv = NULL;\nPFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv = NULL;\nPFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv = NULL;\nPFNGLUSEPROGRAMPROC __glewUseProgram = NULL;\nPFNGLVALIDATEPROGRAMPROC __glewValidateProgram = NULL;\nPFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d = NULL;\nPFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv = NULL;\nPFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f = NULL;\nPFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv = NULL;\nPFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s = NULL;\nPFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv = NULL;\nPFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d = NULL;\nPFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv = NULL;\nPFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f = NULL;\nPFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv = NULL;\nPFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s = NULL;\nPFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv = NULL;\nPFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d = NULL;\nPFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv = NULL;\nPFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f = NULL;\nPFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv = NULL;\nPFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s = NULL;\nPFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv = NULL;\nPFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv = NULL;\nPFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv = NULL;\nPFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv = NULL;\nPFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub = NULL;\nPFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv = NULL;\nPFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv = NULL;\nPFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv = NULL;\nPFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv = NULL;\nPFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d = NULL;\nPFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv = NULL;\nPFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f = NULL;\nPFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv = NULL;\nPFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv = NULL;\nPFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s = NULL;\nPFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv = NULL;\nPFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv = NULL;\nPFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv = NULL;\nPFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv = NULL;\nPFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer = NULL;\n\nPFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv = NULL;\nPFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv = NULL;\nPFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv = NULL;\nPFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv = NULL;\nPFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv = NULL;\nPFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv = NULL;\n\nPFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender = NULL;\nPFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback = NULL;\nPFNGLBINDBUFFERBASEPROC __glewBindBufferBase = NULL;\nPFNGLBINDBUFFERRANGEPROC __glewBindBufferRange = NULL;\nPFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation = NULL;\nPFNGLCLAMPCOLORPROC __glewClampColor = NULL;\nPFNGLCLEARBUFFERFIPROC __glewClearBufferfi = NULL;\nPFNGLCLEARBUFFERFVPROC __glewClearBufferfv = NULL;\nPFNGLCLEARBUFFERIVPROC __glewClearBufferiv = NULL;\nPFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv = NULL;\nPFNGLCOLORMASKIPROC __glewColorMaski = NULL;\nPFNGLDISABLEIPROC __glewDisablei = NULL;\nPFNGLENABLEIPROC __glewEnablei = NULL;\nPFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender = NULL;\nPFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback = NULL;\nPFNGLGETBOOLEANI_VPROC __glewGetBooleani_v = NULL;\nPFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation = NULL;\nPFNGLGETINTEGERI_VPROC __glewGetIntegeri_v = NULL;\nPFNGLGETSTRINGIPROC __glewGetStringi = NULL;\nPFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv = NULL;\nPFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying = NULL;\nPFNGLGETUNIFORMUIVPROC __glewGetUniformuiv = NULL;\nPFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv = NULL;\nPFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv = NULL;\nPFNGLISENABLEDIPROC __glewIsEnabledi = NULL;\nPFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv = NULL;\nPFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings = NULL;\nPFNGLUNIFORM1UIPROC __glewUniform1ui = NULL;\nPFNGLUNIFORM1UIVPROC __glewUniform1uiv = NULL;\nPFNGLUNIFORM2UIPROC __glewUniform2ui = NULL;\nPFNGLUNIFORM2UIVPROC __glewUniform2uiv = NULL;\nPFNGLUNIFORM3UIPROC __glewUniform3ui = NULL;\nPFNGLUNIFORM3UIVPROC __glewUniform3uiv = NULL;\nPFNGLUNIFORM4UIPROC __glewUniform4ui = NULL;\nPFNGLUNIFORM4UIVPROC __glewUniform4uiv = NULL;\nPFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i = NULL;\nPFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv = NULL;\nPFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui = NULL;\nPFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv = NULL;\nPFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i = NULL;\nPFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv = NULL;\nPFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui = NULL;\nPFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv = NULL;\nPFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i = NULL;\nPFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv = NULL;\nPFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui = NULL;\nPFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv = NULL;\nPFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv = NULL;\nPFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i = NULL;\nPFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv = NULL;\nPFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv = NULL;\nPFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv = NULL;\nPFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui = NULL;\nPFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv = NULL;\nPFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv = NULL;\nPFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer = NULL;\n\nPFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX = NULL;\n\nPFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE = NULL;\nPFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE = NULL;\nPFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE = NULL;\nPFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE = NULL;\nPFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE = NULL;\n\nPFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE = NULL;\nPFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE = NULL;\nPFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE = NULL;\nPFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE = NULL;\nPFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE = NULL;\nPFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE = NULL;\nPFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE = NULL;\nPFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE = NULL;\n\nPFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE = NULL;\nPFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE = NULL;\n\nPFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE = NULL;\nPFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE = NULL;\n\nPFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE = NULL;\nPFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE = NULL;\nPFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE = NULL;\nPFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE = NULL;\n\nPFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE = NULL;\nPFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE = NULL;\nPFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE = NULL;\n\nPFNGLCLAMPCOLORARBPROC __glewClampColorARB = NULL;\n\nPFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB = NULL;\n\nPFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB = NULL;\nPFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB = NULL;\n\nPFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer = NULL;\nPFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer = NULL;\nPFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer = NULL;\nPFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus = NULL;\nPFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers = NULL;\nPFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers = NULL;\nPFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer = NULL;\nPFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D = NULL;\nPFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D = NULL;\nPFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D = NULL;\nPFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers = NULL;\nPFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers = NULL;\nPFNGLGENERATEMIPMAPPROC __glewGenerateMipmap = NULL;\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv = NULL;\nPFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv = NULL;\nPFNGLISFRAMEBUFFERPROC __glewIsFramebuffer = NULL;\nPFNGLISRENDERBUFFERPROC __glewIsRenderbuffer = NULL;\nPFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage = NULL;\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample = NULL;\n\nPFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB = NULL;\nPFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB = NULL;\nPFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB = NULL;\n\nPFNGLCOLORSUBTABLEPROC __glewColorSubTable = NULL;\nPFNGLCOLORTABLEPROC __glewColorTable = NULL;\nPFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv = NULL;\nPFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv = NULL;\nPFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D = NULL;\nPFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D = NULL;\nPFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf = NULL;\nPFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv = NULL;\nPFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri = NULL;\nPFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv = NULL;\nPFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable = NULL;\nPFNGLCOPYCOLORTABLEPROC __glewCopyColorTable = NULL;\nPFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D = NULL;\nPFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D = NULL;\nPFNGLGETCOLORTABLEPROC __glewGetColorTable = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv = NULL;\nPFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter = NULL;\nPFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv = NULL;\nPFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv = NULL;\nPFNGLGETHISTOGRAMPROC __glewGetHistogram = NULL;\nPFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv = NULL;\nPFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv = NULL;\nPFNGLGETMINMAXPROC __glewGetMinmax = NULL;\nPFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv = NULL;\nPFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv = NULL;\nPFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter = NULL;\nPFNGLHISTOGRAMPROC __glewHistogram = NULL;\nPFNGLMINMAXPROC __glewMinmax = NULL;\nPFNGLRESETHISTOGRAMPROC __glewResetHistogram = NULL;\nPFNGLRESETMINMAXPROC __glewResetMinmax = NULL;\nPFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D = NULL;\n\nPFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB = NULL;\n\nPFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange = NULL;\nPFNGLMAPBUFFERRANGEPROC __glewMapBufferRange = NULL;\n\nPFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB = NULL;\nPFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB = NULL;\nPFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB = NULL;\nPFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB = NULL;\nPFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB = NULL;\n\nPFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB = NULL;\n\nPFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB = NULL;\nPFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB = NULL;\nPFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB = NULL;\nPFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB = NULL;\nPFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB = NULL;\nPFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB = NULL;\nPFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB = NULL;\nPFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB = NULL;\nPFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB = NULL;\nPFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB = NULL;\nPFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB = NULL;\nPFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB = NULL;\nPFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB = NULL;\nPFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB = NULL;\nPFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB = NULL;\nPFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB = NULL;\nPFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB = NULL;\nPFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB = NULL;\nPFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB = NULL;\nPFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB = NULL;\nPFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB = NULL;\nPFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB = NULL;\nPFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB = NULL;\nPFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB = NULL;\nPFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB = NULL;\nPFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB = NULL;\nPFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB = NULL;\nPFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB = NULL;\nPFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB = NULL;\nPFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB = NULL;\nPFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB = NULL;\nPFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB = NULL;\nPFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB = NULL;\nPFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB = NULL;\n\nPFNGLBEGINQUERYARBPROC __glewBeginQueryARB = NULL;\nPFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB = NULL;\nPFNGLENDQUERYARBPROC __glewEndQueryARB = NULL;\nPFNGLGENQUERIESARBPROC __glewGenQueriesARB = NULL;\nPFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB = NULL;\nPFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB = NULL;\nPFNGLGETQUERYIVARBPROC __glewGetQueryivARB = NULL;\nPFNGLISQUERYARBPROC __glewIsQueryARB = NULL;\n\nPFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB = NULL;\nPFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB = NULL;\n\nPFNGLATTACHOBJECTARBPROC __glewAttachObjectARB = NULL;\nPFNGLCOMPILESHADERARBPROC __glewCompileShaderARB = NULL;\nPFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB = NULL;\nPFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB = NULL;\nPFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB = NULL;\nPFNGLDETACHOBJECTARBPROC __glewDetachObjectARB = NULL;\nPFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB = NULL;\nPFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB = NULL;\nPFNGLGETHANDLEARBPROC __glewGetHandleARB = NULL;\nPFNGLGETINFOLOGARBPROC __glewGetInfoLogARB = NULL;\nPFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB = NULL;\nPFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB = NULL;\nPFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB = NULL;\nPFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB = NULL;\nPFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB = NULL;\nPFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB = NULL;\nPFNGLLINKPROGRAMARBPROC __glewLinkProgramARB = NULL;\nPFNGLSHADERSOURCEARBPROC __glewShaderSourceARB = NULL;\nPFNGLUNIFORM1FARBPROC __glewUniform1fARB = NULL;\nPFNGLUNIFORM1FVARBPROC __glewUniform1fvARB = NULL;\nPFNGLUNIFORM1IARBPROC __glewUniform1iARB = NULL;\nPFNGLUNIFORM1IVARBPROC __glewUniform1ivARB = NULL;\nPFNGLUNIFORM2FARBPROC __glewUniform2fARB = NULL;\nPFNGLUNIFORM2FVARBPROC __glewUniform2fvARB = NULL;\nPFNGLUNIFORM2IARBPROC __glewUniform2iARB = NULL;\nPFNGLUNIFORM2IVARBPROC __glewUniform2ivARB = NULL;\nPFNGLUNIFORM3FARBPROC __glewUniform3fARB = NULL;\nPFNGLUNIFORM3FVARBPROC __glewUniform3fvARB = NULL;\nPFNGLUNIFORM3IARBPROC __glewUniform3iARB = NULL;\nPFNGLUNIFORM3IVARBPROC __glewUniform3ivARB = NULL;\nPFNGLUNIFORM4FARBPROC __glewUniform4fARB = NULL;\nPFNGLUNIFORM4FVARBPROC __glewUniform4fvARB = NULL;\nPFNGLUNIFORM4IARBPROC __glewUniform4iARB = NULL;\nPFNGLUNIFORM4IVARBPROC __glewUniform4ivARB = NULL;\nPFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB = NULL;\nPFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB = NULL;\nPFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB = NULL;\nPFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB = NULL;\nPFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB = NULL;\n\nPFNGLTEXBUFFERARBPROC __glewTexBufferARB = NULL;\n\nPFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB = NULL;\nPFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB = NULL;\nPFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB = NULL;\nPFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB = NULL;\nPFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB = NULL;\n\nPFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB = NULL;\nPFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB = NULL;\nPFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB = NULL;\nPFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB = NULL;\n\nPFNGLBINDVERTEXARRAYPROC __glewBindVertexArray = NULL;\nPFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays = NULL;\nPFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays = NULL;\nPFNGLISVERTEXARRAYPROC __glewIsVertexArray = NULL;\n\nPFNGLVERTEXBLENDARBPROC __glewVertexBlendARB = NULL;\nPFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB = NULL;\nPFNGLWEIGHTBVARBPROC __glewWeightbvARB = NULL;\nPFNGLWEIGHTDVARBPROC __glewWeightdvARB = NULL;\nPFNGLWEIGHTFVARBPROC __glewWeightfvARB = NULL;\nPFNGLWEIGHTIVARBPROC __glewWeightivARB = NULL;\nPFNGLWEIGHTSVARBPROC __glewWeightsvARB = NULL;\nPFNGLWEIGHTUBVARBPROC __glewWeightubvARB = NULL;\nPFNGLWEIGHTUIVARBPROC __glewWeightuivARB = NULL;\nPFNGLWEIGHTUSVARBPROC __glewWeightusvARB = NULL;\n\nPFNGLBINDBUFFERARBPROC __glewBindBufferARB = NULL;\nPFNGLBUFFERDATAARBPROC __glewBufferDataARB = NULL;\nPFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB = NULL;\nPFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB = NULL;\nPFNGLGENBUFFERSARBPROC __glewGenBuffersARB = NULL;\nPFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB = NULL;\nPFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB = NULL;\nPFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB = NULL;\nPFNGLISBUFFERARBPROC __glewIsBufferARB = NULL;\nPFNGLMAPBUFFERARBPROC __glewMapBufferARB = NULL;\nPFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB = NULL;\n\nPFNGLBINDPROGRAMARBPROC __glewBindProgramARB = NULL;\nPFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB = NULL;\nPFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB = NULL;\nPFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB = NULL;\nPFNGLGENPROGRAMSARBPROC __glewGenProgramsARB = NULL;\nPFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB = NULL;\nPFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB = NULL;\nPFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB = NULL;\nPFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB = NULL;\nPFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB = NULL;\nPFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB = NULL;\nPFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB = NULL;\nPFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB = NULL;\nPFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB = NULL;\nPFNGLISPROGRAMARBPROC __glewIsProgramARB = NULL;\nPFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB = NULL;\nPFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB = NULL;\nPFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB = NULL;\nPFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB = NULL;\nPFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB = NULL;\nPFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB = NULL;\nPFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB = NULL;\nPFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB = NULL;\nPFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB = NULL;\nPFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB = NULL;\nPFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB = NULL;\nPFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB = NULL;\nPFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB = NULL;\nPFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB = NULL;\nPFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB = NULL;\nPFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB = NULL;\nPFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB = NULL;\nPFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB = NULL;\nPFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB = NULL;\nPFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB = NULL;\nPFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB = NULL;\nPFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB = NULL;\nPFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB = NULL;\nPFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB = NULL;\nPFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB = NULL;\nPFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB = NULL;\nPFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB = NULL;\nPFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB = NULL;\nPFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB = NULL;\nPFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB = NULL;\nPFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB = NULL;\nPFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB = NULL;\nPFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB = NULL;\nPFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB = NULL;\nPFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB = NULL;\nPFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB = NULL;\nPFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB = NULL;\nPFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB = NULL;\nPFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB = NULL;\nPFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB = NULL;\nPFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB = NULL;\nPFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB = NULL;\nPFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB = NULL;\n\nPFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB = NULL;\nPFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB = NULL;\nPFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB = NULL;\n\nPFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB = NULL;\nPFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB = NULL;\nPFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB = NULL;\nPFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB = NULL;\nPFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB = NULL;\nPFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB = NULL;\nPFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB = NULL;\nPFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB = NULL;\nPFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB = NULL;\nPFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB = NULL;\nPFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB = NULL;\nPFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB = NULL;\nPFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB = NULL;\nPFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB = NULL;\nPFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB = NULL;\nPFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB = NULL;\n\nPFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI = NULL;\n\nPFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI = NULL;\nPFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI = NULL;\nPFNGLELEMENTPOINTERATIPROC __glewElementPointerATI = NULL;\n\nPFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI = NULL;\nPFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI = NULL;\nPFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI = NULL;\nPFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI = NULL;\n\nPFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI = NULL;\nPFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI = NULL;\nPFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI = NULL;\nPFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI = NULL;\nPFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI = NULL;\nPFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI = NULL;\nPFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI = NULL;\nPFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI = NULL;\nPFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI = NULL;\nPFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI = NULL;\nPFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI = NULL;\nPFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI = NULL;\nPFNGLSAMPLEMAPATIPROC __glewSampleMapATI = NULL;\nPFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI = NULL;\n\nPFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI = NULL;\nPFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI = NULL;\n\nPFNGLPNTRIANGLESFATIPROC __glPNTrianglewesfATI = NULL;\nPFNGLPNTRIANGLESIATIPROC __glPNTrianglewesiATI = NULL;\n\nPFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI = NULL;\nPFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI = NULL;\n\nPFNGLARRAYOBJECTATIPROC __glewArrayObjectATI = NULL;\nPFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI = NULL;\nPFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI = NULL;\nPFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI = NULL;\nPFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI = NULL;\nPFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI = NULL;\nPFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI = NULL;\nPFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI = NULL;\nPFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI = NULL;\nPFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI = NULL;\nPFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI = NULL;\nPFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI = NULL;\n\nPFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI = NULL;\nPFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI = NULL;\nPFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI = NULL;\n\nPFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI = NULL;\nPFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI = NULL;\nPFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI = NULL;\nPFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI = NULL;\nPFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI = NULL;\nPFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI = NULL;\nPFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI = NULL;\nPFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI = NULL;\nPFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI = NULL;\nPFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI = NULL;\nPFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI = NULL;\nPFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI = NULL;\nPFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI = NULL;\nPFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI = NULL;\nPFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI = NULL;\nPFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI = NULL;\nPFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI = NULL;\nPFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI = NULL;\nPFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI = NULL;\nPFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI = NULL;\nPFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI = NULL;\nPFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI = NULL;\nPFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI = NULL;\nPFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI = NULL;\nPFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI = NULL;\nPFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI = NULL;\nPFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI = NULL;\nPFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI = NULL;\nPFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI = NULL;\nPFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI = NULL;\nPFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI = NULL;\nPFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI = NULL;\nPFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI = NULL;\nPFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI = NULL;\nPFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI = NULL;\nPFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI = NULL;\nPFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI = NULL;\n\nPFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT = NULL;\nPFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT = NULL;\nPFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT = NULL;\n\nPFNGLBLENDCOLOREXTPROC __glewBlendColorEXT = NULL;\n\nPFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT = NULL;\n\nPFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT = NULL;\n\nPFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT = NULL;\n\nPFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT = NULL;\nPFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT = NULL;\n\nPFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT = NULL;\nPFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT = NULL;\n\nPFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT = NULL;\nPFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT = NULL;\nPFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT = NULL;\nPFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT = NULL;\nPFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT = NULL;\nPFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT = NULL;\nPFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT = NULL;\nPFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT = NULL;\nPFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT = NULL;\nPFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT = NULL;\n\nPFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT = NULL;\nPFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT = NULL;\n\nPFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT = NULL;\nPFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT = NULL;\nPFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT = NULL;\n\nPFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT = NULL;\nPFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT = NULL;\n\nPFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT = NULL;\n\nPFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT = NULL;\nPFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT = NULL;\nPFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT = NULL;\nPFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT = NULL;\nPFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT = NULL;\nPFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT = NULL;\nPFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT = NULL;\nPFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT = NULL;\nPFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT = NULL;\nPFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT = NULL;\nPFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT = NULL;\nPFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT = NULL;\nPFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT = NULL;\nPFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT = NULL;\nPFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT = NULL;\nPFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT = NULL;\nPFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT = NULL;\nPFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT = NULL;\nPFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT = NULL;\nPFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT = NULL;\nPFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT = NULL;\nPFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT = NULL;\nPFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT = NULL;\nPFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT = NULL;\nPFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT = NULL;\nPFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT = NULL;\nPFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT = NULL;\nPFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT = NULL;\nPFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT = NULL;\nPFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT = NULL;\nPFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT = NULL;\nPFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT = NULL;\nPFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT = NULL;\nPFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT = NULL;\nPFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT = NULL;\nPFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT = NULL;\nPFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT = NULL;\nPFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT = NULL;\nPFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT = NULL;\nPFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT = NULL;\nPFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT = NULL;\nPFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT = NULL;\nPFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT = NULL;\nPFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT = NULL;\nPFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT = NULL;\nPFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT = NULL;\nPFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT = NULL;\nPFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT = NULL;\nPFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT = NULL;\nPFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT = NULL;\nPFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT = NULL;\nPFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT = NULL;\nPFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT = NULL;\nPFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT = NULL;\nPFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT = NULL;\nPFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT = NULL;\nPFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT = NULL;\nPFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT = NULL;\nPFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT = NULL;\nPFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT = NULL;\nPFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT = NULL;\nPFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT = NULL;\nPFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT = NULL;\nPFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT = NULL;\nPFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT = NULL;\nPFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT = NULL;\nPFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT = NULL;\nPFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT = NULL;\nPFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT = NULL;\nPFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT = NULL;\nPFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT = NULL;\nPFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT = NULL;\nPFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT = NULL;\nPFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT = NULL;\nPFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT = NULL;\nPFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT = NULL;\nPFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT = NULL;\nPFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT = NULL;\nPFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT = NULL;\nPFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT = NULL;\nPFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT = NULL;\nPFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT = NULL;\nPFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT = NULL;\nPFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT = NULL;\nPFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT = NULL;\nPFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT = NULL;\nPFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT = NULL;\nPFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT = NULL;\nPFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT = NULL;\nPFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT = NULL;\nPFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT = NULL;\nPFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT = NULL;\nPFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT = NULL;\nPFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT = NULL;\nPFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT = NULL;\nPFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT = NULL;\nPFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT = NULL;\nPFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT = NULL;\nPFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT = NULL;\nPFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT = NULL;\nPFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT = NULL;\nPFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT = NULL;\nPFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT = NULL;\nPFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT = NULL;\nPFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT = NULL;\nPFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT = NULL;\nPFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT = NULL;\nPFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT = NULL;\nPFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT = NULL;\nPFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT = NULL;\nPFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT = NULL;\nPFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT = NULL;\nPFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT = NULL;\nPFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT = NULL;\nPFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT = NULL;\nPFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT = NULL;\nPFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT = NULL;\nPFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT = NULL;\nPFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT = NULL;\nPFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT = NULL;\nPFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT = NULL;\nPFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT = NULL;\nPFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT = NULL;\nPFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT = NULL;\nPFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT = NULL;\nPFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT = NULL;\nPFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT = NULL;\nPFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT = NULL;\nPFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT = NULL;\nPFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT = NULL;\nPFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT = NULL;\nPFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT = NULL;\nPFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT = NULL;\nPFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT = NULL;\nPFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT = NULL;\nPFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT = NULL;\nPFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT = NULL;\nPFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT = NULL;\nPFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT = NULL;\nPFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT = NULL;\n\nPFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT = NULL;\nPFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT = NULL;\nPFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT = NULL;\nPFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT = NULL;\nPFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT = NULL;\nPFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT = NULL;\n\nPFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT = NULL;\nPFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT = NULL;\n\nPFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT = NULL;\n\nPFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT = NULL;\nPFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT = NULL;\nPFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT = NULL;\nPFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT = NULL;\nPFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT = NULL;\n\nPFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT = NULL;\nPFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT = NULL;\nPFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT = NULL;\nPFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT = NULL;\nPFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT = NULL;\nPFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT = NULL;\nPFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT = NULL;\nPFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT = NULL;\nPFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT = NULL;\nPFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT = NULL;\nPFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT = NULL;\nPFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT = NULL;\nPFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT = NULL;\nPFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT = NULL;\nPFNGLLIGHTENVIEXTPROC __glewLightEnviEXT = NULL;\n\nPFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT = NULL;\n\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT = NULL;\n\nPFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT = NULL;\nPFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT = NULL;\nPFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT = NULL;\nPFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT = NULL;\nPFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT = NULL;\nPFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT = NULL;\nPFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT = NULL;\nPFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT = NULL;\nPFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT = NULL;\nPFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT = NULL;\nPFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT = NULL;\nPFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT = NULL;\nPFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT = NULL;\nPFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT = NULL;\n\nPFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT = NULL;\nPFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT = NULL;\nPFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT = NULL;\nPFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT = NULL;\n\nPFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT = NULL;\nPFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT = NULL;\n\nPFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT = NULL;\nPFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT = NULL;\nPFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT = NULL;\nPFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT = NULL;\nPFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT = NULL;\nPFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT = NULL;\nPFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT = NULL;\nPFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT = NULL;\nPFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT = NULL;\nPFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT = NULL;\nPFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT = NULL;\nPFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT = NULL;\nPFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT = NULL;\nPFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT = NULL;\nPFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT = NULL;\nPFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT = NULL;\nPFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT = NULL;\nPFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT = NULL;\nPFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT = NULL;\nPFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT = NULL;\nPFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT = NULL;\nPFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT = NULL;\nPFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT = NULL;\nPFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT = NULL;\nPFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT = NULL;\nPFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT = NULL;\nPFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT = NULL;\nPFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT = NULL;\nPFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT = NULL;\nPFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT = NULL;\nPFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT = NULL;\nPFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT = NULL;\nPFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT = NULL;\nPFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT = NULL;\n\nPFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT = NULL;\nPFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT = NULL;\nPFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT = NULL;\nPFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT = NULL;\nPFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT = NULL;\nPFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT = NULL;\nPFNGLHISTOGRAMEXTPROC __glewHistogramEXT = NULL;\nPFNGLMINMAXEXTPROC __glewMinmaxEXT = NULL;\nPFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT = NULL;\nPFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT = NULL;\n\nPFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT = NULL;\n\nPFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT = NULL;\n\nPFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT = NULL;\nPFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT = NULL;\nPFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT = NULL;\n\nPFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT = NULL;\nPFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT = NULL;\n\nPFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT = NULL;\nPFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT = NULL;\n\nPFNGLCOLORTABLEEXTPROC __glewColorTableEXT = NULL;\nPFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT = NULL;\n\nPFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT = NULL;\nPFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT = NULL;\nPFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT = NULL;\n\nPFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT = NULL;\nPFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT = NULL;\n\nPFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT = NULL;\n\nPFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT = NULL;\nPFNGLENDSCENEEXTPROC __glewEndSceneEXT = NULL;\n\nPFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT = NULL;\nPFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT = NULL;\nPFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT = NULL;\nPFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT = NULL;\nPFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT = NULL;\nPFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT = NULL;\nPFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT = NULL;\nPFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT = NULL;\nPFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT = NULL;\nPFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT = NULL;\nPFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT = NULL;\nPFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT = NULL;\nPFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT = NULL;\nPFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT = NULL;\nPFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT = NULL;\nPFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT = NULL;\nPFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT = NULL;\n\nPFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT = NULL;\n\nPFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT = NULL;\nPFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT = NULL;\nPFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT = NULL;\n\nPFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT = NULL;\n\nPFNGLTEXBUFFEREXTPROC __glewTexBufferEXT = NULL;\n\nPFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT = NULL;\nPFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT = NULL;\nPFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT = NULL;\nPFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT = NULL;\nPFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT = NULL;\nPFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT = NULL;\n\nPFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT = NULL;\nPFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT = NULL;\nPFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT = NULL;\nPFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT = NULL;\nPFNGLISTEXTUREEXTPROC __glewIsTextureEXT = NULL;\nPFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT = NULL;\n\nPFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT = NULL;\n\nPFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT = NULL;\nPFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT = NULL;\n\nPFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT = NULL;\nPFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT = NULL;\nPFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT = NULL;\nPFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT = NULL;\nPFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT = NULL;\n\nPFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT = NULL;\nPFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT = NULL;\nPFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT = NULL;\nPFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT = NULL;\nPFNGLGETPOINTERVEXTPROC __glewGetPointervEXT = NULL;\nPFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT = NULL;\nPFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT = NULL;\nPFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT = NULL;\nPFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT = NULL;\n\nPFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT = NULL;\nPFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT = NULL;\nPFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT = NULL;\nPFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT = NULL;\nPFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT = NULL;\nPFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT = NULL;\nPFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT = NULL;\nPFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT = NULL;\nPFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT = NULL;\nPFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT = NULL;\nPFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT = NULL;\nPFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT = NULL;\nPFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT = NULL;\nPFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT = NULL;\nPFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT = NULL;\nPFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT = NULL;\nPFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT = NULL;\nPFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT = NULL;\nPFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT = NULL;\nPFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT = NULL;\nPFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT = NULL;\nPFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT = NULL;\nPFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT = NULL;\nPFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT = NULL;\nPFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT = NULL;\nPFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT = NULL;\nPFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT = NULL;\nPFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT = NULL;\nPFNGLSHADEROP1EXTPROC __glewShaderOp1EXT = NULL;\nPFNGLSHADEROP2EXTPROC __glewShaderOp2EXT = NULL;\nPFNGLSHADEROP3EXTPROC __glewShaderOp3EXT = NULL;\nPFNGLSWIZZLEEXTPROC __glewSwizzleEXT = NULL;\nPFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT = NULL;\nPFNGLVARIANTBVEXTPROC __glewVariantbvEXT = NULL;\nPFNGLVARIANTDVEXTPROC __glewVariantdvEXT = NULL;\nPFNGLVARIANTFVEXTPROC __glewVariantfvEXT = NULL;\nPFNGLVARIANTIVEXTPROC __glewVariantivEXT = NULL;\nPFNGLVARIANTSVEXTPROC __glewVariantsvEXT = NULL;\nPFNGLVARIANTUBVEXTPROC __glewVariantubvEXT = NULL;\nPFNGLVARIANTUIVEXTPROC __glewVariantuivEXT = NULL;\nPFNGLVARIANTUSVEXTPROC __glewVariantusvEXT = NULL;\nPFNGLWRITEMASKEXTPROC __glewWriteMaskEXT = NULL;\n\nPFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT = NULL;\nPFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT = NULL;\nPFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT = NULL;\n\nPFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY = NULL;\n\nPFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY = NULL;\n\nPFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP = NULL;\nPFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP = NULL;\nPFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP = NULL;\n\nPFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM = NULL;\nPFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM = NULL;\n\nPFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM = NULL;\nPFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM = NULL;\nPFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM = NULL;\nPFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM = NULL;\nPFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM = NULL;\nPFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM = NULL;\nPFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM = NULL;\nPFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM = NULL;\n\nPFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL = NULL;\nPFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL = NULL;\nPFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL = NULL;\nPFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL = NULL;\n\nPFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL = NULL;\nPFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL = NULL;\n\nPFNGLBUFFERREGIONENABLEDEXTPROC __glewBufferRegionEnabledEXT = NULL;\nPFNGLDELETEBUFFERREGIONEXTPROC __glewDeleteBufferRegionEXT = NULL;\nPFNGLDRAWBUFFERREGIONEXTPROC __glewDrawBufferRegionEXT = NULL;\nPFNGLNEWBUFFERREGIONEXTPROC __glewNewBufferRegionEXT = NULL;\nPFNGLREADBUFFERREGIONEXTPROC __glewReadBufferRegionEXT = NULL;\n\nPFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA = NULL;\n\nPFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA = NULL;\nPFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA = NULL;\nPFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA = NULL;\nPFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA = NULL;\nPFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA = NULL;\nPFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA = NULL;\nPFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA = NULL;\nPFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA = NULL;\nPFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA = NULL;\nPFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA = NULL;\nPFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA = NULL;\nPFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA = NULL;\nPFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA = NULL;\nPFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA = NULL;\nPFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA = NULL;\nPFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA = NULL;\nPFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA = NULL;\nPFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA = NULL;\nPFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA = NULL;\nPFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA = NULL;\nPFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA = NULL;\nPFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA = NULL;\nPFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA = NULL;\nPFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA = NULL;\n\nPFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV = NULL;\nPFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV = NULL;\n\nPFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV = NULL;\nPFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV = NULL;\nPFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV = NULL;\n\nPFNGLEVALMAPSNVPROC __glewEvalMapsNV = NULL;\nPFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV = NULL;\nPFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV = NULL;\nPFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV = NULL;\nPFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV = NULL;\nPFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV = NULL;\nPFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV = NULL;\nPFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV = NULL;\nPFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV = NULL;\n\nPFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV = NULL;\nPFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV = NULL;\nPFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV = NULL;\n\nPFNGLDELETEFENCESNVPROC __glewDeleteFencesNV = NULL;\nPFNGLFINISHFENCENVPROC __glewFinishFenceNV = NULL;\nPFNGLGENFENCESNVPROC __glewGenFencesNV = NULL;\nPFNGLGETFENCEIVNVPROC __glewGetFenceivNV = NULL;\nPFNGLISFENCENVPROC __glewIsFenceNV = NULL;\nPFNGLSETFENCENVPROC __glewSetFenceNV = NULL;\nPFNGLTESTFENCENVPROC __glewTestFenceNV = NULL;\n\nPFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV = NULL;\nPFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV = NULL;\nPFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV = NULL;\n\nPFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV = NULL;\n\nPFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV = NULL;\n\nPFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV = NULL;\nPFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV = NULL;\nPFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV = NULL;\nPFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV = NULL;\nPFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV = NULL;\n\nPFNGLCOLOR3HNVPROC __glewColor3hNV = NULL;\nPFNGLCOLOR3HVNVPROC __glewColor3hvNV = NULL;\nPFNGLCOLOR4HNVPROC __glewColor4hNV = NULL;\nPFNGLCOLOR4HVNVPROC __glewColor4hvNV = NULL;\nPFNGLFOGCOORDHNVPROC __glewFogCoordhNV = NULL;\nPFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV = NULL;\nPFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV = NULL;\nPFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV = NULL;\nPFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV = NULL;\nPFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV = NULL;\nPFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV = NULL;\nPFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV = NULL;\nPFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV = NULL;\nPFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV = NULL;\nPFNGLNORMAL3HNVPROC __glewNormal3hNV = NULL;\nPFNGLNORMAL3HVNVPROC __glewNormal3hvNV = NULL;\nPFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV = NULL;\nPFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV = NULL;\nPFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV = NULL;\nPFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV = NULL;\nPFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV = NULL;\nPFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV = NULL;\nPFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV = NULL;\nPFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV = NULL;\nPFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV = NULL;\nPFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV = NULL;\nPFNGLVERTEX2HNVPROC __glewVertex2hNV = NULL;\nPFNGLVERTEX2HVNVPROC __glewVertex2hvNV = NULL;\nPFNGLVERTEX3HNVPROC __glewVertex3hNV = NULL;\nPFNGLVERTEX3HVNVPROC __glewVertex3hvNV = NULL;\nPFNGLVERTEX4HNVPROC __glewVertex4hNV = NULL;\nPFNGLVERTEX4HVNVPROC __glewVertex4hvNV = NULL;\nPFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV = NULL;\nPFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV = NULL;\nPFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV = NULL;\nPFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV = NULL;\nPFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV = NULL;\nPFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV = NULL;\nPFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV = NULL;\nPFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV = NULL;\nPFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV = NULL;\nPFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV = NULL;\nPFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV = NULL;\nPFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV = NULL;\nPFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV = NULL;\nPFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV = NULL;\n\nPFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV = NULL;\nPFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV = NULL;\nPFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV = NULL;\nPFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV = NULL;\nPFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV = NULL;\nPFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV = NULL;\nPFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV = NULL;\n\nPFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV = NULL;\nPFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV = NULL;\nPFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV = NULL;\n\nPFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV = NULL;\nPFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV = NULL;\n\nPFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV = NULL;\nPFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV = NULL;\n\nPFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV = NULL;\nPFNGLGETVIDEOIVNVPROC __glewGetVideoivNV = NULL;\nPFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV = NULL;\nPFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV = NULL;\nPFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV = NULL;\nPFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV = NULL;\nPFNGLVIDEOPARAMETERIVNVPROC __glewVideoParameterivNV = NULL;\n\nPFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV = NULL;\nPFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV = NULL;\n\nPFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV = NULL;\nPFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV = NULL;\nPFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV = NULL;\nPFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV = NULL;\nPFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV = NULL;\nPFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV = NULL;\nPFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV = NULL;\nPFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV = NULL;\nPFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV = NULL;\nPFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV = NULL;\nPFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV = NULL;\nPFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV = NULL;\nPFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV = NULL;\n\nPFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV = NULL;\nPFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV = NULL;\n\nPFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV = NULL;\nPFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV = NULL;\nPFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV = NULL;\nPFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV = NULL;\nPFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV = NULL;\nPFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV = NULL;\nPFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV = NULL;\nPFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV = NULL;\nPFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV = NULL;\nPFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV = NULL;\nPFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV = NULL;\n\nPFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV = NULL;\nPFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV = NULL;\n\nPFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV = NULL;\nPFNGLBINDPROGRAMNVPROC __glewBindProgramNV = NULL;\nPFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV = NULL;\nPFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV = NULL;\nPFNGLGENPROGRAMSNVPROC __glewGenProgramsNV = NULL;\nPFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV = NULL;\nPFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV = NULL;\nPFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV = NULL;\nPFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV = NULL;\nPFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV = NULL;\nPFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV = NULL;\nPFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV = NULL;\nPFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV = NULL;\nPFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV = NULL;\nPFNGLISPROGRAMNVPROC __glewIsProgramNV = NULL;\nPFNGLLOADPROGRAMNVPROC __glewLoadProgramNV = NULL;\nPFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV = NULL;\nPFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV = NULL;\nPFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV = NULL;\nPFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV = NULL;\nPFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV = NULL;\nPFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV = NULL;\nPFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV = NULL;\nPFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV = NULL;\nPFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV = NULL;\nPFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV = NULL;\nPFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV = NULL;\nPFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV = NULL;\nPFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV = NULL;\nPFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV = NULL;\nPFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV = NULL;\nPFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV = NULL;\nPFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV = NULL;\nPFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV = NULL;\nPFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV = NULL;\nPFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV = NULL;\nPFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV = NULL;\nPFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV = NULL;\nPFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV = NULL;\nPFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV = NULL;\nPFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV = NULL;\nPFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV = NULL;\nPFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV = NULL;\nPFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV = NULL;\nPFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV = NULL;\nPFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV = NULL;\nPFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV = NULL;\nPFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV = NULL;\nPFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV = NULL;\nPFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV = NULL;\nPFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV = NULL;\nPFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV = NULL;\nPFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV = NULL;\nPFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV = NULL;\nPFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV = NULL;\nPFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV = NULL;\nPFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV = NULL;\nPFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV = NULL;\nPFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV = NULL;\nPFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV = NULL;\nPFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV = NULL;\nPFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV = NULL;\nPFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV = NULL;\nPFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV = NULL;\n\nPFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES = NULL;\nPFNGLCLIPPLANEFOESPROC __glewClipPlanefOES = NULL;\nPFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES = NULL;\nPFNGLFRUSTUMFOESPROC __glewFrustumfOES = NULL;\nPFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES = NULL;\nPFNGLORTHOFOESPROC __glewOrthofOES = NULL;\n\nPFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS = NULL;\nPFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS = NULL;\n\nPFNGLFOGFUNCSGISPROC __glewFogFuncSGIS = NULL;\nPFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS = NULL;\n\nPFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS = NULL;\nPFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS = NULL;\n\nPFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS = NULL;\nPFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS = NULL;\n\nPFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS = NULL;\nPFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS = NULL;\n\nPFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS = NULL;\nPFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS = NULL;\n\nPFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX = NULL;\nPFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX = NULL;\nPFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX = NULL;\nPFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX = NULL;\nPFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX = NULL;\nPFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX = NULL;\n\nPFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX = NULL;\n\nPFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX = NULL;\n\nPFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX = NULL;\nPFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX = NULL;\nPFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX = NULL;\nPFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX = NULL;\nPFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX = NULL;\nPFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX = NULL;\nPFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX = NULL;\nPFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX = NULL;\nPFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX = NULL;\nPFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX = NULL;\nPFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX = NULL;\nPFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX = NULL;\nPFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX = NULL;\nPFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX = NULL;\n\nPFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX = NULL;\n\nPFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX = NULL;\n\nPFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX = NULL;\n\nPFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX = NULL;\nPFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX = NULL;\nPFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX = NULL;\nPFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX = NULL;\n\nPFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX = NULL;\n\nPFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI = NULL;\nPFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI = NULL;\nPFNGLCOLORTABLESGIPROC __glewColorTableSGI = NULL;\nPFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI = NULL;\nPFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI = NULL;\nPFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI = NULL;\nPFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI = NULL;\n\nPFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX = NULL;\n\nPFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN = NULL;\nPFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN = NULL;\nPFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN = NULL;\nPFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN = NULL;\nPFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN = NULL;\nPFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN = NULL;\nPFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN = NULL;\nPFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN = NULL;\n\nPFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN = NULL;\n\nPFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN = NULL;\nPFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN = NULL;\nPFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN = NULL;\nPFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN = NULL;\nPFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN = NULL;\nPFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN = NULL;\nPFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN = NULL;\n\nPFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN = NULL;\nPFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN = NULL;\nPFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN = NULL;\nPFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN = NULL;\nPFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN = NULL;\nPFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN = NULL;\nPFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN = NULL;\nPFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN = NULL;\nPFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN = NULL;\nPFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN = NULL;\nPFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN = NULL;\nPFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN = NULL;\nPFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN = NULL;\nPFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN = NULL;\nPFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN = NULL;\nPFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN = NULL;\nPFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN = NULL;\nPFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN = NULL;\n\nPFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN = NULL;\n\n#endif /* !WIN32 || !GLEW_MX */\n\n#if !defined(GLEW_MX)\n\nGLboolean __GLEW_VERSION_1_1 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_2 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_3 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_4 = GL_FALSE;\nGLboolean __GLEW_VERSION_1_5 = GL_FALSE;\nGLboolean __GLEW_VERSION_2_0 = GL_FALSE;\nGLboolean __GLEW_VERSION_2_1 = GL_FALSE;\nGLboolean __GLEW_VERSION_3_0 = GL_FALSE;\nGLboolean __GLEW_3DFX_multisample = GL_FALSE;\nGLboolean __GLEW_3DFX_tbuffer = GL_FALSE;\nGLboolean __GLEW_3DFX_texture_compression_FXT1 = GL_FALSE;\nGLboolean __GLEW_APPLE_client_storage = GL_FALSE;\nGLboolean __GLEW_APPLE_element_array = GL_FALSE;\nGLboolean __GLEW_APPLE_fence = GL_FALSE;\nGLboolean __GLEW_APPLE_float_pixels = GL_FALSE;\nGLboolean __GLEW_APPLE_flush_buffer_range = GL_FALSE;\nGLboolean __GLEW_APPLE_pixel_buffer = GL_FALSE;\nGLboolean __GLEW_APPLE_specular_vector = GL_FALSE;\nGLboolean __GLEW_APPLE_texture_range = GL_FALSE;\nGLboolean __GLEW_APPLE_transform_hint = GL_FALSE;\nGLboolean __GLEW_APPLE_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_APPLE_vertex_array_range = GL_FALSE;\nGLboolean __GLEW_APPLE_ycbcr_422 = GL_FALSE;\nGLboolean __GLEW_ARB_color_buffer_float = GL_FALSE;\nGLboolean __GLEW_ARB_depth_buffer_float = GL_FALSE;\nGLboolean __GLEW_ARB_depth_texture = GL_FALSE;\nGLboolean __GLEW_ARB_draw_buffers = GL_FALSE;\nGLboolean __GLEW_ARB_draw_instanced = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_program = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_program_shadow = GL_FALSE;\nGLboolean __GLEW_ARB_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ARB_framebuffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLEW_ARB_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_ARB_half_float_pixel = GL_FALSE;\nGLboolean __GLEW_ARB_half_float_vertex = GL_FALSE;\nGLboolean __GLEW_ARB_imaging = GL_FALSE;\nGLboolean __GLEW_ARB_instanced_arrays = GL_FALSE;\nGLboolean __GLEW_ARB_map_buffer_range = GL_FALSE;\nGLboolean __GLEW_ARB_matrix_palette = GL_FALSE;\nGLboolean __GLEW_ARB_multisample = GL_FALSE;\nGLboolean __GLEW_ARB_multitexture = GL_FALSE;\nGLboolean __GLEW_ARB_occlusion_query = GL_FALSE;\nGLboolean __GLEW_ARB_pixel_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_point_parameters = GL_FALSE;\nGLboolean __GLEW_ARB_point_sprite = GL_FALSE;\nGLboolean __GLEW_ARB_shader_objects = GL_FALSE;\nGLboolean __GLEW_ARB_shading_language_100 = GL_FALSE;\nGLboolean __GLEW_ARB_shadow = GL_FALSE;\nGLboolean __GLEW_ARB_shadow_ambient = GL_FALSE;\nGLboolean __GLEW_ARB_texture_border_clamp = GL_FALSE;\nGLboolean __GLEW_ARB_texture_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_texture_compression = GL_FALSE;\nGLboolean __GLEW_ARB_texture_compression_rgtc = GL_FALSE;\nGLboolean __GLEW_ARB_texture_cube_map = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_add = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_combine = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_crossbar = GL_FALSE;\nGLboolean __GLEW_ARB_texture_env_dot3 = GL_FALSE;\nGLboolean __GLEW_ARB_texture_float = GL_FALSE;\nGLboolean __GLEW_ARB_texture_mirrored_repeat = GL_FALSE;\nGLboolean __GLEW_ARB_texture_non_power_of_two = GL_FALSE;\nGLboolean __GLEW_ARB_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_ARB_texture_rg = GL_FALSE;\nGLboolean __GLEW_ARB_transpose_matrix = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_blend = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_buffer_object = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_program = GL_FALSE;\nGLboolean __GLEW_ARB_vertex_shader = GL_FALSE;\nGLboolean __GLEW_ARB_window_pos = GL_FALSE;\nGLboolean __GLEW_ATIX_point_sprites = GL_FALSE;\nGLboolean __GLEW_ATIX_texture_env_combine3 = GL_FALSE;\nGLboolean __GLEW_ATIX_texture_env_route = GL_FALSE;\nGLboolean __GLEW_ATIX_vertex_shader_output_point_size = GL_FALSE;\nGLboolean __GLEW_ATI_draw_buffers = GL_FALSE;\nGLboolean __GLEW_ATI_element_array = GL_FALSE;\nGLboolean __GLEW_ATI_envmap_bumpmap = GL_FALSE;\nGLboolean __GLEW_ATI_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ATI_map_object_buffer = GL_FALSE;\nGLboolean __GLEW_ATI_pn_triangles = GL_FALSE;\nGLboolean __GLEW_ATI_separate_stencil = GL_FALSE;\nGLboolean __GLEW_ATI_shader_texture_lod = GL_FALSE;\nGLboolean __GLEW_ATI_text_fragment_shader = GL_FALSE;\nGLboolean __GLEW_ATI_texture_compression_3dc = GL_FALSE;\nGLboolean __GLEW_ATI_texture_env_combine3 = GL_FALSE;\nGLboolean __GLEW_ATI_texture_float = GL_FALSE;\nGLboolean __GLEW_ATI_texture_mirror_once = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_array_object = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_attrib_array_object = GL_FALSE;\nGLboolean __GLEW_ATI_vertex_streams = GL_FALSE;\nGLboolean __GLEW_EXT_422_pixels = GL_FALSE;\nGLboolean __GLEW_EXT_Cg_shader = GL_FALSE;\nGLboolean __GLEW_EXT_abgr = GL_FALSE;\nGLboolean __GLEW_EXT_bgra = GL_FALSE;\nGLboolean __GLEW_EXT_bindable_uniform = GL_FALSE;\nGLboolean __GLEW_EXT_blend_color = GL_FALSE;\nGLboolean __GLEW_EXT_blend_equation_separate = GL_FALSE;\nGLboolean __GLEW_EXT_blend_func_separate = GL_FALSE;\nGLboolean __GLEW_EXT_blend_logic_op = GL_FALSE;\nGLboolean __GLEW_EXT_blend_minmax = GL_FALSE;\nGLboolean __GLEW_EXT_blend_subtract = GL_FALSE;\nGLboolean __GLEW_EXT_clip_volume_hint = GL_FALSE;\nGLboolean __GLEW_EXT_cmyka = GL_FALSE;\nGLboolean __GLEW_EXT_color_subtable = GL_FALSE;\nGLboolean __GLEW_EXT_compiled_vertex_array = GL_FALSE;\nGLboolean __GLEW_EXT_convolution = GL_FALSE;\nGLboolean __GLEW_EXT_coordinate_frame = GL_FALSE;\nGLboolean __GLEW_EXT_copy_texture = GL_FALSE;\nGLboolean __GLEW_EXT_cull_vertex = GL_FALSE;\nGLboolean __GLEW_EXT_depth_bounds_test = GL_FALSE;\nGLboolean __GLEW_EXT_direct_state_access = GL_FALSE;\nGLboolean __GLEW_EXT_draw_buffers2 = GL_FALSE;\nGLboolean __GLEW_EXT_draw_instanced = GL_FALSE;\nGLboolean __GLEW_EXT_draw_range_elements = GL_FALSE;\nGLboolean __GLEW_EXT_fog_coord = GL_FALSE;\nGLboolean __GLEW_EXT_fragment_lighting = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_blit = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_multisample = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLEW_EXT_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_EXT_gpu_program_parameters = GL_FALSE;\nGLboolean __GLEW_EXT_gpu_shader4 = GL_FALSE;\nGLboolean __GLEW_EXT_histogram = GL_FALSE;\nGLboolean __GLEW_EXT_index_array_formats = GL_FALSE;\nGLboolean __GLEW_EXT_index_func = GL_FALSE;\nGLboolean __GLEW_EXT_index_material = GL_FALSE;\nGLboolean __GLEW_EXT_index_texture = GL_FALSE;\nGLboolean __GLEW_EXT_light_texture = GL_FALSE;\nGLboolean __GLEW_EXT_misc_attribute = GL_FALSE;\nGLboolean __GLEW_EXT_multi_draw_arrays = GL_FALSE;\nGLboolean __GLEW_EXT_multisample = GL_FALSE;\nGLboolean __GLEW_EXT_packed_depth_stencil = GL_FALSE;\nGLboolean __GLEW_EXT_packed_float = GL_FALSE;\nGLboolean __GLEW_EXT_packed_pixels = GL_FALSE;\nGLboolean __GLEW_EXT_paletted_texture = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_buffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_transform = GL_FALSE;\nGLboolean __GLEW_EXT_pixel_transform_color_table = GL_FALSE;\nGLboolean __GLEW_EXT_point_parameters = GL_FALSE;\nGLboolean __GLEW_EXT_polygon_offset = GL_FALSE;\nGLboolean __GLEW_EXT_rescale_normal = GL_FALSE;\nGLboolean __GLEW_EXT_scene_marker = GL_FALSE;\nGLboolean __GLEW_EXT_secondary_color = GL_FALSE;\nGLboolean __GLEW_EXT_separate_specular_color = GL_FALSE;\nGLboolean __GLEW_EXT_shadow_funcs = GL_FALSE;\nGLboolean __GLEW_EXT_shared_texture_palette = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_clear_tag = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_two_side = GL_FALSE;\nGLboolean __GLEW_EXT_stencil_wrap = GL_FALSE;\nGLboolean __GLEW_EXT_subtexture = GL_FALSE;\nGLboolean __GLEW_EXT_texture = GL_FALSE;\nGLboolean __GLEW_EXT_texture3D = GL_FALSE;\nGLboolean __GLEW_EXT_texture_array = GL_FALSE;\nGLboolean __GLEW_EXT_texture_buffer_object = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_dxt1 = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_latc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_rgtc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_compression_s3tc = GL_FALSE;\nGLboolean __GLEW_EXT_texture_cube_map = GL_FALSE;\nGLboolean __GLEW_EXT_texture_edge_clamp = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_add = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_combine = GL_FALSE;\nGLboolean __GLEW_EXT_texture_env_dot3 = GL_FALSE;\nGLboolean __GLEW_EXT_texture_filter_anisotropic = GL_FALSE;\nGLboolean __GLEW_EXT_texture_integer = GL_FALSE;\nGLboolean __GLEW_EXT_texture_lod_bias = GL_FALSE;\nGLboolean __GLEW_EXT_texture_mirror_clamp = GL_FALSE;\nGLboolean __GLEW_EXT_texture_object = GL_FALSE;\nGLboolean __GLEW_EXT_texture_perturb_normal = GL_FALSE;\nGLboolean __GLEW_EXT_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_EXT_texture_sRGB = GL_FALSE;\nGLboolean __GLEW_EXT_texture_shared_exponent = GL_FALSE;\nGLboolean __GLEW_EXT_texture_swizzle = GL_FALSE;\nGLboolean __GLEW_EXT_timer_query = GL_FALSE;\nGLboolean __GLEW_EXT_transform_feedback = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_array = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_array_bgra = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_shader = GL_FALSE;\nGLboolean __GLEW_EXT_vertex_weighting = GL_FALSE;\nGLboolean __GLEW_GREMEDY_frame_terminator = GL_FALSE;\nGLboolean __GLEW_GREMEDY_string_marker = GL_FALSE;\nGLboolean __GLEW_HP_convolution_border_modes = GL_FALSE;\nGLboolean __GLEW_HP_image_transform = GL_FALSE;\nGLboolean __GLEW_HP_occlusion_test = GL_FALSE;\nGLboolean __GLEW_HP_texture_lighting = GL_FALSE;\nGLboolean __GLEW_IBM_cull_vertex = GL_FALSE;\nGLboolean __GLEW_IBM_multimode_draw_arrays = GL_FALSE;\nGLboolean __GLEW_IBM_rasterpos_clip = GL_FALSE;\nGLboolean __GLEW_IBM_static_data = GL_FALSE;\nGLboolean __GLEW_IBM_texture_mirrored_repeat = GL_FALSE;\nGLboolean __GLEW_IBM_vertex_array_lists = GL_FALSE;\nGLboolean __GLEW_INGR_color_clamp = GL_FALSE;\nGLboolean __GLEW_INGR_interlace_read = GL_FALSE;\nGLboolean __GLEW_INTEL_parallel_arrays = GL_FALSE;\nGLboolean __GLEW_INTEL_texture_scissor = GL_FALSE;\nGLboolean __GLEW_KTX_buffer_region = GL_FALSE;\nGLboolean __GLEW_MESAX_texture_stack = GL_FALSE;\nGLboolean __GLEW_MESA_pack_invert = GL_FALSE;\nGLboolean __GLEW_MESA_resize_buffers = GL_FALSE;\nGLboolean __GLEW_MESA_window_pos = GL_FALSE;\nGLboolean __GLEW_MESA_ycbcr_texture = GL_FALSE;\nGLboolean __GLEW_NV_blend_square = GL_FALSE;\nGLboolean __GLEW_NV_conditional_render = GL_FALSE;\nGLboolean __GLEW_NV_copy_depth_to_color = GL_FALSE;\nGLboolean __GLEW_NV_depth_buffer_float = GL_FALSE;\nGLboolean __GLEW_NV_depth_clamp = GL_FALSE;\nGLboolean __GLEW_NV_depth_range_unclamped = GL_FALSE;\nGLboolean __GLEW_NV_evaluators = GL_FALSE;\nGLboolean __GLEW_NV_explicit_multisample = GL_FALSE;\nGLboolean __GLEW_NV_fence = GL_FALSE;\nGLboolean __GLEW_NV_float_buffer = GL_FALSE;\nGLboolean __GLEW_NV_fog_distance = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program2 = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program4 = GL_FALSE;\nGLboolean __GLEW_NV_fragment_program_option = GL_FALSE;\nGLboolean __GLEW_NV_framebuffer_multisample_coverage = GL_FALSE;\nGLboolean __GLEW_NV_geometry_program4 = GL_FALSE;\nGLboolean __GLEW_NV_geometry_shader4 = GL_FALSE;\nGLboolean __GLEW_NV_gpu_program4 = GL_FALSE;\nGLboolean __GLEW_NV_half_float = GL_FALSE;\nGLboolean __GLEW_NV_light_max_exponent = GL_FALSE;\nGLboolean __GLEW_NV_multisample_filter_hint = GL_FALSE;\nGLboolean __GLEW_NV_occlusion_query = GL_FALSE;\nGLboolean __GLEW_NV_packed_depth_stencil = GL_FALSE;\nGLboolean __GLEW_NV_parameter_buffer_object = GL_FALSE;\nGLboolean __GLEW_NV_pixel_data_range = GL_FALSE;\nGLboolean __GLEW_NV_point_sprite = GL_FALSE;\nGLboolean __GLEW_NV_present_video = GL_FALSE;\nGLboolean __GLEW_NV_primitive_restart = GL_FALSE;\nGLboolean __GLEW_NV_register_combiners = GL_FALSE;\nGLboolean __GLEW_NV_register_combiners2 = GL_FALSE;\nGLboolean __GLEW_NV_texgen_emboss = GL_FALSE;\nGLboolean __GLEW_NV_texgen_reflection = GL_FALSE;\nGLboolean __GLEW_NV_texture_compression_vtc = GL_FALSE;\nGLboolean __GLEW_NV_texture_env_combine4 = GL_FALSE;\nGLboolean __GLEW_NV_texture_expand_normal = GL_FALSE;\nGLboolean __GLEW_NV_texture_rectangle = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader2 = GL_FALSE;\nGLboolean __GLEW_NV_texture_shader3 = GL_FALSE;\nGLboolean __GLEW_NV_transform_feedback = GL_FALSE;\nGLboolean __GLEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __GLEW_NV_vertex_array_range2 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program1_1 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program2 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program2_option = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program3 = GL_FALSE;\nGLboolean __GLEW_NV_vertex_program4 = GL_FALSE;\nGLboolean __GLEW_OES_byte_coordinates = GL_FALSE;\nGLboolean __GLEW_OES_compressed_paletted_texture = GL_FALSE;\nGLboolean __GLEW_OES_read_format = GL_FALSE;\nGLboolean __GLEW_OES_single_precision = GL_FALSE;\nGLboolean __GLEW_OML_interlace = GL_FALSE;\nGLboolean __GLEW_OML_resample = GL_FALSE;\nGLboolean __GLEW_OML_subsample = GL_FALSE;\nGLboolean __GLEW_PGI_misc_hints = GL_FALSE;\nGLboolean __GLEW_PGI_vertex_hints = GL_FALSE;\nGLboolean __GLEW_REND_screen_coordinates = GL_FALSE;\nGLboolean __GLEW_S3_s3tc = GL_FALSE;\nGLboolean __GLEW_SGIS_color_range = GL_FALSE;\nGLboolean __GLEW_SGIS_detail_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_fog_function = GL_FALSE;\nGLboolean __GLEW_SGIS_generate_mipmap = GL_FALSE;\nGLboolean __GLEW_SGIS_multisample = GL_FALSE;\nGLboolean __GLEW_SGIS_pixel_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_point_line_texgen = GL_FALSE;\nGLboolean __GLEW_SGIS_sharpen_texture = GL_FALSE;\nGLboolean __GLEW_SGIS_texture4D = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_border_clamp = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_edge_clamp = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_filter4 = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_lod = GL_FALSE;\nGLboolean __GLEW_SGIS_texture_select = GL_FALSE;\nGLboolean __GLEW_SGIX_async = GL_FALSE;\nGLboolean __GLEW_SGIX_async_histogram = GL_FALSE;\nGLboolean __GLEW_SGIX_async_pixel = GL_FALSE;\nGLboolean __GLEW_SGIX_blend_alpha_minmax = GL_FALSE;\nGLboolean __GLEW_SGIX_clipmap = GL_FALSE;\nGLboolean __GLEW_SGIX_convolution_accuracy = GL_FALSE;\nGLboolean __GLEW_SGIX_depth_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_flush_raster = GL_FALSE;\nGLboolean __GLEW_SGIX_fog_offset = GL_FALSE;\nGLboolean __GLEW_SGIX_fog_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_fragment_specular_lighting = GL_FALSE;\nGLboolean __GLEW_SGIX_framezoom = GL_FALSE;\nGLboolean __GLEW_SGIX_interlace = GL_FALSE;\nGLboolean __GLEW_SGIX_ir_instrument1 = GL_FALSE;\nGLboolean __GLEW_SGIX_list_priority = GL_FALSE;\nGLboolean __GLEW_SGIX_pixel_texture = GL_FALSE;\nGLboolean __GLEW_SGIX_pixel_texture_bits = GL_FALSE;\nGLboolean __GLEW_SGIX_reference_plane = GL_FALSE;\nGLboolean __GLEW_SGIX_resample = GL_FALSE;\nGLboolean __GLEW_SGIX_shadow = GL_FALSE;\nGLboolean __GLEW_SGIX_shadow_ambient = GL_FALSE;\nGLboolean __GLEW_SGIX_sprite = GL_FALSE;\nGLboolean __GLEW_SGIX_tag_sample_buffer = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_add_env = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_coordinate_clamp = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_lod_bias = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_multi_buffer = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_range = GL_FALSE;\nGLboolean __GLEW_SGIX_texture_scale_bias = GL_FALSE;\nGLboolean __GLEW_SGIX_vertex_preclip = GL_FALSE;\nGLboolean __GLEW_SGIX_vertex_preclip_hint = GL_FALSE;\nGLboolean __GLEW_SGIX_ycrcb = GL_FALSE;\nGLboolean __GLEW_SGI_color_matrix = GL_FALSE;\nGLboolean __GLEW_SGI_color_table = GL_FALSE;\nGLboolean __GLEW_SGI_texture_color_table = GL_FALSE;\nGLboolean __GLEW_SUNX_constant_data = GL_FALSE;\nGLboolean __GLEW_SUN_convolution_border_modes = GL_FALSE;\nGLboolean __GLEW_SUN_global_alpha = GL_FALSE;\nGLboolean __GLEW_SUN_mesh_array = GL_FALSE;\nGLboolean __GLEW_SUN_read_video_pixels = GL_FALSE;\nGLboolean __GLEW_SUN_slice_accum = GL_FALSE;\nGLboolean __GLEW_SUN_triangle_list = GL_FALSE;\nGLboolean __GLEW_SUN_vertex = GL_FALSE;\nGLboolean __GLEW_WIN_phong_shading = GL_FALSE;\nGLboolean __GLEW_WIN_specular_fog = GL_FALSE;\nGLboolean __GLEW_WIN_swap_hint = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef GL_VERSION_1_2\n\nstatic GLboolean _glewInit_GL_VERSION_1_2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage3D\")) == NULL) || r;\n  r = ((glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElements\")) == NULL) || r;\n  r = ((glTexImage3D = (PFNGLTEXIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glTexImage3D\")) == NULL) || r;\n  r = ((glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_2 */\n\n#ifdef GL_VERSION_1_3\n\nstatic GLboolean _glewInit_GL_VERSION_1_3 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveTexture = (PFNGLACTIVETEXTUREPROC)glewGetProcAddress((const GLubyte*)\"glActiveTexture\")) == NULL) || r;\n  r = ((glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveTexture\")) == NULL) || r;\n  r = ((glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage1D\")) == NULL) || r;\n  r = ((glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage2D\")) == NULL) || r;\n  r = ((glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage3D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage1D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage2D\")) == NULL) || r;\n  r = ((glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage3D\")) == NULL) || r;\n  r = ((glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTexImage\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixd\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixf\")) == NULL) || r;\n  r = ((glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixd\")) == NULL) || r;\n  r = ((glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixf\")) == NULL) || r;\n  r = ((glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1d\")) == NULL) || r;\n  r = ((glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dv\")) == NULL) || r;\n  r = ((glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1f\")) == NULL) || r;\n  r = ((glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fv\")) == NULL) || r;\n  r = ((glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1i\")) == NULL) || r;\n  r = ((glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1iv\")) == NULL) || r;\n  r = ((glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1s\")) == NULL) || r;\n  r = ((glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1sv\")) == NULL) || r;\n  r = ((glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2d\")) == NULL) || r;\n  r = ((glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dv\")) == NULL) || r;\n  r = ((glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2f\")) == NULL) || r;\n  r = ((glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fv\")) == NULL) || r;\n  r = ((glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2i\")) == NULL) || r;\n  r = ((glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2iv\")) == NULL) || r;\n  r = ((glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2s\")) == NULL) || r;\n  r = ((glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2sv\")) == NULL) || r;\n  r = ((glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3d\")) == NULL) || r;\n  r = ((glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dv\")) == NULL) || r;\n  r = ((glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3f\")) == NULL) || r;\n  r = ((glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fv\")) == NULL) || r;\n  r = ((glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3i\")) == NULL) || r;\n  r = ((glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3iv\")) == NULL) || r;\n  r = ((glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3s\")) == NULL) || r;\n  r = ((glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3sv\")) == NULL) || r;\n  r = ((glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4d\")) == NULL) || r;\n  r = ((glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dv\")) == NULL) || r;\n  r = ((glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4f\")) == NULL) || r;\n  r = ((glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fv\")) == NULL) || r;\n  r = ((glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4i\")) == NULL) || r;\n  r = ((glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4iv\")) == NULL) || r;\n  r = ((glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4s\")) == NULL) || r;\n  r = ((glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4sv\")) == NULL) || r;\n  r = ((glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)glewGetProcAddress((const GLubyte*)\"glSampleCoverage\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_3 */\n\n#ifdef GL_VERSION_1_4\n\nstatic GLboolean _glewInit_GL_VERSION_1_4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendColor = (PFNGLBLENDCOLORPROC)glewGetProcAddress((const GLubyte*)\"glBlendColor\")) == NULL) || r;\n  r = ((glBlendEquation = (PFNGLBLENDEQUATIONPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquation\")) == NULL) || r;\n  r = ((glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glBlendFuncSeparate\")) == NULL) || r;\n  r = ((glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointer\")) == NULL) || r;\n  r = ((glFogCoordd = (PFNGLFOGCOORDDPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordd\")) == NULL) || r;\n  r = ((glFogCoorddv = (PFNGLFOGCOORDDVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddv\")) == NULL) || r;\n  r = ((glFogCoordf = (PFNGLFOGCOORDFPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordf\")) == NULL) || r;\n  r = ((glFogCoordfv = (PFNGLFOGCOORDFVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfv\")) == NULL) || r;\n  r = ((glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawArrays\")) == NULL) || r;\n  r = ((glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElements\")) == NULL) || r;\n  r = ((glPointParameterf = (PFNGLPOINTPARAMETERFPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterf\")) == NULL) || r;\n  r = ((glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfv\")) == NULL) || r;\n  r = ((glPointParameteri = (PFNGLPOINTPARAMETERIPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteri\")) == NULL) || r;\n  r = ((glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteriv\")) == NULL) || r;\n  r = ((glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3b\")) == NULL) || r;\n  r = ((glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bv\")) == NULL) || r;\n  r = ((glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3d\")) == NULL) || r;\n  r = ((glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dv\")) == NULL) || r;\n  r = ((glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3f\")) == NULL) || r;\n  r = ((glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fv\")) == NULL) || r;\n  r = ((glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3i\")) == NULL) || r;\n  r = ((glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3iv\")) == NULL) || r;\n  r = ((glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3s\")) == NULL) || r;\n  r = ((glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3sv\")) == NULL) || r;\n  r = ((glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ub\")) == NULL) || r;\n  r = ((glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubv\")) == NULL) || r;\n  r = ((glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ui\")) == NULL) || r;\n  r = ((glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uiv\")) == NULL) || r;\n  r = ((glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3us\")) == NULL) || r;\n  r = ((glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usv\")) == NULL) || r;\n  r = ((glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointer\")) == NULL) || r;\n  r = ((glWindowPos2d = (PFNGLWINDOWPOS2DPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2d\")) == NULL) || r;\n  r = ((glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dv\")) == NULL) || r;\n  r = ((glWindowPos2f = (PFNGLWINDOWPOS2FPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2f\")) == NULL) || r;\n  r = ((glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fv\")) == NULL) || r;\n  r = ((glWindowPos2i = (PFNGLWINDOWPOS2IPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2i\")) == NULL) || r;\n  r = ((glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iv\")) == NULL) || r;\n  r = ((glWindowPos2s = (PFNGLWINDOWPOS2SPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2s\")) == NULL) || r;\n  r = ((glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sv\")) == NULL) || r;\n  r = ((glWindowPos3d = (PFNGLWINDOWPOS3DPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3d\")) == NULL) || r;\n  r = ((glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dv\")) == NULL) || r;\n  r = ((glWindowPos3f = (PFNGLWINDOWPOS3FPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3f\")) == NULL) || r;\n  r = ((glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fv\")) == NULL) || r;\n  r = ((glWindowPos3i = (PFNGLWINDOWPOS3IPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3i\")) == NULL) || r;\n  r = ((glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iv\")) == NULL) || r;\n  r = ((glWindowPos3s = (PFNGLWINDOWPOS3SPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3s\")) == NULL) || r;\n  r = ((glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sv\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_4 */\n\n#ifdef GL_VERSION_1_5\n\nstatic GLboolean _glewInit_GL_VERSION_1_5 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginQuery = (PFNGLBEGINQUERYPROC)glewGetProcAddress((const GLubyte*)\"glBeginQuery\")) == NULL) || r;\n  r = ((glBindBuffer = (PFNGLBINDBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindBuffer\")) == NULL) || r;\n  r = ((glBufferData = (PFNGLBUFFERDATAPROC)glewGetProcAddress((const GLubyte*)\"glBufferData\")) == NULL) || r;\n  r = ((glBufferSubData = (PFNGLBUFFERSUBDATAPROC)glewGetProcAddress((const GLubyte*)\"glBufferSubData\")) == NULL) || r;\n  r = ((glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBuffers\")) == NULL) || r;\n  r = ((glDeleteQueries = (PFNGLDELETEQUERIESPROC)glewGetProcAddress((const GLubyte*)\"glDeleteQueries\")) == NULL) || r;\n  r = ((glEndQuery = (PFNGLENDQUERYPROC)glewGetProcAddress((const GLubyte*)\"glEndQuery\")) == NULL) || r;\n  r = ((glGenBuffers = (PFNGLGENBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenBuffers\")) == NULL) || r;\n  r = ((glGenQueries = (PFNGLGENQUERIESPROC)glewGetProcAddress((const GLubyte*)\"glGenQueries\")) == NULL) || r;\n  r = ((glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferParameteriv\")) == NULL) || r;\n  r = ((glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferPointerv\")) == NULL) || r;\n  r = ((glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferSubData\")) == NULL) || r;\n  r = ((glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectiv\")) == NULL) || r;\n  r = ((glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectuiv\")) == NULL) || r;\n  r = ((glGetQueryiv = (PFNGLGETQUERYIVPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryiv\")) == NULL) || r;\n  r = ((glIsBuffer = (PFNGLISBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsBuffer\")) == NULL) || r;\n  r = ((glIsQuery = (PFNGLISQUERYPROC)glewGetProcAddress((const GLubyte*)\"glIsQuery\")) == NULL) || r;\n  r = ((glMapBuffer = (PFNGLMAPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glMapBuffer\")) == NULL) || r;\n  r = ((glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glUnmapBuffer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_1_5 */\n\n#ifdef GL_VERSION_2_0\n\nstatic GLboolean _glewInit_GL_VERSION_2_0 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAttachShader = (PFNGLATTACHSHADERPROC)glewGetProcAddress((const GLubyte*)\"glAttachShader\")) == NULL) || r;\n  r = ((glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glBindAttribLocation\")) == NULL) || r;\n  r = ((glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationSeparate\")) == NULL) || r;\n  r = ((glCompileShader = (PFNGLCOMPILESHADERPROC)glewGetProcAddress((const GLubyte*)\"glCompileShader\")) == NULL) || r;\n  r = ((glCreateProgram = (PFNGLCREATEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glCreateProgram\")) == NULL) || r;\n  r = ((glCreateShader = (PFNGLCREATESHADERPROC)glewGetProcAddress((const GLubyte*)\"glCreateShader\")) == NULL) || r;\n  r = ((glDeleteProgram = (PFNGLDELETEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgram\")) == NULL) || r;\n  r = ((glDeleteShader = (PFNGLDELETESHADERPROC)glewGetProcAddress((const GLubyte*)\"glDeleteShader\")) == NULL) || r;\n  r = ((glDetachShader = (PFNGLDETACHSHADERPROC)glewGetProcAddress((const GLubyte*)\"glDetachShader\")) == NULL) || r;\n  r = ((glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)glewGetProcAddress((const GLubyte*)\"glDisableVertexAttribArray\")) == NULL) || r;\n  r = ((glDrawBuffers = (PFNGLDRAWBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffers\")) == NULL) || r;\n  r = ((glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glewGetProcAddress((const GLubyte*)\"glEnableVertexAttribArray\")) == NULL) || r;\n  r = ((glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveAttrib\")) == NULL) || r;\n  r = ((glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveUniform\")) == NULL) || r;\n  r = ((glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)glewGetProcAddress((const GLubyte*)\"glGetAttachedShaders\")) == NULL) || r;\n  r = ((glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetAttribLocation\")) == NULL) || r;\n  r = ((glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramInfoLog\")) == NULL) || r;\n  r = ((glGetProgramiv = (PFNGLGETPROGRAMIVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramiv\")) == NULL) || r;\n  r = ((glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderInfoLog\")) == NULL) || r;\n  r = ((glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderSource\")) == NULL) || r;\n  r = ((glGetShaderiv = (PFNGLGETSHADERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderiv\")) == NULL) || r;\n  r = ((glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformLocation\")) == NULL) || r;\n  r = ((glGetUniformfv = (PFNGLGETUNIFORMFVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformfv\")) == NULL) || r;\n  r = ((glGetUniformiv = (PFNGLGETUNIFORMIVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformiv\")) == NULL) || r;\n  r = ((glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointerv\")) == NULL) || r;\n  r = ((glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdv\")) == NULL) || r;\n  r = ((glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfv\")) == NULL) || r;\n  r = ((glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribiv\")) == NULL) || r;\n  r = ((glIsProgram = (PFNGLISPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glIsProgram\")) == NULL) || r;\n  r = ((glIsShader = (PFNGLISSHADERPROC)glewGetProcAddress((const GLubyte*)\"glIsShader\")) == NULL) || r;\n  r = ((glLinkProgram = (PFNGLLINKPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glLinkProgram\")) == NULL) || r;\n  r = ((glShaderSource = (PFNGLSHADERSOURCEPROC)glewGetProcAddress((const GLubyte*)\"glShaderSource\")) == NULL) || r;\n  r = ((glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilFuncSeparate\")) == NULL) || r;\n  r = ((glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilMaskSeparate\")) == NULL) || r;\n  r = ((glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)glewGetProcAddress((const GLubyte*)\"glStencilOpSeparate\")) == NULL) || r;\n  r = ((glUniform1f = (PFNGLUNIFORM1FPROC)glewGetProcAddress((const GLubyte*)\"glUniform1f\")) == NULL) || r;\n  r = ((glUniform1fv = (PFNGLUNIFORM1FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fv\")) == NULL) || r;\n  r = ((glUniform1i = (PFNGLUNIFORM1IPROC)glewGetProcAddress((const GLubyte*)\"glUniform1i\")) == NULL) || r;\n  r = ((glUniform1iv = (PFNGLUNIFORM1IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1iv\")) == NULL) || r;\n  r = ((glUniform2f = (PFNGLUNIFORM2FPROC)glewGetProcAddress((const GLubyte*)\"glUniform2f\")) == NULL) || r;\n  r = ((glUniform2fv = (PFNGLUNIFORM2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fv\")) == NULL) || r;\n  r = ((glUniform2i = (PFNGLUNIFORM2IPROC)glewGetProcAddress((const GLubyte*)\"glUniform2i\")) == NULL) || r;\n  r = ((glUniform2iv = (PFNGLUNIFORM2IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2iv\")) == NULL) || r;\n  r = ((glUniform3f = (PFNGLUNIFORM3FPROC)glewGetProcAddress((const GLubyte*)\"glUniform3f\")) == NULL) || r;\n  r = ((glUniform3fv = (PFNGLUNIFORM3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fv\")) == NULL) || r;\n  r = ((glUniform3i = (PFNGLUNIFORM3IPROC)glewGetProcAddress((const GLubyte*)\"glUniform3i\")) == NULL) || r;\n  r = ((glUniform3iv = (PFNGLUNIFORM3IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3iv\")) == NULL) || r;\n  r = ((glUniform4f = (PFNGLUNIFORM4FPROC)glewGetProcAddress((const GLubyte*)\"glUniform4f\")) == NULL) || r;\n  r = ((glUniform4fv = (PFNGLUNIFORM4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fv\")) == NULL) || r;\n  r = ((glUniform4i = (PFNGLUNIFORM4IPROC)glewGetProcAddress((const GLubyte*)\"glUniform4i\")) == NULL) || r;\n  r = ((glUniform4iv = (PFNGLUNIFORM4IVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4iv\")) == NULL) || r;\n  r = ((glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2fv\")) == NULL) || r;\n  r = ((glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3fv\")) == NULL) || r;\n  r = ((glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4fv\")) == NULL) || r;\n  r = ((glUseProgram = (PFNGLUSEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glUseProgram\")) == NULL) || r;\n  r = ((glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)glewGetProcAddress((const GLubyte*)\"glValidateProgram\")) == NULL) || r;\n  r = ((glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1d\")) == NULL) || r;\n  r = ((glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dv\")) == NULL) || r;\n  r = ((glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1f\")) == NULL) || r;\n  r = ((glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fv\")) == NULL) || r;\n  r = ((glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1s\")) == NULL) || r;\n  r = ((glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sv\")) == NULL) || r;\n  r = ((glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2d\")) == NULL) || r;\n  r = ((glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dv\")) == NULL) || r;\n  r = ((glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2f\")) == NULL) || r;\n  r = ((glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fv\")) == NULL) || r;\n  r = ((glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2s\")) == NULL) || r;\n  r = ((glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sv\")) == NULL) || r;\n  r = ((glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3d\")) == NULL) || r;\n  r = ((glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dv\")) == NULL) || r;\n  r = ((glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3f\")) == NULL) || r;\n  r = ((glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fv\")) == NULL) || r;\n  r = ((glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3s\")) == NULL) || r;\n  r = ((glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nbv\")) == NULL) || r;\n  r = ((glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Niv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nsv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nub\")) == NULL) || r;\n  r = ((glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nubv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nuiv\")) == NULL) || r;\n  r = ((glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4Nusv\")) == NULL) || r;\n  r = ((glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4bv\")) == NULL) || r;\n  r = ((glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4d\")) == NULL) || r;\n  r = ((glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dv\")) == NULL) || r;\n  r = ((glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4f\")) == NULL) || r;\n  r = ((glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fv\")) == NULL) || r;\n  r = ((glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4iv\")) == NULL) || r;\n  r = ((glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4s\")) == NULL) || r;\n  r = ((glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sv\")) == NULL) || r;\n  r = ((glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubv\")) == NULL) || r;\n  r = ((glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4uiv\")) == NULL) || r;\n  r = ((glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4usv\")) == NULL) || r;\n  r = ((glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_2_0 */\n\n#ifdef GL_VERSION_2_1\n\nstatic GLboolean _glewInit_GL_VERSION_2_1 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2x3fv\")) == NULL) || r;\n  r = ((glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2x4fv\")) == NULL) || r;\n  r = ((glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3x2fv\")) == NULL) || r;\n  r = ((glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3x4fv\")) == NULL) || r;\n  r = ((glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4x2fv\")) == NULL) || r;\n  r = ((glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4x3fv\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_2_1 */\n\n#ifdef GL_VERSION_3_0\n\nstatic GLboolean _glewInit_GL_VERSION_3_0 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)glewGetProcAddress((const GLubyte*)\"glBeginConditionalRender\")) == NULL) || r;\n  r = ((glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedback\")) == NULL) || r;\n  r = ((glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBase\")) == NULL) || r;\n  r = ((glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRange\")) == NULL) || r;\n  r = ((glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glBindFragDataLocation\")) == NULL) || r;\n  r = ((glClampColor = (PFNGLCLAMPCOLORPROC)glewGetProcAddress((const GLubyte*)\"glClampColor\")) == NULL) || r;\n  r = ((glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferfi\")) == NULL) || r;\n  r = ((glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferfv\")) == NULL) || r;\n  r = ((glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferiv\")) == NULL) || r;\n  r = ((glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)glewGetProcAddress((const GLubyte*)\"glClearBufferuiv\")) == NULL) || r;\n  r = ((glColorMaski = (PFNGLCOLORMASKIPROC)glewGetProcAddress((const GLubyte*)\"glColorMaski\")) == NULL) || r;\n  r = ((glDisablei = (PFNGLDISABLEIPROC)glewGetProcAddress((const GLubyte*)\"glDisablei\")) == NULL) || r;\n  r = ((glEnablei = (PFNGLENABLEIPROC)glewGetProcAddress((const GLubyte*)\"glEnablei\")) == NULL) || r;\n  r = ((glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)glewGetProcAddress((const GLubyte*)\"glEndConditionalRender\")) == NULL) || r;\n  r = ((glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedback\")) == NULL) || r;\n  r = ((glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)glewGetProcAddress((const GLubyte*)\"glGetBooleani_v\")) == NULL) || r;\n  r = ((glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)glewGetProcAddress((const GLubyte*)\"glGetFragDataLocation\")) == NULL) || r;\n  r = ((glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)glewGetProcAddress((const GLubyte*)\"glGetIntegeri_v\")) == NULL) || r;\n  r = ((glGetStringi = (PFNGLGETSTRINGIPROC)glewGetProcAddress((const GLubyte*)\"glGetStringi\")) == NULL) || r;\n  r = ((glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIiv\")) == NULL) || r;\n  r = ((glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIuiv\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVarying\")) == NULL) || r;\n  r = ((glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformuiv\")) == NULL) || r;\n  r = ((glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIiv\")) == NULL) || r;\n  r = ((glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIuiv\")) == NULL) || r;\n  r = ((glIsEnabledi = (PFNGLISENABLEDIPROC)glewGetProcAddress((const GLubyte*)\"glIsEnabledi\")) == NULL) || r;\n  r = ((glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIiv\")) == NULL) || r;\n  r = ((glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIuiv\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryings\")) == NULL) || r;\n  r = ((glUniform1ui = (PFNGLUNIFORM1UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform1ui\")) == NULL) || r;\n  r = ((glUniform1uiv = (PFNGLUNIFORM1UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uiv\")) == NULL) || r;\n  r = ((glUniform2ui = (PFNGLUNIFORM2UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform2ui\")) == NULL) || r;\n  r = ((glUniform2uiv = (PFNGLUNIFORM2UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uiv\")) == NULL) || r;\n  r = ((glUniform3ui = (PFNGLUNIFORM3UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform3ui\")) == NULL) || r;\n  r = ((glUniform3uiv = (PFNGLUNIFORM3UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uiv\")) == NULL) || r;\n  r = ((glUniform4ui = (PFNGLUNIFORM4UIPROC)glewGetProcAddress((const GLubyte*)\"glUniform4ui\")) == NULL) || r;\n  r = ((glUniform4uiv = (PFNGLUNIFORM4UIVPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uiv\")) == NULL) || r;\n  r = ((glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1i\")) == NULL) || r;\n  r = ((glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1iv\")) == NULL) || r;\n  r = ((glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1ui\")) == NULL) || r;\n  r = ((glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uiv\")) == NULL) || r;\n  r = ((glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2i\")) == NULL) || r;\n  r = ((glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2iv\")) == NULL) || r;\n  r = ((glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2ui\")) == NULL) || r;\n  r = ((glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uiv\")) == NULL) || r;\n  r = ((glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3i\")) == NULL) || r;\n  r = ((glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3iv\")) == NULL) || r;\n  r = ((glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3ui\")) == NULL) || r;\n  r = ((glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uiv\")) == NULL) || r;\n  r = ((glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4bv\")) == NULL) || r;\n  r = ((glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4i\")) == NULL) || r;\n  r = ((glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4iv\")) == NULL) || r;\n  r = ((glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4sv\")) == NULL) || r;\n  r = ((glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ubv\")) == NULL) || r;\n  r = ((glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ui\")) == NULL) || r;\n  r = ((glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uiv\")) == NULL) || r;\n  r = ((glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4usv\")) == NULL) || r;\n  r = ((glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribIPointer\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_VERSION_3_0 */\n\n#ifdef GL_3DFX_multisample\n\n#endif /* GL_3DFX_multisample */\n\n#ifdef GL_3DFX_tbuffer\n\nstatic GLboolean _glewInit_GL_3DFX_tbuffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTbufferMask3DFX = (PFNGLTBUFFERMASK3DFXPROC)glewGetProcAddress((const GLubyte*)\"glTbufferMask3DFX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_3DFX_tbuffer */\n\n#ifdef GL_3DFX_texture_compression_FXT1\n\n#endif /* GL_3DFX_texture_compression_FXT1 */\n\n#ifdef GL_APPLE_client_storage\n\n#endif /* GL_APPLE_client_storage */\n\n#ifdef GL_APPLE_element_array\n\nstatic GLboolean _glewInit_GL_APPLE_element_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawElementArrayAPPLE = (PFNGLDRAWELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementArrayAPPLE\")) == NULL) || r;\n  r = ((glDrawRangeElementArrayAPPLE = (PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementArrayAPPLE\")) == NULL) || r;\n  r = ((glElementPointerAPPLE = (PFNGLELEMENTPOINTERAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glElementPointerAPPLE\")) == NULL) || r;\n  r = ((glMultiDrawElementArrayAPPLE = (PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElementArrayAPPLE\")) == NULL) || r;\n  r = ((glMultiDrawRangeElementArrayAPPLE = (PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawRangeElementArrayAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_element_array */\n\n#ifdef GL_APPLE_fence\n\nstatic GLboolean _glewInit_GL_APPLE_fence (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDeleteFencesAPPLE = (PFNGLDELETEFENCESAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFencesAPPLE\")) == NULL) || r;\n  r = ((glFinishFenceAPPLE = (PFNGLFINISHFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFinishFenceAPPLE\")) == NULL) || r;\n  r = ((glFinishObjectAPPLE = (PFNGLFINISHOBJECTAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFinishObjectAPPLE\")) == NULL) || r;\n  r = ((glGenFencesAPPLE = (PFNGLGENFENCESAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGenFencesAPPLE\")) == NULL) || r;\n  r = ((glIsFenceAPPLE = (PFNGLISFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glIsFenceAPPLE\")) == NULL) || r;\n  r = ((glSetFenceAPPLE = (PFNGLSETFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glSetFenceAPPLE\")) == NULL) || r;\n  r = ((glTestFenceAPPLE = (PFNGLTESTFENCEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTestFenceAPPLE\")) == NULL) || r;\n  r = ((glTestObjectAPPLE = (PFNGLTESTOBJECTAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTestObjectAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_fence */\n\n#ifdef GL_APPLE_float_pixels\n\n#endif /* GL_APPLE_float_pixels */\n\n#ifdef GL_APPLE_flush_buffer_range\n\nstatic GLboolean _glewInit_GL_APPLE_flush_buffer_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBufferParameteriAPPLE = (PFNGLBUFFERPARAMETERIAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glBufferParameteriAPPLE\")) == NULL) || r;\n  r = ((glFlushMappedBufferRangeAPPLE = (PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFlushMappedBufferRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_flush_buffer_range */\n\n#ifdef GL_APPLE_pixel_buffer\n\n#endif /* GL_APPLE_pixel_buffer */\n\n#ifdef GL_APPLE_specular_vector\n\n#endif /* GL_APPLE_specular_vector */\n\n#ifdef GL_APPLE_texture_range\n\nstatic GLboolean _glewInit_GL_APPLE_texture_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexParameterPointervAPPLE = (PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterPointervAPPLE\")) == NULL) || r;\n  r = ((glTextureRangeAPPLE = (PFNGLTEXTURERANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glTextureRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_texture_range */\n\n#ifdef GL_APPLE_transform_hint\n\n#endif /* GL_APPLE_transform_hint */\n\n#ifdef GL_APPLE_vertex_array_object\n\nstatic GLboolean _glewInit_GL_APPLE_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindVertexArrayAPPLE = (PFNGLBINDVERTEXARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexArrayAPPLE\")) == NULL) || r;\n  r = ((glDeleteVertexArraysAPPLE = (PFNGLDELETEVERTEXARRAYSAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexArraysAPPLE\")) == NULL) || r;\n  r = ((glGenVertexArraysAPPLE = (PFNGLGENVERTEXARRAYSAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexArraysAPPLE\")) == NULL) || r;\n  r = ((glIsVertexArrayAPPLE = (PFNGLISVERTEXARRAYAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glIsVertexArrayAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_vertex_array_object */\n\n#ifdef GL_APPLE_vertex_array_range\n\nstatic GLboolean _glewInit_GL_APPLE_vertex_array_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushVertexArrayRangeAPPLE = (PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glFlushVertexArrayRangeAPPLE\")) == NULL) || r;\n  r = ((glVertexArrayParameteriAPPLE = (PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayParameteriAPPLE\")) == NULL) || r;\n  r = ((glVertexArrayRangeAPPLE = (PFNGLVERTEXARRAYRANGEAPPLEPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayRangeAPPLE\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_APPLE_vertex_array_range */\n\n#ifdef GL_APPLE_ycbcr_422\n\n#endif /* GL_APPLE_ycbcr_422 */\n\n#ifdef GL_ARB_color_buffer_float\n\nstatic GLboolean _glewInit_GL_ARB_color_buffer_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClampColorARB = (PFNGLCLAMPCOLORARBPROC)glewGetProcAddress((const GLubyte*)\"glClampColorARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_color_buffer_float */\n\n#ifdef GL_ARB_depth_buffer_float\n\n#endif /* GL_ARB_depth_buffer_float */\n\n#ifdef GL_ARB_depth_texture\n\n#endif /* GL_ARB_depth_texture */\n\n#ifdef GL_ARB_draw_buffers\n\nstatic GLboolean _glewInit_GL_ARB_draw_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawBuffersARB = (PFNGLDRAWBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffersARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_draw_buffers */\n\n#ifdef GL_ARB_draw_instanced\n\nstatic GLboolean _glewInit_GL_ARB_draw_instanced (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawArraysInstancedARB = (PFNGLDRAWARRAYSINSTANCEDARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysInstancedARB\")) == NULL) || r;\n  r = ((glDrawElementsInstancedARB = (PFNGLDRAWELEMENTSINSTANCEDARBPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementsInstancedARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_draw_instanced */\n\n#ifdef GL_ARB_fragment_program\n\n#endif /* GL_ARB_fragment_program */\n\n#ifdef GL_ARB_fragment_program_shadow\n\n#endif /* GL_ARB_fragment_program_shadow */\n\n#ifdef GL_ARB_fragment_shader\n\n#endif /* GL_ARB_fragment_shader */\n\n#ifdef GL_ARB_framebuffer_object\n\nstatic GLboolean _glewInit_GL_ARB_framebuffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindFramebuffer\")) == NULL) || r;\n  r = ((glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBindRenderbuffer\")) == NULL) || r;\n  r = ((glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glBlitFramebuffer\")) == NULL) || r;\n  r = ((glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)glewGetProcAddress((const GLubyte*)\"glCheckFramebufferStatus\")) == NULL) || r;\n  r = ((glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFramebuffers\")) == NULL) || r;\n  r = ((glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteRenderbuffers\")) == NULL) || r;\n  r = ((glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferRenderbuffer\")) == NULL) || r;\n  r = ((glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayer\")) == NULL) || r;\n  r = ((glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture1D\")) == NULL) || r;\n  r = ((glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture2D\")) == NULL) || r;\n  r = ((glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture3D\")) == NULL) || r;\n  r = ((glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenFramebuffers\")) == NULL) || r;\n  r = ((glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)glewGetProcAddress((const GLubyte*)\"glGenRenderbuffers\")) == NULL) || r;\n  r = ((glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMipmap\")) == NULL) || r;\n  r = ((glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferAttachmentParameteriv\")) == NULL) || r;\n  r = ((glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetRenderbufferParameteriv\")) == NULL) || r;\n  r = ((glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsFramebuffer\")) == NULL) || r;\n  r = ((glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glIsRenderbuffer\")) == NULL) || r;\n  r = ((glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorage\")) == NULL) || r;\n  r = ((glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisample\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_framebuffer_object */\n\n#ifdef GL_ARB_framebuffer_sRGB\n\n#endif /* GL_ARB_framebuffer_sRGB */\n\n#ifdef GL_ARB_geometry_shader4\n\nstatic GLboolean _glewInit_GL_ARB_geometry_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFramebufferTextureARB = (PFNGLFRAMEBUFFERTEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureARB\")) == NULL) || r;\n  r = ((glFramebufferTextureFaceARB = (PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureFaceARB\")) == NULL) || r;\n  r = ((glFramebufferTextureLayerARB = (PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayerARB\")) == NULL) || r;\n  r = ((glProgramParameteriARB = (PFNGLPROGRAMPARAMETERIARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameteriARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_geometry_shader4 */\n\n#ifdef GL_ARB_half_float_pixel\n\n#endif /* GL_ARB_half_float_pixel */\n\n#ifdef GL_ARB_half_float_vertex\n\n#endif /* GL_ARB_half_float_vertex */\n\n#ifdef GL_ARB_imaging\n\nstatic GLboolean _glewInit_GL_ARB_imaging (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquation = (PFNGLBLENDEQUATIONPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquation\")) == NULL) || r;\n  r = ((glColorSubTable = (PFNGLCOLORSUBTABLEPROC)glewGetProcAddress((const GLubyte*)\"glColorSubTable\")) == NULL) || r;\n  r = ((glColorTable = (PFNGLCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glColorTable\")) == NULL) || r;\n  r = ((glColorTableParameterfv = (PFNGLCOLORTABLEPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterfv\")) == NULL) || r;\n  r = ((glColorTableParameteriv = (PFNGLCOLORTABLEPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameteriv\")) == NULL) || r;\n  r = ((glConvolutionFilter1D = (PFNGLCONVOLUTIONFILTER1DPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter1D\")) == NULL) || r;\n  r = ((glConvolutionFilter2D = (PFNGLCONVOLUTIONFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter2D\")) == NULL) || r;\n  r = ((glConvolutionParameterf = (PFNGLCONVOLUTIONPARAMETERFPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterf\")) == NULL) || r;\n  r = ((glConvolutionParameterfv = (PFNGLCONVOLUTIONPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfv\")) == NULL) || r;\n  r = ((glConvolutionParameteri = (PFNGLCONVOLUTIONPARAMETERIPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteri\")) == NULL) || r;\n  r = ((glConvolutionParameteriv = (PFNGLCONVOLUTIONPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteriv\")) == NULL) || r;\n  r = ((glCopyColorSubTable = (PFNGLCOPYCOLORSUBTABLEPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorSubTable\")) == NULL) || r;\n  r = ((glCopyColorTable = (PFNGLCOPYCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorTable\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter1D = (PFNGLCOPYCONVOLUTIONFILTER1DPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter1D\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter2D = (PFNGLCOPYCONVOLUTIONFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter2D\")) == NULL) || r;\n  r = ((glGetColorTable = (PFNGLGETCOLORTABLEPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTable\")) == NULL) || r;\n  r = ((glGetColorTableParameterfv = (PFNGLGETCOLORTABLEPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfv\")) == NULL) || r;\n  r = ((glGetColorTableParameteriv = (PFNGLGETCOLORTABLEPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameteriv\")) == NULL) || r;\n  r = ((glGetConvolutionFilter = (PFNGLGETCONVOLUTIONFILTERPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionFilter\")) == NULL) || r;\n  r = ((glGetConvolutionParameterfv = (PFNGLGETCONVOLUTIONPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterfv\")) == NULL) || r;\n  r = ((glGetConvolutionParameteriv = (PFNGLGETCONVOLUTIONPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameteriv\")) == NULL) || r;\n  r = ((glGetHistogram = (PFNGLGETHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogram\")) == NULL) || r;\n  r = ((glGetHistogramParameterfv = (PFNGLGETHISTOGRAMPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterfv\")) == NULL) || r;\n  r = ((glGetHistogramParameteriv = (PFNGLGETHISTOGRAMPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameteriv\")) == NULL) || r;\n  r = ((glGetMinmax = (PFNGLGETMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmax\")) == NULL) || r;\n  r = ((glGetMinmaxParameterfv = (PFNGLGETMINMAXPARAMETERFVPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterfv\")) == NULL) || r;\n  r = ((glGetMinmaxParameteriv = (PFNGLGETMINMAXPARAMETERIVPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameteriv\")) == NULL) || r;\n  r = ((glGetSeparableFilter = (PFNGLGETSEPARABLEFILTERPROC)glewGetProcAddress((const GLubyte*)\"glGetSeparableFilter\")) == NULL) || r;\n  r = ((glHistogram = (PFNGLHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glHistogram\")) == NULL) || r;\n  r = ((glMinmax = (PFNGLMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glMinmax\")) == NULL) || r;\n  r = ((glResetHistogram = (PFNGLRESETHISTOGRAMPROC)glewGetProcAddress((const GLubyte*)\"glResetHistogram\")) == NULL) || r;\n  r = ((glResetMinmax = (PFNGLRESETMINMAXPROC)glewGetProcAddress((const GLubyte*)\"glResetMinmax\")) == NULL) || r;\n  r = ((glSeparableFilter2D = (PFNGLSEPARABLEFILTER2DPROC)glewGetProcAddress((const GLubyte*)\"glSeparableFilter2D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_imaging */\n\n#ifdef GL_ARB_instanced_arrays\n\nstatic GLboolean _glewInit_GL_ARB_instanced_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexAttribDivisorARB = (PFNGLVERTEXATTRIBDIVISORARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribDivisorARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_instanced_arrays */\n\n#ifdef GL_ARB_map_buffer_range\n\nstatic GLboolean _glewInit_GL_ARB_map_buffer_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glFlushMappedBufferRange\")) == NULL) || r;\n  r = ((glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)glewGetProcAddress((const GLubyte*)\"glMapBufferRange\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_map_buffer_range */\n\n#ifdef GL_ARB_matrix_palette\n\nstatic GLboolean _glewInit_GL_ARB_matrix_palette (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCurrentPaletteMatrixARB = (PFNGLCURRENTPALETTEMATRIXARBPROC)glewGetProcAddress((const GLubyte*)\"glCurrentPaletteMatrixARB\")) == NULL) || r;\n  r = ((glMatrixIndexPointerARB = (PFNGLMATRIXINDEXPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexPointerARB\")) == NULL) || r;\n  r = ((glMatrixIndexubvARB = (PFNGLMATRIXINDEXUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexubvARB\")) == NULL) || r;\n  r = ((glMatrixIndexuivARB = (PFNGLMATRIXINDEXUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexuivARB\")) == NULL) || r;\n  r = ((glMatrixIndexusvARB = (PFNGLMATRIXINDEXUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glMatrixIndexusvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_matrix_palette */\n\n#ifdef GL_ARB_multisample\n\nstatic GLboolean _glewInit_GL_ARB_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleCoverageARB = (PFNGLSAMPLECOVERAGEARBPROC)glewGetProcAddress((const GLubyte*)\"glSampleCoverageARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_multisample */\n\n#ifdef GL_ARB_multitexture\n\nstatic GLboolean _glewInit_GL_ARB_multitexture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glActiveTextureARB\")) == NULL) || r;\n  r = ((glClientActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveTextureARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1dARB = (PFNGLMULTITEXCOORD1DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1dvARB = (PFNGLMULTITEXCOORD1DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1fARB = (PFNGLMULTITEXCOORD1FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1fvARB = (PFNGLMULTITEXCOORD1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1iARB = (PFNGLMULTITEXCOORD1IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1ivARB = (PFNGLMULTITEXCOORD1IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1sARB = (PFNGLMULTITEXCOORD1SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord1svARB = (PFNGLMULTITEXCOORD1SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2dARB = (PFNGLMULTITEXCOORD2DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2dvARB = (PFNGLMULTITEXCOORD2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2fvARB = (PFNGLMULTITEXCOORD2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2iARB = (PFNGLMULTITEXCOORD2IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2ivARB = (PFNGLMULTITEXCOORD2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2sARB = (PFNGLMULTITEXCOORD2SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord2svARB = (PFNGLMULTITEXCOORD2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3dARB = (PFNGLMULTITEXCOORD3DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3dvARB = (PFNGLMULTITEXCOORD3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3fARB = (PFNGLMULTITEXCOORD3FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3fvARB = (PFNGLMULTITEXCOORD3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3iARB = (PFNGLMULTITEXCOORD3IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3ivARB = (PFNGLMULTITEXCOORD3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3sARB = (PFNGLMULTITEXCOORD3SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord3svARB = (PFNGLMULTITEXCOORD3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3svARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4dARB = (PFNGLMULTITEXCOORD4DARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4dvARB = (PFNGLMULTITEXCOORD4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4dvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4fvARB = (PFNGLMULTITEXCOORD4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4fvARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4iARB = (PFNGLMULTITEXCOORD4IARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4iARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4ivARB = (PFNGLMULTITEXCOORD4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4ivARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4sARB = (PFNGLMULTITEXCOORD4SARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4sARB\")) == NULL) || r;\n  r = ((glMultiTexCoord4svARB = (PFNGLMULTITEXCOORD4SVARBPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4svARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_multitexture */\n\n#ifdef GL_ARB_occlusion_query\n\nstatic GLboolean _glewInit_GL_ARB_occlusion_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginQueryARB = (PFNGLBEGINQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glBeginQueryARB\")) == NULL) || r;\n  r = ((glDeleteQueriesARB = (PFNGLDELETEQUERIESARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteQueriesARB\")) == NULL) || r;\n  r = ((glEndQueryARB = (PFNGLENDQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glEndQueryARB\")) == NULL) || r;\n  r = ((glGenQueriesARB = (PFNGLGENQUERIESARBPROC)glewGetProcAddress((const GLubyte*)\"glGenQueriesARB\")) == NULL) || r;\n  r = ((glGetQueryObjectivARB = (PFNGLGETQUERYOBJECTIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectivARB\")) == NULL) || r;\n  r = ((glGetQueryObjectuivARB = (PFNGLGETQUERYOBJECTUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectuivARB\")) == NULL) || r;\n  r = ((glGetQueryivARB = (PFNGLGETQUERYIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryivARB\")) == NULL) || r;\n  r = ((glIsQueryARB = (PFNGLISQUERYARBPROC)glewGetProcAddress((const GLubyte*)\"glIsQueryARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_occlusion_query */\n\n#ifdef GL_ARB_pixel_buffer_object\n\n#endif /* GL_ARB_pixel_buffer_object */\n\n#ifdef GL_ARB_point_parameters\n\nstatic GLboolean _glewInit_GL_ARB_point_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfARB\")) == NULL) || r;\n  r = ((glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_point_parameters */\n\n#ifdef GL_ARB_point_sprite\n\n#endif /* GL_ARB_point_sprite */\n\n#ifdef GL_ARB_shader_objects\n\nstatic GLboolean _glewInit_GL_ARB_shader_objects (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glAttachObjectARB\")) == NULL) || r;\n  r = ((glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC)glewGetProcAddress((const GLubyte*)\"glCompileShaderARB\")) == NULL) || r;\n  r = ((glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glCreateProgramObjectARB\")) == NULL) || r;\n  r = ((glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glCreateShaderObjectARB\")) == NULL) || r;\n  r = ((glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteObjectARB\")) == NULL) || r;\n  r = ((glDetachObjectARB = (PFNGLDETACHOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glDetachObjectARB\")) == NULL) || r;\n  r = ((glGetActiveUniformARB = (PFNGLGETACTIVEUNIFORMARBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveUniformARB\")) == NULL) || r;\n  r = ((glGetAttachedObjectsARB = (PFNGLGETATTACHEDOBJECTSARBPROC)glewGetProcAddress((const GLubyte*)\"glGetAttachedObjectsARB\")) == NULL) || r;\n  r = ((glGetHandleARB = (PFNGLGETHANDLEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetHandleARB\")) == NULL) || r;\n  r = ((glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC)glewGetProcAddress((const GLubyte*)\"glGetInfoLogARB\")) == NULL) || r;\n  r = ((glGetObjectParameterfvARB = (PFNGLGETOBJECTPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectParameterfvARB\")) == NULL) || r;\n  r = ((glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectParameterivARB\")) == NULL) || r;\n  r = ((glGetShaderSourceARB = (PFNGLGETSHADERSOURCEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetShaderSourceARB\")) == NULL) || r;\n  r = ((glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformLocationARB\")) == NULL) || r;\n  r = ((glGetUniformfvARB = (PFNGLGETUNIFORMFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformfvARB\")) == NULL) || r;\n  r = ((glGetUniformivARB = (PFNGLGETUNIFORMIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformivARB\")) == NULL) || r;\n  r = ((glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glLinkProgramARB\")) == NULL) || r;\n  r = ((glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC)glewGetProcAddress((const GLubyte*)\"glShaderSourceARB\")) == NULL) || r;\n  r = ((glUniform1fARB = (PFNGLUNIFORM1FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fARB\")) == NULL) || r;\n  r = ((glUniform1fvARB = (PFNGLUNIFORM1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1fvARB\")) == NULL) || r;\n  r = ((glUniform1iARB = (PFNGLUNIFORM1IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1iARB\")) == NULL) || r;\n  r = ((glUniform1ivARB = (PFNGLUNIFORM1IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform1ivARB\")) == NULL) || r;\n  r = ((glUniform2fARB = (PFNGLUNIFORM2FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fARB\")) == NULL) || r;\n  r = ((glUniform2fvARB = (PFNGLUNIFORM2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2fvARB\")) == NULL) || r;\n  r = ((glUniform2iARB = (PFNGLUNIFORM2IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2iARB\")) == NULL) || r;\n  r = ((glUniform2ivARB = (PFNGLUNIFORM2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform2ivARB\")) == NULL) || r;\n  r = ((glUniform3fARB = (PFNGLUNIFORM3FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fARB\")) == NULL) || r;\n  r = ((glUniform3fvARB = (PFNGLUNIFORM3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3fvARB\")) == NULL) || r;\n  r = ((glUniform3iARB = (PFNGLUNIFORM3IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3iARB\")) == NULL) || r;\n  r = ((glUniform3ivARB = (PFNGLUNIFORM3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform3ivARB\")) == NULL) || r;\n  r = ((glUniform4fARB = (PFNGLUNIFORM4FARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fARB\")) == NULL) || r;\n  r = ((glUniform4fvARB = (PFNGLUNIFORM4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4fvARB\")) == NULL) || r;\n  r = ((glUniform4iARB = (PFNGLUNIFORM4IARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4iARB\")) == NULL) || r;\n  r = ((glUniform4ivARB = (PFNGLUNIFORM4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniform4ivARB\")) == NULL) || r;\n  r = ((glUniformMatrix2fvARB = (PFNGLUNIFORMMATRIX2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix2fvARB\")) == NULL) || r;\n  r = ((glUniformMatrix3fvARB = (PFNGLUNIFORMMATRIX3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix3fvARB\")) == NULL) || r;\n  r = ((glUniformMatrix4fvARB = (PFNGLUNIFORMMATRIX4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glUniformMatrix4fvARB\")) == NULL) || r;\n  r = ((glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC)glewGetProcAddress((const GLubyte*)\"glUseProgramObjectARB\")) == NULL) || r;\n  r = ((glValidateProgramARB = (PFNGLVALIDATEPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glValidateProgramARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_shader_objects */\n\n#ifdef GL_ARB_shading_language_100\n\n#endif /* GL_ARB_shading_language_100 */\n\n#ifdef GL_ARB_shadow\n\n#endif /* GL_ARB_shadow */\n\n#ifdef GL_ARB_shadow_ambient\n\n#endif /* GL_ARB_shadow_ambient */\n\n#ifdef GL_ARB_texture_border_clamp\n\n#endif /* GL_ARB_texture_border_clamp */\n\n#ifdef GL_ARB_texture_buffer_object\n\nstatic GLboolean _glewInit_GL_ARB_texture_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexBufferARB = (PFNGLTEXBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glTexBufferARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_texture_buffer_object */\n\n#ifdef GL_ARB_texture_compression\n\nstatic GLboolean _glewInit_GL_ARB_texture_compression (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCompressedTexImage1DARB = (PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage1DARB\")) == NULL) || r;\n  r = ((glCompressedTexImage2DARB = (PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage2DARB\")) == NULL) || r;\n  r = ((glCompressedTexImage3DARB = (PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexImage3DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage1DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage1DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage2DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage2DARB\")) == NULL) || r;\n  r = ((glCompressedTexSubImage3DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTexSubImage3DARB\")) == NULL) || r;\n  r = ((glGetCompressedTexImageARB = (PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTexImageARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_texture_compression */\n\n#ifdef GL_ARB_texture_compression_rgtc\n\n#endif /* GL_ARB_texture_compression_rgtc */\n\n#ifdef GL_ARB_texture_cube_map\n\n#endif /* GL_ARB_texture_cube_map */\n\n#ifdef GL_ARB_texture_env_add\n\n#endif /* GL_ARB_texture_env_add */\n\n#ifdef GL_ARB_texture_env_combine\n\n#endif /* GL_ARB_texture_env_combine */\n\n#ifdef GL_ARB_texture_env_crossbar\n\n#endif /* GL_ARB_texture_env_crossbar */\n\n#ifdef GL_ARB_texture_env_dot3\n\n#endif /* GL_ARB_texture_env_dot3 */\n\n#ifdef GL_ARB_texture_float\n\n#endif /* GL_ARB_texture_float */\n\n#ifdef GL_ARB_texture_mirrored_repeat\n\n#endif /* GL_ARB_texture_mirrored_repeat */\n\n#ifdef GL_ARB_texture_non_power_of_two\n\n#endif /* GL_ARB_texture_non_power_of_two */\n\n#ifdef GL_ARB_texture_rectangle\n\n#endif /* GL_ARB_texture_rectangle */\n\n#ifdef GL_ARB_texture_rg\n\n#endif /* GL_ARB_texture_rg */\n\n#ifdef GL_ARB_transpose_matrix\n\nstatic GLboolean _glewInit_GL_ARB_transpose_matrix (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glLoadTransposeMatrixdARB = (PFNGLLOADTRANSPOSEMATRIXDARBPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixdARB\")) == NULL) || r;\n  r = ((glLoadTransposeMatrixfARB = (PFNGLLOADTRANSPOSEMATRIXFARBPROC)glewGetProcAddress((const GLubyte*)\"glLoadTransposeMatrixfARB\")) == NULL) || r;\n  r = ((glMultTransposeMatrixdARB = (PFNGLMULTTRANSPOSEMATRIXDARBPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixdARB\")) == NULL) || r;\n  r = ((glMultTransposeMatrixfARB = (PFNGLMULTTRANSPOSEMATRIXFARBPROC)glewGetProcAddress((const GLubyte*)\"glMultTransposeMatrixfARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_transpose_matrix */\n\n#ifdef GL_ARB_vertex_array_object\n\nstatic GLboolean _glewInit_GL_ARB_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexArray\")) == NULL) || r;\n  r = ((glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexArrays\")) == NULL) || r;\n  r = ((glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexArrays\")) == NULL) || r;\n  r = ((glIsVertexArray = (PFNGLISVERTEXARRAYPROC)glewGetProcAddress((const GLubyte*)\"glIsVertexArray\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_array_object */\n\n#ifdef GL_ARB_vertex_blend\n\nstatic GLboolean _glewInit_GL_ARB_vertex_blend (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexBlendARB = (PFNGLVERTEXBLENDARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendARB\")) == NULL) || r;\n  r = ((glWeightPointerARB = (PFNGLWEIGHTPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightPointerARB\")) == NULL) || r;\n  r = ((glWeightbvARB = (PFNGLWEIGHTBVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightbvARB\")) == NULL) || r;\n  r = ((glWeightdvARB = (PFNGLWEIGHTDVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightdvARB\")) == NULL) || r;\n  r = ((glWeightfvARB = (PFNGLWEIGHTFVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightfvARB\")) == NULL) || r;\n  r = ((glWeightivARB = (PFNGLWEIGHTIVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightivARB\")) == NULL) || r;\n  r = ((glWeightsvARB = (PFNGLWEIGHTSVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightsvARB\")) == NULL) || r;\n  r = ((glWeightubvARB = (PFNGLWEIGHTUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightubvARB\")) == NULL) || r;\n  r = ((glWeightuivARB = (PFNGLWEIGHTUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightuivARB\")) == NULL) || r;\n  r = ((glWeightusvARB = (PFNGLWEIGHTUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glWeightusvARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_blend */\n\n#ifdef GL_ARB_vertex_buffer_object\n\nstatic GLboolean _glewInit_GL_ARB_vertex_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindBufferARB = (PFNGLBINDBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferARB\")) == NULL) || r;\n  r = ((glBufferDataARB = (PFNGLBUFFERDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glBufferDataARB\")) == NULL) || r;\n  r = ((glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glBufferSubDataARB\")) == NULL) || r;\n  r = ((glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBuffersARB\")) == NULL) || r;\n  r = ((glGenBuffersARB = (PFNGLGENBUFFERSARBPROC)glewGetProcAddress((const GLubyte*)\"glGenBuffersARB\")) == NULL) || r;\n  r = ((glGetBufferParameterivARB = (PFNGLGETBUFFERPARAMETERIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferParameterivARB\")) == NULL) || r;\n  r = ((glGetBufferPointervARB = (PFNGLGETBUFFERPOINTERVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferPointervARB\")) == NULL) || r;\n  r = ((glGetBufferSubDataARB = (PFNGLGETBUFFERSUBDATAARBPROC)glewGetProcAddress((const GLubyte*)\"glGetBufferSubDataARB\")) == NULL) || r;\n  r = ((glIsBufferARB = (PFNGLISBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glIsBufferARB\")) == NULL) || r;\n  r = ((glMapBufferARB = (PFNGLMAPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glMapBufferARB\")) == NULL) || r;\n  r = ((glUnmapBufferARB = (PFNGLUNMAPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"glUnmapBufferARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_buffer_object */\n\n#ifdef GL_ARB_vertex_program\n\nstatic GLboolean _glewInit_GL_ARB_vertex_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindProgramARB = (PFNGLBINDPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glBindProgramARB\")) == NULL) || r;\n  r = ((glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgramsARB\")) == NULL) || r;\n  r = ((glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)glewGetProcAddress((const GLubyte*)\"glDisableVertexAttribArrayARB\")) == NULL) || r;\n  r = ((glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC)glewGetProcAddress((const GLubyte*)\"glEnableVertexAttribArrayARB\")) == NULL) || r;\n  r = ((glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC)glewGetProcAddress((const GLubyte*)\"glGenProgramsARB\")) == NULL) || r;\n  r = ((glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramEnvParameterdvARB\")) == NULL) || r;\n  r = ((glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramEnvParameterfvARB\")) == NULL) || r;\n  r = ((glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramLocalParameterdvARB\")) == NULL) || r;\n  r = ((glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramLocalParameterfvARB\")) == NULL) || r;\n  r = ((glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramStringARB\")) == NULL) || r;\n  r = ((glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramivARB\")) == NULL) || r;\n  r = ((glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointervARB\")) == NULL) || r;\n  r = ((glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdvARB\")) == NULL) || r;\n  r = ((glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfvARB\")) == NULL) || r;\n  r = ((glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribivARB\")) == NULL) || r;\n  r = ((glIsProgramARB = (PFNGLISPROGRAMARBPROC)glewGetProcAddress((const GLubyte*)\"glIsProgramARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4dARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4dvARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4fARB\")) == NULL) || r;\n  r = ((glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameter4fvARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4dARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4dvARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4fARB\")) == NULL) || r;\n  r = ((glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameter4fvARB\")) == NULL) || r;\n  r = ((glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"glProgramStringARB\")) == NULL) || r;\n  r = ((glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dARB\")) == NULL) || r;\n  r = ((glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fARB\")) == NULL) || r;\n  r = ((glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sARB\")) == NULL) || r;\n  r = ((glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1svARB\")) == NULL) || r;\n  r = ((glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dARB\")) == NULL) || r;\n  r = ((glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fARB\")) == NULL) || r;\n  r = ((glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sARB\")) == NULL) || r;\n  r = ((glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2svARB\")) == NULL) || r;\n  r = ((glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dARB\")) == NULL) || r;\n  r = ((glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fARB\")) == NULL) || r;\n  r = ((glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sARB\")) == NULL) || r;\n  r = ((glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3svARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NbvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NsvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NubARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NubvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NuivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4NusvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4bvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dARB\")) == NULL) || r;\n  r = ((glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fARB\")) == NULL) || r;\n  r = ((glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sARB\")) == NULL) || r;\n  r = ((glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4svARB\")) == NULL) || r;\n  r = ((glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubvARB\")) == NULL) || r;\n  r = ((glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4uivARB\")) == NULL) || r;\n  r = ((glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4usvARB\")) == NULL) || r;\n  r = ((glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointerARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_program */\n\n#ifdef GL_ARB_vertex_shader\n\nstatic GLboolean _glewInit_GL_ARB_vertex_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindAttribLocationARB = (PFNGLBINDATTRIBLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glBindAttribLocationARB\")) == NULL) || r;\n  r = ((glGetActiveAttribARB = (PFNGLGETACTIVEATTRIBARBPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveAttribARB\")) == NULL) || r;\n  r = ((glGetAttribLocationARB = (PFNGLGETATTRIBLOCATIONARBPROC)glewGetProcAddress((const GLubyte*)\"glGetAttribLocationARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_vertex_shader */\n\n#ifdef GL_ARB_window_pos\n\nstatic GLboolean _glewInit_GL_ARB_window_pos (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glWindowPos2dARB = (PFNGLWINDOWPOS2DARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dARB\")) == NULL) || r;\n  r = ((glWindowPos2dvARB = (PFNGLWINDOWPOS2DVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dvARB\")) == NULL) || r;\n  r = ((glWindowPos2fARB = (PFNGLWINDOWPOS2FARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fARB\")) == NULL) || r;\n  r = ((glWindowPos2fvARB = (PFNGLWINDOWPOS2FVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fvARB\")) == NULL) || r;\n  r = ((glWindowPos2iARB = (PFNGLWINDOWPOS2IARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iARB\")) == NULL) || r;\n  r = ((glWindowPos2ivARB = (PFNGLWINDOWPOS2IVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2ivARB\")) == NULL) || r;\n  r = ((glWindowPos2sARB = (PFNGLWINDOWPOS2SARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sARB\")) == NULL) || r;\n  r = ((glWindowPos2svARB = (PFNGLWINDOWPOS2SVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2svARB\")) == NULL) || r;\n  r = ((glWindowPos3dARB = (PFNGLWINDOWPOS3DARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dARB\")) == NULL) || r;\n  r = ((glWindowPos3dvARB = (PFNGLWINDOWPOS3DVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dvARB\")) == NULL) || r;\n  r = ((glWindowPos3fARB = (PFNGLWINDOWPOS3FARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fARB\")) == NULL) || r;\n  r = ((glWindowPos3fvARB = (PFNGLWINDOWPOS3FVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fvARB\")) == NULL) || r;\n  r = ((glWindowPos3iARB = (PFNGLWINDOWPOS3IARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iARB\")) == NULL) || r;\n  r = ((glWindowPos3ivARB = (PFNGLWINDOWPOS3IVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3ivARB\")) == NULL) || r;\n  r = ((glWindowPos3sARB = (PFNGLWINDOWPOS3SARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sARB\")) == NULL) || r;\n  r = ((glWindowPos3svARB = (PFNGLWINDOWPOS3SVARBPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3svARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ARB_window_pos */\n\n#ifdef GL_ATIX_point_sprites\n\n#endif /* GL_ATIX_point_sprites */\n\n#ifdef GL_ATIX_texture_env_combine3\n\n#endif /* GL_ATIX_texture_env_combine3 */\n\n#ifdef GL_ATIX_texture_env_route\n\n#endif /* GL_ATIX_texture_env_route */\n\n#ifdef GL_ATIX_vertex_shader_output_point_size\n\n#endif /* GL_ATIX_vertex_shader_output_point_size */\n\n#ifdef GL_ATI_draw_buffers\n\nstatic GLboolean _glewInit_GL_ATI_draw_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawBuffersATI = (PFNGLDRAWBUFFERSATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawBuffersATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_draw_buffers */\n\n#ifdef GL_ATI_element_array\n\nstatic GLboolean _glewInit_GL_ATI_element_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawElementArrayATI = (PFNGLDRAWELEMENTARRAYATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementArrayATI\")) == NULL) || r;\n  r = ((glDrawRangeElementArrayATI = (PFNGLDRAWRANGEELEMENTARRAYATIPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementArrayATI\")) == NULL) || r;\n  r = ((glElementPointerATI = (PFNGLELEMENTPOINTERATIPROC)glewGetProcAddress((const GLubyte*)\"glElementPointerATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_element_array */\n\n#ifdef GL_ATI_envmap_bumpmap\n\nstatic GLboolean _glewInit_GL_ATI_envmap_bumpmap (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexBumpParameterfvATI = (PFNGLGETTEXBUMPPARAMETERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetTexBumpParameterfvATI\")) == NULL) || r;\n  r = ((glGetTexBumpParameterivATI = (PFNGLGETTEXBUMPPARAMETERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetTexBumpParameterivATI\")) == NULL) || r;\n  r = ((glTexBumpParameterfvATI = (PFNGLTEXBUMPPARAMETERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glTexBumpParameterfvATI\")) == NULL) || r;\n  r = ((glTexBumpParameterivATI = (PFNGLTEXBUMPPARAMETERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glTexBumpParameterivATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_envmap_bumpmap */\n\n#ifdef GL_ATI_fragment_shader\n\nstatic GLboolean _glewInit_GL_ATI_fragment_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAlphaFragmentOp1ATI = (PFNGLALPHAFRAGMENTOP1ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp1ATI\")) == NULL) || r;\n  r = ((glAlphaFragmentOp2ATI = (PFNGLALPHAFRAGMENTOP2ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp2ATI\")) == NULL) || r;\n  r = ((glAlphaFragmentOp3ATI = (PFNGLALPHAFRAGMENTOP3ATIPROC)glewGetProcAddress((const GLubyte*)\"glAlphaFragmentOp3ATI\")) == NULL) || r;\n  r = ((glBeginFragmentShaderATI = (PFNGLBEGINFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glBeginFragmentShaderATI\")) == NULL) || r;\n  r = ((glBindFragmentShaderATI = (PFNGLBINDFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glBindFragmentShaderATI\")) == NULL) || r;\n  r = ((glColorFragmentOp1ATI = (PFNGLCOLORFRAGMENTOP1ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp1ATI\")) == NULL) || r;\n  r = ((glColorFragmentOp2ATI = (PFNGLCOLORFRAGMENTOP2ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp2ATI\")) == NULL) || r;\n  r = ((glColorFragmentOp3ATI = (PFNGLCOLORFRAGMENTOP3ATIPROC)glewGetProcAddress((const GLubyte*)\"glColorFragmentOp3ATI\")) == NULL) || r;\n  r = ((glDeleteFragmentShaderATI = (PFNGLDELETEFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFragmentShaderATI\")) == NULL) || r;\n  r = ((glEndFragmentShaderATI = (PFNGLENDFRAGMENTSHADERATIPROC)glewGetProcAddress((const GLubyte*)\"glEndFragmentShaderATI\")) == NULL) || r;\n  r = ((glGenFragmentShadersATI = (PFNGLGENFRAGMENTSHADERSATIPROC)glewGetProcAddress((const GLubyte*)\"glGenFragmentShadersATI\")) == NULL) || r;\n  r = ((glPassTexCoordATI = (PFNGLPASSTEXCOORDATIPROC)glewGetProcAddress((const GLubyte*)\"glPassTexCoordATI\")) == NULL) || r;\n  r = ((glSampleMapATI = (PFNGLSAMPLEMAPATIPROC)glewGetProcAddress((const GLubyte*)\"glSampleMapATI\")) == NULL) || r;\n  r = ((glSetFragmentShaderConstantATI = (PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)glewGetProcAddress((const GLubyte*)\"glSetFragmentShaderConstantATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_fragment_shader */\n\n#ifdef GL_ATI_map_object_buffer\n\nstatic GLboolean _glewInit_GL_ATI_map_object_buffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMapObjectBufferATI = (PFNGLMAPOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glMapObjectBufferATI\")) == NULL) || r;\n  r = ((glUnmapObjectBufferATI = (PFNGLUNMAPOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glUnmapObjectBufferATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_map_object_buffer */\n\n#ifdef GL_ATI_pn_triangles\n\nstatic GLboolean _glewInit_GL_ATI_pn_triangles (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPNTrianglesfATI = (PFNGLPNTRIANGLESFATIPROC)glewGetProcAddress((const GLubyte*)\"glPNTrianglesfATI\")) == NULL) || r;\n  r = ((glPNTrianglesiATI = (PFNGLPNTRIANGLESIATIPROC)glewGetProcAddress((const GLubyte*)\"glPNTrianglesiATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_pn_triangles */\n\n#ifdef GL_ATI_separate_stencil\n\nstatic GLboolean _glewInit_GL_ATI_separate_stencil (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glStencilFuncSeparateATI = (PFNGLSTENCILFUNCSEPARATEATIPROC)glewGetProcAddress((const GLubyte*)\"glStencilFuncSeparateATI\")) == NULL) || r;\n  r = ((glStencilOpSeparateATI = (PFNGLSTENCILOPSEPARATEATIPROC)glewGetProcAddress((const GLubyte*)\"glStencilOpSeparateATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_separate_stencil */\n\n#ifdef GL_ATI_shader_texture_lod\n\n#endif /* GL_ATI_shader_texture_lod */\n\n#ifdef GL_ATI_text_fragment_shader\n\n#endif /* GL_ATI_text_fragment_shader */\n\n#ifdef GL_ATI_texture_compression_3dc\n\n#endif /* GL_ATI_texture_compression_3dc */\n\n#ifdef GL_ATI_texture_env_combine3\n\n#endif /* GL_ATI_texture_env_combine3 */\n\n#ifdef GL_ATI_texture_float\n\n#endif /* GL_ATI_texture_float */\n\n#ifdef GL_ATI_texture_mirror_once\n\n#endif /* GL_ATI_texture_mirror_once */\n\n#ifdef GL_ATI_vertex_array_object\n\nstatic GLboolean _glewInit_GL_ATI_vertex_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glArrayObjectATI = (PFNGLARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glArrayObjectATI\")) == NULL) || r;\n  r = ((glFreeObjectBufferATI = (PFNGLFREEOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glFreeObjectBufferATI\")) == NULL) || r;\n  r = ((glGetArrayObjectfvATI = (PFNGLGETARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetArrayObjectivATI = (PFNGLGETARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetArrayObjectivATI\")) == NULL) || r;\n  r = ((glGetObjectBufferfvATI = (PFNGLGETOBJECTBUFFERFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectBufferfvATI\")) == NULL) || r;\n  r = ((glGetObjectBufferivATI = (PFNGLGETOBJECTBUFFERIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetObjectBufferivATI\")) == NULL) || r;\n  r = ((glGetVariantArrayObjectfvATI = (PFNGLGETVARIANTARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetVariantArrayObjectivATI = (PFNGLGETVARIANTARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantArrayObjectivATI\")) == NULL) || r;\n  r = ((glIsObjectBufferATI = (PFNGLISOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glIsObjectBufferATI\")) == NULL) || r;\n  r = ((glNewObjectBufferATI = (PFNGLNEWOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glNewObjectBufferATI\")) == NULL) || r;\n  r = ((glUpdateObjectBufferATI = (PFNGLUPDATEOBJECTBUFFERATIPROC)glewGetProcAddress((const GLubyte*)\"glUpdateObjectBufferATI\")) == NULL) || r;\n  r = ((glVariantArrayObjectATI = (PFNGLVARIANTARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glVariantArrayObjectATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_array_object */\n\n#ifdef GL_ATI_vertex_attrib_array_object\n\nstatic GLboolean _glewInit_GL_ATI_vertex_attrib_array_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetVertexAttribArrayObjectfvATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribArrayObjectfvATI\")) == NULL) || r;\n  r = ((glGetVertexAttribArrayObjectivATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribArrayObjectivATI\")) == NULL) || r;\n  r = ((glVertexAttribArrayObjectATI = (PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribArrayObjectATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_attrib_array_object */\n\n#ifdef GL_ATI_vertex_streams\n\nstatic GLboolean _glewInit_GL_ATI_vertex_streams (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClientActiveVertexStreamATI = (PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)glewGetProcAddress((const GLubyte*)\"glClientActiveVertexStreamATI\")) == NULL) || r;\n  r = ((glNormalStream3bATI = (PFNGLNORMALSTREAM3BATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3bATI\")) == NULL) || r;\n  r = ((glNormalStream3bvATI = (PFNGLNORMALSTREAM3BVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3bvATI\")) == NULL) || r;\n  r = ((glNormalStream3dATI = (PFNGLNORMALSTREAM3DATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3dATI\")) == NULL) || r;\n  r = ((glNormalStream3dvATI = (PFNGLNORMALSTREAM3DVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3dvATI\")) == NULL) || r;\n  r = ((glNormalStream3fATI = (PFNGLNORMALSTREAM3FATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3fATI\")) == NULL) || r;\n  r = ((glNormalStream3fvATI = (PFNGLNORMALSTREAM3FVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3fvATI\")) == NULL) || r;\n  r = ((glNormalStream3iATI = (PFNGLNORMALSTREAM3IATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3iATI\")) == NULL) || r;\n  r = ((glNormalStream3ivATI = (PFNGLNORMALSTREAM3IVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3ivATI\")) == NULL) || r;\n  r = ((glNormalStream3sATI = (PFNGLNORMALSTREAM3SATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3sATI\")) == NULL) || r;\n  r = ((glNormalStream3svATI = (PFNGLNORMALSTREAM3SVATIPROC)glewGetProcAddress((const GLubyte*)\"glNormalStream3svATI\")) == NULL) || r;\n  r = ((glVertexBlendEnvfATI = (PFNGLVERTEXBLENDENVFATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendEnvfATI\")) == NULL) || r;\n  r = ((glVertexBlendEnviATI = (PFNGLVERTEXBLENDENVIATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexBlendEnviATI\")) == NULL) || r;\n  r = ((glVertexStream2dATI = (PFNGLVERTEXSTREAM2DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2dATI\")) == NULL) || r;\n  r = ((glVertexStream2dvATI = (PFNGLVERTEXSTREAM2DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2dvATI\")) == NULL) || r;\n  r = ((glVertexStream2fATI = (PFNGLVERTEXSTREAM2FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2fATI\")) == NULL) || r;\n  r = ((glVertexStream2fvATI = (PFNGLVERTEXSTREAM2FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2fvATI\")) == NULL) || r;\n  r = ((glVertexStream2iATI = (PFNGLVERTEXSTREAM2IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2iATI\")) == NULL) || r;\n  r = ((glVertexStream2ivATI = (PFNGLVERTEXSTREAM2IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2ivATI\")) == NULL) || r;\n  r = ((glVertexStream2sATI = (PFNGLVERTEXSTREAM2SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2sATI\")) == NULL) || r;\n  r = ((glVertexStream2svATI = (PFNGLVERTEXSTREAM2SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream2svATI\")) == NULL) || r;\n  r = ((glVertexStream3dATI = (PFNGLVERTEXSTREAM3DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3dATI\")) == NULL) || r;\n  r = ((glVertexStream3dvATI = (PFNGLVERTEXSTREAM3DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3dvATI\")) == NULL) || r;\n  r = ((glVertexStream3fATI = (PFNGLVERTEXSTREAM3FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3fATI\")) == NULL) || r;\n  r = ((glVertexStream3fvATI = (PFNGLVERTEXSTREAM3FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3fvATI\")) == NULL) || r;\n  r = ((glVertexStream3iATI = (PFNGLVERTEXSTREAM3IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3iATI\")) == NULL) || r;\n  r = ((glVertexStream3ivATI = (PFNGLVERTEXSTREAM3IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3ivATI\")) == NULL) || r;\n  r = ((glVertexStream3sATI = (PFNGLVERTEXSTREAM3SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3sATI\")) == NULL) || r;\n  r = ((glVertexStream3svATI = (PFNGLVERTEXSTREAM3SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream3svATI\")) == NULL) || r;\n  r = ((glVertexStream4dATI = (PFNGLVERTEXSTREAM4DATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4dATI\")) == NULL) || r;\n  r = ((glVertexStream4dvATI = (PFNGLVERTEXSTREAM4DVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4dvATI\")) == NULL) || r;\n  r = ((glVertexStream4fATI = (PFNGLVERTEXSTREAM4FATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4fATI\")) == NULL) || r;\n  r = ((glVertexStream4fvATI = (PFNGLVERTEXSTREAM4FVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4fvATI\")) == NULL) || r;\n  r = ((glVertexStream4iATI = (PFNGLVERTEXSTREAM4IATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4iATI\")) == NULL) || r;\n  r = ((glVertexStream4ivATI = (PFNGLVERTEXSTREAM4IVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4ivATI\")) == NULL) || r;\n  r = ((glVertexStream4sATI = (PFNGLVERTEXSTREAM4SATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4sATI\")) == NULL) || r;\n  r = ((glVertexStream4svATI = (PFNGLVERTEXSTREAM4SVATIPROC)glewGetProcAddress((const GLubyte*)\"glVertexStream4svATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_ATI_vertex_streams */\n\n#ifdef GL_EXT_422_pixels\n\n#endif /* GL_EXT_422_pixels */\n\n#ifdef GL_EXT_Cg_shader\n\n#endif /* GL_EXT_Cg_shader */\n\n#ifdef GL_EXT_abgr\n\n#endif /* GL_EXT_abgr */\n\n#ifdef GL_EXT_bgra\n\n#endif /* GL_EXT_bgra */\n\n#ifdef GL_EXT_bindable_uniform\n\nstatic GLboolean _glewInit_GL_EXT_bindable_uniform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetUniformBufferSizeEXT = (PFNGLGETUNIFORMBUFFERSIZEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformBufferSizeEXT\")) == NULL) || r;\n  r = ((glGetUniformOffsetEXT = (PFNGLGETUNIFORMOFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformOffsetEXT\")) == NULL) || r;\n  r = ((glUniformBufferEXT = (PFNGLUNIFORMBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glUniformBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_bindable_uniform */\n\n#ifdef GL_EXT_blend_color\n\nstatic GLboolean _glewInit_GL_EXT_blend_color (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendColorEXT = (PFNGLBLENDCOLOREXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendColorEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_color */\n\n#ifdef GL_EXT_blend_equation_separate\n\nstatic GLboolean _glewInit_GL_EXT_blend_equation_separate (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquationSeparateEXT = (PFNGLBLENDEQUATIONSEPARATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationSeparateEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_equation_separate */\n\n#ifdef GL_EXT_blend_func_separate\n\nstatic GLboolean _glewInit_GL_EXT_blend_func_separate (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendFuncSeparateEXT = (PFNGLBLENDFUNCSEPARATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendFuncSeparateEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_func_separate */\n\n#ifdef GL_EXT_blend_logic_op\n\n#endif /* GL_EXT_blend_logic_op */\n\n#ifdef GL_EXT_blend_minmax\n\nstatic GLboolean _glewInit_GL_EXT_blend_minmax (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlendEquationEXT = (PFNGLBLENDEQUATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glBlendEquationEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_blend_minmax */\n\n#ifdef GL_EXT_blend_subtract\n\n#endif /* GL_EXT_blend_subtract */\n\n#ifdef GL_EXT_clip_volume_hint\n\n#endif /* GL_EXT_clip_volume_hint */\n\n#ifdef GL_EXT_cmyka\n\n#endif /* GL_EXT_cmyka */\n\n#ifdef GL_EXT_color_subtable\n\nstatic GLboolean _glewInit_GL_EXT_color_subtable (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorSubTableEXT\")) == NULL) || r;\n  r = ((glCopyColorSubTableEXT = (PFNGLCOPYCOLORSUBTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorSubTableEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_color_subtable */\n\n#ifdef GL_EXT_compiled_vertex_array\n\nstatic GLboolean _glewInit_GL_EXT_compiled_vertex_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glLockArraysEXT = (PFNGLLOCKARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glLockArraysEXT\")) == NULL) || r;\n  r = ((glUnlockArraysEXT = (PFNGLUNLOCKARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glUnlockArraysEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_compiled_vertex_array */\n\n#ifdef GL_EXT_convolution\n\nstatic GLboolean _glewInit_GL_EXT_convolution (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glConvolutionFilter1DEXT = (PFNGLCONVOLUTIONFILTER1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter1DEXT\")) == NULL) || r;\n  r = ((glConvolutionFilter2DEXT = (PFNGLCONVOLUTIONFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionFilter2DEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterfEXT = (PFNGLCONVOLUTIONPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterfvEXT = (PFNGLCONVOLUTIONPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterfvEXT\")) == NULL) || r;\n  r = ((glConvolutionParameteriEXT = (PFNGLCONVOLUTIONPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameteriEXT\")) == NULL) || r;\n  r = ((glConvolutionParameterivEXT = (PFNGLCONVOLUTIONPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glConvolutionParameterivEXT\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter1DEXT = (PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter1DEXT\")) == NULL) || r;\n  r = ((glCopyConvolutionFilter2DEXT = (PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyConvolutionFilter2DEXT\")) == NULL) || r;\n  r = ((glGetConvolutionFilterEXT = (PFNGLGETCONVOLUTIONFILTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionFilterEXT\")) == NULL) || r;\n  r = ((glGetConvolutionParameterfvEXT = (PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterfvEXT\")) == NULL) || r;\n  r = ((glGetConvolutionParameterivEXT = (PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetConvolutionParameterivEXT\")) == NULL) || r;\n  r = ((glGetSeparableFilterEXT = (PFNGLGETSEPARABLEFILTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glGetSeparableFilterEXT\")) == NULL) || r;\n  r = ((glSeparableFilter2DEXT = (PFNGLSEPARABLEFILTER2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glSeparableFilter2DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_convolution */\n\n#ifdef GL_EXT_coordinate_frame\n\nstatic GLboolean _glewInit_GL_EXT_coordinate_frame (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBinormalPointerEXT = (PFNGLBINORMALPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBinormalPointerEXT\")) == NULL) || r;\n  r = ((glTangentPointerEXT = (PFNGLTANGENTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTangentPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_coordinate_frame */\n\n#ifdef GL_EXT_copy_texture\n\nstatic GLboolean _glewInit_GL_EXT_copy_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCopyTexImage1DEXT = (PFNGLCOPYTEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTexImage2DEXT = (PFNGLCOPYTEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage1DEXT = (PFNGLCOPYTEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage2DEXT = (PFNGLCOPYTEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTexSubImage3DEXT = (PFNGLCOPYTEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTexSubImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_copy_texture */\n\n#ifdef GL_EXT_cull_vertex\n\nstatic GLboolean _glewInit_GL_EXT_cull_vertex (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCullParameterdvEXT = (PFNGLCULLPARAMETERDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glCullParameterdvEXT\")) == NULL) || r;\n  r = ((glCullParameterfvEXT = (PFNGLCULLPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glCullParameterfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_cull_vertex */\n\n#ifdef GL_EXT_depth_bounds_test\n\nstatic GLboolean _glewInit_GL_EXT_depth_bounds_test (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDepthBoundsEXT = (PFNGLDEPTHBOUNDSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDepthBoundsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_depth_bounds_test */\n\n#ifdef GL_EXT_direct_state_access\n\nstatic GLboolean _glewInit_GL_EXT_direct_state_access (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindMultiTextureEXT = (PFNGLBINDMULTITEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindMultiTextureEXT\")) == NULL) || r;\n  r = ((glCheckNamedFramebufferStatusEXT = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)glewGetProcAddress((const GLubyte*)\"glCheckNamedFramebufferStatusEXT\")) == NULL) || r;\n  r = ((glClientAttribDefaultEXT = (PFNGLCLIENTATTRIBDEFAULTEXTPROC)glewGetProcAddress((const GLubyte*)\"glClientAttribDefaultEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage1DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage2DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexImage3DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage1DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage2DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedMultiTexSubImage3DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage1DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage2DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureImage3DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureImage3DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage1DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage2DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glCompressedTextureSubImage3DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCompressedTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexImage1DEXT = (PFNGLCOPYMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexImage2DEXT = (PFNGLCOPYMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage1DEXT = (PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage2DEXT = (PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyMultiTexSubImage3DEXT = (PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glCopyTextureImage1DEXT = (PFNGLCOPYTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTextureImage2DEXT = (PFNGLCOPYTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage1DEXT = (PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage2DEXT = (PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glCopyTextureSubImage3DEXT = (PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glCopyTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glDisableClientStateIndexedEXT = (PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableClientStateIndexedEXT\")) == NULL) || r;\n  r = ((glEnableClientStateIndexedEXT = (PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableClientStateIndexedEXT\")) == NULL) || r;\n  r = ((glFramebufferDrawBufferEXT = (PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferDrawBufferEXT\")) == NULL) || r;\n  r = ((glFramebufferDrawBuffersEXT = (PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferDrawBuffersEXT\")) == NULL) || r;\n  r = ((glFramebufferReadBufferEXT = (PFNGLFRAMEBUFFERREADBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferReadBufferEXT\")) == NULL) || r;\n  r = ((glGenerateMultiTexMipmapEXT = (PFNGLGENERATEMULTITEXMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMultiTexMipmapEXT\")) == NULL) || r;\n  r = ((glGenerateTextureMipmapEXT = (PFNGLGENERATETEXTUREMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateTextureMipmapEXT\")) == NULL) || r;\n  r = ((glGetCompressedMultiTexImageEXT = (PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedMultiTexImageEXT\")) == NULL) || r;\n  r = ((glGetCompressedTextureImageEXT = (PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetCompressedTextureImageEXT\")) == NULL) || r;\n  r = ((glGetDoubleIndexedvEXT = (PFNGLGETDOUBLEINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetDoubleIndexedvEXT\")) == NULL) || r;\n  r = ((glGetFloatIndexedvEXT = (PFNGLGETFLOATINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFloatIndexedvEXT\")) == NULL) || r;\n  r = ((glGetFramebufferParameterivEXT = (PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexEnvfvEXT = (PFNGLGETMULTITEXENVFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexEnvfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexEnvivEXT = (PFNGLGETMULTITEXENVIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexEnvivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGendvEXT = (PFNGLGETMULTITEXGENDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGendvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGenfvEXT = (PFNGLGETMULTITEXGENFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGenfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexGenivEXT = (PFNGLGETMULTITEXGENIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexGenivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexImageEXT = (PFNGLGETMULTITEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexImageEXT\")) == NULL) || r;\n  r = ((glGetMultiTexLevelParameterfvEXT = (PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexLevelParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexLevelParameterivEXT = (PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexLevelParameterivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterIivEXT = (PFNGLGETMULTITEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterIivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterIuivEXT = (PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterfvEXT = (PFNGLGETMULTITEXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMultiTexParameterivEXT = (PFNGLGETMULTITEXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMultiTexParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferParameterivEXT = (PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferPointervEXT = (PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferPointervEXT\")) == NULL) || r;\n  r = ((glGetNamedBufferSubDataEXT = (PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedBufferSubDataEXT\")) == NULL) || r;\n  r = ((glGetNamedFramebufferAttachmentParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedFramebufferAttachmentParameterivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterIivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterIivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterIuivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterdvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterdvEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramLocalParameterfvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramLocalParameterfvEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramStringEXT = (PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramStringEXT\")) == NULL) || r;\n  r = ((glGetNamedProgramivEXT = (PFNGLGETNAMEDPROGRAMIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedProgramivEXT\")) == NULL) || r;\n  r = ((glGetNamedRenderbufferParameterivEXT = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetNamedRenderbufferParameterivEXT\")) == NULL) || r;\n  r = ((glGetPointerIndexedvEXT = (PFNGLGETPOINTERINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPointerIndexedvEXT\")) == NULL) || r;\n  r = ((glGetTextureImageEXT = (PFNGLGETTEXTUREIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureImageEXT\")) == NULL) || r;\n  r = ((glGetTextureLevelParameterfvEXT = (PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureLevelParameterfvEXT\")) == NULL) || r;\n  r = ((glGetTextureLevelParameterivEXT = (PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureLevelParameterivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterIivEXT = (PFNGLGETTEXTUREPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterIivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterIuivEXT = (PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterIuivEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterfvEXT = (PFNGLGETTEXTUREPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterfvEXT\")) == NULL) || r;\n  r = ((glGetTextureParameterivEXT = (PFNGLGETTEXTUREPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTextureParameterivEXT\")) == NULL) || r;\n  r = ((glMapNamedBufferEXT = (PFNGLMAPNAMEDBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMapNamedBufferEXT\")) == NULL) || r;\n  r = ((glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixFrustumEXT\")) == NULL) || r;\n  r = ((glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadIdentityEXT\")) == NULL) || r;\n  r = ((glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadTransposedEXT\")) == NULL) || r;\n  r = ((glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadTransposefEXT\")) == NULL) || r;\n  r = ((glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoaddEXT\")) == NULL) || r;\n  r = ((glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixLoadfEXT\")) == NULL) || r;\n  r = ((glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultTransposedEXT\")) == NULL) || r;\n  r = ((glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultTransposefEXT\")) == NULL) || r;\n  r = ((glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultdEXT\")) == NULL) || r;\n  r = ((glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixMultfEXT\")) == NULL) || r;\n  r = ((glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixOrthoEXT\")) == NULL) || r;\n  r = ((glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixPopEXT\")) == NULL) || r;\n  r = ((glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixPushEXT\")) == NULL) || r;\n  r = ((glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixRotatedEXT\")) == NULL) || r;\n  r = ((glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixRotatefEXT\")) == NULL) || r;\n  r = ((glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixScaledEXT\")) == NULL) || r;\n  r = ((glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixScalefEXT\")) == NULL) || r;\n  r = ((glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixTranslatedEXT\")) == NULL) || r;\n  r = ((glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMatrixTranslatefEXT\")) == NULL) || r;\n  r = ((glMultiTexBufferEXT = (PFNGLMULTITEXBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexBufferEXT\")) == NULL) || r;\n  r = ((glMultiTexCoordPointerEXT = (PFNGLMULTITEXCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoordPointerEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvfEXT = (PFNGLMULTITEXENVFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvfEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvfvEXT = (PFNGLMULTITEXENVFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvfvEXT\")) == NULL) || r;\n  r = ((glMultiTexEnviEXT = (PFNGLMULTITEXENVIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnviEXT\")) == NULL) || r;\n  r = ((glMultiTexEnvivEXT = (PFNGLMULTITEXENVIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexEnvivEXT\")) == NULL) || r;\n  r = ((glMultiTexGendEXT = (PFNGLMULTITEXGENDEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGendEXT\")) == NULL) || r;\n  r = ((glMultiTexGendvEXT = (PFNGLMULTITEXGENDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGendvEXT\")) == NULL) || r;\n  r = ((glMultiTexGenfEXT = (PFNGLMULTITEXGENFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenfEXT\")) == NULL) || r;\n  r = ((glMultiTexGenfvEXT = (PFNGLMULTITEXGENFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenfvEXT\")) == NULL) || r;\n  r = ((glMultiTexGeniEXT = (PFNGLMULTITEXGENIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGeniEXT\")) == NULL) || r;\n  r = ((glMultiTexGenivEXT = (PFNGLMULTITEXGENIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexGenivEXT\")) == NULL) || r;\n  r = ((glMultiTexImage1DEXT = (PFNGLMULTITEXIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage1DEXT\")) == NULL) || r;\n  r = ((glMultiTexImage2DEXT = (PFNGLMULTITEXIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage2DEXT\")) == NULL) || r;\n  r = ((glMultiTexImage3DEXT = (PFNGLMULTITEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexImage3DEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterIivEXT = (PFNGLMULTITEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterIivEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterIuivEXT = (PFNGLMULTITEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterfEXT = (PFNGLMULTITEXPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterfEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterfvEXT = (PFNGLMULTITEXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterfvEXT\")) == NULL) || r;\n  r = ((glMultiTexParameteriEXT = (PFNGLMULTITEXPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameteriEXT\")) == NULL) || r;\n  r = ((glMultiTexParameterivEXT = (PFNGLMULTITEXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexParameterivEXT\")) == NULL) || r;\n  r = ((glMultiTexRenderbufferEXT = (PFNGLMULTITEXRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexRenderbufferEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage1DEXT = (PFNGLMULTITEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage2DEXT = (PFNGLMULTITEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glMultiTexSubImage3DEXT = (PFNGLMULTITEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexSubImage3DEXT\")) == NULL) || r;\n  r = ((glNamedBufferDataEXT = (PFNGLNAMEDBUFFERDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedBufferDataEXT\")) == NULL) || r;\n  r = ((glNamedBufferSubDataEXT = (PFNGLNAMEDBUFFERSUBDATAEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedBufferSubDataEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferRenderbufferEXT = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferRenderbufferEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture1DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture1DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture2DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture2DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTexture3DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTexture3DEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureFaceEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureFaceEXT\")) == NULL) || r;\n  r = ((glNamedFramebufferTextureLayerEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedFramebufferTextureLayerEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4dEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4dEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4dvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4dvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4fEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4fEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameter4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameter4fvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4iEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4iEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4ivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4uiEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4uiEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameterI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameterI4uivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParameters4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParameters4fvEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParametersI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParametersI4ivEXT\")) == NULL) || r;\n  r = ((glNamedProgramLocalParametersI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramLocalParametersI4uivEXT\")) == NULL) || r;\n  r = ((glNamedProgramStringEXT = (PFNGLNAMEDPROGRAMSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedProgramStringEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageMultisampleCoverageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageMultisampleCoverageEXT\")) == NULL) || r;\n  r = ((glNamedRenderbufferStorageMultisampleEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glNamedRenderbufferStorageMultisampleEXT\")) == NULL) || r;\n  r = ((glProgramUniform1fEXT = (PFNGLPROGRAMUNIFORM1FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1fEXT\")) == NULL) || r;\n  r = ((glProgramUniform1fvEXT = (PFNGLPROGRAMUNIFORM1FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform1iEXT = (PFNGLPROGRAMUNIFORM1IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1iEXT\")) == NULL) || r;\n  r = ((glProgramUniform1ivEXT = (PFNGLPROGRAMUNIFORM1IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform1uiEXT = (PFNGLPROGRAMUNIFORM1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform1uivEXT = (PFNGLPROGRAMUNIFORM1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform1uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform2fEXT = (PFNGLPROGRAMUNIFORM2FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2fEXT\")) == NULL) || r;\n  r = ((glProgramUniform2fvEXT = (PFNGLPROGRAMUNIFORM2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform2iEXT = (PFNGLPROGRAMUNIFORM2IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2iEXT\")) == NULL) || r;\n  r = ((glProgramUniform2ivEXT = (PFNGLPROGRAMUNIFORM2IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform2uiEXT = (PFNGLPROGRAMUNIFORM2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform2uivEXT = (PFNGLPROGRAMUNIFORM2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform2uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform3fEXT = (PFNGLPROGRAMUNIFORM3FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3fEXT\")) == NULL) || r;\n  r = ((glProgramUniform3fvEXT = (PFNGLPROGRAMUNIFORM3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform3iEXT = (PFNGLPROGRAMUNIFORM3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3iEXT\")) == NULL) || r;\n  r = ((glProgramUniform3ivEXT = (PFNGLPROGRAMUNIFORM3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform3uiEXT = (PFNGLPROGRAMUNIFORM3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform3uivEXT = (PFNGLPROGRAMUNIFORM3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform3uivEXT\")) == NULL) || r;\n  r = ((glProgramUniform4fEXT = (PFNGLPROGRAMUNIFORM4FEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4fEXT\")) == NULL) || r;\n  r = ((glProgramUniform4fvEXT = (PFNGLPROGRAMUNIFORM4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniform4iEXT = (PFNGLPROGRAMUNIFORM4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4iEXT\")) == NULL) || r;\n  r = ((glProgramUniform4ivEXT = (PFNGLPROGRAMUNIFORM4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4ivEXT\")) == NULL) || r;\n  r = ((glProgramUniform4uiEXT = (PFNGLPROGRAMUNIFORM4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4uiEXT\")) == NULL) || r;\n  r = ((glProgramUniform4uivEXT = (PFNGLPROGRAMUNIFORM4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniform4uivEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2x3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix2x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix2x4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3x2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix3x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix3x4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4x2fvEXT\")) == NULL) || r;\n  r = ((glProgramUniformMatrix4x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramUniformMatrix4x3fvEXT\")) == NULL) || r;\n  r = ((glPushClientAttribDefaultEXT = (PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)glewGetProcAddress((const GLubyte*)\"glPushClientAttribDefaultEXT\")) == NULL) || r;\n  r = ((glTextureBufferEXT = (PFNGLTEXTUREBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureBufferEXT\")) == NULL) || r;\n  r = ((glTextureImage1DEXT = (PFNGLTEXTUREIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage1DEXT\")) == NULL) || r;\n  r = ((glTextureImage2DEXT = (PFNGLTEXTUREIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage2DEXT\")) == NULL) || r;\n  r = ((glTextureImage3DEXT = (PFNGLTEXTUREIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureImage3DEXT\")) == NULL) || r;\n  r = ((glTextureParameterIivEXT = (PFNGLTEXTUREPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterIivEXT\")) == NULL) || r;\n  r = ((glTextureParameterIuivEXT = (PFNGLTEXTUREPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterIuivEXT\")) == NULL) || r;\n  r = ((glTextureParameterfEXT = (PFNGLTEXTUREPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterfEXT\")) == NULL) || r;\n  r = ((glTextureParameterfvEXT = (PFNGLTEXTUREPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterfvEXT\")) == NULL) || r;\n  r = ((glTextureParameteriEXT = (PFNGLTEXTUREPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameteriEXT\")) == NULL) || r;\n  r = ((glTextureParameterivEXT = (PFNGLTEXTUREPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureParameterivEXT\")) == NULL) || r;\n  r = ((glTextureRenderbufferEXT = (PFNGLTEXTURERENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureRenderbufferEXT\")) == NULL) || r;\n  r = ((glTextureSubImage1DEXT = (PFNGLTEXTURESUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage1DEXT\")) == NULL) || r;\n  r = ((glTextureSubImage2DEXT = (PFNGLTEXTURESUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage2DEXT\")) == NULL) || r;\n  r = ((glTextureSubImage3DEXT = (PFNGLTEXTURESUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureSubImage3DEXT\")) == NULL) || r;\n  r = ((glUnmapNamedBufferEXT = (PFNGLUNMAPNAMEDBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glUnmapNamedBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_direct_state_access */\n\n#ifdef GL_EXT_draw_buffers2\n\nstatic GLboolean _glewInit_GL_EXT_draw_buffers2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorMaskIndexedEXT = (PFNGLCOLORMASKINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorMaskIndexedEXT\")) == NULL) || r;\n  r = ((glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableIndexedEXT\")) == NULL) || r;\n  r = ((glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableIndexedEXT\")) == NULL) || r;\n  r = ((glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetBooleanIndexedvEXT\")) == NULL) || r;\n  r = ((glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetIntegerIndexedvEXT\")) == NULL) || r;\n  r = ((glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsEnabledIndexedEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_buffers2 */\n\n#ifdef GL_EXT_draw_instanced\n\nstatic GLboolean _glewInit_GL_EXT_draw_instanced (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawArraysInstancedEXT = (PFNGLDRAWARRAYSINSTANCEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysInstancedEXT\")) == NULL) || r;\n  r = ((glDrawElementsInstancedEXT = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawElementsInstancedEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_instanced */\n\n#ifdef GL_EXT_draw_range_elements\n\nstatic GLboolean _glewInit_GL_EXT_draw_range_elements (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDrawRangeElementsEXT = (PFNGLDRAWRANGEELEMENTSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawRangeElementsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_draw_range_elements */\n\n#ifdef GL_EXT_fog_coord\n\nstatic GLboolean _glewInit_GL_EXT_fog_coord (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFogCoordPointerEXT = (PFNGLFOGCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointerEXT\")) == NULL) || r;\n  r = ((glFogCoorddEXT = (PFNGLFOGCOORDDEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddEXT\")) == NULL) || r;\n  r = ((glFogCoorddvEXT = (PFNGLFOGCOORDDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoorddvEXT\")) == NULL) || r;\n  r = ((glFogCoordfEXT = (PFNGLFOGCOORDFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfEXT\")) == NULL) || r;\n  r = ((glFogCoordfvEXT = (PFNGLFOGCOORDFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_fog_coord */\n\n#ifdef GL_EXT_fragment_lighting\n\nstatic GLboolean _glewInit_GL_EXT_fragment_lighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFragmentColorMaterialEXT = (PFNGLFRAGMENTCOLORMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentColorMaterialEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelfEXT = (PFNGLFRAGMENTLIGHTMODELFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelfvEXT = (PFNGLFRAGMENTLIGHTMODELFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfvEXT\")) == NULL) || r;\n  r = ((glFragmentLightModeliEXT = (PFNGLFRAGMENTLIGHTMODELIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModeliEXT\")) == NULL) || r;\n  r = ((glFragmentLightModelivEXT = (PFNGLFRAGMENTLIGHTMODELIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelivEXT\")) == NULL) || r;\n  r = ((glFragmentLightfEXT = (PFNGLFRAGMENTLIGHTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfEXT\")) == NULL) || r;\n  r = ((glFragmentLightfvEXT = (PFNGLFRAGMENTLIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfvEXT\")) == NULL) || r;\n  r = ((glFragmentLightiEXT = (PFNGLFRAGMENTLIGHTIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightiEXT\")) == NULL) || r;\n  r = ((glFragmentLightivEXT = (PFNGLFRAGMENTLIGHTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightivEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialfEXT = (PFNGLFRAGMENTMATERIALFEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialfvEXT = (PFNGLFRAGMENTMATERIALFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfvEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialiEXT = (PFNGLFRAGMENTMATERIALIEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialiEXT\")) == NULL) || r;\n  r = ((glFragmentMaterialivEXT = (PFNGLFRAGMENTMATERIALIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialivEXT\")) == NULL) || r;\n  r = ((glGetFragmentLightfvEXT = (PFNGLGETFRAGMENTLIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightfvEXT\")) == NULL) || r;\n  r = ((glGetFragmentLightivEXT = (PFNGLGETFRAGMENTLIGHTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightivEXT\")) == NULL) || r;\n  r = ((glGetFragmentMaterialfvEXT = (PFNGLGETFRAGMENTMATERIALFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialfvEXT\")) == NULL) || r;\n  r = ((glGetFragmentMaterialivEXT = (PFNGLGETFRAGMENTMATERIALIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialivEXT\")) == NULL) || r;\n  r = ((glLightEnviEXT = (PFNGLLIGHTENVIEXTPROC)glewGetProcAddress((const GLubyte*)\"glLightEnviEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_fragment_lighting */\n\n#ifdef GL_EXT_framebuffer_blit\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_blit (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBlitFramebufferEXT = (PFNGLBLITFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBlitFramebufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_blit */\n\n#ifdef GL_EXT_framebuffer_multisample\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glRenderbufferStorageMultisampleEXT = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisampleEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_multisample */\n\n#ifdef GL_EXT_framebuffer_object\n\nstatic GLboolean _glewInit_GL_EXT_framebuffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindFramebufferEXT\")) == NULL) || r;\n  r = ((glBindRenderbufferEXT = (PFNGLBINDRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindRenderbufferEXT\")) == NULL) || r;\n  r = ((glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)glewGetProcAddress((const GLubyte*)\"glCheckFramebufferStatusEXT\")) == NULL) || r;\n  r = ((glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFramebuffersEXT\")) == NULL) || r;\n  r = ((glDeleteRenderbuffersEXT = (PFNGLDELETERENDERBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteRenderbuffersEXT\")) == NULL) || r;\n  r = ((glFramebufferRenderbufferEXT = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferRenderbufferEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture1DEXT = (PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture1DEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture2DEXT\")) == NULL) || r;\n  r = ((glFramebufferTexture3DEXT = (PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTexture3DEXT\")) == NULL) || r;\n  r = ((glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenFramebuffersEXT\")) == NULL) || r;\n  r = ((glGenRenderbuffersEXT = (PFNGLGENRENDERBUFFERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenRenderbuffersEXT\")) == NULL) || r;\n  r = ((glGenerateMipmapEXT = (PFNGLGENERATEMIPMAPEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenerateMipmapEXT\")) == NULL) || r;\n  r = ((glGetFramebufferAttachmentParameterivEXT = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFramebufferAttachmentParameterivEXT\")) == NULL) || r;\n  r = ((glGetRenderbufferParameterivEXT = (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetRenderbufferParameterivEXT\")) == NULL) || r;\n  r = ((glIsFramebufferEXT = (PFNGLISFRAMEBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIsFramebufferEXT\")) == NULL) || r;\n  r = ((glIsRenderbufferEXT = (PFNGLISRENDERBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIsRenderbufferEXT\")) == NULL) || r;\n  r = ((glRenderbufferStorageEXT = (PFNGLRENDERBUFFERSTORAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_framebuffer_object */\n\n#ifdef GL_EXT_framebuffer_sRGB\n\n#endif /* GL_EXT_framebuffer_sRGB */\n\n#ifdef GL_EXT_geometry_shader4\n\nstatic GLboolean _glewInit_GL_EXT_geometry_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFramebufferTextureEXT = (PFNGLFRAMEBUFFERTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureEXT\")) == NULL) || r;\n  r = ((glFramebufferTextureFaceEXT = (PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureFaceEXT\")) == NULL) || r;\n  r = ((glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)glewGetProcAddress((const GLubyte*)\"glFramebufferTextureLayerEXT\")) == NULL) || r;\n  r = ((glProgramParameteriEXT = (PFNGLPROGRAMPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameteriEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_geometry_shader4 */\n\n#ifdef GL_EXT_gpu_program_parameters\n\nstatic GLboolean _glewInit_GL_EXT_gpu_program_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramEnvParameters4fvEXT = (PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameters4fvEXT\")) == NULL) || r;\n  r = ((glProgramLocalParameters4fvEXT = (PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameters4fvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_gpu_program_parameters */\n\n#ifdef GL_EXT_gpu_shader4\n\nstatic GLboolean _glewInit_GL_EXT_gpu_shader4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBindFragDataLocationEXT = (PFNGLBINDFRAGDATALOCATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindFragDataLocationEXT\")) == NULL) || r;\n  r = ((glGetFragDataLocationEXT = (PFNGLGETFRAGDATALOCATIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetFragDataLocationEXT\")) == NULL) || r;\n  r = ((glGetUniformuivEXT = (PFNGLGETUNIFORMUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetUniformuivEXT\")) == NULL) || r;\n  r = ((glGetVertexAttribIivEXT = (PFNGLGETVERTEXATTRIBIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIivEXT\")) == NULL) || r;\n  r = ((glGetVertexAttribIuivEXT = (PFNGLGETVERTEXATTRIBIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribIuivEXT\")) == NULL) || r;\n  r = ((glUniform1uiEXT = (PFNGLUNIFORM1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uiEXT\")) == NULL) || r;\n  r = ((glUniform1uivEXT = (PFNGLUNIFORM1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform1uivEXT\")) == NULL) || r;\n  r = ((glUniform2uiEXT = (PFNGLUNIFORM2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uiEXT\")) == NULL) || r;\n  r = ((glUniform2uivEXT = (PFNGLUNIFORM2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform2uivEXT\")) == NULL) || r;\n  r = ((glUniform3uiEXT = (PFNGLUNIFORM3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uiEXT\")) == NULL) || r;\n  r = ((glUniform3uivEXT = (PFNGLUNIFORM3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform3uivEXT\")) == NULL) || r;\n  r = ((glUniform4uiEXT = (PFNGLUNIFORM4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uiEXT\")) == NULL) || r;\n  r = ((glUniform4uivEXT = (PFNGLUNIFORM4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glUniform4uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1iEXT = (PFNGLVERTEXATTRIBI1IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1ivEXT = (PFNGLVERTEXATTRIBI1IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1uiEXT = (PFNGLVERTEXATTRIBI1UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI1uivEXT = (PFNGLVERTEXATTRIBI1UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI1uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2iEXT = (PFNGLVERTEXATTRIBI2IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2ivEXT = (PFNGLVERTEXATTRIBI2IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2uiEXT = (PFNGLVERTEXATTRIBI2UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI2uivEXT = (PFNGLVERTEXATTRIBI2UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI2uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3iEXT = (PFNGLVERTEXATTRIBI3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3ivEXT = (PFNGLVERTEXATTRIBI3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3uiEXT = (PFNGLVERTEXATTRIBI3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI3uivEXT = (PFNGLVERTEXATTRIBI3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI3uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4bvEXT = (PFNGLVERTEXATTRIBI4BVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4bvEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4iEXT = (PFNGLVERTEXATTRIBI4IEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4iEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4ivEXT = (PFNGLVERTEXATTRIBI4IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4svEXT = (PFNGLVERTEXATTRIBI4SVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4svEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4ubvEXT = (PFNGLVERTEXATTRIBI4UBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4ubvEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4uiEXT = (PFNGLVERTEXATTRIBI4UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uiEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4uivEXT = (PFNGLVERTEXATTRIBI4UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4uivEXT\")) == NULL) || r;\n  r = ((glVertexAttribI4usvEXT = (PFNGLVERTEXATTRIBI4USVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribI4usvEXT\")) == NULL) || r;\n  r = ((glVertexAttribIPointerEXT = (PFNGLVERTEXATTRIBIPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribIPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_gpu_shader4 */\n\n#ifdef GL_EXT_histogram\n\nstatic GLboolean _glewInit_GL_EXT_histogram (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetHistogramEXT = (PFNGLGETHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramEXT\")) == NULL) || r;\n  r = ((glGetHistogramParameterfvEXT = (PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterfvEXT\")) == NULL) || r;\n  r = ((glGetHistogramParameterivEXT = (PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetHistogramParameterivEXT\")) == NULL) || r;\n  r = ((glGetMinmaxEXT = (PFNGLGETMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxEXT\")) == NULL) || r;\n  r = ((glGetMinmaxParameterfvEXT = (PFNGLGETMINMAXPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterfvEXT\")) == NULL) || r;\n  r = ((glGetMinmaxParameterivEXT = (PFNGLGETMINMAXPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetMinmaxParameterivEXT\")) == NULL) || r;\n  r = ((glHistogramEXT = (PFNGLHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glHistogramEXT\")) == NULL) || r;\n  r = ((glMinmaxEXT = (PFNGLMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glMinmaxEXT\")) == NULL) || r;\n  r = ((glResetHistogramEXT = (PFNGLRESETHISTOGRAMEXTPROC)glewGetProcAddress((const GLubyte*)\"glResetHistogramEXT\")) == NULL) || r;\n  r = ((glResetMinmaxEXT = (PFNGLRESETMINMAXEXTPROC)glewGetProcAddress((const GLubyte*)\"glResetMinmaxEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_histogram */\n\n#ifdef GL_EXT_index_array_formats\n\n#endif /* GL_EXT_index_array_formats */\n\n#ifdef GL_EXT_index_func\n\nstatic GLboolean _glewInit_GL_EXT_index_func (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glIndexFuncEXT = (PFNGLINDEXFUNCEXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexFuncEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_index_func */\n\n#ifdef GL_EXT_index_material\n\nstatic GLboolean _glewInit_GL_EXT_index_material (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glIndexMaterialEXT = (PFNGLINDEXMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexMaterialEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_index_material */\n\n#ifdef GL_EXT_index_texture\n\n#endif /* GL_EXT_index_texture */\n\n#ifdef GL_EXT_light_texture\n\nstatic GLboolean _glewInit_GL_EXT_light_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glApplyTextureEXT = (PFNGLAPPLYTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glApplyTextureEXT\")) == NULL) || r;\n  r = ((glTextureLightEXT = (PFNGLTEXTURELIGHTEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureLightEXT\")) == NULL) || r;\n  r = ((glTextureMaterialEXT = (PFNGLTEXTUREMATERIALEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureMaterialEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_light_texture */\n\n#ifdef GL_EXT_misc_attribute\n\n#endif /* GL_EXT_misc_attribute */\n\n#ifdef GL_EXT_multi_draw_arrays\n\nstatic GLboolean _glewInit_GL_EXT_multi_draw_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMultiDrawArraysEXT = (PFNGLMULTIDRAWARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawArraysEXT\")) == NULL) || r;\n  r = ((glMultiDrawElementsEXT = (PFNGLMULTIDRAWELEMENTSEXTPROC)glewGetProcAddress((const GLubyte*)\"glMultiDrawElementsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_multi_draw_arrays */\n\n#ifdef GL_EXT_multisample\n\nstatic GLboolean _glewInit_GL_EXT_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleMaskEXT = (PFNGLSAMPLEMASKEXTPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskEXT\")) == NULL) || r;\n  r = ((glSamplePatternEXT = (PFNGLSAMPLEPATTERNEXTPROC)glewGetProcAddress((const GLubyte*)\"glSamplePatternEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_multisample */\n\n#ifdef GL_EXT_packed_depth_stencil\n\n#endif /* GL_EXT_packed_depth_stencil */\n\n#ifdef GL_EXT_packed_float\n\n#endif /* GL_EXT_packed_float */\n\n#ifdef GL_EXT_packed_pixels\n\n#endif /* GL_EXT_packed_pixels */\n\n#ifdef GL_EXT_paletted_texture\n\nstatic GLboolean _glewInit_GL_EXT_paletted_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorTableEXT = (PFNGLCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glColorTableEXT\")) == NULL) || r;\n  r = ((glGetColorTableEXT = (PFNGLGETCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableEXT\")) == NULL) || r;\n  r = ((glGetColorTableParameterfvEXT = (PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfvEXT\")) == NULL) || r;\n  r = ((glGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_paletted_texture */\n\n#ifdef GL_EXT_pixel_buffer_object\n\n#endif /* GL_EXT_pixel_buffer_object */\n\n#ifdef GL_EXT_pixel_transform\n\nstatic GLboolean _glewInit_GL_EXT_pixel_transform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetPixelTransformParameterfvEXT = (PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPixelTransformParameterfvEXT\")) == NULL) || r;\n  r = ((glGetPixelTransformParameterivEXT = (PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPixelTransformParameterivEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterfEXT = (PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterfEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterfvEXT = (PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterfvEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameteriEXT = (PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameteriEXT\")) == NULL) || r;\n  r = ((glPixelTransformParameterivEXT = (PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPixelTransformParameterivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_pixel_transform */\n\n#ifdef GL_EXT_pixel_transform_color_table\n\n#endif /* GL_EXT_pixel_transform_color_table */\n\n#ifdef GL_EXT_point_parameters\n\nstatic GLboolean _glewInit_GL_EXT_point_parameters (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameterfEXT = (PFNGLPOINTPARAMETERFEXTPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfEXT\")) == NULL) || r;\n  r = ((glPointParameterfvEXT = (PFNGLPOINTPARAMETERFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_point_parameters */\n\n#ifdef GL_EXT_polygon_offset\n\nstatic GLboolean _glewInit_GL_EXT_polygon_offset (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPolygonOffsetEXT = (PFNGLPOLYGONOFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glPolygonOffsetEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_polygon_offset */\n\n#ifdef GL_EXT_rescale_normal\n\n#endif /* GL_EXT_rescale_normal */\n\n#ifdef GL_EXT_scene_marker\n\nstatic GLboolean _glewInit_GL_EXT_scene_marker (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginSceneEXT = (PFNGLBEGINSCENEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginSceneEXT\")) == NULL) || r;\n  r = ((glEndSceneEXT = (PFNGLENDSCENEEXTPROC)glewGetProcAddress((const GLubyte*)\"glEndSceneEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_scene_marker */\n\n#ifdef GL_EXT_secondary_color\n\nstatic GLboolean _glewInit_GL_EXT_secondary_color (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSecondaryColor3bEXT = (PFNGLSECONDARYCOLOR3BEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3bvEXT = (PFNGLSECONDARYCOLOR3BVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3bvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3dEXT = (PFNGLSECONDARYCOLOR3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3dvEXT = (PFNGLSECONDARYCOLOR3DVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3dvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3fEXT = (PFNGLSECONDARYCOLOR3FEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3fvEXT = (PFNGLSECONDARYCOLOR3FVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3fvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3iEXT = (PFNGLSECONDARYCOLOR3IEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3iEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ivEXT = (PFNGLSECONDARYCOLOR3IVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ivEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3sEXT = (PFNGLSECONDARYCOLOR3SEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3sEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3svEXT = (PFNGLSECONDARYCOLOR3SVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3svEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ubEXT = (PFNGLSECONDARYCOLOR3UBEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3ubvEXT = (PFNGLSECONDARYCOLOR3UBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3ubvEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3uiEXT = (PFNGLSECONDARYCOLOR3UIEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uiEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3uivEXT = (PFNGLSECONDARYCOLOR3UIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3uivEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3usEXT = (PFNGLSECONDARYCOLOR3USEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usEXT\")) == NULL) || r;\n  r = ((glSecondaryColor3usvEXT = (PFNGLSECONDARYCOLOR3USVEXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3usvEXT\")) == NULL) || r;\n  r = ((glSecondaryColorPointerEXT = (PFNGLSECONDARYCOLORPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_secondary_color */\n\n#ifdef GL_EXT_separate_specular_color\n\n#endif /* GL_EXT_separate_specular_color */\n\n#ifdef GL_EXT_shadow_funcs\n\n#endif /* GL_EXT_shadow_funcs */\n\n#ifdef GL_EXT_shared_texture_palette\n\n#endif /* GL_EXT_shared_texture_palette */\n\n#ifdef GL_EXT_stencil_clear_tag\n\n#endif /* GL_EXT_stencil_clear_tag */\n\n#ifdef GL_EXT_stencil_two_side\n\nstatic GLboolean _glewInit_GL_EXT_stencil_two_side (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveStencilFaceEXT = (PFNGLACTIVESTENCILFACEEXTPROC)glewGetProcAddress((const GLubyte*)\"glActiveStencilFaceEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_stencil_two_side */\n\n#ifdef GL_EXT_stencil_wrap\n\n#endif /* GL_EXT_stencil_wrap */\n\n#ifdef GL_EXT_subtexture\n\nstatic GLboolean _glewInit_GL_EXT_subtexture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexSubImage1DEXT = (PFNGLTEXSUBIMAGE1DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage1DEXT\")) == NULL) || r;\n  r = ((glTexSubImage2DEXT = (PFNGLTEXSUBIMAGE2DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage2DEXT\")) == NULL) || r;\n  r = ((glTexSubImage3DEXT = (PFNGLTEXSUBIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_subtexture */\n\n#ifdef GL_EXT_texture\n\n#endif /* GL_EXT_texture */\n\n#ifdef GL_EXT_texture3D\n\nstatic GLboolean _glewInit_GL_EXT_texture3D (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexImage3DEXT = (PFNGLTEXIMAGE3DEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexImage3DEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture3D */\n\n#ifdef GL_EXT_texture_array\n\n#endif /* GL_EXT_texture_array */\n\n#ifdef GL_EXT_texture_buffer_object\n\nstatic GLboolean _glewInit_GL_EXT_texture_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexBufferEXT = (PFNGLTEXBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTexBufferEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_buffer_object */\n\n#ifdef GL_EXT_texture_compression_dxt1\n\n#endif /* GL_EXT_texture_compression_dxt1 */\n\n#ifdef GL_EXT_texture_compression_latc\n\n#endif /* GL_EXT_texture_compression_latc */\n\n#ifdef GL_EXT_texture_compression_rgtc\n\n#endif /* GL_EXT_texture_compression_rgtc */\n\n#ifdef GL_EXT_texture_compression_s3tc\n\n#endif /* GL_EXT_texture_compression_s3tc */\n\n#ifdef GL_EXT_texture_cube_map\n\n#endif /* GL_EXT_texture_cube_map */\n\n#ifdef GL_EXT_texture_edge_clamp\n\n#endif /* GL_EXT_texture_edge_clamp */\n\n#ifdef GL_EXT_texture_env\n\n#endif /* GL_EXT_texture_env */\n\n#ifdef GL_EXT_texture_env_add\n\n#endif /* GL_EXT_texture_env_add */\n\n#ifdef GL_EXT_texture_env_combine\n\n#endif /* GL_EXT_texture_env_combine */\n\n#ifdef GL_EXT_texture_env_dot3\n\n#endif /* GL_EXT_texture_env_dot3 */\n\n#ifdef GL_EXT_texture_filter_anisotropic\n\n#endif /* GL_EXT_texture_filter_anisotropic */\n\n#ifdef GL_EXT_texture_integer\n\nstatic GLboolean _glewInit_GL_EXT_texture_integer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearColorIiEXT = (PFNGLCLEARCOLORIIEXTPROC)glewGetProcAddress((const GLubyte*)\"glClearColorIiEXT\")) == NULL) || r;\n  r = ((glClearColorIuiEXT = (PFNGLCLEARCOLORIUIEXTPROC)glewGetProcAddress((const GLubyte*)\"glClearColorIuiEXT\")) == NULL) || r;\n  r = ((glGetTexParameterIivEXT = (PFNGLGETTEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIivEXT\")) == NULL) || r;\n  r = ((glGetTexParameterIuivEXT = (PFNGLGETTEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTexParameterIuivEXT\")) == NULL) || r;\n  r = ((glTexParameterIivEXT = (PFNGLTEXPARAMETERIIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIivEXT\")) == NULL) || r;\n  r = ((glTexParameterIuivEXT = (PFNGLTEXPARAMETERIUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glTexParameterIuivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_integer */\n\n#ifdef GL_EXT_texture_lod_bias\n\n#endif /* GL_EXT_texture_lod_bias */\n\n#ifdef GL_EXT_texture_mirror_clamp\n\n#endif /* GL_EXT_texture_mirror_clamp */\n\n#ifdef GL_EXT_texture_object\n\nstatic GLboolean _glewInit_GL_EXT_texture_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAreTexturesResidentEXT = (PFNGLARETEXTURESRESIDENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glAreTexturesResidentEXT\")) == NULL) || r;\n  r = ((glBindTextureEXT = (PFNGLBINDTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTextureEXT\")) == NULL) || r;\n  r = ((glDeleteTexturesEXT = (PFNGLDELETETEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteTexturesEXT\")) == NULL) || r;\n  r = ((glGenTexturesEXT = (PFNGLGENTEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenTexturesEXT\")) == NULL) || r;\n  r = ((glIsTextureEXT = (PFNGLISTEXTUREEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsTextureEXT\")) == NULL) || r;\n  r = ((glPrioritizeTexturesEXT = (PFNGLPRIORITIZETEXTURESEXTPROC)glewGetProcAddress((const GLubyte*)\"glPrioritizeTexturesEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_object */\n\n#ifdef GL_EXT_texture_perturb_normal\n\nstatic GLboolean _glewInit_GL_EXT_texture_perturb_normal (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTextureNormalEXT = (PFNGLTEXTURENORMALEXTPROC)glewGetProcAddress((const GLubyte*)\"glTextureNormalEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_texture_perturb_normal */\n\n#ifdef GL_EXT_texture_rectangle\n\n#endif /* GL_EXT_texture_rectangle */\n\n#ifdef GL_EXT_texture_sRGB\n\n#endif /* GL_EXT_texture_sRGB */\n\n#ifdef GL_EXT_texture_shared_exponent\n\n#endif /* GL_EXT_texture_shared_exponent */\n\n#ifdef GL_EXT_texture_swizzle\n\n#endif /* GL_EXT_texture_swizzle */\n\n#ifdef GL_EXT_timer_query\n\nstatic GLboolean _glewInit_GL_EXT_timer_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetQueryObjecti64vEXT = (PFNGLGETQUERYOBJECTI64VEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjecti64vEXT\")) == NULL) || r;\n  r = ((glGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetQueryObjectui64vEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_timer_query */\n\n#ifdef GL_EXT_transform_feedback\n\nstatic GLboolean _glewInit_GL_EXT_transform_feedback (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginTransformFeedbackEXT = (PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedbackEXT\")) == NULL) || r;\n  r = ((glBindBufferBaseEXT = (PFNGLBINDBUFFERBASEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBaseEXT\")) == NULL) || r;\n  r = ((glBindBufferOffsetEXT = (PFNGLBINDBUFFEROFFSETEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferOffsetEXT\")) == NULL) || r;\n  r = ((glBindBufferRangeEXT = (PFNGLBINDBUFFERRANGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRangeEXT\")) == NULL) || r;\n  r = ((glEndTransformFeedbackEXT = (PFNGLENDTRANSFORMFEEDBACKEXTPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedbackEXT\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVaryingEXT = (PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVaryingEXT\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryingsEXT = (PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryingsEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_transform_feedback */\n\n#ifdef GL_EXT_vertex_array\n\nstatic GLboolean _glewInit_GL_EXT_vertex_array (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glArrayElementEXT = (PFNGLARRAYELEMENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glArrayElementEXT\")) == NULL) || r;\n  r = ((glColorPointerEXT = (PFNGLCOLORPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glColorPointerEXT\")) == NULL) || r;\n  r = ((glDrawArraysEXT = (PFNGLDRAWARRAYSEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawArraysEXT\")) == NULL) || r;\n  r = ((glEdgeFlagPointerEXT = (PFNGLEDGEFLAGPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glEdgeFlagPointerEXT\")) == NULL) || r;\n  r = ((glGetPointervEXT = (PFNGLGETPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetPointervEXT\")) == NULL) || r;\n  r = ((glIndexPointerEXT = (PFNGLINDEXPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glIndexPointerEXT\")) == NULL) || r;\n  r = ((glNormalPointerEXT = (PFNGLNORMALPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointerEXT\")) == NULL) || r;\n  r = ((glTexCoordPointerEXT = (PFNGLTEXCOORDPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointerEXT\")) == NULL) || r;\n  r = ((glVertexPointerEXT = (PFNGLVERTEXPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointerEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_array */\n\n#ifdef GL_EXT_vertex_array_bgra\n\n#endif /* GL_EXT_vertex_array_bgra */\n\n#ifdef GL_EXT_vertex_shader\n\nstatic GLboolean _glewInit_GL_EXT_vertex_shader (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginVertexShaderEXT = (PFNGLBEGINVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBeginVertexShaderEXT\")) == NULL) || r;\n  r = ((glBindLightParameterEXT = (PFNGLBINDLIGHTPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindLightParameterEXT\")) == NULL) || r;\n  r = ((glBindMaterialParameterEXT = (PFNGLBINDMATERIALPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindMaterialParameterEXT\")) == NULL) || r;\n  r = ((glBindParameterEXT = (PFNGLBINDPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindParameterEXT\")) == NULL) || r;\n  r = ((glBindTexGenParameterEXT = (PFNGLBINDTEXGENPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTexGenParameterEXT\")) == NULL) || r;\n  r = ((glBindTextureUnitParameterEXT = (PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindTextureUnitParameterEXT\")) == NULL) || r;\n  r = ((glBindVertexShaderEXT = (PFNGLBINDVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glBindVertexShaderEXT\")) == NULL) || r;\n  r = ((glDeleteVertexShaderEXT = (PFNGLDELETEVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteVertexShaderEXT\")) == NULL) || r;\n  r = ((glDisableVariantClientStateEXT = (PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glDisableVariantClientStateEXT\")) == NULL) || r;\n  r = ((glEnableVariantClientStateEXT = (PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)glewGetProcAddress((const GLubyte*)\"glEnableVariantClientStateEXT\")) == NULL) || r;\n  r = ((glEndVertexShaderEXT = (PFNGLENDVERTEXSHADEREXTPROC)glewGetProcAddress((const GLubyte*)\"glEndVertexShaderEXT\")) == NULL) || r;\n  r = ((glExtractComponentEXT = (PFNGLEXTRACTCOMPONENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glExtractComponentEXT\")) == NULL) || r;\n  r = ((glGenSymbolsEXT = (PFNGLGENSYMBOLSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenSymbolsEXT\")) == NULL) || r;\n  r = ((glGenVertexShadersEXT = (PFNGLGENVERTEXSHADERSEXTPROC)glewGetProcAddress((const GLubyte*)\"glGenVertexShadersEXT\")) == NULL) || r;\n  r = ((glGetInvariantBooleanvEXT = (PFNGLGETINVARIANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetInvariantFloatvEXT = (PFNGLGETINVARIANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantFloatvEXT\")) == NULL) || r;\n  r = ((glGetInvariantIntegervEXT = (PFNGLGETINVARIANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetInvariantIntegervEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantBooleanvEXT = (PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantFloatvEXT = (PFNGLGETLOCALCONSTANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantFloatvEXT\")) == NULL) || r;\n  r = ((glGetLocalConstantIntegervEXT = (PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetLocalConstantIntegervEXT\")) == NULL) || r;\n  r = ((glGetVariantBooleanvEXT = (PFNGLGETVARIANTBOOLEANVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantBooleanvEXT\")) == NULL) || r;\n  r = ((glGetVariantFloatvEXT = (PFNGLGETVARIANTFLOATVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantFloatvEXT\")) == NULL) || r;\n  r = ((glGetVariantIntegervEXT = (PFNGLGETVARIANTINTEGERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantIntegervEXT\")) == NULL) || r;\n  r = ((glGetVariantPointervEXT = (PFNGLGETVARIANTPOINTERVEXTPROC)glewGetProcAddress((const GLubyte*)\"glGetVariantPointervEXT\")) == NULL) || r;\n  r = ((glInsertComponentEXT = (PFNGLINSERTCOMPONENTEXTPROC)glewGetProcAddress((const GLubyte*)\"glInsertComponentEXT\")) == NULL) || r;\n  r = ((glIsVariantEnabledEXT = (PFNGLISVARIANTENABLEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glIsVariantEnabledEXT\")) == NULL) || r;\n  r = ((glSetInvariantEXT = (PFNGLSETINVARIANTEXTPROC)glewGetProcAddress((const GLubyte*)\"glSetInvariantEXT\")) == NULL) || r;\n  r = ((glSetLocalConstantEXT = (PFNGLSETLOCALCONSTANTEXTPROC)glewGetProcAddress((const GLubyte*)\"glSetLocalConstantEXT\")) == NULL) || r;\n  r = ((glShaderOp1EXT = (PFNGLSHADEROP1EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp1EXT\")) == NULL) || r;\n  r = ((glShaderOp2EXT = (PFNGLSHADEROP2EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp2EXT\")) == NULL) || r;\n  r = ((glShaderOp3EXT = (PFNGLSHADEROP3EXTPROC)glewGetProcAddress((const GLubyte*)\"glShaderOp3EXT\")) == NULL) || r;\n  r = ((glSwizzleEXT = (PFNGLSWIZZLEEXTPROC)glewGetProcAddress((const GLubyte*)\"glSwizzleEXT\")) == NULL) || r;\n  r = ((glVariantPointerEXT = (PFNGLVARIANTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantPointerEXT\")) == NULL) || r;\n  r = ((glVariantbvEXT = (PFNGLVARIANTBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantbvEXT\")) == NULL) || r;\n  r = ((glVariantdvEXT = (PFNGLVARIANTDVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantdvEXT\")) == NULL) || r;\n  r = ((glVariantfvEXT = (PFNGLVARIANTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantfvEXT\")) == NULL) || r;\n  r = ((glVariantivEXT = (PFNGLVARIANTIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantivEXT\")) == NULL) || r;\n  r = ((glVariantsvEXT = (PFNGLVARIANTSVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantsvEXT\")) == NULL) || r;\n  r = ((glVariantubvEXT = (PFNGLVARIANTUBVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantubvEXT\")) == NULL) || r;\n  r = ((glVariantuivEXT = (PFNGLVARIANTUIVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantuivEXT\")) == NULL) || r;\n  r = ((glVariantusvEXT = (PFNGLVARIANTUSVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVariantusvEXT\")) == NULL) || r;\n  r = ((glWriteMaskEXT = (PFNGLWRITEMASKEXTPROC)glewGetProcAddress((const GLubyte*)\"glWriteMaskEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_shader */\n\n#ifdef GL_EXT_vertex_weighting\n\nstatic GLboolean _glewInit_GL_EXT_vertex_weighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glVertexWeightPointerEXT = (PFNGLVERTEXWEIGHTPOINTEREXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightPointerEXT\")) == NULL) || r;\n  r = ((glVertexWeightfEXT = (PFNGLVERTEXWEIGHTFEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightfEXT\")) == NULL) || r;\n  r = ((glVertexWeightfvEXT = (PFNGLVERTEXWEIGHTFVEXTPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeightfvEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_EXT_vertex_weighting */\n\n#ifdef GL_GREMEDY_frame_terminator\n\nstatic GLboolean _glewInit_GL_GREMEDY_frame_terminator (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFrameTerminatorGREMEDY = (PFNGLFRAMETERMINATORGREMEDYPROC)glewGetProcAddress((const GLubyte*)\"glFrameTerminatorGREMEDY\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_GREMEDY_frame_terminator */\n\n#ifdef GL_GREMEDY_string_marker\n\nstatic GLboolean _glewInit_GL_GREMEDY_string_marker (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glStringMarkerGREMEDY = (PFNGLSTRINGMARKERGREMEDYPROC)glewGetProcAddress((const GLubyte*)\"glStringMarkerGREMEDY\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_GREMEDY_string_marker */\n\n#ifdef GL_HP_convolution_border_modes\n\n#endif /* GL_HP_convolution_border_modes */\n\n#ifdef GL_HP_image_transform\n\nstatic GLboolean _glewInit_GL_HP_image_transform (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetImageTransformParameterfvHP = (PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)glewGetProcAddress((const GLubyte*)\"glGetImageTransformParameterfvHP\")) == NULL) || r;\n  r = ((glGetImageTransformParameterivHP = (PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)glewGetProcAddress((const GLubyte*)\"glGetImageTransformParameterivHP\")) == NULL) || r;\n  r = ((glImageTransformParameterfHP = (PFNGLIMAGETRANSFORMPARAMETERFHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterfHP\")) == NULL) || r;\n  r = ((glImageTransformParameterfvHP = (PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterfvHP\")) == NULL) || r;\n  r = ((glImageTransformParameteriHP = (PFNGLIMAGETRANSFORMPARAMETERIHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameteriHP\")) == NULL) || r;\n  r = ((glImageTransformParameterivHP = (PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)glewGetProcAddress((const GLubyte*)\"glImageTransformParameterivHP\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_HP_image_transform */\n\n#ifdef GL_HP_occlusion_test\n\n#endif /* GL_HP_occlusion_test */\n\n#ifdef GL_HP_texture_lighting\n\n#endif /* GL_HP_texture_lighting */\n\n#ifdef GL_IBM_cull_vertex\n\n#endif /* GL_IBM_cull_vertex */\n\n#ifdef GL_IBM_multimode_draw_arrays\n\nstatic GLboolean _glewInit_GL_IBM_multimode_draw_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glMultiModeDrawArraysIBM = (PFNGLMULTIMODEDRAWARRAYSIBMPROC)glewGetProcAddress((const GLubyte*)\"glMultiModeDrawArraysIBM\")) == NULL) || r;\n  r = ((glMultiModeDrawElementsIBM = (PFNGLMULTIMODEDRAWELEMENTSIBMPROC)glewGetProcAddress((const GLubyte*)\"glMultiModeDrawElementsIBM\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_IBM_multimode_draw_arrays */\n\n#ifdef GL_IBM_rasterpos_clip\n\n#endif /* GL_IBM_rasterpos_clip */\n\n#ifdef GL_IBM_static_data\n\n#endif /* GL_IBM_static_data */\n\n#ifdef GL_IBM_texture_mirrored_repeat\n\n#endif /* GL_IBM_texture_mirrored_repeat */\n\n#ifdef GL_IBM_vertex_array_lists\n\nstatic GLboolean _glewInit_GL_IBM_vertex_array_lists (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorPointerListIBM = (PFNGLCOLORPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glColorPointerListIBM\")) == NULL) || r;\n  r = ((glEdgeFlagPointerListIBM = (PFNGLEDGEFLAGPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glEdgeFlagPointerListIBM\")) == NULL) || r;\n  r = ((glFogCoordPointerListIBM = (PFNGLFOGCOORDPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordPointerListIBM\")) == NULL) || r;\n  r = ((glIndexPointerListIBM = (PFNGLINDEXPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glIndexPointerListIBM\")) == NULL) || r;\n  r = ((glNormalPointerListIBM = (PFNGLNORMALPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointerListIBM\")) == NULL) || r;\n  r = ((glSecondaryColorPointerListIBM = (PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColorPointerListIBM\")) == NULL) || r;\n  r = ((glTexCoordPointerListIBM = (PFNGLTEXCOORDPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointerListIBM\")) == NULL) || r;\n  r = ((glVertexPointerListIBM = (PFNGLVERTEXPOINTERLISTIBMPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointerListIBM\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_IBM_vertex_array_lists */\n\n#ifdef GL_INGR_color_clamp\n\n#endif /* GL_INGR_color_clamp */\n\n#ifdef GL_INGR_interlace_read\n\n#endif /* GL_INGR_interlace_read */\n\n#ifdef GL_INTEL_parallel_arrays\n\nstatic GLboolean _glewInit_GL_INTEL_parallel_arrays (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorPointervINTEL = (PFNGLCOLORPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glColorPointervINTEL\")) == NULL) || r;\n  r = ((glNormalPointervINTEL = (PFNGLNORMALPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glNormalPointervINTEL\")) == NULL) || r;\n  r = ((glTexCoordPointervINTEL = (PFNGLTEXCOORDPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexCoordPointervINTEL\")) == NULL) || r;\n  r = ((glVertexPointervINTEL = (PFNGLVERTEXPOINTERVINTELPROC)glewGetProcAddress((const GLubyte*)\"glVertexPointervINTEL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_INTEL_parallel_arrays */\n\n#ifdef GL_INTEL_texture_scissor\n\nstatic GLboolean _glewInit_GL_INTEL_texture_scissor (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexScissorFuncINTEL = (PFNGLTEXSCISSORFUNCINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexScissorFuncINTEL\")) == NULL) || r;\n  r = ((glTexScissorINTEL = (PFNGLTEXSCISSORINTELPROC)glewGetProcAddress((const GLubyte*)\"glTexScissorINTEL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_INTEL_texture_scissor */\n\n#ifdef GL_KTX_buffer_region\n\nstatic GLboolean _glewInit_GL_KTX_buffer_region (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBufferRegionEnabledEXT = (PFNGLBUFFERREGIONENABLEDEXTPROC)glewGetProcAddress((const GLubyte*)\"glBufferRegionEnabledEXT\")) == NULL) || r;\n  r = ((glDeleteBufferRegionEXT = (PFNGLDELETEBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glDeleteBufferRegionEXT\")) == NULL) || r;\n  r = ((glDrawBufferRegionEXT = (PFNGLDRAWBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glDrawBufferRegionEXT\")) == NULL) || r;\n  r = ((glNewBufferRegionEXT = (PFNGLNEWBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glNewBufferRegionEXT\")) == NULL) || r;\n  r = ((glReadBufferRegionEXT = (PFNGLREADBUFFERREGIONEXTPROC)glewGetProcAddress((const GLubyte*)\"glReadBufferRegionEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_KTX_buffer_region */\n\n#ifdef GL_MESAX_texture_stack\n\n#endif /* GL_MESAX_texture_stack */\n\n#ifdef GL_MESA_pack_invert\n\n#endif /* GL_MESA_pack_invert */\n\n#ifdef GL_MESA_resize_buffers\n\nstatic GLboolean _glewInit_GL_MESA_resize_buffers (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glResizeBuffersMESA = (PFNGLRESIZEBUFFERSMESAPROC)glewGetProcAddress((const GLubyte*)\"glResizeBuffersMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_MESA_resize_buffers */\n\n#ifdef GL_MESA_window_pos\n\nstatic GLboolean _glewInit_GL_MESA_window_pos (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glWindowPos2dMESA = (PFNGLWINDOWPOS2DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dMESA\")) == NULL) || r;\n  r = ((glWindowPos2dvMESA = (PFNGLWINDOWPOS2DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2dvMESA\")) == NULL) || r;\n  r = ((glWindowPos2fMESA = (PFNGLWINDOWPOS2FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fMESA\")) == NULL) || r;\n  r = ((glWindowPos2fvMESA = (PFNGLWINDOWPOS2FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2fvMESA\")) == NULL) || r;\n  r = ((glWindowPos2iMESA = (PFNGLWINDOWPOS2IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2iMESA\")) == NULL) || r;\n  r = ((glWindowPos2ivMESA = (PFNGLWINDOWPOS2IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2ivMESA\")) == NULL) || r;\n  r = ((glWindowPos2sMESA = (PFNGLWINDOWPOS2SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2sMESA\")) == NULL) || r;\n  r = ((glWindowPos2svMESA = (PFNGLWINDOWPOS2SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos2svMESA\")) == NULL) || r;\n  r = ((glWindowPos3dMESA = (PFNGLWINDOWPOS3DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dMESA\")) == NULL) || r;\n  r = ((glWindowPos3dvMESA = (PFNGLWINDOWPOS3DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3dvMESA\")) == NULL) || r;\n  r = ((glWindowPos3fMESA = (PFNGLWINDOWPOS3FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fMESA\")) == NULL) || r;\n  r = ((glWindowPos3fvMESA = (PFNGLWINDOWPOS3FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3fvMESA\")) == NULL) || r;\n  r = ((glWindowPos3iMESA = (PFNGLWINDOWPOS3IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3iMESA\")) == NULL) || r;\n  r = ((glWindowPos3ivMESA = (PFNGLWINDOWPOS3IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3ivMESA\")) == NULL) || r;\n  r = ((glWindowPos3sMESA = (PFNGLWINDOWPOS3SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3sMESA\")) == NULL) || r;\n  r = ((glWindowPos3svMESA = (PFNGLWINDOWPOS3SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos3svMESA\")) == NULL) || r;\n  r = ((glWindowPos4dMESA = (PFNGLWINDOWPOS4DMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4dMESA\")) == NULL) || r;\n  r = ((glWindowPos4dvMESA = (PFNGLWINDOWPOS4DVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4dvMESA\")) == NULL) || r;\n  r = ((glWindowPos4fMESA = (PFNGLWINDOWPOS4FMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4fMESA\")) == NULL) || r;\n  r = ((glWindowPos4fvMESA = (PFNGLWINDOWPOS4FVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4fvMESA\")) == NULL) || r;\n  r = ((glWindowPos4iMESA = (PFNGLWINDOWPOS4IMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4iMESA\")) == NULL) || r;\n  r = ((glWindowPos4ivMESA = (PFNGLWINDOWPOS4IVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4ivMESA\")) == NULL) || r;\n  r = ((glWindowPos4sMESA = (PFNGLWINDOWPOS4SMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4sMESA\")) == NULL) || r;\n  r = ((glWindowPos4svMESA = (PFNGLWINDOWPOS4SVMESAPROC)glewGetProcAddress((const GLubyte*)\"glWindowPos4svMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_MESA_window_pos */\n\n#ifdef GL_MESA_ycbcr_texture\n\n#endif /* GL_MESA_ycbcr_texture */\n\n#ifdef GL_NV_blend_square\n\n#endif /* GL_NV_blend_square */\n\n#ifdef GL_NV_conditional_render\n\nstatic GLboolean _glewInit_GL_NV_conditional_render (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginConditionalRenderNV = (PFNGLBEGINCONDITIONALRENDERNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginConditionalRenderNV\")) == NULL) || r;\n  r = ((glEndConditionalRenderNV = (PFNGLENDCONDITIONALRENDERNVPROC)glewGetProcAddress((const GLubyte*)\"glEndConditionalRenderNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_conditional_render */\n\n#ifdef GL_NV_copy_depth_to_color\n\n#endif /* GL_NV_copy_depth_to_color */\n\n#ifdef GL_NV_depth_buffer_float\n\nstatic GLboolean _glewInit_GL_NV_depth_buffer_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearDepthdNV = (PFNGLCLEARDEPTHDNVPROC)glewGetProcAddress((const GLubyte*)\"glClearDepthdNV\")) == NULL) || r;\n  r = ((glDepthBoundsdNV = (PFNGLDEPTHBOUNDSDNVPROC)glewGetProcAddress((const GLubyte*)\"glDepthBoundsdNV\")) == NULL) || r;\n  r = ((glDepthRangedNV = (PFNGLDEPTHRANGEDNVPROC)glewGetProcAddress((const GLubyte*)\"glDepthRangedNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_depth_buffer_float */\n\n#ifdef GL_NV_depth_clamp\n\n#endif /* GL_NV_depth_clamp */\n\n#ifdef GL_NV_depth_range_unclamped\n\n#endif /* GL_NV_depth_range_unclamped */\n\n#ifdef GL_NV_evaluators\n\nstatic GLboolean _glewInit_GL_NV_evaluators (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glEvalMapsNV = (PFNGLEVALMAPSNVPROC)glewGetProcAddress((const GLubyte*)\"glEvalMapsNV\")) == NULL) || r;\n  r = ((glGetMapAttribParameterfvNV = (PFNGLGETMAPATTRIBPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapAttribParameterfvNV\")) == NULL) || r;\n  r = ((glGetMapAttribParameterivNV = (PFNGLGETMAPATTRIBPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapAttribParameterivNV\")) == NULL) || r;\n  r = ((glGetMapControlPointsNV = (PFNGLGETMAPCONTROLPOINTSNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapControlPointsNV\")) == NULL) || r;\n  r = ((glGetMapParameterfvNV = (PFNGLGETMAPPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapParameterfvNV\")) == NULL) || r;\n  r = ((glGetMapParameterivNV = (PFNGLGETMAPPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMapParameterivNV\")) == NULL) || r;\n  r = ((glMapControlPointsNV = (PFNGLMAPCONTROLPOINTSNVPROC)glewGetProcAddress((const GLubyte*)\"glMapControlPointsNV\")) == NULL) || r;\n  r = ((glMapParameterfvNV = (PFNGLMAPPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glMapParameterfvNV\")) == NULL) || r;\n  r = ((glMapParameterivNV = (PFNGLMAPPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glMapParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_evaluators */\n\n#ifdef GL_NV_explicit_multisample\n\nstatic GLboolean _glewInit_GL_NV_explicit_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetMultisamplefvNV = (PFNGLGETMULTISAMPLEFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetMultisamplefvNV\")) == NULL) || r;\n  r = ((glSampleMaskIndexedNV = (PFNGLSAMPLEMASKINDEXEDNVPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskIndexedNV\")) == NULL) || r;\n  r = ((glTexRenderbufferNV = (PFNGLTEXRENDERBUFFERNVPROC)glewGetProcAddress((const GLubyte*)\"glTexRenderbufferNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_explicit_multisample */\n\n#ifdef GL_NV_fence\n\nstatic GLboolean _glewInit_GL_NV_fence (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDeleteFencesNV = (PFNGLDELETEFENCESNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteFencesNV\")) == NULL) || r;\n  r = ((glFinishFenceNV = (PFNGLFINISHFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glFinishFenceNV\")) == NULL) || r;\n  r = ((glGenFencesNV = (PFNGLGENFENCESNVPROC)glewGetProcAddress((const GLubyte*)\"glGenFencesNV\")) == NULL) || r;\n  r = ((glGetFenceivNV = (PFNGLGETFENCEIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFenceivNV\")) == NULL) || r;\n  r = ((glIsFenceNV = (PFNGLISFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glIsFenceNV\")) == NULL) || r;\n  r = ((glSetFenceNV = (PFNGLSETFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glSetFenceNV\")) == NULL) || r;\n  r = ((glTestFenceNV = (PFNGLTESTFENCENVPROC)glewGetProcAddress((const GLubyte*)\"glTestFenceNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_fence */\n\n#ifdef GL_NV_float_buffer\n\n#endif /* GL_NV_float_buffer */\n\n#ifdef GL_NV_fog_distance\n\n#endif /* GL_NV_fog_distance */\n\n#ifdef GL_NV_fragment_program\n\nstatic GLboolean _glewInit_GL_NV_fragment_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetProgramNamedParameterdvNV = (PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramNamedParameterdvNV\")) == NULL) || r;\n  r = ((glGetProgramNamedParameterfvNV = (PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramNamedParameterfvNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4dNV = (PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4dNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4dvNV = (PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4dvNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4fNV = (PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4fNV\")) == NULL) || r;\n  r = ((glProgramNamedParameter4fvNV = (PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramNamedParameter4fvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_fragment_program */\n\n#ifdef GL_NV_fragment_program2\n\n#endif /* GL_NV_fragment_program2 */\n\n#ifdef GL_NV_fragment_program4\n\n#endif /* GL_NV_fragment_program4 */\n\n#ifdef GL_NV_fragment_program_option\n\n#endif /* GL_NV_fragment_program_option */\n\n#ifdef GL_NV_framebuffer_multisample_coverage\n\nstatic GLboolean _glewInit_GL_NV_framebuffer_multisample_coverage (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glRenderbufferStorageMultisampleCoverageNV = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)glewGetProcAddress((const GLubyte*)\"glRenderbufferStorageMultisampleCoverageNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_framebuffer_multisample_coverage */\n\n#ifdef GL_NV_geometry_program4\n\nstatic GLboolean _glewInit_GL_NV_geometry_program4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramVertexLimitNV = (PFNGLPROGRAMVERTEXLIMITNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramVertexLimitNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_geometry_program4 */\n\n#ifdef GL_NV_geometry_shader4\n\n#endif /* GL_NV_geometry_shader4 */\n\n#ifdef GL_NV_gpu_program4\n\nstatic GLboolean _glewInit_GL_NV_gpu_program4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramEnvParameterI4iNV = (PFNGLPROGRAMENVPARAMETERI4INVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4iNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4ivNV = (PFNGLPROGRAMENVPARAMETERI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4ivNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4uiNV = (PFNGLPROGRAMENVPARAMETERI4UINVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4uiNV\")) == NULL) || r;\n  r = ((glProgramEnvParameterI4uivNV = (PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParameterI4uivNV\")) == NULL) || r;\n  r = ((glProgramEnvParametersI4ivNV = (PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParametersI4ivNV\")) == NULL) || r;\n  r = ((glProgramEnvParametersI4uivNV = (PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramEnvParametersI4uivNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4iNV = (PFNGLPROGRAMLOCALPARAMETERI4INVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4iNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4ivNV = (PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4ivNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4uiNV = (PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4uiNV\")) == NULL) || r;\n  r = ((glProgramLocalParameterI4uivNV = (PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParameterI4uivNV\")) == NULL) || r;\n  r = ((glProgramLocalParametersI4ivNV = (PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParametersI4ivNV\")) == NULL) || r;\n  r = ((glProgramLocalParametersI4uivNV = (PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramLocalParametersI4uivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_gpu_program4 */\n\n#ifdef GL_NV_half_float\n\nstatic GLboolean _glewInit_GL_NV_half_float (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColor3hNV = (PFNGLCOLOR3HNVPROC)glewGetProcAddress((const GLubyte*)\"glColor3hNV\")) == NULL) || r;\n  r = ((glColor3hvNV = (PFNGLCOLOR3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glColor3hvNV\")) == NULL) || r;\n  r = ((glColor4hNV = (PFNGLCOLOR4HNVPROC)glewGetProcAddress((const GLubyte*)\"glColor4hNV\")) == NULL) || r;\n  r = ((glColor4hvNV = (PFNGLCOLOR4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glColor4hvNV\")) == NULL) || r;\n  r = ((glFogCoordhNV = (PFNGLFOGCOORDHNVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordhNV\")) == NULL) || r;\n  r = ((glFogCoordhvNV = (PFNGLFOGCOORDHVNVPROC)glewGetProcAddress((const GLubyte*)\"glFogCoordhvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord1hNV = (PFNGLMULTITEXCOORD1HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord1hvNV = (PFNGLMULTITEXCOORD1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord1hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord2hNV = (PFNGLMULTITEXCOORD2HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord2hvNV = (PFNGLMULTITEXCOORD2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord2hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord3hNV = (PFNGLMULTITEXCOORD3HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord3hvNV = (PFNGLMULTITEXCOORD3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord3hvNV\")) == NULL) || r;\n  r = ((glMultiTexCoord4hNV = (PFNGLMULTITEXCOORD4HNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4hNV\")) == NULL) || r;\n  r = ((glMultiTexCoord4hvNV = (PFNGLMULTITEXCOORD4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glMultiTexCoord4hvNV\")) == NULL) || r;\n  r = ((glNormal3hNV = (PFNGLNORMAL3HNVPROC)glewGetProcAddress((const GLubyte*)\"glNormal3hNV\")) == NULL) || r;\n  r = ((glNormal3hvNV = (PFNGLNORMAL3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glNormal3hvNV\")) == NULL) || r;\n  r = ((glSecondaryColor3hNV = (PFNGLSECONDARYCOLOR3HNVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3hNV\")) == NULL) || r;\n  r = ((glSecondaryColor3hvNV = (PFNGLSECONDARYCOLOR3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glSecondaryColor3hvNV\")) == NULL) || r;\n  r = ((glTexCoord1hNV = (PFNGLTEXCOORD1HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord1hNV\")) == NULL) || r;\n  r = ((glTexCoord1hvNV = (PFNGLTEXCOORD1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord1hvNV\")) == NULL) || r;\n  r = ((glTexCoord2hNV = (PFNGLTEXCOORD2HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2hNV\")) == NULL) || r;\n  r = ((glTexCoord2hvNV = (PFNGLTEXCOORD2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2hvNV\")) == NULL) || r;\n  r = ((glTexCoord3hNV = (PFNGLTEXCOORD3HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord3hNV\")) == NULL) || r;\n  r = ((glTexCoord3hvNV = (PFNGLTEXCOORD3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord3hvNV\")) == NULL) || r;\n  r = ((glTexCoord4hNV = (PFNGLTEXCOORD4HNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4hNV\")) == NULL) || r;\n  r = ((glTexCoord4hvNV = (PFNGLTEXCOORD4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4hvNV\")) == NULL) || r;\n  r = ((glVertex2hNV = (PFNGLVERTEX2HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex2hNV\")) == NULL) || r;\n  r = ((glVertex2hvNV = (PFNGLVERTEX2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex2hvNV\")) == NULL) || r;\n  r = ((glVertex3hNV = (PFNGLVERTEX3HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex3hNV\")) == NULL) || r;\n  r = ((glVertex3hvNV = (PFNGLVERTEX3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex3hvNV\")) == NULL) || r;\n  r = ((glVertex4hNV = (PFNGLVERTEX4HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex4hNV\")) == NULL) || r;\n  r = ((glVertex4hvNV = (PFNGLVERTEX4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertex4hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1hNV = (PFNGLVERTEXATTRIB1HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1hNV\")) == NULL) || r;\n  r = ((glVertexAttrib1hvNV = (PFNGLVERTEXATTRIB1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2hNV = (PFNGLVERTEXATTRIB2HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2hNV\")) == NULL) || r;\n  r = ((glVertexAttrib2hvNV = (PFNGLVERTEXATTRIB2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3hNV = (PFNGLVERTEXATTRIB3HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3hNV\")) == NULL) || r;\n  r = ((glVertexAttrib3hvNV = (PFNGLVERTEXATTRIB3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3hvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4hNV = (PFNGLVERTEXATTRIB4HNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4hNV\")) == NULL) || r;\n  r = ((glVertexAttrib4hvNV = (PFNGLVERTEXATTRIB4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1hvNV = (PFNGLVERTEXATTRIBS1HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2hvNV = (PFNGLVERTEXATTRIBS2HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3hvNV = (PFNGLVERTEXATTRIBS3HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3hvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4hvNV = (PFNGLVERTEXATTRIBS4HVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4hvNV\")) == NULL) || r;\n  r = ((glVertexWeighthNV = (PFNGLVERTEXWEIGHTHNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeighthNV\")) == NULL) || r;\n  r = ((glVertexWeighthvNV = (PFNGLVERTEXWEIGHTHVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexWeighthvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_half_float */\n\n#ifdef GL_NV_light_max_exponent\n\n#endif /* GL_NV_light_max_exponent */\n\n#ifdef GL_NV_multisample_filter_hint\n\n#endif /* GL_NV_multisample_filter_hint */\n\n#ifdef GL_NV_occlusion_query\n\nstatic GLboolean _glewInit_GL_NV_occlusion_query (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glBeginOcclusionQueryNV = (PFNGLBEGINOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginOcclusionQueryNV\")) == NULL) || r;\n  r = ((glDeleteOcclusionQueriesNV = (PFNGLDELETEOCCLUSIONQUERIESNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteOcclusionQueriesNV\")) == NULL) || r;\n  r = ((glEndOcclusionQueryNV = (PFNGLENDOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glEndOcclusionQueryNV\")) == NULL) || r;\n  r = ((glGenOcclusionQueriesNV = (PFNGLGENOCCLUSIONQUERIESNVPROC)glewGetProcAddress((const GLubyte*)\"glGenOcclusionQueriesNV\")) == NULL) || r;\n  r = ((glGetOcclusionQueryivNV = (PFNGLGETOCCLUSIONQUERYIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetOcclusionQueryivNV\")) == NULL) || r;\n  r = ((glGetOcclusionQueryuivNV = (PFNGLGETOCCLUSIONQUERYUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetOcclusionQueryuivNV\")) == NULL) || r;\n  r = ((glIsOcclusionQueryNV = (PFNGLISOCCLUSIONQUERYNVPROC)glewGetProcAddress((const GLubyte*)\"glIsOcclusionQueryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_occlusion_query */\n\n#ifdef GL_NV_packed_depth_stencil\n\n#endif /* GL_NV_packed_depth_stencil */\n\n#ifdef GL_NV_parameter_buffer_object\n\nstatic GLboolean _glewInit_GL_NV_parameter_buffer_object (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glProgramBufferParametersIivNV = (PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersIivNV\")) == NULL) || r;\n  r = ((glProgramBufferParametersIuivNV = (PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersIuivNV\")) == NULL) || r;\n  r = ((glProgramBufferParametersfvNV = (PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramBufferParametersfvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_parameter_buffer_object */\n\n#ifdef GL_NV_pixel_data_range\n\nstatic GLboolean _glewInit_GL_NV_pixel_data_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushPixelDataRangeNV = (PFNGLFLUSHPIXELDATARANGENVPROC)glewGetProcAddress((const GLubyte*)\"glFlushPixelDataRangeNV\")) == NULL) || r;\n  r = ((glPixelDataRangeNV = (PFNGLPIXELDATARANGENVPROC)glewGetProcAddress((const GLubyte*)\"glPixelDataRangeNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_pixel_data_range */\n\n#ifdef GL_NV_point_sprite\n\nstatic GLboolean _glewInit_GL_NV_point_sprite (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPointParameteriNV = (PFNGLPOINTPARAMETERINVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameteriNV\")) == NULL) || r;\n  r = ((glPointParameterivNV = (PFNGLPOINTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glPointParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_point_sprite */\n\n#ifdef GL_NV_present_video\n\nstatic GLboolean _glewInit_GL_NV_present_video (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetVideoi64vNV = (PFNGLGETVIDEOI64VNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoi64vNV\")) == NULL) || r;\n  r = ((glGetVideoivNV = (PFNGLGETVIDEOIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoivNV\")) == NULL) || r;\n  r = ((glGetVideoui64vNV = (PFNGLGETVIDEOUI64VNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideoui64vNV\")) == NULL) || r;\n  r = ((glGetVideouivNV = (PFNGLGETVIDEOUIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVideouivNV\")) == NULL) || r;\n  r = ((glPresentFrameDualFillNV = (PFNGLPRESENTFRAMEDUALFILLNVPROC)glewGetProcAddress((const GLubyte*)\"glPresentFrameDualFillNV\")) == NULL) || r;\n  r = ((glPresentFrameKeyedNV = (PFNGLPRESENTFRAMEKEYEDNVPROC)glewGetProcAddress((const GLubyte*)\"glPresentFrameKeyedNV\")) == NULL) || r;\n  r = ((glVideoParameterivNV = (PFNGLVIDEOPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glVideoParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_present_video */\n\n#ifdef GL_NV_primitive_restart\n\nstatic GLboolean _glewInit_GL_NV_primitive_restart (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPrimitiveRestartIndexNV = (PFNGLPRIMITIVERESTARTINDEXNVPROC)glewGetProcAddress((const GLubyte*)\"glPrimitiveRestartIndexNV\")) == NULL) || r;\n  r = ((glPrimitiveRestartNV = (PFNGLPRIMITIVERESTARTNVPROC)glewGetProcAddress((const GLubyte*)\"glPrimitiveRestartNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_primitive_restart */\n\n#ifdef GL_NV_register_combiners\n\nstatic GLboolean _glewInit_GL_NV_register_combiners (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCombinerInputNV = (PFNGLCOMBINERINPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerInputNV\")) == NULL) || r;\n  r = ((glCombinerOutputNV = (PFNGLCOMBINEROUTPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerOutputNV\")) == NULL) || r;\n  r = ((glCombinerParameterfNV = (PFNGLCOMBINERPARAMETERFNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterfNV\")) == NULL) || r;\n  r = ((glCombinerParameterfvNV = (PFNGLCOMBINERPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterfvNV\")) == NULL) || r;\n  r = ((glCombinerParameteriNV = (PFNGLCOMBINERPARAMETERINVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameteriNV\")) == NULL) || r;\n  r = ((glCombinerParameterivNV = (PFNGLCOMBINERPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerParameterivNV\")) == NULL) || r;\n  r = ((glFinalCombinerInputNV = (PFNGLFINALCOMBINERINPUTNVPROC)glewGetProcAddress((const GLubyte*)\"glFinalCombinerInputNV\")) == NULL) || r;\n  r = ((glGetCombinerInputParameterfvNV = (PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerInputParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerInputParameterivNV = (PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerInputParameterivNV\")) == NULL) || r;\n  r = ((glGetCombinerOutputParameterfvNV = (PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerOutputParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerOutputParameterivNV = (PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerOutputParameterivNV\")) == NULL) || r;\n  r = ((glGetFinalCombinerInputParameterfvNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFinalCombinerInputParameterfvNV\")) == NULL) || r;\n  r = ((glGetFinalCombinerInputParameterivNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetFinalCombinerInputParameterivNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_register_combiners */\n\n#ifdef GL_NV_register_combiners2\n\nstatic GLboolean _glewInit_GL_NV_register_combiners2 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glCombinerStageParameterfvNV = (PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glCombinerStageParameterfvNV\")) == NULL) || r;\n  r = ((glGetCombinerStageParameterfvNV = (PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetCombinerStageParameterfvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_register_combiners2 */\n\n#ifdef GL_NV_texgen_emboss\n\n#endif /* GL_NV_texgen_emboss */\n\n#ifdef GL_NV_texgen_reflection\n\n#endif /* GL_NV_texgen_reflection */\n\n#ifdef GL_NV_texture_compression_vtc\n\n#endif /* GL_NV_texture_compression_vtc */\n\n#ifdef GL_NV_texture_env_combine4\n\n#endif /* GL_NV_texture_env_combine4 */\n\n#ifdef GL_NV_texture_expand_normal\n\n#endif /* GL_NV_texture_expand_normal */\n\n#ifdef GL_NV_texture_rectangle\n\n#endif /* GL_NV_texture_rectangle */\n\n#ifdef GL_NV_texture_shader\n\n#endif /* GL_NV_texture_shader */\n\n#ifdef GL_NV_texture_shader2\n\n#endif /* GL_NV_texture_shader2 */\n\n#ifdef GL_NV_texture_shader3\n\n#endif /* GL_NV_texture_shader3 */\n\n#ifdef GL_NV_transform_feedback\n\nstatic GLboolean _glewInit_GL_NV_transform_feedback (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glActiveVaryingNV = (PFNGLACTIVEVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glActiveVaryingNV\")) == NULL) || r;\n  r = ((glBeginTransformFeedbackNV = (PFNGLBEGINTRANSFORMFEEDBACKNVPROC)glewGetProcAddress((const GLubyte*)\"glBeginTransformFeedbackNV\")) == NULL) || r;\n  r = ((glBindBufferBaseNV = (PFNGLBINDBUFFERBASENVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferBaseNV\")) == NULL) || r;\n  r = ((glBindBufferOffsetNV = (PFNGLBINDBUFFEROFFSETNVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferOffsetNV\")) == NULL) || r;\n  r = ((glBindBufferRangeNV = (PFNGLBINDBUFFERRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glBindBufferRangeNV\")) == NULL) || r;\n  r = ((glEndTransformFeedbackNV = (PFNGLENDTRANSFORMFEEDBACKNVPROC)glewGetProcAddress((const GLubyte*)\"glEndTransformFeedbackNV\")) == NULL) || r;\n  r = ((glGetActiveVaryingNV = (PFNGLGETACTIVEVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetActiveVaryingNV\")) == NULL) || r;\n  r = ((glGetTransformFeedbackVaryingNV = (PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetTransformFeedbackVaryingNV\")) == NULL) || r;\n  r = ((glGetVaryingLocationNV = (PFNGLGETVARYINGLOCATIONNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVaryingLocationNV\")) == NULL) || r;\n  r = ((glTransformFeedbackAttribsNV = (PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackAttribsNV\")) == NULL) || r;\n  r = ((glTransformFeedbackVaryingsNV = (PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)glewGetProcAddress((const GLubyte*)\"glTransformFeedbackVaryingsNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_transform_feedback */\n\n#ifdef GL_NV_vertex_array_range\n\nstatic GLboolean _glewInit_GL_NV_vertex_array_range (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushVertexArrayRangeNV = (PFNGLFLUSHVERTEXARRAYRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glFlushVertexArrayRangeNV\")) == NULL) || r;\n  r = ((glVertexArrayRangeNV = (PFNGLVERTEXARRAYRANGENVPROC)glewGetProcAddress((const GLubyte*)\"glVertexArrayRangeNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_vertex_array_range */\n\n#ifdef GL_NV_vertex_array_range2\n\n#endif /* GL_NV_vertex_array_range2 */\n\n#ifdef GL_NV_vertex_program\n\nstatic GLboolean _glewInit_GL_NV_vertex_program (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAreProgramsResidentNV = (PFNGLAREPROGRAMSRESIDENTNVPROC)glewGetProcAddress((const GLubyte*)\"glAreProgramsResidentNV\")) == NULL) || r;\n  r = ((glBindProgramNV = (PFNGLBINDPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glBindProgramNV\")) == NULL) || r;\n  r = ((glDeleteProgramsNV = (PFNGLDELETEPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glDeleteProgramsNV\")) == NULL) || r;\n  r = ((glExecuteProgramNV = (PFNGLEXECUTEPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glExecuteProgramNV\")) == NULL) || r;\n  r = ((glGenProgramsNV = (PFNGLGENPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glGenProgramsNV\")) == NULL) || r;\n  r = ((glGetProgramParameterdvNV = (PFNGLGETPROGRAMPARAMETERDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramParameterdvNV\")) == NULL) || r;\n  r = ((glGetProgramParameterfvNV = (PFNGLGETPROGRAMPARAMETERFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramParameterfvNV\")) == NULL) || r;\n  r = ((glGetProgramStringNV = (PFNGLGETPROGRAMSTRINGNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramStringNV\")) == NULL) || r;\n  r = ((glGetProgramivNV = (PFNGLGETPROGRAMIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetProgramivNV\")) == NULL) || r;\n  r = ((glGetTrackMatrixivNV = (PFNGLGETTRACKMATRIXIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetTrackMatrixivNV\")) == NULL) || r;\n  r = ((glGetVertexAttribPointervNV = (PFNGLGETVERTEXATTRIBPOINTERVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribPointervNV\")) == NULL) || r;\n  r = ((glGetVertexAttribdvNV = (PFNGLGETVERTEXATTRIBDVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribdvNV\")) == NULL) || r;\n  r = ((glGetVertexAttribfvNV = (PFNGLGETVERTEXATTRIBFVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribfvNV\")) == NULL) || r;\n  r = ((glGetVertexAttribivNV = (PFNGLGETVERTEXATTRIBIVNVPROC)glewGetProcAddress((const GLubyte*)\"glGetVertexAttribivNV\")) == NULL) || r;\n  r = ((glIsProgramNV = (PFNGLISPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glIsProgramNV\")) == NULL) || r;\n  r = ((glLoadProgramNV = (PFNGLLOADPROGRAMNVPROC)glewGetProcAddress((const GLubyte*)\"glLoadProgramNV\")) == NULL) || r;\n  r = ((glProgramParameter4dNV = (PFNGLPROGRAMPARAMETER4DNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4dNV\")) == NULL) || r;\n  r = ((glProgramParameter4dvNV = (PFNGLPROGRAMPARAMETER4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4dvNV\")) == NULL) || r;\n  r = ((glProgramParameter4fNV = (PFNGLPROGRAMPARAMETER4FNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4fNV\")) == NULL) || r;\n  r = ((glProgramParameter4fvNV = (PFNGLPROGRAMPARAMETER4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameter4fvNV\")) == NULL) || r;\n  r = ((glProgramParameters4dvNV = (PFNGLPROGRAMPARAMETERS4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameters4dvNV\")) == NULL) || r;\n  r = ((glProgramParameters4fvNV = (PFNGLPROGRAMPARAMETERS4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glProgramParameters4fvNV\")) == NULL) || r;\n  r = ((glRequestResidentProgramsNV = (PFNGLREQUESTRESIDENTPROGRAMSNVPROC)glewGetProcAddress((const GLubyte*)\"glRequestResidentProgramsNV\")) == NULL) || r;\n  r = ((glTrackMatrixNV = (PFNGLTRACKMATRIXNVPROC)glewGetProcAddress((const GLubyte*)\"glTrackMatrixNV\")) == NULL) || r;\n  r = ((glVertexAttrib1dNV = (PFNGLVERTEXATTRIB1DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dNV\")) == NULL) || r;\n  r = ((glVertexAttrib1dvNV = (PFNGLVERTEXATTRIB1DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1fNV = (PFNGLVERTEXATTRIB1FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fNV\")) == NULL) || r;\n  r = ((glVertexAttrib1fvNV = (PFNGLVERTEXATTRIB1FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib1sNV = (PFNGLVERTEXATTRIB1SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1sNV\")) == NULL) || r;\n  r = ((glVertexAttrib1svNV = (PFNGLVERTEXATTRIB1SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib1svNV\")) == NULL) || r;\n  r = ((glVertexAttrib2dNV = (PFNGLVERTEXATTRIB2DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dNV\")) == NULL) || r;\n  r = ((glVertexAttrib2dvNV = (PFNGLVERTEXATTRIB2DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2fNV = (PFNGLVERTEXATTRIB2FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fNV\")) == NULL) || r;\n  r = ((glVertexAttrib2fvNV = (PFNGLVERTEXATTRIB2FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib2sNV = (PFNGLVERTEXATTRIB2SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2sNV\")) == NULL) || r;\n  r = ((glVertexAttrib2svNV = (PFNGLVERTEXATTRIB2SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib2svNV\")) == NULL) || r;\n  r = ((glVertexAttrib3dNV = (PFNGLVERTEXATTRIB3DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dNV\")) == NULL) || r;\n  r = ((glVertexAttrib3dvNV = (PFNGLVERTEXATTRIB3DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3fNV = (PFNGLVERTEXATTRIB3FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fNV\")) == NULL) || r;\n  r = ((glVertexAttrib3fvNV = (PFNGLVERTEXATTRIB3FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib3sNV = (PFNGLVERTEXATTRIB3SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3sNV\")) == NULL) || r;\n  r = ((glVertexAttrib3svNV = (PFNGLVERTEXATTRIB3SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib3svNV\")) == NULL) || r;\n  r = ((glVertexAttrib4dNV = (PFNGLVERTEXATTRIB4DNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dNV\")) == NULL) || r;\n  r = ((glVertexAttrib4dvNV = (PFNGLVERTEXATTRIB4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4dvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4fNV = (PFNGLVERTEXATTRIB4FNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fNV\")) == NULL) || r;\n  r = ((glVertexAttrib4fvNV = (PFNGLVERTEXATTRIB4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4fvNV\")) == NULL) || r;\n  r = ((glVertexAttrib4sNV = (PFNGLVERTEXATTRIB4SNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4sNV\")) == NULL) || r;\n  r = ((glVertexAttrib4svNV = (PFNGLVERTEXATTRIB4SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4svNV\")) == NULL) || r;\n  r = ((glVertexAttrib4ubNV = (PFNGLVERTEXATTRIB4UBNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubNV\")) == NULL) || r;\n  r = ((glVertexAttrib4ubvNV = (PFNGLVERTEXATTRIB4UBVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttrib4ubvNV\")) == NULL) || r;\n  r = ((glVertexAttribPointerNV = (PFNGLVERTEXATTRIBPOINTERNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribPointerNV\")) == NULL) || r;\n  r = ((glVertexAttribs1dvNV = (PFNGLVERTEXATTRIBS1DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1fvNV = (PFNGLVERTEXATTRIBS1FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs1svNV = (PFNGLVERTEXATTRIBS1SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs1svNV\")) == NULL) || r;\n  r = ((glVertexAttribs2dvNV = (PFNGLVERTEXATTRIBS2DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2fvNV = (PFNGLVERTEXATTRIBS2FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs2svNV = (PFNGLVERTEXATTRIBS2SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs2svNV\")) == NULL) || r;\n  r = ((glVertexAttribs3dvNV = (PFNGLVERTEXATTRIBS3DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3fvNV = (PFNGLVERTEXATTRIBS3FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs3svNV = (PFNGLVERTEXATTRIBS3SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs3svNV\")) == NULL) || r;\n  r = ((glVertexAttribs4dvNV = (PFNGLVERTEXATTRIBS4DVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4dvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4fvNV = (PFNGLVERTEXATTRIBS4FVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4fvNV\")) == NULL) || r;\n  r = ((glVertexAttribs4svNV = (PFNGLVERTEXATTRIBS4SVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4svNV\")) == NULL) || r;\n  r = ((glVertexAttribs4ubvNV = (PFNGLVERTEXATTRIBS4UBVNVPROC)glewGetProcAddress((const GLubyte*)\"glVertexAttribs4ubvNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_NV_vertex_program */\n\n#ifdef GL_NV_vertex_program1_1\n\n#endif /* GL_NV_vertex_program1_1 */\n\n#ifdef GL_NV_vertex_program2\n\n#endif /* GL_NV_vertex_program2 */\n\n#ifdef GL_NV_vertex_program2_option\n\n#endif /* GL_NV_vertex_program2_option */\n\n#ifdef GL_NV_vertex_program3\n\n#endif /* GL_NV_vertex_program3 */\n\n#ifdef GL_NV_vertex_program4\n\n#endif /* GL_NV_vertex_program4 */\n\n#ifdef GL_OES_byte_coordinates\n\n#endif /* GL_OES_byte_coordinates */\n\n#ifdef GL_OES_compressed_paletted_texture\n\n#endif /* GL_OES_compressed_paletted_texture */\n\n#ifdef GL_OES_read_format\n\n#endif /* GL_OES_read_format */\n\n#ifdef GL_OES_single_precision\n\nstatic GLboolean _glewInit_GL_OES_single_precision (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glClearDepthfOES = (PFNGLCLEARDEPTHFOESPROC)glewGetProcAddress((const GLubyte*)\"glClearDepthfOES\")) == NULL) || r;\n  r = ((glClipPlanefOES = (PFNGLCLIPPLANEFOESPROC)glewGetProcAddress((const GLubyte*)\"glClipPlanefOES\")) == NULL) || r;\n  r = ((glDepthRangefOES = (PFNGLDEPTHRANGEFOESPROC)glewGetProcAddress((const GLubyte*)\"glDepthRangefOES\")) == NULL) || r;\n  r = ((glFrustumfOES = (PFNGLFRUSTUMFOESPROC)glewGetProcAddress((const GLubyte*)\"glFrustumfOES\")) == NULL) || r;\n  r = ((glGetClipPlanefOES = (PFNGLGETCLIPPLANEFOESPROC)glewGetProcAddress((const GLubyte*)\"glGetClipPlanefOES\")) == NULL) || r;\n  r = ((glOrthofOES = (PFNGLORTHOFOESPROC)glewGetProcAddress((const GLubyte*)\"glOrthofOES\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_OES_single_precision */\n\n#ifdef GL_OML_interlace\n\n#endif /* GL_OML_interlace */\n\n#ifdef GL_OML_resample\n\n#endif /* GL_OML_resample */\n\n#ifdef GL_OML_subsample\n\n#endif /* GL_OML_subsample */\n\n#ifdef GL_PGI_misc_hints\n\n#endif /* GL_PGI_misc_hints */\n\n#ifdef GL_PGI_vertex_hints\n\n#endif /* GL_PGI_vertex_hints */\n\n#ifdef GL_REND_screen_coordinates\n\n#endif /* GL_REND_screen_coordinates */\n\n#ifdef GL_S3_s3tc\n\n#endif /* GL_S3_s3tc */\n\n#ifdef GL_SGIS_color_range\n\n#endif /* GL_SGIS_color_range */\n\n#ifdef GL_SGIS_detail_texture\n\nstatic GLboolean _glewInit_GL_SGIS_detail_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glDetailTexFuncSGIS = (PFNGLDETAILTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glDetailTexFuncSGIS\")) == NULL) || r;\n  r = ((glGetDetailTexFuncSGIS = (PFNGLGETDETAILTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetDetailTexFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_detail_texture */\n\n#ifdef GL_SGIS_fog_function\n\nstatic GLboolean _glewInit_GL_SGIS_fog_function (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFogFuncSGIS = (PFNGLFOGFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glFogFuncSGIS\")) == NULL) || r;\n  r = ((glGetFogFuncSGIS = (PFNGLGETFOGFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetFogFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_fog_function */\n\n#ifdef GL_SGIS_generate_mipmap\n\n#endif /* GL_SGIS_generate_mipmap */\n\n#ifdef GL_SGIS_multisample\n\nstatic GLboolean _glewInit_GL_SGIS_multisample (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSampleMaskSGIS = (PFNGLSAMPLEMASKSGISPROC)glewGetProcAddress((const GLubyte*)\"glSampleMaskSGIS\")) == NULL) || r;\n  r = ((glSamplePatternSGIS = (PFNGLSAMPLEPATTERNSGISPROC)glewGetProcAddress((const GLubyte*)\"glSamplePatternSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_multisample */\n\n#ifdef GL_SGIS_pixel_texture\n\n#endif /* GL_SGIS_pixel_texture */\n\n#ifdef GL_SGIS_point_line_texgen\n\n#endif /* GL_SGIS_point_line_texgen */\n\n#ifdef GL_SGIS_sharpen_texture\n\nstatic GLboolean _glewInit_GL_SGIS_sharpen_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetSharpenTexFuncSGIS = (PFNGLGETSHARPENTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetSharpenTexFuncSGIS\")) == NULL) || r;\n  r = ((glSharpenTexFuncSGIS = (PFNGLSHARPENTEXFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glSharpenTexFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_sharpen_texture */\n\n#ifdef GL_SGIS_texture4D\n\nstatic GLboolean _glewInit_GL_SGIS_texture4D (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTexImage4DSGIS = (PFNGLTEXIMAGE4DSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexImage4DSGIS\")) == NULL) || r;\n  r = ((glTexSubImage4DSGIS = (PFNGLTEXSUBIMAGE4DSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexSubImage4DSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_texture4D */\n\n#ifdef GL_SGIS_texture_border_clamp\n\n#endif /* GL_SGIS_texture_border_clamp */\n\n#ifdef GL_SGIS_texture_edge_clamp\n\n#endif /* GL_SGIS_texture_edge_clamp */\n\n#ifdef GL_SGIS_texture_filter4\n\nstatic GLboolean _glewInit_GL_SGIS_texture_filter4 (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGetTexFilterFuncSGIS = (PFNGLGETTEXFILTERFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glGetTexFilterFuncSGIS\")) == NULL) || r;\n  r = ((glTexFilterFuncSGIS = (PFNGLTEXFILTERFUNCSGISPROC)glewGetProcAddress((const GLubyte*)\"glTexFilterFuncSGIS\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIS_texture_filter4 */\n\n#ifdef GL_SGIS_texture_lod\n\n#endif /* GL_SGIS_texture_lod */\n\n#ifdef GL_SGIS_texture_select\n\n#endif /* GL_SGIS_texture_select */\n\n#ifdef GL_SGIX_async\n\nstatic GLboolean _glewInit_GL_SGIX_async (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAsyncMarkerSGIX = (PFNGLASYNCMARKERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glAsyncMarkerSGIX\")) == NULL) || r;\n  r = ((glDeleteAsyncMarkersSGIX = (PFNGLDELETEASYNCMARKERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glDeleteAsyncMarkersSGIX\")) == NULL) || r;\n  r = ((glFinishAsyncSGIX = (PFNGLFINISHASYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFinishAsyncSGIX\")) == NULL) || r;\n  r = ((glGenAsyncMarkersSGIX = (PFNGLGENASYNCMARKERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGenAsyncMarkersSGIX\")) == NULL) || r;\n  r = ((glIsAsyncMarkerSGIX = (PFNGLISASYNCMARKERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glIsAsyncMarkerSGIX\")) == NULL) || r;\n  r = ((glPollAsyncSGIX = (PFNGLPOLLASYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glPollAsyncSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_async */\n\n#ifdef GL_SGIX_async_histogram\n\n#endif /* GL_SGIX_async_histogram */\n\n#ifdef GL_SGIX_async_pixel\n\n#endif /* GL_SGIX_async_pixel */\n\n#ifdef GL_SGIX_blend_alpha_minmax\n\n#endif /* GL_SGIX_blend_alpha_minmax */\n\n#ifdef GL_SGIX_clipmap\n\n#endif /* GL_SGIX_clipmap */\n\n#ifdef GL_SGIX_convolution_accuracy\n\n#endif /* GL_SGIX_convolution_accuracy */\n\n#ifdef GL_SGIX_depth_texture\n\n#endif /* GL_SGIX_depth_texture */\n\n#ifdef GL_SGIX_flush_raster\n\nstatic GLboolean _glewInit_GL_SGIX_flush_raster (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFlushRasterSGIX = (PFNGLFLUSHRASTERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFlushRasterSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_flush_raster */\n\n#ifdef GL_SGIX_fog_offset\n\n#endif /* GL_SGIX_fog_offset */\n\n#ifdef GL_SGIX_fog_texture\n\nstatic GLboolean _glewInit_GL_SGIX_fog_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTextureFogSGIX = (PFNGLTEXTUREFOGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glTextureFogSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_fog_texture */\n\n#ifdef GL_SGIX_fragment_specular_lighting\n\nstatic GLboolean _glewInit_GL_SGIX_fragment_specular_lighting (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFragmentColorMaterialSGIX = (PFNGLFRAGMENTCOLORMATERIALSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentColorMaterialSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelfSGIX = (PFNGLFRAGMENTLIGHTMODELFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelfvSGIX = (PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelfvSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModeliSGIX = (PFNGLFRAGMENTLIGHTMODELISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModeliSGIX\")) == NULL) || r;\n  r = ((glFragmentLightModelivSGIX = (PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightModelivSGIX\")) == NULL) || r;\n  r = ((glFragmentLightfSGIX = (PFNGLFRAGMENTLIGHTFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfSGIX\")) == NULL) || r;\n  r = ((glFragmentLightfvSGIX = (PFNGLFRAGMENTLIGHTFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightfvSGIX\")) == NULL) || r;\n  r = ((glFragmentLightiSGIX = (PFNGLFRAGMENTLIGHTISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightiSGIX\")) == NULL) || r;\n  r = ((glFragmentLightivSGIX = (PFNGLFRAGMENTLIGHTIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentLightivSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialfSGIX = (PFNGLFRAGMENTMATERIALFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialfvSGIX = (PFNGLFRAGMENTMATERIALFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialfvSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialiSGIX = (PFNGLFRAGMENTMATERIALISGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialiSGIX\")) == NULL) || r;\n  r = ((glFragmentMaterialivSGIX = (PFNGLFRAGMENTMATERIALIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFragmentMaterialivSGIX\")) == NULL) || r;\n  r = ((glGetFragmentLightfvSGIX = (PFNGLGETFRAGMENTLIGHTFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightfvSGIX\")) == NULL) || r;\n  r = ((glGetFragmentLightivSGIX = (PFNGLGETFRAGMENTLIGHTIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentLightivSGIX\")) == NULL) || r;\n  r = ((glGetFragmentMaterialfvSGIX = (PFNGLGETFRAGMENTMATERIALFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialfvSGIX\")) == NULL) || r;\n  r = ((glGetFragmentMaterialivSGIX = (PFNGLGETFRAGMENTMATERIALIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glGetFragmentMaterialivSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_fragment_specular_lighting */\n\n#ifdef GL_SGIX_framezoom\n\nstatic GLboolean _glewInit_GL_SGIX_framezoom (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFrameZoomSGIX = (PFNGLFRAMEZOOMSGIXPROC)glewGetProcAddress((const GLubyte*)\"glFrameZoomSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_framezoom */\n\n#ifdef GL_SGIX_interlace\n\n#endif /* GL_SGIX_interlace */\n\n#ifdef GL_SGIX_ir_instrument1\n\n#endif /* GL_SGIX_ir_instrument1 */\n\n#ifdef GL_SGIX_list_priority\n\n#endif /* GL_SGIX_list_priority */\n\n#ifdef GL_SGIX_pixel_texture\n\nstatic GLboolean _glewInit_GL_SGIX_pixel_texture (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glPixelTexGenSGIX = (PFNGLPIXELTEXGENSGIXPROC)glewGetProcAddress((const GLubyte*)\"glPixelTexGenSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_pixel_texture */\n\n#ifdef GL_SGIX_pixel_texture_bits\n\n#endif /* GL_SGIX_pixel_texture_bits */\n\n#ifdef GL_SGIX_reference_plane\n\nstatic GLboolean _glewInit_GL_SGIX_reference_plane (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReferencePlaneSGIX = (PFNGLREFERENCEPLANESGIXPROC)glewGetProcAddress((const GLubyte*)\"glReferencePlaneSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_reference_plane */\n\n#ifdef GL_SGIX_resample\n\n#endif /* GL_SGIX_resample */\n\n#ifdef GL_SGIX_shadow\n\n#endif /* GL_SGIX_shadow */\n\n#ifdef GL_SGIX_shadow_ambient\n\n#endif /* GL_SGIX_shadow_ambient */\n\n#ifdef GL_SGIX_sprite\n\nstatic GLboolean _glewInit_GL_SGIX_sprite (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glSpriteParameterfSGIX = (PFNGLSPRITEPARAMETERFSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterfSGIX\")) == NULL) || r;\n  r = ((glSpriteParameterfvSGIX = (PFNGLSPRITEPARAMETERFVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterfvSGIX\")) == NULL) || r;\n  r = ((glSpriteParameteriSGIX = (PFNGLSPRITEPARAMETERISGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameteriSGIX\")) == NULL) || r;\n  r = ((glSpriteParameterivSGIX = (PFNGLSPRITEPARAMETERIVSGIXPROC)glewGetProcAddress((const GLubyte*)\"glSpriteParameterivSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_sprite */\n\n#ifdef GL_SGIX_tag_sample_buffer\n\nstatic GLboolean _glewInit_GL_SGIX_tag_sample_buffer (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glTagSampleBufferSGIX = (PFNGLTAGSAMPLEBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glTagSampleBufferSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGIX_tag_sample_buffer */\n\n#ifdef GL_SGIX_texture_add_env\n\n#endif /* GL_SGIX_texture_add_env */\n\n#ifdef GL_SGIX_texture_coordinate_clamp\n\n#endif /* GL_SGIX_texture_coordinate_clamp */\n\n#ifdef GL_SGIX_texture_lod_bias\n\n#endif /* GL_SGIX_texture_lod_bias */\n\n#ifdef GL_SGIX_texture_multi_buffer\n\n#endif /* GL_SGIX_texture_multi_buffer */\n\n#ifdef GL_SGIX_texture_range\n\n#endif /* GL_SGIX_texture_range */\n\n#ifdef GL_SGIX_texture_scale_bias\n\n#endif /* GL_SGIX_texture_scale_bias */\n\n#ifdef GL_SGIX_vertex_preclip\n\n#endif /* GL_SGIX_vertex_preclip */\n\n#ifdef GL_SGIX_vertex_preclip_hint\n\n#endif /* GL_SGIX_vertex_preclip_hint */\n\n#ifdef GL_SGIX_ycrcb\n\n#endif /* GL_SGIX_ycrcb */\n\n#ifdef GL_SGI_color_matrix\n\n#endif /* GL_SGI_color_matrix */\n\n#ifdef GL_SGI_color_table\n\nstatic GLboolean _glewInit_GL_SGI_color_table (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColorTableParameterfvSGI = (PFNGLCOLORTABLEPARAMETERFVSGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterfvSGI\")) == NULL) || r;\n  r = ((glColorTableParameterivSGI = (PFNGLCOLORTABLEPARAMETERIVSGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableParameterivSGI\")) == NULL) || r;\n  r = ((glColorTableSGI = (PFNGLCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glColorTableSGI\")) == NULL) || r;\n  r = ((glCopyColorTableSGI = (PFNGLCOPYCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glCopyColorTableSGI\")) == NULL) || r;\n  r = ((glGetColorTableParameterfvSGI = (PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterfvSGI\")) == NULL) || r;\n  r = ((glGetColorTableParameterivSGI = (PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableParameterivSGI\")) == NULL) || r;\n  r = ((glGetColorTableSGI = (PFNGLGETCOLORTABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glGetColorTableSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SGI_color_table */\n\n#ifdef GL_SGI_texture_color_table\n\n#endif /* GL_SGI_texture_color_table */\n\n#ifdef GL_SUNX_constant_data\n\nstatic GLboolean _glewInit_GL_SUNX_constant_data (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glFinishTextureSUNX = (PFNGLFINISHTEXTURESUNXPROC)glewGetProcAddress((const GLubyte*)\"glFinishTextureSUNX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUNX_constant_data */\n\n#ifdef GL_SUN_convolution_border_modes\n\n#endif /* GL_SUN_convolution_border_modes */\n\n#ifdef GL_SUN_global_alpha\n\nstatic GLboolean _glewInit_GL_SUN_global_alpha (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glGlobalAlphaFactorbSUN = (PFNGLGLOBALALPHAFACTORBSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorbSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactordSUN = (PFNGLGLOBALALPHAFACTORDSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactordSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorfSUN = (PFNGLGLOBALALPHAFACTORFSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorfSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactoriSUN = (PFNGLGLOBALALPHAFACTORISUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactoriSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorsSUN = (PFNGLGLOBALALPHAFACTORSSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorsSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorubSUN = (PFNGLGLOBALALPHAFACTORUBSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorubSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactoruiSUN = (PFNGLGLOBALALPHAFACTORUISUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactoruiSUN\")) == NULL) || r;\n  r = ((glGlobalAlphaFactorusSUN = (PFNGLGLOBALALPHAFACTORUSSUNPROC)glewGetProcAddress((const GLubyte*)\"glGlobalAlphaFactorusSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_global_alpha */\n\n#ifdef GL_SUN_mesh_array\n\n#endif /* GL_SUN_mesh_array */\n\n#ifdef GL_SUN_read_video_pixels\n\nstatic GLboolean _glewInit_GL_SUN_read_video_pixels (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReadVideoPixelsSUN = (PFNGLREADVIDEOPIXELSSUNPROC)glewGetProcAddress((const GLubyte*)\"glReadVideoPixelsSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_read_video_pixels */\n\n#ifdef GL_SUN_slice_accum\n\n#endif /* GL_SUN_slice_accum */\n\n#ifdef GL_SUN_triangle_list\n\nstatic GLboolean _glewInit_GL_SUN_triangle_list (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glReplacementCodePointerSUN = (PFNGLREPLACEMENTCODEPOINTERSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodePointerSUN\")) == NULL) || r;\n  r = ((glReplacementCodeubSUN = (PFNGLREPLACEMENTCODEUBSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeubSUN\")) == NULL) || r;\n  r = ((glReplacementCodeubvSUN = (PFNGLREPLACEMENTCODEUBVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeubvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiSUN = (PFNGLREPLACEMENTCODEUISUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuivSUN = (PFNGLREPLACEMENTCODEUIVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuivSUN\")) == NULL) || r;\n  r = ((glReplacementCodeusSUN = (PFNGLREPLACEMENTCODEUSSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeusSUN\")) == NULL) || r;\n  r = ((glReplacementCodeusvSUN = (PFNGLREPLACEMENTCODEUSVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeusvSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_triangle_list */\n\n#ifdef GL_SUN_vertex\n\nstatic GLboolean _glewInit_GL_SUN_vertex (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glColor3fVertex3fSUN = (PFNGLCOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glColor3fVertex3fvSUN = (PFNGLCOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glColor4fNormal3fVertex3fSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glColor4fNormal3fVertex3fvSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex2fSUN = (PFNGLCOLOR4UBVERTEX2FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex2fSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex2fvSUN = (PFNGLCOLOR4UBVERTEX2FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex2fvSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex3fSUN = (PFNGLCOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glColor4ubVertex3fvSUN = (PFNGLCOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glNormal3fVertex3fSUN = (PFNGLNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glNormal3fVertex3fvSUN = (PFNGLNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4ubVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiColor4ubVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiTexCoord2fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiTexCoord2fVertex3fvSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiVertex3fSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiVertex3fSUN\")) == NULL) || r;\n  r = ((glReplacementCodeuiVertex3fvSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glReplacementCodeuiVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4ubVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4ubVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fColor4ubVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fColor4ubVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fNormal3fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fNormal3fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord2fVertex3fSUN = (PFNGLTEXCOORD2FVERTEX3FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fVertex3fSUN\")) == NULL) || r;\n  r = ((glTexCoord2fVertex3fvSUN = (PFNGLTEXCOORD2FVERTEX3FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord2fVertex3fvSUN\")) == NULL) || r;\n  r = ((glTexCoord4fColor4fNormal3fVertex4fSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fColor4fNormal3fVertex4fSUN\")) == NULL) || r;\n  r = ((glTexCoord4fColor4fNormal3fVertex4fvSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fColor4fNormal3fVertex4fvSUN\")) == NULL) || r;\n  r = ((glTexCoord4fVertex4fSUN = (PFNGLTEXCOORD4FVERTEX4FSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fVertex4fSUN\")) == NULL) || r;\n  r = ((glTexCoord4fVertex4fvSUN = (PFNGLTEXCOORD4FVERTEX4FVSUNPROC)glewGetProcAddress((const GLubyte*)\"glTexCoord4fVertex4fvSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_SUN_vertex */\n\n#ifdef GL_WIN_phong_shading\n\n#endif /* GL_WIN_phong_shading */\n\n#ifdef GL_WIN_specular_fog\n\n#endif /* GL_WIN_specular_fog */\n\n#ifdef GL_WIN_swap_hint\n\nstatic GLboolean _glewInit_GL_WIN_swap_hint (GLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glAddSwapHintRectWIN = (PFNGLADDSWAPHINTRECTWINPROC)glewGetProcAddress((const GLubyte*)\"glAddSwapHintRectWIN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GL_WIN_swap_hint */\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * Search for name in the extensions string. Use of strstr()\n * is not sufficient because extension names can be prefixes of\n * other extension names. Could use strtok() but the constant\n * string returned by glGetString might be in read-only memory.\n */\nGLboolean glewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  p = (GLubyte*)glGetString(GL_EXTENSIONS);\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\n/* ------------------------------------------------------------------------- */\n\n/*\n * MT 2010-12-22: Always export this symbol so that AGL can be used on mac\n * by calling this function instead of glewInit() wrapper -- which would also\n * invoke GLX init -- and fail for pure AGL programs.\n\n * #ifndef GLEW_MX\n * static\n * #endif\n*/\nGLenum glewContextInit (GLEW_CONTEXT_ARG_DEF_LIST)\n{\n  const GLubyte* s;\n   GLuint dot, major, minor;\n   /* query opengl version */\n   s = glGetString(GL_VERSION);\n   dot = _glewStrCLen(s, '.');\n   major = dot-1;\n   minor = dot+1;\n   if (dot == 0 || s[minor] == '\\0')\n   return GLEW_ERROR_NO_GL_VERSION;\n   if (s[major] == '1' && s[minor] == '0')\n   {\n      return GLEW_ERROR_GL_VERSION_10_ONLY;\n   }\n   else\n   {\n      CONST_CAST(GLEW_VERSION_1_1) = GL_TRUE;\n      if (s[major] >= '2')\n      {\n         CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_1_5) = GL_TRUE;\n         CONST_CAST(GLEW_VERSION_2_0) = GL_TRUE;\n         if (s[minor] >= '1')\n         {\n            CONST_CAST(GLEW_VERSION_2_1) = GL_TRUE;\n         }\n      }\n      else\n      {\n         if (s[minor] >= '5')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '4')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '3')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] == '2')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_TRUE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n         if (s[minor] < '2')\n         {\n            CONST_CAST(GLEW_VERSION_1_2) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_3) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_4) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_1_5) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_0) = GL_FALSE;\n            CONST_CAST(GLEW_VERSION_2_1) = GL_FALSE;\n         }\n      }\n   }\n  /* initialize extensions */\n#ifdef GL_VERSION_1_2\n  if (glewExperimental || GLEW_VERSION_1_2) CONST_CAST(GLEW_VERSION_1_2) = !_glewInit_GL_VERSION_1_2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_2 */\n#ifdef GL_VERSION_1_3\n  if (glewExperimental || GLEW_VERSION_1_3) CONST_CAST(GLEW_VERSION_1_3) = !_glewInit_GL_VERSION_1_3(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_3 */\n#ifdef GL_VERSION_1_4\n  if (glewExperimental || GLEW_VERSION_1_4) CONST_CAST(GLEW_VERSION_1_4) = !_glewInit_GL_VERSION_1_4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_4 */\n#ifdef GL_VERSION_1_5\n  if (glewExperimental || GLEW_VERSION_1_5) CONST_CAST(GLEW_VERSION_1_5) = !_glewInit_GL_VERSION_1_5(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_1_5 */\n#ifdef GL_VERSION_2_0\n  if (glewExperimental || GLEW_VERSION_2_0) CONST_CAST(GLEW_VERSION_2_0) = !_glewInit_GL_VERSION_2_0(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_2_0 */\n#ifdef GL_VERSION_2_1\n  if (glewExperimental || GLEW_VERSION_2_1) CONST_CAST(GLEW_VERSION_2_1) = !_glewInit_GL_VERSION_2_1(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_2_1 */\n#ifdef GL_VERSION_3_0\n  if (glewExperimental || GLEW_VERSION_3_0) CONST_CAST(GLEW_VERSION_3_0) = !_glewInit_GL_VERSION_3_0(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_VERSION_3_0 */\n#ifdef GL_3DFX_multisample\n  CONST_CAST(GLEW_3DFX_multisample) = glewGetExtension(\"GL_3DFX_multisample\");\n#endif /* GL_3DFX_multisample */\n#ifdef GL_3DFX_tbuffer\n  CONST_CAST(GLEW_3DFX_tbuffer) = glewGetExtension(\"GL_3DFX_tbuffer\");\n  if (glewExperimental || GLEW_3DFX_tbuffer) CONST_CAST(GLEW_3DFX_tbuffer) = !_glewInit_GL_3DFX_tbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_3DFX_tbuffer */\n#ifdef GL_3DFX_texture_compression_FXT1\n  CONST_CAST(GLEW_3DFX_texture_compression_FXT1) = glewGetExtension(\"GL_3DFX_texture_compression_FXT1\");\n#endif /* GL_3DFX_texture_compression_FXT1 */\n#ifdef GL_APPLE_client_storage\n  CONST_CAST(GLEW_APPLE_client_storage) = glewGetExtension(\"GL_APPLE_client_storage\");\n#endif /* GL_APPLE_client_storage */\n#ifdef GL_APPLE_element_array\n  CONST_CAST(GLEW_APPLE_element_array) = glewGetExtension(\"GL_APPLE_element_array\");\n  if (glewExperimental || GLEW_APPLE_element_array) CONST_CAST(GLEW_APPLE_element_array) = !_glewInit_GL_APPLE_element_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_element_array */\n#ifdef GL_APPLE_fence\n  CONST_CAST(GLEW_APPLE_fence) = glewGetExtension(\"GL_APPLE_fence\");\n  if (glewExperimental || GLEW_APPLE_fence) CONST_CAST(GLEW_APPLE_fence) = !_glewInit_GL_APPLE_fence(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_fence */\n#ifdef GL_APPLE_float_pixels\n  CONST_CAST(GLEW_APPLE_float_pixels) = glewGetExtension(\"GL_APPLE_float_pixels\");\n#endif /* GL_APPLE_float_pixels */\n#ifdef GL_APPLE_flush_buffer_range\n  CONST_CAST(GLEW_APPLE_flush_buffer_range) = glewGetExtension(\"GL_APPLE_flush_buffer_range\");\n  if (glewExperimental || GLEW_APPLE_flush_buffer_range) CONST_CAST(GLEW_APPLE_flush_buffer_range) = !_glewInit_GL_APPLE_flush_buffer_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_flush_buffer_range */\n#ifdef GL_APPLE_pixel_buffer\n  CONST_CAST(GLEW_APPLE_pixel_buffer) = glewGetExtension(\"GL_APPLE_pixel_buffer\");\n#endif /* GL_APPLE_pixel_buffer */\n#ifdef GL_APPLE_specular_vector\n  CONST_CAST(GLEW_APPLE_specular_vector) = glewGetExtension(\"GL_APPLE_specular_vector\");\n#endif /* GL_APPLE_specular_vector */\n#ifdef GL_APPLE_texture_range\n  CONST_CAST(GLEW_APPLE_texture_range) = glewGetExtension(\"GL_APPLE_texture_range\");\n  if (glewExperimental || GLEW_APPLE_texture_range) CONST_CAST(GLEW_APPLE_texture_range) = !_glewInit_GL_APPLE_texture_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_texture_range */\n#ifdef GL_APPLE_transform_hint\n  CONST_CAST(GLEW_APPLE_transform_hint) = glewGetExtension(\"GL_APPLE_transform_hint\");\n#endif /* GL_APPLE_transform_hint */\n#ifdef GL_APPLE_vertex_array_object\n  CONST_CAST(GLEW_APPLE_vertex_array_object) = glewGetExtension(\"GL_APPLE_vertex_array_object\");\n  if (glewExperimental || GLEW_APPLE_vertex_array_object) CONST_CAST(GLEW_APPLE_vertex_array_object) = !_glewInit_GL_APPLE_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_vertex_array_object */\n#ifdef GL_APPLE_vertex_array_range\n  CONST_CAST(GLEW_APPLE_vertex_array_range) = glewGetExtension(\"GL_APPLE_vertex_array_range\");\n  if (glewExperimental || GLEW_APPLE_vertex_array_range) CONST_CAST(GLEW_APPLE_vertex_array_range) = !_glewInit_GL_APPLE_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_APPLE_vertex_array_range */\n#ifdef GL_APPLE_ycbcr_422\n  CONST_CAST(GLEW_APPLE_ycbcr_422) = glewGetExtension(\"GL_APPLE_ycbcr_422\");\n#endif /* GL_APPLE_ycbcr_422 */\n#ifdef GL_ARB_color_buffer_float\n  CONST_CAST(GLEW_ARB_color_buffer_float) = glewGetExtension(\"GL_ARB_color_buffer_float\");\n  if (glewExperimental || GLEW_ARB_color_buffer_float) CONST_CAST(GLEW_ARB_color_buffer_float) = !_glewInit_GL_ARB_color_buffer_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_color_buffer_float */\n#ifdef GL_ARB_depth_buffer_float\n  CONST_CAST(GLEW_ARB_depth_buffer_float) = glewGetExtension(\"GL_ARB_depth_buffer_float\");\n#endif /* GL_ARB_depth_buffer_float */\n#ifdef GL_ARB_depth_texture\n  CONST_CAST(GLEW_ARB_depth_texture) = glewGetExtension(\"GL_ARB_depth_texture\");\n#endif /* GL_ARB_depth_texture */\n#ifdef GL_ARB_draw_buffers\n  CONST_CAST(GLEW_ARB_draw_buffers) = glewGetExtension(\"GL_ARB_draw_buffers\");\n  if (glewExperimental || GLEW_ARB_draw_buffers) CONST_CAST(GLEW_ARB_draw_buffers) = !_glewInit_GL_ARB_draw_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_draw_buffers */\n#ifdef GL_ARB_draw_instanced\n  CONST_CAST(GLEW_ARB_draw_instanced) = glewGetExtension(\"GL_ARB_draw_instanced\");\n  if (glewExperimental || GLEW_ARB_draw_instanced) CONST_CAST(GLEW_ARB_draw_instanced) = !_glewInit_GL_ARB_draw_instanced(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_draw_instanced */\n#ifdef GL_ARB_fragment_program\n  CONST_CAST(GLEW_ARB_fragment_program) = glewGetExtension(\"GL_ARB_fragment_program\");\n#endif /* GL_ARB_fragment_program */\n#ifdef GL_ARB_fragment_program_shadow\n  CONST_CAST(GLEW_ARB_fragment_program_shadow) = glewGetExtension(\"GL_ARB_fragment_program_shadow\");\n#endif /* GL_ARB_fragment_program_shadow */\n#ifdef GL_ARB_fragment_shader\n  CONST_CAST(GLEW_ARB_fragment_shader) = glewGetExtension(\"GL_ARB_fragment_shader\");\n#endif /* GL_ARB_fragment_shader */\n#ifdef GL_ARB_framebuffer_object\n  CONST_CAST(GLEW_ARB_framebuffer_object) = glewGetExtension(\"GL_ARB_framebuffer_object\");\n  if (glewExperimental || GLEW_ARB_framebuffer_object) CONST_CAST(GLEW_ARB_framebuffer_object) = !_glewInit_GL_ARB_framebuffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_framebuffer_object */\n#ifdef GL_ARB_framebuffer_sRGB\n  CONST_CAST(GLEW_ARB_framebuffer_sRGB) = glewGetExtension(\"GL_ARB_framebuffer_sRGB\");\n#endif /* GL_ARB_framebuffer_sRGB */\n#ifdef GL_ARB_geometry_shader4\n  CONST_CAST(GLEW_ARB_geometry_shader4) = glewGetExtension(\"GL_ARB_geometry_shader4\");\n  if (glewExperimental || GLEW_ARB_geometry_shader4) CONST_CAST(GLEW_ARB_geometry_shader4) = !_glewInit_GL_ARB_geometry_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_geometry_shader4 */\n#ifdef GL_ARB_half_float_pixel\n  CONST_CAST(GLEW_ARB_half_float_pixel) = glewGetExtension(\"GL_ARB_half_float_pixel\");\n#endif /* GL_ARB_half_float_pixel */\n#ifdef GL_ARB_half_float_vertex\n  CONST_CAST(GLEW_ARB_half_float_vertex) = glewGetExtension(\"GL_ARB_half_float_vertex\");\n#endif /* GL_ARB_half_float_vertex */\n#ifdef GL_ARB_imaging\n  CONST_CAST(GLEW_ARB_imaging) = glewGetExtension(\"GL_ARB_imaging\");\n  if (glewExperimental || GLEW_ARB_imaging) CONST_CAST(GLEW_ARB_imaging) = !_glewInit_GL_ARB_imaging(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_imaging */\n#ifdef GL_ARB_instanced_arrays\n  CONST_CAST(GLEW_ARB_instanced_arrays) = glewGetExtension(\"GL_ARB_instanced_arrays\");\n  if (glewExperimental || GLEW_ARB_instanced_arrays) CONST_CAST(GLEW_ARB_instanced_arrays) = !_glewInit_GL_ARB_instanced_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_instanced_arrays */\n#ifdef GL_ARB_map_buffer_range\n  CONST_CAST(GLEW_ARB_map_buffer_range) = glewGetExtension(\"GL_ARB_map_buffer_range\");\n  if (glewExperimental || GLEW_ARB_map_buffer_range) CONST_CAST(GLEW_ARB_map_buffer_range) = !_glewInit_GL_ARB_map_buffer_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_map_buffer_range */\n#ifdef GL_ARB_matrix_palette\n  CONST_CAST(GLEW_ARB_matrix_palette) = glewGetExtension(\"GL_ARB_matrix_palette\");\n  if (glewExperimental || GLEW_ARB_matrix_palette) CONST_CAST(GLEW_ARB_matrix_palette) = !_glewInit_GL_ARB_matrix_palette(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_matrix_palette */\n#ifdef GL_ARB_multisample\n  CONST_CAST(GLEW_ARB_multisample) = glewGetExtension(\"GL_ARB_multisample\");\n  if (glewExperimental || GLEW_ARB_multisample) CONST_CAST(GLEW_ARB_multisample) = !_glewInit_GL_ARB_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_multisample */\n#ifdef GL_ARB_multitexture\n  CONST_CAST(GLEW_ARB_multitexture) = glewGetExtension(\"GL_ARB_multitexture\");\n  if (glewExperimental || GLEW_ARB_multitexture) CONST_CAST(GLEW_ARB_multitexture) = !_glewInit_GL_ARB_multitexture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_multitexture */\n#ifdef GL_ARB_occlusion_query\n  CONST_CAST(GLEW_ARB_occlusion_query) = glewGetExtension(\"GL_ARB_occlusion_query\");\n  if (glewExperimental || GLEW_ARB_occlusion_query) CONST_CAST(GLEW_ARB_occlusion_query) = !_glewInit_GL_ARB_occlusion_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_occlusion_query */\n#ifdef GL_ARB_pixel_buffer_object\n  CONST_CAST(GLEW_ARB_pixel_buffer_object) = glewGetExtension(\"GL_ARB_pixel_buffer_object\");\n#endif /* GL_ARB_pixel_buffer_object */\n#ifdef GL_ARB_point_parameters\n  CONST_CAST(GLEW_ARB_point_parameters) = glewGetExtension(\"GL_ARB_point_parameters\");\n  if (glewExperimental || GLEW_ARB_point_parameters) CONST_CAST(GLEW_ARB_point_parameters) = !_glewInit_GL_ARB_point_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_point_parameters */\n#ifdef GL_ARB_point_sprite\n  CONST_CAST(GLEW_ARB_point_sprite) = glewGetExtension(\"GL_ARB_point_sprite\");\n#endif /* GL_ARB_point_sprite */\n#ifdef GL_ARB_shader_objects\n  CONST_CAST(GLEW_ARB_shader_objects) = glewGetExtension(\"GL_ARB_shader_objects\");\n  if (glewExperimental || GLEW_ARB_shader_objects) CONST_CAST(GLEW_ARB_shader_objects) = !_glewInit_GL_ARB_shader_objects(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_shader_objects */\n#ifdef GL_ARB_shading_language_100\n  CONST_CAST(GLEW_ARB_shading_language_100) = glewGetExtension(\"GL_ARB_shading_language_100\");\n#endif /* GL_ARB_shading_language_100 */\n#ifdef GL_ARB_shadow\n  CONST_CAST(GLEW_ARB_shadow) = glewGetExtension(\"GL_ARB_shadow\");\n#endif /* GL_ARB_shadow */\n#ifdef GL_ARB_shadow_ambient\n  CONST_CAST(GLEW_ARB_shadow_ambient) = glewGetExtension(\"GL_ARB_shadow_ambient\");\n#endif /* GL_ARB_shadow_ambient */\n#ifdef GL_ARB_texture_border_clamp\n  CONST_CAST(GLEW_ARB_texture_border_clamp) = glewGetExtension(\"GL_ARB_texture_border_clamp\");\n#endif /* GL_ARB_texture_border_clamp */\n#ifdef GL_ARB_texture_buffer_object\n  CONST_CAST(GLEW_ARB_texture_buffer_object) = glewGetExtension(\"GL_ARB_texture_buffer_object\");\n  if (glewExperimental || GLEW_ARB_texture_buffer_object) CONST_CAST(GLEW_ARB_texture_buffer_object) = !_glewInit_GL_ARB_texture_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_texture_buffer_object */\n#ifdef GL_ARB_texture_compression\n  CONST_CAST(GLEW_ARB_texture_compression) = glewGetExtension(\"GL_ARB_texture_compression\");\n  if (glewExperimental || GLEW_ARB_texture_compression) CONST_CAST(GLEW_ARB_texture_compression) = !_glewInit_GL_ARB_texture_compression(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_texture_compression */\n#ifdef GL_ARB_texture_compression_rgtc\n  CONST_CAST(GLEW_ARB_texture_compression_rgtc) = glewGetExtension(\"GL_ARB_texture_compression_rgtc\");\n#endif /* GL_ARB_texture_compression_rgtc */\n#ifdef GL_ARB_texture_cube_map\n  CONST_CAST(GLEW_ARB_texture_cube_map) = glewGetExtension(\"GL_ARB_texture_cube_map\");\n#endif /* GL_ARB_texture_cube_map */\n#ifdef GL_ARB_texture_env_add\n  CONST_CAST(GLEW_ARB_texture_env_add) = glewGetExtension(\"GL_ARB_texture_env_add\");\n#endif /* GL_ARB_texture_env_add */\n#ifdef GL_ARB_texture_env_combine\n  CONST_CAST(GLEW_ARB_texture_env_combine) = glewGetExtension(\"GL_ARB_texture_env_combine\");\n#endif /* GL_ARB_texture_env_combine */\n#ifdef GL_ARB_texture_env_crossbar\n  CONST_CAST(GLEW_ARB_texture_env_crossbar) = glewGetExtension(\"GL_ARB_texture_env_crossbar\");\n#endif /* GL_ARB_texture_env_crossbar */\n#ifdef GL_ARB_texture_env_dot3\n  CONST_CAST(GLEW_ARB_texture_env_dot3) = glewGetExtension(\"GL_ARB_texture_env_dot3\");\n#endif /* GL_ARB_texture_env_dot3 */\n#ifdef GL_ARB_texture_float\n  CONST_CAST(GLEW_ARB_texture_float) = glewGetExtension(\"GL_ARB_texture_float\");\n#endif /* GL_ARB_texture_float */\n#ifdef GL_ARB_texture_mirrored_repeat\n  CONST_CAST(GLEW_ARB_texture_mirrored_repeat) = glewGetExtension(\"GL_ARB_texture_mirrored_repeat\");\n#endif /* GL_ARB_texture_mirrored_repeat */\n#ifdef GL_ARB_texture_non_power_of_two\n  CONST_CAST(GLEW_ARB_texture_non_power_of_two) = glewGetExtension(\"GL_ARB_texture_non_power_of_two\");\n#endif /* GL_ARB_texture_non_power_of_two */\n#ifdef GL_ARB_texture_rectangle\n  CONST_CAST(GLEW_ARB_texture_rectangle) = glewGetExtension(\"GL_ARB_texture_rectangle\");\n#endif /* GL_ARB_texture_rectangle */\n#ifdef GL_ARB_texture_rg\n  CONST_CAST(GLEW_ARB_texture_rg) = glewGetExtension(\"GL_ARB_texture_rg\");\n#endif /* GL_ARB_texture_rg */\n#ifdef GL_ARB_transpose_matrix\n  CONST_CAST(GLEW_ARB_transpose_matrix) = glewGetExtension(\"GL_ARB_transpose_matrix\");\n  if (glewExperimental || GLEW_ARB_transpose_matrix) CONST_CAST(GLEW_ARB_transpose_matrix) = !_glewInit_GL_ARB_transpose_matrix(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_transpose_matrix */\n#ifdef GL_ARB_vertex_array_object\n  CONST_CAST(GLEW_ARB_vertex_array_object) = glewGetExtension(\"GL_ARB_vertex_array_object\");\n  if (glewExperimental || GLEW_ARB_vertex_array_object) CONST_CAST(GLEW_ARB_vertex_array_object) = !_glewInit_GL_ARB_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_array_object */\n#ifdef GL_ARB_vertex_blend\n  CONST_CAST(GLEW_ARB_vertex_blend) = glewGetExtension(\"GL_ARB_vertex_blend\");\n  if (glewExperimental || GLEW_ARB_vertex_blend) CONST_CAST(GLEW_ARB_vertex_blend) = !_glewInit_GL_ARB_vertex_blend(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_blend */\n#ifdef GL_ARB_vertex_buffer_object\n  CONST_CAST(GLEW_ARB_vertex_buffer_object) = glewGetExtension(\"GL_ARB_vertex_buffer_object\");\n  if (glewExperimental || GLEW_ARB_vertex_buffer_object) CONST_CAST(GLEW_ARB_vertex_buffer_object) = !_glewInit_GL_ARB_vertex_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_buffer_object */\n#ifdef GL_ARB_vertex_program\n  CONST_CAST(GLEW_ARB_vertex_program) = glewGetExtension(\"GL_ARB_vertex_program\");\n  if (glewExperimental || GLEW_ARB_vertex_program) CONST_CAST(GLEW_ARB_vertex_program) = !_glewInit_GL_ARB_vertex_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_program */\n#ifdef GL_ARB_vertex_shader\n  CONST_CAST(GLEW_ARB_vertex_shader) = glewGetExtension(\"GL_ARB_vertex_shader\");\n  if (glewExperimental || GLEW_ARB_vertex_shader) CONST_CAST(GLEW_ARB_vertex_shader) = !_glewInit_GL_ARB_vertex_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_vertex_shader */\n#ifdef GL_ARB_window_pos\n  CONST_CAST(GLEW_ARB_window_pos) = glewGetExtension(\"GL_ARB_window_pos\");\n  if (glewExperimental || GLEW_ARB_window_pos) CONST_CAST(GLEW_ARB_window_pos) = !_glewInit_GL_ARB_window_pos(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ARB_window_pos */\n#ifdef GL_ATIX_point_sprites\n  CONST_CAST(GLEW_ATIX_point_sprites) = glewGetExtension(\"GL_ATIX_point_sprites\");\n#endif /* GL_ATIX_point_sprites */\n#ifdef GL_ATIX_texture_env_combine3\n  CONST_CAST(GLEW_ATIX_texture_env_combine3) = glewGetExtension(\"GL_ATIX_texture_env_combine3\");\n#endif /* GL_ATIX_texture_env_combine3 */\n#ifdef GL_ATIX_texture_env_route\n  CONST_CAST(GLEW_ATIX_texture_env_route) = glewGetExtension(\"GL_ATIX_texture_env_route\");\n#endif /* GL_ATIX_texture_env_route */\n#ifdef GL_ATIX_vertex_shader_output_point_size\n  CONST_CAST(GLEW_ATIX_vertex_shader_output_point_size) = glewGetExtension(\"GL_ATIX_vertex_shader_output_point_size\");\n#endif /* GL_ATIX_vertex_shader_output_point_size */\n#ifdef GL_ATI_draw_buffers\n  CONST_CAST(GLEW_ATI_draw_buffers) = glewGetExtension(\"GL_ATI_draw_buffers\");\n  if (glewExperimental || GLEW_ATI_draw_buffers) CONST_CAST(GLEW_ATI_draw_buffers) = !_glewInit_GL_ATI_draw_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_draw_buffers */\n#ifdef GL_ATI_element_array\n  CONST_CAST(GLEW_ATI_element_array) = glewGetExtension(\"GL_ATI_element_array\");\n  if (glewExperimental || GLEW_ATI_element_array) CONST_CAST(GLEW_ATI_element_array) = !_glewInit_GL_ATI_element_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_element_array */\n#ifdef GL_ATI_envmap_bumpmap\n  CONST_CAST(GLEW_ATI_envmap_bumpmap) = glewGetExtension(\"GL_ATI_envmap_bumpmap\");\n  if (glewExperimental || GLEW_ATI_envmap_bumpmap) CONST_CAST(GLEW_ATI_envmap_bumpmap) = !_glewInit_GL_ATI_envmap_bumpmap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_envmap_bumpmap */\n#ifdef GL_ATI_fragment_shader\n  CONST_CAST(GLEW_ATI_fragment_shader) = glewGetExtension(\"GL_ATI_fragment_shader\");\n  if (glewExperimental || GLEW_ATI_fragment_shader) CONST_CAST(GLEW_ATI_fragment_shader) = !_glewInit_GL_ATI_fragment_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_fragment_shader */\n#ifdef GL_ATI_map_object_buffer\n  CONST_CAST(GLEW_ATI_map_object_buffer) = glewGetExtension(\"GL_ATI_map_object_buffer\");\n  if (glewExperimental || GLEW_ATI_map_object_buffer) CONST_CAST(GLEW_ATI_map_object_buffer) = !_glewInit_GL_ATI_map_object_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_map_object_buffer */\n#ifdef GL_ATI_pn_triangles\n  CONST_CAST(GLEW_ATI_pn_triangles) = glewGetExtension(\"GL_ATI_pn_triangles\");\n  if (glewExperimental || GLEW_ATI_pn_triangles) CONST_CAST(GLEW_ATI_pn_triangles) = !_glewInit_GL_ATI_pn_triangles(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_pn_triangles */\n#ifdef GL_ATI_separate_stencil\n  CONST_CAST(GLEW_ATI_separate_stencil) = glewGetExtension(\"GL_ATI_separate_stencil\");\n  if (glewExperimental || GLEW_ATI_separate_stencil) CONST_CAST(GLEW_ATI_separate_stencil) = !_glewInit_GL_ATI_separate_stencil(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_separate_stencil */\n#ifdef GL_ATI_shader_texture_lod\n  CONST_CAST(GLEW_ATI_shader_texture_lod) = glewGetExtension(\"GL_ATI_shader_texture_lod\");\n#endif /* GL_ATI_shader_texture_lod */\n#ifdef GL_ATI_text_fragment_shader\n  CONST_CAST(GLEW_ATI_text_fragment_shader) = glewGetExtension(\"GL_ATI_text_fragment_shader\");\n#endif /* GL_ATI_text_fragment_shader */\n#ifdef GL_ATI_texture_compression_3dc\n  CONST_CAST(GLEW_ATI_texture_compression_3dc) = glewGetExtension(\"GL_ATI_texture_compression_3dc\");\n#endif /* GL_ATI_texture_compression_3dc */\n#ifdef GL_ATI_texture_env_combine3\n  CONST_CAST(GLEW_ATI_texture_env_combine3) = glewGetExtension(\"GL_ATI_texture_env_combine3\");\n#endif /* GL_ATI_texture_env_combine3 */\n#ifdef GL_ATI_texture_float\n  CONST_CAST(GLEW_ATI_texture_float) = glewGetExtension(\"GL_ATI_texture_float\");\n#endif /* GL_ATI_texture_float */\n#ifdef GL_ATI_texture_mirror_once\n  CONST_CAST(GLEW_ATI_texture_mirror_once) = glewGetExtension(\"GL_ATI_texture_mirror_once\");\n#endif /* GL_ATI_texture_mirror_once */\n#ifdef GL_ATI_vertex_array_object\n  CONST_CAST(GLEW_ATI_vertex_array_object) = glewGetExtension(\"GL_ATI_vertex_array_object\");\n  if (glewExperimental || GLEW_ATI_vertex_array_object) CONST_CAST(GLEW_ATI_vertex_array_object) = !_glewInit_GL_ATI_vertex_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_array_object */\n#ifdef GL_ATI_vertex_attrib_array_object\n  CONST_CAST(GLEW_ATI_vertex_attrib_array_object) = glewGetExtension(\"GL_ATI_vertex_attrib_array_object\");\n  if (glewExperimental || GLEW_ATI_vertex_attrib_array_object) CONST_CAST(GLEW_ATI_vertex_attrib_array_object) = !_glewInit_GL_ATI_vertex_attrib_array_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_attrib_array_object */\n#ifdef GL_ATI_vertex_streams\n  CONST_CAST(GLEW_ATI_vertex_streams) = glewGetExtension(\"GL_ATI_vertex_streams\");\n  if (glewExperimental || GLEW_ATI_vertex_streams) CONST_CAST(GLEW_ATI_vertex_streams) = !_glewInit_GL_ATI_vertex_streams(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_ATI_vertex_streams */\n#ifdef GL_EXT_422_pixels\n  CONST_CAST(GLEW_EXT_422_pixels) = glewGetExtension(\"GL_EXT_422_pixels\");\n#endif /* GL_EXT_422_pixels */\n#ifdef GL_EXT_Cg_shader\n  CONST_CAST(GLEW_EXT_Cg_shader) = glewGetExtension(\"GL_EXT_Cg_shader\");\n#endif /* GL_EXT_Cg_shader */\n#ifdef GL_EXT_abgr\n  CONST_CAST(GLEW_EXT_abgr) = glewGetExtension(\"GL_EXT_abgr\");\n#endif /* GL_EXT_abgr */\n#ifdef GL_EXT_bgra\n  CONST_CAST(GLEW_EXT_bgra) = glewGetExtension(\"GL_EXT_bgra\");\n#endif /* GL_EXT_bgra */\n#ifdef GL_EXT_bindable_uniform\n  CONST_CAST(GLEW_EXT_bindable_uniform) = glewGetExtension(\"GL_EXT_bindable_uniform\");\n  if (glewExperimental || GLEW_EXT_bindable_uniform) CONST_CAST(GLEW_EXT_bindable_uniform) = !_glewInit_GL_EXT_bindable_uniform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_bindable_uniform */\n#ifdef GL_EXT_blend_color\n  CONST_CAST(GLEW_EXT_blend_color) = glewGetExtension(\"GL_EXT_blend_color\");\n  if (glewExperimental || GLEW_EXT_blend_color) CONST_CAST(GLEW_EXT_blend_color) = !_glewInit_GL_EXT_blend_color(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_color */\n#ifdef GL_EXT_blend_equation_separate\n  CONST_CAST(GLEW_EXT_blend_equation_separate) = glewGetExtension(\"GL_EXT_blend_equation_separate\");\n  if (glewExperimental || GLEW_EXT_blend_equation_separate) CONST_CAST(GLEW_EXT_blend_equation_separate) = !_glewInit_GL_EXT_blend_equation_separate(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_equation_separate */\n#ifdef GL_EXT_blend_func_separate\n  CONST_CAST(GLEW_EXT_blend_func_separate) = glewGetExtension(\"GL_EXT_blend_func_separate\");\n  if (glewExperimental || GLEW_EXT_blend_func_separate) CONST_CAST(GLEW_EXT_blend_func_separate) = !_glewInit_GL_EXT_blend_func_separate(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_func_separate */\n#ifdef GL_EXT_blend_logic_op\n  CONST_CAST(GLEW_EXT_blend_logic_op) = glewGetExtension(\"GL_EXT_blend_logic_op\");\n#endif /* GL_EXT_blend_logic_op */\n#ifdef GL_EXT_blend_minmax\n  CONST_CAST(GLEW_EXT_blend_minmax) = glewGetExtension(\"GL_EXT_blend_minmax\");\n  if (glewExperimental || GLEW_EXT_blend_minmax) CONST_CAST(GLEW_EXT_blend_minmax) = !_glewInit_GL_EXT_blend_minmax(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_blend_minmax */\n#ifdef GL_EXT_blend_subtract\n  CONST_CAST(GLEW_EXT_blend_subtract) = glewGetExtension(\"GL_EXT_blend_subtract\");\n#endif /* GL_EXT_blend_subtract */\n#ifdef GL_EXT_clip_volume_hint\n  CONST_CAST(GLEW_EXT_clip_volume_hint) = glewGetExtension(\"GL_EXT_clip_volume_hint\");\n#endif /* GL_EXT_clip_volume_hint */\n#ifdef GL_EXT_cmyka\n  CONST_CAST(GLEW_EXT_cmyka) = glewGetExtension(\"GL_EXT_cmyka\");\n#endif /* GL_EXT_cmyka */\n#ifdef GL_EXT_color_subtable\n  CONST_CAST(GLEW_EXT_color_subtable) = glewGetExtension(\"GL_EXT_color_subtable\");\n  if (glewExperimental || GLEW_EXT_color_subtable) CONST_CAST(GLEW_EXT_color_subtable) = !_glewInit_GL_EXT_color_subtable(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_color_subtable */\n#ifdef GL_EXT_compiled_vertex_array\n  CONST_CAST(GLEW_EXT_compiled_vertex_array) = glewGetExtension(\"GL_EXT_compiled_vertex_array\");\n  if (glewExperimental || GLEW_EXT_compiled_vertex_array) CONST_CAST(GLEW_EXT_compiled_vertex_array) = !_glewInit_GL_EXT_compiled_vertex_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_compiled_vertex_array */\n#ifdef GL_EXT_convolution\n  CONST_CAST(GLEW_EXT_convolution) = glewGetExtension(\"GL_EXT_convolution\");\n  if (glewExperimental || GLEW_EXT_convolution) CONST_CAST(GLEW_EXT_convolution) = !_glewInit_GL_EXT_convolution(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_convolution */\n#ifdef GL_EXT_coordinate_frame\n  CONST_CAST(GLEW_EXT_coordinate_frame) = glewGetExtension(\"GL_EXT_coordinate_frame\");\n  if (glewExperimental || GLEW_EXT_coordinate_frame) CONST_CAST(GLEW_EXT_coordinate_frame) = !_glewInit_GL_EXT_coordinate_frame(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_coordinate_frame */\n#ifdef GL_EXT_copy_texture\n  CONST_CAST(GLEW_EXT_copy_texture) = glewGetExtension(\"GL_EXT_copy_texture\");\n  if (glewExperimental || GLEW_EXT_copy_texture) CONST_CAST(GLEW_EXT_copy_texture) = !_glewInit_GL_EXT_copy_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_copy_texture */\n#ifdef GL_EXT_cull_vertex\n  CONST_CAST(GLEW_EXT_cull_vertex) = glewGetExtension(\"GL_EXT_cull_vertex\");\n  if (glewExperimental || GLEW_EXT_cull_vertex) CONST_CAST(GLEW_EXT_cull_vertex) = !_glewInit_GL_EXT_cull_vertex(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_cull_vertex */\n#ifdef GL_EXT_depth_bounds_test\n  CONST_CAST(GLEW_EXT_depth_bounds_test) = glewGetExtension(\"GL_EXT_depth_bounds_test\");\n  if (glewExperimental || GLEW_EXT_depth_bounds_test) CONST_CAST(GLEW_EXT_depth_bounds_test) = !_glewInit_GL_EXT_depth_bounds_test(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_depth_bounds_test */\n#ifdef GL_EXT_direct_state_access\n  CONST_CAST(GLEW_EXT_direct_state_access) = glewGetExtension(\"GL_EXT_direct_state_access\");\n  if (glewExperimental || GLEW_EXT_direct_state_access) CONST_CAST(GLEW_EXT_direct_state_access) = !_glewInit_GL_EXT_direct_state_access(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_direct_state_access */\n#ifdef GL_EXT_draw_buffers2\n  CONST_CAST(GLEW_EXT_draw_buffers2) = glewGetExtension(\"GL_EXT_draw_buffers2\");\n  if (glewExperimental || GLEW_EXT_draw_buffers2) CONST_CAST(GLEW_EXT_draw_buffers2) = !_glewInit_GL_EXT_draw_buffers2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_buffers2 */\n#ifdef GL_EXT_draw_instanced\n  CONST_CAST(GLEW_EXT_draw_instanced) = glewGetExtension(\"GL_EXT_draw_instanced\");\n  if (glewExperimental || GLEW_EXT_draw_instanced) CONST_CAST(GLEW_EXT_draw_instanced) = !_glewInit_GL_EXT_draw_instanced(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_instanced */\n#ifdef GL_EXT_draw_range_elements\n  CONST_CAST(GLEW_EXT_draw_range_elements) = glewGetExtension(\"GL_EXT_draw_range_elements\");\n  if (glewExperimental || GLEW_EXT_draw_range_elements) CONST_CAST(GLEW_EXT_draw_range_elements) = !_glewInit_GL_EXT_draw_range_elements(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_draw_range_elements */\n#ifdef GL_EXT_fog_coord\n  CONST_CAST(GLEW_EXT_fog_coord) = glewGetExtension(\"GL_EXT_fog_coord\");\n  if (glewExperimental || GLEW_EXT_fog_coord) CONST_CAST(GLEW_EXT_fog_coord) = !_glewInit_GL_EXT_fog_coord(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_fog_coord */\n#ifdef GL_EXT_fragment_lighting\n  CONST_CAST(GLEW_EXT_fragment_lighting) = glewGetExtension(\"GL_EXT_fragment_lighting\");\n  if (glewExperimental || GLEW_EXT_fragment_lighting) CONST_CAST(GLEW_EXT_fragment_lighting) = !_glewInit_GL_EXT_fragment_lighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_fragment_lighting */\n#ifdef GL_EXT_framebuffer_blit\n  CONST_CAST(GLEW_EXT_framebuffer_blit) = glewGetExtension(\"GL_EXT_framebuffer_blit\");\n  if (glewExperimental || GLEW_EXT_framebuffer_blit) CONST_CAST(GLEW_EXT_framebuffer_blit) = !_glewInit_GL_EXT_framebuffer_blit(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_blit */\n#ifdef GL_EXT_framebuffer_multisample\n  CONST_CAST(GLEW_EXT_framebuffer_multisample) = glewGetExtension(\"GL_EXT_framebuffer_multisample\");\n  if (glewExperimental || GLEW_EXT_framebuffer_multisample) CONST_CAST(GLEW_EXT_framebuffer_multisample) = !_glewInit_GL_EXT_framebuffer_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_multisample */\n#ifdef GL_EXT_framebuffer_object\n  CONST_CAST(GLEW_EXT_framebuffer_object) = glewGetExtension(\"GL_EXT_framebuffer_object\");\n  if (glewExperimental || GLEW_EXT_framebuffer_object) CONST_CAST(GLEW_EXT_framebuffer_object) = !_glewInit_GL_EXT_framebuffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_framebuffer_object */\n#ifdef GL_EXT_framebuffer_sRGB\n  CONST_CAST(GLEW_EXT_framebuffer_sRGB) = glewGetExtension(\"GL_EXT_framebuffer_sRGB\");\n#endif /* GL_EXT_framebuffer_sRGB */\n#ifdef GL_EXT_geometry_shader4\n  CONST_CAST(GLEW_EXT_geometry_shader4) = glewGetExtension(\"GL_EXT_geometry_shader4\");\n  if (glewExperimental || GLEW_EXT_geometry_shader4) CONST_CAST(GLEW_EXT_geometry_shader4) = !_glewInit_GL_EXT_geometry_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_geometry_shader4 */\n#ifdef GL_EXT_gpu_program_parameters\n  CONST_CAST(GLEW_EXT_gpu_program_parameters) = glewGetExtension(\"GL_EXT_gpu_program_parameters\");\n  if (glewExperimental || GLEW_EXT_gpu_program_parameters) CONST_CAST(GLEW_EXT_gpu_program_parameters) = !_glewInit_GL_EXT_gpu_program_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_gpu_program_parameters */\n#ifdef GL_EXT_gpu_shader4\n  CONST_CAST(GLEW_EXT_gpu_shader4) = glewGetExtension(\"GL_EXT_gpu_shader4\");\n  if (glewExperimental || GLEW_EXT_gpu_shader4) CONST_CAST(GLEW_EXT_gpu_shader4) = !_glewInit_GL_EXT_gpu_shader4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_gpu_shader4 */\n#ifdef GL_EXT_histogram\n  CONST_CAST(GLEW_EXT_histogram) = glewGetExtension(\"GL_EXT_histogram\");\n  if (glewExperimental || GLEW_EXT_histogram) CONST_CAST(GLEW_EXT_histogram) = !_glewInit_GL_EXT_histogram(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_histogram */\n#ifdef GL_EXT_index_array_formats\n  CONST_CAST(GLEW_EXT_index_array_formats) = glewGetExtension(\"GL_EXT_index_array_formats\");\n#endif /* GL_EXT_index_array_formats */\n#ifdef GL_EXT_index_func\n  CONST_CAST(GLEW_EXT_index_func) = glewGetExtension(\"GL_EXT_index_func\");\n  if (glewExperimental || GLEW_EXT_index_func) CONST_CAST(GLEW_EXT_index_func) = !_glewInit_GL_EXT_index_func(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_index_func */\n#ifdef GL_EXT_index_material\n  CONST_CAST(GLEW_EXT_index_material) = glewGetExtension(\"GL_EXT_index_material\");\n  if (glewExperimental || GLEW_EXT_index_material) CONST_CAST(GLEW_EXT_index_material) = !_glewInit_GL_EXT_index_material(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_index_material */\n#ifdef GL_EXT_index_texture\n  CONST_CAST(GLEW_EXT_index_texture) = glewGetExtension(\"GL_EXT_index_texture\");\n#endif /* GL_EXT_index_texture */\n#ifdef GL_EXT_light_texture\n  CONST_CAST(GLEW_EXT_light_texture) = glewGetExtension(\"GL_EXT_light_texture\");\n  if (glewExperimental || GLEW_EXT_light_texture) CONST_CAST(GLEW_EXT_light_texture) = !_glewInit_GL_EXT_light_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_light_texture */\n#ifdef GL_EXT_misc_attribute\n  CONST_CAST(GLEW_EXT_misc_attribute) = glewGetExtension(\"GL_EXT_misc_attribute\");\n#endif /* GL_EXT_misc_attribute */\n#ifdef GL_EXT_multi_draw_arrays\n  CONST_CAST(GLEW_EXT_multi_draw_arrays) = glewGetExtension(\"GL_EXT_multi_draw_arrays\");\n  if (glewExperimental || GLEW_EXT_multi_draw_arrays) CONST_CAST(GLEW_EXT_multi_draw_arrays) = !_glewInit_GL_EXT_multi_draw_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_multi_draw_arrays */\n#ifdef GL_EXT_multisample\n  CONST_CAST(GLEW_EXT_multisample) = glewGetExtension(\"GL_EXT_multisample\");\n  if (glewExperimental || GLEW_EXT_multisample) CONST_CAST(GLEW_EXT_multisample) = !_glewInit_GL_EXT_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_multisample */\n#ifdef GL_EXT_packed_depth_stencil\n  CONST_CAST(GLEW_EXT_packed_depth_stencil) = glewGetExtension(\"GL_EXT_packed_depth_stencil\");\n#endif /* GL_EXT_packed_depth_stencil */\n#ifdef GL_EXT_packed_float\n  CONST_CAST(GLEW_EXT_packed_float) = glewGetExtension(\"GL_EXT_packed_float\");\n#endif /* GL_EXT_packed_float */\n#ifdef GL_EXT_packed_pixels\n  CONST_CAST(GLEW_EXT_packed_pixels) = glewGetExtension(\"GL_EXT_packed_pixels\");\n#endif /* GL_EXT_packed_pixels */\n#ifdef GL_EXT_paletted_texture\n  CONST_CAST(GLEW_EXT_paletted_texture) = glewGetExtension(\"GL_EXT_paletted_texture\");\n  if (glewExperimental || GLEW_EXT_paletted_texture) CONST_CAST(GLEW_EXT_paletted_texture) = !_glewInit_GL_EXT_paletted_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_paletted_texture */\n#ifdef GL_EXT_pixel_buffer_object\n  CONST_CAST(GLEW_EXT_pixel_buffer_object) = glewGetExtension(\"GL_EXT_pixel_buffer_object\");\n#endif /* GL_EXT_pixel_buffer_object */\n#ifdef GL_EXT_pixel_transform\n  CONST_CAST(GLEW_EXT_pixel_transform) = glewGetExtension(\"GL_EXT_pixel_transform\");\n  if (glewExperimental || GLEW_EXT_pixel_transform) CONST_CAST(GLEW_EXT_pixel_transform) = !_glewInit_GL_EXT_pixel_transform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_pixel_transform */\n#ifdef GL_EXT_pixel_transform_color_table\n  CONST_CAST(GLEW_EXT_pixel_transform_color_table) = glewGetExtension(\"GL_EXT_pixel_transform_color_table\");\n#endif /* GL_EXT_pixel_transform_color_table */\n#ifdef GL_EXT_point_parameters\n  CONST_CAST(GLEW_EXT_point_parameters) = glewGetExtension(\"GL_EXT_point_parameters\");\n  if (glewExperimental || GLEW_EXT_point_parameters) CONST_CAST(GLEW_EXT_point_parameters) = !_glewInit_GL_EXT_point_parameters(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_point_parameters */\n#ifdef GL_EXT_polygon_offset\n  CONST_CAST(GLEW_EXT_polygon_offset) = glewGetExtension(\"GL_EXT_polygon_offset\");\n  if (glewExperimental || GLEW_EXT_polygon_offset) CONST_CAST(GLEW_EXT_polygon_offset) = !_glewInit_GL_EXT_polygon_offset(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_polygon_offset */\n#ifdef GL_EXT_rescale_normal\n  CONST_CAST(GLEW_EXT_rescale_normal) = glewGetExtension(\"GL_EXT_rescale_normal\");\n#endif /* GL_EXT_rescale_normal */\n#ifdef GL_EXT_scene_marker\n  CONST_CAST(GLEW_EXT_scene_marker) = glewGetExtension(\"GL_EXT_scene_marker\");\n  if (glewExperimental || GLEW_EXT_scene_marker) CONST_CAST(GLEW_EXT_scene_marker) = !_glewInit_GL_EXT_scene_marker(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_scene_marker */\n#ifdef GL_EXT_secondary_color\n  CONST_CAST(GLEW_EXT_secondary_color) = glewGetExtension(\"GL_EXT_secondary_color\");\n  if (glewExperimental || GLEW_EXT_secondary_color) CONST_CAST(GLEW_EXT_secondary_color) = !_glewInit_GL_EXT_secondary_color(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_secondary_color */\n#ifdef GL_EXT_separate_specular_color\n  CONST_CAST(GLEW_EXT_separate_specular_color) = glewGetExtension(\"GL_EXT_separate_specular_color\");\n#endif /* GL_EXT_separate_specular_color */\n#ifdef GL_EXT_shadow_funcs\n  CONST_CAST(GLEW_EXT_shadow_funcs) = glewGetExtension(\"GL_EXT_shadow_funcs\");\n#endif /* GL_EXT_shadow_funcs */\n#ifdef GL_EXT_shared_texture_palette\n  CONST_CAST(GLEW_EXT_shared_texture_palette) = glewGetExtension(\"GL_EXT_shared_texture_palette\");\n#endif /* GL_EXT_shared_texture_palette */\n#ifdef GL_EXT_stencil_clear_tag\n  CONST_CAST(GLEW_EXT_stencil_clear_tag) = glewGetExtension(\"GL_EXT_stencil_clear_tag\");\n#endif /* GL_EXT_stencil_clear_tag */\n#ifdef GL_EXT_stencil_two_side\n  CONST_CAST(GLEW_EXT_stencil_two_side) = glewGetExtension(\"GL_EXT_stencil_two_side\");\n  if (glewExperimental || GLEW_EXT_stencil_two_side) CONST_CAST(GLEW_EXT_stencil_two_side) = !_glewInit_GL_EXT_stencil_two_side(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_stencil_two_side */\n#ifdef GL_EXT_stencil_wrap\n  CONST_CAST(GLEW_EXT_stencil_wrap) = glewGetExtension(\"GL_EXT_stencil_wrap\");\n#endif /* GL_EXT_stencil_wrap */\n#ifdef GL_EXT_subtexture\n  CONST_CAST(GLEW_EXT_subtexture) = glewGetExtension(\"GL_EXT_subtexture\");\n  if (glewExperimental || GLEW_EXT_subtexture) CONST_CAST(GLEW_EXT_subtexture) = !_glewInit_GL_EXT_subtexture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_subtexture */\n#ifdef GL_EXT_texture\n  CONST_CAST(GLEW_EXT_texture) = glewGetExtension(\"GL_EXT_texture\");\n#endif /* GL_EXT_texture */\n#ifdef GL_EXT_texture3D\n  CONST_CAST(GLEW_EXT_texture3D) = glewGetExtension(\"GL_EXT_texture3D\");\n  if (glewExperimental || GLEW_EXT_texture3D) CONST_CAST(GLEW_EXT_texture3D) = !_glewInit_GL_EXT_texture3D(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture3D */\n#ifdef GL_EXT_texture_array\n  CONST_CAST(GLEW_EXT_texture_array) = glewGetExtension(\"GL_EXT_texture_array\");\n#endif /* GL_EXT_texture_array */\n#ifdef GL_EXT_texture_buffer_object\n  CONST_CAST(GLEW_EXT_texture_buffer_object) = glewGetExtension(\"GL_EXT_texture_buffer_object\");\n  if (glewExperimental || GLEW_EXT_texture_buffer_object) CONST_CAST(GLEW_EXT_texture_buffer_object) = !_glewInit_GL_EXT_texture_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_buffer_object */\n#ifdef GL_EXT_texture_compression_dxt1\n  CONST_CAST(GLEW_EXT_texture_compression_dxt1) = glewGetExtension(\"GL_EXT_texture_compression_dxt1\");\n#endif /* GL_EXT_texture_compression_dxt1 */\n#ifdef GL_EXT_texture_compression_latc\n  CONST_CAST(GLEW_EXT_texture_compression_latc) = glewGetExtension(\"GL_EXT_texture_compression_latc\");\n#endif /* GL_EXT_texture_compression_latc */\n#ifdef GL_EXT_texture_compression_rgtc\n  CONST_CAST(GLEW_EXT_texture_compression_rgtc) = glewGetExtension(\"GL_EXT_texture_compression_rgtc\");\n#endif /* GL_EXT_texture_compression_rgtc */\n#ifdef GL_EXT_texture_compression_s3tc\n  CONST_CAST(GLEW_EXT_texture_compression_s3tc) = glewGetExtension(\"GL_EXT_texture_compression_s3tc\");\n#endif /* GL_EXT_texture_compression_s3tc */\n#ifdef GL_EXT_texture_cube_map\n  CONST_CAST(GLEW_EXT_texture_cube_map) = glewGetExtension(\"GL_EXT_texture_cube_map\");\n#endif /* GL_EXT_texture_cube_map */\n#ifdef GL_EXT_texture_edge_clamp\n  CONST_CAST(GLEW_EXT_texture_edge_clamp) = glewGetExtension(\"GL_EXT_texture_edge_clamp\");\n#endif /* GL_EXT_texture_edge_clamp */\n#ifdef GL_EXT_texture_env\n  CONST_CAST(GLEW_EXT_texture_env) = glewGetExtension(\"GL_EXT_texture_env\");\n#endif /* GL_EXT_texture_env */\n#ifdef GL_EXT_texture_env_add\n  CONST_CAST(GLEW_EXT_texture_env_add) = glewGetExtension(\"GL_EXT_texture_env_add\");\n#endif /* GL_EXT_texture_env_add */\n#ifdef GL_EXT_texture_env_combine\n  CONST_CAST(GLEW_EXT_texture_env_combine) = glewGetExtension(\"GL_EXT_texture_env_combine\");\n#endif /* GL_EXT_texture_env_combine */\n#ifdef GL_EXT_texture_env_dot3\n  CONST_CAST(GLEW_EXT_texture_env_dot3) = glewGetExtension(\"GL_EXT_texture_env_dot3\");\n#endif /* GL_EXT_texture_env_dot3 */\n#ifdef GL_EXT_texture_filter_anisotropic\n  CONST_CAST(GLEW_EXT_texture_filter_anisotropic) = glewGetExtension(\"GL_EXT_texture_filter_anisotropic\");\n#endif /* GL_EXT_texture_filter_anisotropic */\n#ifdef GL_EXT_texture_integer\n  CONST_CAST(GLEW_EXT_texture_integer) = glewGetExtension(\"GL_EXT_texture_integer\");\n  if (glewExperimental || GLEW_EXT_texture_integer) CONST_CAST(GLEW_EXT_texture_integer) = !_glewInit_GL_EXT_texture_integer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_integer */\n#ifdef GL_EXT_texture_lod_bias\n  CONST_CAST(GLEW_EXT_texture_lod_bias) = glewGetExtension(\"GL_EXT_texture_lod_bias\");\n#endif /* GL_EXT_texture_lod_bias */\n#ifdef GL_EXT_texture_mirror_clamp\n  CONST_CAST(GLEW_EXT_texture_mirror_clamp) = glewGetExtension(\"GL_EXT_texture_mirror_clamp\");\n#endif /* GL_EXT_texture_mirror_clamp */\n#ifdef GL_EXT_texture_object\n  CONST_CAST(GLEW_EXT_texture_object) = glewGetExtension(\"GL_EXT_texture_object\");\n  if (glewExperimental || GLEW_EXT_texture_object) CONST_CAST(GLEW_EXT_texture_object) = !_glewInit_GL_EXT_texture_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_object */\n#ifdef GL_EXT_texture_perturb_normal\n  CONST_CAST(GLEW_EXT_texture_perturb_normal) = glewGetExtension(\"GL_EXT_texture_perturb_normal\");\n  if (glewExperimental || GLEW_EXT_texture_perturb_normal) CONST_CAST(GLEW_EXT_texture_perturb_normal) = !_glewInit_GL_EXT_texture_perturb_normal(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_texture_perturb_normal */\n#ifdef GL_EXT_texture_rectangle\n  CONST_CAST(GLEW_EXT_texture_rectangle) = glewGetExtension(\"GL_EXT_texture_rectangle\");\n#endif /* GL_EXT_texture_rectangle */\n#ifdef GL_EXT_texture_sRGB\n  CONST_CAST(GLEW_EXT_texture_sRGB) = glewGetExtension(\"GL_EXT_texture_sRGB\");\n#endif /* GL_EXT_texture_sRGB */\n#ifdef GL_EXT_texture_shared_exponent\n  CONST_CAST(GLEW_EXT_texture_shared_exponent) = glewGetExtension(\"GL_EXT_texture_shared_exponent\");\n#endif /* GL_EXT_texture_shared_exponent */\n#ifdef GL_EXT_texture_swizzle\n  CONST_CAST(GLEW_EXT_texture_swizzle) = glewGetExtension(\"GL_EXT_texture_swizzle\");\n#endif /* GL_EXT_texture_swizzle */\n#ifdef GL_EXT_timer_query\n  CONST_CAST(GLEW_EXT_timer_query) = glewGetExtension(\"GL_EXT_timer_query\");\n  if (glewExperimental || GLEW_EXT_timer_query) CONST_CAST(GLEW_EXT_timer_query) = !_glewInit_GL_EXT_timer_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_timer_query */\n#ifdef GL_EXT_transform_feedback\n  CONST_CAST(GLEW_EXT_transform_feedback) = glewGetExtension(\"GL_EXT_transform_feedback\");\n  if (glewExperimental || GLEW_EXT_transform_feedback) CONST_CAST(GLEW_EXT_transform_feedback) = !_glewInit_GL_EXT_transform_feedback(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_transform_feedback */\n#ifdef GL_EXT_vertex_array\n  CONST_CAST(GLEW_EXT_vertex_array) = glewGetExtension(\"GL_EXT_vertex_array\");\n  if (glewExperimental || GLEW_EXT_vertex_array) CONST_CAST(GLEW_EXT_vertex_array) = !_glewInit_GL_EXT_vertex_array(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_array */\n#ifdef GL_EXT_vertex_array_bgra\n  CONST_CAST(GLEW_EXT_vertex_array_bgra) = glewGetExtension(\"GL_EXT_vertex_array_bgra\");\n#endif /* GL_EXT_vertex_array_bgra */\n#ifdef GL_EXT_vertex_shader\n  CONST_CAST(GLEW_EXT_vertex_shader) = glewGetExtension(\"GL_EXT_vertex_shader\");\n  if (glewExperimental || GLEW_EXT_vertex_shader) CONST_CAST(GLEW_EXT_vertex_shader) = !_glewInit_GL_EXT_vertex_shader(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_shader */\n#ifdef GL_EXT_vertex_weighting\n  CONST_CAST(GLEW_EXT_vertex_weighting) = glewGetExtension(\"GL_EXT_vertex_weighting\");\n  if (glewExperimental || GLEW_EXT_vertex_weighting) CONST_CAST(GLEW_EXT_vertex_weighting) = !_glewInit_GL_EXT_vertex_weighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_EXT_vertex_weighting */\n#ifdef GL_GREMEDY_frame_terminator\n  CONST_CAST(GLEW_GREMEDY_frame_terminator) = glewGetExtension(\"GL_GREMEDY_frame_terminator\");\n  if (glewExperimental || GLEW_GREMEDY_frame_terminator) CONST_CAST(GLEW_GREMEDY_frame_terminator) = !_glewInit_GL_GREMEDY_frame_terminator(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_GREMEDY_frame_terminator */\n#ifdef GL_GREMEDY_string_marker\n  CONST_CAST(GLEW_GREMEDY_string_marker) = glewGetExtension(\"GL_GREMEDY_string_marker\");\n  if (glewExperimental || GLEW_GREMEDY_string_marker) CONST_CAST(GLEW_GREMEDY_string_marker) = !_glewInit_GL_GREMEDY_string_marker(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_GREMEDY_string_marker */\n#ifdef GL_HP_convolution_border_modes\n  CONST_CAST(GLEW_HP_convolution_border_modes) = glewGetExtension(\"GL_HP_convolution_border_modes\");\n#endif /* GL_HP_convolution_border_modes */\n#ifdef GL_HP_image_transform\n  CONST_CAST(GLEW_HP_image_transform) = glewGetExtension(\"GL_HP_image_transform\");\n  if (glewExperimental || GLEW_HP_image_transform) CONST_CAST(GLEW_HP_image_transform) = !_glewInit_GL_HP_image_transform(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_HP_image_transform */\n#ifdef GL_HP_occlusion_test\n  CONST_CAST(GLEW_HP_occlusion_test) = glewGetExtension(\"GL_HP_occlusion_test\");\n#endif /* GL_HP_occlusion_test */\n#ifdef GL_HP_texture_lighting\n  CONST_CAST(GLEW_HP_texture_lighting) = glewGetExtension(\"GL_HP_texture_lighting\");\n#endif /* GL_HP_texture_lighting */\n#ifdef GL_IBM_cull_vertex\n  CONST_CAST(GLEW_IBM_cull_vertex) = glewGetExtension(\"GL_IBM_cull_vertex\");\n#endif /* GL_IBM_cull_vertex */\n#ifdef GL_IBM_multimode_draw_arrays\n  CONST_CAST(GLEW_IBM_multimode_draw_arrays) = glewGetExtension(\"GL_IBM_multimode_draw_arrays\");\n  if (glewExperimental || GLEW_IBM_multimode_draw_arrays) CONST_CAST(GLEW_IBM_multimode_draw_arrays) = !_glewInit_GL_IBM_multimode_draw_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_IBM_multimode_draw_arrays */\n#ifdef GL_IBM_rasterpos_clip\n  CONST_CAST(GLEW_IBM_rasterpos_clip) = glewGetExtension(\"GL_IBM_rasterpos_clip\");\n#endif /* GL_IBM_rasterpos_clip */\n#ifdef GL_IBM_static_data\n  CONST_CAST(GLEW_IBM_static_data) = glewGetExtension(\"GL_IBM_static_data\");\n#endif /* GL_IBM_static_data */\n#ifdef GL_IBM_texture_mirrored_repeat\n  CONST_CAST(GLEW_IBM_texture_mirrored_repeat) = glewGetExtension(\"GL_IBM_texture_mirrored_repeat\");\n#endif /* GL_IBM_texture_mirrored_repeat */\n#ifdef GL_IBM_vertex_array_lists\n  CONST_CAST(GLEW_IBM_vertex_array_lists) = glewGetExtension(\"GL_IBM_vertex_array_lists\");\n  if (glewExperimental || GLEW_IBM_vertex_array_lists) CONST_CAST(GLEW_IBM_vertex_array_lists) = !_glewInit_GL_IBM_vertex_array_lists(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_IBM_vertex_array_lists */\n#ifdef GL_INGR_color_clamp\n  CONST_CAST(GLEW_INGR_color_clamp) = glewGetExtension(\"GL_INGR_color_clamp\");\n#endif /* GL_INGR_color_clamp */\n#ifdef GL_INGR_interlace_read\n  CONST_CAST(GLEW_INGR_interlace_read) = glewGetExtension(\"GL_INGR_interlace_read\");\n#endif /* GL_INGR_interlace_read */\n#ifdef GL_INTEL_parallel_arrays\n  CONST_CAST(GLEW_INTEL_parallel_arrays) = glewGetExtension(\"GL_INTEL_parallel_arrays\");\n  if (glewExperimental || GLEW_INTEL_parallel_arrays) CONST_CAST(GLEW_INTEL_parallel_arrays) = !_glewInit_GL_INTEL_parallel_arrays(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_INTEL_parallel_arrays */\n#ifdef GL_INTEL_texture_scissor\n  CONST_CAST(GLEW_INTEL_texture_scissor) = glewGetExtension(\"GL_INTEL_texture_scissor\");\n  if (glewExperimental || GLEW_INTEL_texture_scissor) CONST_CAST(GLEW_INTEL_texture_scissor) = !_glewInit_GL_INTEL_texture_scissor(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_INTEL_texture_scissor */\n#ifdef GL_KTX_buffer_region\n  CONST_CAST(GLEW_KTX_buffer_region) = glewGetExtension(\"GL_KTX_buffer_region\");\n  if (glewExperimental || GLEW_KTX_buffer_region) CONST_CAST(GLEW_KTX_buffer_region) = !_glewInit_GL_KTX_buffer_region(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_KTX_buffer_region */\n#ifdef GL_MESAX_texture_stack\n  CONST_CAST(GLEW_MESAX_texture_stack) = glewGetExtension(\"GL_MESAX_texture_stack\");\n#endif /* GL_MESAX_texture_stack */\n#ifdef GL_MESA_pack_invert\n  CONST_CAST(GLEW_MESA_pack_invert) = glewGetExtension(\"GL_MESA_pack_invert\");\n#endif /* GL_MESA_pack_invert */\n#ifdef GL_MESA_resize_buffers\n  CONST_CAST(GLEW_MESA_resize_buffers) = glewGetExtension(\"GL_MESA_resize_buffers\");\n  if (glewExperimental || GLEW_MESA_resize_buffers) CONST_CAST(GLEW_MESA_resize_buffers) = !_glewInit_GL_MESA_resize_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_MESA_resize_buffers */\n#ifdef GL_MESA_window_pos\n  CONST_CAST(GLEW_MESA_window_pos) = glewGetExtension(\"GL_MESA_window_pos\");\n  if (glewExperimental || GLEW_MESA_window_pos) CONST_CAST(GLEW_MESA_window_pos) = !_glewInit_GL_MESA_window_pos(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_MESA_window_pos */\n#ifdef GL_MESA_ycbcr_texture\n  CONST_CAST(GLEW_MESA_ycbcr_texture) = glewGetExtension(\"GL_MESA_ycbcr_texture\");\n#endif /* GL_MESA_ycbcr_texture */\n#ifdef GL_NV_blend_square\n  CONST_CAST(GLEW_NV_blend_square) = glewGetExtension(\"GL_NV_blend_square\");\n#endif /* GL_NV_blend_square */\n#ifdef GL_NV_conditional_render\n  CONST_CAST(GLEW_NV_conditional_render) = glewGetExtension(\"GL_NV_conditional_render\");\n  if (glewExperimental || GLEW_NV_conditional_render) CONST_CAST(GLEW_NV_conditional_render) = !_glewInit_GL_NV_conditional_render(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_conditional_render */\n#ifdef GL_NV_copy_depth_to_color\n  CONST_CAST(GLEW_NV_copy_depth_to_color) = glewGetExtension(\"GL_NV_copy_depth_to_color\");\n#endif /* GL_NV_copy_depth_to_color */\n#ifdef GL_NV_depth_buffer_float\n  CONST_CAST(GLEW_NV_depth_buffer_float) = glewGetExtension(\"GL_NV_depth_buffer_float\");\n  if (glewExperimental || GLEW_NV_depth_buffer_float) CONST_CAST(GLEW_NV_depth_buffer_float) = !_glewInit_GL_NV_depth_buffer_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_depth_buffer_float */\n#ifdef GL_NV_depth_clamp\n  CONST_CAST(GLEW_NV_depth_clamp) = glewGetExtension(\"GL_NV_depth_clamp\");\n#endif /* GL_NV_depth_clamp */\n#ifdef GL_NV_depth_range_unclamped\n  CONST_CAST(GLEW_NV_depth_range_unclamped) = glewGetExtension(\"GL_NV_depth_range_unclamped\");\n#endif /* GL_NV_depth_range_unclamped */\n#ifdef GL_NV_evaluators\n  CONST_CAST(GLEW_NV_evaluators) = glewGetExtension(\"GL_NV_evaluators\");\n  if (glewExperimental || GLEW_NV_evaluators) CONST_CAST(GLEW_NV_evaluators) = !_glewInit_GL_NV_evaluators(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_evaluators */\n#ifdef GL_NV_explicit_multisample\n  CONST_CAST(GLEW_NV_explicit_multisample) = glewGetExtension(\"GL_NV_explicit_multisample\");\n  if (glewExperimental || GLEW_NV_explicit_multisample) CONST_CAST(GLEW_NV_explicit_multisample) = !_glewInit_GL_NV_explicit_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_explicit_multisample */\n#ifdef GL_NV_fence\n  CONST_CAST(GLEW_NV_fence) = glewGetExtension(\"GL_NV_fence\");\n  if (glewExperimental || GLEW_NV_fence) CONST_CAST(GLEW_NV_fence) = !_glewInit_GL_NV_fence(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_fence */\n#ifdef GL_NV_float_buffer\n  CONST_CAST(GLEW_NV_float_buffer) = glewGetExtension(\"GL_NV_float_buffer\");\n#endif /* GL_NV_float_buffer */\n#ifdef GL_NV_fog_distance\n  CONST_CAST(GLEW_NV_fog_distance) = glewGetExtension(\"GL_NV_fog_distance\");\n#endif /* GL_NV_fog_distance */\n#ifdef GL_NV_fragment_program\n  CONST_CAST(GLEW_NV_fragment_program) = glewGetExtension(\"GL_NV_fragment_program\");\n  if (glewExperimental || GLEW_NV_fragment_program) CONST_CAST(GLEW_NV_fragment_program) = !_glewInit_GL_NV_fragment_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_fragment_program */\n#ifdef GL_NV_fragment_program2\n  CONST_CAST(GLEW_NV_fragment_program2) = glewGetExtension(\"GL_NV_fragment_program2\");\n#endif /* GL_NV_fragment_program2 */\n#ifdef GL_NV_fragment_program4\n  CONST_CAST(GLEW_NV_fragment_program4) = glewGetExtension(\"GL_NV_fragment_program4\");\n#endif /* GL_NV_fragment_program4 */\n#ifdef GL_NV_fragment_program_option\n  CONST_CAST(GLEW_NV_fragment_program_option) = glewGetExtension(\"GL_NV_fragment_program_option\");\n#endif /* GL_NV_fragment_program_option */\n#ifdef GL_NV_framebuffer_multisample_coverage\n  CONST_CAST(GLEW_NV_framebuffer_multisample_coverage) = glewGetExtension(\"GL_NV_framebuffer_multisample_coverage\");\n  if (glewExperimental || GLEW_NV_framebuffer_multisample_coverage) CONST_CAST(GLEW_NV_framebuffer_multisample_coverage) = !_glewInit_GL_NV_framebuffer_multisample_coverage(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_framebuffer_multisample_coverage */\n#ifdef GL_NV_geometry_program4\n  CONST_CAST(GLEW_NV_geometry_program4) = glewGetExtension(\"GL_NV_geometry_program4\");\n  if (glewExperimental || GLEW_NV_geometry_program4) CONST_CAST(GLEW_NV_geometry_program4) = !_glewInit_GL_NV_geometry_program4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_geometry_program4 */\n#ifdef GL_NV_geometry_shader4\n  CONST_CAST(GLEW_NV_geometry_shader4) = glewGetExtension(\"GL_NV_geometry_shader4\");\n#endif /* GL_NV_geometry_shader4 */\n#ifdef GL_NV_gpu_program4\n  CONST_CAST(GLEW_NV_gpu_program4) = glewGetExtension(\"GL_NV_gpu_program4\");\n  if (glewExperimental || GLEW_NV_gpu_program4) CONST_CAST(GLEW_NV_gpu_program4) = !_glewInit_GL_NV_gpu_program4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_gpu_program4 */\n#ifdef GL_NV_half_float\n  CONST_CAST(GLEW_NV_half_float) = glewGetExtension(\"GL_NV_half_float\");\n  if (glewExperimental || GLEW_NV_half_float) CONST_CAST(GLEW_NV_half_float) = !_glewInit_GL_NV_half_float(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_half_float */\n#ifdef GL_NV_light_max_exponent\n  CONST_CAST(GLEW_NV_light_max_exponent) = glewGetExtension(\"GL_NV_light_max_exponent\");\n#endif /* GL_NV_light_max_exponent */\n#ifdef GL_NV_multisample_filter_hint\n  CONST_CAST(GLEW_NV_multisample_filter_hint) = glewGetExtension(\"GL_NV_multisample_filter_hint\");\n#endif /* GL_NV_multisample_filter_hint */\n#ifdef GL_NV_occlusion_query\n  CONST_CAST(GLEW_NV_occlusion_query) = glewGetExtension(\"GL_NV_occlusion_query\");\n  if (glewExperimental || GLEW_NV_occlusion_query) CONST_CAST(GLEW_NV_occlusion_query) = !_glewInit_GL_NV_occlusion_query(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_occlusion_query */\n#ifdef GL_NV_packed_depth_stencil\n  CONST_CAST(GLEW_NV_packed_depth_stencil) = glewGetExtension(\"GL_NV_packed_depth_stencil\");\n#endif /* GL_NV_packed_depth_stencil */\n#ifdef GL_NV_parameter_buffer_object\n  CONST_CAST(GLEW_NV_parameter_buffer_object) = glewGetExtension(\"GL_NV_parameter_buffer_object\");\n  if (glewExperimental || GLEW_NV_parameter_buffer_object) CONST_CAST(GLEW_NV_parameter_buffer_object) = !_glewInit_GL_NV_parameter_buffer_object(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_parameter_buffer_object */\n#ifdef GL_NV_pixel_data_range\n  CONST_CAST(GLEW_NV_pixel_data_range) = glewGetExtension(\"GL_NV_pixel_data_range\");\n  if (glewExperimental || GLEW_NV_pixel_data_range) CONST_CAST(GLEW_NV_pixel_data_range) = !_glewInit_GL_NV_pixel_data_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_pixel_data_range */\n#ifdef GL_NV_point_sprite\n  CONST_CAST(GLEW_NV_point_sprite) = glewGetExtension(\"GL_NV_point_sprite\");\n  if (glewExperimental || GLEW_NV_point_sprite) CONST_CAST(GLEW_NV_point_sprite) = !_glewInit_GL_NV_point_sprite(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_point_sprite */\n#ifdef GL_NV_present_video\n  CONST_CAST(GLEW_NV_present_video) = glewGetExtension(\"GL_NV_present_video\");\n  if (glewExperimental || GLEW_NV_present_video) CONST_CAST(GLEW_NV_present_video) = !_glewInit_GL_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_present_video */\n#ifdef GL_NV_primitive_restart\n  CONST_CAST(GLEW_NV_primitive_restart) = glewGetExtension(\"GL_NV_primitive_restart\");\n  if (glewExperimental || GLEW_NV_primitive_restart) CONST_CAST(GLEW_NV_primitive_restart) = !_glewInit_GL_NV_primitive_restart(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_primitive_restart */\n#ifdef GL_NV_register_combiners\n  CONST_CAST(GLEW_NV_register_combiners) = glewGetExtension(\"GL_NV_register_combiners\");\n  if (glewExperimental || GLEW_NV_register_combiners) CONST_CAST(GLEW_NV_register_combiners) = !_glewInit_GL_NV_register_combiners(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_register_combiners */\n#ifdef GL_NV_register_combiners2\n  CONST_CAST(GLEW_NV_register_combiners2) = glewGetExtension(\"GL_NV_register_combiners2\");\n  if (glewExperimental || GLEW_NV_register_combiners2) CONST_CAST(GLEW_NV_register_combiners2) = !_glewInit_GL_NV_register_combiners2(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_register_combiners2 */\n#ifdef GL_NV_texgen_emboss\n  CONST_CAST(GLEW_NV_texgen_emboss) = glewGetExtension(\"GL_NV_texgen_emboss\");\n#endif /* GL_NV_texgen_emboss */\n#ifdef GL_NV_texgen_reflection\n  CONST_CAST(GLEW_NV_texgen_reflection) = glewGetExtension(\"GL_NV_texgen_reflection\");\n#endif /* GL_NV_texgen_reflection */\n#ifdef GL_NV_texture_compression_vtc\n  CONST_CAST(GLEW_NV_texture_compression_vtc) = glewGetExtension(\"GL_NV_texture_compression_vtc\");\n#endif /* GL_NV_texture_compression_vtc */\n#ifdef GL_NV_texture_env_combine4\n  CONST_CAST(GLEW_NV_texture_env_combine4) = glewGetExtension(\"GL_NV_texture_env_combine4\");\n#endif /* GL_NV_texture_env_combine4 */\n#ifdef GL_NV_texture_expand_normal\n  CONST_CAST(GLEW_NV_texture_expand_normal) = glewGetExtension(\"GL_NV_texture_expand_normal\");\n#endif /* GL_NV_texture_expand_normal */\n#ifdef GL_NV_texture_rectangle\n  CONST_CAST(GLEW_NV_texture_rectangle) = glewGetExtension(\"GL_NV_texture_rectangle\");\n#endif /* GL_NV_texture_rectangle */\n#ifdef GL_NV_texture_shader\n  CONST_CAST(GLEW_NV_texture_shader) = glewGetExtension(\"GL_NV_texture_shader\");\n#endif /* GL_NV_texture_shader */\n#ifdef GL_NV_texture_shader2\n  CONST_CAST(GLEW_NV_texture_shader2) = glewGetExtension(\"GL_NV_texture_shader2\");\n#endif /* GL_NV_texture_shader2 */\n#ifdef GL_NV_texture_shader3\n  CONST_CAST(GLEW_NV_texture_shader3) = glewGetExtension(\"GL_NV_texture_shader3\");\n#endif /* GL_NV_texture_shader3 */\n#ifdef GL_NV_transform_feedback\n  CONST_CAST(GLEW_NV_transform_feedback) = glewGetExtension(\"GL_NV_transform_feedback\");\n  if (glewExperimental || GLEW_NV_transform_feedback) CONST_CAST(GLEW_NV_transform_feedback) = !_glewInit_GL_NV_transform_feedback(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_transform_feedback */\n#ifdef GL_NV_vertex_array_range\n  CONST_CAST(GLEW_NV_vertex_array_range) = glewGetExtension(\"GL_NV_vertex_array_range\");\n  if (glewExperimental || GLEW_NV_vertex_array_range) CONST_CAST(GLEW_NV_vertex_array_range) = !_glewInit_GL_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_vertex_array_range */\n#ifdef GL_NV_vertex_array_range2\n  CONST_CAST(GLEW_NV_vertex_array_range2) = glewGetExtension(\"GL_NV_vertex_array_range2\");\n#endif /* GL_NV_vertex_array_range2 */\n#ifdef GL_NV_vertex_program\n  CONST_CAST(GLEW_NV_vertex_program) = glewGetExtension(\"GL_NV_vertex_program\");\n  if (glewExperimental || GLEW_NV_vertex_program) CONST_CAST(GLEW_NV_vertex_program) = !_glewInit_GL_NV_vertex_program(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_NV_vertex_program */\n#ifdef GL_NV_vertex_program1_1\n  CONST_CAST(GLEW_NV_vertex_program1_1) = glewGetExtension(\"GL_NV_vertex_program1_1\");\n#endif /* GL_NV_vertex_program1_1 */\n#ifdef GL_NV_vertex_program2\n  CONST_CAST(GLEW_NV_vertex_program2) = glewGetExtension(\"GL_NV_vertex_program2\");\n#endif /* GL_NV_vertex_program2 */\n#ifdef GL_NV_vertex_program2_option\n  CONST_CAST(GLEW_NV_vertex_program2_option) = glewGetExtension(\"GL_NV_vertex_program2_option\");\n#endif /* GL_NV_vertex_program2_option */\n#ifdef GL_NV_vertex_program3\n  CONST_CAST(GLEW_NV_vertex_program3) = glewGetExtension(\"GL_NV_vertex_program3\");\n#endif /* GL_NV_vertex_program3 */\n#ifdef GL_NV_vertex_program4\n  CONST_CAST(GLEW_NV_vertex_program4) = glewGetExtension(\"GL_NV_vertex_program4\");\n#endif /* GL_NV_vertex_program4 */\n#ifdef GL_OES_byte_coordinates\n  CONST_CAST(GLEW_OES_byte_coordinates) = glewGetExtension(\"GL_OES_byte_coordinates\");\n#endif /* GL_OES_byte_coordinates */\n#ifdef GL_OES_compressed_paletted_texture\n  CONST_CAST(GLEW_OES_compressed_paletted_texture) = glewGetExtension(\"GL_OES_compressed_paletted_texture\");\n#endif /* GL_OES_compressed_paletted_texture */\n#ifdef GL_OES_read_format\n  CONST_CAST(GLEW_OES_read_format) = glewGetExtension(\"GL_OES_read_format\");\n#endif /* GL_OES_read_format */\n#ifdef GL_OES_single_precision\n  CONST_CAST(GLEW_OES_single_precision) = glewGetExtension(\"GL_OES_single_precision\");\n  if (glewExperimental || GLEW_OES_single_precision) CONST_CAST(GLEW_OES_single_precision) = !_glewInit_GL_OES_single_precision(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_OES_single_precision */\n#ifdef GL_OML_interlace\n  CONST_CAST(GLEW_OML_interlace) = glewGetExtension(\"GL_OML_interlace\");\n#endif /* GL_OML_interlace */\n#ifdef GL_OML_resample\n  CONST_CAST(GLEW_OML_resample) = glewGetExtension(\"GL_OML_resample\");\n#endif /* GL_OML_resample */\n#ifdef GL_OML_subsample\n  CONST_CAST(GLEW_OML_subsample) = glewGetExtension(\"GL_OML_subsample\");\n#endif /* GL_OML_subsample */\n#ifdef GL_PGI_misc_hints\n  CONST_CAST(GLEW_PGI_misc_hints) = glewGetExtension(\"GL_PGI_misc_hints\");\n#endif /* GL_PGI_misc_hints */\n#ifdef GL_PGI_vertex_hints\n  CONST_CAST(GLEW_PGI_vertex_hints) = glewGetExtension(\"GL_PGI_vertex_hints\");\n#endif /* GL_PGI_vertex_hints */\n#ifdef GL_REND_screen_coordinates\n  CONST_CAST(GLEW_REND_screen_coordinates) = glewGetExtension(\"GL_REND_screen_coordinates\");\n#endif /* GL_REND_screen_coordinates */\n#ifdef GL_S3_s3tc\n  CONST_CAST(GLEW_S3_s3tc) = glewGetExtension(\"GL_S3_s3tc\");\n#endif /* GL_S3_s3tc */\n#ifdef GL_SGIS_color_range\n  CONST_CAST(GLEW_SGIS_color_range) = glewGetExtension(\"GL_SGIS_color_range\");\n#endif /* GL_SGIS_color_range */\n#ifdef GL_SGIS_detail_texture\n  CONST_CAST(GLEW_SGIS_detail_texture) = glewGetExtension(\"GL_SGIS_detail_texture\");\n  if (glewExperimental || GLEW_SGIS_detail_texture) CONST_CAST(GLEW_SGIS_detail_texture) = !_glewInit_GL_SGIS_detail_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_detail_texture */\n#ifdef GL_SGIS_fog_function\n  CONST_CAST(GLEW_SGIS_fog_function) = glewGetExtension(\"GL_SGIS_fog_function\");\n  if (glewExperimental || GLEW_SGIS_fog_function) CONST_CAST(GLEW_SGIS_fog_function) = !_glewInit_GL_SGIS_fog_function(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_fog_function */\n#ifdef GL_SGIS_generate_mipmap\n  CONST_CAST(GLEW_SGIS_generate_mipmap) = glewGetExtension(\"GL_SGIS_generate_mipmap\");\n#endif /* GL_SGIS_generate_mipmap */\n#ifdef GL_SGIS_multisample\n  CONST_CAST(GLEW_SGIS_multisample) = glewGetExtension(\"GL_SGIS_multisample\");\n  if (glewExperimental || GLEW_SGIS_multisample) CONST_CAST(GLEW_SGIS_multisample) = !_glewInit_GL_SGIS_multisample(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_multisample */\n#ifdef GL_SGIS_pixel_texture\n  CONST_CAST(GLEW_SGIS_pixel_texture) = glewGetExtension(\"GL_SGIS_pixel_texture\");\n#endif /* GL_SGIS_pixel_texture */\n#ifdef GL_SGIS_point_line_texgen\n  CONST_CAST(GLEW_SGIS_point_line_texgen) = glewGetExtension(\"GL_SGIS_point_line_texgen\");\n#endif /* GL_SGIS_point_line_texgen */\n#ifdef GL_SGIS_sharpen_texture\n  CONST_CAST(GLEW_SGIS_sharpen_texture) = glewGetExtension(\"GL_SGIS_sharpen_texture\");\n  if (glewExperimental || GLEW_SGIS_sharpen_texture) CONST_CAST(GLEW_SGIS_sharpen_texture) = !_glewInit_GL_SGIS_sharpen_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_sharpen_texture */\n#ifdef GL_SGIS_texture4D\n  CONST_CAST(GLEW_SGIS_texture4D) = glewGetExtension(\"GL_SGIS_texture4D\");\n  if (glewExperimental || GLEW_SGIS_texture4D) CONST_CAST(GLEW_SGIS_texture4D) = !_glewInit_GL_SGIS_texture4D(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_texture4D */\n#ifdef GL_SGIS_texture_border_clamp\n  CONST_CAST(GLEW_SGIS_texture_border_clamp) = glewGetExtension(\"GL_SGIS_texture_border_clamp\");\n#endif /* GL_SGIS_texture_border_clamp */\n#ifdef GL_SGIS_texture_edge_clamp\n  CONST_CAST(GLEW_SGIS_texture_edge_clamp) = glewGetExtension(\"GL_SGIS_texture_edge_clamp\");\n#endif /* GL_SGIS_texture_edge_clamp */\n#ifdef GL_SGIS_texture_filter4\n  CONST_CAST(GLEW_SGIS_texture_filter4) = glewGetExtension(\"GL_SGIS_texture_filter4\");\n  if (glewExperimental || GLEW_SGIS_texture_filter4) CONST_CAST(GLEW_SGIS_texture_filter4) = !_glewInit_GL_SGIS_texture_filter4(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIS_texture_filter4 */\n#ifdef GL_SGIS_texture_lod\n  CONST_CAST(GLEW_SGIS_texture_lod) = glewGetExtension(\"GL_SGIS_texture_lod\");\n#endif /* GL_SGIS_texture_lod */\n#ifdef GL_SGIS_texture_select\n  CONST_CAST(GLEW_SGIS_texture_select) = glewGetExtension(\"GL_SGIS_texture_select\");\n#endif /* GL_SGIS_texture_select */\n#ifdef GL_SGIX_async\n  CONST_CAST(GLEW_SGIX_async) = glewGetExtension(\"GL_SGIX_async\");\n  if (glewExperimental || GLEW_SGIX_async) CONST_CAST(GLEW_SGIX_async) = !_glewInit_GL_SGIX_async(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_async */\n#ifdef GL_SGIX_async_histogram\n  CONST_CAST(GLEW_SGIX_async_histogram) = glewGetExtension(\"GL_SGIX_async_histogram\");\n#endif /* GL_SGIX_async_histogram */\n#ifdef GL_SGIX_async_pixel\n  CONST_CAST(GLEW_SGIX_async_pixel) = glewGetExtension(\"GL_SGIX_async_pixel\");\n#endif /* GL_SGIX_async_pixel */\n#ifdef GL_SGIX_blend_alpha_minmax\n  CONST_CAST(GLEW_SGIX_blend_alpha_minmax) = glewGetExtension(\"GL_SGIX_blend_alpha_minmax\");\n#endif /* GL_SGIX_blend_alpha_minmax */\n#ifdef GL_SGIX_clipmap\n  CONST_CAST(GLEW_SGIX_clipmap) = glewGetExtension(\"GL_SGIX_clipmap\");\n#endif /* GL_SGIX_clipmap */\n#ifdef GL_SGIX_convolution_accuracy\n  CONST_CAST(GLEW_SGIX_convolution_accuracy) = glewGetExtension(\"GL_SGIX_convolution_accuracy\");\n#endif /* GL_SGIX_convolution_accuracy */\n#ifdef GL_SGIX_depth_texture\n  CONST_CAST(GLEW_SGIX_depth_texture) = glewGetExtension(\"GL_SGIX_depth_texture\");\n#endif /* GL_SGIX_depth_texture */\n#ifdef GL_SGIX_flush_raster\n  CONST_CAST(GLEW_SGIX_flush_raster) = glewGetExtension(\"GL_SGIX_flush_raster\");\n  if (glewExperimental || GLEW_SGIX_flush_raster) CONST_CAST(GLEW_SGIX_flush_raster) = !_glewInit_GL_SGIX_flush_raster(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_flush_raster */\n#ifdef GL_SGIX_fog_offset\n  CONST_CAST(GLEW_SGIX_fog_offset) = glewGetExtension(\"GL_SGIX_fog_offset\");\n#endif /* GL_SGIX_fog_offset */\n#ifdef GL_SGIX_fog_texture\n  CONST_CAST(GLEW_SGIX_fog_texture) = glewGetExtension(\"GL_SGIX_fog_texture\");\n  if (glewExperimental || GLEW_SGIX_fog_texture) CONST_CAST(GLEW_SGIX_fog_texture) = !_glewInit_GL_SGIX_fog_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_fog_texture */\n#ifdef GL_SGIX_fragment_specular_lighting\n  CONST_CAST(GLEW_SGIX_fragment_specular_lighting) = glewGetExtension(\"GL_SGIX_fragment_specular_lighting\");\n  if (glewExperimental || GLEW_SGIX_fragment_specular_lighting) CONST_CAST(GLEW_SGIX_fragment_specular_lighting) = !_glewInit_GL_SGIX_fragment_specular_lighting(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_fragment_specular_lighting */\n#ifdef GL_SGIX_framezoom\n  CONST_CAST(GLEW_SGIX_framezoom) = glewGetExtension(\"GL_SGIX_framezoom\");\n  if (glewExperimental || GLEW_SGIX_framezoom) CONST_CAST(GLEW_SGIX_framezoom) = !_glewInit_GL_SGIX_framezoom(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_framezoom */\n#ifdef GL_SGIX_interlace\n  CONST_CAST(GLEW_SGIX_interlace) = glewGetExtension(\"GL_SGIX_interlace\");\n#endif /* GL_SGIX_interlace */\n#ifdef GL_SGIX_ir_instrument1\n  CONST_CAST(GLEW_SGIX_ir_instrument1) = glewGetExtension(\"GL_SGIX_ir_instrument1\");\n#endif /* GL_SGIX_ir_instrument1 */\n#ifdef GL_SGIX_list_priority\n  CONST_CAST(GLEW_SGIX_list_priority) = glewGetExtension(\"GL_SGIX_list_priority\");\n#endif /* GL_SGIX_list_priority */\n#ifdef GL_SGIX_pixel_texture\n  CONST_CAST(GLEW_SGIX_pixel_texture) = glewGetExtension(\"GL_SGIX_pixel_texture\");\n  if (glewExperimental || GLEW_SGIX_pixel_texture) CONST_CAST(GLEW_SGIX_pixel_texture) = !_glewInit_GL_SGIX_pixel_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_pixel_texture */\n#ifdef GL_SGIX_pixel_texture_bits\n  CONST_CAST(GLEW_SGIX_pixel_texture_bits) = glewGetExtension(\"GL_SGIX_pixel_texture_bits\");\n#endif /* GL_SGIX_pixel_texture_bits */\n#ifdef GL_SGIX_reference_plane\n  CONST_CAST(GLEW_SGIX_reference_plane) = glewGetExtension(\"GL_SGIX_reference_plane\");\n  if (glewExperimental || GLEW_SGIX_reference_plane) CONST_CAST(GLEW_SGIX_reference_plane) = !_glewInit_GL_SGIX_reference_plane(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_reference_plane */\n#ifdef GL_SGIX_resample\n  CONST_CAST(GLEW_SGIX_resample) = glewGetExtension(\"GL_SGIX_resample\");\n#endif /* GL_SGIX_resample */\n#ifdef GL_SGIX_shadow\n  CONST_CAST(GLEW_SGIX_shadow) = glewGetExtension(\"GL_SGIX_shadow\");\n#endif /* GL_SGIX_shadow */\n#ifdef GL_SGIX_shadow_ambient\n  CONST_CAST(GLEW_SGIX_shadow_ambient) = glewGetExtension(\"GL_SGIX_shadow_ambient\");\n#endif /* GL_SGIX_shadow_ambient */\n#ifdef GL_SGIX_sprite\n  CONST_CAST(GLEW_SGIX_sprite) = glewGetExtension(\"GL_SGIX_sprite\");\n  if (glewExperimental || GLEW_SGIX_sprite) CONST_CAST(GLEW_SGIX_sprite) = !_glewInit_GL_SGIX_sprite(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_sprite */\n#ifdef GL_SGIX_tag_sample_buffer\n  CONST_CAST(GLEW_SGIX_tag_sample_buffer) = glewGetExtension(\"GL_SGIX_tag_sample_buffer\");\n  if (glewExperimental || GLEW_SGIX_tag_sample_buffer) CONST_CAST(GLEW_SGIX_tag_sample_buffer) = !_glewInit_GL_SGIX_tag_sample_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGIX_tag_sample_buffer */\n#ifdef GL_SGIX_texture_add_env\n  CONST_CAST(GLEW_SGIX_texture_add_env) = glewGetExtension(\"GL_SGIX_texture_add_env\");\n#endif /* GL_SGIX_texture_add_env */\n#ifdef GL_SGIX_texture_coordinate_clamp\n  CONST_CAST(GLEW_SGIX_texture_coordinate_clamp) = glewGetExtension(\"GL_SGIX_texture_coordinate_clamp\");\n#endif /* GL_SGIX_texture_coordinate_clamp */\n#ifdef GL_SGIX_texture_lod_bias\n  CONST_CAST(GLEW_SGIX_texture_lod_bias) = glewGetExtension(\"GL_SGIX_texture_lod_bias\");\n#endif /* GL_SGIX_texture_lod_bias */\n#ifdef GL_SGIX_texture_multi_buffer\n  CONST_CAST(GLEW_SGIX_texture_multi_buffer) = glewGetExtension(\"GL_SGIX_texture_multi_buffer\");\n#endif /* GL_SGIX_texture_multi_buffer */\n#ifdef GL_SGIX_texture_range\n  CONST_CAST(GLEW_SGIX_texture_range) = glewGetExtension(\"GL_SGIX_texture_range\");\n#endif /* GL_SGIX_texture_range */\n#ifdef GL_SGIX_texture_scale_bias\n  CONST_CAST(GLEW_SGIX_texture_scale_bias) = glewGetExtension(\"GL_SGIX_texture_scale_bias\");\n#endif /* GL_SGIX_texture_scale_bias */\n#ifdef GL_SGIX_vertex_preclip\n  CONST_CAST(GLEW_SGIX_vertex_preclip) = glewGetExtension(\"GL_SGIX_vertex_preclip\");\n#endif /* GL_SGIX_vertex_preclip */\n#ifdef GL_SGIX_vertex_preclip_hint\n  CONST_CAST(GLEW_SGIX_vertex_preclip_hint) = glewGetExtension(\"GL_SGIX_vertex_preclip_hint\");\n#endif /* GL_SGIX_vertex_preclip_hint */\n#ifdef GL_SGIX_ycrcb\n  CONST_CAST(GLEW_SGIX_ycrcb) = glewGetExtension(\"GL_SGIX_ycrcb\");\n#endif /* GL_SGIX_ycrcb */\n#ifdef GL_SGI_color_matrix\n  CONST_CAST(GLEW_SGI_color_matrix) = glewGetExtension(\"GL_SGI_color_matrix\");\n#endif /* GL_SGI_color_matrix */\n#ifdef GL_SGI_color_table\n  CONST_CAST(GLEW_SGI_color_table) = glewGetExtension(\"GL_SGI_color_table\");\n  if (glewExperimental || GLEW_SGI_color_table) CONST_CAST(GLEW_SGI_color_table) = !_glewInit_GL_SGI_color_table(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SGI_color_table */\n#ifdef GL_SGI_texture_color_table\n  CONST_CAST(GLEW_SGI_texture_color_table) = glewGetExtension(\"GL_SGI_texture_color_table\");\n#endif /* GL_SGI_texture_color_table */\n#ifdef GL_SUNX_constant_data\n  CONST_CAST(GLEW_SUNX_constant_data) = glewGetExtension(\"GL_SUNX_constant_data\");\n  if (glewExperimental || GLEW_SUNX_constant_data) CONST_CAST(GLEW_SUNX_constant_data) = !_glewInit_GL_SUNX_constant_data(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUNX_constant_data */\n#ifdef GL_SUN_convolution_border_modes\n  CONST_CAST(GLEW_SUN_convolution_border_modes) = glewGetExtension(\"GL_SUN_convolution_border_modes\");\n#endif /* GL_SUN_convolution_border_modes */\n#ifdef GL_SUN_global_alpha\n  CONST_CAST(GLEW_SUN_global_alpha) = glewGetExtension(\"GL_SUN_global_alpha\");\n  if (glewExperimental || GLEW_SUN_global_alpha) CONST_CAST(GLEW_SUN_global_alpha) = !_glewInit_GL_SUN_global_alpha(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_global_alpha */\n#ifdef GL_SUN_mesh_array\n  CONST_CAST(GLEW_SUN_mesh_array) = glewGetExtension(\"GL_SUN_mesh_array\");\n#endif /* GL_SUN_mesh_array */\n#ifdef GL_SUN_read_video_pixels\n  CONST_CAST(GLEW_SUN_read_video_pixels) = glewGetExtension(\"GL_SUN_read_video_pixels\");\n  if (glewExperimental || GLEW_SUN_read_video_pixels) CONST_CAST(GLEW_SUN_read_video_pixels) = !_glewInit_GL_SUN_read_video_pixels(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_read_video_pixels */\n#ifdef GL_SUN_slice_accum\n  CONST_CAST(GLEW_SUN_slice_accum) = glewGetExtension(\"GL_SUN_slice_accum\");\n#endif /* GL_SUN_slice_accum */\n#ifdef GL_SUN_triangle_list\n  CONST_CAST(GLEW_SUN_triangle_list) = glewGetExtension(\"GL_SUN_triangle_list\");\n  if (glewExperimental || GLEW_SUN_triangle_list) CONST_CAST(GLEW_SUN_triangle_list) = !_glewInit_GL_SUN_triangle_list(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_triangle_list */\n#ifdef GL_SUN_vertex\n  CONST_CAST(GLEW_SUN_vertex) = glewGetExtension(\"GL_SUN_vertex\");\n  if (glewExperimental || GLEW_SUN_vertex) CONST_CAST(GLEW_SUN_vertex) = !_glewInit_GL_SUN_vertex(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_SUN_vertex */\n#ifdef GL_WIN_phong_shading\n  CONST_CAST(GLEW_WIN_phong_shading) = glewGetExtension(\"GL_WIN_phong_shading\");\n#endif /* GL_WIN_phong_shading */\n#ifdef GL_WIN_specular_fog\n  CONST_CAST(GLEW_WIN_specular_fog) = glewGetExtension(\"GL_WIN_specular_fog\");\n#endif /* GL_WIN_specular_fog */\n#ifdef GL_WIN_swap_hint\n  CONST_CAST(GLEW_WIN_swap_hint) = glewGetExtension(\"GL_WIN_swap_hint\");\n  if (glewExperimental || GLEW_WIN_swap_hint) CONST_CAST(GLEW_WIN_swap_hint) = !_glewInit_GL_WIN_swap_hint(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GL_WIN_swap_hint */\n\n  return GLEW_OK;\n}\n\n\n#if defined(_WIN32)\n\n#if !defined(GLEW_MX)\n\nPFNWGLSETSTEREOEMITTERSTATE3DLPROC __wglewSetStereoEmitterState3DL = NULL;\n\nPFNWGLCREATEBUFFERREGIONARBPROC __wglewCreateBufferRegionARB = NULL;\nPFNWGLDELETEBUFFERREGIONARBPROC __wglewDeleteBufferRegionARB = NULL;\nPFNWGLRESTOREBUFFERREGIONARBPROC __wglewRestoreBufferRegionARB = NULL;\nPFNWGLSAVEBUFFERREGIONARBPROC __wglewSaveBufferRegionARB = NULL;\n\nPFNWGLCREATECONTEXTATTRIBSARBPROC __wglewCreateContextAttribsARB = NULL;\n\nPFNWGLGETEXTENSIONSSTRINGARBPROC __wglewGetExtensionsStringARB = NULL;\n\nPFNWGLGETCURRENTREADDCARBPROC __wglewGetCurrentReadDCARB = NULL;\nPFNWGLMAKECONTEXTCURRENTARBPROC __wglewMakeContextCurrentARB = NULL;\n\nPFNWGLCREATEPBUFFERARBPROC __wglewCreatePbufferARB = NULL;\nPFNWGLDESTROYPBUFFERARBPROC __wglewDestroyPbufferARB = NULL;\nPFNWGLGETPBUFFERDCARBPROC __wglewGetPbufferDCARB = NULL;\nPFNWGLQUERYPBUFFERARBPROC __wglewQueryPbufferARB = NULL;\nPFNWGLRELEASEPBUFFERDCARBPROC __wglewReleasePbufferDCARB = NULL;\n\nPFNWGLCHOOSEPIXELFORMATARBPROC __wglewChoosePixelFormatARB = NULL;\nPFNWGLGETPIXELFORMATATTRIBFVARBPROC __wglewGetPixelFormatAttribfvARB = NULL;\nPFNWGLGETPIXELFORMATATTRIBIVARBPROC __wglewGetPixelFormatAttribivARB = NULL;\n\nPFNWGLBINDTEXIMAGEARBPROC __wglewBindTexImageARB = NULL;\nPFNWGLRELEASETEXIMAGEARBPROC __wglewReleaseTexImageARB = NULL;\nPFNWGLSETPBUFFERATTRIBARBPROC __wglewSetPbufferAttribARB = NULL;\n\nPFNWGLBINDDISPLAYCOLORTABLEEXTPROC __wglewBindDisplayColorTableEXT = NULL;\nPFNWGLCREATEDISPLAYCOLORTABLEEXTPROC __wglewCreateDisplayColorTableEXT = NULL;\nPFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC __wglewDestroyDisplayColorTableEXT = NULL;\nPFNWGLLOADDISPLAYCOLORTABLEEXTPROC __wglewLoadDisplayColorTableEXT = NULL;\n\nPFNWGLGETEXTENSIONSSTRINGEXTPROC __wglewGetExtensionsStringEXT = NULL;\n\nPFNWGLGETCURRENTREADDCEXTPROC __wglewGetCurrentReadDCEXT = NULL;\nPFNWGLMAKECONTEXTCURRENTEXTPROC __wglewMakeContextCurrentEXT = NULL;\n\nPFNWGLCREATEPBUFFEREXTPROC __wglewCreatePbufferEXT = NULL;\nPFNWGLDESTROYPBUFFEREXTPROC __wglewDestroyPbufferEXT = NULL;\nPFNWGLGETPBUFFERDCEXTPROC __wglewGetPbufferDCEXT = NULL;\nPFNWGLQUERYPBUFFEREXTPROC __wglewQueryPbufferEXT = NULL;\nPFNWGLRELEASEPBUFFERDCEXTPROC __wglewReleasePbufferDCEXT = NULL;\n\nPFNWGLCHOOSEPIXELFORMATEXTPROC __wglewChoosePixelFormatEXT = NULL;\nPFNWGLGETPIXELFORMATATTRIBFVEXTPROC __wglewGetPixelFormatAttribfvEXT = NULL;\nPFNWGLGETPIXELFORMATATTRIBIVEXTPROC __wglewGetPixelFormatAttribivEXT = NULL;\n\nPFNWGLGETSWAPINTERVALEXTPROC __wglewGetSwapIntervalEXT = NULL;\nPFNWGLSWAPINTERVALEXTPROC __wglewSwapIntervalEXT = NULL;\n\nPFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC __wglewGetDigitalVideoParametersI3D = NULL;\nPFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC __wglewSetDigitalVideoParametersI3D = NULL;\n\nPFNWGLGETGAMMATABLEI3DPROC __wglewGetGammaTableI3D = NULL;\nPFNWGLGETGAMMATABLEPARAMETERSI3DPROC __wglewGetGammaTableParametersI3D = NULL;\nPFNWGLSETGAMMATABLEI3DPROC __wglewSetGammaTableI3D = NULL;\nPFNWGLSETGAMMATABLEPARAMETERSI3DPROC __wglewSetGammaTableParametersI3D = NULL;\n\nPFNWGLDISABLEGENLOCKI3DPROC __wglewDisableGenlockI3D = NULL;\nPFNWGLENABLEGENLOCKI3DPROC __wglewEnableGenlockI3D = NULL;\nPFNWGLGENLOCKSAMPLERATEI3DPROC __wglewGenlockSampleRateI3D = NULL;\nPFNWGLGENLOCKSOURCEDELAYI3DPROC __wglewGenlockSourceDelayI3D = NULL;\nPFNWGLGENLOCKSOURCEEDGEI3DPROC __wglewGenlockSourceEdgeI3D = NULL;\nPFNWGLGENLOCKSOURCEI3DPROC __wglewGenlockSourceI3D = NULL;\nPFNWGLGETGENLOCKSAMPLERATEI3DPROC __wglewGetGenlockSampleRateI3D = NULL;\nPFNWGLGETGENLOCKSOURCEDELAYI3DPROC __wglewGetGenlockSourceDelayI3D = NULL;\nPFNWGLGETGENLOCKSOURCEEDGEI3DPROC __wglewGetGenlockSourceEdgeI3D = NULL;\nPFNWGLGETGENLOCKSOURCEI3DPROC __wglewGetGenlockSourceI3D = NULL;\nPFNWGLISENABLEDGENLOCKI3DPROC __wglewIsEnabledGenlockI3D = NULL;\nPFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC __wglewQueryGenlockMaxSourceDelayI3D = NULL;\n\nPFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC __wglewAssociateImageBufferEventsI3D = NULL;\nPFNWGLCREATEIMAGEBUFFERI3DPROC __wglewCreateImageBufferI3D = NULL;\nPFNWGLDESTROYIMAGEBUFFERI3DPROC __wglewDestroyImageBufferI3D = NULL;\nPFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC __wglewReleaseImageBufferEventsI3D = NULL;\n\nPFNWGLDISABLEFRAMELOCKI3DPROC __wglewDisableFrameLockI3D = NULL;\nPFNWGLENABLEFRAMELOCKI3DPROC __wglewEnableFrameLockI3D = NULL;\nPFNWGLISENABLEDFRAMELOCKI3DPROC __wglewIsEnabledFrameLockI3D = NULL;\nPFNWGLQUERYFRAMELOCKMASTERI3DPROC __wglewQueryFrameLockMasterI3D = NULL;\n\nPFNWGLBEGINFRAMETRACKINGI3DPROC __wglewBeginFrameTrackingI3D = NULL;\nPFNWGLENDFRAMETRACKINGI3DPROC __wglewEndFrameTrackingI3D = NULL;\nPFNWGLGETFRAMEUSAGEI3DPROC __wglewGetFrameUsageI3D = NULL;\nPFNWGLQUERYFRAMETRACKINGI3DPROC __wglewQueryFrameTrackingI3D = NULL;\n\nPFNWGLCREATEAFFINITYDCNVPROC __wglewCreateAffinityDCNV = NULL;\nPFNWGLDELETEDCNVPROC __wglewDeleteDCNV = NULL;\nPFNWGLENUMGPUDEVICESNVPROC __wglewEnumGpuDevicesNV = NULL;\nPFNWGLENUMGPUSFROMAFFINITYDCNVPROC __wglewEnumGpusFromAffinityDCNV = NULL;\nPFNWGLENUMGPUSNVPROC __wglewEnumGpusNV = NULL;\n\nPFNWGLBINDVIDEODEVICENVPROC __wglewBindVideoDeviceNV = NULL;\nPFNWGLENUMERATEVIDEODEVICESNVPROC __wglewEnumerateVideoDevicesNV = NULL;\nPFNWGLQUERYCURRENTCONTEXTNVPROC __wglewQueryCurrentContextNV = NULL;\n\nPFNWGLBINDSWAPBARRIERNVPROC __wglewBindSwapBarrierNV = NULL;\nPFNWGLJOINSWAPGROUPNVPROC __wglewJoinSwapGroupNV = NULL;\nPFNWGLQUERYFRAMECOUNTNVPROC __wglewQueryFrameCountNV = NULL;\nPFNWGLQUERYMAXSWAPGROUPSNVPROC __wglewQueryMaxSwapGroupsNV = NULL;\nPFNWGLQUERYSWAPGROUPNVPROC __wglewQuerySwapGroupNV = NULL;\nPFNWGLRESETFRAMECOUNTNVPROC __wglewResetFrameCountNV = NULL;\n\nPFNWGLALLOCATEMEMORYNVPROC __wglewAllocateMemoryNV = NULL;\nPFNWGLFREEMEMORYNVPROC __wglewFreeMemoryNV = NULL;\n\nPFNWGLBINDVIDEOIMAGENVPROC __wglewBindVideoImageNV = NULL;\nPFNWGLGETVIDEODEVICENVPROC __wglewGetVideoDeviceNV = NULL;\nPFNWGLGETVIDEOINFONVPROC __wglewGetVideoInfoNV = NULL;\nPFNWGLRELEASEVIDEODEVICENVPROC __wglewReleaseVideoDeviceNV = NULL;\nPFNWGLRELEASEVIDEOIMAGENVPROC __wglewReleaseVideoImageNV = NULL;\nPFNWGLSENDPBUFFERTOVIDEONVPROC __wglewSendPbufferToVideoNV = NULL;\n\nPFNWGLGETMSCRATEOMLPROC __wglewGetMscRateOML = NULL;\nPFNWGLGETSYNCVALUESOMLPROC __wglewGetSyncValuesOML = NULL;\nPFNWGLSWAPBUFFERSMSCOMLPROC __wglewSwapBuffersMscOML = NULL;\nPFNWGLSWAPLAYERBUFFERSMSCOMLPROC __wglewSwapLayerBuffersMscOML = NULL;\nPFNWGLWAITFORMSCOMLPROC __wglewWaitForMscOML = NULL;\nPFNWGLWAITFORSBCOMLPROC __wglewWaitForSbcOML = NULL;\nGLboolean __WGLEW_3DFX_multisample = GL_FALSE;\nGLboolean __WGLEW_3DL_stereo_control = GL_FALSE;\nGLboolean __WGLEW_ARB_buffer_region = GL_FALSE;\nGLboolean __WGLEW_ARB_create_context = GL_FALSE;\nGLboolean __WGLEW_ARB_extensions_string = GL_FALSE;\nGLboolean __WGLEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __WGLEW_ARB_make_current_read = GL_FALSE;\nGLboolean __WGLEW_ARB_multisample = GL_FALSE;\nGLboolean __WGLEW_ARB_pbuffer = GL_FALSE;\nGLboolean __WGLEW_ARB_pixel_format = GL_FALSE;\nGLboolean __WGLEW_ARB_pixel_format_float = GL_FALSE;\nGLboolean __WGLEW_ARB_render_texture = GL_FALSE;\nGLboolean __WGLEW_ATI_pixel_format_float = GL_FALSE;\nGLboolean __WGLEW_ATI_render_texture_rectangle = GL_FALSE;\nGLboolean __WGLEW_EXT_depth_float = GL_FALSE;\nGLboolean __WGLEW_EXT_display_color_table = GL_FALSE;\nGLboolean __WGLEW_EXT_extensions_string = GL_FALSE;\nGLboolean __WGLEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __WGLEW_EXT_make_current_read = GL_FALSE;\nGLboolean __WGLEW_EXT_multisample = GL_FALSE;\nGLboolean __WGLEW_EXT_pbuffer = GL_FALSE;\nGLboolean __WGLEW_EXT_pixel_format = GL_FALSE;\nGLboolean __WGLEW_EXT_pixel_format_packed_float = GL_FALSE;\nGLboolean __WGLEW_EXT_swap_control = GL_FALSE;\nGLboolean __WGLEW_I3D_digital_video_control = GL_FALSE;\nGLboolean __WGLEW_I3D_gamma = GL_FALSE;\nGLboolean __WGLEW_I3D_genlock = GL_FALSE;\nGLboolean __WGLEW_I3D_image_buffer = GL_FALSE;\nGLboolean __WGLEW_I3D_swap_frame_lock = GL_FALSE;\nGLboolean __WGLEW_I3D_swap_frame_usage = GL_FALSE;\nGLboolean __WGLEW_NV_float_buffer = GL_FALSE;\nGLboolean __WGLEW_NV_gpu_affinity = GL_FALSE;\nGLboolean __WGLEW_NV_present_video = GL_FALSE;\nGLboolean __WGLEW_NV_render_depth_texture = GL_FALSE;\nGLboolean __WGLEW_NV_render_texture_rectangle = GL_FALSE;\nGLboolean __WGLEW_NV_swap_group = GL_FALSE;\nGLboolean __WGLEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __WGLEW_NV_video_output = GL_FALSE;\nGLboolean __WGLEW_OML_sync_control = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef WGL_3DFX_multisample\n\n#endif /* WGL_3DFX_multisample */\n\n#ifdef WGL_3DL_stereo_control\n\nstatic GLboolean _glewInit_WGL_3DL_stereo_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglSetStereoEmitterState3DL = (PFNWGLSETSTEREOEMITTERSTATE3DLPROC)glewGetProcAddress((const GLubyte*)\"wglSetStereoEmitterState3DL\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_3DL_stereo_control */\n\n#ifdef WGL_ARB_buffer_region\n\nstatic GLboolean _glewInit_WGL_ARB_buffer_region (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateBufferRegionARB = (PFNWGLCREATEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreateBufferRegionARB\")) == NULL) || r;\n  r = ((wglDeleteBufferRegionARB = (PFNWGLDELETEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglDeleteBufferRegionARB\")) == NULL) || r;\n  r = ((wglRestoreBufferRegionARB = (PFNWGLRESTOREBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglRestoreBufferRegionARB\")) == NULL) || r;\n  r = ((wglSaveBufferRegionARB = (PFNWGLSAVEBUFFERREGIONARBPROC)glewGetProcAddress((const GLubyte*)\"wglSaveBufferRegionARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_buffer_region */\n\n#ifdef WGL_ARB_create_context\n\nstatic GLboolean _glewInit_WGL_ARB_create_context (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreateContextAttribsARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_create_context */\n\n#ifdef WGL_ARB_extensions_string\n\nstatic GLboolean _glewInit_WGL_ARB_extensions_string (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_extensions_string */\n\n#ifdef WGL_ARB_framebuffer_sRGB\n\n#endif /* WGL_ARB_framebuffer_sRGB */\n\n#ifdef WGL_ARB_make_current_read\n\nstatic GLboolean _glewInit_WGL_ARB_make_current_read (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetCurrentReadDCARB = (PFNWGLGETCURRENTREADDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetCurrentReadDCARB\")) == NULL) || r;\n  r = ((wglMakeContextCurrentARB = (PFNWGLMAKECONTEXTCURRENTARBPROC)glewGetProcAddress((const GLubyte*)\"wglMakeContextCurrentARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_make_current_read */\n\n#ifdef WGL_ARB_multisample\n\n#endif /* WGL_ARB_multisample */\n\n#ifdef WGL_ARB_pbuffer\n\nstatic GLboolean _glewInit_WGL_ARB_pbuffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreatePbufferARB = (PFNWGLCREATEPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglCreatePbufferARB\")) == NULL) || r;\n  r = ((wglDestroyPbufferARB = (PFNWGLDESTROYPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyPbufferARB\")) == NULL) || r;\n  r = ((wglGetPbufferDCARB = (PFNWGLGETPBUFFERDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPbufferDCARB\")) == NULL) || r;\n  r = ((wglQueryPbufferARB = (PFNWGLQUERYPBUFFERARBPROC)glewGetProcAddress((const GLubyte*)\"wglQueryPbufferARB\")) == NULL) || r;\n  r = ((wglReleasePbufferDCARB = (PFNWGLRELEASEPBUFFERDCARBPROC)glewGetProcAddress((const GLubyte*)\"wglReleasePbufferDCARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_pbuffer */\n\n#ifdef WGL_ARB_pixel_format\n\nstatic GLboolean _glewInit_WGL_ARB_pixel_format (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)glewGetProcAddress((const GLubyte*)\"wglChoosePixelFormatARB\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribfvARB = (PFNWGLGETPIXELFORMATATTRIBFVARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribfvARB\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribivARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_pixel_format */\n\n#ifdef WGL_ARB_pixel_format_float\n\n#endif /* WGL_ARB_pixel_format_float */\n\n#ifdef WGL_ARB_render_texture\n\nstatic GLboolean _glewInit_WGL_ARB_render_texture (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindTexImageARB = (PFNWGLBINDTEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"wglBindTexImageARB\")) == NULL) || r;\n  r = ((wglReleaseTexImageARB = (PFNWGLRELEASETEXIMAGEARBPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseTexImageARB\")) == NULL) || r;\n  r = ((wglSetPbufferAttribARB = (PFNWGLSETPBUFFERATTRIBARBPROC)glewGetProcAddress((const GLubyte*)\"wglSetPbufferAttribARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_ARB_render_texture */\n\n#ifdef WGL_ATI_pixel_format_float\n\n#endif /* WGL_ATI_pixel_format_float */\n\n#ifdef WGL_ATI_render_texture_rectangle\n\n#endif /* WGL_ATI_render_texture_rectangle */\n\n#ifdef WGL_EXT_depth_float\n\n#endif /* WGL_EXT_depth_float */\n\n#ifdef WGL_EXT_display_color_table\n\nstatic GLboolean _glewInit_WGL_EXT_display_color_table (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindDisplayColorTableEXT = (PFNWGLBINDDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglBindDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglCreateDisplayColorTableEXT = (PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglCreateDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglDestroyDisplayColorTableEXT = (PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyDisplayColorTableEXT\")) == NULL) || r;\n  r = ((wglLoadDisplayColorTableEXT = (PFNWGLLOADDISPLAYCOLORTABLEEXTPROC)glewGetProcAddress((const GLubyte*)\"wglLoadDisplayColorTableEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_display_color_table */\n\n#ifdef WGL_EXT_extensions_string\n\nstatic GLboolean _glewInit_WGL_EXT_extensions_string (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_extensions_string */\n\n#ifdef WGL_EXT_framebuffer_sRGB\n\n#endif /* WGL_EXT_framebuffer_sRGB */\n\n#ifdef WGL_EXT_make_current_read\n\nstatic GLboolean _glewInit_WGL_EXT_make_current_read (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetCurrentReadDCEXT = (PFNWGLGETCURRENTREADDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetCurrentReadDCEXT\")) == NULL) || r;\n  r = ((wglMakeContextCurrentEXT = (PFNWGLMAKECONTEXTCURRENTEXTPROC)glewGetProcAddress((const GLubyte*)\"wglMakeContextCurrentEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_make_current_read */\n\n#ifdef WGL_EXT_multisample\n\n#endif /* WGL_EXT_multisample */\n\n#ifdef WGL_EXT_pbuffer\n\nstatic GLboolean _glewInit_WGL_EXT_pbuffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreatePbufferEXT = (PFNWGLCREATEPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglCreatePbufferEXT\")) == NULL) || r;\n  r = ((wglDestroyPbufferEXT = (PFNWGLDESTROYPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyPbufferEXT\")) == NULL) || r;\n  r = ((wglGetPbufferDCEXT = (PFNWGLGETPBUFFERDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPbufferDCEXT\")) == NULL) || r;\n  r = ((wglQueryPbufferEXT = (PFNWGLQUERYPBUFFEREXTPROC)glewGetProcAddress((const GLubyte*)\"wglQueryPbufferEXT\")) == NULL) || r;\n  r = ((wglReleasePbufferDCEXT = (PFNWGLRELEASEPBUFFERDCEXTPROC)glewGetProcAddress((const GLubyte*)\"wglReleasePbufferDCEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_pbuffer */\n\n#ifdef WGL_EXT_pixel_format\n\nstatic GLboolean _glewInit_WGL_EXT_pixel_format (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglChoosePixelFormatEXT = (PFNWGLCHOOSEPIXELFORMATEXTPROC)glewGetProcAddress((const GLubyte*)\"wglChoosePixelFormatEXT\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribfvEXT = (PFNWGLGETPIXELFORMATATTRIBFVEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribfvEXT\")) == NULL) || r;\n  r = ((wglGetPixelFormatAttribivEXT = (PFNWGLGETPIXELFORMATATTRIBIVEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetPixelFormatAttribivEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_pixel_format */\n\n#ifdef WGL_EXT_pixel_format_packed_float\n\n#endif /* WGL_EXT_pixel_format_packed_float */\n\n#ifdef WGL_EXT_swap_control\n\nstatic GLboolean _glewInit_WGL_EXT_swap_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetSwapIntervalEXT = (PFNWGLGETSWAPINTERVALEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetSwapIntervalEXT\")) == NULL) || r;\n  r = ((wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)glewGetProcAddress((const GLubyte*)\"wglSwapIntervalEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_EXT_swap_control */\n\n#ifdef WGL_I3D_digital_video_control\n\nstatic GLboolean _glewInit_WGL_I3D_digital_video_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetDigitalVideoParametersI3D = (PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetDigitalVideoParametersI3D\")) == NULL) || r;\n  r = ((wglSetDigitalVideoParametersI3D = (PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetDigitalVideoParametersI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_digital_video_control */\n\n#ifdef WGL_I3D_gamma\n\nstatic GLboolean _glewInit_WGL_I3D_gamma (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetGammaTableI3D = (PFNWGLGETGAMMATABLEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGammaTableI3D\")) == NULL) || r;\n  r = ((wglGetGammaTableParametersI3D = (PFNWGLGETGAMMATABLEPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGammaTableParametersI3D\")) == NULL) || r;\n  r = ((wglSetGammaTableI3D = (PFNWGLSETGAMMATABLEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetGammaTableI3D\")) == NULL) || r;\n  r = ((wglSetGammaTableParametersI3D = (PFNWGLSETGAMMATABLEPARAMETERSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglSetGammaTableParametersI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_gamma */\n\n#ifdef WGL_I3D_genlock\n\nstatic GLboolean _glewInit_WGL_I3D_genlock (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglDisableGenlockI3D = (PFNWGLDISABLEGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDisableGenlockI3D\")) == NULL) || r;\n  r = ((wglEnableGenlockI3D = (PFNWGLENABLEGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEnableGenlockI3D\")) == NULL) || r;\n  r = ((wglGenlockSampleRateI3D = (PFNWGLGENLOCKSAMPLERATEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSampleRateI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceDelayI3D = (PFNWGLGENLOCKSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceDelayI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceEdgeI3D = (PFNWGLGENLOCKSOURCEEDGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceEdgeI3D\")) == NULL) || r;\n  r = ((wglGenlockSourceI3D = (PFNWGLGENLOCKSOURCEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGenlockSourceI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSampleRateI3D = (PFNWGLGETGENLOCKSAMPLERATEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSampleRateI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceDelayI3D = (PFNWGLGETGENLOCKSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceDelayI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceEdgeI3D = (PFNWGLGETGENLOCKSOURCEEDGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceEdgeI3D\")) == NULL) || r;\n  r = ((wglGetGenlockSourceI3D = (PFNWGLGETGENLOCKSOURCEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetGenlockSourceI3D\")) == NULL) || r;\n  r = ((wglIsEnabledGenlockI3D = (PFNWGLISENABLEDGENLOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglIsEnabledGenlockI3D\")) == NULL) || r;\n  r = ((wglQueryGenlockMaxSourceDelayI3D = (PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryGenlockMaxSourceDelayI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_genlock */\n\n#ifdef WGL_I3D_image_buffer\n\nstatic GLboolean _glewInit_WGL_I3D_image_buffer (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglAssociateImageBufferEventsI3D = (PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglAssociateImageBufferEventsI3D\")) == NULL) || r;\n  r = ((wglCreateImageBufferI3D = (PFNWGLCREATEIMAGEBUFFERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglCreateImageBufferI3D\")) == NULL) || r;\n  r = ((wglDestroyImageBufferI3D = (PFNWGLDESTROYIMAGEBUFFERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDestroyImageBufferI3D\")) == NULL) || r;\n  r = ((wglReleaseImageBufferEventsI3D = (PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseImageBufferEventsI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_image_buffer */\n\n#ifdef WGL_I3D_swap_frame_lock\n\nstatic GLboolean _glewInit_WGL_I3D_swap_frame_lock (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglDisableFrameLockI3D = (PFNWGLDISABLEFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglDisableFrameLockI3D\")) == NULL) || r;\n  r = ((wglEnableFrameLockI3D = (PFNWGLENABLEFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEnableFrameLockI3D\")) == NULL) || r;\n  r = ((wglIsEnabledFrameLockI3D = (PFNWGLISENABLEDFRAMELOCKI3DPROC)glewGetProcAddress((const GLubyte*)\"wglIsEnabledFrameLockI3D\")) == NULL) || r;\n  r = ((wglQueryFrameLockMasterI3D = (PFNWGLQUERYFRAMELOCKMASTERI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameLockMasterI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_swap_frame_lock */\n\n#ifdef WGL_I3D_swap_frame_usage\n\nstatic GLboolean _glewInit_WGL_I3D_swap_frame_usage (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBeginFrameTrackingI3D = (PFNWGLBEGINFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglBeginFrameTrackingI3D\")) == NULL) || r;\n  r = ((wglEndFrameTrackingI3D = (PFNWGLENDFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglEndFrameTrackingI3D\")) == NULL) || r;\n  r = ((wglGetFrameUsageI3D = (PFNWGLGETFRAMEUSAGEI3DPROC)glewGetProcAddress((const GLubyte*)\"wglGetFrameUsageI3D\")) == NULL) || r;\n  r = ((wglQueryFrameTrackingI3D = (PFNWGLQUERYFRAMETRACKINGI3DPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameTrackingI3D\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_I3D_swap_frame_usage */\n\n#ifdef WGL_NV_float_buffer\n\n#endif /* WGL_NV_float_buffer */\n\n#ifdef WGL_NV_gpu_affinity\n\nstatic GLboolean _glewInit_WGL_NV_gpu_affinity (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglCreateAffinityDCNV = (PFNWGLCREATEAFFINITYDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglCreateAffinityDCNV\")) == NULL) || r;\n  r = ((wglDeleteDCNV = (PFNWGLDELETEDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglDeleteDCNV\")) == NULL) || r;\n  r = ((wglEnumGpuDevicesNV = (PFNWGLENUMGPUDEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpuDevicesNV\")) == NULL) || r;\n  r = ((wglEnumGpusFromAffinityDCNV = (PFNWGLENUMGPUSFROMAFFINITYDCNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpusFromAffinityDCNV\")) == NULL) || r;\n  r = ((wglEnumGpusNV = (PFNWGLENUMGPUSNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumGpusNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_gpu_affinity */\n\n#ifdef WGL_NV_present_video\n\nstatic GLboolean _glewInit_WGL_NV_present_video (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindVideoDeviceNV = (PFNWGLBINDVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglBindVideoDeviceNV\")) == NULL) || r;\n  r = ((wglEnumerateVideoDevicesNV = (PFNWGLENUMERATEVIDEODEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"wglEnumerateVideoDevicesNV\")) == NULL) || r;\n  r = ((wglQueryCurrentContextNV = (PFNWGLQUERYCURRENTCONTEXTNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryCurrentContextNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_present_video */\n\n#ifdef WGL_NV_render_depth_texture\n\n#endif /* WGL_NV_render_depth_texture */\n\n#ifdef WGL_NV_render_texture_rectangle\n\n#endif /* WGL_NV_render_texture_rectangle */\n\n#ifdef WGL_NV_swap_group\n\nstatic GLboolean _glewInit_WGL_NV_swap_group (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindSwapBarrierNV = (PFNWGLBINDSWAPBARRIERNVPROC)glewGetProcAddress((const GLubyte*)\"wglBindSwapBarrierNV\")) == NULL) || r;\n  r = ((wglJoinSwapGroupNV = (PFNWGLJOINSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"wglJoinSwapGroupNV\")) == NULL) || r;\n  r = ((wglQueryFrameCountNV = (PFNWGLQUERYFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryFrameCountNV\")) == NULL) || r;\n  r = ((wglQueryMaxSwapGroupsNV = (PFNWGLQUERYMAXSWAPGROUPSNVPROC)glewGetProcAddress((const GLubyte*)\"wglQueryMaxSwapGroupsNV\")) == NULL) || r;\n  r = ((wglQuerySwapGroupNV = (PFNWGLQUERYSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"wglQuerySwapGroupNV\")) == NULL) || r;\n  r = ((wglResetFrameCountNV = (PFNWGLRESETFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"wglResetFrameCountNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_swap_group */\n\n#ifdef WGL_NV_vertex_array_range\n\nstatic GLboolean _glewInit_WGL_NV_vertex_array_range (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglAllocateMemoryNV = (PFNWGLALLOCATEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"wglAllocateMemoryNV\")) == NULL) || r;\n  r = ((wglFreeMemoryNV = (PFNWGLFREEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"wglFreeMemoryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_vertex_array_range */\n\n#ifdef WGL_NV_video_output\n\nstatic GLboolean _glewInit_WGL_NV_video_output (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglBindVideoImageNV = (PFNWGLBINDVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"wglBindVideoImageNV\")) == NULL) || r;\n  r = ((wglGetVideoDeviceNV = (PFNWGLGETVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglGetVideoDeviceNV\")) == NULL) || r;\n  r = ((wglGetVideoInfoNV = (PFNWGLGETVIDEOINFONVPROC)glewGetProcAddress((const GLubyte*)\"wglGetVideoInfoNV\")) == NULL) || r;\n  r = ((wglReleaseVideoDeviceNV = (PFNWGLRELEASEVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseVideoDeviceNV\")) == NULL) || r;\n  r = ((wglReleaseVideoImageNV = (PFNWGLRELEASEVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"wglReleaseVideoImageNV\")) == NULL) || r;\n  r = ((wglSendPbufferToVideoNV = (PFNWGLSENDPBUFFERTOVIDEONVPROC)glewGetProcAddress((const GLubyte*)\"wglSendPbufferToVideoNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_NV_video_output */\n\n#ifdef WGL_OML_sync_control\n\nstatic GLboolean _glewInit_WGL_OML_sync_control (WGLEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((wglGetMscRateOML = (PFNWGLGETMSCRATEOMLPROC)glewGetProcAddress((const GLubyte*)\"wglGetMscRateOML\")) == NULL) || r;\n  r = ((wglGetSyncValuesOML = (PFNWGLGETSYNCVALUESOMLPROC)glewGetProcAddress((const GLubyte*)\"wglGetSyncValuesOML\")) == NULL) || r;\n  r = ((wglSwapBuffersMscOML = (PFNWGLSWAPBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglSwapBuffersMscOML\")) == NULL) || r;\n  r = ((wglSwapLayerBuffersMscOML = (PFNWGLSWAPLAYERBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglSwapLayerBuffersMscOML\")) == NULL) || r;\n  r = ((wglWaitForMscOML = (PFNWGLWAITFORMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglWaitForMscOML\")) == NULL) || r;\n  r = ((wglWaitForSbcOML = (PFNWGLWAITFORSBCOMLPROC)glewGetProcAddress((const GLubyte*)\"wglWaitForSbcOML\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* WGL_OML_sync_control */\n\n/* ------------------------------------------------------------------------- */\n\nstatic PFNWGLGETEXTENSIONSSTRINGARBPROC _wglewGetExtensionsStringARB = NULL;\nstatic PFNWGLGETEXTENSIONSSTRINGEXTPROC _wglewGetExtensionsStringEXT = NULL;\n\nGLboolean wglewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n  if (_wglewGetExtensionsStringARB == NULL)\n    if (_wglewGetExtensionsStringEXT == NULL)\n      return GL_FALSE;\n    else\n      p = (GLubyte*)_wglewGetExtensionsStringEXT();\n  else\n    p = (GLubyte*)_wglewGetExtensionsStringARB(wglGetCurrentDC());\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\nGLenum wglewContextInit (WGLEW_CONTEXT_ARG_DEF_LIST)\n{\n  GLboolean crippled;\n  /* find wgl extension string query functions */\n  _wglewGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringARB\");\n  _wglewGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)glewGetProcAddress((const GLubyte*)\"wglGetExtensionsStringEXT\");\n  /* initialize extensions */\n  crippled = _wglewGetExtensionsStringARB == NULL && _wglewGetExtensionsStringEXT == NULL;\n#ifdef WGL_3DFX_multisample\n  CONST_CAST(WGLEW_3DFX_multisample) = wglewGetExtension(\"WGL_3DFX_multisample\");\n#endif /* WGL_3DFX_multisample */\n#ifdef WGL_3DL_stereo_control\n  CONST_CAST(WGLEW_3DL_stereo_control) = wglewGetExtension(\"WGL_3DL_stereo_control\");\n  if (glewExperimental || WGLEW_3DL_stereo_control|| crippled) CONST_CAST(WGLEW_3DL_stereo_control)= !_glewInit_WGL_3DL_stereo_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_3DL_stereo_control */\n#ifdef WGL_ARB_buffer_region\n  CONST_CAST(WGLEW_ARB_buffer_region) = wglewGetExtension(\"WGL_ARB_buffer_region\");\n  if (glewExperimental || WGLEW_ARB_buffer_region|| crippled) CONST_CAST(WGLEW_ARB_buffer_region)= !_glewInit_WGL_ARB_buffer_region(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_buffer_region */\n#ifdef WGL_ARB_create_context\n  CONST_CAST(WGLEW_ARB_create_context) = wglewGetExtension(\"WGL_ARB_create_context\");\n  if (glewExperimental || WGLEW_ARB_create_context|| crippled) CONST_CAST(WGLEW_ARB_create_context)= !_glewInit_WGL_ARB_create_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_create_context */\n#ifdef WGL_ARB_extensions_string\n  CONST_CAST(WGLEW_ARB_extensions_string) = wglewGetExtension(\"WGL_ARB_extensions_string\");\n  if (glewExperimental || WGLEW_ARB_extensions_string|| crippled) CONST_CAST(WGLEW_ARB_extensions_string)= !_glewInit_WGL_ARB_extensions_string(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_extensions_string */\n#ifdef WGL_ARB_framebuffer_sRGB\n  CONST_CAST(WGLEW_ARB_framebuffer_sRGB) = wglewGetExtension(\"WGL_ARB_framebuffer_sRGB\");\n#endif /* WGL_ARB_framebuffer_sRGB */\n#ifdef WGL_ARB_make_current_read\n  CONST_CAST(WGLEW_ARB_make_current_read) = wglewGetExtension(\"WGL_ARB_make_current_read\");\n  if (glewExperimental || WGLEW_ARB_make_current_read|| crippled) CONST_CAST(WGLEW_ARB_make_current_read)= !_glewInit_WGL_ARB_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_make_current_read */\n#ifdef WGL_ARB_multisample\n  CONST_CAST(WGLEW_ARB_multisample) = wglewGetExtension(\"WGL_ARB_multisample\");\n#endif /* WGL_ARB_multisample */\n#ifdef WGL_ARB_pbuffer\n  CONST_CAST(WGLEW_ARB_pbuffer) = wglewGetExtension(\"WGL_ARB_pbuffer\");\n  if (glewExperimental || WGLEW_ARB_pbuffer|| crippled) CONST_CAST(WGLEW_ARB_pbuffer)= !_glewInit_WGL_ARB_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_pbuffer */\n#ifdef WGL_ARB_pixel_format\n  CONST_CAST(WGLEW_ARB_pixel_format) = wglewGetExtension(\"WGL_ARB_pixel_format\");\n  if (glewExperimental || WGLEW_ARB_pixel_format|| crippled) CONST_CAST(WGLEW_ARB_pixel_format)= !_glewInit_WGL_ARB_pixel_format(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_pixel_format */\n#ifdef WGL_ARB_pixel_format_float\n  CONST_CAST(WGLEW_ARB_pixel_format_float) = wglewGetExtension(\"WGL_ARB_pixel_format_float\");\n#endif /* WGL_ARB_pixel_format_float */\n#ifdef WGL_ARB_render_texture\n  CONST_CAST(WGLEW_ARB_render_texture) = wglewGetExtension(\"WGL_ARB_render_texture\");\n  if (glewExperimental || WGLEW_ARB_render_texture|| crippled) CONST_CAST(WGLEW_ARB_render_texture)= !_glewInit_WGL_ARB_render_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_ARB_render_texture */\n#ifdef WGL_ATI_pixel_format_float\n  CONST_CAST(WGLEW_ATI_pixel_format_float) = wglewGetExtension(\"WGL_ATI_pixel_format_float\");\n#endif /* WGL_ATI_pixel_format_float */\n#ifdef WGL_ATI_render_texture_rectangle\n  CONST_CAST(WGLEW_ATI_render_texture_rectangle) = wglewGetExtension(\"WGL_ATI_render_texture_rectangle\");\n#endif /* WGL_ATI_render_texture_rectangle */\n#ifdef WGL_EXT_depth_float\n  CONST_CAST(WGLEW_EXT_depth_float) = wglewGetExtension(\"WGL_EXT_depth_float\");\n#endif /* WGL_EXT_depth_float */\n#ifdef WGL_EXT_display_color_table\n  CONST_CAST(WGLEW_EXT_display_color_table) = wglewGetExtension(\"WGL_EXT_display_color_table\");\n  if (glewExperimental || WGLEW_EXT_display_color_table|| crippled) CONST_CAST(WGLEW_EXT_display_color_table)= !_glewInit_WGL_EXT_display_color_table(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_display_color_table */\n#ifdef WGL_EXT_extensions_string\n  CONST_CAST(WGLEW_EXT_extensions_string) = wglewGetExtension(\"WGL_EXT_extensions_string\");\n  if (glewExperimental || WGLEW_EXT_extensions_string|| crippled) CONST_CAST(WGLEW_EXT_extensions_string)= !_glewInit_WGL_EXT_extensions_string(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_extensions_string */\n#ifdef WGL_EXT_framebuffer_sRGB\n  CONST_CAST(WGLEW_EXT_framebuffer_sRGB) = wglewGetExtension(\"WGL_EXT_framebuffer_sRGB\");\n#endif /* WGL_EXT_framebuffer_sRGB */\n#ifdef WGL_EXT_make_current_read\n  CONST_CAST(WGLEW_EXT_make_current_read) = wglewGetExtension(\"WGL_EXT_make_current_read\");\n  if (glewExperimental || WGLEW_EXT_make_current_read|| crippled) CONST_CAST(WGLEW_EXT_make_current_read)= !_glewInit_WGL_EXT_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_make_current_read */\n#ifdef WGL_EXT_multisample\n  CONST_CAST(WGLEW_EXT_multisample) = wglewGetExtension(\"WGL_EXT_multisample\");\n#endif /* WGL_EXT_multisample */\n#ifdef WGL_EXT_pbuffer\n  CONST_CAST(WGLEW_EXT_pbuffer) = wglewGetExtension(\"WGL_EXT_pbuffer\");\n  if (glewExperimental || WGLEW_EXT_pbuffer|| crippled) CONST_CAST(WGLEW_EXT_pbuffer)= !_glewInit_WGL_EXT_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_pbuffer */\n#ifdef WGL_EXT_pixel_format\n  CONST_CAST(WGLEW_EXT_pixel_format) = wglewGetExtension(\"WGL_EXT_pixel_format\");\n  if (glewExperimental || WGLEW_EXT_pixel_format|| crippled) CONST_CAST(WGLEW_EXT_pixel_format)= !_glewInit_WGL_EXT_pixel_format(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_pixel_format */\n#ifdef WGL_EXT_pixel_format_packed_float\n  CONST_CAST(WGLEW_EXT_pixel_format_packed_float) = wglewGetExtension(\"WGL_EXT_pixel_format_packed_float\");\n#endif /* WGL_EXT_pixel_format_packed_float */\n#ifdef WGL_EXT_swap_control\n  CONST_CAST(WGLEW_EXT_swap_control) = wglewGetExtension(\"WGL_EXT_swap_control\");\n  if (glewExperimental || WGLEW_EXT_swap_control|| crippled) CONST_CAST(WGLEW_EXT_swap_control)= !_glewInit_WGL_EXT_swap_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_EXT_swap_control */\n#ifdef WGL_I3D_digital_video_control\n  CONST_CAST(WGLEW_I3D_digital_video_control) = wglewGetExtension(\"WGL_I3D_digital_video_control\");\n  if (glewExperimental || WGLEW_I3D_digital_video_control|| crippled) CONST_CAST(WGLEW_I3D_digital_video_control)= !_glewInit_WGL_I3D_digital_video_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_digital_video_control */\n#ifdef WGL_I3D_gamma\n  CONST_CAST(WGLEW_I3D_gamma) = wglewGetExtension(\"WGL_I3D_gamma\");\n  if (glewExperimental || WGLEW_I3D_gamma|| crippled) CONST_CAST(WGLEW_I3D_gamma)= !_glewInit_WGL_I3D_gamma(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_gamma */\n#ifdef WGL_I3D_genlock\n  CONST_CAST(WGLEW_I3D_genlock) = wglewGetExtension(\"WGL_I3D_genlock\");\n  if (glewExperimental || WGLEW_I3D_genlock|| crippled) CONST_CAST(WGLEW_I3D_genlock)= !_glewInit_WGL_I3D_genlock(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_genlock */\n#ifdef WGL_I3D_image_buffer\n  CONST_CAST(WGLEW_I3D_image_buffer) = wglewGetExtension(\"WGL_I3D_image_buffer\");\n  if (glewExperimental || WGLEW_I3D_image_buffer|| crippled) CONST_CAST(WGLEW_I3D_image_buffer)= !_glewInit_WGL_I3D_image_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_image_buffer */\n#ifdef WGL_I3D_swap_frame_lock\n  CONST_CAST(WGLEW_I3D_swap_frame_lock) = wglewGetExtension(\"WGL_I3D_swap_frame_lock\");\n  if (glewExperimental || WGLEW_I3D_swap_frame_lock|| crippled) CONST_CAST(WGLEW_I3D_swap_frame_lock)= !_glewInit_WGL_I3D_swap_frame_lock(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_swap_frame_lock */\n#ifdef WGL_I3D_swap_frame_usage\n  CONST_CAST(WGLEW_I3D_swap_frame_usage) = wglewGetExtension(\"WGL_I3D_swap_frame_usage\");\n  if (glewExperimental || WGLEW_I3D_swap_frame_usage|| crippled) CONST_CAST(WGLEW_I3D_swap_frame_usage)= !_glewInit_WGL_I3D_swap_frame_usage(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_I3D_swap_frame_usage */\n#ifdef WGL_NV_float_buffer\n  CONST_CAST(WGLEW_NV_float_buffer) = wglewGetExtension(\"WGL_NV_float_buffer\");\n#endif /* WGL_NV_float_buffer */\n#ifdef WGL_NV_gpu_affinity\n  CONST_CAST(WGLEW_NV_gpu_affinity) = wglewGetExtension(\"WGL_NV_gpu_affinity\");\n  if (glewExperimental || WGLEW_NV_gpu_affinity|| crippled) CONST_CAST(WGLEW_NV_gpu_affinity)= !_glewInit_WGL_NV_gpu_affinity(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_gpu_affinity */\n#ifdef WGL_NV_present_video\n  CONST_CAST(WGLEW_NV_present_video) = wglewGetExtension(\"WGL_NV_present_video\");\n  if (glewExperimental || WGLEW_NV_present_video|| crippled) CONST_CAST(WGLEW_NV_present_video)= !_glewInit_WGL_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_present_video */\n#ifdef WGL_NV_render_depth_texture\n  CONST_CAST(WGLEW_NV_render_depth_texture) = wglewGetExtension(\"WGL_NV_render_depth_texture\");\n#endif /* WGL_NV_render_depth_texture */\n#ifdef WGL_NV_render_texture_rectangle\n  CONST_CAST(WGLEW_NV_render_texture_rectangle) = wglewGetExtension(\"WGL_NV_render_texture_rectangle\");\n#endif /* WGL_NV_render_texture_rectangle */\n#ifdef WGL_NV_swap_group\n  CONST_CAST(WGLEW_NV_swap_group) = wglewGetExtension(\"WGL_NV_swap_group\");\n  if (glewExperimental || WGLEW_NV_swap_group|| crippled) CONST_CAST(WGLEW_NV_swap_group)= !_glewInit_WGL_NV_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_swap_group */\n#ifdef WGL_NV_vertex_array_range\n  CONST_CAST(WGLEW_NV_vertex_array_range) = wglewGetExtension(\"WGL_NV_vertex_array_range\");\n  if (glewExperimental || WGLEW_NV_vertex_array_range|| crippled) CONST_CAST(WGLEW_NV_vertex_array_range)= !_glewInit_WGL_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_vertex_array_range */\n#ifdef WGL_NV_video_output\n  CONST_CAST(WGLEW_NV_video_output) = wglewGetExtension(\"WGL_NV_video_output\");\n  if (glewExperimental || WGLEW_NV_video_output|| crippled) CONST_CAST(WGLEW_NV_video_output)= !_glewInit_WGL_NV_video_output(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_NV_video_output */\n#ifdef WGL_OML_sync_control\n  CONST_CAST(WGLEW_OML_sync_control) = wglewGetExtension(\"WGL_OML_sync_control\");\n  if (glewExperimental || WGLEW_OML_sync_control|| crippled) CONST_CAST(WGLEW_OML_sync_control)= !_glewInit_WGL_OML_sync_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* WGL_OML_sync_control */\n\n  return GLEW_OK;\n}\n\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n\nPFNGLXGETCURRENTDISPLAYPROC __glewXGetCurrentDisplay = NULL;\n\nPFNGLXCHOOSEFBCONFIGPROC __glewXChooseFBConfig = NULL;\nPFNGLXCREATENEWCONTEXTPROC __glewXCreateNewContext = NULL;\nPFNGLXCREATEPBUFFERPROC __glewXCreatePbuffer = NULL;\nPFNGLXCREATEPIXMAPPROC __glewXCreatePixmap = NULL;\nPFNGLXCREATEWINDOWPROC __glewXCreateWindow = NULL;\nPFNGLXDESTROYPBUFFERPROC __glewXDestroyPbuffer = NULL;\nPFNGLXDESTROYPIXMAPPROC __glewXDestroyPixmap = NULL;\nPFNGLXDESTROYWINDOWPROC __glewXDestroyWindow = NULL;\nPFNGLXGETCURRENTREADDRAWABLEPROC __glewXGetCurrentReadDrawable = NULL;\nPFNGLXGETFBCONFIGATTRIBPROC __glewXGetFBConfigAttrib = NULL;\nPFNGLXGETFBCONFIGSPROC __glewXGetFBConfigs = NULL;\nPFNGLXGETSELECTEDEVENTPROC __glewXGetSelectedEvent = NULL;\nPFNGLXGETVISUALFROMFBCONFIGPROC __glewXGetVisualFromFBConfig = NULL;\nPFNGLXMAKECONTEXTCURRENTPROC __glewXMakeContextCurrent = NULL;\nPFNGLXQUERYCONTEXTPROC __glewXQueryContext = NULL;\nPFNGLXQUERYDRAWABLEPROC __glewXQueryDrawable = NULL;\nPFNGLXSELECTEVENTPROC __glewXSelectEvent = NULL;\n\nPFNGLXCREATECONTEXTATTRIBSARBPROC __glewXCreateContextAttribsARB = NULL;\n\nPFNGLXBINDTEXIMAGEATIPROC __glewXBindTexImageATI = NULL;\nPFNGLXDRAWABLEATTRIBATIPROC __glewXDrawableAttribATI = NULL;\nPFNGLXRELEASETEXIMAGEATIPROC __glewXReleaseTexImageATI = NULL;\n\nPFNGLXFREECONTEXTEXTPROC __glewXFreeContextEXT = NULL;\nPFNGLXGETCONTEXTIDEXTPROC __glewXGetContextIDEXT = NULL;\nPFNGLXIMPORTCONTEXTEXTPROC __glewXImportContextEXT = NULL;\nPFNGLXQUERYCONTEXTINFOEXTPROC __glewXQueryContextInfoEXT = NULL;\n\nPFNGLXBINDTEXIMAGEEXTPROC __glewXBindTexImageEXT = NULL;\nPFNGLXRELEASETEXIMAGEEXTPROC __glewXReleaseTexImageEXT = NULL;\n\nPFNGLXGETAGPOFFSETMESAPROC __glewXGetAGPOffsetMESA = NULL;\n\nPFNGLXCOPYSUBBUFFERMESAPROC __glewXCopySubBufferMESA = NULL;\n\nPFNGLXCREATEGLXPIXMAPMESAPROC __glewXCreateGLXPixmapMESA = NULL;\n\nPFNGLXRELEASEBUFFERSMESAPROC __glewXReleaseBuffersMESA = NULL;\n\nPFNGLXSET3DFXMODEMESAPROC __glewXSet3DfxModeMESA = NULL;\n\nPFNGLXBINDVIDEODEVICENVPROC __glewXBindVideoDeviceNV = NULL;\nPFNGLXENUMERATEVIDEODEVICESNVPROC __glewXEnumerateVideoDevicesNV = NULL;\n\nPFNGLXBINDSWAPBARRIERNVPROC __glewXBindSwapBarrierNV = NULL;\nPFNGLXJOINSWAPGROUPNVPROC __glewXJoinSwapGroupNV = NULL;\nPFNGLXQUERYFRAMECOUNTNVPROC __glewXQueryFrameCountNV = NULL;\nPFNGLXQUERYMAXSWAPGROUPSNVPROC __glewXQueryMaxSwapGroupsNV = NULL;\nPFNGLXQUERYSWAPGROUPNVPROC __glewXQuerySwapGroupNV = NULL;\nPFNGLXRESETFRAMECOUNTNVPROC __glewXResetFrameCountNV = NULL;\n\nPFNGLXALLOCATEMEMORYNVPROC __glewXAllocateMemoryNV = NULL;\nPFNGLXFREEMEMORYNVPROC __glewXFreeMemoryNV = NULL;\n\nPFNGLXBINDVIDEOIMAGENVPROC __glewXBindVideoImageNV = NULL;\nPFNGLXGETVIDEODEVICENVPROC __glewXGetVideoDeviceNV = NULL;\nPFNGLXGETVIDEOINFONVPROC __glewXGetVideoInfoNV = NULL;\nPFNGLXRELEASEVIDEODEVICENVPROC __glewXReleaseVideoDeviceNV = NULL;\nPFNGLXRELEASEVIDEOIMAGENVPROC __glewXReleaseVideoImageNV = NULL;\nPFNGLXSENDPBUFFERTOVIDEONVPROC __glewXSendPbufferToVideoNV = NULL;\n\n#ifdef GLX_OML_sync_control\nPFNGLXGETMSCRATEOMLPROC __glewXGetMscRateOML = NULL;\nPFNGLXGETSYNCVALUESOMLPROC __glewXGetSyncValuesOML = NULL;\nPFNGLXSWAPBUFFERSMSCOMLPROC __glewXSwapBuffersMscOML = NULL;\nPFNGLXWAITFORMSCOMLPROC __glewXWaitForMscOML = NULL;\nPFNGLXWAITFORSBCOMLPROC __glewXWaitForSbcOML = NULL;\n#endif\n\nPFNGLXCHOOSEFBCONFIGSGIXPROC __glewXChooseFBConfigSGIX = NULL;\nPFNGLXCREATECONTEXTWITHCONFIGSGIXPROC __glewXCreateContextWithConfigSGIX = NULL;\nPFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC __glewXCreateGLXPixmapWithConfigSGIX = NULL;\nPFNGLXGETFBCONFIGATTRIBSGIXPROC __glewXGetFBConfigAttribSGIX = NULL;\nPFNGLXGETFBCONFIGFROMVISUALSGIXPROC __glewXGetFBConfigFromVisualSGIX = NULL;\nPFNGLXGETVISUALFROMFBCONFIGSGIXPROC __glewXGetVisualFromFBConfigSGIX = NULL;\n\nPFNGLXBINDHYPERPIPESGIXPROC __glewXBindHyperpipeSGIX = NULL;\nPFNGLXDESTROYHYPERPIPECONFIGSGIXPROC __glewXDestroyHyperpipeConfigSGIX = NULL;\nPFNGLXHYPERPIPEATTRIBSGIXPROC __glewXHyperpipeAttribSGIX = NULL;\nPFNGLXHYPERPIPECONFIGSGIXPROC __glewXHyperpipeConfigSGIX = NULL;\nPFNGLXQUERYHYPERPIPEATTRIBSGIXPROC __glewXQueryHyperpipeAttribSGIX = NULL;\nPFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC __glewXQueryHyperpipeBestAttribSGIX = NULL;\nPFNGLXQUERYHYPERPIPECONFIGSGIXPROC __glewXQueryHyperpipeConfigSGIX = NULL;\nPFNGLXQUERYHYPERPIPENETWORKSGIXPROC __glewXQueryHyperpipeNetworkSGIX = NULL;\n\nPFNGLXCREATEGLXPBUFFERSGIXPROC __glewXCreateGLXPbufferSGIX = NULL;\nPFNGLXDESTROYGLXPBUFFERSGIXPROC __glewXDestroyGLXPbufferSGIX = NULL;\nPFNGLXGETSELECTEDEVENTSGIXPROC __glewXGetSelectedEventSGIX = NULL;\nPFNGLXQUERYGLXPBUFFERSGIXPROC __glewXQueryGLXPbufferSGIX = NULL;\nPFNGLXSELECTEVENTSGIXPROC __glewXSelectEventSGIX = NULL;\n\nPFNGLXBINDSWAPBARRIERSGIXPROC __glewXBindSwapBarrierSGIX = NULL;\nPFNGLXQUERYMAXSWAPBARRIERSSGIXPROC __glewXQueryMaxSwapBarriersSGIX = NULL;\n\nPFNGLXJOINSWAPGROUPSGIXPROC __glewXJoinSwapGroupSGIX = NULL;\n\nPFNGLXBINDCHANNELTOWINDOWSGIXPROC __glewXBindChannelToWindowSGIX = NULL;\nPFNGLXCHANNELRECTSGIXPROC __glewXChannelRectSGIX = NULL;\nPFNGLXCHANNELRECTSYNCSGIXPROC __glewXChannelRectSyncSGIX = NULL;\nPFNGLXQUERYCHANNELDELTASSGIXPROC __glewXQueryChannelDeltasSGIX = NULL;\nPFNGLXQUERYCHANNELRECTSGIXPROC __glewXQueryChannelRectSGIX = NULL;\n\nPFNGLXCUSHIONSGIPROC __glewXCushionSGI = NULL;\n\nPFNGLXGETCURRENTREADDRAWABLESGIPROC __glewXGetCurrentReadDrawableSGI = NULL;\nPFNGLXMAKECURRENTREADSGIPROC __glewXMakeCurrentReadSGI = NULL;\n\nPFNGLXSWAPINTERVALSGIPROC __glewXSwapIntervalSGI = NULL;\n\nPFNGLXGETVIDEOSYNCSGIPROC __glewXGetVideoSyncSGI = NULL;\nPFNGLXWAITVIDEOSYNCSGIPROC __glewXWaitVideoSyncSGI = NULL;\n\nPFNGLXGETTRANSPARENTINDEXSUNPROC __glewXGetTransparentIndexSUN = NULL;\n\nPFNGLXGETVIDEORESIZESUNPROC __glewXGetVideoResizeSUN = NULL;\nPFNGLXVIDEORESIZESUNPROC __glewXVideoResizeSUN = NULL;\n\n#if !defined(GLEW_MX)\n\nGLboolean __GLXEW_VERSION_1_0 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_1 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_2 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_3 = GL_FALSE;\nGLboolean __GLXEW_VERSION_1_4 = GL_FALSE;\nGLboolean __GLXEW_3DFX_multisample = GL_FALSE;\nGLboolean __GLXEW_ARB_create_context = GL_FALSE;\nGLboolean __GLXEW_ARB_fbconfig_float = GL_FALSE;\nGLboolean __GLXEW_ARB_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLXEW_ARB_get_proc_address = GL_FALSE;\nGLboolean __GLXEW_ARB_multisample = GL_FALSE;\nGLboolean __GLXEW_ATI_pixel_format_float = GL_FALSE;\nGLboolean __GLXEW_ATI_render_texture = GL_FALSE;\nGLboolean __GLXEW_EXT_fbconfig_packed_float = GL_FALSE;\nGLboolean __GLXEW_EXT_framebuffer_sRGB = GL_FALSE;\nGLboolean __GLXEW_EXT_import_context = GL_FALSE;\nGLboolean __GLXEW_EXT_scene_marker = GL_FALSE;\nGLboolean __GLXEW_EXT_texture_from_pixmap = GL_FALSE;\nGLboolean __GLXEW_EXT_visual_info = GL_FALSE;\nGLboolean __GLXEW_EXT_visual_rating = GL_FALSE;\nGLboolean __GLXEW_MESA_agp_offset = GL_FALSE;\nGLboolean __GLXEW_MESA_copy_sub_buffer = GL_FALSE;\nGLboolean __GLXEW_MESA_pixmap_colormap = GL_FALSE;\nGLboolean __GLXEW_MESA_release_buffers = GL_FALSE;\nGLboolean __GLXEW_MESA_set_3dfx_mode = GL_FALSE;\nGLboolean __GLXEW_NV_float_buffer = GL_FALSE;\nGLboolean __GLXEW_NV_present_video = GL_FALSE;\nGLboolean __GLXEW_NV_swap_group = GL_FALSE;\nGLboolean __GLXEW_NV_vertex_array_range = GL_FALSE;\nGLboolean __GLXEW_NV_video_output = GL_FALSE;\nGLboolean __GLXEW_OML_swap_method = GL_FALSE;\n#ifdef GLX_OML_sync_control\nGLboolean __GLXEW_OML_sync_control = GL_FALSE;\n#endif\nGLboolean __GLXEW_SGIS_blended_overlay = GL_FALSE;\nGLboolean __GLXEW_SGIS_color_range = GL_FALSE;\nGLboolean __GLXEW_SGIS_multisample = GL_FALSE;\nGLboolean __GLXEW_SGIS_shared_multisample = GL_FALSE;\nGLboolean __GLXEW_SGIX_fbconfig = GL_FALSE;\nGLboolean __GLXEW_SGIX_hyperpipe = GL_FALSE;\nGLboolean __GLXEW_SGIX_pbuffer = GL_FALSE;\nGLboolean __GLXEW_SGIX_swap_barrier = GL_FALSE;\nGLboolean __GLXEW_SGIX_swap_group = GL_FALSE;\nGLboolean __GLXEW_SGIX_video_resize = GL_FALSE;\nGLboolean __GLXEW_SGIX_visual_select_group = GL_FALSE;\nGLboolean __GLXEW_SGI_cushion = GL_FALSE;\nGLboolean __GLXEW_SGI_make_current_read = GL_FALSE;\nGLboolean __GLXEW_SGI_swap_control = GL_FALSE;\nGLboolean __GLXEW_SGI_video_sync = GL_FALSE;\nGLboolean __GLXEW_SUN_get_transparent_index = GL_FALSE;\nGLboolean __GLXEW_SUN_video_resize = GL_FALSE;\n\n#endif /* !GLEW_MX */\n\n#ifdef GLX_VERSION_1_2\n\nstatic GLboolean _glewInit_GLX_VERSION_1_2 (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetCurrentDisplay = (PFNGLXGETCURRENTDISPLAYPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentDisplay\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_VERSION_1_2 */\n\n#ifdef GLX_VERSION_1_3\n\nstatic GLboolean _glewInit_GLX_VERSION_1_3 (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXChooseFBConfig = (PFNGLXCHOOSEFBCONFIGPROC)glewGetProcAddress((const GLubyte*)\"glXChooseFBConfig\")) == NULL) || r;\n  r = ((glXCreateNewContext = (PFNGLXCREATENEWCONTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXCreateNewContext\")) == NULL) || r;\n  r = ((glXCreatePbuffer = (PFNGLXCREATEPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glXCreatePbuffer\")) == NULL) || r;\n  r = ((glXCreatePixmap = (PFNGLXCREATEPIXMAPPROC)glewGetProcAddress((const GLubyte*)\"glXCreatePixmap\")) == NULL) || r;\n  r = ((glXCreateWindow = (PFNGLXCREATEWINDOWPROC)glewGetProcAddress((const GLubyte*)\"glXCreateWindow\")) == NULL) || r;\n  r = ((glXDestroyPbuffer = (PFNGLXDESTROYPBUFFERPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyPbuffer\")) == NULL) || r;\n  r = ((glXDestroyPixmap = (PFNGLXDESTROYPIXMAPPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyPixmap\")) == NULL) || r;\n  r = ((glXDestroyWindow = (PFNGLXDESTROYWINDOWPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyWindow\")) == NULL) || r;\n  r = ((glXGetCurrentReadDrawable = (PFNGLXGETCURRENTREADDRAWABLEPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentReadDrawable\")) == NULL) || r;\n  r = ((glXGetFBConfigAttrib = (PFNGLXGETFBCONFIGATTRIBPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigAttrib\")) == NULL) || r;\n  r = ((glXGetFBConfigs = (PFNGLXGETFBCONFIGSPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigs\")) == NULL) || r;\n  r = ((glXGetSelectedEvent = (PFNGLXGETSELECTEDEVENTPROC)glewGetProcAddress((const GLubyte*)\"glXGetSelectedEvent\")) == NULL) || r;\n  r = ((glXGetVisualFromFBConfig = (PFNGLXGETVISUALFROMFBCONFIGPROC)glewGetProcAddress((const GLubyte*)\"glXGetVisualFromFBConfig\")) == NULL) || r;\n  r = ((glXMakeContextCurrent = (PFNGLXMAKECONTEXTCURRENTPROC)glewGetProcAddress((const GLubyte*)\"glXMakeContextCurrent\")) == NULL) || r;\n  r = ((glXQueryContext = (PFNGLXQUERYCONTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXQueryContext\")) == NULL) || r;\n  r = ((glXQueryDrawable = (PFNGLXQUERYDRAWABLEPROC)glewGetProcAddress((const GLubyte*)\"glXQueryDrawable\")) == NULL) || r;\n  r = ((glXSelectEvent = (PFNGLXSELECTEVENTPROC)glewGetProcAddress((const GLubyte*)\"glXSelectEvent\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_VERSION_1_3 */\n\n#ifdef GLX_VERSION_1_4\n\n#endif /* GLX_VERSION_1_4 */\n\n#ifdef GLX_3DFX_multisample\n\n#endif /* GLX_3DFX_multisample */\n\n#ifdef GLX_ARB_create_context\n\nstatic GLboolean _glewInit_GLX_ARB_create_context (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glewGetProcAddress((const GLubyte*)\"glXCreateContextAttribsARB\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_ARB_create_context */\n\n#ifdef GLX_ARB_fbconfig_float\n\n#endif /* GLX_ARB_fbconfig_float */\n\n#ifdef GLX_ARB_framebuffer_sRGB\n\n#endif /* GLX_ARB_framebuffer_sRGB */\n\n#ifdef GLX_ARB_get_proc_address\n\n#endif /* GLX_ARB_get_proc_address */\n\n#ifdef GLX_ARB_multisample\n\n#endif /* GLX_ARB_multisample */\n\n#ifdef GLX_ATI_pixel_format_float\n\n#endif /* GLX_ATI_pixel_format_float */\n\n#ifdef GLX_ATI_render_texture\n\nstatic GLboolean _glewInit_GLX_ATI_render_texture (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindTexImageATI = (PFNGLXBINDTEXIMAGEATIPROC)glewGetProcAddress((const GLubyte*)\"glXBindTexImageATI\")) == NULL) || r;\n  r = ((glXDrawableAttribATI = (PFNGLXDRAWABLEATTRIBATIPROC)glewGetProcAddress((const GLubyte*)\"glXDrawableAttribATI\")) == NULL) || r;\n  r = ((glXReleaseTexImageATI = (PFNGLXRELEASETEXIMAGEATIPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseTexImageATI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_ATI_render_texture */\n\n#ifdef GLX_EXT_fbconfig_packed_float\n\n#endif /* GLX_EXT_fbconfig_packed_float */\n\n#ifdef GLX_EXT_framebuffer_sRGB\n\n#endif /* GLX_EXT_framebuffer_sRGB */\n\n#ifdef GLX_EXT_import_context\n\nstatic GLboolean _glewInit_GLX_EXT_import_context (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXFreeContextEXT = (PFNGLXFREECONTEXTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXFreeContextEXT\")) == NULL) || r;\n  r = ((glXGetContextIDEXT = (PFNGLXGETCONTEXTIDEXTPROC)glewGetProcAddress((const GLubyte*)\"glXGetContextIDEXT\")) == NULL) || r;\n  r = ((glXImportContextEXT = (PFNGLXIMPORTCONTEXTEXTPROC)glewGetProcAddress((const GLubyte*)\"glXImportContextEXT\")) == NULL) || r;\n  r = ((glXQueryContextInfoEXT = (PFNGLXQUERYCONTEXTINFOEXTPROC)glewGetProcAddress((const GLubyte*)\"glXQueryContextInfoEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_EXT_import_context */\n\n#ifdef GLX_EXT_scene_marker\n\n#endif /* GLX_EXT_scene_marker */\n\n#ifdef GLX_EXT_texture_from_pixmap\n\nstatic GLboolean _glewInit_GLX_EXT_texture_from_pixmap (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindTexImageEXT = (PFNGLXBINDTEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glXBindTexImageEXT\")) == NULL) || r;\n  r = ((glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseTexImageEXT\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_EXT_texture_from_pixmap */\n\n#ifdef GLX_EXT_visual_info\n\n#endif /* GLX_EXT_visual_info */\n\n#ifdef GLX_EXT_visual_rating\n\n#endif /* GLX_EXT_visual_rating */\n\n#ifdef GLX_MESA_agp_offset\n\nstatic GLboolean _glewInit_GLX_MESA_agp_offset (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetAGPOffsetMESA = (PFNGLXGETAGPOFFSETMESAPROC)glewGetProcAddress((const GLubyte*)\"glXGetAGPOffsetMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_agp_offset */\n\n#ifdef GLX_MESA_copy_sub_buffer\n\nstatic GLboolean _glewInit_GLX_MESA_copy_sub_buffer (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCopySubBufferMESA = (PFNGLXCOPYSUBBUFFERMESAPROC)glewGetProcAddress((const GLubyte*)\"glXCopySubBufferMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_copy_sub_buffer */\n\n#ifdef GLX_MESA_pixmap_colormap\n\nstatic GLboolean _glewInit_GLX_MESA_pixmap_colormap (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateGLXPixmapMESA = (PFNGLXCREATEGLXPIXMAPMESAPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPixmapMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_pixmap_colormap */\n\n#ifdef GLX_MESA_release_buffers\n\nstatic GLboolean _glewInit_GLX_MESA_release_buffers (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXReleaseBuffersMESA = (PFNGLXRELEASEBUFFERSMESAPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseBuffersMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_release_buffers */\n\n#ifdef GLX_MESA_set_3dfx_mode\n\nstatic GLboolean _glewInit_GLX_MESA_set_3dfx_mode (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXSet3DfxModeMESA = (PFNGLXSET3DFXMODEMESAPROC)glewGetProcAddress((const GLubyte*)\"glXSet3DfxModeMESA\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_MESA_set_3dfx_mode */\n\n#ifdef GLX_NV_float_buffer\n\n#endif /* GLX_NV_float_buffer */\n\n#ifdef GLX_NV_present_video\n\nstatic GLboolean _glewInit_GLX_NV_present_video (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindVideoDeviceNV = (PFNGLXBINDVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXBindVideoDeviceNV\")) == NULL) || r;\n  r = ((glXEnumerateVideoDevicesNV = (PFNGLXENUMERATEVIDEODEVICESNVPROC)glewGetProcAddress((const GLubyte*)\"glXEnumerateVideoDevicesNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_present_video */\n\n#ifdef GLX_NV_swap_group\n\nstatic GLboolean _glewInit_GLX_NV_swap_group (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindSwapBarrierNV = (PFNGLXBINDSWAPBARRIERNVPROC)glewGetProcAddress((const GLubyte*)\"glXBindSwapBarrierNV\")) == NULL) || r;\n  r = ((glXJoinSwapGroupNV = (PFNGLXJOINSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"glXJoinSwapGroupNV\")) == NULL) || r;\n  r = ((glXQueryFrameCountNV = (PFNGLXQUERYFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"glXQueryFrameCountNV\")) == NULL) || r;\n  r = ((glXQueryMaxSwapGroupsNV = (PFNGLXQUERYMAXSWAPGROUPSNVPROC)glewGetProcAddress((const GLubyte*)\"glXQueryMaxSwapGroupsNV\")) == NULL) || r;\n  r = ((glXQuerySwapGroupNV = (PFNGLXQUERYSWAPGROUPNVPROC)glewGetProcAddress((const GLubyte*)\"glXQuerySwapGroupNV\")) == NULL) || r;\n  r = ((glXResetFrameCountNV = (PFNGLXRESETFRAMECOUNTNVPROC)glewGetProcAddress((const GLubyte*)\"glXResetFrameCountNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_swap_group */\n\n#ifdef GLX_NV_vertex_array_range\n\nstatic GLboolean _glewInit_GLX_NV_vertex_array_range (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXAllocateMemoryNV = (PFNGLXALLOCATEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"glXAllocateMemoryNV\")) == NULL) || r;\n  r = ((glXFreeMemoryNV = (PFNGLXFREEMEMORYNVPROC)glewGetProcAddress((const GLubyte*)\"glXFreeMemoryNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_vertex_array_range */\n\n#ifdef GLX_NV_video_output\n\nstatic GLboolean _glewInit_GLX_NV_video_output (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindVideoImageNV = (PFNGLXBINDVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"glXBindVideoImageNV\")) == NULL) || r;\n  r = ((glXGetVideoDeviceNV = (PFNGLXGETVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoDeviceNV\")) == NULL) || r;\n  r = ((glXGetVideoInfoNV = (PFNGLXGETVIDEOINFONVPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoInfoNV\")) == NULL) || r;\n  r = ((glXReleaseVideoDeviceNV = (PFNGLXRELEASEVIDEODEVICENVPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseVideoDeviceNV\")) == NULL) || r;\n  r = ((glXReleaseVideoImageNV = (PFNGLXRELEASEVIDEOIMAGENVPROC)glewGetProcAddress((const GLubyte*)\"glXReleaseVideoImageNV\")) == NULL) || r;\n  r = ((glXSendPbufferToVideoNV = (PFNGLXSENDPBUFFERTOVIDEONVPROC)glewGetProcAddress((const GLubyte*)\"glXSendPbufferToVideoNV\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_NV_video_output */\n\n#ifdef GLX_OML_swap_method\n\n#endif /* GLX_OML_swap_method */\n\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n\nstatic GLboolean _glewInit_GLX_OML_sync_control (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetMscRateOML = (PFNGLXGETMSCRATEOMLPROC)glewGetProcAddress((const GLubyte*)\"glXGetMscRateOML\")) == NULL) || r;\n  r = ((glXGetSyncValuesOML = (PFNGLXGETSYNCVALUESOMLPROC)glewGetProcAddress((const GLubyte*)\"glXGetSyncValuesOML\")) == NULL) || r;\n  r = ((glXSwapBuffersMscOML = (PFNGLXSWAPBUFFERSMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXSwapBuffersMscOML\")) == NULL) || r;\n  r = ((glXWaitForMscOML = (PFNGLXWAITFORMSCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXWaitForMscOML\")) == NULL) || r;\n  r = ((glXWaitForSbcOML = (PFNGLXWAITFORSBCOMLPROC)glewGetProcAddress((const GLubyte*)\"glXWaitForSbcOML\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_OML_sync_control */\n\n#ifdef GLX_SGIS_blended_overlay\n\n#endif /* GLX_SGIS_blended_overlay */\n\n#ifdef GLX_SGIS_color_range\n\n#endif /* GLX_SGIS_color_range */\n\n#ifdef GLX_SGIS_multisample\n\n#endif /* GLX_SGIS_multisample */\n\n#ifdef GLX_SGIS_shared_multisample\n\n#endif /* GLX_SGIS_shared_multisample */\n\n#ifdef GLX_SGIX_fbconfig\n\nstatic GLboolean _glewInit_GLX_SGIX_fbconfig (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXChooseFBConfigSGIX = (PFNGLXCHOOSEFBCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChooseFBConfigSGIX\")) == NULL) || r;\n  r = ((glXCreateContextWithConfigSGIX = (PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateContextWithConfigSGIX\")) == NULL) || r;\n  r = ((glXCreateGLXPixmapWithConfigSGIX = (PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPixmapWithConfigSGIX\")) == NULL) || r;\n  r = ((glXGetFBConfigAttribSGIX = (PFNGLXGETFBCONFIGATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigAttribSGIX\")) == NULL) || r;\n  r = ((glXGetFBConfigFromVisualSGIX = (PFNGLXGETFBCONFIGFROMVISUALSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetFBConfigFromVisualSGIX\")) == NULL) || r;\n  r = ((glXGetVisualFromFBConfigSGIX = (PFNGLXGETVISUALFROMFBCONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetVisualFromFBConfigSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_fbconfig */\n\n#ifdef GLX_SGIX_hyperpipe\n\nstatic GLboolean _glewInit_GLX_SGIX_hyperpipe (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindHyperpipeSGIX = (PFNGLXBINDHYPERPIPESGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindHyperpipeSGIX\")) == NULL) || r;\n  r = ((glXDestroyHyperpipeConfigSGIX = (PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXHyperpipeAttribSGIX = (PFNGLXHYPERPIPEATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXHyperpipeAttribSGIX\")) == NULL) || r;\n  r = ((glXHyperpipeConfigSGIX = (PFNGLXHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeAttribSGIX = (PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeAttribSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeBestAttribSGIX = (PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeBestAttribSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeConfigSGIX = (PFNGLXQUERYHYPERPIPECONFIGSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeConfigSGIX\")) == NULL) || r;\n  r = ((glXQueryHyperpipeNetworkSGIX = (PFNGLXQUERYHYPERPIPENETWORKSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryHyperpipeNetworkSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_hyperpipe */\n\n#ifdef GLX_SGIX_pbuffer\n\nstatic GLboolean _glewInit_GLX_SGIX_pbuffer (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCreateGLXPbufferSGIX = (PFNGLXCREATEGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXCreateGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXDestroyGLXPbufferSGIX = (PFNGLXDESTROYGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXDestroyGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXGetSelectedEventSGIX = (PFNGLXGETSELECTEDEVENTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXGetSelectedEventSGIX\")) == NULL) || r;\n  r = ((glXQueryGLXPbufferSGIX = (PFNGLXQUERYGLXPBUFFERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryGLXPbufferSGIX\")) == NULL) || r;\n  r = ((glXSelectEventSGIX = (PFNGLXSELECTEVENTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXSelectEventSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_pbuffer */\n\n#ifdef GLX_SGIX_swap_barrier\n\nstatic GLboolean _glewInit_GLX_SGIX_swap_barrier (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindSwapBarrierSGIX = (PFNGLXBINDSWAPBARRIERSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindSwapBarrierSGIX\")) == NULL) || r;\n  r = ((glXQueryMaxSwapBarriersSGIX = (PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryMaxSwapBarriersSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_swap_barrier */\n\n#ifdef GLX_SGIX_swap_group\n\nstatic GLboolean _glewInit_GLX_SGIX_swap_group (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXJoinSwapGroupSGIX = (PFNGLXJOINSWAPGROUPSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXJoinSwapGroupSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_swap_group */\n\n#ifdef GLX_SGIX_video_resize\n\nstatic GLboolean _glewInit_GLX_SGIX_video_resize (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXBindChannelToWindowSGIX = (PFNGLXBINDCHANNELTOWINDOWSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXBindChannelToWindowSGIX\")) == NULL) || r;\n  r = ((glXChannelRectSGIX = (PFNGLXCHANNELRECTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChannelRectSGIX\")) == NULL) || r;\n  r = ((glXChannelRectSyncSGIX = (PFNGLXCHANNELRECTSYNCSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXChannelRectSyncSGIX\")) == NULL) || r;\n  r = ((glXQueryChannelDeltasSGIX = (PFNGLXQUERYCHANNELDELTASSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryChannelDeltasSGIX\")) == NULL) || r;\n  r = ((glXQueryChannelRectSGIX = (PFNGLXQUERYCHANNELRECTSGIXPROC)glewGetProcAddress((const GLubyte*)\"glXQueryChannelRectSGIX\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGIX_video_resize */\n\n#ifdef GLX_SGIX_visual_select_group\n\n#endif /* GLX_SGIX_visual_select_group */\n\n#ifdef GLX_SGI_cushion\n\nstatic GLboolean _glewInit_GLX_SGI_cushion (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXCushionSGI = (PFNGLXCUSHIONSGIPROC)glewGetProcAddress((const GLubyte*)\"glXCushionSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_cushion */\n\n#ifdef GLX_SGI_make_current_read\n\nstatic GLboolean _glewInit_GLX_SGI_make_current_read (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetCurrentReadDrawableSGI = (PFNGLXGETCURRENTREADDRAWABLESGIPROC)glewGetProcAddress((const GLubyte*)\"glXGetCurrentReadDrawableSGI\")) == NULL) || r;\n  r = ((glXMakeCurrentReadSGI = (PFNGLXMAKECURRENTREADSGIPROC)glewGetProcAddress((const GLubyte*)\"glXMakeCurrentReadSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_make_current_read */\n\n#ifdef GLX_SGI_swap_control\n\nstatic GLboolean _glewInit_GLX_SGI_swap_control (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXSwapIntervalSGI = (PFNGLXSWAPINTERVALSGIPROC)glewGetProcAddress((const GLubyte*)\"glXSwapIntervalSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_swap_control */\n\n#ifdef GLX_SGI_video_sync\n\nstatic GLboolean _glewInit_GLX_SGI_video_sync (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetVideoSyncSGI = (PFNGLXGETVIDEOSYNCSGIPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoSyncSGI\")) == NULL) || r;\n  r = ((glXWaitVideoSyncSGI = (PFNGLXWAITVIDEOSYNCSGIPROC)glewGetProcAddress((const GLubyte*)\"glXWaitVideoSyncSGI\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SGI_video_sync */\n\n#ifdef GLX_SUN_get_transparent_index\n\nstatic GLboolean _glewInit_GLX_SUN_get_transparent_index (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetTransparentIndexSUN = (PFNGLXGETTRANSPARENTINDEXSUNPROC)glewGetProcAddress((const GLubyte*)\"glXGetTransparentIndexSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SUN_get_transparent_index */\n\n#ifdef GLX_SUN_video_resize\n\nstatic GLboolean _glewInit_GLX_SUN_video_resize (GLXEW_CONTEXT_ARG_DEF_INIT)\n{\n  GLboolean r = GL_FALSE;\n\n  r = ((glXGetVideoResizeSUN = (PFNGLXGETVIDEORESIZESUNPROC)glewGetProcAddress((const GLubyte*)\"glXGetVideoResizeSUN\")) == NULL) || r;\n  r = ((glXVideoResizeSUN = (PFNGLXVIDEORESIZESUNPROC)glewGetProcAddress((const GLubyte*)\"glXVideoResizeSUN\")) == NULL) || r;\n\n  return r;\n}\n\n#endif /* GLX_SUN_video_resize */\n\n/* ------------------------------------------------------------------------ */\n\nGLboolean glxewGetExtension (const char* name)\n{\n  GLubyte* p;\n  GLubyte* end;\n  GLuint len = _glewStrLen((const GLubyte*)name);\n/*   if (glXQueryExtensionsString == NULL || glXGetCurrentDisplay == NULL) return GL_FALSE; */\n/*   p = (GLubyte*)glXQueryExtensionsString(glXGetCurrentDisplay(), DefaultScreen(glXGetCurrentDisplay())); */\n  if (glXGetCurrentDisplay == NULL) return GL_FALSE;\n  p = (GLubyte*)glXGetClientString(glXGetCurrentDisplay(), GLX_EXTENSIONS);\n  if (0 == p) return GL_FALSE;\n  end = p + _glewStrLen(p);\n  while (p < end)\n  {\n    GLuint n = _glewStrCLen(p, ' ');\n    if (len == n && _glewStrSame((const GLubyte*)name, p, n)) return GL_TRUE;\n    p += n+1;\n  }\n  return GL_FALSE;\n}\n\nGLenum glxewContextInit (GLXEW_CONTEXT_ARG_DEF_LIST)\n{\n  int major, minor;\n  /* initialize core GLX 1.2 */\n  if (_glewInit_GLX_VERSION_1_2(GLEW_CONTEXT_ARG_VAR_INIT)) return GLEW_ERROR_GLX_VERSION_11_ONLY;\n  /* initialize flags */\n  CONST_CAST(GLXEW_VERSION_1_0) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_1) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_2) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_3) = GL_TRUE;\n  CONST_CAST(GLXEW_VERSION_1_4) = GL_TRUE;\n  /* query GLX version */\n  glXQueryVersion(glXGetCurrentDisplay(), &major, &minor);\n  if (major == 1 && minor <= 3)\n  {\n    switch (minor)\n    {\n      case 3:\n      CONST_CAST(GLXEW_VERSION_1_4) = GL_FALSE;\n      break;\n      case 2:\n      CONST_CAST(GLXEW_VERSION_1_4) = GL_FALSE;\n      CONST_CAST(GLXEW_VERSION_1_3) = GL_FALSE;\n      break;\n      default:\n      return GLEW_ERROR_GLX_VERSION_11_ONLY;\n      break;\n    }\n  }\n  /* initialize extensions */\n#ifdef GLX_VERSION_1_3\n  if (glewExperimental || GLXEW_VERSION_1_3) CONST_CAST(GLXEW_VERSION_1_3) = !_glewInit_GLX_VERSION_1_3(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_VERSION_1_3 */\n#ifdef GLX_3DFX_multisample\n  CONST_CAST(GLXEW_3DFX_multisample) = glxewGetExtension(\"GLX_3DFX_multisample\");\n#endif /* GLX_3DFX_multisample */\n#ifdef GLX_ARB_create_context\n  CONST_CAST(GLXEW_ARB_create_context) = glxewGetExtension(\"GLX_ARB_create_context\");\n  if (glewExperimental || GLXEW_ARB_create_context) CONST_CAST(GLXEW_ARB_create_context) = !_glewInit_GLX_ARB_create_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_ARB_create_context */\n#ifdef GLX_ARB_fbconfig_float\n  CONST_CAST(GLXEW_ARB_fbconfig_float) = glxewGetExtension(\"GLX_ARB_fbconfig_float\");\n#endif /* GLX_ARB_fbconfig_float */\n#ifdef GLX_ARB_framebuffer_sRGB\n  CONST_CAST(GLXEW_ARB_framebuffer_sRGB) = glxewGetExtension(\"GLX_ARB_framebuffer_sRGB\");\n#endif /* GLX_ARB_framebuffer_sRGB */\n#ifdef GLX_ARB_get_proc_address\n  CONST_CAST(GLXEW_ARB_get_proc_address) = glxewGetExtension(\"GLX_ARB_get_proc_address\");\n#endif /* GLX_ARB_get_proc_address */\n#ifdef GLX_ARB_multisample\n  CONST_CAST(GLXEW_ARB_multisample) = glxewGetExtension(\"GLX_ARB_multisample\");\n#endif /* GLX_ARB_multisample */\n#ifdef GLX_ATI_pixel_format_float\n  CONST_CAST(GLXEW_ATI_pixel_format_float) = glxewGetExtension(\"GLX_ATI_pixel_format_float\");\n#endif /* GLX_ATI_pixel_format_float */\n#ifdef GLX_ATI_render_texture\n  CONST_CAST(GLXEW_ATI_render_texture) = glxewGetExtension(\"GLX_ATI_render_texture\");\n  if (glewExperimental || GLXEW_ATI_render_texture) CONST_CAST(GLXEW_ATI_render_texture) = !_glewInit_GLX_ATI_render_texture(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_ATI_render_texture */\n#ifdef GLX_EXT_fbconfig_packed_float\n  CONST_CAST(GLXEW_EXT_fbconfig_packed_float) = glxewGetExtension(\"GLX_EXT_fbconfig_packed_float\");\n#endif /* GLX_EXT_fbconfig_packed_float */\n#ifdef GLX_EXT_framebuffer_sRGB\n  CONST_CAST(GLXEW_EXT_framebuffer_sRGB) = glxewGetExtension(\"GLX_EXT_framebuffer_sRGB\");\n#endif /* GLX_EXT_framebuffer_sRGB */\n#ifdef GLX_EXT_import_context\n  CONST_CAST(GLXEW_EXT_import_context) = glxewGetExtension(\"GLX_EXT_import_context\");\n  if (glewExperimental || GLXEW_EXT_import_context) CONST_CAST(GLXEW_EXT_import_context) = !_glewInit_GLX_EXT_import_context(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_EXT_import_context */\n#ifdef GLX_EXT_scene_marker\n  CONST_CAST(GLXEW_EXT_scene_marker) = glxewGetExtension(\"GLX_EXT_scene_marker\");\n#endif /* GLX_EXT_scene_marker */\n#ifdef GLX_EXT_texture_from_pixmap\n  CONST_CAST(GLXEW_EXT_texture_from_pixmap) = glxewGetExtension(\"GLX_EXT_texture_from_pixmap\");\n  if (glewExperimental || GLXEW_EXT_texture_from_pixmap) CONST_CAST(GLXEW_EXT_texture_from_pixmap) = !_glewInit_GLX_EXT_texture_from_pixmap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_EXT_texture_from_pixmap */\n#ifdef GLX_EXT_visual_info\n  CONST_CAST(GLXEW_EXT_visual_info) = glxewGetExtension(\"GLX_EXT_visual_info\");\n#endif /* GLX_EXT_visual_info */\n#ifdef GLX_EXT_visual_rating\n  CONST_CAST(GLXEW_EXT_visual_rating) = glxewGetExtension(\"GLX_EXT_visual_rating\");\n#endif /* GLX_EXT_visual_rating */\n#ifdef GLX_MESA_agp_offset\n  CONST_CAST(GLXEW_MESA_agp_offset) = glxewGetExtension(\"GLX_MESA_agp_offset\");\n  if (glewExperimental || GLXEW_MESA_agp_offset) CONST_CAST(GLXEW_MESA_agp_offset) = !_glewInit_GLX_MESA_agp_offset(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_agp_offset */\n#ifdef GLX_MESA_copy_sub_buffer\n  CONST_CAST(GLXEW_MESA_copy_sub_buffer) = glxewGetExtension(\"GLX_MESA_copy_sub_buffer\");\n  if (glewExperimental || GLXEW_MESA_copy_sub_buffer) CONST_CAST(GLXEW_MESA_copy_sub_buffer) = !_glewInit_GLX_MESA_copy_sub_buffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_copy_sub_buffer */\n#ifdef GLX_MESA_pixmap_colormap\n  CONST_CAST(GLXEW_MESA_pixmap_colormap) = glxewGetExtension(\"GLX_MESA_pixmap_colormap\");\n  if (glewExperimental || GLXEW_MESA_pixmap_colormap) CONST_CAST(GLXEW_MESA_pixmap_colormap) = !_glewInit_GLX_MESA_pixmap_colormap(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_pixmap_colormap */\n#ifdef GLX_MESA_release_buffers\n  CONST_CAST(GLXEW_MESA_release_buffers) = glxewGetExtension(\"GLX_MESA_release_buffers\");\n  if (glewExperimental || GLXEW_MESA_release_buffers) CONST_CAST(GLXEW_MESA_release_buffers) = !_glewInit_GLX_MESA_release_buffers(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_release_buffers */\n#ifdef GLX_MESA_set_3dfx_mode\n  CONST_CAST(GLXEW_MESA_set_3dfx_mode) = glxewGetExtension(\"GLX_MESA_set_3dfx_mode\");\n  if (glewExperimental || GLXEW_MESA_set_3dfx_mode) CONST_CAST(GLXEW_MESA_set_3dfx_mode) = !_glewInit_GLX_MESA_set_3dfx_mode(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_MESA_set_3dfx_mode */\n#ifdef GLX_NV_float_buffer\n  CONST_CAST(GLXEW_NV_float_buffer) = glxewGetExtension(\"GLX_NV_float_buffer\");\n#endif /* GLX_NV_float_buffer */\n#ifdef GLX_NV_present_video\n  CONST_CAST(GLXEW_NV_present_video) = glxewGetExtension(\"GLX_NV_present_video\");\n  if (glewExperimental || GLXEW_NV_present_video) CONST_CAST(GLXEW_NV_present_video) = !_glewInit_GLX_NV_present_video(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_present_video */\n#ifdef GLX_NV_swap_group\n  CONST_CAST(GLXEW_NV_swap_group) = glxewGetExtension(\"GLX_NV_swap_group\");\n  if (glewExperimental || GLXEW_NV_swap_group) CONST_CAST(GLXEW_NV_swap_group) = !_glewInit_GLX_NV_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_swap_group */\n#ifdef GLX_NV_vertex_array_range\n  CONST_CAST(GLXEW_NV_vertex_array_range) = glxewGetExtension(\"GLX_NV_vertex_array_range\");\n  if (glewExperimental || GLXEW_NV_vertex_array_range) CONST_CAST(GLXEW_NV_vertex_array_range) = !_glewInit_GLX_NV_vertex_array_range(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_vertex_array_range */\n#ifdef GLX_NV_video_output\n  CONST_CAST(GLXEW_NV_video_output) = glxewGetExtension(\"GLX_NV_video_output\");\n  if (glewExperimental || GLXEW_NV_video_output) CONST_CAST(GLXEW_NV_video_output) = !_glewInit_GLX_NV_video_output(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_NV_video_output */\n#ifdef GLX_OML_swap_method\n  CONST_CAST(GLXEW_OML_swap_method) = glxewGetExtension(\"GLX_OML_swap_method\");\n#endif /* GLX_OML_swap_method */\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n  CONST_CAST(GLXEW_OML_sync_control) = glxewGetExtension(\"GLX_OML_sync_control\");\n  if (glewExperimental || GLXEW_OML_sync_control) CONST_CAST(GLXEW_OML_sync_control) = !_glewInit_GLX_OML_sync_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_OML_sync_control */\n#ifdef GLX_SGIS_blended_overlay\n  CONST_CAST(GLXEW_SGIS_blended_overlay) = glxewGetExtension(\"GLX_SGIS_blended_overlay\");\n#endif /* GLX_SGIS_blended_overlay */\n#ifdef GLX_SGIS_color_range\n  CONST_CAST(GLXEW_SGIS_color_range) = glxewGetExtension(\"GLX_SGIS_color_range\");\n#endif /* GLX_SGIS_color_range */\n#ifdef GLX_SGIS_multisample\n  CONST_CAST(GLXEW_SGIS_multisample) = glxewGetExtension(\"GLX_SGIS_multisample\");\n#endif /* GLX_SGIS_multisample */\n#ifdef GLX_SGIS_shared_multisample\n  CONST_CAST(GLXEW_SGIS_shared_multisample) = glxewGetExtension(\"GLX_SGIS_shared_multisample\");\n#endif /* GLX_SGIS_shared_multisample */\n#ifdef GLX_SGIX_fbconfig\n  CONST_CAST(GLXEW_SGIX_fbconfig) = glxewGetExtension(\"GLX_SGIX_fbconfig\");\n  if (glewExperimental || GLXEW_SGIX_fbconfig) CONST_CAST(GLXEW_SGIX_fbconfig) = !_glewInit_GLX_SGIX_fbconfig(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_fbconfig */\n#ifdef GLX_SGIX_hyperpipe\n  CONST_CAST(GLXEW_SGIX_hyperpipe) = glxewGetExtension(\"GLX_SGIX_hyperpipe\");\n  if (glewExperimental || GLXEW_SGIX_hyperpipe) CONST_CAST(GLXEW_SGIX_hyperpipe) = !_glewInit_GLX_SGIX_hyperpipe(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_hyperpipe */\n#ifdef GLX_SGIX_pbuffer\n  CONST_CAST(GLXEW_SGIX_pbuffer) = glxewGetExtension(\"GLX_SGIX_pbuffer\");\n  if (glewExperimental || GLXEW_SGIX_pbuffer) CONST_CAST(GLXEW_SGIX_pbuffer) = !_glewInit_GLX_SGIX_pbuffer(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_pbuffer */\n#ifdef GLX_SGIX_swap_barrier\n  CONST_CAST(GLXEW_SGIX_swap_barrier) = glxewGetExtension(\"GLX_SGIX_swap_barrier\");\n  if (glewExperimental || GLXEW_SGIX_swap_barrier) CONST_CAST(GLXEW_SGIX_swap_barrier) = !_glewInit_GLX_SGIX_swap_barrier(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_swap_barrier */\n#ifdef GLX_SGIX_swap_group\n  CONST_CAST(GLXEW_SGIX_swap_group) = glxewGetExtension(\"GLX_SGIX_swap_group\");\n  if (glewExperimental || GLXEW_SGIX_swap_group) CONST_CAST(GLXEW_SGIX_swap_group) = !_glewInit_GLX_SGIX_swap_group(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_swap_group */\n#ifdef GLX_SGIX_video_resize\n  CONST_CAST(GLXEW_SGIX_video_resize) = glxewGetExtension(\"GLX_SGIX_video_resize\");\n  if (glewExperimental || GLXEW_SGIX_video_resize) CONST_CAST(GLXEW_SGIX_video_resize) = !_glewInit_GLX_SGIX_video_resize(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGIX_video_resize */\n#ifdef GLX_SGIX_visual_select_group\n  CONST_CAST(GLXEW_SGIX_visual_select_group) = glxewGetExtension(\"GLX_SGIX_visual_select_group\");\n#endif /* GLX_SGIX_visual_select_group */\n#ifdef GLX_SGI_cushion\n  CONST_CAST(GLXEW_SGI_cushion) = glxewGetExtension(\"GLX_SGI_cushion\");\n  if (glewExperimental || GLXEW_SGI_cushion) CONST_CAST(GLXEW_SGI_cushion) = !_glewInit_GLX_SGI_cushion(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_cushion */\n#ifdef GLX_SGI_make_current_read\n  CONST_CAST(GLXEW_SGI_make_current_read) = glxewGetExtension(\"GLX_SGI_make_current_read\");\n  if (glewExperimental || GLXEW_SGI_make_current_read) CONST_CAST(GLXEW_SGI_make_current_read) = !_glewInit_GLX_SGI_make_current_read(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_make_current_read */\n#ifdef GLX_SGI_swap_control\n  CONST_CAST(GLXEW_SGI_swap_control) = glxewGetExtension(\"GLX_SGI_swap_control\");\n  if (glewExperimental || GLXEW_SGI_swap_control) CONST_CAST(GLXEW_SGI_swap_control) = !_glewInit_GLX_SGI_swap_control(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_swap_control */\n#ifdef GLX_SGI_video_sync\n  CONST_CAST(GLXEW_SGI_video_sync) = glxewGetExtension(\"GLX_SGI_video_sync\");\n  if (glewExperimental || GLXEW_SGI_video_sync) CONST_CAST(GLXEW_SGI_video_sync) = !_glewInit_GLX_SGI_video_sync(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SGI_video_sync */\n#ifdef GLX_SUN_get_transparent_index\n  CONST_CAST(GLXEW_SUN_get_transparent_index) = glxewGetExtension(\"GLX_SUN_get_transparent_index\");\n  if (glewExperimental || GLXEW_SUN_get_transparent_index) CONST_CAST(GLXEW_SUN_get_transparent_index) = !_glewInit_GLX_SUN_get_transparent_index(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SUN_get_transparent_index */\n#ifdef GLX_SUN_video_resize\n  CONST_CAST(GLXEW_SUN_video_resize) = glxewGetExtension(\"GLX_SUN_video_resize\");\n  if (glewExperimental || GLXEW_SUN_video_resize) CONST_CAST(GLXEW_SUN_video_resize) = !_glewInit_GLX_SUN_video_resize(GLEW_CONTEXT_ARG_VAR_INIT);\n#endif /* GLX_SUN_video_resize */\n\n  return GLEW_OK;\n}\n\n#endif /* !__APPLE__ || GLEW_APPLE_GLX */\n\n/* ------------------------------------------------------------------------ */\n\nconst GLubyte* glewGetErrorString (GLenum error)\n{\n  static const GLubyte* _glewErrorString[] =\n  {\n    (const GLubyte*)\"No error\",\n    (const GLubyte*)\"Missing GL version\",\n    (const GLubyte*)\"GL 1.1 and up are not supported\",\n    (const GLubyte*)\"GLX 1.2 and up are not supported\",\n    (const GLubyte*)\"Unknown error\"\n  };\n  const int max_error = sizeof(_glewErrorString)/sizeof(*_glewErrorString) - 1;\n  return _glewErrorString[(int)error > max_error ? max_error : (int)error];\n}\n\nconst GLubyte* glewGetString (GLenum name)\n{\n  static const GLubyte* _glewString[] =\n  {\n    (const GLubyte*)NULL,\n    (const GLubyte*)\"1.5.1\",\n    (const GLubyte*)\"1\",\n    (const GLubyte*)\"5\",\n    (const GLubyte*)\"1\"\n  };\n  const int max_string = sizeof(_glewString)/sizeof(*_glewString) - 1;\n  return _glewString[(int)name > max_string ? 0 : (int)name];\n}\n\n/* ------------------------------------------------------------------------ */\n\nGLboolean glewExperimental = GL_FALSE;\n\n#if !defined(GLEW_MX)\n\n#if defined(_WIN32)\nextern GLenum wglewContextInit (void);\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */\nextern GLenum glxewContextInit (void);\n#endif /* _WIN32 */\n\nGLenum glewInit ()\n{\n  GLenum r;\n  if ( (r = glewContextInit()) ) return r;\n#if defined(_WIN32)\n  return wglewContextInit();\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX) /* _UNIX */\n  return glxewContextInit();\n#else\n  return r;\n#endif /* _WIN32 */\n}\n\n#endif /* !GLEW_MX */\n#ifdef GLEW_MX\nGLboolean glewContextIsSupported (GLEWContext* ctx, const char* name)\n#else\nGLboolean glewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if (_glewStrSame1(&pos, &len, (const GLubyte*)\"GL_\", 3))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"VERSION_\", 8))\n      {\n#ifdef GL_VERSION_1_2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_2\", 3))\n        {\n          ret = GLEW_VERSION_1_2;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_3\", 3))\n        {\n          ret = GLEW_VERSION_1_3;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_4\", 3))\n        {\n          ret = GLEW_VERSION_1_4;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_1_5\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_5\", 3))\n        {\n          ret = GLEW_VERSION_1_5;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_2_0\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"2_0\", 3))\n        {\n          ret = GLEW_VERSION_2_0;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_2_1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"2_1\", 3))\n        {\n          ret = GLEW_VERSION_2_1;\n          continue;\n        }\n#endif\n#ifdef GL_VERSION_3_0\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"3_0\", 3))\n        {\n          ret = GLEW_VERSION_3_0;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef GL_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_3DFX_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_3DFX_tbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"tbuffer\", 7))\n        {\n          ret = GLEW_3DFX_tbuffer;\n          continue;\n        }\n#endif\n#ifdef GL_3DFX_texture_compression_FXT1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_FXT1\", 24))\n        {\n          ret = GLEW_3DFX_texture_compression_FXT1;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"APPLE_\", 6))\n      {\n#ifdef GL_APPLE_client_storage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"client_storage\", 14))\n        {\n          ret = GLEW_APPLE_client_storage;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_element_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"element_array\", 13))\n        {\n          ret = GLEW_APPLE_element_array;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_fence\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fence\", 5))\n        {\n          ret = GLEW_APPLE_fence;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_float_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_pixels\", 12))\n        {\n          ret = GLEW_APPLE_float_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_flush_buffer_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"flush_buffer_range\", 18))\n        {\n          ret = GLEW_APPLE_flush_buffer_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_pixel_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer\", 12))\n        {\n          ret = GLEW_APPLE_pixel_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_specular_vector\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"specular_vector\", 15))\n        {\n          ret = GLEW_APPLE_specular_vector;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_texture_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_range\", 13))\n        {\n          ret = GLEW_APPLE_texture_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_transform_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_hint\", 14))\n        {\n          ret = GLEW_APPLE_transform_hint;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_APPLE_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLEW_APPLE_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GL_APPLE_ycbcr_422\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycbcr_422\", 9))\n        {\n          ret = GLEW_APPLE_ycbcr_422;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef GL_ARB_color_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_buffer_float\", 18))\n        {\n          ret = GLEW_ARB_color_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_depth_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_buffer_float\", 18))\n        {\n          ret = GLEW_ARB_depth_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_texture\", 13))\n        {\n          ret = GLEW_ARB_depth_texture;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_draw_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers\", 12))\n        {\n          ret = GLEW_ARB_draw_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_draw_instanced\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_instanced\", 14))\n        {\n          ret = GLEW_ARB_draw_instanced;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program\", 16))\n        {\n          ret = GLEW_ARB_fragment_program;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_program_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program_shadow\", 23))\n        {\n          ret = GLEW_ARB_fragment_program_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_shader\", 15))\n        {\n          ret = GLEW_ARB_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_framebuffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_object\", 18))\n        {\n          ret = GLEW_ARB_framebuffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_ARB_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_half_float_pixel\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float_pixel\", 16))\n        {\n          ret = GLEW_ARB_half_float_pixel;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_half_float_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float_vertex\", 17))\n        {\n          ret = GLEW_ARB_half_float_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_imaging\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"imaging\", 7))\n        {\n          ret = GLEW_ARB_imaging;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_instanced_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"instanced_arrays\", 16))\n        {\n          ret = GLEW_ARB_instanced_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_map_buffer_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"map_buffer_range\", 16))\n        {\n          ret = GLEW_ARB_map_buffer_range;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_matrix_palette\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"matrix_palette\", 14))\n        {\n          ret = GLEW_ARB_matrix_palette;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_ARB_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_multitexture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multitexture\", 12))\n        {\n          ret = GLEW_ARB_multitexture;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_occlusion_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_query\", 15))\n        {\n          ret = GLEW_ARB_occlusion_query;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_pixel_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer_object\", 19))\n        {\n          ret = GLEW_ARB_pixel_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_point_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_parameters\", 16))\n        {\n          ret = GLEW_ARB_point_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_point_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprite\", 12))\n        {\n          ret = GLEW_ARB_point_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shader_objects\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shader_objects\", 14))\n        {\n          ret = GLEW_ARB_shader_objects;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shading_language_100\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shading_language_100\", 20))\n        {\n          ret = GLEW_ARB_shading_language_100;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow\", 6))\n        {\n          ret = GLEW_ARB_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_shadow_ambient\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_ambient\", 14))\n        {\n          ret = GLEW_ARB_shadow_ambient;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_border_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_border_clamp\", 20))\n        {\n          ret = GLEW_ARB_texture_border_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_buffer_object\", 21))\n        {\n          ret = GLEW_ARB_texture_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_compression\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression\", 19))\n        {\n          ret = GLEW_ARB_texture_compression;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_compression_rgtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_rgtc\", 24))\n        {\n          ret = GLEW_ARB_texture_compression_rgtc;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_cube_map\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_cube_map\", 16))\n        {\n          ret = GLEW_ARB_texture_cube_map;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_add\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_add\", 15))\n        {\n          ret = GLEW_ARB_texture_env_add;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_combine\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine\", 19))\n        {\n          ret = GLEW_ARB_texture_env_combine;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_crossbar\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_crossbar\", 20))\n        {\n          ret = GLEW_ARB_texture_env_crossbar;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_env_dot3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_dot3\", 16))\n        {\n          ret = GLEW_ARB_texture_env_dot3;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_float\", 13))\n        {\n          ret = GLEW_ARB_texture_float;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_mirrored_repeat\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirrored_repeat\", 23))\n        {\n          ret = GLEW_ARB_texture_mirrored_repeat;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_non_power_of_two\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_non_power_of_two\", 24))\n        {\n          ret = GLEW_ARB_texture_non_power_of_two;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_ARB_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_texture_rg\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rg\", 10))\n        {\n          ret = GLEW_ARB_texture_rg;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_transpose_matrix\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transpose_matrix\", 16))\n        {\n          ret = GLEW_ARB_transpose_matrix;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_ARB_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_blend\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_blend\", 12))\n        {\n          ret = GLEW_ARB_vertex_blend;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_buffer_object\", 20))\n        {\n          ret = GLEW_ARB_vertex_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program\", 14))\n        {\n          ret = GLEW_ARB_vertex_program;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_vertex_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader\", 13))\n        {\n          ret = GLEW_ARB_vertex_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ARB_window_pos\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"window_pos\", 10))\n        {\n          ret = GLEW_ARB_window_pos;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATIX_\", 5))\n      {\n#ifdef GL_ATIX_point_sprites\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprites\", 13))\n        {\n          ret = GLEW_ATIX_point_sprites;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_texture_env_combine3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine3\", 20))\n        {\n          ret = GLEW_ATIX_texture_env_combine3;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_texture_env_route\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_route\", 17))\n        {\n          ret = GLEW_ATIX_texture_env_route;\n          continue;\n        }\n#endif\n#ifdef GL_ATIX_vertex_shader_output_point_size\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader_output_point_size\", 31))\n        {\n          ret = GLEW_ATIX_vertex_shader_output_point_size;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef GL_ATI_draw_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers\", 12))\n        {\n          ret = GLEW_ATI_draw_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_element_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"element_array\", 13))\n        {\n          ret = GLEW_ATI_element_array;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_envmap_bumpmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"envmap_bumpmap\", 14))\n        {\n          ret = GLEW_ATI_envmap_bumpmap;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_shader\", 15))\n        {\n          ret = GLEW_ATI_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_map_object_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"map_object_buffer\", 17))\n        {\n          ret = GLEW_ATI_map_object_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_pn_triangles\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pn_triangles\", 12))\n        {\n          ret = GLEW_ATI_pn_triangles;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_separate_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"separate_stencil\", 16))\n        {\n          ret = GLEW_ATI_separate_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_shader_texture_lod\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shader_texture_lod\", 18))\n        {\n          ret = GLEW_ATI_shader_texture_lod;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_text_fragment_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"text_fragment_shader\", 20))\n        {\n          ret = GLEW_ATI_text_fragment_shader;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_compression_3dc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_3dc\", 23))\n        {\n          ret = GLEW_ATI_texture_compression_3dc;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_env_combine3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine3\", 20))\n        {\n          ret = GLEW_ATI_texture_env_combine3;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_float\", 13))\n        {\n          ret = GLEW_ATI_texture_float;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_texture_mirror_once\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirror_once\", 19))\n        {\n          ret = GLEW_ATI_texture_mirror_once;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_object\", 19))\n        {\n          ret = GLEW_ATI_vertex_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_attrib_array_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_attrib_array_object\", 26))\n        {\n          ret = GLEW_ATI_vertex_attrib_array_object;\n          continue;\n        }\n#endif\n#ifdef GL_ATI_vertex_streams\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_streams\", 14))\n        {\n          ret = GLEW_ATI_vertex_streams;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef GL_EXT_422_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"422_pixels\", 10))\n        {\n          ret = GLEW_EXT_422_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_Cg_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"Cg_shader\", 9))\n        {\n          ret = GLEW_EXT_Cg_shader;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_abgr\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"abgr\", 4))\n        {\n          ret = GLEW_EXT_abgr;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_bgra\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"bgra\", 4))\n        {\n          ret = GLEW_EXT_bgra;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_bindable_uniform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"bindable_uniform\", 16))\n        {\n          ret = GLEW_EXT_bindable_uniform;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_color\", 11))\n        {\n          ret = GLEW_EXT_blend_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_equation_separate\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_equation_separate\", 23))\n        {\n          ret = GLEW_EXT_blend_equation_separate;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_func_separate\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_func_separate\", 19))\n        {\n          ret = GLEW_EXT_blend_func_separate;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_logic_op\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_logic_op\", 14))\n        {\n          ret = GLEW_EXT_blend_logic_op;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_minmax\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_minmax\", 12))\n        {\n          ret = GLEW_EXT_blend_minmax;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_blend_subtract\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_subtract\", 14))\n        {\n          ret = GLEW_EXT_blend_subtract;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_clip_volume_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"clip_volume_hint\", 16))\n        {\n          ret = GLEW_EXT_clip_volume_hint;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_cmyka\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cmyka\", 5))\n        {\n          ret = GLEW_EXT_cmyka;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_color_subtable\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_subtable\", 14))\n        {\n          ret = GLEW_EXT_color_subtable;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_compiled_vertex_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"compiled_vertex_array\", 21))\n        {\n          ret = GLEW_EXT_compiled_vertex_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_convolution\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution\", 11))\n        {\n          ret = GLEW_EXT_convolution;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_coordinate_frame\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"coordinate_frame\", 16))\n        {\n          ret = GLEW_EXT_coordinate_frame;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_copy_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_texture\", 12))\n        {\n          ret = GLEW_EXT_copy_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_cull_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cull_vertex\", 11))\n        {\n          ret = GLEW_EXT_cull_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_depth_bounds_test\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_bounds_test\", 17))\n        {\n          ret = GLEW_EXT_depth_bounds_test;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_direct_state_access\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"direct_state_access\", 19))\n        {\n          ret = GLEW_EXT_direct_state_access;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_buffers2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_buffers2\", 13))\n        {\n          ret = GLEW_EXT_draw_buffers2;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_instanced\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_instanced\", 14))\n        {\n          ret = GLEW_EXT_draw_instanced;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_draw_range_elements\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"draw_range_elements\", 19))\n        {\n          ret = GLEW_EXT_draw_range_elements;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_fog_coord\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_coord\", 9))\n        {\n          ret = GLEW_EXT_fog_coord;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_fragment_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_lighting\", 17))\n        {\n          ret = GLEW_EXT_fragment_lighting;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_blit\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_blit\", 16))\n        {\n          ret = GLEW_EXT_framebuffer_blit;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_multisample\", 23))\n        {\n          ret = GLEW_EXT_framebuffer_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_object\", 18))\n        {\n          ret = GLEW_EXT_framebuffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_EXT_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_gpu_program_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_program_parameters\", 22))\n        {\n          ret = GLEW_EXT_gpu_program_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_gpu_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_shader4\", 11))\n        {\n          ret = GLEW_EXT_gpu_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_histogram\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"histogram\", 9))\n        {\n          ret = GLEW_EXT_histogram;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_array_formats\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_array_formats\", 19))\n        {\n          ret = GLEW_EXT_index_array_formats;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_func\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_func\", 10))\n        {\n          ret = GLEW_EXT_index_func;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_material\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_material\", 14))\n        {\n          ret = GLEW_EXT_index_material;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_index_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"index_texture\", 13))\n        {\n          ret = GLEW_EXT_index_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_light_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"light_texture\", 13))\n        {\n          ret = GLEW_EXT_light_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_misc_attribute\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"misc_attribute\", 14))\n        {\n          ret = GLEW_EXT_misc_attribute;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_multi_draw_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multi_draw_arrays\", 17))\n        {\n          ret = GLEW_EXT_multi_draw_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_EXT_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_depth_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_depth_stencil\", 20))\n        {\n          ret = GLEW_EXT_packed_depth_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_float\", 12))\n        {\n          ret = GLEW_EXT_packed_float;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_packed_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_pixels\", 13))\n        {\n          ret = GLEW_EXT_packed_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_paletted_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"paletted_texture\", 16))\n        {\n          ret = GLEW_EXT_paletted_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_buffer_object\", 19))\n        {\n          ret = GLEW_EXT_pixel_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_transform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_transform\", 15))\n        {\n          ret = GLEW_EXT_pixel_transform;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_pixel_transform_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_transform_color_table\", 27))\n        {\n          ret = GLEW_EXT_pixel_transform_color_table;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_point_parameters\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_parameters\", 16))\n        {\n          ret = GLEW_EXT_point_parameters;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_polygon_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"polygon_offset\", 14))\n        {\n          ret = GLEW_EXT_polygon_offset;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_rescale_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"rescale_normal\", 14))\n        {\n          ret = GLEW_EXT_rescale_normal;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_scene_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"scene_marker\", 12))\n        {\n          ret = GLEW_EXT_scene_marker;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_secondary_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"secondary_color\", 15))\n        {\n          ret = GLEW_EXT_secondary_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_separate_specular_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"separate_specular_color\", 23))\n        {\n          ret = GLEW_EXT_separate_specular_color;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_shadow_funcs\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_funcs\", 12))\n        {\n          ret = GLEW_EXT_shadow_funcs;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_shared_texture_palette\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shared_texture_palette\", 22))\n        {\n          ret = GLEW_EXT_shared_texture_palette;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_clear_tag\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_clear_tag\", 17))\n        {\n          ret = GLEW_EXT_stencil_clear_tag;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_two_side\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_two_side\", 16))\n        {\n          ret = GLEW_EXT_stencil_two_side;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_stencil_wrap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stencil_wrap\", 12))\n        {\n          ret = GLEW_EXT_stencil_wrap;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_subtexture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"subtexture\", 10))\n        {\n          ret = GLEW_EXT_subtexture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture\", 7))\n        {\n          ret = GLEW_EXT_texture;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture3D\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture3D\", 9))\n        {\n          ret = GLEW_EXT_texture3D;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_array\", 13))\n        {\n          ret = GLEW_EXT_texture_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_buffer_object\", 21))\n        {\n          ret = GLEW_EXT_texture_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_dxt1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_dxt1\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_dxt1;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_latc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_latc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_latc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_rgtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_rgtc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_rgtc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_compression_s3tc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_s3tc\", 24))\n        {\n          ret = GLEW_EXT_texture_compression_s3tc;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_cube_map\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_cube_map\", 16))\n        {\n          ret = GLEW_EXT_texture_cube_map;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_edge_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_edge_clamp\", 18))\n        {\n          ret = GLEW_EXT_texture_edge_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env\", 11))\n        {\n          ret = GLEW_EXT_texture_env;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_add\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_add\", 15))\n        {\n          ret = GLEW_EXT_texture_env_add;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_combine\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine\", 19))\n        {\n          ret = GLEW_EXT_texture_env_combine;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_env_dot3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_dot3\", 16))\n        {\n          ret = GLEW_EXT_texture_env_dot3;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_filter_anisotropic\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_filter_anisotropic\", 26))\n        {\n          ret = GLEW_EXT_texture_filter_anisotropic;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_integer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_integer\", 15))\n        {\n          ret = GLEW_EXT_texture_integer;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_lod_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod_bias\", 16))\n        {\n          ret = GLEW_EXT_texture_lod_bias;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_mirror_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirror_clamp\", 20))\n        {\n          ret = GLEW_EXT_texture_mirror_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_object\", 14))\n        {\n          ret = GLEW_EXT_texture_object;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_perturb_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_perturb_normal\", 22))\n        {\n          ret = GLEW_EXT_texture_perturb_normal;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_EXT_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_sRGB\", 12))\n        {\n          ret = GLEW_EXT_texture_sRGB;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_shared_exponent\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shared_exponent\", 23))\n        {\n          ret = GLEW_EXT_texture_shared_exponent;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_texture_swizzle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_swizzle\", 15))\n        {\n          ret = GLEW_EXT_texture_swizzle;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_timer_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"timer_query\", 11))\n        {\n          ret = GLEW_EXT_timer_query;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_transform_feedback\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_feedback\", 18))\n        {\n          ret = GLEW_EXT_transform_feedback;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array\", 12))\n        {\n          ret = GLEW_EXT_vertex_array;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_array_bgra\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_bgra\", 17))\n        {\n          ret = GLEW_EXT_vertex_array_bgra;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_shader\", 13))\n        {\n          ret = GLEW_EXT_vertex_shader;\n          continue;\n        }\n#endif\n#ifdef GL_EXT_vertex_weighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_weighting\", 16))\n        {\n          ret = GLEW_EXT_vertex_weighting;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"GREMEDY_\", 8))\n      {\n#ifdef GL_GREMEDY_frame_terminator\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"frame_terminator\", 16))\n        {\n          ret = GLEW_GREMEDY_frame_terminator;\n          continue;\n        }\n#endif\n#ifdef GL_GREMEDY_string_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"string_marker\", 13))\n        {\n          ret = GLEW_GREMEDY_string_marker;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"HP_\", 3))\n      {\n#ifdef GL_HP_convolution_border_modes\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_border_modes\", 24))\n        {\n          ret = GLEW_HP_convolution_border_modes;\n          continue;\n        }\n#endif\n#ifdef GL_HP_image_transform\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"image_transform\", 15))\n        {\n          ret = GLEW_HP_image_transform;\n          continue;\n        }\n#endif\n#ifdef GL_HP_occlusion_test\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_test\", 14))\n        {\n          ret = GLEW_HP_occlusion_test;\n          continue;\n        }\n#endif\n#ifdef GL_HP_texture_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lighting\", 16))\n        {\n          ret = GLEW_HP_texture_lighting;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"IBM_\", 4))\n      {\n#ifdef GL_IBM_cull_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cull_vertex\", 11))\n        {\n          ret = GLEW_IBM_cull_vertex;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_multimode_draw_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multimode_draw_arrays\", 21))\n        {\n          ret = GLEW_IBM_multimode_draw_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_rasterpos_clip\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"rasterpos_clip\", 14))\n        {\n          ret = GLEW_IBM_rasterpos_clip;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_static_data\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"static_data\", 11))\n        {\n          ret = GLEW_IBM_static_data;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_texture_mirrored_repeat\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_mirrored_repeat\", 23))\n        {\n          ret = GLEW_IBM_texture_mirrored_repeat;\n          continue;\n        }\n#endif\n#ifdef GL_IBM_vertex_array_lists\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_lists\", 18))\n        {\n          ret = GLEW_IBM_vertex_array_lists;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"INGR_\", 5))\n      {\n#ifdef GL_INGR_color_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_clamp\", 11))\n        {\n          ret = GLEW_INGR_color_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_INGR_interlace_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace_read\", 14))\n        {\n          ret = GLEW_INGR_interlace_read;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"INTEL_\", 6))\n      {\n#ifdef GL_INTEL_parallel_arrays\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"parallel_arrays\", 15))\n        {\n          ret = GLEW_INTEL_parallel_arrays;\n          continue;\n        }\n#endif\n#ifdef GL_INTEL_texture_scissor\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_scissor\", 15))\n        {\n          ret = GLEW_INTEL_texture_scissor;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"KTX_\", 4))\n      {\n#ifdef GL_KTX_buffer_region\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"buffer_region\", 13))\n        {\n          ret = GLEW_KTX_buffer_region;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESAX_\", 6))\n      {\n#ifdef GL_MESAX_texture_stack\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_stack\", 13))\n        {\n          ret = GLEW_MESAX_texture_stack;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESA_\", 5))\n      {\n#ifdef GL_MESA_pack_invert\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pack_invert\", 11))\n        {\n          ret = GLEW_MESA_pack_invert;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_resize_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resize_buffers\", 14))\n        {\n          ret = GLEW_MESA_resize_buffers;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_window_pos\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"window_pos\", 10))\n        {\n          ret = GLEW_MESA_window_pos;\n          continue;\n        }\n#endif\n#ifdef GL_MESA_ycbcr_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycbcr_texture\", 13))\n        {\n          ret = GLEW_MESA_ycbcr_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef GL_NV_blend_square\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_square\", 12))\n        {\n          ret = GLEW_NV_blend_square;\n          continue;\n        }\n#endif\n#ifdef GL_NV_conditional_render\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"conditional_render\", 18))\n        {\n          ret = GLEW_NV_conditional_render;\n          continue;\n        }\n#endif\n#ifdef GL_NV_copy_depth_to_color\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_depth_to_color\", 19))\n        {\n          ret = GLEW_NV_copy_depth_to_color;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_buffer_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_buffer_float\", 18))\n        {\n          ret = GLEW_NV_depth_buffer_float;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_clamp\", 11))\n        {\n          ret = GLEW_NV_depth_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_NV_depth_range_unclamped\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_range_unclamped\", 21))\n        {\n          ret = GLEW_NV_depth_range_unclamped;\n          continue;\n        }\n#endif\n#ifdef GL_NV_evaluators\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"evaluators\", 10))\n        {\n          ret = GLEW_NV_evaluators;\n          continue;\n        }\n#endif\n#ifdef GL_NV_explicit_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"explicit_multisample\", 20))\n        {\n          ret = GLEW_NV_explicit_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fence\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fence\", 5))\n        {\n          ret = GLEW_NV_fence;\n          continue;\n        }\n#endif\n#ifdef GL_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = GLEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fog_distance\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_distance\", 12))\n        {\n          ret = GLEW_NV_fog_distance;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program\", 16))\n        {\n          ret = GLEW_NV_fragment_program;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program2\", 17))\n        {\n          ret = GLEW_NV_fragment_program2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program4\", 17))\n        {\n          ret = GLEW_NV_fragment_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_fragment_program_option\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_program_option\", 23))\n        {\n          ret = GLEW_NV_fragment_program_option;\n          continue;\n        }\n#endif\n#ifdef GL_NV_framebuffer_multisample_coverage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_multisample_coverage\", 32))\n        {\n          ret = GLEW_NV_framebuffer_multisample_coverage;\n          continue;\n        }\n#endif\n#ifdef GL_NV_geometry_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_program4\", 17))\n        {\n          ret = GLEW_NV_geometry_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_geometry_shader4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"geometry_shader4\", 16))\n        {\n          ret = GLEW_NV_geometry_shader4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_gpu_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_program4\", 12))\n        {\n          ret = GLEW_NV_gpu_program4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_half_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"half_float\", 10))\n        {\n          ret = GLEW_NV_half_float;\n          continue;\n        }\n#endif\n#ifdef GL_NV_light_max_exponent\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"light_max_exponent\", 18))\n        {\n          ret = GLEW_NV_light_max_exponent;\n          continue;\n        }\n#endif\n#ifdef GL_NV_multisample_filter_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample_filter_hint\", 23))\n        {\n          ret = GLEW_NV_multisample_filter_hint;\n          continue;\n        }\n#endif\n#ifdef GL_NV_occlusion_query\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"occlusion_query\", 15))\n        {\n          ret = GLEW_NV_occlusion_query;\n          continue;\n        }\n#endif\n#ifdef GL_NV_packed_depth_stencil\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"packed_depth_stencil\", 20))\n        {\n          ret = GLEW_NV_packed_depth_stencil;\n          continue;\n        }\n#endif\n#ifdef GL_NV_parameter_buffer_object\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"parameter_buffer_object\", 23))\n        {\n          ret = GLEW_NV_parameter_buffer_object;\n          continue;\n        }\n#endif\n#ifdef GL_NV_pixel_data_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_data_range\", 16))\n        {\n          ret = GLEW_NV_pixel_data_range;\n          continue;\n        }\n#endif\n#ifdef GL_NV_point_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_sprite\", 12))\n        {\n          ret = GLEW_NV_point_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = GLEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef GL_NV_primitive_restart\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"primitive_restart\", 17))\n        {\n          ret = GLEW_NV_primitive_restart;\n          continue;\n        }\n#endif\n#ifdef GL_NV_register_combiners\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"register_combiners\", 18))\n        {\n          ret = GLEW_NV_register_combiners;\n          continue;\n        }\n#endif\n#ifdef GL_NV_register_combiners2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"register_combiners2\", 19))\n        {\n          ret = GLEW_NV_register_combiners2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texgen_emboss\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texgen_emboss\", 13))\n        {\n          ret = GLEW_NV_texgen_emboss;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texgen_reflection\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texgen_reflection\", 17))\n        {\n          ret = GLEW_NV_texgen_reflection;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_compression_vtc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_compression_vtc\", 23))\n        {\n          ret = GLEW_NV_texture_compression_vtc;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_env_combine4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_env_combine4\", 20))\n        {\n          ret = GLEW_NV_texture_env_combine4;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_expand_normal\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_expand_normal\", 21))\n        {\n          ret = GLEW_NV_texture_expand_normal;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_rectangle\", 17))\n        {\n          ret = GLEW_NV_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader\", 14))\n        {\n          ret = GLEW_NV_texture_shader;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader2\", 15))\n        {\n          ret = GLEW_NV_texture_shader2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_texture_shader3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_shader3\", 15))\n        {\n          ret = GLEW_NV_texture_shader3;\n          continue;\n        }\n#endif\n#ifdef GL_NV_transform_feedback\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"transform_feedback\", 18))\n        {\n          ret = GLEW_NV_transform_feedback;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_array_range2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range2\", 19))\n        {\n          ret = GLEW_NV_vertex_array_range2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program\", 14))\n        {\n          ret = GLEW_NV_vertex_program;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program1_1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program1_1\", 17))\n        {\n          ret = GLEW_NV_vertex_program1_1;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program2\", 15))\n        {\n          ret = GLEW_NV_vertex_program2;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program2_option\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program2_option\", 22))\n        {\n          ret = GLEW_NV_vertex_program2_option;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program3\", 15))\n        {\n          ret = GLEW_NV_vertex_program3;\n          continue;\n        }\n#endif\n#ifdef GL_NV_vertex_program4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_program4\", 15))\n        {\n          ret = GLEW_NV_vertex_program4;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OES_\", 4))\n      {\n#ifdef GL_OES_byte_coordinates\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"byte_coordinates\", 16))\n        {\n          ret = GLEW_OES_byte_coordinates;\n          continue;\n        }\n#endif\n#ifdef GL_OES_compressed_paletted_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"compressed_paletted_texture\", 27))\n        {\n          ret = GLEW_OES_compressed_paletted_texture;\n          continue;\n        }\n#endif\n#ifdef GL_OES_read_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"read_format\", 11))\n        {\n          ret = GLEW_OES_read_format;\n          continue;\n        }\n#endif\n#ifdef GL_OES_single_precision\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"single_precision\", 16))\n        {\n          ret = GLEW_OES_single_precision;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef GL_OML_interlace\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace\", 9))\n        {\n          ret = GLEW_OML_interlace;\n          continue;\n        }\n#endif\n#ifdef GL_OML_resample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resample\", 8))\n        {\n          ret = GLEW_OML_resample;\n          continue;\n        }\n#endif\n#ifdef GL_OML_subsample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"subsample\", 9))\n        {\n          ret = GLEW_OML_subsample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"PGI_\", 4))\n      {\n#ifdef GL_PGI_misc_hints\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"misc_hints\", 10))\n        {\n          ret = GLEW_PGI_misc_hints;\n          continue;\n        }\n#endif\n#ifdef GL_PGI_vertex_hints\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_hints\", 12))\n        {\n          ret = GLEW_PGI_vertex_hints;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"REND_\", 5))\n      {\n#ifdef GL_REND_screen_coordinates\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"screen_coordinates\", 18))\n        {\n          ret = GLEW_REND_screen_coordinates;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"S3_\", 3))\n      {\n#ifdef GL_S3_s3tc\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"s3tc\", 4))\n        {\n          ret = GLEW_S3_s3tc;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIS_\", 5))\n      {\n#ifdef GL_SGIS_color_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_range\", 11))\n        {\n          ret = GLEW_SGIS_color_range;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_detail_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"detail_texture\", 14))\n        {\n          ret = GLEW_SGIS_detail_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_fog_function\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_function\", 12))\n        {\n          ret = GLEW_SGIS_fog_function;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_generate_mipmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"generate_mipmap\", 15))\n        {\n          ret = GLEW_SGIS_generate_mipmap;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLEW_SGIS_multisample;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_pixel_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture\", 13))\n        {\n          ret = GLEW_SGIS_pixel_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_point_line_texgen\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"point_line_texgen\", 17))\n        {\n          ret = GLEW_SGIS_point_line_texgen;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_sharpen_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sharpen_texture\", 15))\n        {\n          ret = GLEW_SGIS_sharpen_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture4D\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture4D\", 9))\n        {\n          ret = GLEW_SGIS_texture4D;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_border_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_border_clamp\", 20))\n        {\n          ret = GLEW_SGIS_texture_border_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_edge_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_edge_clamp\", 18))\n        {\n          ret = GLEW_SGIS_texture_edge_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_filter4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_filter4\", 15))\n        {\n          ret = GLEW_SGIS_texture_filter4;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_lod\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod\", 11))\n        {\n          ret = GLEW_SGIS_texture_lod;\n          continue;\n        }\n#endif\n#ifdef GL_SGIS_texture_select\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_select\", 14))\n        {\n          ret = GLEW_SGIS_texture_select;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIX_\", 5))\n      {\n#ifdef GL_SGIX_async\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async\", 5))\n        {\n          ret = GLEW_SGIX_async;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_async_histogram\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async_histogram\", 15))\n        {\n          ret = GLEW_SGIX_async_histogram;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_async_pixel\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"async_pixel\", 11))\n        {\n          ret = GLEW_SGIX_async_pixel;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_blend_alpha_minmax\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blend_alpha_minmax\", 18))\n        {\n          ret = GLEW_SGIX_blend_alpha_minmax;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_clipmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"clipmap\", 7))\n        {\n          ret = GLEW_SGIX_clipmap;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_convolution_accuracy\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_accuracy\", 20))\n        {\n          ret = GLEW_SGIX_convolution_accuracy;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_texture\", 13))\n        {\n          ret = GLEW_SGIX_depth_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_flush_raster\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"flush_raster\", 12))\n        {\n          ret = GLEW_SGIX_flush_raster;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fog_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_offset\", 10))\n        {\n          ret = GLEW_SGIX_fog_offset;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fog_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fog_texture\", 11))\n        {\n          ret = GLEW_SGIX_fog_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_fragment_specular_lighting\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fragment_specular_lighting\", 26))\n        {\n          ret = GLEW_SGIX_fragment_specular_lighting;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_framezoom\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framezoom\", 9))\n        {\n          ret = GLEW_SGIX_framezoom;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_interlace\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"interlace\", 9))\n        {\n          ret = GLEW_SGIX_interlace;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_ir_instrument1\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ir_instrument1\", 14))\n        {\n          ret = GLEW_SGIX_ir_instrument1;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_list_priority\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"list_priority\", 13))\n        {\n          ret = GLEW_SGIX_list_priority;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_pixel_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture\", 13))\n        {\n          ret = GLEW_SGIX_pixel_texture;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_pixel_texture_bits\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_texture_bits\", 18))\n        {\n          ret = GLEW_SGIX_pixel_texture_bits;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_reference_plane\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"reference_plane\", 15))\n        {\n          ret = GLEW_SGIX_reference_plane;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_resample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"resample\", 8))\n        {\n          ret = GLEW_SGIX_resample;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_shadow\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow\", 6))\n        {\n          ret = GLEW_SGIX_shadow;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_shadow_ambient\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shadow_ambient\", 14))\n        {\n          ret = GLEW_SGIX_shadow_ambient;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_sprite\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sprite\", 6))\n        {\n          ret = GLEW_SGIX_sprite;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_tag_sample_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"tag_sample_buffer\", 17))\n        {\n          ret = GLEW_SGIX_tag_sample_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_add_env\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_add_env\", 15))\n        {\n          ret = GLEW_SGIX_texture_add_env;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_coordinate_clamp\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_coordinate_clamp\", 24))\n        {\n          ret = GLEW_SGIX_texture_coordinate_clamp;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_lod_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_lod_bias\", 16))\n        {\n          ret = GLEW_SGIX_texture_lod_bias;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_multi_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_multi_buffer\", 20))\n        {\n          ret = GLEW_SGIX_texture_multi_buffer;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_range\", 13))\n        {\n          ret = GLEW_SGIX_texture_range;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_texture_scale_bias\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_scale_bias\", 18))\n        {\n          ret = GLEW_SGIX_texture_scale_bias;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_vertex_preclip\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_preclip\", 14))\n        {\n          ret = GLEW_SGIX_vertex_preclip;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_vertex_preclip_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_preclip_hint\", 19))\n        {\n          ret = GLEW_SGIX_vertex_preclip_hint;\n          continue;\n        }\n#endif\n#ifdef GL_SGIX_ycrcb\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"ycrcb\", 5))\n        {\n          ret = GLEW_SGIX_ycrcb;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGI_\", 4))\n      {\n#ifdef GL_SGI_color_matrix\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_matrix\", 12))\n        {\n          ret = GLEW_SGI_color_matrix;\n          continue;\n        }\n#endif\n#ifdef GL_SGI_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_table\", 11))\n        {\n          ret = GLEW_SGI_color_table;\n          continue;\n        }\n#endif\n#ifdef GL_SGI_texture_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_color_table\", 19))\n        {\n          ret = GLEW_SGI_texture_color_table;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUNX_\", 5))\n      {\n#ifdef GL_SUNX_constant_data\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"constant_data\", 13))\n        {\n          ret = GLEW_SUNX_constant_data;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUN_\", 4))\n      {\n#ifdef GL_SUN_convolution_border_modes\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"convolution_border_modes\", 24))\n        {\n          ret = GLEW_SUN_convolution_border_modes;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_global_alpha\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"global_alpha\", 12))\n        {\n          ret = GLEW_SUN_global_alpha;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_mesh_array\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"mesh_array\", 10))\n        {\n          ret = GLEW_SUN_mesh_array;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_read_video_pixels\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"read_video_pixels\", 17))\n        {\n          ret = GLEW_SUN_read_video_pixels;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_slice_accum\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"slice_accum\", 11))\n        {\n          ret = GLEW_SUN_slice_accum;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_triangle_list\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"triangle_list\", 13))\n        {\n          ret = GLEW_SUN_triangle_list;\n          continue;\n        }\n#endif\n#ifdef GL_SUN_vertex\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex\", 6))\n        {\n          ret = GLEW_SUN_vertex;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"WIN_\", 4))\n      {\n#ifdef GL_WIN_phong_shading\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"phong_shading\", 13))\n        {\n          ret = GLEW_WIN_phong_shading;\n          continue;\n        }\n#endif\n#ifdef GL_WIN_specular_fog\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"specular_fog\", 12))\n        {\n          ret = GLEW_WIN_specular_fog;\n          continue;\n        }\n#endif\n#ifdef GL_WIN_swap_hint\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_hint\", 9))\n        {\n          ret = GLEW_WIN_swap_hint;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#if defined(_WIN32)\n\n#if defined(GLEW_MX)\nGLboolean wglewContextIsSupported (WGLEWContext* ctx, const char* name)\n#else\nGLboolean wglewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if (_glewStrSame1(&pos, &len, (const GLubyte*)\"WGL_\", 4))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef WGL_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_3DFX_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DL_\", 4))\n      {\n#ifdef WGL_3DL_stereo_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"stereo_control\", 14))\n        {\n          ret = WGLEW_3DL_stereo_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef WGL_ARB_buffer_region\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"buffer_region\", 13))\n        {\n          ret = WGLEW_ARB_buffer_region;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_create_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"create_context\", 14))\n        {\n          ret = WGLEW_ARB_create_context;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_extensions_string\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"extensions_string\", 17))\n        {\n          ret = WGLEW_ARB_extensions_string;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = WGLEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = WGLEW_ARB_make_current_read;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_ARB_multisample;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = WGLEW_ARB_pbuffer;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pixel_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format\", 12))\n        {\n          ret = WGLEW_ARB_pixel_format;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = WGLEW_ARB_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef WGL_ARB_render_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture\", 14))\n        {\n          ret = WGLEW_ARB_render_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef WGL_ATI_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = WGLEW_ATI_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef WGL_ATI_render_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture_rectangle\", 24))\n        {\n          ret = WGLEW_ATI_render_texture_rectangle;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef WGL_EXT_depth_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"depth_float\", 11))\n        {\n          ret = WGLEW_EXT_depth_float;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_display_color_table\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"display_color_table\", 19))\n        {\n          ret = WGLEW_EXT_display_color_table;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_extensions_string\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"extensions_string\", 17))\n        {\n          ret = WGLEW_EXT_extensions_string;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = WGLEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = WGLEW_EXT_make_current_read;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = WGLEW_EXT_multisample;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = WGLEW_EXT_pbuffer;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pixel_format\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format\", 12))\n        {\n          ret = WGLEW_EXT_pixel_format;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_pixel_format_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_packed_float\", 25))\n        {\n          ret = WGLEW_EXT_pixel_format_packed_float;\n          continue;\n        }\n#endif\n#ifdef WGL_EXT_swap_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_control\", 12))\n        {\n          ret = WGLEW_EXT_swap_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"I3D_\", 4))\n      {\n#ifdef WGL_I3D_digital_video_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"digital_video_control\", 21))\n        {\n          ret = WGLEW_I3D_digital_video_control;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_gamma\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gamma\", 5))\n        {\n          ret = WGLEW_I3D_gamma;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_genlock\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"genlock\", 7))\n        {\n          ret = WGLEW_I3D_genlock;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_image_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"image_buffer\", 12))\n        {\n          ret = WGLEW_I3D_image_buffer;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_swap_frame_lock\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_frame_lock\", 15))\n        {\n          ret = WGLEW_I3D_swap_frame_lock;\n          continue;\n        }\n#endif\n#ifdef WGL_I3D_swap_frame_usage\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_frame_usage\", 16))\n        {\n          ret = WGLEW_I3D_swap_frame_usage;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef WGL_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = WGLEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_gpu_affinity\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"gpu_affinity\", 12))\n        {\n          ret = WGLEW_NV_gpu_affinity;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = WGLEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_render_depth_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_depth_texture\", 20))\n        {\n          ret = WGLEW_NV_render_depth_texture;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_render_texture_rectangle\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture_rectangle\", 24))\n        {\n          ret = WGLEW_NV_render_texture_rectangle;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = WGLEW_NV_swap_group;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = WGLEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef WGL_NV_video_output\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_output\", 12))\n        {\n          ret = WGLEW_NV_video_output;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef WGL_OML_sync_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sync_control\", 12))\n        {\n          ret = WGLEW_OML_sync_control;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#elif !defined(__APPLE__) || defined(GLEW_APPLE_GLX)\n\n#if defined(GLEW_MX)\nGLboolean glxewContextIsSupported (GLXEWContext* ctx, const char* name)\n#else\nGLboolean glxewIsSupported (const char* name)\n#endif\n{\n  GLubyte* pos = (GLubyte*)name;\n  GLuint len = _glewStrLen(pos);\n  GLboolean ret = GL_TRUE;\n  while (ret && len > 0)\n  {\n    if(_glewStrSame1(&pos, &len, (const GLubyte*)\"GLX_\", 4))\n    {\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"VERSION_\", 8))\n      {\n#ifdef GLX_VERSION_1_2\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_2\", 3))\n        {\n          ret = GLXEW_VERSION_1_2;\n          continue;\n        }\n#endif\n#ifdef GLX_VERSION_1_3\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_3\", 3))\n        {\n          ret = GLXEW_VERSION_1_3;\n          continue;\n        }\n#endif\n#ifdef GLX_VERSION_1_4\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"1_4\", 3))\n        {\n          ret = GLXEW_VERSION_1_4;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"3DFX_\", 5))\n      {\n#ifdef GLX_3DFX_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_3DFX_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ARB_\", 4))\n      {\n#ifdef GLX_ARB_create_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"create_context\", 14))\n        {\n          ret = GLXEW_ARB_create_context;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_fbconfig_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig_float\", 14))\n        {\n          ret = GLXEW_ARB_fbconfig_float;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLXEW_ARB_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_get_proc_address\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"get_proc_address\", 16))\n        {\n          ret = GLXEW_ARB_get_proc_address;\n          continue;\n        }\n#endif\n#ifdef GLX_ARB_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_ARB_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"ATI_\", 4))\n      {\n#ifdef GLX_ATI_pixel_format_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixel_format_float\", 18))\n        {\n          ret = GLXEW_ATI_pixel_format_float;\n          continue;\n        }\n#endif\n#ifdef GLX_ATI_render_texture\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"render_texture\", 14))\n        {\n          ret = GLXEW_ATI_render_texture;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"EXT_\", 4))\n      {\n#ifdef GLX_EXT_fbconfig_packed_float\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig_packed_float\", 21))\n        {\n          ret = GLXEW_EXT_fbconfig_packed_float;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_framebuffer_sRGB\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"framebuffer_sRGB\", 16))\n        {\n          ret = GLXEW_EXT_framebuffer_sRGB;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_import_context\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"import_context\", 14))\n        {\n          ret = GLXEW_EXT_import_context;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_scene_marker\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"scene_marker\", 12))\n        {\n          ret = GLXEW_EXT_scene_marker;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_texture_from_pixmap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"texture_from_pixmap\", 19))\n        {\n          ret = GLXEW_EXT_texture_from_pixmap;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_visual_info\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_info\", 11))\n        {\n          ret = GLXEW_EXT_visual_info;\n          continue;\n        }\n#endif\n#ifdef GLX_EXT_visual_rating\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_rating\", 13))\n        {\n          ret = GLXEW_EXT_visual_rating;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"MESA_\", 5))\n      {\n#ifdef GLX_MESA_agp_offset\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"agp_offset\", 10))\n        {\n          ret = GLXEW_MESA_agp_offset;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_copy_sub_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"copy_sub_buffer\", 15))\n        {\n          ret = GLXEW_MESA_copy_sub_buffer;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_pixmap_colormap\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pixmap_colormap\", 15))\n        {\n          ret = GLXEW_MESA_pixmap_colormap;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_release_buffers\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"release_buffers\", 15))\n        {\n          ret = GLXEW_MESA_release_buffers;\n          continue;\n        }\n#endif\n#ifdef GLX_MESA_set_3dfx_mode\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"set_3dfx_mode\", 13))\n        {\n          ret = GLXEW_MESA_set_3dfx_mode;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"NV_\", 3))\n      {\n#ifdef GLX_NV_float_buffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"float_buffer\", 12))\n        {\n          ret = GLXEW_NV_float_buffer;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_present_video\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"present_video\", 13))\n        {\n          ret = GLXEW_NV_present_video;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = GLXEW_NV_swap_group;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_vertex_array_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"vertex_array_range\", 18))\n        {\n          ret = GLXEW_NV_vertex_array_range;\n          continue;\n        }\n#endif\n#ifdef GLX_NV_video_output\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_output\", 12))\n        {\n          ret = GLXEW_NV_video_output;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"OML_\", 4))\n      {\n#ifdef GLX_OML_swap_method\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_method\", 11))\n        {\n          ret = GLXEW_OML_swap_method;\n          continue;\n        }\n#endif\n#if defined(GLX_OML_sync_control) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n#include <inttypes.h>\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"sync_control\", 12))\n        {\n          ret = GLXEW_OML_sync_control;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIS_\", 5))\n      {\n#ifdef GLX_SGIS_blended_overlay\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"blended_overlay\", 15))\n        {\n          ret = GLXEW_SGIS_blended_overlay;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_color_range\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"color_range\", 11))\n        {\n          ret = GLXEW_SGIS_color_range;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"multisample\", 11))\n        {\n          ret = GLXEW_SGIS_multisample;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIS_shared_multisample\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"shared_multisample\", 18))\n        {\n          ret = GLXEW_SGIS_shared_multisample;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGIX_\", 5))\n      {\n#ifdef GLX_SGIX_fbconfig\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"fbconfig\", 8))\n        {\n          ret = GLXEW_SGIX_fbconfig;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_hyperpipe\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"hyperpipe\", 9))\n        {\n          ret = GLXEW_SGIX_hyperpipe;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_pbuffer\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"pbuffer\", 7))\n        {\n          ret = GLXEW_SGIX_pbuffer;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_swap_barrier\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_barrier\", 12))\n        {\n          ret = GLXEW_SGIX_swap_barrier;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_swap_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_group\", 10))\n        {\n          ret = GLXEW_SGIX_swap_group;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_video_resize\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_resize\", 12))\n        {\n          ret = GLXEW_SGIX_video_resize;\n          continue;\n        }\n#endif\n#ifdef GLX_SGIX_visual_select_group\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"visual_select_group\", 19))\n        {\n          ret = GLXEW_SGIX_visual_select_group;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SGI_\", 4))\n      {\n#ifdef GLX_SGI_cushion\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"cushion\", 7))\n        {\n          ret = GLXEW_SGI_cushion;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_make_current_read\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"make_current_read\", 17))\n        {\n          ret = GLXEW_SGI_make_current_read;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_swap_control\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"swap_control\", 12))\n        {\n          ret = GLXEW_SGI_swap_control;\n          continue;\n        }\n#endif\n#ifdef GLX_SGI_video_sync\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_sync\", 10))\n        {\n          ret = GLXEW_SGI_video_sync;\n          continue;\n        }\n#endif\n      }\n      if (_glewStrSame2(&pos, &len, (const GLubyte*)\"SUN_\", 4))\n      {\n#ifdef GLX_SUN_get_transparent_index\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"get_transparent_index\", 21))\n        {\n          ret = GLXEW_SUN_get_transparent_index;\n          continue;\n        }\n#endif\n#ifdef GLX_SUN_video_resize\n        if (_glewStrSame3(&pos, &len, (const GLubyte*)\"video_resize\", 12))\n        {\n          ret = GLXEW_SUN_video_resize;\n          continue;\n        }\n#endif\n      }\n    }\n    ret = (len == 0);\n  }\n  return ret;\n}\n\n#endif /* _WIN32 */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v600/candle.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v602/violin.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/textoption.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/th2polyUSA.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/hbarmin0.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/th2polyBoxes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/th2polyEurope.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v528/th2polyHoneycomb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v526/gtime.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v526/surf7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v526/gtime2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v526/graph2derrors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v534/mg3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v522/Contour.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v522/Scan.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/hist/doc/v522/FitPanel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_save.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_fontselect.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_rename.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_AlignTop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_paste_into.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_cut.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/record.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_compact.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_shutter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/refresh.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_AlignLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/Splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_paste.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/glow_green.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ReloadPage.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_redo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_copy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_execute.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_hbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/class.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/member.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/rotate.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_vbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/GoForward.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_sortup.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/Root6Splash.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/StopLoading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_open.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_edit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_paste.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_saveas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/GoBack.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_undo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ver_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_help.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/GoHome.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_print.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/closetab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_goto.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_newtab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_new.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/pause.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/closetab_d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_cut.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_AlignBtm.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/glow_red.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_AlignCenter.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/eve_text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/speedo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/right_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/method.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_crop.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/Root6Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/replay.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_quit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_grid.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_save.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/recursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_open.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_colorselect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_AlignRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_fontselect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_interrupt.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/htmlfile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_exit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/top_left_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/RootIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_copy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_new.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_edit_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_break.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/bld_removetab.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/top_right_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/glow_orange.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/hor_arrow_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/move_cursor.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/icons/ed_findnext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tree/dataframe/test/RSqliteDS_test.sqlite",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tree/doc/v526/perfstats_atlas_flushed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tree/doc/v526/perfstats_atlas_original.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/build/package/common/s050000l.pfb",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/build/package/debian/application-x-root.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/build/package/debian/root-system-bin.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/build/package/debian/po/da.po",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/utils/lit/tests/shtest-encoding.py",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/utils/lit/tests/Inputs/shtest-format/external_shell/write-bad-encoding.sh",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/bindings/python/llvm/tests/test.bc",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/cmake/nsis_logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/cmake/nsis_icon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/feature-compile1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/feature-compile2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/feature-memory1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/carbon-compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/demo/cathead.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_use_assert.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_null_pointer.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_cf_returns_retained.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/scan_build_cmd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/analyzer_html.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_custom_assert.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/analyzer_xcode.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_ns_returns_retained.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_cf_returns_retained_gc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/example_attribute_nonnull.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/ellipses_dark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/arrows_light.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/arrows_dark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/www/analyzer/images/expandcollapse/ellipses_light.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/scan-view/share/FileRadar.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/scan-view/share/bugcatcher.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/clang-format-vs/ClangFormat/Resources/Images_32bit.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/clang-format-vs/ClangFormat/Resources/Package.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/scan-build/share/scan-build/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/tools/scan-build-py/libscanbuild/resources/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/docs/DriverArchitecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/tools/clang/docs/PCHLayout.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/ARM-BE-bitcastfail.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-dyld-load.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-engine-builder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-creation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-load-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/MCJIT-resolve-relocations.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/ARM-BE-ld1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/gcc-loops.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/ARM-BE-bitcastsuccess.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/linpack-pc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/ARM-BE-ldr.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/tutorial/LangImpl05-cfg.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/_static/lines.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/contents.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/llvm/src/docs/_themes/llvm-theme/static/navigation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/test/Prompt/ValuePrinter/Strings.dat",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/JupyterScreenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/graphic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/link.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/search.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/bullet.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/style/menu_bg.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/docs/talks/CreatingCling.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/docs/talks/ImplementingDynamicScopesInCling.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/docs/talks/ClingTheLLVM-basedInterpreter.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/www/docs/talks/AxelNaumann-cling-GoogleTech.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/tools/packaging/LLVM.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/interpreter/cling/tools/packaging/LLVM.icns",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/HttpServer/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/minuit2/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/minuit2/figures/fcnbase.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/minuit2/figures/fcngradientbase.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/examplefit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/TF1_DoubleSlit.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/th2f.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/TH1F_Example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/graf_with_law.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/ROOTPanel_SetParameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/poisson.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/fitted2dFunction.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/polar_graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/histo_sum.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/TGraphErrors_Example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/graph_with_expectation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/ROOTPanel_FitPanel.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/multigraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/Cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/histo_ratio.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/functions.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/proj_and_prof.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/primer/figures/hstack.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/rootlogo_s.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/notebook.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/rootlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/mathjax.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_default.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter016.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_canvas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter032.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_frame0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter021.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_brik.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/tgraph2d_delaunay.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter010.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TFormula_eval.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_ctub_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/hlsimple_nofun.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_dialogbuttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/graf_graphqq2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_calorimeters.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_gtra_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_text.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_arrow_standalone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_frame1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_cons_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TFormula_compile.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter011.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_tube_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_slider.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/normal95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/uni95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_random2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_smoothing_image008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumfit_awmi_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_voxelfind.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter028.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_pad2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_triangleset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/graf_pavestext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter040.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/RDF_Graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_cms_stereo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter033.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_inspect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/ttree_friend1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_stiefel_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_enhance_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_browser.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_box_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter020.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_show_extract.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/graf_graphqq1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_3ds.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_eltu_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_hype_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/hlGraph1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_xtru.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_pcon_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/av_cov.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumtransform_transform_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_mgr.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_voxtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_box.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_boxset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_annotation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching10.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_ctub_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_background_image006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumtransform_enhance_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_background_image003.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching14.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trap_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_alice_esd_split.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter017.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_cone_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/hlHisto3_top.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_pointset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_na49.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/R_image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumfit_constructor_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_stiefel_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_trap.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_finder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_track.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_assembly.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter008.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_cons_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_lhcb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_transform_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/wilson95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_classtree1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter015.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/image_hist2image.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_hype_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_pcon_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_graf.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_pad5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_histobrowser.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter037.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_linestyle.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_pad3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter038.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/ac95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_lineset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumfit_stiefel_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_axis3d_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_searching_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter041.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumtransform_transform_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_pgon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_quadset.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter035.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_aliceproj.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/tmva_mlp.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_glplot_geom.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_para_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter031.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_trd1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_trd2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_filter_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_glplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_boxset_cones.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_torus_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/RF_Landau.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_pack.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_sphe_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_tubs_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_calo_detail.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter019.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_pad4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_cmsgeo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image006.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_transform_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_atlas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Background_smooth1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_polytype.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_enhance_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_sphe_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter027.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/multidimfit_img86.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/cp95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_searching_image003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_projection_prescale.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching9.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_inspect.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_alice_tpc.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Unfolding3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumfit_awmi_image002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_cone_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/graf_pavelabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_shapes.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter024.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_controlbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter030.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter002.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Smoothing1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_background_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_tbuffer3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching12.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumtransform_filter_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_hsummenu.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_eltu_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_box_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter039.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/postscript_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_projection.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_gtra.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_alice_its.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_axis3d_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter023.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_view3ds.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter036.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/image_galaxy_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter018.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_tubs.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/R_image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_compound.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/ttree_treeview.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_tube_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/tchain_friend.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_deconvolution_image005.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_hierarchical_scene.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_booltree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_scaledshape.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter034.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter003.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_alice_vsd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter012.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching13.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_background_image007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_alias.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_ratioplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/ttree_friend2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Unfolding3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_pgon_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2transform_filter_image001.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_pad1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_para.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_random1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_alice3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter013.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trd2_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_cons.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_hsumdialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trd1_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_tshape_classtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_tdictionary.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_torus_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter009.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trd2_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_tubs_ed.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter025.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/graf_pave.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter022.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_classinfo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_alice_esd.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_cone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_checkpoint.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_para_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/R_image3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/hlgerrors2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/tbufferfile_double32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/jeffrey95.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_tasks.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/base_object.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_pcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Unfolding2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trap_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_frameexp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_geom_cms.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/gpad_classtree2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_trd1_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum_Deconvolution_wide2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/hlsimple.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Background4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Searching1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_ctub.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter014.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TFormula_analyze.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/g3d_tube.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter026.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_awmi_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_window_manager.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_pgon_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum2fit_constructor_image001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/ttree_makeselector_option_examples.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_jetcone.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/tbufferfile_fildir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_gtra_pic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrum3_smoothing_image007.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/geom_t_shape.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/eve_csgdemo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/TSpectrum2_Deconvolution4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/doxygen/images/spectrumpainter029.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image068.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image086.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image180.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image176.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image216.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image026.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image246.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image078.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image072.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image230.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image114.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image074.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image016.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image090.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image196.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image222.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image094.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image040.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image024.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image032.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image174.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image116.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image036.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image064.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image236.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image062.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image200.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image056.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image100.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image030.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image188.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image208.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image096.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image054.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image014.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image244.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image060.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image218.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image008.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image052.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image210.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image102.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image028.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image020.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image088.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image048.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image242.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image212.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image178.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image012.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image238.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image198.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image120.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image108.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image098.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image058.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image018.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image010.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image234.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image172.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image214.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image070.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image034.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image038.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image226.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image118.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image202.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image194.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image220.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image004.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image204.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image050.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image192.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image206.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image224.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image190.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image046.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image066.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image076.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image110.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image042.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image232.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image228.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image006.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/spectrum/figures/image044.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/url.sty",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/hypernat.sty",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/liktransform.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MLP_SingleNode.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/category_rejBvsS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/correlationscatter__NoTransform_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/TMVAppFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/PDEFoam-foam_bw.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MVA-Likelihood.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/deviation_MLP_target_test_c0.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/CorrelationMatrixB.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/Schachbrett_ROC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/Rarity-Likelihood.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MLP.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/PDEFoam-foam_kernel_bw.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/CorrelationMatrixS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/linDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x02.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x12.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/funcDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/category_var4_cat1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/deviation_LD_target_test_c0.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/VariableTransforms.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/nonFuncDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MVA-MLP.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MVA-PDERS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/TMVARegGui.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/pders_gauss.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/variables_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/SVM.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/Schachbrett_both.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/correlationscatter__DecorrTransform_c1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/Rarity-Fisher.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MVA-Fisher.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/TMVAGui.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/BDTsketch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/noDep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/category_var4_cat2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/rulefitpath.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/knn_3d_s13_b7_x01.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/TMVAnalysisFlow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/rejBvsS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/pders_teepee.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/MVA-BDT.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/multiclass/TMVAMulticlassGui.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/multiclass/TMVAMulticlassRoc1vsAll.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-ce.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-split.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/tmva/UsersGuide/plots/cv/cv-workflows-retrain.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/JSROOT/figures/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000EA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000092.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200009D.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000DC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001F4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000B3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000058.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300004E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200022C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000103.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000207.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001B9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300022B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000020.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/spider1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300020D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300005F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001EF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000F1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000215.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000DB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000012.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000038.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para11.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000013.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001E4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001EE.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000039.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000222.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001C6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300005D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0800003F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000010.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000220.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000016.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000A0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200021A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300003E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001CA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200020B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200021E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300008D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000DA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000B1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200020F.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200009E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000221.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000A9.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000059.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000BE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300002F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300012D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001A1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300003A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000045.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/bp1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000B4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001B1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001FE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000AC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000B0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000C1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300002A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000C8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000223.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000054.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000FC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000DF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300004D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/image212.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000005.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000FE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/spider2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001B4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001BB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000204.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000031.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000028.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/image443.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000216.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300004B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001B3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000097.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000DE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000219.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001CC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300005C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300002B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000014.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000033.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000128.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000A5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000E3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000C3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000210.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200021B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000070.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000019.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000042.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000C6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000026.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300009F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001CF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060000C4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000007.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000202.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000057.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200020E.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000050.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para12.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001B5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000208.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000040.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/pad_02.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000AF.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001CE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000C7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001E7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000061.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200009C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000A6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000EF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000C9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080000A3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000025.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000BC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para10.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000213.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200003C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001BF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000109.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001B2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001EB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000027.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001C9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001B7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001C1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000004.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300021D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300004F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000052.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000205.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001BC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200021F.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300004C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001EC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300000B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000032.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000E4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000DD.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000034.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200020C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000017.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000060.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/function-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000EE.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/pad_01.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/mathtext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para13.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001C.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000105.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000200.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000211.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para14.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000AB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001EA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000056.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200022A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200009B.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/Minimization.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000EB.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000094.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000218.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000A7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/image145.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/rootlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001F9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001CB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001FD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001BD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000228.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300002D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000C5.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001E8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000041.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000053.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000102.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001B8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/th2poly1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000095.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001FF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200021C.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000036.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000022.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000F3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001BE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001F.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000A8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001A9.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000224.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000229.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300005E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000E2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000008.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001FA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000108.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000206.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300005A.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000023.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000049.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000096.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000225.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000ED.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000201.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001E6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000FF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000006.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000047.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000212.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000035.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001DF.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300003D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000009.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000015.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001A6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0600002E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000BD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/Integration.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000062.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000209.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0600003B.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001C8.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000037.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001DE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000043.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000018.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D7.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000227.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000EC.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000217.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000AE.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000203.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300001E.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001E0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000098.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200020A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000FA.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000214.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000024.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000CB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001CD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000099.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0300022D.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000021.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/0200009A.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000055.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030001FC.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000C2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000011.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001ED.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/para1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000226.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/080001FB.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000B2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000AD.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000AA.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000030.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/image144.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/03000093.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/02000101.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020001F0.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/020000A4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/030000D4.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/documentation/users-guide/pictures/060001B6.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/r/doc/users-guide/img/simplefit.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/r/doc/users-guide/img/minimization.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/r/doc/users-guide/img/logo.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/r/doc/users-guide/img/interpolation.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/bindings/r/doc/users-guide/img/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/geom/doc/v522/geom_prev3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/freetype/src/freetype-2.6.1.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v520/graf2d_02.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v520/graf2d_01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v600/lingrad.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v600/mathtext.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v600/ellipses.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v600/mixgrad.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/detail_view.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/file_contents.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/e5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/top_level.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/tutorials.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/iospad.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/tut_editor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v532/editors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v528/markers.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v528/itbf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v528/symbolitalic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v526/graphstruct.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v534/quartz2d.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/doc/v522/graf2d_01.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/exchange.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/star.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/pirate.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/circle.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/crosshair.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/top-right-corner.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gtk.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-v-double-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dotbox.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/xterm.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/right-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/hand1.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/left-ptr-watch.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gobbler.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/gumby.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-up-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-right-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/color-picker.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/fleur.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/hand2.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/top-left-corner.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-ask.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-left-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/spider.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/question-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/shuttle.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/spraycan.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-copy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-move.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/heart.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dot.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/left-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-link.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-down-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/Busy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/X-cursor.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/pencil.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/center-ptr.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/umbrella.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/plus.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/sb-h-double-arrow.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/gdk/win32/rc/dnd-none.cur",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf2d/win32gdk/gdk/src/glib/glib.rc",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v524/roofit_524_convolution.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v524/roofit_524_visualerror.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v524/roofit_524_derivatives.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v524/roofit_524_demo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v524/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/roofit/doc/v530/scan_cls.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/proof/afdsmgrd/afdsmgrd-v1.1.0.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/proof/doc/confman/img/sshcertauth-web.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v606/palette_112.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v606/ttree_makeselector_option_examples.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v610/ReverseAxis.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v610/NewBoxOption.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v610/NewMarkers.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_59.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_56.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_94.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_66.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_64.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_104.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_51.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_58.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_70.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_99.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_93.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_111.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_108.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_107.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_110.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_82.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_67.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_79.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_106.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_90.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_73.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_68.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/colz0.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_88.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_78.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_83.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_84.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_91.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_76.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_96.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_65.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_55.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_92.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_100.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_77.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_105.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_52.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_71.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_60.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_86.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/nostackb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_54.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_69.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_62.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_57.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_75.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_109.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_102.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_63.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_53.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_101.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_87.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_89.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_72.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_98.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_85.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_80.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_97.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_81.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_103.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_61.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_95.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/README/ReleaseNotes/v604/palette_74.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/lzma/src/xz-5.2.1-win32.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/lzma/src/xz-5.2.1.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/pcre/src/pcre-8.37.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v600/pal255.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hpxpyclassic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hlabmodern-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hpxmodern.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hpxpymodern.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hpxclassic.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hlabclassic-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hlabmodern.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/core/doc/v530/hlabclassic.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/math/smatrix/test/kalmam_slc3_ia32_gcc323.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/math/smatrix/test/testOperations_slc3_ia32_gcc323.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/math/unuran/src/unuran-1.8.0-root.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/HistFactoryTest.tar",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/stressHistFactory_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/stressRooStats_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/stressRooFit_ref.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/periodic/icons/Zr-loc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/periodic/icons/topbar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/RootShower/RootShower.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/RootShower/RootShower.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/RootShower/Physics.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/histviewer/hist6_8.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/test/histviewer/hist4_5.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/symbol.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/cour.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz4Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/courbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/comicbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz3Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeMonoBoldOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz2Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/verdanaz.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/georgiaz.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/wingding.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz1Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/timesi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz1SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/trebuc.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSansOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/impact.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXGeneralBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/couri.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/arial.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXGeneralItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/webdings.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/times.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/timesbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/arialbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSans.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/arialbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/ariali.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXGeneral.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/courbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/georgiai.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/BlackChancery.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/monotype.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSerifItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSerifBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSerif.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/verdana.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz4SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz2SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/trebucbd.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz3SymBol.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXGeneralBolIta.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/trebucit.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/trebucbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSerifBoldItalic.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/georgiab.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSansBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeMono.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeMonoBold.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/STIXSiz5Sym.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/georgia.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/DroidSansFallback.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/verdanab.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeSansBoldOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/timesbi.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/FreeMonoOblique.otf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/ariblk.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/comic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/fonts/verdanai.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/notebook/kernels/root/logo-64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/notebook/custom/root-banner_99x33.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/notebook/custom/root-logo-darkblue_33x33.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/html/shadow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/html/shadowAlpha.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/img/RootIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_444444_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_ffffff_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_cc0000_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_555555_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_777777_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/etc/http/style/images/ui-icons_777620_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/gallery.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/image/rose512.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/eve/swap.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/eve/nasashuttle.3ds",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/eve/Default.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/mlp/mlpHiggs.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/spectrum/TSpectrum.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/pythia8.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/packtest2.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/event.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/ntprndm.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/packtest1.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/proof/packtest3.par",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/quadp/stock.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/fitsio/sample3.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/fitsio/sample1.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/fitsio/sample5.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/fitsio/sample4.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/fitsio/sample2.fits",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/tmva/tmva_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/tmva/line-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/tmva/sigmoid-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/tmva/data/toy_sigbkg_categ_offset.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/tmva/data/toy_sigbkg_categ_varoff.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/dataframe/df017_vecOpsHEP.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/doc/v528/mass_spectrum.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/tutorials/gui/worldmap.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/net/http/openui5/openui5.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/memstat/doc/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/memstat/doc/caution.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/memstat/doc/tip.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/memstat/doc/note.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/memstat/doc/important.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/rootsl/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/rootsl/English.lproj/schema.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/misc/rootql/English.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/doc/v520/graf3d_eve-news-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/doc/v520/graf3d_eve-news-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/doc/v520/graf3d_eve-news-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/doc/v530/glvox1.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/graf3d/doc/v530/glvox2.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/doc/v520/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/doc/v524/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/doc/v522/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/qtgsi/test/example2/test.root",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/qtgsi/test/example2/images/qtroot_canvas.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/qtgsi/test/example2/images/h2_t.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/qtgsi/test/example2/images/h1_t.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/doc/v520/gui_availabledrives.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/doc/v520/gui_contextmenu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/doc/v522/gui_tgrecorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-root-6.16.00-xnzyazctulzt2zrptkdzd2ci3ndyz67t/spack-src/gui/doc/v522/gui_tgpack.png"
    ],
    "total_files": 18723
}