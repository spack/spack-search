{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 56 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2009 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '/^# Generated shell functions inserted here/q' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_XSI_SHELLFNS\n\n  sed -n '/^# Generated shell functions inserted here/,$p' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\tif test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]][[,.]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES\n# --------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX\n# -----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nAC_LINK_IFELSE(AC_LANG_PROGRAM,[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`print -r -- -n 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*linux*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*linux*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[AC_CHECK_TOOL(AR, ar, false)\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1])\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`func_fallback_echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nvoid fnord () __attribute__((visibility(\"default\")));\n#endif\n\nvoid fnord () { int i=42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhaiku*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method == \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nconst struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-Xcompiler -fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\nAC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"L\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw* | cegcc*)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"L\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n        save_LDFLAGS=\"$LDFLAGS\"\n        LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n        AC_LINK_IFELSE(int foo(void) {},\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n        )\n        LDFLAGS=\"$save_LDFLAGS\"\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],\n    [[If ld is used when linking, flag to hardcode $libdir into a binary\n    during linking.  This must work even if $libdir does not exist]])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [fix_srcfile_path], [1],\n    [Fix the shell variable $srcfile for the compiler])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n        # as there is no search path for DLLs.\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n        _LT_TAGVAR(always_export_symbols, $1)=no\n        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n          # If the export-symbols file already is a .def file (1st line\n          # is EXPORTS), use it as is; otherwise, prepend...\n          _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    cp $export_symbols $output_objdir/$soname.def;\n          else\n\t    echo EXPORTS > $output_objdir/$soname.def;\n\t    cat $export_symbols >> $output_objdir/$soname.def;\n          fi~\n          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n        else\n          _LT_TAGVAR(ld_shlibs, $1)=no\n        fi\n        ;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${F77-\"f77\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${FC-\"f95\"}\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_XSI_SHELLFNS\n# ---------------------\n# Bourne and XSI compatible variants of some useful shell functions.\nm4_defun([_LT_PROG_XSI_SHELLFNS],\n[case $xsi_shell in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nfunc_stripname ()\n{\n  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n  # positional parameters, so assign one to ordinary parameter first.\n  func_stripname_result=${3}\n  func_stripname_result=${func_stripname_result#\"${1}\"}\n  func_stripname_result=${func_stripname_result%\"${2}\"}\n}\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=${1%%=*}\n  func_opt_split_arg=${1#*=}\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  case ${1} in\n    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n    *)    func_lo2o_result=${1} ;;\n  esac\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=${1%.*}.lo\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=$(( $[*] ))\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=${#1}\n}\n\n_LT_EOF\n    ;;\n  *) # Bourne compatible functions.\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n}\n\ndnl func_dirname_and_basename\ndnl A portable version of this function is already defined in general.m4sh\ndnl so there is no need for it here.\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n  case ${2} in\n    .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n    *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n}\n\n# sed scripts:\nmy_sed_long_opt='1s/^\\(-[[^=]]*\\)=.*/\\1/;q'\nmy_sed_long_arg='1s/^-[[^=]]*=//'\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=`$ECHO \"${1}\" | $SED \"$my_sed_long_opt\"`\n  func_opt_split_arg=`$ECHO \"${1}\" | $SED \"$my_sed_long_arg\"`\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[[^.]]*$/.lo/'`\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=`expr \"$[@]\"`\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=`expr \"$[1]\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n}\n\n_LT_EOF\nesac\n\ncase $lt_shell_append in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]+=\\$[2]\"\n}\n_LT_EOF\n    ;;\n  *)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]=\\$$[1]\\$[2]\"\n}\n\n_LT_EOF\n    ;;\n  esac\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/ltmain.sh": "# Generated from ltmain.m4sh.\n\n# libtool (GNU libtool 1.3134 2009-11-29) 2.2.7a\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --no-finish          let install mode avoid finish commands\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool 1.3134 2009-11-29) 2.2.7a\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=2.2.7a\nTIMESTAMP=\" 1.3134 2009-11-29\"\npackage_revision=1.3134\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\n# Only set LANG and LC_ALL to C if already set.\n# These must not be set unconditionally because not all systems understand\n# e.g. LANG=C (notably SCO).\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\n\n$lt_unset CDPATH\n\n\n\n\n\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\n: ${ECHO=$as_echo}\n: ${EGREP=\"/bin/grep -E\"}\n: ${FGREP=\"/bin/grep -F\"}\n: ${GREP=\"/bin/grep\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SED=\"/mount/endor/wildenhu/local-x86_64/bin/sed\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n  func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n}\n\n# Generated shell functions inserted here.\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=:\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname${mode+: }$mode: $*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname${mode+: }$mode: \"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname${mode+: }$mode: warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# //\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $SED -n '/^# Usage:/,/^#  *-h/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(automake --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(autoconf --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n     }' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    func_error \"missing argument for $1\"\n    exit_cmd=exit\n}\n\nexit_cmd=:\n\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\n# $mode is unset\nnonopt=\nexecute_dlfiles=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\nopt_dry_run=false\nopt_finish=:\nopt_duplicate_deps=false\nopt_silent=false\nopt_debug=:\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# Parse options once, thoroughly.  This comes as soon as possible in\n# the script to make things like `libtool --version' happen quickly.\n{\n\n  # Shorthand for --mode=foo, only valid as the first argument\n  case $1 in\n  clean|clea|cle|cl)\n    shift; set dummy --mode clean ${1+\"$@\"}; shift\n    ;;\n  compile|compil|compi|comp|com|co|c)\n    shift; set dummy --mode compile ${1+\"$@\"}; shift\n    ;;\n  execute|execut|execu|exec|exe|ex|e)\n    shift; set dummy --mode execute ${1+\"$@\"}; shift\n    ;;\n  finish|finis|fini|fin|fi|f)\n    shift; set dummy --mode finish ${1+\"$@\"}; shift\n    ;;\n  install|instal|insta|inst|ins|in|i)\n    shift; set dummy --mode install ${1+\"$@\"}; shift\n    ;;\n  link|lin|li|l)\n    shift; set dummy --mode link ${1+\"$@\"}; shift\n    ;;\n  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n    shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n    ;;\n  esac\n\n  # Parse non-mode specific arguments:\n  while test \"$#\" -gt 0; do\n    opt=\"$1\"\n    shift\n\n    case $opt in\n      --config)\t\tfunc_config\t\t\t\t\t;;\n\n      --debug)\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\topt_debug='set -x'\n\t\t\t$opt_debug\n\t\t\t;;\n\n      -dlopen)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\texecute_dlfiles=\"$execute_dlfiles $1\"\n\t\t\tshift\n\t\t\t;;\n\n      --dry-run | -n)\topt_dry_run=:\t\t\t\t\t;;\n      --features)       func_features\t\t\t\t\t;;\n      --finish)\t\tmode=\"finish\"\t\t\t\t\t;;\n      --no-finish)\topt_finish=false\t\t\t\t;;\n\n      --mode)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tcase $1 in\n\t\t\t  # Valid mode arguments:\n\t\t\t  clean)\t;;\n\t\t\t  compile)\t;;\n\t\t\t  execute)\t;;\n\t\t\t  finish)\t;;\n\t\t\t  install)\t;;\n\t\t\t  link)\t\t;;\n\t\t\t  relink)\t;;\n\t\t\t  uninstall)\t;;\n\n\t\t\t  # Catch anything else as an error\n\t\t\t  *) func_error \"invalid argument for $opt\"\n\t\t\t     exit_cmd=exit\n\t\t\t     break\n\t\t\t     ;;\n\t\t        esac\n\n\t\t\tmode=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\n      --preserve-dup-deps)\n\t\t\topt_duplicate_deps=:\t\t\t\t;;\n\n      --quiet|--silent)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=:\n\t\t\topt_verbose=false\n\t\t\t;;\n\n      --no-quiet|--no-silent)\n\t\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\t;;\n\n      --verbose| -v)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\topt_verbose=:\n\t\t\t;;\n\n      --no-verbose)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_verbose=false\n\t\t\t;;\n\n      --tag)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tpreserve_args=\"$preserve_args $opt $1\"\n\t\t\tfunc_enable_tag \"$1\"\t# tagname is set here\n\t\t\tshift\n\t\t\t;;\n\n      # Separate optargs to long options:\n      -dlopen=*|--mode=*|--tag=*)\n\t\t\tfunc_opt_split \"$opt\"\n\t\t\tset dummy \"$func_opt_split_opt\" \"$func_opt_split_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t\t;;\n      --help)\t\topt_help=:\t\t\t\t\t;;\n      --help-all)\topt_help=': help-all'\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t\t;;\n\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\"\t;;\n\n      *)\t\tnonopt=\"$opt\"\n\t\t\tbreak\n\t\t\t;;\n    esac\n  done\n\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* )\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps\n      ;;\n  esac\n\n  # Having warned about all mis-specified options, bail out if\n  # anything was wrong.\n  $exit_cmd $EXIT_FAILURE\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n$opt_help || {\n  # Sanity checks first:\n  func_check_version_match\n\n  if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n    func_fatal_configuration \"not configured to build any kind of library\"\n  fi\n\n  test -z \"$mode\" && func_fatal_error \"error: you must specify a MODE.\"\n\n\n  # Darwin sucks\n  eval \"std_shrext=\\\"$shrext_cmds\\\"\"\n\n\n  # Only execute mode is allowed to have -dlopen flags.\n  if test -n \"$execute_dlfiles\" && test \"$mode\" != execute; then\n    func_error \"unrecognized option \\`-dlopen'\"\n    $ECHO \"$help\" 1>&2\n    exit $EXIT_FAILURE\n  fi\n\n  # Change the help message to a mode-specific one.\n  generic_help=\"$help\"\n  help=\"Try \\`$progname --help --mode=$mode' for more information.\"\n}\n\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_ltwrapper_scriptname_result=\"\"\n    if func_ltwrapper_executable_p \"$1\"; then\n\tfunc_dirname_and_basename \"$1\" \"\" \".\"\n\tfunc_stripname '' '.exe' \"$func_basename_result\"\n\tfunc_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n    fi\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval \"cmd=\\\"$cmd\\\"\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n        func_quote_for_eval \"$arg\"\n\tCC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_quote_for_eval \"$arg\"\n\t      CC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          pie_flag=\"$pie_flag $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  later=\"$later $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_quote_for_eval \"$arg\"\n\t    lastarg=\"$lastarg $func_quote_for_eval_result\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  base_compile=\"$base_compile $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_quote_for_eval \"$lastarg\"\n      base_compile=\"$base_compile $func_quote_for_eval_result\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      removelist=\"$removelist $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    removelist=\"$removelist $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    if test -n \"$fix_srcfile_path\"; then\n      eval \"srcfile=\\\"$fix_srcfile_path\\\"\"\n    fi\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tcommand=\"$command -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tcommand=\"$command -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      command=\"$command$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to building PIC objects only\n  -prefer-non-pic   try to building non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $execute_dlfiles; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  dir=\"$dir/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval test -z \\\"\\$$shlibpath_var\\\"; then\n\teval $shlibpath_var=\\$dir\n      else\n\teval $shlibpath_var=\\$dir:\\$$shlibpath_var\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_quote_for_eval \"$file\"\n      args=\"$args $func_quote_for_eval_result\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libdirs=\"$nonopt\"\n    admincmds=\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for dir\n      do\n\tlibdirs=\"$libdirs $dir\"\n      done\n\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || admincmds=\"$admincmds\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    echo \"----------------------------------------------------------------------\"\n    echo \"Libraries have been installed in:\"\n    for libdir in $libdirs; do\n      $ECHO \"   $libdir\"\n    done\n    echo\n    echo \"If you ever happen to want to link against installed libraries\"\n    echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n    echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n    echo \"flag during linking and do at least one of the following:\"\n    if test -n \"$shlibpath_var\"; then\n      echo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n      echo \"     during execution\"\n    fi\n    if test -n \"$runpath_var\"; then\n      echo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n      echo \"     during linking\"\n    fi\n    if test -n \"$hardcode_libdir_flag_spec\"; then\n      libdir=LIBDIR\n      eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\n      $ECHO \"   - use the \\`$flag' linker flag\"\n    fi\n    if test -n \"$admincmds\"; then\n      $ECHO \"   - have your system administrator run these commands:$admincmds\"\n    fi\n    if test -f /etc/ld.so.conf; then\n      echo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n    fi\n    echo\n\n    echo \"See any operating system documentation about shared libraries for\"\n    case $host in\n      solaris2.[6789]|solaris2.1[0-9])\n        echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\techo \"pages.\"\n\t;;\n      *)\n        echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n        ;;\n    esac\n    echo \"----------------------------------------------------------------------\"\n    exit $EXIT_SUCCESS\n}\n\ntest \"$mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    install_prog=\"$install_prog$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfiles=\"$files $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      install_prog=\"$install_prog $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      install_shared_prog=\"$install_shared_prog $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tinstall_shared_prog=\"$install_shared_prog -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tstaticlibs=\"$staticlibs $file\"\n\t;;\n\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) current_libdirs=\"$current_libdirs $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) future_libdirs=\"$future_libdirs $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tdir=\"$dir$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && staticlibs=\"$staticlibs $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\" && $opt_finish; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_verbose \"extracting global C symbols from \\`$progfile'\"\n\t    $opt_dry_run || eval \"$NM $progfile | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      $EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      ${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' < \"$nlist\" > \"$export_symbols\"\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                echo EXPORTS > \"$output_objdir/$outputname.def\"\n                cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      ${SED} -e 's/\\([].[*^$]\\)/\\\\\\1/g' -e 's/^/ /' -e 's/$/$/' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"\n\t      $GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          echo EXPORTS > \"$output_objdir/$outputname.def\"\n\t          cat \"$nlist\" >> \"$output_objdir/$outputname.def\"\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n\t  $opt_dry_run || {\n\t    $ECHO \": $name \" >> \"$nlist\"\n\t    eval \"$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t  }\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\n\"\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* )\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* DATA imports from DLLs on WIN32 con't be const, because\n   runtime relocations are performed -- see ld's documentation\n   on pseudo-relocs.  */\"\n\t    lt_dlsym_const= ;;\n\t  *osf5*)\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* This system does not cope well with relocations in const data */\"\n\t    lt_dlsym_const= ;;\n\t  *)\n\t    lt_dlsym_const=const ;;\n\t  esac\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\nextern $lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\n$lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) symtab_cflags=\"$symtab_cflags $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    if $OBJDUMP -f \"$1\" | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pe-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      win32_nmres=`$NM -f posix -A \"$1\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\\\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\\"\\$relink_command\\\" 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t# fixup the dll searchpath if we need to.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n\"\n\tcase $host in\n\t# Backslashes separate directories on plain windows\n\t*-*-mingw | *-*-os2* | *-cegcc*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\n\t*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\tesac\n\t$ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_to_host_path arg\n#\n# Convert paths to host format when used with build tools.\n# Intended for use with \"native\" mingw (where libtool itself\n# is running under the msys shell), or in the following cross-\n# build environments:\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n# where wine is equipped with the `winepath' executable.\n# In the native mingw case, the (msys) shell automatically\n# converts paths for any non-msys applications it launches,\n# but that facility isn't available from inside the cwrapper.\n# Similar accommodations are necessary for $host mingw and\n# $build cygwin.  Calling this function does no harm for other\n# $host/$build combinations not listed above.\n#\n# ARG is the path (on $build) that should be converted to\n# the proper representation for $host. The result is stored\n# in $func_to_host_path_result.\nfunc_to_host_path ()\n{\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        case $build in\n          *mingw* ) # actually, msys\n            # awkward: cmd appends spaces to result\n            func_to_host_path_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n              $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_path_result=`cygpath -w \"$1\" |\n\t      $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # Unfortunately, winepath does not exit with a non-zero\n            # error code, so we are forced to check the contents of\n            # stdout. On the other hand, if the command is not\n            # found, the shell will set an exit code of 127 and print\n            # *an error message* to stdout. So we must check for both\n            # error code of zero AND non-empty stdout, which explains\n            # the odd construction:\n            func_to_host_path_tmp1=`winepath -w \"$1\" 2>/dev/null`\n            if test \"$?\" -eq 0 && test -n \"${func_to_host_path_tmp1}\"; then\n              func_to_host_path_result=`$ECHO \"$func_to_host_path_tmp1\" |\n                $SED -e \"$lt_sed_naive_backslashify\"`\n            else\n              # Allow warning below.\n              func_to_host_path_result=\n            fi\n            ;;\n        esac\n        if test -z \"$func_to_host_path_result\" ; then\n          func_error \"Could not determine host path corresponding to\"\n          func_error \"  \\`$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback:\n          func_to_host_path_result=\"$1\"\n        fi\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_path\n\n# func_to_host_pathlist arg\n#\n# Convert pathlists to host format when used with build tools.\n# See func_to_host_path(), above. This function supports the\n# following $build/$host combinations (but does no harm for\n# combinations not listed here):\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n#\n# Path separators are also converted from $build format to\n# $host format. If ARG begins or ends with a path separator\n# character, it is preserved (but converted to $host format)\n# on output.\n#\n# ARG is a pathlist (on $build) that should be converted to\n# the proper representation on $host. The result is stored\n# in $func_to_host_pathlist_result.\nfunc_to_host_pathlist ()\n{\n  func_to_host_pathlist_result=\"$1\"\n  if test -n \"$1\"; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        # Remove leading and trailing path separator characters from\n        # ARG. msys behavior is inconsistent here, cygpath turns them\n        # into '.;' and ';.', and winepath ignores them completely.\n\tfunc_stripname : : \"$1\"\n        func_to_host_pathlist_tmp1=$func_stripname_result\n        case $build in\n          *mingw* ) # Actually, msys.\n            # Awkward: cmd appends spaces to result.\n            func_to_host_pathlist_result=`\n\t      ( cmd //c echo \"$func_to_host_pathlist_tmp1\" ) 2>/dev/null |\n\t      $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_pathlist_result=`cygpath -w -p \"$func_to_host_pathlist_tmp1\" |\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # unfortunately, winepath doesn't convert pathlists\n            func_to_host_pathlist_result=\"\"\n            func_to_host_pathlist_oldIFS=$IFS\n            IFS=:\n            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do\n              IFS=$func_to_host_pathlist_oldIFS\n              if test -n \"$func_to_host_pathlist_f\" ; then\n                func_to_host_path \"$func_to_host_pathlist_f\"\n                if test -n \"$func_to_host_path_result\" ; then\n                  if test -z \"$func_to_host_pathlist_result\" ; then\n                    func_to_host_pathlist_result=\"$func_to_host_path_result\"\n                  else\n                    func_append func_to_host_pathlist_result \";$func_to_host_path_result\"\n                  fi\n                fi\n              fi\n            done\n            IFS=$func_to_host_pathlist_oldIFS\n            ;;\n        esac\n        if test -z \"$func_to_host_pathlist_result\"; then\n          func_error \"Could not determine the host path(s) corresponding to\"\n          func_error \"  \\`$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback. This may break if $1 contains DOS-style drive\n          # specifications. The fix is not to complicate the expression\n          # below, but for the user to provide a working wine installation\n          # with winepath so that path translation in the cross-to-mingw\n          # case works properly.\n          lt_replace_pathsep_nix_to_dos=\"s|:|;|g\"\n          func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp1\" |\\\n            $SED -e \"$lt_replace_pathsep_nix_to_dos\"`\n        fi\n        # Now, add the leading and trailing path separators back\n        case \"$1\" in\n          :* ) func_to_host_pathlist_result=\";$func_to_host_pathlist_result\"\n            ;;\n        esac\n        case \"$1\" in\n          *: ) func_append func_to_host_pathlist_result \";\"\n            ;;\n        esac\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_pathlist\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n\n   Currently, it simply execs the wrapper *script* \"$SHELL $output\",\n   but could eventually absorb all of the scripts functionality and\n   exec $objdir/$outputname directly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#undef LTWRAPPER_DEBUGPRINTF\n#if defined LT_DEBUGWRAPPER\n# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args\nstatic void\nltwrapper_debugprintf (const char *fmt, ...)\n{\n    va_list args;\n    va_start (args, fmt);\n    (void) vfprintf (stderr, fmt, args);\n    va_end (args);\n}\n#else\n# define LTWRAPPER_DEBUGPRINTF(args)\n#endif\n\nconst char *program_name = NULL;\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_fatal (const char *message, ...);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nconst char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_pathlist \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_pathlist \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n#define LTWRAPPER_OPTION_PREFIX_LENGTH  5\n\nstatic const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\n\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) argv[0]      : %s\\n\", argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) program_name : %s\\n\", program_name));\n\n  /* very simple arg parsing; don't want to rely on getopt */\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n    }\n\n  newargz = XMALLOC (char *, argc + 1);\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (\"Couldn't find %s\", argv[0]);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (before symlink chase) at : %s\\n\",\n\t\t\t  tmp_pathspec));\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (after symlink chase) at : %s\\n\",\n\t\t\t  actual_cwrapper_path));\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(main) libtool target name: %s\\n\",\n\t\t\t  target_name));\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (\"Unrecognized option in %s namespace: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\n  LTWRAPPER_DEBUGPRINTF     ((\"(main) lt_argv_zero : %s\\n\", (lt_argv_zero ? lt_argv_zero : \"<NULL>\")));\n  for (i = 0; i < newargc; i++)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"(main) newargz[%d]   : %s\\n\", i, (newargz[i] ? newargz[i] : \"<NULL>\")));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      LTWRAPPER_DEBUGPRINTF ((\"(main) failed to launch target \\\"%s\\\": errno = %d\\n\", lt_argv_zero, errno));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (\"Memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(check_executable)  : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(make_executable)   : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(find_executable)   : %s\\n\",\n\t\t\t  wrapper ? (*wrapper ? wrapper : \"EMPTY!\") : \"NULL!\"));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (\"getcwd failed\");\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (\"getcwd failed\");\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"checking path component for symlinks: %s\\n\",\n\t\t\t      tmp_pathspec));\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  char *errstr = strerror (errno);\n\t  lt_fatal (\"Error accessing file %s (%s)\", tmp_pathspec, errstr);\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (\"Could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nstatic void\nlt_error_core (int exit_status, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s: %s: \", program_name, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_setenv) setting '%s' to '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n              $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t           -e 's/^/  fputs (\"/' -e 's/$/\\\\n\", f);/'\n\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval \"$file_magic_cmd \\\"\\$1\\\" 2>/dev/null\" | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      dlfiles=\"$dlfiles $arg\"\n\t    else\n\t      dlprefiles=\"$dlprefiles $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) deplibs=\"$deplibs $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      moreargs=\"$moreargs $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      dlfiles=\"$dlfiles $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    dlprefiles=\"$dlprefiles $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) rpath=\"$rpath $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) xrpath=\"$xrpath $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  weak_libs=\"$weak_libs $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname '-L' '' \"$arg\"\n\tdir=$func_stripname_result\n\tif test -z \"$dir\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"*) ;;\n\t*)\n\t  deplibs=\"$deplibs -L$dir\"\n\t  lib_search_path=\"$lib_search_path $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-linux*)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tdeplibs=\"$deplibs $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) xrpath=\"$xrpath $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $wl$func_quote_for_eval_result\"\n\t  linker_flags=\"$linker_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler\n      # -r[0-9][0-9]* specifies the processor on the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler\n      # +DA*, +DD* enable 64-bit mode on the HP compiler\n      # -q* pass through compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* pass through architecture-specific\n      # compiler args for GCC\n      # -F/path gives path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC\n      # @file GCC response files\n      # -tp=* Portland pgcc target processor selection\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        compiler_flags=\"$compiler_flags $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tobjs=\"$objs $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tdlfiles=\"$dlfiles $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      dlprefiles=\"$dlprefiles $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tdeplibs=\"$deplibs $arg\"\n\told_deplibs=\"$old_deplibs $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  dlfiles=\"$dlfiles $arg\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  dlprefiles=\"$dlprefiles $arg\"\n\t  prev=\n\telse\n\t  deplibs=\"$deplibs $arg\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval \"arg=\\\"$export_dynamic_flag_spec\\\"\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval \"sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\"\n    eval \"sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_duplicate_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\tesac\n      fi\n      libs=\"$libs $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) specialdeplibs=\"$specialdeplibs $pre_post_deps\" ;;\n\t  esac\n\t  pre_post_deps=\"$pre_post_deps $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  case $lib in\n\t  *.la)\tfunc_source \"$lib\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) deplibs=\"$deplibs $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    compiler_flags=\"$compiler_flags $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    dir=$func_stripname_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) xrpath=\"$xrpath $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la) lib=\"$deplib\" ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      newdlprefiles=\"$newdlprefiles $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      newdlfiles=\"$newdlfiles $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) new_inherited_linker_flags=\"$new_inherited_linker_flags $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && dlfiles=\"$dlfiles $dlopen\"\n\t  test -n \"$dlpreopen\" && dlprefiles=\"$dlprefiles $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    convenience=\"$convenience $ladir/$objdir/$old_library\"\n\t    old_convenience=\"$old_convenience $ladir/$objdir/$old_library\"\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tfor l in $old_library $library_names; do\n\t  linklib=\"$l\"\n\tdone\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    dlprefiles=\"$dlprefiles $lib $dependency_libs\"\n\t  else\n\t    newdlfiles=\"$newdlfiles $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$libdir\"\n\t    absdir=\"$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t  # are required to link).\n\t  if test -n \"$old_library\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$old_library\"\n\t    # Keep a list of preopened convenience libraries to check\n\t    # that they are being used correctly in the link pass.\n\t    test -z \"$libdir\" && \\\n\t\tdlpreconveniencelibs=\"$dlpreconveniencelibs $dir/$old_library\"\n\t  # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t  elif test -n \"$dlname\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$dlname\"\n\t  else\n\t    newdlprefiles=\"$newdlprefiles $dir/$linklib\"\n\t  fi\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  newlib_search_path=\"$newlib_search_path $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) temp_rpath=\"$temp_rpath$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    eval \"libname=\\\"$libname_spec\\\"\"\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval \"soname=\\\"$soname_spec\\\"\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) compile_shlibpath=\"$compile_shlibpath$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) xrpath=\"$xrpath $temp_xrpath\";;\n\t\t   esac;;\n\t      *) temp_deplibs=\"$temp_deplibs $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  newlib_search_path=\"$newlib_search_path $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=\"$func_dirname_result\"\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      compiler_flags=\"$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      linker_flags=\"$linker_flags -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) lib_search_path=\"$lib_search_path $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\$$var\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\$tmp_libs\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  tmp_libs=\"$tmp_libs $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      objs=\"$objs$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\teval \"libname=\\\"$libname_spec\\\"\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\t  eval \"libname=\\\"$libname_spec\\\"\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  libobjs=\"$libobjs $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  verstring=\"$verstring:${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      libobjs=\"$libobjs $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       removelist=\"$removelist $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\toldlibs=\"$oldlibs $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  temp_xrpath=\"$temp_xrpath -R$libdir\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlfiles=\"$dlfiles $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlprefiles=\"$dlprefiles $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      deplibs=\"$deplibs -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  eval \"libname=\\\"$libname_spec\\\"\"\n\t\t  eval \"deplib_matches=\\\"$library_names_spec\\\"\"\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    eval \"libname=\\\"$libname_spec\\\"\"\n\t\t    eval \"deplib_matches=\\\"$library_names_spec\\\"\"\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\teval \"libname=\\\"$libname_spec\\\"\"\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval \"$file_magic_cmd \\\"\\$potlib\\\"\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tnewdeplibs=\"$newdeplibs $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\teval \"libname=\\\"$libname_spec\\\"\"\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    hardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t\tdep_rpath=\"$dep_rpath $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    if test -n \"$hardcode_libdir_flag_spec_ld\"; then\n\t      eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec_ld\\\"\"\n\t    else\n\t      eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    fi\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      rpath=\"$rpath$dir:\"\n\t    done\n\t    eval $runpath_var=\\$rpath\\$$runpath_var\n\t    export $runpath_var\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval $shlibpath_var=\\$shlibpath\\$$shlibpath_var\n\t  export $shlibpath_var\n\tfi\n\n\t# Get the real and link names of the library.\n\teval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\teval \"library_names=\\\"$library_names_spec\\\"\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval \"soname=\\\"$soname_spec\\\"\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  linknames=\"$linknames $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  delfiles=\"$delfiles $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      eval \"cmd=\\\"$cmd\\\"\"\n\t      func_len \" $cmd\"\n\t      len=$func_len_result\n\t      if test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || $ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    tmp_deplibs=\"$tmp_deplibs $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval \"libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    generated=\"$generated $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    libobjs=\"$libobjs $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval \"flag=\\\"$thread_safe_flag_spec\\\"\"\n\t  linker_flags=\"$linker_flags $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || (cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U) || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval \"test_cmds=\\\"$module_expsym_cmds\\\"\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval \"test_cmds=\\\"$module_cmds\\\"\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval \"test_cmds=\\\"$archive_expsym_cmds\\\"\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval \"test_cmds=\\\"$archive_cmds\\\"\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    delfiles=\"$delfiles $output\"\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    delfiles=\"$delfiles $output\"\n\t    output=$firstobj\\\"$file_list_spec$output\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval \"test_cmds=\\\"$reload_cmds\\\"\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval \"concat_cmds=\\\"$reload_cmds\\\"\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval \"concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval \"concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\"\n\t      if test -n \"$last_robj\"; then\n\t        eval \"concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\"\n\t      fi\n\t      delfiles=\"$delfiles $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval \"concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\"\n\t      if test -n \"$last_robj\"; then\n\t\teval \"concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || $ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval \"libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval \"cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  libobjs=\"$libobjs $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval \"cmd=\\\"$cmd\\\"\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || (cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname) || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval \"tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || echo timestamp > $libobj || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      compile_command=\"$compile_command ${wl}-bind_at_load\"\n\t      finalize_command=\"$finalize_command ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      compile_command=\"$compile_command $compile_deplibs\"\n      finalize_command=\"$finalize_command $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval \"rpath=\\\" $hardcode_libdir_flag_spec\\\"\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_perm_rpath=\"$finalize_perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval \"rpath=\\\" $hardcode_libdir_flag_spec\\\"\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    oldobjs=\"$oldobjs $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tgenerated=\"$generated $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\toldobjs=\"$oldobjs $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  oldobjs=\"$oldobjs $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      oldobjs=\"$oldobjs $gentop/$newobj\"\n\t      ;;\n\t    *) oldobjs=\"$oldobjs $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\teval \"cmds=\\\"$old_archive_cmds\\\"\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval \"test_cmds=\\\"$old_archive_cmds\\\"\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval \"concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval \"cmds=\\\"\\$concat_cmds\\\"\"\n\t  else\n\t    eval \"cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tnewdependency_libs=\"$newdependency_libs $libdir/$name\"\n\t\t;;\n\t      *) newdependency_libs=\"$newdependency_libs $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlfiles=\"$newdlfiles $libdir/$name\"\n\t\t;;\n\t      *) newdlfiles=\"$newdlfiles $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlprefiles=\"$newdlprefiles $libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlfiles=\"$newdlfiles $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlprefiles=\"$newdlprefiles $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$mode\" = link || test \"$mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) RM=\"$RM $arg\"; rmforce=yes ;;\n      -*) RM=\"$RM $arg\" ;;\n      *) files=\"$files $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    origobjdir=\"$objdir\"\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\tobjdir=\"$origobjdir\"\n      else\n\tobjdir=\"$dir/$origobjdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$mode\" = uninstall && objdir=\"$dir\"\n\n      # Remember objdir for removal later, being careful to avoid duplicates\n      if test \"$mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $objdir \"*) ;;\n\t  *) rmdirs=\"$rmdirs $objdir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    rmfiles=\"$rmfiles $objdir/$n\"\n\t  done\n\t  test -n \"$old_library\" && rmfiles=\"$rmfiles $objdir/$old_library\"\n\n\t  case \"$mode\" in\n\t  clean)\n\t    case \"  $library_names \" in\n\t    # \"  \" in the beginning catches empty $dlname\n\t    *\" $dlname \"*) ;;\n\t    *) rmfiles=\"$rmfiles $objdir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && rmfiles=\"$rmfiles $objdir/$name $objdir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    rmfiles=\"$rmfiles $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      rmfiles=\"$rmfiles $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    rmfiles=\"$rmfiles $objdir/$name $objdir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      rmfiles=\"$rmfiles $objdir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      rmfiles=\"$rmfiles $objdir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n    objdir=\"$origobjdir\"\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$mode\" = uninstall || test \"$mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/plugin.c": "/* Support for GCC plugin mechanism.\n   Copyright (C) 2009-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n/* This file contains the support for GCC plugin mechanism based on the\n   APIs described in doc/plugin.texi.  */\n\n#include \"config.h\"\n#include \"system.h\"\n#include \"coretypes.h\"\n#include \"options.h\"\n#include \"tree-pass.h\"\n#include \"diagnostic-core.h\"\n#include \"flags.h\"\n#include \"intl.h\"\n#include \"plugin.h\"\n\n#ifdef ENABLE_PLUGIN\n#include \"plugin-version.h\"\n#endif\n\n#define GCC_PLUGIN_STRINGIFY0(X) #X\n#define GCC_PLUGIN_STRINGIFY1(X) GCC_PLUGIN_STRINGIFY0 (X)\n\n/* Event names as strings.  Keep in sync with enum plugin_event.  */\nstatic const char *plugin_event_name_init[] =\n{\n# define DEFEVENT(NAME) GCC_PLUGIN_STRINGIFY1 (NAME),\n# include \"plugin.def\"\n# undef DEFEVENT\n};\n\n/* A printf format large enough for the largest event above.  */\n#define FMT_FOR_PLUGIN_EVENT \"%-32s\"\n\nconst char **plugin_event_name = plugin_event_name_init;\n\n/* Event hashtable helpers.  */\n\nstruct event_hasher : nofree_ptr_hash <const char *>\n{\n  static inline hashval_t hash (const char **);\n  static inline bool equal (const char **, const char **);\n};\n\n/* Helper function for the event hash table that hashes the entry V.  */\n\ninline hashval_t\nevent_hasher::hash (const char **v)\n{\n  return htab_hash_string (*v);\n}\n\n/* Helper function for the event hash table that compares the name of an\n   existing entry (S1) with the given string (S2).  */\n\ninline bool\nevent_hasher::equal (const char **s1, const char **s2)\n{\n  return !strcmp (*s1, *s2);\n}\n\n/* A hash table to map event names to the position of the names in the\n   plugin_event_name table.  */\nstatic hash_table<event_hasher> *event_tab;\n\n/* Keep track of the limit of allocated events and space ready for\n   allocating events.  */\nstatic int event_last = PLUGIN_EVENT_FIRST_DYNAMIC;\nstatic int event_horizon = PLUGIN_EVENT_FIRST_DYNAMIC;\n\n/* Hash table for the plugin_name_args objects created during command-line\n   parsing.  */\nstatic htab_t plugin_name_args_tab = NULL;\n\n/* List node for keeping track of plugin-registered callback.  */\nstruct callback_info\n{\n  const char *plugin_name;   /* Name of plugin that registers the callback.  */\n  plugin_callback_func func; /* Callback to be called.  */\n  void *user_data;           /* plugin-specified data.  */\n  struct callback_info *next;\n};\n\n/* An array of lists of 'callback_info' objects indexed by the event id.  */\nstatic struct callback_info *plugin_callbacks_init[PLUGIN_EVENT_FIRST_DYNAMIC];\nstatic struct callback_info **plugin_callbacks = plugin_callbacks_init;\n\n/* For invoke_plugin_callbacks(), see plugin.h.  */\nbool flag_plugin_added = false;\n\n#ifdef ENABLE_PLUGIN\n/* Each plugin should define an initialization function with exactly\n   this name.  */\nstatic const char *str_plugin_init_func_name = \"plugin_init\";\n\n/* Each plugin should define this symbol to assert that it is\n   distributed under a GPL-compatible license.  */\nstatic const char *str_license = \"plugin_is_GPL_compatible\";\n#endif\n\n/* Helper function for hashing the base_name of the plugin_name_args\n   structure to be inserted into the hash table.  */\n\nstatic hashval_t\nhtab_hash_plugin (const PTR p)\n{\n  const struct plugin_name_args *plugin = (const struct plugin_name_args *) p;\n  return htab_hash_string (plugin->base_name);\n }\n\n/* Helper function for the hash table that compares the base_name of the\n   existing entry (S1) with the given string (S2).  */\n\nstatic int\nhtab_str_eq (const void *s1, const void *s2)\n{\n  const struct plugin_name_args *plugin = (const struct plugin_name_args *) s1;\n  return !strcmp (plugin->base_name, (const char *) s2);\n}\n\n\n/* Given a plugin's full-path name FULL_NAME, e.g. /pass/to/NAME.so,\n   return NAME.  */\n\nstatic char *\nget_plugin_base_name (const char *full_name)\n{\n  /* First get the base name part of the full-path name, i.e. NAME.so.  */\n  char *base_name = xstrdup (lbasename (full_name));\n\n  /* Then get rid of '.so' part of the name.  */\n  strip_off_ending (base_name, strlen (base_name));\n\n  return base_name;\n}\n\n\n/* Create a plugin_name_args object for the given plugin and insert it\n   to the hash table. This function is called when\n   -fplugin=/path/to/NAME.so or -fplugin=NAME option is processed.  */\n\nvoid\nadd_new_plugin (const char* plugin_name)\n{\n  struct plugin_name_args *plugin;\n  void **slot;\n  char *base_name;\n  bool name_is_short;\n  const char *pc;\n\n  flag_plugin_added = true;\n\n  /* Replace short names by their full path when relevant.  */\n  name_is_short  = !IS_ABSOLUTE_PATH (plugin_name);\n  for (pc = plugin_name; name_is_short && *pc; pc++)\n    if (*pc == '.' || IS_DIR_SEPARATOR (*pc))\n      name_is_short = false;\n\n  if (name_is_short)\n    {\n      base_name = CONST_CAST (char*, plugin_name);\n      /* FIXME: the \".so\" suffix is currently builtin, since plugins\n\t only work on ELF host systems like e.g. Linux or Solaris.\n\t When plugins shall be available on non ELF systems such as\n\t Windows or MacOS, this code has to be greatly improved.  */\n      plugin_name = concat (default_plugin_dir_name (), \"/\",\n\t\t\t    plugin_name, \".so\", NULL);\n      if (access (plugin_name, R_OK))\n\tfatal_error\n\t  (input_location,\n\t   \"inaccessible plugin file %s expanded from short plugin name %s: %m\",\n\t   plugin_name, base_name);\n    }\n  else\n    base_name = get_plugin_base_name (plugin_name);\n\n  /* If this is the first -fplugin= option we encounter, create\n     'plugin_name_args_tab' hash table.  */\n  if (!plugin_name_args_tab)\n    plugin_name_args_tab = htab_create (10, htab_hash_plugin, htab_str_eq,\n                                        NULL);\n\n  slot = htab_find_slot_with_hash (plugin_name_args_tab, base_name,\n\t\t\t\t   htab_hash_string (base_name), INSERT);\n\n  /* If the same plugin (name) has been specified earlier, either emit an\n     error or a warning message depending on if they have identical full\n     (path) names.  */\n  if (*slot)\n    {\n      plugin = (struct plugin_name_args *) *slot;\n      if (strcmp (plugin->full_name, plugin_name))\n        error (\"plugin %s was specified with different paths:\\n%s\\n%s\",\n               plugin->base_name, plugin->full_name, plugin_name);\n      return;\n    }\n\n  plugin = XCNEW (struct plugin_name_args);\n  plugin->base_name = base_name;\n  plugin->full_name = plugin_name;\n\n  *slot = plugin;\n}\n\n\n/* Parse the -fplugin-arg-<name>-<key>[=<value>] option and create a\n   'plugin_argument' object for the parsed key-value pair. ARG is\n   the <name>-<key>[=<value>] part of the option.  */\n\nvoid\nparse_plugin_arg_opt (const char *arg)\n{\n  size_t len = 0, name_len = 0, key_len = 0, value_len = 0;\n  const char *ptr, *name_start = arg, *key_start = NULL, *value_start = NULL;\n  char *name, *key, *value;\n  void **slot;\n  bool name_parsed = false, key_parsed = false;\n\n  /* Iterate over the ARG string and identify the starting character position\n     of 'name', 'key', and 'value' and their lengths.  */\n  for (ptr = arg; *ptr; ++ptr)\n    {\n      /* Only the first '-' encountered is considered a separator between\n         'name' and 'key'. All the subsequent '-'s are considered part of\n         'key'. For example, given -fplugin-arg-foo-bar-primary-key=value,\n         the plugin name is 'foo' and the key is 'bar-primary-key'.  */\n      if (*ptr == '-' && !name_parsed)\n        {\n          name_len = len;\n          len = 0;\n          key_start = ptr + 1;\n          name_parsed = true;\n          continue;\n        }\n      else if (*ptr == '=')\n        {\n\t  if (!key_parsed) \n\t    {\n\t      key_len = len;\n\t      len = 0;\n\t      value_start = ptr + 1;\n\t      key_parsed = true;\n\t    }\n          continue;\n        }\n      else\n        ++len;\n    }\n\n  if (!key_start)\n    {\n      error (\"malformed option -fplugin-arg-%s (missing -<key>[=<value>])\",\n             arg);\n      return;\n    }\n\n  /* If the option doesn't contain the 'value' part, LEN is the KEY_LEN.\n     Otherwise, it is the VALUE_LEN.  */\n  if (!value_start)\n    key_len = len;\n  else\n    value_len = len;\n\n  name = XNEWVEC (char, name_len + 1);\n  strncpy (name, name_start, name_len);\n  name[name_len] = '\\0';\n\n  /* Check if the named plugin has already been specified earlier in the\n     command-line.  */\n  if (plugin_name_args_tab\n      && ((slot = htab_find_slot_with_hash (plugin_name_args_tab, name,\n\t\t\t\t\t    htab_hash_string (name), NO_INSERT))\n          != NULL))\n    {\n      struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n\n      key = XNEWVEC (char, key_len + 1);\n      strncpy (key, key_start, key_len);\n      key[key_len] = '\\0';\n      if (value_start)\n        {\n          value = XNEWVEC (char, value_len + 1);\n          strncpy (value, value_start, value_len);\n          value[value_len] = '\\0';\n        }\n      else\n        value = NULL;\n\n      /* Create a plugin_argument object for the parsed key-value pair.\n         If there are already arguments for this plugin, we will need to\n         adjust the argument array size by creating a new array and deleting\n         the old one. If the performance ever becomes an issue, we can\n         change the code by pre-allocating a larger array first.  */\n      if (plugin->argc > 0)\n        {\n          struct plugin_argument *args = XNEWVEC (struct plugin_argument,\n                                                  plugin->argc + 1);\n          memcpy (args, plugin->argv,\n                  sizeof (struct plugin_argument) * plugin->argc);\n          XDELETEVEC (plugin->argv);\n          plugin->argv = args;\n          ++plugin->argc;\n        }\n      else\n        {\n          gcc_assert (plugin->argv == NULL);\n          plugin->argv = XNEWVEC (struct plugin_argument, 1);\n          plugin->argc = 1;\n        }\n\n      plugin->argv[plugin->argc - 1].key = key;\n      plugin->argv[plugin->argc - 1].value = value;\n    }\n  else\n    error (\"plugin %s should be specified before -fplugin-arg-%s \"\n           \"in the command line\", name, arg);\n\n  /* We don't need the plugin's name anymore. Just release it.  */\n  XDELETEVEC (name);\n}\n\n/* Register additional plugin information. NAME is the name passed to\n   plugin_init. INFO is the information that should be registered. */\n\nstatic void\nregister_plugin_info (const char* name, struct plugin_info *info)\n{\n  void **slot = htab_find_slot_with_hash (plugin_name_args_tab, name,\n\t\t\t\t\t  htab_hash_string (name), NO_INSERT);\n  struct plugin_name_args *plugin;\n\n  if (slot == NULL)\n    {\n      error (\"unable to register info for plugin %qs - plugin name not found\",\n\t     name);\n      return;\n    }\n  plugin = (struct plugin_name_args *) *slot;\n  plugin->version = info->version;\n  plugin->help = info->help;\n}\n\n/* Look up the event id for NAME.  If the name is not found, return -1\n   if INSERT is NO_INSERT.  */\n\nint\nget_named_event_id (const char *name, enum insert_option insert)\n{\n  const char ***slot;\n\n  if (!event_tab)\n    {\n      int i;\n\n      event_tab = new hash_table<event_hasher> (150);\n      for (i = 0; i < event_last; i++)\n\t{\n\t  slot = event_tab->find_slot (&plugin_event_name[i], INSERT);\n\t  gcc_assert (*slot == HTAB_EMPTY_ENTRY);\n\t  *slot = &plugin_event_name[i];\n\t}\n    }\n  slot = event_tab->find_slot (&name, insert);\n  if (slot == NULL)\n    return -1;\n  if (*slot != HTAB_EMPTY_ENTRY)\n    return *slot - &plugin_event_name[0];\n\n  if (event_last >= event_horizon)\n    {\n      event_horizon = event_last * 2;\n      if (plugin_event_name == plugin_event_name_init)\n\t{\n\t  plugin_event_name = XNEWVEC (const char *, event_horizon);\n\t  memcpy (plugin_event_name, plugin_event_name_init,\n\t\t  sizeof plugin_event_name_init);\n\t  plugin_callbacks = XNEWVEC (struct callback_info *, event_horizon);\n\t  memcpy (plugin_callbacks, plugin_callbacks_init,\n\t\t  sizeof plugin_callbacks_init);\n\t}\n      else\n\t{\n\t  plugin_event_name\n\t    = XRESIZEVEC (const char *, plugin_event_name, event_horizon);\n\t  plugin_callbacks = XRESIZEVEC (struct callback_info *,\n\t\t\t\t\t plugin_callbacks, event_horizon);\n\t}\n      /* All the pointers in the hash table will need to be updated.  */\n      delete event_tab;\n      event_tab = NULL;\n    }\n  else\n    *slot = &plugin_event_name[event_last];\n  plugin_event_name[event_last] = name;\n  return event_last++;\n}\n\n/* Called from the plugin's initialization code. Register a single callback.\n   This function can be called multiple times.\n\n   PLUGIN_NAME - display name for this plugin\n   EVENT       - which event the callback is for\n   CALLBACK    - the callback to be called at the event\n   USER_DATA   - plugin-provided data   */\n\nvoid\nregister_callback (const char *plugin_name,\n\t\t   int event,\n                   plugin_callback_func callback,\n                   void *user_data)\n{\n  switch (event)\n    {\n      case PLUGIN_PASS_MANAGER_SETUP:\n\tgcc_assert (!callback);\n        register_pass ((struct register_pass_info *) user_data);\n        break;\n      case PLUGIN_INFO:\n\tgcc_assert (!callback);\n\tregister_plugin_info (plugin_name, (struct plugin_info *) user_data);\n\tbreak;\n      case PLUGIN_REGISTER_GGC_ROOTS:\n\tgcc_assert (!callback);\n        ggc_register_root_tab ((const struct ggc_root_tab*) user_data);\n\tbreak;\n      case PLUGIN_EVENT_FIRST_DYNAMIC:\n      default:\n\tif (event < PLUGIN_EVENT_FIRST_DYNAMIC || event >= event_last)\n\t  {\n\t    error (\"unknown callback event registered by plugin %s\",\n\t\t   plugin_name);\n\t    return;\n\t  }\n      /* Fall through.  */\n      case PLUGIN_START_PARSE_FUNCTION:\n      case PLUGIN_FINISH_PARSE_FUNCTION:\n      case PLUGIN_FINISH_TYPE:\n      case PLUGIN_FINISH_DECL:\n      case PLUGIN_START_UNIT:\n      case PLUGIN_FINISH_UNIT:\n      case PLUGIN_PRE_GENERICIZE:\n      case PLUGIN_GGC_START:\n      case PLUGIN_GGC_MARKING:\n      case PLUGIN_GGC_END:\n      case PLUGIN_ATTRIBUTES:\n      case PLUGIN_PRAGMAS:\n      case PLUGIN_FINISH:\n      case PLUGIN_ALL_PASSES_START:\n      case PLUGIN_ALL_PASSES_END:\n      case PLUGIN_ALL_IPA_PASSES_START:\n      case PLUGIN_ALL_IPA_PASSES_END:\n      case PLUGIN_OVERRIDE_GATE:\n      case PLUGIN_PASS_EXECUTION:\n      case PLUGIN_EARLY_GIMPLE_PASSES_START:\n      case PLUGIN_EARLY_GIMPLE_PASSES_END:\n      case PLUGIN_NEW_PASS:\n      case PLUGIN_INCLUDE_FILE:\n        {\n          struct callback_info *new_callback;\n          if (!callback)\n            {\n              error (\"plugin %s registered a null callback function \"\n\t\t     \"for event %s\", plugin_name, plugin_event_name[event]);\n              return;\n            }\n          new_callback = XNEW (struct callback_info);\n          new_callback->plugin_name = plugin_name;\n          new_callback->func = callback;\n          new_callback->user_data = user_data;\n          new_callback->next = plugin_callbacks[event];\n          plugin_callbacks[event] = new_callback;\n        }\n        break;\n    }\n}\n\n/* Remove a callback for EVENT which has been registered with for a plugin\n   PLUGIN_NAME.  Return PLUGEVT_SUCCESS if a matching callback was\n   found & removed, PLUGEVT_NO_CALLBACK if the event does not have a matching\n   callback, and PLUGEVT_NO_SUCH_EVENT if EVENT is invalid.  */\nint\nunregister_callback (const char *plugin_name, int event)\n{\n  struct callback_info *callback, **cbp;\n\n  if (event >= event_last)\n    return PLUGEVT_NO_SUCH_EVENT;\n\n  for (cbp = &plugin_callbacks[event]; (callback = *cbp); cbp = &callback->next)\n    if (strcmp (callback->plugin_name, plugin_name) == 0)\n      {\n\t*cbp = callback->next;\n\treturn PLUGEVT_SUCCESS;\n      }\n  return PLUGEVT_NO_CALLBACK;\n}\n\n/* Invoke all plugin callbacks registered with the specified event,\n   called from invoke_plugin_callbacks().  */\n\nint\ninvoke_plugin_callbacks_full (int event, void *gcc_data)\n{\n  int retval = PLUGEVT_SUCCESS;\n\n  timevar_push (TV_PLUGIN_RUN);\n\n  switch (event)\n    {\n      case PLUGIN_EVENT_FIRST_DYNAMIC:\n      default:\n\tgcc_assert (event >= PLUGIN_EVENT_FIRST_DYNAMIC);\n\tgcc_assert (event < event_last);\n      /* Fall through.  */\n      case PLUGIN_START_PARSE_FUNCTION:\n      case PLUGIN_FINISH_PARSE_FUNCTION:\n      case PLUGIN_FINISH_TYPE:\n      case PLUGIN_FINISH_DECL:\n      case PLUGIN_START_UNIT:\n      case PLUGIN_FINISH_UNIT:\n      case PLUGIN_PRE_GENERICIZE:\n      case PLUGIN_ATTRIBUTES:\n      case PLUGIN_PRAGMAS:\n      case PLUGIN_FINISH:\n      case PLUGIN_GGC_START:\n      case PLUGIN_GGC_MARKING:\n      case PLUGIN_GGC_END:\n      case PLUGIN_ALL_PASSES_START:\n      case PLUGIN_ALL_PASSES_END:\n      case PLUGIN_ALL_IPA_PASSES_START:\n      case PLUGIN_ALL_IPA_PASSES_END:\n      case PLUGIN_OVERRIDE_GATE:\n      case PLUGIN_PASS_EXECUTION:\n      case PLUGIN_EARLY_GIMPLE_PASSES_START:\n      case PLUGIN_EARLY_GIMPLE_PASSES_END:\n      case PLUGIN_NEW_PASS:\n      case PLUGIN_INCLUDE_FILE:\n        {\n          /* Iterate over every callback registered with this event and\n             call it.  */\n          struct callback_info *callback = plugin_callbacks[event];\n\n\t  if (!callback)\n\t    retval = PLUGEVT_NO_CALLBACK;\n          for ( ; callback; callback = callback->next)\n            (*callback->func) (gcc_data, callback->user_data);\n        }\n        break;\n\n      case PLUGIN_PASS_MANAGER_SETUP:\n      case PLUGIN_REGISTER_GGC_ROOTS:\n        gcc_assert (false);\n    }\n\n  timevar_pop (TV_PLUGIN_RUN);\n  return retval;\n}\n\n#ifdef ENABLE_PLUGIN\n/* We need a union to cast dlsym return value to a function pointer\n   as ISO C forbids assignment between function pointer and 'void *'.\n   Use explicit union instead of __extension__(<union_cast>) for\n   portability.  */\n#define PTR_UNION_TYPE(TOTYPE) union { void *_q; TOTYPE _nq; }\n#define PTR_UNION_AS_VOID_PTR(NAME) (NAME._q)\n#define PTR_UNION_AS_CAST_PTR(NAME) (NAME._nq)\n\n/* Try to initialize PLUGIN. Return true if successful. */\n\nstatic bool\ntry_init_one_plugin (struct plugin_name_args *plugin)\n{\n  void *dl_handle;\n  plugin_init_func plugin_init;\n  const char *err;\n  PTR_UNION_TYPE (plugin_init_func) plugin_init_union;\n\n  /* We use RTLD_NOW to accelerate binding and detect any mismatch\n     between the API expected by the plugin and the GCC API; we use\n     RTLD_GLOBAL which is useful to plugins which themselves call\n     dlopen.  */\n  dl_handle = dlopen (plugin->full_name, RTLD_NOW | RTLD_GLOBAL);\n  if (!dl_handle)\n    {\n      error (\"cannot load plugin %s\\n%s\", plugin->full_name, dlerror ());\n      return false;\n    }\n\n  /* Clear any existing error.  */\n  dlerror ();\n\n  /* Check the plugin license.  */\n  if (dlsym (dl_handle, str_license) == NULL)\n    fatal_error (input_location,\n\t\t \"plugin %s is not licensed under a GPL-compatible license\\n\"\n\t\t \"%s\", plugin->full_name, dlerror ());\n\n  PTR_UNION_AS_VOID_PTR (plugin_init_union) =\n      dlsym (dl_handle, str_plugin_init_func_name);\n  plugin_init = PTR_UNION_AS_CAST_PTR (plugin_init_union);\n\n  if ((err = dlerror ()) != NULL)\n    {\n      error (\"cannot find %s in plugin %s\\n%s\", str_plugin_init_func_name,\n             plugin->full_name, err);\n      return false;\n    }\n\n  /* Call the plugin-provided initialization routine with the arguments.  */\n  if ((*plugin_init) (plugin, &gcc_version))\n    {\n      error (\"fail to initialize plugin %s\", plugin->full_name);\n      return false;\n    }\n\n  return true;\n}\n\n\n/* Routine to dlopen and initialize one plugin. This function is passed to\n   (and called by) the hash table traverse routine. Return 1 for the\n   htab_traverse to continue scan, 0 to stop.\n\n   SLOT - slot of the hash table element\n   INFO - auxiliary pointer handed to hash table traverse routine\n          (unused in this function)  */\n\nstatic int\ninit_one_plugin (void **slot, void * ARG_UNUSED (info))\n{\n  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n  bool ok = try_init_one_plugin (plugin);\n  if (!ok)\n    {\n      htab_remove_elt_with_hash (plugin_name_args_tab, plugin->base_name,\n\t\t\t\t htab_hash_string (plugin->base_name));\n      XDELETE (plugin);\n    }\n  return 1;\n}\n\n#endif\t/* ENABLE_PLUGIN  */\n\n/* Main plugin initialization function.  Called from compile_file() in\n   toplev.c.  */\n\nvoid\ninitialize_plugins (void)\n{\n  /* If no plugin was specified in the command-line, simply return.  */\n  if (!plugin_name_args_tab)\n    return;\n\n  timevar_push (TV_PLUGIN_INIT);\n\n#ifdef ENABLE_PLUGIN\n  /* Traverse and initialize each plugin specified in the command-line.  */\n  htab_traverse_noresize (plugin_name_args_tab, init_one_plugin, NULL);\n#endif\n\n  timevar_pop (TV_PLUGIN_INIT);\n}\n\n/* Release memory used by one plugin. */\n\nstatic int\nfinalize_one_plugin (void **slot, void * ARG_UNUSED (info))\n{\n  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n  XDELETE (plugin);\n  return 1;\n}\n\n/* Free memory allocated by the plugin system. */\n\nvoid\nfinalize_plugins (void)\n{\n  if (!plugin_name_args_tab)\n    return;\n\n  /* We can now delete the plugin_name_args object as it will no longer\n     be used. Note that base_name and argv fields (both of which were also\n     dynamically allocated) are not freed as they could still be used by\n     the plugin code.  */\n\n  htab_traverse_noresize (plugin_name_args_tab, finalize_one_plugin, NULL);\n\n  /* PLUGIN_NAME_ARGS_TAB is no longer needed, just delete it.  */\n  htab_delete (plugin_name_args_tab);\n  plugin_name_args_tab = NULL;\n}\n\n/* Used to pass options to htab_traverse callbacks. */\n\nstruct print_options\n{\n  FILE *file;\n  const char *indent;\n};\n\n/* Print the version of one plugin. */\n\nstatic int\nprint_version_one_plugin (void **slot, void *data)\n{\n  struct print_options *opt = (struct print_options *) data;\n  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n  const char *version = plugin->version ? plugin->version : \"Unknown version.\";\n\n  fprintf (opt->file, \" %s%s: %s\\n\", opt->indent, plugin->base_name, version);\n  return 1;\n}\n\n/* Print the version of each plugin. */\n\nvoid\nprint_plugins_versions (FILE *file, const char *indent)\n{\n  struct print_options opt;\n  opt.file = file;\n  opt.indent = indent;\n  if (!plugin_name_args_tab || htab_elements (plugin_name_args_tab) == 0)\n    return;\n\n  fprintf (file, \"%sVersions of loaded plugins:\\n\", indent);\n  htab_traverse_noresize (plugin_name_args_tab, print_version_one_plugin, &opt);\n}\n\n/* Print help for one plugin. SLOT is the hash table slot. DATA is the\n   argument to htab_traverse_noresize. */\n\nstatic int\nprint_help_one_plugin (void **slot, void *data)\n{\n  struct print_options *opt = (struct print_options *) data;\n  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n  const char *help = plugin->help ? plugin->help : \"No help available .\";\n\n  char *dup = xstrdup (help);\n  char *p, *nl;\n  fprintf (opt->file, \" %s%s:\\n\", opt->indent, plugin->base_name);\n\n  for (p = nl = dup; nl; p = nl)\n    {\n      nl = strchr (nl, '\\n');\n      if (nl)\n\t{\n\t  *nl = '\\0';\n\t  nl++;\n\t}\n      fprintf (opt->file, \"   %s %s\\n\", opt->indent, p);\n    }\n\n  free (dup);\n  return 1;\n}\n\n/* Print help for each plugin. The output goes to FILE and every line starts\n   with INDENT. */\n\nvoid\nprint_plugins_help (FILE *file, const char *indent)\n{\n  struct print_options opt;\n  opt.file = file;\n  opt.indent = indent;\n  if (!plugin_name_args_tab || htab_elements (plugin_name_args_tab) == 0)\n    return;\n\n  fprintf (file, \"%sHelp for the loaded plugins:\\n\", indent);\n  htab_traverse_noresize (plugin_name_args_tab, print_help_one_plugin, &opt);\n}\n\n\n/* Return true if plugins have been loaded.  */\n\nbool\nplugins_active_p (void)\n{\n  int event;\n\n  for (event = PLUGIN_PASS_MANAGER_SETUP; event < event_last; event++)\n    if (plugin_callbacks[event])\n      return true;\n\n  return false;\n}\n\n\n/* Dump to FILE the names and associated events for all the active\n   plugins.  */\n\nDEBUG_FUNCTION void\ndump_active_plugins (FILE *file)\n{\n  int event;\n\n  if (!plugins_active_p ())\n    return;\n\n  fprintf (file, FMT_FOR_PLUGIN_EVENT \" | %s\\n\", _(\"Event\"), _(\"Plugins\"));\n  for (event = PLUGIN_PASS_MANAGER_SETUP; event < event_last; event++)\n    if (plugin_callbacks[event])\n      {\n\tstruct callback_info *ci;\n\n\tfprintf (file, FMT_FOR_PLUGIN_EVENT \" |\", plugin_event_name[event]);\n\n\tfor (ci = plugin_callbacks[event]; ci; ci = ci->next)\n\t  fprintf (file, \" %s\", ci->plugin_name);\n\n\tputc ('\\n', file);\n      }\n}\n\n\n/* Dump active plugins to stderr.  */\n\nDEBUG_FUNCTION void\ndebug_active_plugins (void)\n{\n  dump_active_plugins (stderr);\n}\n\n/* Give a warning if plugins are present, before an ICE message asking\n   to submit a bug report.  */\n\nvoid\nwarn_if_plugins (void)\n{\n  if (plugins_active_p ())\n    {\n      fnotice (stderr, \"*** WARNING *** there are active plugins, do not report\"\n\t       \" this as a bug unless you can reproduce it without enabling\"\n\t       \" any plugins.\\n\");\n      dump_active_plugins (stderr);\n    }\n\n}\n\n/* Likewise, as a callback from the diagnostics code.  */\n\nvoid\nplugins_internal_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n\t\t\t\t const char *msgid ATTRIBUTE_UNUSED,\n\t\t\t\t va_list *ap ATTRIBUTE_UNUSED)\n{\n  warn_if_plugins ();\n}\n\n/* The default version check. Compares every field in VERSION. */\n\nbool\nplugin_default_version_check (struct plugin_gcc_version *gcc_version,\n\t\t\t      struct plugin_gcc_version *plugin_version)\n{\n  if (!gcc_version || !plugin_version)\n    return false;\n\n  if (strcmp (gcc_version->basever, plugin_version->basever))\n    return false;\n  if (strcmp (gcc_version->datestamp, plugin_version->datestamp))\n    return false;\n  if (strcmp (gcc_version->devphase, plugin_version->devphase))\n    return false;\n  if (strcmp (gcc_version->revision, plugin_version->revision))\n    return false;\n  if (strcmp (gcc_version->configuration_arguments,\n\t      plugin_version->configuration_arguments))\n    return false;\n  return true;\n}\n\n\n/* Return the current value of event_last, so that plugins which provide\n   additional functionality for events for the benefit of high-level plugins\n   know how many valid entries plugin_event_name holds.  */\n\nint\nget_event_last (void)\n{\n  return event_last;\n}\n\n\n/* Retrieve the default plugin directory.  The gcc driver should have passed\n   it as -iplugindir <dir> to the cc1 program, and it is queriable through the\n   -print-file-name=plugin option to gcc.  */\nconst char*\ndefault_plugin_dir_name (void)\n{\n  if (!plugindir_string)\n    fatal_error (input_location,\n\t\t \"-iplugindir <dir> option not passed from the gcc driver\");\n  return plugindir_string;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/config/vms/vms-crtlmap.map": "# Standard C names to DEC-C names map table.\n# All names in the DEC-C shared image (shared library) are prefixed\n# with decc$ (this is the standard vms convention for names in public\n# shared libraries).  This conversion is done by the compiler for all\n# languages.\n#\n# Currently contains only a partial list, e.g. those functions use\n# in GNAT and GCC.\n#\n# File format:\n# - Empty lines are ignored.\n# - Comment lines start with '#' in the first column.\n# - map lines consist in an identifier optionnaly followed by at most 2\n#   space-separated flags.\n# Flags are described in vms.c (prefixed by VMS_CRTL_).\n#\n# Keep entries alpha-sorted - this is enforced by the awk script.\n#\n__32_getpwent\n__32_getpwnam\n__32_getpwuid\n__32_sigaction\n__32_signal\n__32_ssignal\n__64_getpwent\n__64_getpwnam\n__64_getpwuid\n__64_sigaction\n__64_signal\n__64_ssignal\n__assert\n__dl__xpv\n__freeaddrinfo32\n__freeaddrinfo64\n__getaddrinfo32\n__getaddrinfo64\n__getaddrinfo_compat4332\n__getaddrinfo_compat4364\n__getgrent64\n__getgrgid64\n__getgrgid_r64\n__getgrnam64\n__getgrnam_r64\n__lgamma\t FLOAT64 FLOATV2\n__lgammaf\t FLOAT32 FLOATV2\n__lgammal\t FLOAT64 FLOAT128 FLOATV2\n__long_gid___32_getpwnam\n__long_gid___32_getpwuid\n__long_gid___64_getpwnam\n__long_gid___64_getpwuid\n__long_gid_access\n__long_gid_chmod\n__long_gid_chown\n__long_gid_fchmod\n__long_gid_fchown\n__long_gid_fstat\n__long_gid_ftw\n__long_gid_getegid\n__long_gid_geteuid\n__long_gid_getgid\n__long_gid_getgroups\n__long_gid_getpwnam\n__long_gid_getpwnam_r\t 64\n__long_gid_getpwuid\n__long_gid_getpwuid_r\t 64\n__long_gid_getuid\n__long_gid_lchown\n__long_gid_lstat\n__long_gid_setgid\n__long_gid_setuid\n__long_gid_stat\n__non_utc_ftw\n__nw__xui\n__off64_fcntl\n__off64_fseeko\n__off64_fstat\n__off64_ftello\n__off64_ftruncate\n__off64_ftw\n__off64_long_gid_fstat\n__off64_long_gid_ftw\n__off64_long_gid_lstat\n__off64_long_gid_stat\n__off64_lseek\n__off64_lstat\n__off64_mmap\t 64\n__off64_non_utc_ftw\n__off64_pread\n__off64_pwrite\n__off64_stat\n__off64_truncate\n__off64_utc_fstat\n__off64_utc_lstat\n__off64_utc_stat\n__pdam_wcsftime\n__pdam_wcstok\t 64\n__posix__exit\n__posix_exit\n__posix_kill\n__posix_long_gid_kill\n__posix_system\n__posix_wait\n__read_rnd\n__recvmsg32\t BSD44\n__recvmsg64\t BSD44\n__sendmsg32\t BSD44\n__sendmsg64\t BSD44\n__short_gid___32_getpwent\n__short_gid___64_getpwent\n__short_gid_getpwent\n__std_fstat\n__std_ftw\n__std_lstat\n__std_stat\n__unix_geteuid\n__unix_getuid\n__utc_ctime\n__utc_ctime_r\n__utc_fstat\n__utc_ftime\n__utc_gmtime\n__utc_gmtime_r\n__utc_localtime\n__utc_localtime_r\n__utc_lstat\n__utc_mktime\n__utc_pdam_wcsftime\n__utc_stat\n__utc_strftime\n__utc_time\n__utc_utime\n__utc_utimes\n__utc_wcsftime\n__utctz_gmtime\n__utctz_gmtime_r\n__utctz_localtime\n__utctz_localtime_r\n__vms_pclose\n__vms_wait3\n__vms_wait4\n__vms_waitpid\n__writev32\n__writev64\n_exit\n_fstat\na64l\nabort\nabs\naccept\t BSD44\naccess\nacos\t FLOAT64 DPML\nacosd\tFLOAT64_VAXD DPML\nacosdl\tFLOAT64_VAXD\nacosh\tFLOAT64_VAXD DPML\nacoshl\tFLOAT64_VAXD\nacosl\tFLOAT64_VAXD\nalarm\nasctime\nasctime_r\nasin\t FLOAT64 DPML\nasind\tFLOAT64_VAXD DPML\nasindl\tFLOAT64_VAXD\nasinh\tFLOAT64_VAXD DPML\nasinhl\tFLOAT64_VAXD\nasinl\tFLOAT64_VAXD\natan\t FLOAT64 DPML\natan2\t FLOAT64 DPML\natan2l\tFLOAT64_VAXD\natand\tFLOAT64_VAXD DPML\natand2\tFLOAT64_VAXD DPML\natand2l\tFLOAT64_VAXD\natandl\tFLOAT64_VAXD\natanh\tFLOAT64_VAXD DPML\natanhl\tFLOAT64_VAXD\natanl\tFLOAT64_VAXD\natexit\natof\t FLOAT64\natoi\natol\natoll\natoq\nbasename\t 64\nbcmp\nbcopy\nbind\t BSD44\nbox\n# brk\nbsd_mh\t GA\nbsd_waddbytes\nbsd_waddstr\nbsearch\t 64\nbtowc\nbzero\ncabs\t FLOAT64 FLOATV2\ncabsf\t FLOAT32 FLOATV2\ncabsl\t FLOAT64 FLOAT128 FLOATV2\ncacos\t DPML\ncacosh\t DPML\ncalloc\t 64 MALLOC\ncalloc_opt\ncarg\tDPML\ncasin\tDPML\ncasinh\tDPML\ncatan\tDPML\ncatanh\tDPML\ncatclose\ncatgets\t 64\ncatopen\ncbrt\tFLOAT64_VAXD\ncbrtl\tFLOAT64_VAXD\nccos\tDPML\nccosh\tDPML\ncdiv\tDPML\nceil\t FLOAT64 DPML\nceill\tFLOAT64_VAXD\ncexp\tDPML\ncfree\ncfree_opt\nchdir\nchmod\nchown\nclearerr\nclearerr_unlocked\nclock\nclock_getres\nclock_gettime\nclock_settime\nclog\tDPML\nclose\nclosedir\ncmul\tDPML\ncols\t GA\nconfstr\nconnect\t BSD44\ncopysign\tFLOAT64_VAXD DPML\ncopysignl\tFLOAT64_VAXD\ncos\t FLOAT64 DPML\ncosd\tFLOAT64_VAXD DPML\ncosdl\tFLOAT64_VAXD\ncosh\t FLOAT64 DPML\ncoshl\tFLOAT64_VAXD\ncosl\tFLOAT64_VAXD\ncot\tFLOAT64_VAXD DPML\ncotd\tFLOAT64_VAXD DPML\ncotdl\tFLOAT64_VAXD\ncotl\tFLOAT64_VAXD\ncpow\tDPML\ncreat\ncrtl_init\ncrypt\t 64\ncsin\tDPML\ncsinh\tDPML\ncsqrt   DPML\nctan\tDPML\nctanh\tDPML\nctermid\t 64\nctime\nctime_r\ncuserid\t 64\ndaylight\t GL\ndelete\ndelwin\ndifftime\t FLOAT64\ndirname\t 64\ndiv\ndlclose\ndlerror\ndlopen\ndlsym\ndrand48\t FLOAT64\ndrem\tDPML\ndup\ndup2\necvt\t FLOAT64\nencrypt\nendgrent\nendhostent\nendnetent\nendprotoent\nendpwent\nendservent\nendwin\nenviron  GA\nerand48\t FLOAT64\nerf\tFLOAT64_VAXD DPML\nerfc\tFLOAT64_VAXD DPML\nerfcl\tFLOAT64_VAXD\nerfl\tFLOAT64_VAXD\nerrno\t GA\nexecl\nexecle\nexeclp\nexecv\nexecve\nexecvp\nexit\nexp\t FLOAT64 DPML\nexpl\tFLOAT64_VAXD\nexpm1\tFLOAT64_VAXD DPML\nexpm1l\tFLOAT64_VAXD\nfabs\t FLOAT64 DPML\nfabsl\tFLOAT64_VAXD\nfchmod\nfchown\nfclose\nfcntl\nfcvt\t FLOAT64\nfdopen\nfeof\nfeof_unlocked\nferror\nferror_unlocked\nfflush\nffs\nfgetc\nfgetc_unlocked\nfgetname\t 64\nfgetpos\nfgets\t 64\nfgetwc\nfgetws\t 64\nfileno\nfinite\tFLOAT64_VAXD DPML\nfinitel\tFLOAT64_VAXD\nflockfile\nfloor\t FLOAT64 DPML\nfloorl\tFLOAT64_VAXD\nfmod\t FLOAT64 DPML NODPML FLOATV2\nfmodf\t FLOAT32 NODPML FLOATV2\nfmodl\t FLOAT64 FLOAT128 NODPML FLOATV2\n# fnmatch # Overridden by libiberty.\nfopen\nfp_class\tFLOAT64_VAXD DPML\nfp_classl\tFLOAT64_VAXD\nfpathconf\nfprintf\t FLOAT64 FLOAT128\nfprintf__cf\t FLOAT64 FLOAT128\nfputc\nfputc_unlocked\nfputs\nfputwc\nfputws\nfread\nfree\nfree_opt\nfreeaddrinfo\nfreehostent\nfreopen\nfrexp\t FLOAT64 DPML\nfrexpl\tFLOAT64_VAXD\nfscanf\t FLOAT64 FLOAT128\nfseek\nfseeko\nfsetpos\nfstat\nfstatvfs\nfsync\nftell\nftello\nftime\nftruncate\nftrylockfile\nftw\nfunlockfile\nfwait\nfwide\nfwprintf\t FLOAT64 FLOAT128\nfwrite\nfwscanf\t FLOAT64 FLOAT128\ngai_strerror\ngamma\t FLOAT64 FLOATV2\ngammaf\t FLOAT32 FLOATV2\ngammal\t FLOAT64 FLOAT128 FLOATV2\ngbsd_mvprintw\ngbsd_mvscanw\ngbsd_mvwprintw\ngbsd_mvwscanw\ngbsd_printw\ngbsd_scanw\ngbsd_wprintw\ngbsd_wscanw\ngcvt\t FLOAT64 64\nget_errno_addr\nget_vms_errno_addr\ngetaddrinfo\ngetaddrinfo_compat43\ngetc\ngetc_unlocked\ngetchar\ngetchar_unlocked\ngetclock\ngetcwd\t 64\ngetdtablesize\ngetegid\ngetenv\ngeteuid\ngetgid\ngetgrent\ngetgrgid\ngetgrgid_r\ngetgrnam\ngetgrnam_r\ngetgroups\ngethostaddr\ngethostbyaddr\t BSD44\ngethostbyname\t BSD44\ngethostent\ngethostname\ngetipnodebyaddr\ngetipnodebyname\ngetitimer\ngetlogin\ngetlogin_r\ngetname\t 64\ngetnameinfo\ngetnetbyaddr\ngetnetbyname\ngetnetent\ngetopt\t32ONLY\ngetpagesize\ngetpeername\t BSD44\ngetpgid\ngetpgrp\ngetpid\ngetppid\ngetprotobyname\ngetprotobynumber\ngetprotoent\ngetpwent\ngetpwnam\ngetpwnam_r\t 64\ngetpwuid\ngetpwuid_r\t 64\ngets\t 64\ngetservbyname\ngetservbyport\ngetservent\ngetsid\ngetsockname\t BSD44\ngetsockopt\ngettimeofday\ngetuid\ngetw\ngetwc\ngetwchar\nglob\t 64\nglobfree\t 64\ngmtime\ngmtime_r\ngsignal\nherror\nhostalias\nhstrerror\nhtonl\nhtons\nhypot\t FLOAT64 DPML NODPML FLOATV2\nhypotf\t FLOAT32 NODPML FLOATV2\nhypotl\t FLOAT64 FLOAT128 NODPML FLOATV2\niconv\niconv_close\niconv_open\nif_freenameindex\nif_indextoname\nif_nameindex\nif_nametoindex\nilogb\tDPML\nindex\t 64\ninet6_opt_append\ninet6_opt_find\ninet6_opt_finish\ninet6_opt_get_val\ninet6_opt_init\ninet6_opt_next\ninet6_opt_set_val\ninet6_rth_add\ninet6_rth_getaddr\ninet6_rth_init\ninet6_rth_reverse\ninet6_rth_segments\ninet6_rth_space\ninet_addr\ninet_aton\ninet_lnaof\ninet_makeaddr\ninet_netof\ninet_network\ninet_ntoa\ninet_ntop\ninet_pton\ninitscr\ninitstate\nioctl\nisalnum\nisalpha\nisapipe\nisascii\nisatty\niscntrl\nisdigit\nisgraph\nislower\nisnan\tFLOAT64_VAXD DPML\nisnanl\tFLOAT64_VAXD\nisprint\nispunct\nisspace\nisupper\niswalnum\niswalpha\niswcntrl\niswctype\niswdigit\niswgraph\niswlower\niswprint\niswpunct\niswspace\niswupper\niswxdigit\nisxdigit\nj0\tFLOAT64_VAXD DPML\nj0l\tFLOAT64_VAXD\nj1\tFLOAT64_VAXD DPML\nj1l\tFLOAT64_VAXD\njn\tFLOAT64_VAXD DPML\njnl\tFLOAT64_VAXD\njrand48\nkill\nl64a\nl64a_r\nlabs\nlchown\nlcong48\nldexp\t FLOAT64 DPML\nldexpl\tFLOAT64_VAXD\nldiv\nlgamma\t FLOAT64 DPML NODPML FLOATV2\nlgammaf\t FLOAT32 NODPML FLOATV2\nlgammal\t FLOAT64 FLOAT128 NODPML FLOATV2\nlines\t GA\nlink\nlisten\nllabs\nlldiv\nlocale\nlocaleconv\nlocaltime\nlocaltime_r\n# ln -> log DPML\nlog\t FLOAT64 FLOATV2\nlog10\t FLOAT64 DPML\nlog10l\tFLOAT64_VAXD\nlog1p\tFLOAT64_VAXD DPML\nlog1pl\tFLOAT64_VAXD\nlog2\tFLOAT64_VAXD DPML\nlog2l\tFLOAT64_VAXD\nlogb\tFLOAT64_VAXD DPML\nlogbl\tFLOAT64_VAXD\nlogf\t FLOAT32 FLOATV2\nlogl\t FLOAT64 FLOAT128 FLOATV2\nlongjmp\nlongname 64\nlrand48\nlround\t DPML\nlseek\nlstat\nlwait\nmalloc\t 64 MALLOC\nmalloc_opt\nmblen\nmbrlen\nmbrtowc\nmbsinit\nmbsrtowcs\t 64\nmbstowcs\nmbtowc\nmemccpy\t 64\nmemchr\t 64\nmemcmp\nmemcpy\t 64\nmemmove\t 64\nmemset\t 64\nmkdir\nmkstemp\nmktemp\t 64\nmktime\nmmap\t 64\nmodf\t FLOAT64 DPML\nmodfl\tFLOAT64_VAXD\nmprotect\nmrand48\nmsync\nmunmap\nmvwaddstr\nmvwin\nnanosleep\nnewwin\nnextafter\tFLOAT64_VAXD DPML\nnextafterl\tFLOAT64_VAXD\nnice\nnint\tFLOAT64_VAXD DPML\nnintl\tFLOAT64_VAXD\nnl_langinfo\nnrand48\nntohl\nntohs\nopen\nopendir\noptarg\t GA\t32ONLY\nopterr\t GL\t32ONLY\noptind\t GL\t32ONLY\noptopt\t GL\t32ONLY\noverlay\noverwrite\npathconf\npause\npclose\nperror\npipe\npoll\npopen\n# pow DPML version ???\npow\t FLOAT64 FLOATV2\npowf\t FLOAT32 FLOATV2\npowl\t FLOAT64 FLOAT128 FLOATV2\npread\nprintf\t FLOAT64 FLOAT128\nprintf__cf\t FLOAT64 FLOAT128\nprintw\t FLOAT64 FLOAT128\nputc\nputc_unlocked\nputchar\nputchar_unlocked\nputenv\nputs\nputw\nputwc\nputwchar\npwrite\nqabs\nqdiv\nqsort\t 64\nraise\nrand\nrand_r\nrandom\nread\nreaddir\nreaddir_r\t 64\nreadlink\nreadv\t 64\nrealloc\t 64 MALLOC\nrealloc_opt\nrealpath\t 64\nrecord_read\nrecv\nrecvfrom\t BSD44\nrecvmsg\t BSD44\nremainder DPML\nremove\nrename\nrewind\nrewinddir\nrindex\t 64\nrint\tFLOAT64_VAXD DPML\nrintl\tFLOAT64_VAXD\nrmdir\nrtl_private\n# sbrk # Makes libiberty/xmalloc.c fails to build.\nscalb\tFLOAT64_VAXD DPML\nscalbl\tFLOAT64_VAXD\nscanf\t FLOAT64 FLOAT128\nscanw\t FLOAT64 FLOAT128\nscroll\nseed48\nseekdir\nselect\nsend\nsendmsg\t BSD44\nsendto\t BSD44\nset_new_handler__xpxv_v\nsetbuf\nsetenv\nseteuid\nsetgid\nsetgrent\nsethostent\nsetitimer\nsetkey\nsetlocale\nsetnetent\nsetpgid\nsetpgrp\nsetprotoent\nsetpwent\nsetregid\nsetreuid\nsetservent\nsetsid\nsetsockopt\nsetstate\nsetuid\nsetvbuf\nshm_open\nshm_unlink\nshutdown\nsigaction\nsigaddset\nsigblock\nsigdelset\nsigemptyset\nsigfillset\nsighold\nsigignore\nsigismember\nsiglongjmp\nsigmask\nsignal\nsigngam\t GL\nsigpause\nsigpending\nsigprocmask\nsigrelse\nsigsetjmp\nsigsetmask\nsigstack\nsigsuspend\nsigtimedwait\nsigvec\nsigwait\nsigwaitinfo\nsin\t FLOAT64 DPML\nsincos  DPML\nsincosd DPML\nsind\tFLOAT64_VAXD DPML\nsindl\tFLOAT64_VAXD\nsinh\t FLOAT64 DPML\nsinhcosh DPML\nsinhl\tFLOAT64_VAXD\nsinl\tFLOAT64_VAXD\nsleep\nsnprintf\t FLOAT64 FLOAT128\nsocket\nsocketpair\nsprintf\t FLOAT64 FLOAT128\nsprintf__cf\t FLOAT64 FLOAT128\nsqrt\t FLOAT64 DPML\nsqrtl\tFLOAT64_VAXD\nsrand\nsrand48\nsrandom\nsscanf\t FLOAT64 FLOAT128\nssignal\nstat\nstatvfs\nstrcasecmp\nstrcat\t 64\nstrchr\t 64\nstrcmp\nstrcoll\nstrcpy\t 64\nstrcspn\nstrdup\t 64 MALLOC\nstrerror\nstrfmon\t FLOAT64\nstrftime\nstrlen\nstrncasecmp\nstrncat\t 64\nstrncmp\nstrncpy\t 64\nstrnlen\nstrpbrk\t 64\nstrptime\t 64\nstrptime_xpg4\nstrrchr\t 64\nstrsep\t 64\nstrspn\nstrstr\t 64\nstrtod\t FLOAT64 64\nstrtok\t 64\nstrtok_r\t 64\nstrtol\t 64\nstrtoll\t 64\nstrtoq\t 64\nstrtoul\t 64\nstrtoull\t 64\nstrtouq\t 64\nstrxfrm\nsubwin\nswab\nswprintf\t FLOAT64 FLOAT128\nswscanf\t FLOAT64 FLOAT128\nsymlink\nsys_errlist\t GA\nsys_nerr\t GL\nsysconf\nsystem\ntan\t FLOAT64 DPML\ntand\tFLOAT64_VAXD DPML\ntandl\tFLOAT64_VAXD\ntanh\t FLOAT64 DPML\ntanhl\tFLOAT64_VAXD\ntanl\tFLOAT64_VAXD\ntelldir\ntempnam\ntgamma  DPML\ntime\ntimes\ntimezone\t GL\ntmpfile\ntmpnam\t 64\ntoascii\ntolower\ntouchwin\ntoupper\ntowctrans\ntowlower\ntowupper\ntrunc\tFLOAT64_VAXD DPML\ntruncate\ntruncl\tFLOAT64_VAXD\nttyname\nttyname_r\ntzname\t GA\ntzset\nualarm\numask\nuname\nungetc\nungetwc\nunlink\nunordered\tFLOAT64_VAXD DPML\nunorderedl\tFLOAT64_VAXD\nunsetenv\nusleep\nutime\nutimes\nvaxc$calloc_opt\nvaxc$cfree_opt\nvaxc$crtl_init\nvaxc$errno\t GA\nvaxc$free_opt\nvaxc$get_sdc\nvaxc$malloc_opt\nvaxc$realloc_opt\nvfprintf\t FLOAT64 FLOAT128\nvfscanf\t FLOAT64 FLOAT128\nvfwprintf\t FLOAT64 FLOAT128\nvfwscanf\t FLOAT64 FLOAT128\nvprintf\t FLOAT64 FLOAT128\nvscanf\t FLOAT64 FLOAT128\nvsnprintf\t FLOAT64 FLOAT128\nvsprintf\t FLOAT64 FLOAT128\nvsscanf\t FLOAT64 FLOAT128\nvswprintf\t FLOAT64 FLOAT128\nvswscanf\t FLOAT64 FLOAT128\nvwprintf\t FLOAT64 FLOAT128\nvwscanf\t FLOAT64 FLOAT128\nwaddch\nwaddstr\nwait\nwait3\nwait4\nwaitpid\nwclear\nwclrattr\nwclrtobot\nwclrtoeol\nwcrtomb\nwcscat\t 64\nwcschr\t 64\nwcscmp\nwcscoll\nwcscpy\t 64\nwcscspn\nwcsftime\nwcslen\nwcsncat\t 64\nwcsncmp\nwcsncpy\t 64\nwcspbrk\t 64\nwcsrchr\t 64\nwcsrtombs\t 64\nwcsspn\nwcsstr\t 64\nwcstod\t FLOAT64 64\nwcstok\t 64\nwcstol\t 64\nwcstombs\nwcstoul\t 64\nwcswcs\t 64\nwcswidth\nwcsxfrm\nwctob\nwctomb\nwctrans\nwctype\nwcwidth\nwdelch\nwdeleteln\nwerase\nwgetch\nwgetstr\nwinch\nwinsch\nwinsertln\nwinsstr\nwmemchr\t 64\nwmemcmp\nwmemcpy\t 64\nwmemmove\t 64\nwmemset\t 64\nwmove\nwprintf\t FLOAT64 FLOAT128\nwprintw\t FLOAT64 FLOAT128\nwrefresh\nwrite\nwritev\nwscanf\t FLOAT64 FLOAT128\nwscanw\t FLOAT64 FLOAT128\nwsetattr\nwstandend\nwstandout\ny0\tFLOAT64_VAXD DPML\ny0l\tFLOAT64_VAXD\ny1\tFLOAT64_VAXD DPML\ny1l\tFLOAT64_VAXD\nyn\tFLOAT64_VAXD DPML\nynl\tFLOAT64_VAXD\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/notes.txt": "Client Code   . Generated .            libgccjit.so\n              . code      .\n              .           . JIT API  . JIT \"Frontend\". (libbackend.a)\n....................................................................................\n   \u2502          .           .          .               .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502     .               .\n              .           .    V     .               .\n              .           .    \u2500\u2500> libgccjit.c       .\n              .           .        \u2502 (error-checking).\n              .           .        \u2502                 .\n              .           .        \u2500\u2500> jit-recording.c\n              .           .              (record API calls)\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500              .\n              .           .    \u2502     .               .\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_context_compile .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 start of recording::context::compile ()\n              .           .    \u2502     .               .\n              .           .    \u2502 start of playback::context::compile ()\n              .           .    \u2502   (create tempdir)  .\n              .           .    \u2502     .               .\n              .           .    \u2502 ACQUIRE MUTEX       .\n              .           .    \u2502     .               .\n              .           .    V\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> toplev::main (for now)\n              .           .          .               .       \u2502\n              .           .          .               .   (various code)\n              .           .          .               .       \u2502\n              .           .          .               .       V\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:parse_file\n              .           .          .    \u2502          .\n              .           .          .    \u2502 (jit_langhook_parse_file)\n              .           .          .    \u2502          .\n..........................................\u2502..................VVVVVVVVVVVVV...\n              .           .          .    \u2502          .       No GC in here\n              .           .          .    \u2502 jit-playback.c\n              .           .          .    \u2502   (playback of API calls)\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> creation of functions,\n              .           .          .               .     types, expression trees\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 etc\n              .           .          .    \u2502(handle_locations: add locations to\n              .           .          .    \u2502 linemap and associate them with trees)\n              .           .          .    \u2502          .\n              .           .          .    \u2502          .       No GC in here\n..........................................\u2502..................AAAAAAAAAAAAA...\n              .           .          .    \u2502 for each function\n              .           .          .    \u2500\u2500> postprocess\n              .           .          .        \u2502      .\n              .           .          .        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> cgraph_finalize_function\n              .           .          .        <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              .           .          .     <\u2500\u2500       .\n              .           .          .    \u2502          .\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> (end of\n              .           .          .               .       \u2502 langhook_parse_file)\n              .           .          .               .       \u2502\n              .           .          .               .   (various code)\n              .           .          .               .       \u2502\n              .           .          .               .       \u2193\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:write_globals\n              .           .          .    \u2502          .\n              .           .          .    \u2502 (jit_langhook_write_globals)\n              .           .          .    \u2502          .\n              .           .          .    \u2502          .\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> finalize_compilation_unit\n              .           .          .               .       \u2502\n              .           .          .               .   (the middle\u2500end and backend)\n              .           .          .               .       \u2193\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::main\n              .           .    \u2502     .               .\n              .           .    V\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> toplev::finalize\n              .           .          .               . \u2502   (purge internal state)\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::finalize\n              .           .    \u2502     .               .\n              .           .    V\u2500> playback::context::postprocess:\n              .           .      \u2502   .               .\n              .           .      \u2502   (assuming an in-memory compile):\n              .           .      \u2502   .               .\n              .           .      --> Convert assembler to DSO, via embedded\n              .           .          copy of driver:\n              .           .           driver::main ()\n              .           .             invocation of \"as\"\n              .           .             invocation of \"ld\"\n              .           .           driver::finalize ()\n              .           .      <----\n              .           .      \u2502   .               .\n              .           .      \u2502   . Load DSO (dlopen \"fake.so\")\n              .           .      \u2502   .               .\n              .           .      \u2502   . Bundle it up in a jit::result\n              .           .    <\u2500\u2500   .               .\n              .           .    \u2502     .               .\n              .           .    \u2502 RELEASE MUTEX       .\n              .           .    \u2502     .               .\n              .           .    \u2502 end of playback::context::compile ()\n              .           .    \u2502     .               .\n              .           .    \u2502 playback::context dtor\n              .           .     \u2500\u2500>  .               .\n              .           .       \u2502 Normally we cleanup the tempdir here:\n              .           .       \u2502   (\"fake.so\" is unlinked from the\n              .           .       \u2502    filesystem at this point)\n              .           .       \u2502 If the client code requested debuginfo, the\n              .           .       \u2502 cleanup happens later (in gcc_jit_result_release)\n              .           .       \u2502 to make it easier on the debugger (see PR jit/64206)\n              .           .    <\u2500\u2500   .               .\n              .           .    \u2502     .               .\n              .           .    \u2502 end of recording::context::compile ()\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_result_get_code .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 dlsym () within loaded DSO\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   Get (void*).           .          .               .\n   \u2502          .           .          .               .\n   \u2502 Call it  .           .          .               .\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>       .          .               .\n              .    \u2502      .          .               .\n              .    \u2502      .          .               .\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       .          .               .\n   \u2502          .           .          .               .\netc\u2502          .           .          .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_result_release  .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 dlclose () the loaded DSO\n              .           .    \u2502    (code becomes uncallable)\n              .           .    \u2502     .               .\n              .           .    \u2502 If the client code requested debuginfo, then\n              .           .    \u2502 cleanup of the tempdir was delayed.\n              .           .    \u2502 If that was the case, clean it up now.\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/jit-result.c": "/* Internals of libgccjit: implementation of gcc_jit_result\n   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n   Contributed by David Malcolm <dmalcolm@redhat.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include \"config.h\"\n#include \"system.h\"\n#include \"coretypes.h\"\n\n#include \"jit-common.h\"\n#include \"jit-logging.h\"\n#include \"jit-result.h\"\n#include \"jit-tempdir.h\"\n\nnamespace gcc {\nnamespace jit {\n\n/* Constructor for gcc::jit::result.  */\n\nresult::\nresult(logger *logger, void *dso_handle, tempdir *tempdir_) :\n  log_user (logger),\n  m_dso_handle (dso_handle),\n  m_tempdir (tempdir_)\n{\n  JIT_LOG_SCOPE (get_logger ());\n}\n\n/* gcc::jit::result's destructor.\n\n   Called implicitly by gcc_jit_result_release.  */\n\nresult::~result()\n{\n  JIT_LOG_SCOPE (get_logger ());\n\n  dlclose (m_dso_handle);\n\n  /* Responsibility for cleaning up the tempdir (including \"fake.so\" within\n     the filesystem) might have been handed to us by the playback::context,\n     so that the cleanup can be delayed (see PR jit/64206).\n\n     If so, clean it up now.  */\n  delete m_tempdir;\n}\n\n/* Attempt to locate the given function by name within the\n   playback::result, using dlsym.\n\n   Implements the post-error-checking part of\n   gcc_jit_result_get_code.  */\n\nvoid *\nresult::\nget_code (const char *funcname)\n{\n  JIT_LOG_SCOPE (get_logger ());\n\n  void *code;\n  const char *error;\n\n  /* Clear any existing error.  */\n  dlerror ();\n\n  code = dlsym (m_dso_handle, funcname);\n\n  if ((error = dlerror()) != NULL)  {\n    fprintf(stderr, \"%s\\n\", error);\n  }\n\n  return code;\n}\n\n/* Attempt to locate the given global by name within the\n   playback::result, using dlsym.\n\n   Implements the post-error-checking part of\n   gcc_jit_result_get_global.  */\n\nvoid *\nresult::\nget_global (const char *name)\n{\n  JIT_LOG_SCOPE (get_logger ());\n\n  void *global;\n  const char *error;\n\n  /* Clear any existing error.  */\n  dlerror ();\n\n  global = dlsym (m_dso_handle, name);\n\n  if ((error = dlerror()) != NULL)  {\n    fprintf(stderr, \"%s\\n\", error);\n  }\n\n  return global;\n}\n\n} // namespace gcc::jit\n\n} // namespace gcc\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/_build/texinfo/libgccjit.texi": "\\input texinfo   @c -*-texinfo-*-\n@c %**start of header\n@setfilename libgccjit.info\n@documentencoding UTF-8\n@ifinfo\n@*Generated by Sphinx 1.1.3.@*\n@end ifinfo\n@settitle libgccjit Documentation\n@defindex ge\n@paragraphindent 2\n@exampleindent 4\n@afourlatex\n@dircategory Miscellaneous\n@direntry\n* libgccjit: (libgccjit.info). One line description of project.\n@end direntry\n\n@c %**end of header\n\n@copying\n@quotation\nlibgccjit 7.0.0 (experimental 20160517), May 17, 2016\n\nDavid Malcolm\n\nCopyright @copyright{} 2014-2017 Free Software Foundation, Inc.\n@end quotation\n\n@end copying\n\n@titlepage\n@title libgccjit Documentation\n@insertcopying\n@end titlepage\n@contents\n\n@c %** start of user preamble\n\n@c %** end of user preamble\n\n@ifnottex\n@node Top\n@top libgccjit Documentation\n@insertcopying\n@end ifnottex\n\n@c %**start of body\n@anchor{index doc}@anchor{0}\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\nThis document describes libgccjit@footnote{http://gcc.gnu.org/wiki/JIT}, an API\nfor embedding GCC inside programs and libraries.\n\nNote that libgccjit is currently of \"Alpha\" quality;\nthe APIs are not yet set in stone, and they shouldn't be used in\nproduction yet.\n\nThere are actually two APIs for the library:\n\n\n@itemize *\n\n@item \na pure C API: @code{libgccjit.h}\n\n@item \na C++ wrapper API: @code{libgccjit++.h}.  This is a collection of \"thin\"\nwrapper classes around the C API, to save typing.\n@end itemize\n\nContents:\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Tutorial:: \n* Topic Reference:: \n* C++ bindings for libgccjit:: \n* Internals:: \n* Indices and tables:: \n* Index:: \n\n@detailmenu\n --- The Detailed Node Listing ---\n\nTutorial\n\n* Tutorial part 1; \"Hello world\": Tutorial part 1 \"Hello world\". \n* Tutorial part 2; Creating a trivial machine code function: Tutorial part 2 Creating a trivial machine code function. \n* Tutorial part 3; Loops and variables: Tutorial part 3 Loops and variables. \n* Tutorial part 4; Adding JIT-compilation to a toy interpreter: Tutorial part 4 Adding JIT-compilation to a toy interpreter. \n* Tutorial part 5; Implementing an Ahead-of-Time compiler: Tutorial part 5 Implementing an Ahead-of-Time compiler. \n\nTutorial part 2: Creating a trivial machine code function\n\n* Error-handling:: \n* Options:: \n* Full example:: \n\nTutorial part 3: Loops and variables\n\n* Expressions; lvalues and rvalues: Expressions lvalues and rvalues. \n* Control flow:: \n* Visualizing the control flow graph:: \n* Full example: Full example<2>. \n\nTutorial part 4: Adding JIT-compilation to a toy interpreter\n\n* Our toy interpreter:: \n* Compiling to machine code:: \n* Setting things up:: \n* Populating the function:: \n* Verifying the control flow graph:: \n* Compiling the context:: \n* Single-stepping through the generated code:: \n* Examining the generated code:: \n* Putting it all together:: \n* Behind the curtain; How does our code get optimized?: Behind the curtain How does our code get optimized?. \n\nBehind the curtain: How does our code get optimized?\n\n* Optimizing away stack manipulation:: \n* Elimination of tail recursion:: \n\nTutorial part 5: Implementing an Ahead-of-Time compiler\n\n* The \"brainf\" language:: \n* Converting a brainf script to libgccjit IR:: \n* Compiling a context to a file:: \n* Other forms of ahead-of-time-compilation:: \n\nTopic Reference\n\n* Compilation contexts:: \n* Objects:: \n* Types:: \n* Expressions:: \n* Creating and using functions:: \n* Source Locations:: \n* Compiling a context:: \n* ABI and API compatibility:: \n* Performance:: \n\nCompilation contexts\n\n* Lifetime-management:: \n* Thread-safety:: \n* Error-handling: Error-handling<2>. \n* Debugging:: \n* Options: Options<2>. \n\nOptions\n\n* String Options:: \n* Boolean options:: \n* Integer options:: \n* Additional command-line options:: \n\nTypes\n\n* Standard types:: \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile. \n* Structures and unions:: \n\nExpressions\n\n* Rvalues:: \n* Lvalues:: \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions. \n\nRvalues\n\n* Simple expressions:: \n* Unary Operations:: \n* Binary Operations:: \n* Comparisons:: \n* Function calls:: \n* Type-coercion:: \n\nLvalues\n\n* Global variables:: \n\nCreating and using functions\n\n* Params:: \n* Functions:: \n* Blocks:: \n* Statements:: \n\nSource Locations\n\n* Faking it:: \n\nCompiling a context\n\n* In-memory compilation:: \n* Ahead-of-time compilation:: \n\nABI and API compatibility\n\n* ABI symbol tags:: \n\nABI symbol tags\n\n* LIBGCCJIT_ABI_0:: \n* LIBGCCJIT_ABI_1:: \n* LIBGCCJIT_ABI_2:: \n* LIBGCCJIT_ABI_3:: \n* LIBGCCJIT_ABI_4:: \n* LIBGCCJIT_ABI_5:: \n\nPerformance\n\n* The timing API:: \n\nC++ bindings for libgccjit\n\n* Tutorial: Tutorial<2>. \n* Topic Reference: Topic Reference<2>. \n\nTutorial\n\n* Tutorial part 1; \"Hello world\": Tutorial part 1 \"Hello world\"<2>. \n* Tutorial part 2; Creating a trivial machine code function: Tutorial part 2 Creating a trivial machine code function<2>. \n* Tutorial part 3; Loops and variables: Tutorial part 3 Loops and variables<2>. \n* Tutorial part 4; Adding JIT-compilation to a toy interpreter: Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>. \n\nTutorial part 2: Creating a trivial machine code function\n\n* Options: Options<3>. \n* Full example: Full example<3>. \n\nTutorial part 3: Loops and variables\n\n* Expressions; lvalues and rvalues: Expressions lvalues and rvalues<2>. \n* Control flow: Control flow<2>. \n* Visualizing the control flow graph: Visualizing the control flow graph<2>. \n* Full example: Full example<4>. \n\nTutorial part 4: Adding JIT-compilation to a toy interpreter\n\n* Our toy interpreter: Our toy interpreter<2>. \n* Compiling to machine code: Compiling to machine code<2>. \n* Setting things up: Setting things up<2>. \n* Populating the function: Populating the function<2>. \n* Verifying the control flow graph: Verifying the control flow graph<2>. \n* Compiling the context: Compiling the context<2>. \n* Single-stepping through the generated code: Single-stepping through the generated code<2>. \n* Examining the generated code: Examining the generated code<2>. \n* Putting it all together: Putting it all together<2>. \n* Behind the curtain; How does our code get optimized?: Behind the curtain How does our code get optimized?<2>. \n\nBehind the curtain: How does our code get optimized?\n\n* Optimizing away stack manipulation: Optimizing away stack manipulation<2>. \n* Elimination of tail recursion: Elimination of tail recursion<2>. \n\nTopic Reference\n\n* Compilation contexts: Compilation contexts<2>. \n* Objects: Objects<2>. \n* Types: Types<2>. \n* Expressions: Expressions<2>. \n* Creating and using functions: Creating and using functions<2>. \n* Source Locations: Source Locations<2>. \n* Compiling a context: Compiling a context<2>. \n\nCompilation contexts\n\n* Lifetime-management: Lifetime-management<2>. \n* Thread-safety: Thread-safety<2>. \n* Error-handling: Error-handling<3>. \n* Debugging: Debugging<2>. \n* Options: Options<4>. \n\nOptions\n\n* String Options: String Options<2>. \n* Boolean options: Boolean options<2>. \n* Integer options: Integer options<2>. \n* Additional command-line options: Additional command-line options<2>. \n\nTypes\n\n* Standard types: Standard types<2>. \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile<2>. \n* Structures and unions: Structures and unions<2>. \n\nExpressions\n\n* Rvalues: Rvalues<2>. \n* Lvalues: Lvalues<2>. \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions<2>. \n\nRvalues\n\n* Simple expressions: Simple expressions<2>. \n* Unary Operations: Unary Operations<2>. \n* Binary Operations: Binary Operations<2>. \n* Comparisons: Comparisons<2>. \n* Function calls: Function calls<2>. \n* Type-coercion: Type-coercion<2>. \n\nLvalues\n\n* Global variables: Global variables<2>. \n\nCreating and using functions\n\n* Params: Params<2>. \n* Functions: Functions<2>. \n* Blocks: Blocks<2>. \n* Statements: Statements<2>. \n\nSource Locations\n\n* Faking it: Faking it<2>. \n\nCompiling a context\n\n* In-memory compilation: In-memory compilation<2>. \n* Ahead-of-time compilation: Ahead-of-time compilation<2>. \n\nInternals\n\n* Working on the JIT library:: \n* Running the test suite:: \n* Environment variables:: \n* Packaging notes:: \n* Overview of code structure:: \n* Design notes:: \n* Submitting patches:: \n\nRunning the test suite\n\n* Running under valgrind:: \n\n@end detailmenu\n@end menu\n\n\n@node Tutorial,Topic Reference,Top,Top\n@anchor{intro/index libgccjit}@anchor{1}@anchor{intro/index doc}@anchor{2}@anchor{intro/index tutorial}@anchor{3}\n@chapter Tutorial\n\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Tutorial part 1; \"Hello world\": Tutorial part 1 \"Hello world\". \n* Tutorial part 2; Creating a trivial machine code function: Tutorial part 2 Creating a trivial machine code function. \n* Tutorial part 3; Loops and variables: Tutorial part 3 Loops and variables. \n* Tutorial part 4; Adding JIT-compilation to a toy interpreter: Tutorial part 4 Adding JIT-compilation to a toy interpreter. \n* Tutorial part 5; Implementing an Ahead-of-Time compiler: Tutorial part 5 Implementing an Ahead-of-Time compiler. \n\n@end menu\n\n@node Tutorial part 1 \"Hello world\",Tutorial part 2 Creating a trivial machine code function,,Tutorial\n@anchor{intro/tutorial01 doc}@anchor{4}@anchor{intro/tutorial01 tutorial-part-1-hello-world}@anchor{5}\n@section Tutorial part 1: \"Hello world\"\n\n\nBefore we look at the details of the API, let's look at building and\nrunning programs that use the library.\n\nHere's a toy \"hello world\" program that uses the library to synthesize\na call to @cite{printf} and uses it to write a message to stdout.\n\nDon't worry about the content of the program for now; we'll cover\nthe details in later parts of this tutorial.\n\n@quotation\n\n@example\n/* Smoketest example for libgccjit.so\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void\ncreate_code (gcc_jit_context *ctxt)\n@{\n  /* Let's try to inject the equivalent of:\n     void\n     greet (const char *name)\n     @{\n        printf (\"hello %s\\n\", name);\n     @}\n  */\n  gcc_jit_type *void_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n  gcc_jit_type *const_char_ptr_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n  gcc_jit_param *param_name =\n    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n  gcc_jit_function *func =\n    gcc_jit_context_new_function (ctxt, NULL,\n                                  GCC_JIT_FUNCTION_EXPORTED,\n                                  void_type,\n                                  \"greet\",\n                                  1, &param_name,\n                                  0);\n\n  gcc_jit_param *param_format =\n    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n  gcc_jit_function *printf_func =\n    gcc_jit_context_new_function (ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n\t\t\t\t  gcc_jit_context_get_type (\n\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n\t\t\t\t  \"printf\",\n\t\t\t\t  1, &param_format,\n\t\t\t\t  1);\n  gcc_jit_rvalue *args[2];\n  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n  args[1] = gcc_jit_param_as_rvalue (param_name);\n\n  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n\n  gcc_jit_block_add_eval (\n    block, NULL,\n    gcc_jit_context_new_call (ctxt,\n                              NULL,\n                              printf_func,\n                              2, args));\n  gcc_jit_block_end_with_void_return (block, NULL);\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  gcc_jit_context *ctxt;\n  gcc_jit_result *result;\n\n  /* Get a \"context\" object for working with the library.  */\n  ctxt = gcc_jit_context_acquire ();\n  if (!ctxt)\n    @{\n      fprintf (stderr, \"NULL ctxt\");\n      exit (1);\n    @}\n\n  /* Set some options on the context.\n     Let's see the code being generated, in assembler form.  */\n  gcc_jit_context_set_bool_option (\n    ctxt,\n    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n    0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  result = gcc_jit_context_compile (ctxt);\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      exit (1);\n    @}\n\n  /* Extract the generated code from \"result\".  */\n  typedef void (*fn_type) (const char *);\n  fn_type greet =\n    (fn_type)gcc_jit_result_get_code (result, \"greet\");\n  if (!greet)\n    @{\n      fprintf (stderr, \"NULL greet\");\n      exit (1);\n    @}\n\n  /* Now call the generated function: */\n  greet (\"world\");\n  fflush (stdout);\n\n  gcc_jit_context_release (ctxt);\n  gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nCopy the above to @cite{tut01-hello-world.c}.\n\nAssuming you have the jit library installed, build the test program\nusing:\n\n@example\n$ gcc \\\n    tut01-hello-world.c \\\n    -o tut01-hello-world \\\n    -lgccjit\n@end example\n\n@noindent\n\nYou should then be able to run the built program:\n\n@example\n$ ./tut01-hello-world\nhello world\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 2 Creating a trivial machine code function,Tutorial part 3 Loops and variables,Tutorial part 1 \"Hello world\",Tutorial\n@anchor{intro/tutorial02 doc}@anchor{6}@anchor{intro/tutorial02 tutorial-part-2-creating-a-trivial-machine-code-function}@anchor{7}\n@section Tutorial part 2: Creating a trivial machine code function\n\n\nConsider this C function:\n\n@example\nint square (int i)\n@{\n  return i * i;\n@}\n@end example\n\n@noindent\n\nHow can we construct this at run-time using libgccjit?\n\nFirst we need to include the relevant header:\n\n@example\n#include <libgccjit.h>\n@end example\n\n@noindent\n\nAll state associated with compilation is associated with a\n@pxref{8,,gcc_jit_context *}.\n\nCreate one using @pxref{9,,gcc_jit_context_acquire()}:\n\n@example\ngcc_jit_context *ctxt;\nctxt = gcc_jit_context_acquire ();\n@end example\n\n@noindent\n\nThe JIT library has a system of types.  It is statically-typed: every\nexpression is of a specific type, fixed at compile-time.  In our example,\nall of the expressions are of the C @cite{int} type, so let's obtain this from\nthe context, as a @pxref{a,,gcc_jit_type *}, using\n@pxref{b,,gcc_jit_context_get_type()}:\n\n@example\ngcc_jit_type *int_type =\n  gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n@end example\n\n@noindent\n\n@pxref{a,,gcc_jit_type *} is an example of a \"contextual\" object: every\nentity in the API is associated with a @pxref{8,,gcc_jit_context *}.\n\nMemory management is easy: all such \"contextual\" objects are automatically\ncleaned up for you when the context is released, using\n@pxref{c,,gcc_jit_context_release()}:\n\n@example\ngcc_jit_context_release (ctxt);\n@end example\n\n@noindent\n\nso you don't need to manually track and cleanup all objects, just the\ncontexts.\n\nAlthough the API is C-based, there is a form of class hierarchy, which\nlooks like this:\n\n@example\n+- gcc_jit_object\n    +- gcc_jit_location\n    +- gcc_jit_type\n       +- gcc_jit_struct\n    +- gcc_jit_field\n    +- gcc_jit_function\n    +- gcc_jit_block\n    +- gcc_jit_rvalue\n        +- gcc_jit_lvalue\n           +- gcc_jit_param\n@end example\n\n@noindent\n\nThere are casting methods for upcasting from subclasses to parent classes.\nFor example, @pxref{d,,gcc_jit_type_as_object()}:\n\n@example\ngcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n@end example\n\n@noindent\n\nOne thing you can do with a @pxref{e,,gcc_jit_object *} is\nto ask it for a human-readable description, using\n@pxref{f,,gcc_jit_object_get_debug_string()}:\n\n@example\nprintf (\"obj: %s\\n\", gcc_jit_object_get_debug_string (obj));\n@end example\n\n@noindent\n\ngiving this text on stdout:\n\n@example\nobj: int\n@end example\n\n@noindent\n\nThis is invaluable when debugging.\n\nLet's create the function.  To do so, we first need to construct\nits single parameter, specifying its type and giving it a name,\nusing @pxref{10,,gcc_jit_context_new_param()}:\n\n@example\ngcc_jit_param *param_i =\n  gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n@end example\n\n@noindent\n\nNow we can create the function, using\n@pxref{11,,gcc_jit_context_new_function()}:\n\n@example\ngcc_jit_function *func =\n  gcc_jit_context_new_function (ctxt, NULL,\n                                GCC_JIT_FUNCTION_EXPORTED,\n                                int_type,\n                                \"square\",\n                                1, &param_i,\n                                0);\n@end example\n\n@noindent\n\nTo define the code within the function, we must create basic blocks\ncontaining statements.\n\nEvery basic block contains a list of statements, eventually terminated\nby a statement that either returns, or jumps to another basic block.\n\nOur function has no control-flow, so we just need one basic block:\n\n@example\ngcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n@end example\n\n@noindent\n\nOur basic block is relatively simple: it immediately terminates by\nreturning the value of an expression.\n\nWe can build the expression using @pxref{12,,gcc_jit_context_new_binary_op()}:\n\n@example\ngcc_jit_rvalue *expr =\n  gcc_jit_context_new_binary_op (\n    ctxt, NULL,\n    GCC_JIT_BINARY_OP_MULT, int_type,\n    gcc_jit_param_as_rvalue (param_i),\n    gcc_jit_param_as_rvalue (param_i));\n@end example\n\n@noindent\n\nA @pxref{13,,gcc_jit_rvalue *} is another example of a\n@pxref{e,,gcc_jit_object *} subclass.  We can upcast it using\n@pxref{14,,gcc_jit_rvalue_as_object()} and as before print it with\n@pxref{f,,gcc_jit_object_get_debug_string()}.\n\n@example\nprintf (\"expr: %s\\n\",\n        gcc_jit_object_get_debug_string (\n          gcc_jit_rvalue_as_object (expr)));\n@end example\n\n@noindent\n\ngiving this output:\n\n@example\nexpr: i * i\n@end example\n\n@noindent\n\nCreating the expression in itself doesn't do anything; we have to add\nthis expression to a statement within the block.  In this case, we use it\nto build a return statement, which terminates the basic block:\n\n@example\ngcc_jit_block_end_with_return (block, NULL, expr);\n@end example\n\n@noindent\n\nOK, we've populated the context.  We can now compile it using\n@pxref{15,,gcc_jit_context_compile()}:\n\n@example\ngcc_jit_result *result;\nresult = gcc_jit_context_compile (ctxt);\n@end example\n\n@noindent\n\nand get a @pxref{16,,gcc_jit_result *}.\n\nAt this point we're done with the context; we can release it:\n\n@example\ngcc_jit_context_release (ctxt);\n@end example\n\n@noindent\n\nWe can now use @pxref{17,,gcc_jit_result_get_code()} to look up a specific\nmachine code routine within the result, in this case, the function we\ncreated above.\n\n@example\nvoid *fn_ptr = gcc_jit_result_get_code (result, \"square\");\nif (!fn_ptr)\n  @{\n    fprintf (stderr, \"NULL fn_ptr\");\n    goto error;\n  @}\n@end example\n\n@noindent\n\nWe can now cast the pointer to an appropriate function pointer type, and\nthen call it:\n\n@example\ntypedef int (*fn_type) (int);\nfn_type square = (fn_type)fn_ptr;\nprintf (\"result: %d\", square (5));\n@end example\n\n@noindent\n\n@example\nresult: 25\n@end example\n\n@noindent\n\nOnce we're done with the code, we can release the result:\n\n@example\ngcc_jit_result_release (result);\n@end example\n\n@noindent\n\nWe can't call @code{square} anymore once we've released @code{result}.\n\n@menu\n* Error-handling:: \n* Options:: \n* Full example:: \n\n@end menu\n\n@node Error-handling,Options,,Tutorial part 2 Creating a trivial machine code function\n@anchor{intro/tutorial02 error-handling}@anchor{18}\n@subsection Error-handling\n\n\nVarious kinds of errors are possible when using the API, such as\nmismatched types in an assignment.  You can only compile and get code\nfrom a context if no errors occur.\n\nErrors are printed on stderr; they typically contain the name of the API\nentrypoint where the error occurred, and pertinent information on the\nproblem:\n\n@example\n./buggy-program: error: gcc_jit_block_add_assignment: mismatching types: assignment to i (type: int) from \"hello world\" (type: const char *)\n@end example\n\n@noindent\n\nThe API is designed to cope with errors without crashing, so you can get\naway with having a single error-handling check in your code:\n\n@example\nvoid *fn_ptr = gcc_jit_result_get_code (result, \"square\");\nif (!fn_ptr)\n  @{\n    fprintf (stderr, \"NULL fn_ptr\");\n    goto error;\n  @}\n@end example\n\n@noindent\n\nFor more information, see the @pxref{19,,error-handling guide}\nwithin the Topic eference.\n\n@node Options,Full example,Error-handling,Tutorial part 2 Creating a trivial machine code function\n@anchor{intro/tutorial02 options}@anchor{1a}\n@subsection Options\n\n\nTo get more information on what's going on, you can set debugging flags\non the context using @pxref{1b,,gcc_jit_context_set_bool_option()}.\n\n@c (I'm deliberately not mentioning\n@c :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE` here since I think\n@c it's probably more of use to implementors than to users)\n\nSetting @pxref{1c,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE} will dump a\nC-like representation to stderr when you compile (GCC's \"GIMPLE\"\nrepresentation):\n\n@example\ngcc_jit_context_set_bool_option (\n  ctxt,\n  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n  1);\nresult = gcc_jit_context_compile (ctxt);\n@end example\n\n@noindent\n\n@example\nsquare (signed int i)\n@{\n  signed int D.260;\n\n  entry:\n  D.260 = i * i;\n  return D.260;\n@}\n@end example\n\n@noindent\n\nWe can see the generated machine code in assembler form (on stderr) by\nsetting @pxref{1d,,GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE} on the context\nbefore compiling:\n\n@example\ngcc_jit_context_set_bool_option (\n  ctxt,\n  GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n  1);\nresult = gcc_jit_context_compile (ctxt);\n@end example\n\n@noindent\n\n@example\n      .file   \"fake.c\"\n      .text\n      .globl  square\n      .type   square, @@function\nsquare:\n.LFB6:\n      .cfi_startproc\n      pushq   %rbp\n      .cfi_def_cfa_offset 16\n      .cfi_offset 6, -16\n      movq    %rsp, %rbp\n      .cfi_def_cfa_register 6\n      movl    %edi, -4(%rbp)\n.L14:\n      movl    -4(%rbp), %eax\n      imull   -4(%rbp), %eax\n      popq    %rbp\n      .cfi_def_cfa 7, 8\n      ret\n      .cfi_endproc\n.LFE6:\n      .size   square, .-square\n      .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n      .section       .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nBy default, no optimizations are performed, the equivalent of GCC's\n@cite{-O0} option.  We can turn things up to e.g. @cite{-O3} by calling\n@pxref{1e,,gcc_jit_context_set_int_option()} with\n@pxref{1f,,GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL}:\n\n@example\ngcc_jit_context_set_int_option (\n  ctxt,\n  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n  3);\n@end example\n\n@noindent\n\n@example\n      .file   \"fake.c\"\n      .text\n      .p2align 4,,15\n      .globl  square\n      .type   square, @@function\nsquare:\n.LFB7:\n      .cfi_startproc\n.L16:\n      movl    %edi, %eax\n      imull   %edi, %eax\n      ret\n      .cfi_endproc\n.LFE7:\n      .size   square, .-square\n      .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n      .section        .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nNaturally this has only a small effect on such a trivial function.\n\n@node Full example,,Options,Tutorial part 2 Creating a trivial machine code function\n@anchor{intro/tutorial02 full-example}@anchor{20}\n@subsection Full example\n\n\nHere's what the above looks like as a complete program:\n\n@quotation\n\n@example\n/* Usage example for libgccjit.so\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid\ncreate_code (gcc_jit_context *ctxt)\n@{\n  /* Let's try to inject the equivalent of:\n\n      int square (int i)\n      @{\n        return i * i;\n      @}\n  */\n  gcc_jit_type *int_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n  gcc_jit_param *param_i =\n    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n  gcc_jit_function *func =\n    gcc_jit_context_new_function (ctxt, NULL,\n                                  GCC_JIT_FUNCTION_EXPORTED,\n                                  int_type,\n                                  \"square\",\n                                  1, &param_i,\n                                  0);\n\n  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n\n  gcc_jit_rvalue *expr =\n    gcc_jit_context_new_binary_op (\n      ctxt, NULL,\n      GCC_JIT_BINARY_OP_MULT, int_type,\n      gcc_jit_param_as_rvalue (param_i),\n      gcc_jit_param_as_rvalue (param_i));\n\n   gcc_jit_block_end_with_return (block, NULL, expr);\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  gcc_jit_context *ctxt = NULL;\n  gcc_jit_result *result = NULL;\n\n  /* Get a \"context\" object for working with the library.  */\n  ctxt = gcc_jit_context_acquire ();\n  if (!ctxt)\n    @{\n      fprintf (stderr, \"NULL ctxt\");\n      goto error;\n    @}\n\n  /* Set some options on the context.\n     Let's see the code being generated, in assembler form.  */\n  gcc_jit_context_set_bool_option (\n    ctxt,\n    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n    0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  result = gcc_jit_context_compile (ctxt);\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      goto error;\n    @}\n\n  /* We're done with the context; we can release it: */\n  gcc_jit_context_release (ctxt);\n  ctxt = NULL;\n\n  /* Extract the generated code from \"result\".  */\n  void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n  if (!fn_ptr)\n     @{\n       fprintf (stderr, \"NULL fn_ptr\");\n       goto error;\n     @}\n\n  typedef int (*fn_type) (int);\n  fn_type square = (fn_type)fn_ptr;\n  printf (\"result: %d\\n\", square (5));\n\n error:\n  if (ctxt)\n    gcc_jit_context_release (ctxt);\n  if (result)\n    gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nBuilding and running it:\n\n@example\n$ gcc \\\n    tut02-square.c \\\n    -o tut02-square \\\n    -lgccjit\n\n# Run the built program:\n$ ./tut02-square\nresult: 25\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 3 Loops and variables,Tutorial part 4 Adding JIT-compilation to a toy interpreter,Tutorial part 2 Creating a trivial machine code function,Tutorial\n@anchor{intro/tutorial03 tutorial-part-3-loops-and-variables}@anchor{21}@anchor{intro/tutorial03 doc}@anchor{22}\n@section Tutorial part 3: Loops and variables\n\n\nConsider this C function:\n\n@quotation\n\n@example\nint loop_test (int n)\n@{\n  int sum = 0;\n  for (int i = 0; i < n; i++)\n    sum += i * i;\n  return sum;\n@}\n@end example\n\n@noindent\n@end quotation\n\nThis example demonstrates some more features of libgccjit, with local\nvariables and a loop.\n\nTo break this down into libgccjit terms, it's usually easier to reword\nthe @cite{for} loop as a @cite{while} loop, giving:\n\n@quotation\n\n@example\nint loop_test (int n)\n@{\n  int sum = 0;\n  int i = 0;\n  while (i < n)\n  @{\n    sum += i * i;\n    i++;\n  @}\n  return sum;\n@}\n@end example\n\n@noindent\n@end quotation\n\nHere's what the final control flow graph will look like:\n\n@quotation\n\n\n@float Figure\n\n@image{sum-of-squares1,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\nAs before, we include the libgccjit header and make a\n@pxref{8,,gcc_jit_context *}.\n\n@example\n#include <libgccjit.h>\n\nvoid test (void)\n@{\n  gcc_jit_context *ctxt;\n  ctxt = gcc_jit_context_acquire ();\n@end example\n\n@noindent\n\nThe function works with the C @cite{int} type:\n\n@example\ngcc_jit_type *the_type =\n  gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\ngcc_jit_type *return_type = the_type;\n@end example\n\n@noindent\n\nthough we could equally well make it work on, say, @cite{double}:\n\n@example\ngcc_jit_type *the_type =\n  gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n@end example\n\n@noindent\n\nLet's build the function:\n\n@example\ngcc_jit_param *n =\n  gcc_jit_context_new_param (ctxt, NULL, the_type, \"n\");\ngcc_jit_param *params[1] = @{n@};\ngcc_jit_function *func =\n  gcc_jit_context_new_function (ctxt, NULL,\n                                GCC_JIT_FUNCTION_EXPORTED,\n                                return_type,\n                                \"loop_test\",\n                                1, params, 0);\n@end example\n\n@noindent\n\n@menu\n* Expressions; lvalues and rvalues: Expressions lvalues and rvalues. \n* Control flow:: \n* Visualizing the control flow graph:: \n* Full example: Full example<2>. \n\n@end menu\n\n@node Expressions lvalues and rvalues,Control flow,,Tutorial part 3 Loops and variables\n@anchor{intro/tutorial03 expressions-lvalues-and-rvalues}@anchor{23}\n@subsection Expressions: lvalues and rvalues\n\n\nThe base class of expression is the @pxref{13,,gcc_jit_rvalue *},\nrepresenting an expression that can be on the @emph{right}-hand side of\nan assignment: a value that can be computed somehow, and assigned\n@emph{to} a storage area (such as a variable).  It has a specific\n@pxref{a,,gcc_jit_type *}.\n\nAnothe important class is @pxref{24,,gcc_jit_lvalue *}.\nA @pxref{24,,gcc_jit_lvalue *}. is something that can of the @emph{left}-hand\nside of an assignment: a storage area (such as a variable).\n\nIn other words, every assignment can be thought of as:\n\n@example\nLVALUE = RVALUE;\n@end example\n\n@noindent\n\nNote that @pxref{24,,gcc_jit_lvalue *} is a subclass of\n@pxref{13,,gcc_jit_rvalue *}, where in an assignment of the form:\n\n@example\nLVALUE_A = LVALUE_B;\n@end example\n\n@noindent\n\nthe @cite{LVALUE_B} implies reading the current value of that storage\narea, assigning it into the @cite{LVALUE_A}.\n\nSo far the only expressions we've seen are @cite{i * i}:\n\n@example\ngcc_jit_rvalue *expr =\n  gcc_jit_context_new_binary_op (\n    ctxt, NULL,\n    GCC_JIT_BINARY_OP_MULT, int_type,\n    gcc_jit_param_as_rvalue (param_i),\n    gcc_jit_param_as_rvalue (param_i));\n@end example\n\n@noindent\n\nwhich is a @pxref{13,,gcc_jit_rvalue *}, and the various function\nparameters: @cite{param_i} and @cite{param_n}, instances of\n@pxref{25,,gcc_jit_param *}, which is a subclass of\n@pxref{24,,gcc_jit_lvalue *} (and, in turn, of @pxref{13,,gcc_jit_rvalue *}):\nwe can both read from and write to function parameters within the\nbody of a function.\n\nOur new example has a couple of local variables.  We create them by\ncalling @pxref{26,,gcc_jit_function_new_local()}, supplying a type and a\nname:\n\n@example\n/* Build locals:  */\ngcc_jit_lvalue *i =\n  gcc_jit_function_new_local (func, NULL, the_type, \"i\");\ngcc_jit_lvalue *sum =\n  gcc_jit_function_new_local (func, NULL, the_type, \"sum\");\n@end example\n\n@noindent\n\nThese are instances of @pxref{24,,gcc_jit_lvalue *} - they can be read from\nand written to.\n\nNote that there is no precanned way to create @emph{and} initialize a variable\nlike in C:\n\n@example\nint i = 0;\n@end example\n\n@noindent\n\nInstead, having added the local to the function, we have to separately add\nan assignment of @cite{0} to @cite{local_i} at the beginning of the function.\n\n@node Control flow,Visualizing the control flow graph,Expressions lvalues and rvalues,Tutorial part 3 Loops and variables\n@anchor{intro/tutorial03 control-flow}@anchor{27}\n@subsection Control flow\n\n\nThis function has a loop, so we need to build some basic blocks to\nhandle the control flow.  In this case, we need 4 blocks:\n\n\n@enumerate \n\n@item \nbefore the loop (initializing the locals)\n\n@item \nthe conditional at the top of the loop (comparing @cite{i < n})\n\n@item \nthe body of the loop\n\n@item \nafter the loop terminates (@cite{return sum})\n@end enumerate\n\nso we create these as @pxref{28,,gcc_jit_block *} instances within the\n@pxref{29,,gcc_jit_function *}:\n\n@example\ngcc_jit_block *b_initial =\n  gcc_jit_function_new_block (func, \"initial\");\ngcc_jit_block *b_loop_cond =\n  gcc_jit_function_new_block (func, \"loop_cond\");\ngcc_jit_block *b_loop_body =\n  gcc_jit_function_new_block (func, \"loop_body\");\ngcc_jit_block *b_after_loop =\n  gcc_jit_function_new_block (func, \"after_loop\");\n@end example\n\n@noindent\n\nWe now populate each block with statements.\n\nThe entry block @cite{b_initial} consists of initializations followed by a jump\nto the conditional.  We assign @cite{0} to @cite{i} and to @cite{sum}, using\n@pxref{2a,,gcc_jit_block_add_assignment()} to add\nan assignment statement, and using @pxref{2b,,gcc_jit_context_zero()} to get\nthe constant value @cite{0} for the relevant type for the right-hand side of\nthe assignment:\n\n@example\n/* sum = 0; */\ngcc_jit_block_add_assignment (\n  b_initial, NULL,\n  sum,\n  gcc_jit_context_zero (ctxt, the_type));\n\n/* i = 0; */\ngcc_jit_block_add_assignment (\n  b_initial, NULL,\n  i,\n  gcc_jit_context_zero (ctxt, the_type));\n@end example\n\n@noindent\n\nWe can then terminate the entry block by jumping to the conditional:\n\n@example\ngcc_jit_block_end_with_jump (b_initial, NULL, b_loop_cond);\n@end example\n\n@noindent\n\nThe conditional block is equivalent to the line @cite{while (i < n)} from our\nC example. It contains a single statement: a conditional, which jumps to\none of two destination blocks depending on a boolean\n@pxref{13,,gcc_jit_rvalue *}, in this case the comparison of @cite{i} and @cite{n}.\nWe build the comparison using @pxref{2c,,gcc_jit_context_new_comparison()}:\n\n@example\n/* (i >= n) */\n gcc_jit_rvalue *guard =\n   gcc_jit_context_new_comparison (\n     ctxt, NULL,\n     GCC_JIT_COMPARISON_GE,\n     gcc_jit_lvalue_as_rvalue (i),\n     gcc_jit_param_as_rvalue (n));\n@end example\n\n@noindent\n\nand can then use this to add @cite{b_loop_cond}'s sole statement, via\n@pxref{2d,,gcc_jit_block_end_with_conditional()}:\n\n@example\n/* Equivalent to:\n     if (guard)\n       goto after_loop;\n     else\n       goto loop_body;  */\ngcc_jit_block_end_with_conditional (\n  b_loop_cond, NULL,\n  guard,\n  b_after_loop, /* on_true */\n  b_loop_body); /* on_false */\n@end example\n\n@noindent\n\nNext, we populate the body of the loop.\n\nThe C statement @cite{sum += i * i;} is an assignment operation, where an\nlvalue is modified \"in-place\".  We use\n@pxref{2e,,gcc_jit_block_add_assignment_op()} to handle these operations:\n\n@example\n/* sum += i * i */\ngcc_jit_block_add_assignment_op (\n  b_loop_body, NULL,\n  sum,\n  GCC_JIT_BINARY_OP_PLUS,\n  gcc_jit_context_new_binary_op (\n    ctxt, NULL,\n    GCC_JIT_BINARY_OP_MULT, the_type,\n    gcc_jit_lvalue_as_rvalue (i),\n    gcc_jit_lvalue_as_rvalue (i)));\n@end example\n\n@noindent\n\nThe @cite{i++} can be thought of as @cite{i += 1}, and can thus be handled in\na similar way.  We use @pxref{2f,,gcc_jit_context_one()} to get the constant\nvalue @cite{1} (for the relevant type) for the right-hand side\nof the assignment.\n\n@example\n/* i++ */\ngcc_jit_block_add_assignment_op (\n  b_loop_body, NULL,\n  i,\n  GCC_JIT_BINARY_OP_PLUS,\n  gcc_jit_context_one (ctxt, the_type));\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nFor numeric constants other than 0 or 1, we could use\n@pxref{30,,gcc_jit_context_new_rvalue_from_int()} and\n@pxref{31,,gcc_jit_context_new_rvalue_from_double()}.\n@end quotation\n@end cartouche\n\nThe loop body completes by jumping back to the conditional:\n\n@example\ngcc_jit_block_end_with_jump (b_loop_body, NULL, b_loop_cond);\n@end example\n\n@noindent\n\nFinally, we populate the @cite{b_after_loop} block, reached when the loop\nconditional is false.  We want to generate the equivalent of:\n\n@example\nreturn sum;\n@end example\n\n@noindent\n\nso the block is just one statement:\n\n@example\n/* return sum */\ngcc_jit_block_end_with_return (\n  b_after_loop,\n  NULL,\n  gcc_jit_lvalue_as_rvalue (sum));\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nYou can intermingle block creation with statement creation,\nbut given that the terminator statements generally include references\nto other blocks, I find it's clearer to create all the blocks,\n@emph{then} all the statements.\n@end quotation\n@end cartouche\n\nWe've finished populating the function.  As before, we can now compile it\nto machine code:\n\n@example\ngcc_jit_result *result;\nresult = gcc_jit_context_compile (ctxt);\n\ntypedef int (*loop_test_fn_type) (int);\nloop_test_fn_type loop_test =\n (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\nif (!loop_test)\n  goto error;\nprintf (\"result: %d\", loop_test (10));\n@end example\n\n@noindent\n\n@example\nresult: 285\n@end example\n\n@noindent\n\n@node Visualizing the control flow graph,Full example<2>,Control flow,Tutorial part 3 Loops and variables\n@anchor{intro/tutorial03 visualizing-the-control-flow-graph}@anchor{32}\n@subsection Visualizing the control flow graph\n\n\nYou can see the control flow graph of a function using\n@pxref{33,,gcc_jit_function_dump_to_dot()}:\n\n@example\ngcc_jit_function_dump_to_dot (func, \"/tmp/sum-of-squares.dot\");\n@end example\n\n@noindent\n\ngiving a .dot file in GraphViz format.\n\nYou can convert this to an image using @cite{dot}:\n\n@example\n$ dot -Tpng /tmp/sum-of-squares.dot -o /tmp/sum-of-squares.png\n@end example\n\n@noindent\n\nor use a viewer (my preferred one is xdot.py; see\n@indicateurl{https://github.com/jrfonseca/xdot.py}; on Fedora you can\ninstall it with @cite{yum install python-xdot}):\n\n@quotation\n\n\n@float Figure\n\n@image{sum-of-squares1,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\n@node Full example<2>,,Visualizing the control flow graph,Tutorial part 3 Loops and variables\n@anchor{intro/tutorial03 full-example}@anchor{34}\n@subsection Full example\n\n\n@quotation\n\n@example\n/* Usage example for libgccjit.so\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid\ncreate_code (gcc_jit_context *ctxt)\n@{\n  /*\n    Simple sum-of-squares, to test conditionals and looping\n\n    int loop_test (int n)\n    @{\n      int i;\n      int sum = 0;\n      for (i = 0; i < n ; i ++)\n      @{\n\tsum += i * i;\n      @}\n      return sum;\n   */\n  gcc_jit_type *the_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n  gcc_jit_type *return_type = the_type;\n\n  gcc_jit_param *n =\n    gcc_jit_context_new_param (ctxt, NULL, the_type, \"n\");\n  gcc_jit_param *params[1] = @{n@};\n  gcc_jit_function *func =\n    gcc_jit_context_new_function (ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n\t\t\t\t  return_type,\n\t\t\t\t  \"loop_test\",\n\t\t\t\t  1, params, 0);\n\n  /* Build locals:  */\n  gcc_jit_lvalue *i =\n    gcc_jit_function_new_local (func, NULL, the_type, \"i\");\n  gcc_jit_lvalue *sum =\n    gcc_jit_function_new_local (func, NULL, the_type, \"sum\");\n\n  gcc_jit_block *b_initial =\n    gcc_jit_function_new_block (func, \"initial\");\n  gcc_jit_block *b_loop_cond =\n    gcc_jit_function_new_block (func, \"loop_cond\");\n  gcc_jit_block *b_loop_body =\n    gcc_jit_function_new_block (func, \"loop_body\");\n  gcc_jit_block *b_after_loop =\n    gcc_jit_function_new_block (func, \"after_loop\");\n\n  /* sum = 0; */\n  gcc_jit_block_add_assignment (\n    b_initial, NULL,\n    sum,\n    gcc_jit_context_zero (ctxt, the_type));\n\n  /* i = 0; */\n  gcc_jit_block_add_assignment (\n    b_initial, NULL,\n    i,\n    gcc_jit_context_zero (ctxt, the_type));\n\n  gcc_jit_block_end_with_jump (b_initial, NULL, b_loop_cond);\n\n  /* if (i >= n) */\n  gcc_jit_block_end_with_conditional (\n    b_loop_cond, NULL,\n    gcc_jit_context_new_comparison (\n       ctxt, NULL,\n       GCC_JIT_COMPARISON_GE,\n       gcc_jit_lvalue_as_rvalue (i),\n       gcc_jit_param_as_rvalue (n)),\n    b_after_loop,\n    b_loop_body);\n\n  /* sum += i * i */\n  gcc_jit_block_add_assignment_op (\n    b_loop_body, NULL,\n    sum,\n    GCC_JIT_BINARY_OP_PLUS,\n    gcc_jit_context_new_binary_op (\n      ctxt, NULL,\n      GCC_JIT_BINARY_OP_MULT, the_type,\n      gcc_jit_lvalue_as_rvalue (i),\n      gcc_jit_lvalue_as_rvalue (i)));\n\n  /* i++ */\n  gcc_jit_block_add_assignment_op (\n    b_loop_body, NULL,\n    i,\n    GCC_JIT_BINARY_OP_PLUS,\n    gcc_jit_context_one (ctxt, the_type));\n\n  gcc_jit_block_end_with_jump (b_loop_body, NULL, b_loop_cond);\n\n  /* return sum */\n  gcc_jit_block_end_with_return (\n    b_after_loop,\n    NULL,\n    gcc_jit_lvalue_as_rvalue (sum));\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  gcc_jit_context *ctxt = NULL;\n  gcc_jit_result *result = NULL;\n\n  /* Get a \"context\" object for working with the library.  */\n  ctxt = gcc_jit_context_acquire ();\n  if (!ctxt)\n    @{\n      fprintf (stderr, \"NULL ctxt\");\n      goto error;\n    @}\n\n  /* Set some options on the context.\n     Let's see the code being generated, in assembler form.  */\n  gcc_jit_context_set_bool_option (\n    ctxt,\n    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n    0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  result = gcc_jit_context_compile (ctxt);\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      goto error;\n    @}\n\n  /* Extract the generated code from \"result\".  */\n  typedef int (*loop_test_fn_type) (int);\n  loop_test_fn_type loop_test =\n    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n  if (!loop_test)\n    @{\n      fprintf (stderr, \"NULL loop_test\");\n      goto error;\n    @}\n\n  /* Run the generated code.  */\n  int val = loop_test (10);\n  printf(\"loop_test returned: %d\\n\", val);\n\n error:\n  gcc_jit_context_release (ctxt);\n  gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nBuilding and running it:\n\n@example\n$ gcc \\\n    tut03-sum-of-squares.c \\\n    -o tut03-sum-of-squares \\\n    -lgccjit\n\n# Run the built program:\n$ ./tut03-sum-of-squares\nloop_test returned: 285\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 4 Adding JIT-compilation to a toy interpreter,Tutorial part 5 Implementing an Ahead-of-Time compiler,Tutorial part 3 Loops and variables,Tutorial\n@anchor{intro/tutorial04 tutorial-part-4-adding-jit-compilation-to-a-toy-interpreter}@anchor{35}@anchor{intro/tutorial04 doc}@anchor{36}\n@section Tutorial part 4: Adding JIT-compilation to a toy interpreter\n\n\nIn this example we construct a \"toy\" interpreter, and add JIT-compilation\nto it.\n\n@menu\n* Our toy interpreter:: \n* Compiling to machine code:: \n* Setting things up:: \n* Populating the function:: \n* Verifying the control flow graph:: \n* Compiling the context:: \n* Single-stepping through the generated code:: \n* Examining the generated code:: \n* Putting it all together:: \n* Behind the curtain; How does our code get optimized?: Behind the curtain How does our code get optimized?. \n\n@end menu\n\n@node Our toy interpreter,Compiling to machine code,,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 our-toy-interpreter}@anchor{37}\n@subsection Our toy interpreter\n\n\nIt's a stack-based interpreter, and is intended as a (very simple) example\nof the kind of bytecode interpreter seen in dynamic languages such as\nPython, Ruby etc.\n\nFor the sake of simplicity, our toy virtual machine is very limited:\n\n@quotation\n\n\n@itemize *\n\n@item \nThe only data type is @cite{int}\n\n@item \nIt can only work on one function at a time (so that the only\nfunction call that can be made is to recurse).\n\n@item \nFunctions can only take one parameter.\n\n@item \nFunctions have a stack of @cite{int} values.\n\n@item \nWe'll implement function call within the interpreter by calling a\nfunction in our implementation, rather than implementing our own\nframe stack.\n\n@item \nThe parser is only good enough to get the examples to work.\n@end itemize\n@end quotation\n\nNaturally, a real interpreter would be much more complicated that this.\n\nThe following operations are supported:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxx} \n@headitem\n\nOperation\n\n@tab\n\nMeaning\n\n@tab\n\nOld Stack\n\n@tab\n\nNew Stack\n\n@item\n\nDUP\n\n@tab\n\nDuplicate top of stack.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[..., x, x]}\n\n@item\n\nROT\n\n@tab\n\nSwap top two elements\nof stack.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., y, x]}\n\n@item\n\nBINARY_ADD\n\n@tab\n\nAdd the top two elements\non the stack.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x+y)]}\n\n@item\n\nBINARY_SUBTRACT\n\n@tab\n\nLikewise, but subtract.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x-y)]}\n\n@item\n\nBINARY_MULT\n\n@tab\n\nLikewise, but multiply.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x*y)]}\n\n@item\n\nBINARY_COMPARE_LT\n\n@tab\n\nCompare the top two\nelements on the stack\nand push a nonzero/zero\nif (x<y).\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x<y)]}\n\n@item\n\nRECURSE\n\n@tab\n\nRecurse, passing the top\nof the stack, and\npopping the result.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[..., fn(x)]}\n\n@item\n\nRETURN\n\n@tab\n\nReturn the top of the\nstack.\n\n@tab\n\n@code{[x]}\n\n@tab\n\n@code{[]}\n\n@item\n\nPUSH_CONST @cite{arg}\n\n@tab\n\nPush an int const.\n\n@tab\n\n@code{[...]}\n\n@tab\n\n@code{[..., arg]}\n\n@item\n\nJUMP_ABS_IF_TRUE @cite{arg}\n\n@tab\n\nPop; if top of stack was\nnonzero, jump to\n@code{arg}.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[...]}\n\n@end multitable\n\n\nPrograms can be interpreted, disassembled, and compiled to machine code.\n\nThe interpreter reads @code{.toy} scripts.  Here's what a simple recursive\nfactorial program looks like, the script @code{factorial.toy}.\nThe parser ignores lines beginning with a @cite{#}.\n\n@quotation\n\n@example\n# Simple recursive factorial implementation, roughly equivalent to:\n#\n#  int factorial (int arg)\n#  @{\n#     if (arg < 2)\n#       return arg\n#     return arg * factorial (arg - 1)\n#  @}\n\n# Initial state:\n# stack: [arg]\n\n# 0:\nDUP\n# stack: [arg, arg]\n\n# 1:\nPUSH_CONST 2\n# stack: [arg, arg, 2]\n\n# 2:\nBINARY_COMPARE_LT\n# stack: [arg, (arg < 2)]\n\n# 3:\nJUMP_ABS_IF_TRUE 9\n# stack: [arg]\n\n# 4:\nDUP\n# stack: [arg, arg]\n\n# 5:\nPUSH_CONST 1\n# stack: [arg, arg, 1]\n\n# 6:\nBINARY_SUBTRACT\n# stack: [arg,  (arg - 1)\n\n# 7:\nRECURSE\n# stack: [arg, factorial(arg - 1)]\n\n# 8:\nBINARY_MULT\n# stack: [arg * factorial(arg - 1)]\n\n# 9:\nRETURN\n\n@end example\n\n@noindent\n@end quotation\n\nThe interpreter is a simple infinite loop with a big @code{switch} statement\nbased on what the next opcode is:\n\n@quotation\n\n@example\n\nstatic int\ntoyvm_function_interpret (toyvm_function *fn, int arg, FILE *trace)\n@{\n  toyvm_frame frame;\n#define PUSH(ARG) (toyvm_frame_push (&frame, (ARG)))\n#define POP(ARG) (toyvm_frame_pop (&frame))\n\n  frame.frm_function = fn;\n  frame.frm_pc = 0;\n  frame.frm_cur_depth = 0;\n\n  PUSH (arg);\n\n  while (1)\n    @{\n      toyvm_op *op;\n      int x, y;\n      assert (frame.frm_pc < fn->fn_num_ops);\n      op = &fn->fn_ops[frame.frm_pc++];\n\n      if (trace)\n\t@{\n\t  toyvm_frame_dump_stack (&frame, trace);\n\t  toyvm_function_disassemble_op (fn, op, frame.frm_pc, trace);\n\t@}\n\n      switch (op->op_opcode)\n\t@{\n\t  /* Ops taking no operand.  */\n\tcase DUP:\n\t  x = POP ();\n\t  PUSH (x);\n\t  PUSH (x);\n\t  break;\n\n\tcase ROT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (y);\n\t  PUSH (x);\n\t  break;\n\n\tcase BINARY_ADD:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x + y);\n\t  break;\n\n\tcase BINARY_SUBTRACT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x - y);\n\t  break;\n\n\tcase BINARY_MULT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x * y);\n\t  break;\n\n\tcase BINARY_COMPARE_LT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x < y);\n\t  break;\n\n\tcase RECURSE:\n\t  x = POP ();\n\t  x = toyvm_function_interpret (fn, x, trace);\n\t  PUSH (x);\n\t  break;\n\n\tcase RETURN:\n\t  return POP ();\n\n\t  /* Ops taking an operand.  */\n\tcase PUSH_CONST:\n\t  PUSH (op->op_operand);\n\t  break;\n\n\tcase JUMP_ABS_IF_TRUE:\n\t  x = POP ();\n\t  if (x)\n\t    frame.frm_pc = op->op_operand;\n\t  break;\n\n\tdefault:\n\t  assert (0); /* unknown opcode */\n\n\t@} /* end of switch on opcode */\n    @} /* end of while loop */\n\n#undef PUSH\n#undef POP\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Compiling to machine code,Setting things up,Our toy interpreter,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 compiling-to-machine-code}@anchor{38}\n@subsection Compiling to machine code\n\n\nWe want to generate machine code that can be cast to this type and\nthen directly executed in-process:\n\n@quotation\n\n@example\ntypedef int (*toyvm_compiled_code) (int);\n\n\n@end example\n\n@noindent\n@end quotation\n\nThe lifetime of the code is tied to that of a @pxref{16,,gcc_jit_result *}.\nWe'll handle this by bundling them up in a structure, so that we can\nclean them up together by calling @pxref{39,,gcc_jit_result_release()}:\n\n@quotation\n\n@example\n\nstruct toyvm_compiled_function\n@{\n  gcc_jit_result *cf_jit_result;\n  toyvm_compiled_code cf_code;\n@};\n\n\n@end example\n\n@noindent\n@end quotation\n\nOur compiler isn't very sophisticated; it takes the implementation of\neach opcode above, and maps it directly to the operations supported by\nthe libgccjit API.\n\nHow should we handle the stack?  In theory we could calculate what the\nstack depth will be at each opcode, and optimize away the stack\nmanipulation \"by hand\".  We'll see below that libgccjit is able to do\nthis for us, so we'll implement stack manipulation\nin a direct way, by creating a @code{stack} array and @code{stack_depth}\nvariables, local within the generated function, equivalent to this C code:\n\n@example\nint stack_depth;\nint stack[MAX_STACK_DEPTH];\n@end example\n\n@noindent\n\nWe'll also have local variables @code{x} and @code{y} for use when implementing\nthe opcodes, equivalent to this:\n\n@example\nint x;\nint y;\n@end example\n\n@noindent\n\nThis means our compiler has the following state:\n\n@quotation\n\n@example\n\nstruct compilation_state\n@{\n  gcc_jit_context *ctxt;\n\n  gcc_jit_type *int_type;\n  gcc_jit_type *bool_type;\n  gcc_jit_type *stack_type; /* int[MAX_STACK_DEPTH] */\n\n  gcc_jit_rvalue *const_one;\n\n  gcc_jit_function *fn;\n  gcc_jit_param *param_arg;\n  gcc_jit_lvalue *stack;\n  gcc_jit_lvalue *stack_depth;\n  gcc_jit_lvalue *x;\n  gcc_jit_lvalue *y;\n\n  gcc_jit_location *op_locs[MAX_OPS];\n  gcc_jit_block *initial_block;\n  gcc_jit_block *op_blocks[MAX_OPS];\n\n@};\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Setting things up,Populating the function,Compiling to machine code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 setting-things-up}@anchor{3a}\n@subsection Setting things up\n\n\nFirst we create our types:\n\n@quotation\n\n@example\n  state.int_type =\n    gcc_jit_context_get_type (state.ctxt, GCC_JIT_TYPE_INT);\n  state.bool_type =\n    gcc_jit_context_get_type (state.ctxt, GCC_JIT_TYPE_BOOL);\n  state.stack_type =\n    gcc_jit_context_new_array_type (state.ctxt, NULL,\n\t\t\t\t    state.int_type, MAX_STACK_DEPTH);\n\n\n@end example\n\n@noindent\n@end quotation\n\nalong with extracting a useful @cite{int} constant:\n\n@quotation\n\n@example\n  state.const_one = gcc_jit_context_one (state.ctxt, state.int_type);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe'll implement push and pop in terms of the @code{stack} array and\n@code{stack_depth}.  Here are helper functions for adding statements to\na block, implementing pushing and popping values:\n\n@quotation\n\n@example\n\nstatic void\nadd_push (compilation_state *state,\n\t  gcc_jit_block *block,\n\t  gcc_jit_rvalue *rvalue,\n\t  gcc_jit_location *loc)\n@{\n  /* stack[stack_depth] = RVALUE */\n  gcc_jit_block_add_assignment (\n    block,\n    loc,\n    /* stack[stack_depth] */\n    gcc_jit_context_new_array_access (\n      state->ctxt,\n      loc,\n      gcc_jit_lvalue_as_rvalue (state->stack),\n      gcc_jit_lvalue_as_rvalue (state->stack_depth)),\n    rvalue);\n\n  /* \"stack_depth++;\".  */\n  gcc_jit_block_add_assignment_op (\n    block,\n    loc,\n    state->stack_depth,\n    GCC_JIT_BINARY_OP_PLUS,\n    state->const_one);\n@}\n\nstatic void\nadd_pop (compilation_state *state,\n\t gcc_jit_block *block,\n\t gcc_jit_lvalue *lvalue,\n\t gcc_jit_location *loc)\n@{\n  /* \"--stack_depth;\".  */\n  gcc_jit_block_add_assignment_op (\n    block,\n    loc,\n    state->stack_depth,\n    GCC_JIT_BINARY_OP_MINUS,\n    state->const_one);\n\n  /* \"LVALUE = stack[stack_depth];\".  */\n  gcc_jit_block_add_assignment (\n    block,\n    loc,\n    lvalue,\n    /* stack[stack_depth] */\n    gcc_jit_lvalue_as_rvalue (\n      gcc_jit_context_new_array_access (\n\tstate->ctxt,\n\tloc,\n\tgcc_jit_lvalue_as_rvalue (state->stack),\n\tgcc_jit_lvalue_as_rvalue (state->stack_depth))));\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe will support single-stepping through the generated code in the\ndebugger, so we need to create @pxref{3b,,gcc_jit_location} instances, one\nper operation in the source code.  These will reference the lines of\ne.g. @code{factorial.toy}.\n\n@quotation\n\n@example\n  for (pc = 0; pc < fn->fn_num_ops; pc++)\n    @{\n      toyvm_op *op = &fn->fn_ops[pc];\n\n      state.op_locs[pc] = gcc_jit_context_new_location (state.ctxt,\n\t\t\t\t\t\t\tfn->fn_filename,\n\t\t\t\t\t\t\top->op_linenum,\n\t\t\t\t\t\t\t0); /* column */\n    @}\n\n\n@end example\n\n@noindent\n@end quotation\n\nLet's create the function itself.  As usual, we create its parameter\nfirst, then use the parameter to create the function:\n\n@quotation\n\n@example\n  state.param_arg =\n    gcc_jit_context_new_param (state.ctxt, state.op_locs[0],\n\t\t\t       state.int_type, \"arg\");\n  state.fn =\n    gcc_jit_context_new_function (state.ctxt,\n\t\t\t\t  state.op_locs[0],\n\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n\t\t\t\t  state.int_type,\n\t\t\t\t  funcname,\n\t\t\t\t  1, &state.param_arg, 0);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe create the locals within the function.\n\n@quotation\n\n@example\n  state.stack =\n    gcc_jit_function_new_local (state.fn, NULL,\n\t\t\t\tstate.stack_type, \"stack\");\n  state.stack_depth =\n    gcc_jit_function_new_local (state.fn, NULL,\n\t\t\t\tstate.int_type, \"stack_depth\");\n  state.x =\n    gcc_jit_function_new_local (state.fn, NULL,\n\t\t\t\tstate.int_type, \"x\");\n  state.y =\n    gcc_jit_function_new_local (state.fn, NULL,\n\t\t\t\tstate.int_type, \"y\");\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Populating the function,Verifying the control flow graph,Setting things up,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 populating-the-function}@anchor{3c}\n@subsection Populating the function\n\n\nThere's some one-time initialization, and the API treats the first block\nyou create as the entrypoint of the function, so we need to create that\nblock first:\n\n@quotation\n\n@example\n  state.initial_block = gcc_jit_function_new_block (state.fn, \"initial\");\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now create blocks for each of the operations.  Most of these will\nbe consolidated into larger blocks when the optimizer runs.\n\n@quotation\n\n@example\n  for (pc = 0; pc < fn->fn_num_ops; pc++)\n    @{\n      char buf[16];\n      sprintf (buf, \"instr%i\", pc);\n      state.op_blocks[pc] = gcc_jit_function_new_block (state.fn, buf);\n    @}\n\n\n@end example\n\n@noindent\n@end quotation\n\nNow that we have a block it can jump to when it's done, we can populate\nthe initial block:\n\n@quotation\n\n@example\n\n  /* \"stack_depth = 0;\".  */\n  gcc_jit_block_add_assignment (\n    state.initial_block,\n    state.op_locs[0],\n    state.stack_depth,\n    gcc_jit_context_zero (state.ctxt, state.int_type));\n\n  /* \"PUSH (arg);\".  */\n  add_push (&state,\n\t    state.initial_block,\n\t    gcc_jit_param_as_rvalue (state.param_arg),\n\t    state.op_locs[0]);\n\n  /* ...and jump to insn 0.  */\n  gcc_jit_block_end_with_jump (state.initial_block,\n\t\t\t       state.op_locs[0],\n\t\t\t       state.op_blocks[0]);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now populate the blocks for the individual operations.  We loop\nthrough them, adding instructions to their blocks:\n\n@quotation\n\n@example\n  for (pc = 0; pc < fn->fn_num_ops; pc++)\n    @{\n      gcc_jit_location *loc = state.op_locs[pc];\n\n      gcc_jit_block *block = state.op_blocks[pc];\n      gcc_jit_block *next_block = (pc < fn->fn_num_ops\n\t\t\t\t   ? state.op_blocks[pc + 1]\n\t\t\t\t   : NULL);\n\n      toyvm_op *op;\n      op = &fn->fn_ops[pc];\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe're going to have another big @code{switch} statement for implementing\nthe opcodes, this time for compiling them, rather than interpreting\nthem.  It's helpful to have macros for implementing push and pop, so that\nwe can make the @code{switch} statement that's coming up look as much as\npossible like the one above within the interpreter:\n\n@example\n\n#define X_EQUALS_POP()\\\n      add_pop (&state, block, state.x, loc)\n#define Y_EQUALS_POP()\\\n      add_pop (&state, block, state.y, loc)\n#define PUSH_RVALUE(RVALUE)\\\n      add_push (&state, block, (RVALUE), loc)\n#define PUSH_X()\\\n      PUSH_RVALUE (gcc_jit_lvalue_as_rvalue (state.x))\n#define PUSH_Y() \\\n      PUSH_RVALUE (gcc_jit_lvalue_as_rvalue (state.y))\n\n\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nA particularly clever implementation would have an @emph{identical}\n@code{switch} statement shared by the interpreter and the compiler, with\nsome preprocessor \"magic\".  We're not doing that here, for the sake\nof simplicity.\n@end quotation\n@end cartouche\n\nWhen I first implemented this compiler, I accidentally missed an edit\nwhen copying and pasting the @code{Y_EQUALS_POP} macro, so that popping the\nstack into @code{y} instead erroneously assigned it to @code{x}, leaving @code{y}\nuninitialized.\n\nTo track this kind of thing down, we can use\n@pxref{3d,,gcc_jit_block_add_comment()} to add descriptive comments\nto the internal representation.  This is invaluable when looking through\nthe generated IR for, say @code{factorial}:\n\n@quotation\n\n@example\n\n      gcc_jit_block_add_comment (block, loc, opcode_names[op->op_opcode]);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now write the big @code{switch} statement that implements the\nindividual opcodes, populating the relevant block with statements:\n\n@quotation\n\n@example\n\n      switch (op->op_opcode)\n\t@{\n\tcase DUP:\n\t  X_EQUALS_POP ();\n\t  PUSH_X ();\n\t  PUSH_X ();\n\t  break;\n\n\tcase ROT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_Y ();\n\t  PUSH_X ();\n\t  break;\n\n\tcase BINARY_ADD:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t   gcc_jit_context_new_binary_op (\n\t     state.ctxt,\n\t     loc,\n\t     GCC_JIT_BINARY_OP_PLUS,\n\t     state.int_type,\n\t     gcc_jit_lvalue_as_rvalue (state.x),\n\t     gcc_jit_lvalue_as_rvalue (state.y)));\n\t  break;\n\n\tcase BINARY_SUBTRACT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t   gcc_jit_context_new_binary_op (\n\t     state.ctxt,\n\t     loc,\n\t     GCC_JIT_BINARY_OP_MINUS,\n\t     state.int_type,\n\t     gcc_jit_lvalue_as_rvalue (state.x),\n\t     gcc_jit_lvalue_as_rvalue (state.y)));\n\t  break;\n\n\tcase BINARY_MULT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t   gcc_jit_context_new_binary_op (\n\t     state.ctxt,\n\t     loc,\n\t     GCC_JIT_BINARY_OP_MULT,\n\t     state.int_type,\n\t     gcc_jit_lvalue_as_rvalue (state.x),\n\t     gcc_jit_lvalue_as_rvalue (state.y)));\n\t  break;\n\n\tcase BINARY_COMPARE_LT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t     /* cast of bool to int */\n\t     gcc_jit_context_new_cast (\n\t       state.ctxt,\n\t       loc,\n\t       /* (x < y) as a bool */\n\t       gcc_jit_context_new_comparison (\n\t\t state.ctxt,\n\t\t loc,\n\t\t GCC_JIT_COMPARISON_LT,\n\t\t gcc_jit_lvalue_as_rvalue (state.x),\n\t\t gcc_jit_lvalue_as_rvalue (state.y)),\n\t       state.int_type));\n\t  break;\n\n\tcase RECURSE:\n\t  @{\n\t    X_EQUALS_POP ();\n\t    gcc_jit_rvalue *arg = gcc_jit_lvalue_as_rvalue (state.x);\n\t    PUSH_RVALUE (\n\t      gcc_jit_context_new_call (\n\t\tstate.ctxt,\n\t\tloc,\n\t\tstate.fn,\n\t\t1, &arg));\n\t    break;\n\t  @}\n\n\tcase RETURN:\n\t  X_EQUALS_POP ();\n\t  gcc_jit_block_end_with_return (\n\t    block,\n\t    loc,\n\t    gcc_jit_lvalue_as_rvalue (state.x));\n\t  break;\n\n\t  /* Ops taking an operand.  */\n\tcase PUSH_CONST:\n\t  PUSH_RVALUE (\n\t    gcc_jit_context_new_rvalue_from_int (\n\t      state.ctxt,\n\t      state.int_type,\n\t      op->op_operand));\n\t  break;\n\n\tcase JUMP_ABS_IF_TRUE:\n\t  X_EQUALS_POP ();\n\t  gcc_jit_block_end_with_conditional (\n\t    block,\n\t    loc,\n\t    /* \"(bool)x\".  */\n\t    gcc_jit_context_new_cast (\n\t      state.ctxt,\n\t      loc,\n\t      gcc_jit_lvalue_as_rvalue (state.x),\n\t      state.bool_type),\n\t    state.op_blocks[op->op_operand], /* on_true */\n\t    next_block); /* on_false */\n\t  break;\n\n\tdefault:\n\t  assert(0);\n\t@} /* end of switch on opcode */\n\n\n@end example\n\n@noindent\n@end quotation\n\nEvery block must be terminated, via a call to one of the\n@code{gcc_jit_block_end_with_} entrypoints.  This has been done for two\nof the opcodes, but we need to do it for the other ones, by jumping\nto the next block.\n\n@quotation\n\n@example\n      if (op->op_opcode != JUMP_ABS_IF_TRUE\n\t  && op->op_opcode != RETURN)\n\tgcc_jit_block_end_with_jump (\n\t  block,\n\t  loc,\n\t  next_block);\n\n\n@end example\n\n@noindent\n@end quotation\n\nThis is analogous to simply incrementing the program counter.\n\n@node Verifying the control flow graph,Compiling the context,Populating the function,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 verifying-the-control-flow-graph}@anchor{3e}\n@subsection Verifying the control flow graph\n\n\nHaving finished looping over the blocks, the context is complete.\n\nAs before, we can verify that the control flow and statements are sane by\nusing @pxref{33,,gcc_jit_function_dump_to_dot()}:\n\n@example\ngcc_jit_function_dump_to_dot (state.fn, \"/tmp/factorial.dot\");\n@end example\n\n@noindent\n\nand viewing the result.  Note how the label names, comments, and\nvariable names show up in the dump, to make it easier to spot\nerrors in our compiler.\n\n@quotation\n\n\n@float Figure\n\n@image{factorial1,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\n@node Compiling the context,Single-stepping through the generated code,Verifying the control flow graph,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 compiling-the-context}@anchor{3f}\n@subsection Compiling the context\n\n\nHaving finished looping over the blocks and populating them with\nstatements, the context is complete.\n\nWe can now compile it, and extract machine code from the result:\n\n@quotation\n\n@example\n  gcc_jit_result *jit_result = gcc_jit_context_compile (state.ctxt);\n  gcc_jit_context_release (state.ctxt);\n\n  toyvm_compiled_function *toyvm_result =\n    (toyvm_compiled_function *)calloc (1, sizeof (toyvm_compiled_function));\n  if (!toyvm_result)\n    @{\n      fprintf (stderr, \"out of memory allocating toyvm_compiled_function\\n\");\n      gcc_jit_result_release (jit_result);\n      return NULL;\n    @}\n\n  toyvm_result->cf_jit_result = jit_result;\n  toyvm_result->cf_code =\n    (toyvm_compiled_code)gcc_jit_result_get_code (jit_result,\n\t\t\t\t\t\t  funcname);\n\n  free (funcname);\n\n  return toyvm_result;\n@}\n\nchar test[1024];\n\n#define CHECK_NON_NULL(PTR) \\\n  do @{                                       \\\n    if ((PTR) != NULL)                       \\\n      @{                                      \\\n\tpass (\"%s: %s is non-null\", test, #PTR); \\\n      @}                                      \\\n    else                                     \\\n      @{                                      \\\n\tfail (\"%s: %s is NULL\", test, #PTR); \\\n\tabort ();                            \\\n    @}                                        \\\n  @} while (0)\n\n#define CHECK_VALUE(ACTUAL, EXPECTED) \\\n  do @{                                       \\\n    if ((ACTUAL) == (EXPECTED))              \\\n      @{                                      \\\n\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n      @}                                      \\\n    else                                     \\\n      @{                                        \\\n\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n\tfprintf (stderr, \"incorrect value\\n\"); \\\n\tabort ();                              \\\n    @}                                        \\\n  @} while (0)\n\nstatic void\ntest_script (const char *scripts_dir, const char *script_name, int input,\n\t     int expected_result)\n@{\n  char *script_path;\n  toyvm_function *fn;\n  int interpreted_result;\n  toyvm_compiled_function *compiled_fn;\n  toyvm_compiled_code code;\n  int compiled_result;\n\n  snprintf (test, sizeof (test), \"toyvm.c: %s\", script_name);\n\n  script_path = (char *)malloc (strlen (scripts_dir)\n\t\t\t\t+ strlen (script_name) + 1);\n  CHECK_NON_NULL (script_path);\n  sprintf (script_path, \"%s%s\", scripts_dir, script_name);\n\n  fn = toyvm_function_parse (script_path, script_name);\n  CHECK_NON_NULL (fn);\n\n  interpreted_result = toyvm_function_interpret (fn, input, NULL);\n  CHECK_VALUE (interpreted_result, expected_result);\n\n  compiled_fn = toyvm_function_compile (fn);\n  CHECK_NON_NULL (compiled_fn);\n\n  code = (toyvm_compiled_code)compiled_fn->cf_code;\n  CHECK_NON_NULL (code);\n\n  compiled_result = code (input);\n  CHECK_VALUE (compiled_result, expected_result);\n\n  gcc_jit_result_release (compiled_fn->cf_jit_result);\n  free (compiled_fn);\n  free (fn);\n  free (script_path);\n@}\n\n#define PATH_TO_SCRIPTS  (\"/jit/docs/examples/tut04-toyvm/\")\n\nstatic void\ntest_suite (void)\n@{\n  const char *srcdir;\n  char *scripts_dir;\n\n  snprintf (test, sizeof (test), \"toyvm.c\");\n\n  /* We need to locate the test scripts.\n     Rely on \"srcdir\" being set in the environment.  */\n\n  srcdir = getenv (\"srcdir\");\n  CHECK_NON_NULL (srcdir);\n\n  scripts_dir = (char *)malloc (strlen (srcdir) + strlen(PATH_TO_SCRIPTS)\n\t\t\t\t+ 1);\n  CHECK_NON_NULL (scripts_dir);\n  sprintf (scripts_dir, \"%s%s\", srcdir, PATH_TO_SCRIPTS);\n\n  test_script (scripts_dir, \"factorial.toy\", 10, 3628800);\n  test_script (scripts_dir, \"fibonacci.toy\", 10, 55);\n\n  free (scripts_dir);\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  const char *filename = NULL;\n  toyvm_function *fn = NULL;\n\n  /* If called with no args, assume we're being run by the test suite.  */\n  if (argc < 3)\n    @{\n      test_suite ();\n      return 0;\n    @}\n\n  if (argc != 3)\n    @{\n      fprintf (stdout,\n\t\"%s FILENAME INPUT: Parse and run a .toy file\\n\",\n\targv[0]);\n      exit (1);\n    @}\n\n  filename = argv[1];\n  fn = toyvm_function_parse (filename, filename);\n  if (!fn)\n    exit (1);\n\n  if (0)\n    toyvm_function_disassemble (fn, stdout);\n\n  printf (\"interpreter result: %d\\n\",\n\t  toyvm_function_interpret (fn, atoi (argv[2]), NULL));\n\n  /* JIT-compilation.  */\n  toyvm_compiled_function *compiled_fn\n    = toyvm_function_compile (fn);\n\n  toyvm_compiled_code code = compiled_fn->cf_code;\n  printf (\"compiler result: %d\\n\",\n\t  code (atoi (argv[2])));\n\n  gcc_jit_result_release (compiled_fn->cf_jit_result);\n  free (compiled_fn);\n\n return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now run the result:\n\n@quotation\n\n@example\n  toyvm_compiled_function *compiled_fn\n    = toyvm_function_compile (fn);\n\n  toyvm_compiled_code code = compiled_fn->cf_code;\n  printf (\"compiler result: %d\\n\",\n\t  code (atoi (argv[2])));\n\n  gcc_jit_result_release (compiled_fn->cf_jit_result);\n  free (compiled_fn);\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Single-stepping through the generated code,Examining the generated code,Compiling the context,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 single-stepping-through-the-generated-code}@anchor{40}\n@subsection Single-stepping through the generated code\n\n\nIt's possible to debug the generated code.  To do this we need to both:\n\n@quotation\n\n\n@itemize *\n\n@item \nSet up source code locations for our statements, so that we can\nmeaningfully step through the code.  We did this above by\ncalling @pxref{41,,gcc_jit_context_new_location()} and using the\nresults.\n\n@item \nEnable the generation of debugging information, by setting\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n@pxref{8,,gcc_jit_context} via\n@pxref{1b,,gcc_jit_context_set_bool_option()}:\n\n@example\ngcc_jit_context_set_bool_option (\n  ctxt,\n  GCC_JIT_BOOL_OPTION_DEBUGINFO,\n  1);\n@end example\n\n@noindent\n@end itemize\n@end quotation\n\nHaving done this, we can put a breakpoint on the generated function:\n\n@example\n$ gdb --args ./toyvm factorial.toy 10\n(gdb) break factorial\nFunction \"factorial\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 1 (factorial) pending.\n(gdb) run\nBreakpoint 1, factorial (arg=10) at factorial.toy:14\n14    DUP\n@end example\n\n@noindent\n\nWe've set up location information, which references @code{factorial.toy}.\nThis allows us to use e.g. @code{list} to see where we are in the script:\n\n@example\n(gdb) list\n9\n10    # Initial state:\n11    # stack: [arg]\n12\n13    # 0:\n14    DUP\n15    # stack: [arg, arg]\n16\n17    # 1:\n18    PUSH_CONST 2\n@end example\n\n@noindent\n\nand to step through the function, examining the data:\n\n@example\n(gdb) n\n18    PUSH_CONST 2\n(gdb) n\n22    BINARY_COMPARE_LT\n(gdb) print stack\n$5 = @{10, 10, 2, 0, -7152, 32767, 0, 0@}\n(gdb) print stack_depth\n$6 = 3\n@end example\n\n@noindent\n\nYou'll see that the parts of the @code{stack} array that haven't been\ntouched yet are uninitialized.\n\n@cartouche\n@quotation Note \nTurning on optimizations may lead to unpredictable results when\nstepping through the generated code: the execution may appear to\n\"jump around\" the source code.  This is analogous to turning up the\noptimization level in a regular compiler.\n@end quotation\n@end cartouche\n\n@node Examining the generated code,Putting it all together,Single-stepping through the generated code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 examining-the-generated-code}@anchor{43}\n@subsection Examining the generated code\n\n\nHow good is the optimized code?\n\nWe can turn up optimizations, by calling\n@pxref{1e,,gcc_jit_context_set_int_option()} with\n@pxref{1f,,GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL}:\n\n@example\ngcc_jit_context_set_int_option (\n  ctxt,\n  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n  3);\n@end example\n\n@noindent\n\nOne of GCC's internal representations is called \"gimple\".  A dump of the\ninitial gimple representation of the code can be seen by setting:\n\n@example\ngcc_jit_context_set_bool_option (ctxt,\n                                 GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n                                 1);\n@end example\n\n@noindent\n\nWith optimization on and source locations displayed, this gives:\n\n@c We'll use \"c\" for gimple dumps\n\n@example\nfactorial (signed int arg)\n@{\n  <unnamed type> D.80;\n  signed int D.81;\n  signed int D.82;\n  signed int D.83;\n  signed int D.84;\n  signed int D.85;\n  signed int y;\n  signed int x;\n  signed int stack_depth;\n  signed int stack[8];\n\n  try\n    @{\n      initial:\n      stack_depth = 0;\n      stack[stack_depth] = arg;\n      stack_depth = stack_depth + 1;\n      goto instr0;\n      instr0:\n      /* DUP */:\n      stack_depth = stack_depth + -1;\n      x = stack[stack_depth];\n      stack[stack_depth] = x;\n      stack_depth = stack_depth + 1;\n      stack[stack_depth] = x;\n      stack_depth = stack_depth + 1;\n      goto instr1;\n      instr1:\n      /* PUSH_CONST */:\n      stack[stack_depth] = 2;\n      stack_depth = stack_depth + 1;\n      goto instr2;\n\n      /* etc */\n@end example\n\n@noindent\n\nYou can see the generated machine code in assembly form via:\n\n@example\ngcc_jit_context_set_bool_option (\n  ctxt,\n  GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n  1);\nresult = gcc_jit_context_compile (ctxt);\n@end example\n\n@noindent\n\nwhich shows that (on this x86_64 box) the compiler has unrolled the loop\nand is using MMX instructions to perform several multiplications\nsimultaneously:\n\n@example\n        .file   \"fake.c\"\n        .text\n.Ltext0:\n        .p2align 4,,15\n        .globl  factorial\n        .type   factorial, @@function\nfactorial:\n.LFB0:\n        .file 1 \"factorial.toy\"\n        .loc 1 14 0\n        .cfi_startproc\n.LVL0:\n.L2:\n        .loc 1 26 0\n        cmpl    $1, %edi\n        jle     .L13\n        leal    -1(%rdi), %edx\n        movl    %edx, %ecx\n        shrl    $2, %ecx\n        leal    0(,%rcx,4), %esi\n        testl   %esi, %esi\n        je      .L14\n        cmpl    $9, %edx\n        jbe     .L14\n        leal    -2(%rdi), %eax\n        movl    %eax, -16(%rsp)\n        leal    -3(%rdi), %eax\n        movd    -16(%rsp), %xmm0\n        movl    %edi, -16(%rsp)\n        movl    %eax, -12(%rsp)\n        movd    -16(%rsp), %xmm1\n        xorl    %eax, %eax\n        movl    %edx, -16(%rsp)\n        movd    -12(%rsp), %xmm4\n        movd    -16(%rsp), %xmm6\n        punpckldq       %xmm4, %xmm0\n        movdqa  .LC1(%rip), %xmm4\n        punpckldq       %xmm6, %xmm1\n        punpcklqdq      %xmm0, %xmm1\n        movdqa  .LC0(%rip), %xmm0\n        jmp     .L5\n        # etc - edited for brevity\n@end example\n\n@noindent\n\nThis is clearly overkill for a function that will likely overflow the\n@code{int} type before the vectorization is worthwhile - but then again, this\nis a toy example.\n\nTurning down the optimization level to 2:\n\n@example\ngcc_jit_context_set_int_option (\n  ctxt,\n  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n  3);\n@end example\n\n@noindent\n\nyields this code, which is simple enough to quote in its entirety:\n\n@example\n        .file   \"fake.c\"\n        .text\n        .p2align 4,,15\n        .globl  factorial\n        .type   factorial, @@function\nfactorial:\n.LFB0:\n        .cfi_startproc\n.L2:\n        cmpl    $1, %edi\n        jle     .L8\n        movl    $1, %edx\n        jmp     .L4\n        .p2align 4,,10\n        .p2align 3\n.L6:\n        movl    %eax, %edi\n.L4:\n.L5:\n        leal    -1(%rdi), %eax\n        imull   %edi, %edx\n        cmpl    $1, %eax\n        jne     .L6\n.L3:\n.L7:\n        imull   %edx, %eax\n        ret\n.L8:\n        movl    %edi, %eax\n        movl    $1, %edx\n        jmp     .L7\n        .cfi_endproc\n.LFE0:\n        .size   factorial, .-factorial\n        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-%@{gcc_release@})\"\n        .section        .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nNote that the stack pushing and popping have been eliminated, as has the\nrecursive call (in favor of an iteration).\n\n@node Putting it all together,Behind the curtain How does our code get optimized?,Examining the generated code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 putting-it-all-together}@anchor{44}\n@subsection Putting it all together\n\n\nThe complete example can be seen in the source tree at\n@code{gcc/jit/docs/examples/tut04-toyvm/toyvm.c}\n\nalong with a Makefile and a couple of sample .toy scripts:\n\n@example\n$ ls -al\ndrwxrwxr-x. 2 david david   4096 Sep 19 17:46 .\ndrwxrwxr-x. 3 david david   4096 Sep 19 15:26 ..\n-rw-rw-r--. 1 david david    615 Sep 19 12:43 factorial.toy\n-rw-rw-r--. 1 david david    834 Sep 19 13:08 fibonacci.toy\n-rw-rw-r--. 1 david david    238 Sep 19 14:22 Makefile\n-rw-rw-r--. 1 david david  16457 Sep 19 17:07 toyvm.c\n\n$ make toyvm\ng++ -Wall -g -o toyvm toyvm.c -lgccjit\n\n$ ./toyvm factorial.toy 10\ninterpreter result: 3628800\ncompiler result: 3628800\n\n$ ./toyvm fibonacci.toy 10\ninterpreter result: 55\ncompiler result: 55\n@end example\n\n@noindent\n\n@node Behind the curtain How does our code get optimized?,,Putting it all together,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n@anchor{intro/tutorial04 behind-the-curtain-how-does-our-code-get-optimized}@anchor{45}\n@subsection Behind the curtain: How does our code get optimized?\n\n\nOur example is done, but you may be wondering about exactly how the\ncompiler turned what we gave it into the machine code seen above.\n\nWe can examine what the compiler is doing in detail by setting:\n\n@example\ngcc_jit_context_set_bool_option (state.ctxt,\n                                 GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n                                 1);\ngcc_jit_context_set_bool_option (state.ctxt,\n                                 GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n                                 1);\n@end example\n\n@noindent\n\nThis will dump detailed information about the compiler's state to a\ndirectory under @code{/tmp}, and keep it from being cleaned up.\n\nThe precise names and their formats of these files is subject to change.\nHigher optimization levels lead to more files.\nHere's what I saw (edited for brevity; there were almost 200 files):\n\n@example\nintermediate files written to /tmp/libgccjit-KPQbGw\n$ ls /tmp/libgccjit-KPQbGw/\nfake.c.000i.cgraph\nfake.c.000i.type-inheritance\nfake.c.004t.gimple\nfake.c.007t.omplower\nfake.c.008t.lower\nfake.c.011t.eh\nfake.c.012t.cfg\nfake.c.014i.visibility\nfake.c.015i.early_local_cleanups\nfake.c.016t.ssa\n# etc\n@end example\n\n@noindent\n\nThe gimple code is converted into Static Single Assignment form,\nwith annotations for use when generating the debuginfo:\n\n@example\n$ less /tmp/libgccjit-KPQbGw/fake.c.016t.ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n  signed int _56;\n\ninitial:\n  stack_depth_3 = 0;\n  # DEBUG stack_depth => stack_depth_3\n  stack[stack_depth_3] = arg_5(D);\n  stack_depth_7 = stack_depth_3 + 1;\n  # DEBUG stack_depth => stack_depth_7\n  # DEBUG instr0 => NULL\n  # DEBUG /* DUP */ => NULL\n  stack_depth_8 = stack_depth_7 + -1;\n  # DEBUG stack_depth => stack_depth_8\n  x_9 = stack[stack_depth_8];\n  # DEBUG x => x_9\n  stack[stack_depth_8] = x_9;\n  stack_depth_11 = stack_depth_8 + 1;\n  # DEBUG stack_depth => stack_depth_11\n  stack[stack_depth_11] = x_9;\n  stack_depth_13 = stack_depth_11 + 1;\n  # DEBUG stack_depth => stack_depth_13\n  # DEBUG instr1 => NULL\n  # DEBUG /* PUSH_CONST */ => NULL\n  stack[stack_depth_13] = 2;\n\n  /* etc; edited for brevity */\n@end example\n\n@noindent\n\nWe can perhaps better see the code by turning off\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to suppress all those @code{DEBUG}\nstatements, giving:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.016t.ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n  signed int _56;\n\ninitial:\n  stack_depth_3 = 0;\n  stack[stack_depth_3] = arg_5(D);\n  stack_depth_7 = stack_depth_3 + 1;\n  stack_depth_8 = stack_depth_7 + -1;\n  x_9 = stack[stack_depth_8];\n  stack[stack_depth_8] = x_9;\n  stack_depth_11 = stack_depth_8 + 1;\n  stack[stack_depth_11] = x_9;\n  stack_depth_13 = stack_depth_11 + 1;\n  stack[stack_depth_13] = 2;\n  stack_depth_15 = stack_depth_13 + 1;\n  stack_depth_16 = stack_depth_15 + -1;\n  y_17 = stack[stack_depth_16];\n  stack_depth_18 = stack_depth_16 + -1;\n  x_19 = stack[stack_depth_18];\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack[stack_depth_18] = _21;\n  stack_depth_23 = stack_depth_18 + 1;\n  stack_depth_24 = stack_depth_23 + -1;\n  x_25 = stack[stack_depth_24];\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  stack_depth_26 = stack_depth_24 + -1;\n  x_27 = stack[stack_depth_26];\n  stack[stack_depth_26] = x_27;\n  stack_depth_29 = stack_depth_26 + 1;\n  stack[stack_depth_29] = x_27;\n  stack_depth_31 = stack_depth_29 + 1;\n  stack[stack_depth_31] = 1;\n  stack_depth_33 = stack_depth_31 + 1;\n  stack_depth_34 = stack_depth_33 + -1;\n  y_35 = stack[stack_depth_34];\n  stack_depth_36 = stack_depth_34 + -1;\n  x_37 = stack[stack_depth_36];\n  _38 = x_37 - y_35;\n  stack[stack_depth_36] = _38;\n  stack_depth_40 = stack_depth_36 + 1;\n  stack_depth_41 = stack_depth_40 + -1;\n  x_42 = stack[stack_depth_41];\n  _44 = factorial (x_42);\n  stack[stack_depth_41] = _44;\n  stack_depth_46 = stack_depth_41 + 1;\n  stack_depth_47 = stack_depth_46 + -1;\n  y_48 = stack[stack_depth_47];\n  stack_depth_49 = stack_depth_47 + -1;\n  x_50 = stack[stack_depth_49];\n  _51 = x_50 * y_48;\n  stack[stack_depth_49] = _51;\n  stack_depth_53 = stack_depth_49 + 1;\n\n  # stack_depth_1 = PHI <stack_depth_24(2), stack_depth_53(3)>\ninstr9:\n/* RETURN */:\n  stack_depth_54 = stack_depth_1 + -1;\n  x_55 = stack[stack_depth_54];\n  _56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return _56;\n\n@}\n@end example\n\n@noindent\n\nNote in the above how all the @pxref{28,,gcc_jit_block} instances we\ncreated have been consolidated into just 3 blocks in GCC's internal\nrepresentation: @code{initial}, @code{instr4} and @code{instr9}.\n\n@menu\n* Optimizing away stack manipulation:: \n* Elimination of tail recursion:: \n\n@end menu\n\n@node Optimizing away stack manipulation,Elimination of tail recursion,,Behind the curtain How does our code get optimized?\n@anchor{intro/tutorial04 optimizing-away-stack-manipulation}@anchor{46}\n@subsubsection Optimizing away stack manipulation\n\n\nRecall our simple implementation of stack operations.  Let's examine\nhow the stack operations are optimized away.\n\nAfter a pass of constant-propagation, the depth of the stack at each\nopcode can be determined at compile-time:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.021t.ccp1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack[0] = arg_5(D);\n  x_9 = stack[0];\n  stack[0] = x_9;\n  stack[1] = x_9;\n  stack[2] = 2;\n  y_17 = stack[2];\n  x_19 = stack[1];\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack[1] = _21;\n  x_25 = stack[1];\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  x_27 = stack[0];\n  stack[0] = x_27;\n  stack[1] = x_27;\n  stack[2] = 1;\n  y_35 = stack[2];\n  x_37 = stack[1];\n  _38 = x_37 - y_35;\n  stack[1] = _38;\n  x_42 = stack[1];\n  _44 = factorial (x_42);\n  stack[1] = _44;\n  y_48 = stack[1];\n  x_50 = stack[0];\n  _51 = x_50 * y_48;\n  stack[0] = _51;\n\ninstr9:\n/* RETURN */:\n  x_55 = stack[0];\n  x_56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return x_56;\n\n@}\n@end example\n\n@noindent\n\nNote how, in the above, all those @code{stack_depth} values are now just\nconstants: we're accessing specific stack locations at each opcode.\n\nThe \"esra\" pass (\"Early Scalar Replacement of Aggregates\") breaks\nout our \"stack\" array into individual elements:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.024t.esra\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nCreated a replacement for stack offset: 0, size: 32: stack$0\nCreated a replacement for stack offset: 32, size: 32: stack$1\nCreated a replacement for stack offset: 64, size: 32: stack$2\n\nSymbols to be put in SSA form\n@{ D.89 D.90 D.91 @}\nIncremental SSA update started at block: 0\nNumber of blocks in CFG: 5\nNumber of blocks to update: 4 ( 80%)\n\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack$0_45 = arg_5(D);\n  x_9 = stack$0_45;\n  stack$0_39 = x_9;\n  stack$1_32 = x_9;\n  stack$2_30 = 2;\n  y_17 = stack$2_30;\n  x_19 = stack$1_32;\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack$1_28 = _21;\n  x_25 = stack$1_28;\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  x_27 = stack$0_39;\n  stack$0_22 = x_27;\n  stack$1_14 = x_27;\n  stack$2_12 = 1;\n  y_35 = stack$2_12;\n  x_37 = stack$1_14;\n  _38 = x_37 - y_35;\n  stack$1_10 = _38;\n  x_42 = stack$1_10;\n  _44 = factorial (x_42);\n  stack$1_6 = _44;\n  y_48 = stack$1_6;\n  x_50 = stack$0_22;\n  _51 = x_50 * y_48;\n  stack$0_1 = _51;\n\n  # stack$0_52 = PHI <stack$0_39(2), stack$0_1(3)>\ninstr9:\n/* RETURN */:\n  x_55 = stack$0_52;\n  x_56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return x_56;\n\n@}\n@end example\n\n@noindent\n\nHence at this point, all those pushes and pops of the stack are now\nsimply assignments to specific temporary variables.\n\nAfter some copy propagation, the stack manipulation has been completely\noptimized away:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.026t.copyprop1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack$0_39 = arg_5(D);\n  _20 = arg_5(D) <= 1;\n  _21 = (signed int) _20;\n  if (_21 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _38 = arg_5(D) + -1;\n  _44 = factorial (_38);\n  _51 = arg_5(D) * _44;\n  stack$0_1 = _51;\n\n  # stack$0_52 = PHI <arg_5(D)(2), _51(3)>\ninstr9:\n/* RETURN */:\n  stack =@{v@} @{CLOBBER@};\n  return stack$0_52;\n\n@}\n@end example\n\n@noindent\n\nLater on, another pass finally eliminated @code{stack_depth} local and the\nunused parts of the @cite{stack`} array altogether:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.036t.release_ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nReleased 44 names, 314.29%, removed 44 holes\nfactorial (signed int arg)\n@{\n  signed int stack$0;\n  signed int mult_acc_1;\n  <unnamed type> _5;\n  signed int _6;\n  signed int _7;\n  signed int mul_tmp_10;\n  signed int mult_acc_11;\n  signed int mult_acc_13;\n\n  # arg_9 = PHI <arg_8(D)(0)>\n  # mult_acc_13 = PHI <1(0)>\ninitial:\n\n  <bb 5>:\n  # arg_4 = PHI <arg_9(2), _7(3)>\n  # mult_acc_1 = PHI <mult_acc_13(2), mult_acc_11(3)>\n  _5 = arg_4 <= 1;\n  _6 = (signed int) _5;\n  if (_6 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _7 = arg_4 + -1;\n  mult_acc_11 = mult_acc_1 * arg_4;\n  goto <bb 5>;\n\n  # stack$0_12 = PHI <arg_4(5)>\ninstr9:\n/* RETURN */:\n  mul_tmp_10 = mult_acc_1 * stack$0_12;\n  return mul_tmp_10;\n\n@}\n@end example\n\n@noindent\n\n@node Elimination of tail recursion,,Optimizing away stack manipulation,Behind the curtain How does our code get optimized?\n@anchor{intro/tutorial04 elimination-of-tail-recursion}@anchor{47}\n@subsubsection Elimination of tail recursion\n\n\nAnother significant optimization is the detection that the call to\n@code{factorial} is tail recursion, which can be eliminated in favor of\nan iteration:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.030t.tailr1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\n\nSymbols to be put in SSA form\n@{ D.88 @}\nIncremental SSA update started at block: 0\nNumber of blocks in CFG: 5\nNumber of blocks to update: 4 ( 80%)\n\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  signed int mult_acc_1;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int mul_tmp_44;\n  signed int mult_acc_51;\n\n  # arg_5 = PHI <arg_39(D)(0), _38(3)>\n  # mult_acc_1 = PHI <1(0), mult_acc_51(3)>\ninitial:\n  _20 = arg_5 <= 1;\n  _21 = (signed int) _20;\n  if (_21 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _38 = arg_5 + -1;\n  mult_acc_51 = mult_acc_1 * arg_5;\n  goto <bb 2> (initial);\n\n  # stack$0_52 = PHI <arg_5(2)>\ninstr9:\n/* RETURN */:\n  stack =@{v@} @{CLOBBER@};\n  mul_tmp_44 = mult_acc_1 * stack$0_52;\n  return mul_tmp_44;\n\n@}\n@end example\n\n@noindent\n\n@c Copyright (C) 2015-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 5 Implementing an Ahead-of-Time compiler,,Tutorial part 4 Adding JIT-compilation to a toy interpreter,Tutorial\n@anchor{intro/tutorial05 doc}@anchor{48}@anchor{intro/tutorial05 tutorial-part-5-implementing-an-ahead-of-time-compiler}@anchor{49}\n@section Tutorial part 5: Implementing an Ahead-of-Time compiler\n\n\nIf you have a pre-existing language frontend that's compatible with\nlibgccjit's license, it's possible to hook it up to libgccjit as a\nbackend.  In the previous example we showed\nhow to do that for in-memory JIT-compilation, but libgccjit can also\ncompile code directly to a file, allowing you to implement a more\ntraditional ahead-of-time compiler (\"JIT\" is something of a misnomer\nfor this use-case).\n\nThe essential difference is to compile the context using\n@pxref{4a,,gcc_jit_context_compile_to_file()} rather than\n@pxref{15,,gcc_jit_context_compile()}.\n\n@menu\n* The \"brainf\" language:: \n* Converting a brainf script to libgccjit IR:: \n* Compiling a context to a file:: \n* Other forms of ahead-of-time-compilation:: \n\n@end menu\n\n@node The \"brainf\" language,Converting a brainf script to libgccjit IR,,Tutorial part 5 Implementing an Ahead-of-Time compiler\n@anchor{intro/tutorial05 the-brainf-language}@anchor{4b}\n@subsection The \"brainf\" language\n\n\nIn this example we use libgccjit to construct an ahead-of-time compiler\nfor an esoteric programming language that we shall refer to as \"brainf\".\n\nbrainf scripts operate on an array of bytes, with a notional data pointer\nwithin the array.\n\nbrainf is hard for humans to read, but it's trivial to write a parser for\nit, as there is no lexing; just a stream of bytes.  The operations are:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} \n@headitem\n\nCharacter\n\n@tab\n\nMeaning\n\n@item\n\n@code{>}\n\n@tab\n\n@code{idx += 1}\n\n@item\n\n@code{<}\n\n@tab\n\n@code{idx -= 1}\n\n@item\n\n@code{+}\n\n@tab\n\n@code{data[idx] += 1}\n\n@item\n\n@code{-}\n\n@tab\n\n@code{data[idx] -= 1}\n\n@item\n\n@code{.}\n\n@tab\n\n@code{output (data[idx])}\n\n@item\n\n@code{,}\n\n@tab\n\n@code{data[idx] = input ()}\n\n@item\n\n@code{[}\n\n@tab\n\nloop until @code{data[idx] == 0}\n\n@item\n\n@code{]}\n\n@tab\n\nend of loop\n\n@item\n\nAnything else\n\n@tab\n\nignored\n\n@end multitable\n\n\nUnlike the previous example, we'll implement an ahead-of-time compiler,\nwhich reads @code{.bf} scripts and outputs executables (though it would\nbe trivial to have it run them JIT-compiled in-process).\n\nHere's what a simple @code{.bf} script looks like:\n\n@quotation\n\n@example\n[\n  Emit the uppercase alphabet\n]\n\ncell 0 = 26\n++++++++++++++++++++++++++\n\ncell 1 = 65\n>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n\nwhile cell#0 != 0\n[\n >\n .      emit cell#1\n +      increment cell@@1\n <-     decrement cell@@0\n]\n\n@end example\n\n@noindent\n@end quotation\n\n@cartouche\n@quotation Note \nThis example makes use of whitespace and comments for legibility, but\ncould have been written as:\n\n@example\n++++++++++++++++++++++++++\n>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n[>.+<-]\n@end example\n\n@noindent\n\nIt's not a particularly useful language, except for providing\ncompiler-writers with a test case that's easy to parse.  The point\nis that you can use @pxref{4a,,gcc_jit_context_compile_to_file()}\nto use libgccjit as a backend for a pre-existing language frontend\n(provided that the pre-existing frontend is compatible with libgccjit's\nlicense).\n@end quotation\n@end cartouche\n\n@node Converting a brainf script to libgccjit IR,Compiling a context to a file,The \"brainf\" language,Tutorial part 5 Implementing an Ahead-of-Time compiler\n@anchor{intro/tutorial05 converting-a-brainf-script-to-libgccjit-ir}@anchor{4c}\n@subsection Converting a brainf script to libgccjit IR\n\n\nAs before we write simple code to populate a @pxref{8,,gcc_jit_context *}.\n\n@quotation\n\n@example\n\ntypedef struct bf_compiler\n@{\n  const char *filename;\n  int line;\n  int column;\n\n  gcc_jit_context *ctxt;\n\n  gcc_jit_type *void_type;\n  gcc_jit_type *int_type;\n  gcc_jit_type *byte_type;\n  gcc_jit_type *array_type;\n\n  gcc_jit_function *func_getchar;\n  gcc_jit_function *func_putchar;\n\n  gcc_jit_function *func;\n  gcc_jit_block *curblock;\n\n  gcc_jit_rvalue *int_zero;\n  gcc_jit_rvalue *int_one;\n  gcc_jit_rvalue *byte_zero;\n  gcc_jit_rvalue *byte_one;\n  gcc_jit_lvalue *data_cells;\n  gcc_jit_lvalue *idx;\n\n  int num_open_parens;\n  gcc_jit_block *paren_test[MAX_OPEN_PARENS];\n  gcc_jit_block *paren_body[MAX_OPEN_PARENS];\n  gcc_jit_block *paren_after[MAX_OPEN_PARENS];\n\n@} bf_compiler;\n\n/* Bail out, with a message on stderr.  */\n\nstatic void\nfatal_error (bf_compiler *bfc, const char *msg)\n@{\n  fprintf (stderr,\n\t   \"%s:%i:%i: %s\",\n\t   bfc->filename, bfc->line, bfc->column, msg);\n  abort ();\n@}\n\n/* Get \"data_cells[idx]\" as an lvalue.  */\n\nstatic gcc_jit_lvalue *\nbf_get_current_data (bf_compiler *bfc, gcc_jit_location *loc)\n@{\n  return gcc_jit_context_new_array_access (\n    bfc->ctxt,\n    loc,\n    gcc_jit_lvalue_as_rvalue (bfc->data_cells),\n    gcc_jit_lvalue_as_rvalue (bfc->idx));\n@}\n\n/* Get \"data_cells[idx] == 0\" as a boolean rvalue.  */\n\nstatic gcc_jit_rvalue *\nbf_current_data_is_zero (bf_compiler *bfc, gcc_jit_location *loc)\n@{\n  return gcc_jit_context_new_comparison (\n    bfc->ctxt,\n    loc,\n    GCC_JIT_COMPARISON_EQ,\n    gcc_jit_lvalue_as_rvalue (bf_get_current_data (bfc, loc)),\n    bfc->byte_zero);\n@}\n\n/* Compile one bf character.  */\n\nstatic void\nbf_compile_char (bf_compiler *bfc,\n\t\t unsigned char ch)\n@{\n  gcc_jit_location *loc =\n    gcc_jit_context_new_location (bfc->ctxt,\n\t\t\t\t  bfc->filename,\n\t\t\t\t  bfc->line,\n\t\t\t\t  bfc->column);\n\n  /* Turn this on to trace execution, by injecting putchar ()\n     of each source char. */\n  if (0)\n    @{\n      gcc_jit_rvalue *arg =\n\tgcc_jit_context_new_rvalue_from_int (\n\t\t\t\t\t     bfc->ctxt,\n\t\t\t\t\t     bfc->int_type,\n\t\t\t\t\t     ch);\n      gcc_jit_rvalue *call =\n\tgcc_jit_context_new_call (bfc->ctxt,\n\t\t\t\t  loc,\n\t\t\t\t  bfc->func_putchar,\n\t\t\t\t  1, &arg);\n      gcc_jit_block_add_eval (bfc->curblock,\n\t\t\t      loc,\n\t\t\t      call);\n    @}\n\n  switch (ch)\n    @{\n      case '>':\n\tgcc_jit_block_add_comment (bfc->curblock,\n\t\t\t\t   loc,\n\t\t\t\t   \"'>': idx += 1;\");\n\tgcc_jit_block_add_assignment_op (bfc->curblock,\n\t\t\t\t\t loc,\n\t\t\t\t\t bfc->idx,\n\t\t\t\t\t GCC_JIT_BINARY_OP_PLUS,\n\t\t\t\t\t bfc->int_one);\n\tbreak;\n\n      case '<':\n\tgcc_jit_block_add_comment (bfc->curblock,\n\t\t\t\t   loc,\n\t\t\t\t   \"'<': idx -= 1;\");\n\tgcc_jit_block_add_assignment_op (bfc->curblock,\n\t\t\t\t\t loc,\n\t\t\t\t\t bfc->idx,\n\t\t\t\t\t GCC_JIT_BINARY_OP_MINUS,\n\t\t\t\t\t bfc->int_one);\n\tbreak;\n\n      case '+':\n\tgcc_jit_block_add_comment (bfc->curblock,\n\t\t\t\t   loc,\n\t\t\t\t   \"'+': data[idx] += 1;\");\n\tgcc_jit_block_add_assignment_op (bfc->curblock,\n\t\t\t\t\t loc,\n\t\t\t\t\t bf_get_current_data (bfc, loc),\n\t\t\t\t\t GCC_JIT_BINARY_OP_PLUS,\n\t\t\t\t\t bfc->byte_one);\n\tbreak;\n\n      case '-':\n\tgcc_jit_block_add_comment (bfc->curblock,\n\t\t\t\t   loc,\n\t\t\t\t   \"'-': data[idx] -= 1;\");\n\tgcc_jit_block_add_assignment_op (bfc->curblock,\n\t\t\t\t\t loc,\n\t\t\t\t\t bf_get_current_data (bfc, loc),\n\t\t\t\t\t GCC_JIT_BINARY_OP_MINUS,\n\t\t\t\t\t bfc->byte_one);\n\tbreak;\n\n      case '.':\n\t@{\n\t  gcc_jit_rvalue *arg =\n\t    gcc_jit_context_new_cast (\n\t      bfc->ctxt,\n\t      loc,\n\t      gcc_jit_lvalue_as_rvalue (bf_get_current_data (bfc, loc)),\n\t      bfc->int_type);\n\t  gcc_jit_rvalue *call =\n\t    gcc_jit_context_new_call (bfc->ctxt,\n\t\t\t\t      loc,\n\t\t\t\t      bfc->func_putchar,\n\t\t\t\t      1, &arg);\n\t  gcc_jit_block_add_comment (bfc->curblock,\n\t\t\t\t     loc,\n\t\t\t\t     \"'.': putchar ((int)data[idx]);\");\n\t  gcc_jit_block_add_eval (bfc->curblock,\n\t\t\t\t  loc,\n\t\t\t\t  call);\n\t@}\n\tbreak;\n\n      case ',':\n\t@{\n\t  gcc_jit_rvalue *call =\n\t    gcc_jit_context_new_call (bfc->ctxt,\n\t\t\t\t      loc,\n\t\t\t\t      bfc->func_getchar,\n\t\t\t\t      0, NULL);\n\t  gcc_jit_block_add_comment (\n\t    bfc->curblock,\n\t    loc,\n\t    \"',': data[idx] = (unsigned char)getchar ();\");\n\t  gcc_jit_block_add_assignment (bfc->curblock,\n\t\t\t\t\tloc,\n\t\t\t\t\tbf_get_current_data (bfc, loc),\n\t\t\t\t\tgcc_jit_context_new_cast (\n\t\t\t\t\t  bfc->ctxt,\n\t\t\t\t\t  loc,\n\t\t\t\t\t  call,\n\t\t\t\t\t  bfc->byte_type));\n\t@}\n\tbreak;\n\n      case '[':\n\t@{\n\t  gcc_jit_block *loop_test =\n\t    gcc_jit_function_new_block (bfc->func, NULL);\n\t  gcc_jit_block *on_zero =\n\t    gcc_jit_function_new_block (bfc->func, NULL);\n\t  gcc_jit_block *on_non_zero =\n\t    gcc_jit_function_new_block (bfc->func, NULL);\n\n\t  if (bfc->num_open_parens == MAX_OPEN_PARENS)\n\t    fatal_error (bfc, \"too many open parens\");\n\n\t  gcc_jit_block_end_with_jump (\n\t    bfc->curblock,\n\t    loc,\n\t    loop_test);\n\n\t  gcc_jit_block_add_comment (\n\t    loop_test,\n\t    loc,\n\t    \"'['\");\n\t  gcc_jit_block_end_with_conditional (\n\t    loop_test,\n\t    loc,\n\t    bf_current_data_is_zero (bfc, loc),\n\t    on_zero,\n\t    on_non_zero);\n\t  bfc->paren_test[bfc->num_open_parens] = loop_test;\n\t  bfc->paren_body[bfc->num_open_parens] = on_non_zero;\n\t  bfc->paren_after[bfc->num_open_parens] = on_zero;\n\t  bfc->num_open_parens += 1;\n\t  bfc->curblock = on_non_zero;\n\t@}\n\tbreak;\n\n      case ']':\n\t@{\n\t  gcc_jit_block_add_comment (\n\t    bfc->curblock,\n\t    loc,\n\t    \"']'\");\n\n\t  if (bfc->num_open_parens == 0)\n\t    fatal_error (bfc, \"mismatching parens\");\n\t  bfc->num_open_parens -= 1;\n\t  gcc_jit_block_end_with_jump (\n\t    bfc->curblock,\n\t    loc,\n\t    bfc->paren_test[bfc->num_open_parens]);\n\t  bfc->curblock = bfc->paren_after[bfc->num_open_parens];\n\t@}\n\tbreak;\n\n    case '\\n':\n      bfc->line +=1;\n      bfc->column = 0;\n      break;\n    @}\n\n  if (ch != '\\n')\n    bfc->column += 1;\n@}\n\n/* Compile the given .bf file into a gcc_jit_context, containing a\n   single \"main\" function suitable for compiling into an executable.  */\n\ngcc_jit_context *\nbf_compile (const char *filename)\n@{\n  bf_compiler bfc;\n  FILE *f_in;\n  int ch;\n\n  memset (&bfc, 0, sizeof (bfc));\n\n  bfc.filename = filename;\n  f_in = fopen (filename, \"r\");\n  if (!f_in)\n    fatal_error (&bfc, \"unable to open file\");\n  bfc.line = 1;\n\n  bfc.ctxt = gcc_jit_context_acquire ();\n\n  gcc_jit_context_set_int_option (\n    bfc.ctxt,\n    GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n    3);\n  gcc_jit_context_set_bool_option (\n    bfc.ctxt,\n    GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n    0);\n  gcc_jit_context_set_bool_option (\n    bfc.ctxt,\n    GCC_JIT_BOOL_OPTION_DEBUGINFO,\n    1);\n  gcc_jit_context_set_bool_option (\n    bfc.ctxt,\n    GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n    0);\n  gcc_jit_context_set_bool_option (\n    bfc.ctxt,\n    GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n    0);\n\n  bfc.void_type =\n    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_VOID);\n  bfc.int_type =\n    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_INT);\n  bfc.byte_type =\n    gcc_jit_context_get_type (bfc.ctxt, GCC_JIT_TYPE_UNSIGNED_CHAR);\n  bfc.array_type =\n    gcc_jit_context_new_array_type (bfc.ctxt,\n\t\t\t\t    NULL,\n\t\t\t\t    bfc.byte_type,\n\t\t\t\t    30000);\n\n  bfc.func_getchar =\n    gcc_jit_context_new_function (bfc.ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n\t\t\t\t  bfc.int_type,\n\t\t\t\t  \"getchar\",\n\t\t\t\t  0, NULL,\n\t\t\t\t  0);\n\n  gcc_jit_param *param_c =\n    gcc_jit_context_new_param (bfc.ctxt, NULL, bfc.int_type, \"c\");\n  bfc.func_putchar =\n    gcc_jit_context_new_function (bfc.ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n\t\t\t\t  bfc.void_type,\n\t\t\t\t  \"putchar\",\n\t\t\t\t  1, &param_c,\n\t\t\t\t  0);\n\n  bfc.func = make_main (bfc.ctxt);\n   bfc.curblock =\n    gcc_jit_function_new_block (bfc.func, \"initial\");\n  bfc.int_zero = gcc_jit_context_zero (bfc.ctxt, bfc.int_type);\n  bfc.int_one = gcc_jit_context_one (bfc.ctxt, bfc.int_type);\n  bfc.byte_zero = gcc_jit_context_zero (bfc.ctxt, bfc.byte_type);\n  bfc.byte_one = gcc_jit_context_one (bfc.ctxt, bfc.byte_type);\n\n  bfc.data_cells =\n    gcc_jit_context_new_global (bfc.ctxt, NULL,\n\t\t\t\t GCC_JIT_GLOBAL_INTERNAL,\n\t\t\t\t bfc.array_type,\n\t\t\t\t \"data_cells\");\n  bfc.idx =\n    gcc_jit_function_new_local (bfc.func, NULL,\n\t\t\t\tbfc.int_type,\n\t\t\t\t\"idx\");\n\n  gcc_jit_block_add_comment (bfc.curblock,\n\t\t\t     NULL,\n\t\t\t     \"idx = 0;\");\n  gcc_jit_block_add_assignment (bfc.curblock,\n\t\t\t\tNULL,\n\t\t\t\tbfc.idx,\n\t\t\t\tbfc.int_zero);\n\n  bfc.num_open_parens = 0;\n\n  while ( EOF != (ch = fgetc (f_in)))\n    bf_compile_char (&bfc, (unsigned char)ch);\n\n  gcc_jit_block_end_with_return (bfc.curblock, NULL, bfc.int_zero);\n\n  fclose (f_in);\n\n  return bfc.ctxt;\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Compiling a context to a file,Other forms of ahead-of-time-compilation,Converting a brainf script to libgccjit IR,Tutorial part 5 Implementing an Ahead-of-Time compiler\n@anchor{intro/tutorial05 compiling-a-context-to-a-file}@anchor{4d}\n@subsection Compiling a context to a file\n\n\nUnlike the previous tutorial, this time we'll compile the context\ndirectly to an executable, using @pxref{4a,,gcc_jit_context_compile_to_file()}:\n\n@example\ngcc_jit_context_compile_to_file (ctxt,\n                                 GCC_JIT_OUTPUT_KIND_EXECUTABLE,\n                                 output_file);\n@end example\n\n@noindent\n\nHere's the top-level of the compiler, which is what actually calls into\n@pxref{4a,,gcc_jit_context_compile_to_file()}:\n\n@quotation\n\n@example\n\nint\nmain (int argc, char **argv)\n@{\n  const char *input_file;\n  const char *output_file;\n  gcc_jit_context *ctxt;\n  const char *err;\n\n  if (argc != 3)\n    @{\n      fprintf (stderr, \"%s: INPUT_FILE OUTPUT_FILE\\n\", argv[0]);\n      return 1;\n    @}\n\n  input_file = argv[1];\n  output_file = argv[2];\n  ctxt = bf_compile (input_file);\n\n  gcc_jit_context_compile_to_file (ctxt,\n\t\t\t\t   GCC_JIT_OUTPUT_KIND_EXECUTABLE,\n\t\t\t\t   output_file);\n\n  err = gcc_jit_context_get_first_error (ctxt);\n\n  if (err)\n    @{\n      gcc_jit_context_release (ctxt);\n      return 1;\n    @}\n\n  gcc_jit_context_release (ctxt);\n  return 0;\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\nNote how once the context is populated you could trivially instead compile\nit to memory using @pxref{15,,gcc_jit_context_compile()} and run it in-process\nas in the previous tutorial.\n\nTo create an executable, we need to export a @code{main} function.  Here's\nhow to create one from the JIT API:\n\n@quotation\n\n@example\n\n/* Make \"main\" function:\n     int\n     main (int argc, char **argv)\n     @{\n       ...\n     @}\n*/\nstatic gcc_jit_function *\nmake_main (gcc_jit_context *ctxt)\n@{\n  gcc_jit_type *int_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n  gcc_jit_param *param_argc =\n    gcc_jit_context_new_param (ctxt, NULL, int_type, \"argc\");\n  gcc_jit_type *char_ptr_ptr_type =\n    gcc_jit_type_get_pointer (\n      gcc_jit_type_get_pointer (\n\tgcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR)));\n  gcc_jit_param *param_argv =\n    gcc_jit_context_new_param (ctxt, NULL, char_ptr_ptr_type, \"argv\");\n  gcc_jit_param *params[2] = @{param_argc, param_argv@};\n  gcc_jit_function *func_main =\n    gcc_jit_context_new_function (ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n\t\t\t\t  int_type,\n\t\t\t\t  \"main\",\n\t\t\t\t  2, params,\n\t\t\t\t  0);\n  return func_main;\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\n@cartouche\n@quotation Note \nThe above implementation ignores @code{argc} and @code{argv}, but you could\nmake use of them by exposing @code{param_argc} and @code{param_argv} to the\ncaller.\n@end quotation\n@end cartouche\n\nUpon compiling this C code, we obtain a bf-to-machine-code compiler;\nlet's call it @code{bfc}:\n\n@example\n$ gcc \\\n    tut05-bf.c \\\n    -o bfc \\\n    -lgccjit\n@end example\n\n@noindent\n\nWe can now use @code{bfc} to compile .bf files into machine code executables:\n\n@example\n$ ./bfc \\\n     emit-alphabet.bf \\\n     a.out\n@end example\n\n@noindent\n\nwhich we can run directly:\n\n@example\n$ ./a.out\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n@end example\n\n@noindent\n\nSuccess!\n\nWe can also inspect the generated executable using standard tools:\n\n@example\n$ objdump -d a.out |less\n@end example\n\n@noindent\n\nwhich shows that libgccjit has managed to optimize the function\nsomewhat (for example, the runs of 26 and 65 increment operations\nhave become integer constants 0x1a and 0x41):\n\n@example\n0000000000400620 <main>:\n  400620:     80 3d 39 0a 20 00 00    cmpb   $0x0,0x200a39(%rip)        # 601060 <data\n  400627:     74 07                   je     400630 <main\n  400629:     eb fe                   jmp    400629 <main+0x9>\n  40062b:     0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\n  400630:     48 83 ec 08             sub    $0x8,%rsp\n  400634:     0f b6 05 26 0a 20 00    movzbl 0x200a26(%rip),%eax        # 601061 <data_cells+0x1>\n  40063b:     c6 05 1e 0a 20 00 1a    movb   $0x1a,0x200a1e(%rip)       # 601060 <data_cells>\n  400642:     8d 78 41                lea    0x41(%rax),%edi\n  400645:     40 88 3d 15 0a 20 00    mov    %dil,0x200a15(%rip)        # 601061 <data_cells+0x1>\n  40064c:     0f 1f 40 00             nopl   0x0(%rax)\n  400650:     40 0f b6 ff             movzbl %dil,%edi\n  400654:     e8 87 fe ff ff          callq  4004e0 <putchar@@plt>\n  400659:     0f b6 05 01 0a 20 00    movzbl 0x200a01(%rip),%eax        # 601061 <data_cells+0x1>\n  400660:     80 2d f9 09 20 00 01    subb   $0x1,0x2009f9(%rip)        # 601060 <data_cells>\n  400667:     8d 78 01                lea    0x1(%rax),%edi\n  40066a:     40 88 3d f0 09 20 00    mov    %dil,0x2009f0(%rip)        # 601061 <data_cells+0x1>\n  400671:     75 dd                   jne    400650 <main+0x30>\n  400673:     31 c0                   xor    %eax,%eax\n  400675:     48 83 c4 08             add    $0x8,%rsp\n  400679:     c3                      retq\n  40067a:     66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)\n@end example\n\n@noindent\n\nWe also set up debugging information (via\n@pxref{41,,gcc_jit_context_new_location()} and\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO}), so it's possible to use @code{gdb}\nto singlestep through the generated binary and inspect the internal\nstate @code{idx} and @code{data_cells}:\n\n@example\n(gdb) break main\nBreakpoint 1 at 0x400790\n(gdb) run\nStarting program: a.out\n\nBreakpoint 1, 0x0000000000400790 in main (argc=1, argv=0x7fffffffe448)\n(gdb) stepi\n0x0000000000400797 in main (argc=1, argv=0x7fffffffe448)\n(gdb) stepi\n0x00000000004007a0 in main (argc=1, argv=0x7fffffffe448)\n(gdb) stepi\n9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n(gdb) list\n4\n5     cell 0 = 26\n6     ++++++++++++++++++++++++++\n7\n8     cell 1 = 65\n9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n10\n11    while cell#0 != 0\n12    [\n13     >\n(gdb) n\n6     ++++++++++++++++++++++++++\n(gdb) n\n9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n(gdb) p idx\n$1 = 1\n(gdb) p data_cells\n$2 = \"\\032\", '\\000' <repeats 29998 times>\n(gdb) p data_cells[0]\n$3 = 26 '\\032'\n(gdb) p data_cells[1]\n$4 = 0 '\\000'\n(gdb) list\n4\n5     cell 0 = 26\n6     ++++++++++++++++++++++++++\n7\n8     cell 1 = 65\n9     >+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<\n10\n11    while cell#0 != 0\n12    [\n13     >\n@end example\n\n@noindent\n\n@node Other forms of ahead-of-time-compilation,,Compiling a context to a file,Tutorial part 5 Implementing an Ahead-of-Time compiler\n@anchor{intro/tutorial05 other-forms-of-ahead-of-time-compilation}@anchor{4e}\n@subsection Other forms of ahead-of-time-compilation\n\n\nThe above demonstrates compiling a @pxref{8,,gcc_jit_context *} directly\nto an executable.  It's also possible to compile it to an object file,\nand to a dynamic library.  See the documentation of\n@pxref{4a,,gcc_jit_context_compile_to_file()} for more information.\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Topic Reference,C++ bindings for libgccjit,Tutorial,Top\n@anchor{topics/index doc}@anchor{4f}@anchor{topics/index topic-reference}@anchor{50}\n@chapter Topic Reference\n\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Compilation contexts:: \n* Objects:: \n* Types:: \n* Expressions:: \n* Creating and using functions:: \n* Source Locations:: \n* Compiling a context:: \n* ABI and API compatibility:: \n* Performance:: \n\nCompilation contexts\n\n* Lifetime-management:: \n* Thread-safety:: \n* Error-handling: Error-handling<2>. \n* Debugging:: \n* Options: Options<2>. \n\nOptions\n\n* String Options:: \n* Boolean options:: \n* Integer options:: \n* Additional command-line options:: \n\nTypes\n\n* Standard types:: \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile. \n* Structures and unions:: \n\nExpressions\n\n* Rvalues:: \n* Lvalues:: \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions. \n\nRvalues\n\n* Simple expressions:: \n* Unary Operations:: \n* Binary Operations:: \n* Comparisons:: \n* Function calls:: \n* Type-coercion:: \n\nLvalues\n\n* Global variables:: \n\nCreating and using functions\n\n* Params:: \n* Functions:: \n* Blocks:: \n* Statements:: \n\nSource Locations\n\n* Faking it:: \n\nCompiling a context\n\n* In-memory compilation:: \n* Ahead-of-time compilation:: \n\nABI and API compatibility\n\n* ABI symbol tags:: \n\nABI symbol tags\n\n* LIBGCCJIT_ABI_0:: \n* LIBGCCJIT_ABI_1:: \n* LIBGCCJIT_ABI_2:: \n* LIBGCCJIT_ABI_3:: \n* LIBGCCJIT_ABI_4:: \n* LIBGCCJIT_ABI_5:: \n\nPerformance\n\n* The timing API:: \n\n@end menu\n\n\n@node Compilation contexts,Objects,,Topic Reference\n@anchor{topics/contexts compilation-contexts}@anchor{51}@anchor{topics/contexts doc}@anchor{52}\n@section Compilation contexts\n\n\n@geindex gcc_jit_context (C type)\n@anchor{topics/contexts gcc_jit_context}@anchor{8}\n@deffn {C Type} gcc_jit_context\n@end deffn\n\nThe top-level of the API is the @pxref{8,,gcc_jit_context} type.\n\nA @pxref{8,,gcc_jit_context} instance encapsulates the state of a\ncompilation.\n\nYou can set up options on it, and add types, functions and code.\nInvoking @pxref{15,,gcc_jit_context_compile()} on it gives you a\n@pxref{16,,gcc_jit_result}.\n\n@menu\n* Lifetime-management:: \n* Thread-safety:: \n* Error-handling: Error-handling<2>. \n* Debugging:: \n* Options: Options<2>. \n\n@end menu\n\n@node Lifetime-management,Thread-safety,,Compilation contexts\n@anchor{topics/contexts lifetime-management}@anchor{53}\n@subsection Lifetime-management\n\n\nContexts are the unit of lifetime-management within the API: objects\nhave their lifetime bounded by the context they are created within, and\ncleanup of such objects is done for you when the context is released.\n\n@geindex gcc_jit_context_acquire (C function)\n@anchor{topics/contexts gcc_jit_context_acquire}@anchor{9}\n@deffn {C Function} gcc_jit_context *gcc_jit_context_acquire (void)\n\nThis function acquires a new @pxref{8,,gcc_jit_context *} instance,\nwhich is independent of any others that may be present within this\nprocess.\n@end deffn\n\n@geindex gcc_jit_context_release (C function)\n@anchor{topics/contexts gcc_jit_context_release}@anchor{c}\n@deffn {C Function} void gcc_jit_context_release (gcc_jit_context@w{ }*ctxt)\n\nThis function releases all resources associated with the given context.\nBoth the context itself and all of its @pxref{e,,gcc_jit_object *}\ninstances are cleaned up.  It should be called exactly once on a given\ncontext.\n\nIt is invalid to use the context or any of its \"contextual\" objects\nafter calling this.\n\n@example\ngcc_jit_context_release (ctxt);\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_new_child_context (C function)\n@anchor{topics/contexts gcc_jit_context_new_child_context}@anchor{54}\n@deffn {C Function} gcc_jit_context * gcc_jit_context_new_child_context (gcc_jit_context@w{ }*parent_ctxt)\n\nGiven an existing JIT context, create a child context.\n\nThe child inherits a copy of all option-settings from the parent.\n\nThe child can reference objects created within the parent, but not\nvice-versa.\n\nThe lifetime of the child context must be bounded by that of the\nparent: you should release a child context before releasing the parent\ncontext.\n\nIf you use a function from a parent context within a child context,\nyou have to compile the parent context before you can compile the\nchild context, and the gcc_jit_result of the parent context must\noutlive the gcc_jit_result of the child context.\n\nThis allows caching of shared initializations.  For example, you could\ncreate types and declarations of global functions in a parent context\nonce within a process, and then create child contexts whenever a\nfunction or loop becomes hot. Each such child context can be used for\nJIT-compiling just one function or loop, but can reference types\nand helper functions created within the parent context.\n\nContexts can be arbitrarily nested, provided the above rules are\nfollowed, but it's probably not worth going above 2 or 3 levels, and\nthere will likely be a performance hit for such nesting.\n@end deffn\n\n@node Thread-safety,Error-handling<2>,Lifetime-management,Compilation contexts\n@anchor{topics/contexts thread-safety}@anchor{55}\n@subsection Thread-safety\n\n\nInstances of @pxref{8,,gcc_jit_context *} created via\n@pxref{9,,gcc_jit_context_acquire()} are independent from each other:\nonly one thread may use a given context at once, but multiple threads\ncould each have their own contexts without needing locks.\n\nContexts created via @pxref{54,,gcc_jit_context_new_child_context()} are\nrelated to their parent context.  They can be partitioned by their\nultimate ancestor into independent \"family trees\".   Only one thread\nwithin a process may use a given \"family tree\" of such contexts at once,\nand if you're using multiple threads you should provide your own locking\naround entire such context partitions.\n\n@node Error-handling<2>,Debugging,Thread-safety,Compilation contexts\n@anchor{topics/contexts error-handling}@anchor{19}@anchor{topics/contexts id1}@anchor{56}\n@subsection Error-handling\n\n\nVarious kinds of errors are possible when using the API, such as\nmismatched types in an assignment.  You can only compile and get code from\na context if no errors occur.\n\nErrors are printed on stderr and can be queried using\n@pxref{57,,gcc_jit_context_get_first_error()}.\n\nThey typically contain the name of the API entrypoint where the error\noccurred, and pertinent information on the problem:\n\n@example\n./buggy-program: error: gcc_jit_block_add_assignment: mismatching types: assignment to i (type: int) from \"hello world\" (type: const char *)\n@end example\n\n@noindent\n\nIn general, if an error occurs when using an API entrypoint, the\nentrypoint returns NULL.  You don't have to check everywhere for NULL\nresults, since the API handles a NULL being passed in for any\nargument by issuing another error.  This typically leads to a cascade of\nfollowup error messages, but is safe (albeit verbose).  The first error\nmessage is usually the one to pay attention to, since it is likely to\nbe responsible for all of the rest:\n\n@geindex gcc_jit_context_get_first_error (C function)\n@anchor{topics/contexts gcc_jit_context_get_first_error}@anchor{57}\n@deffn {C Function} const char *           gcc_jit_context_get_first_error (gcc_jit_context@w{ }*ctxt)\n\nReturns the first error message that occurred on the context.\n\nThe returned string is valid for the rest of the lifetime of the\ncontext.\n\nIf no errors occurred, this will be NULL.\n@end deffn\n\nIf you are wrapping the C API for a higher-level language that supports\nexception-handling, you may instead be interested in the last error that\noccurred on the context, so that you can embed this in an exception:\n\n@geindex gcc_jit_context_get_last_error (C function)\n@anchor{topics/contexts gcc_jit_context_get_last_error}@anchor{58}\n@deffn {C Function} const char *           gcc_jit_context_get_last_error (gcc_jit_context@w{ }*ctxt)\n\nReturns the last error message that occurred on the context.\n\nIf no errors occurred, this will be NULL.\n\nIf non-NULL, the returned string is only guaranteed to be valid until\nthe next call to libgccjit relating to this context.\n@end deffn\n\n@node Debugging,Options<2>,Error-handling<2>,Compilation contexts\n@anchor{topics/contexts debugging}@anchor{59}\n@subsection Debugging\n\n\n@geindex gcc_jit_context_dump_to_file (C function)\n@anchor{topics/contexts gcc_jit_context_dump_to_file}@anchor{5a}\n@deffn {C Function} void           gcc_jit_context_dump_to_file (gcc_jit_context@w{ }*ctxt, const char@w{ }*path, int@w{ }update_locations)\n\nTo help with debugging: dump a C-like representation to the given path,\ndescribing what's been set up on the context.\n\nIf \"update_locations\" is true, then also set up @pxref{3b,,gcc_jit_location}\ninformation throughout the context, pointing at the dump file as if it\nwere a source file.  This may be of use in conjunction with\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to allow stepping through the\ncode in a debugger.\n@end deffn\n\n@geindex gcc_jit_context_set_logfile (C function)\n@anchor{topics/contexts gcc_jit_context_set_logfile}@anchor{5b}\n@deffn {C Function} void           gcc_jit_context_set_logfile (gcc_jit_context@w{ }*ctxt, FILE@w{ }*logfile, int@w{ }flags, int@w{ }verbosity)\n\nTo help with debugging; enable ongoing logging of the context's\nactivity to the given file.\n\nFor example, the following will enable logging to stderr.\n\n@example\ngcc_jit_context_set_logfile (ctxt, stderr, 0, 0);\n@end example\n\n@noindent\n\nExamples of information logged include:\n\n\n@itemize *\n\n@item \nAPI calls\n\n@item \nthe various steps involved within compilation\n\n@item \nactivity on any @pxref{16,,gcc_jit_result} instances created by\nthe context\n\n@item \nactivity within any child contexts\n@end itemize\n\nAn example of a log can be seen @pxref{5c,,here},\nthough the precise format and kinds of information logged is subject\nto change.\n\nThe caller remains responsible for closing @cite{logfile}, and it must not\nbe closed until all users are released.  In particular, note that\nchild contexts and @pxref{16,,gcc_jit_result} instances created by\nthe context will use the logfile.\n\nThere may a performance cost for logging.\n\nYou can turn off logging on @cite{ctxt} by passing @cite{NULL} for @cite{logfile}.\nDoing so only affects the context; it does not affect child contexts\nor @pxref{16,,gcc_jit_result} instances already created by\nthe context.\n\nThe parameters \"flags\" and \"verbosity\" are reserved for future\nexpansion, and must be zero for now.\n@end deffn\n\nTo contrast the above: @pxref{5a,,gcc_jit_context_dump_to_file()} dumps the\ncurrent state of a context to the given path, whereas\n@pxref{5b,,gcc_jit_context_set_logfile()} enables on-going logging of\nfuture activies on a context to the given @cite{FILE *}.\n\n@geindex gcc_jit_context_dump_reproducer_to_file (C function)\n@anchor{topics/contexts gcc_jit_context_dump_reproducer_to_file}@anchor{5d}\n@deffn {C Function} void           gcc_jit_context_dump_reproducer_to_file (gcc_jit_context@w{ }*ctxt, const char@w{ }*path)\n\nWrite C source code into @cite{path} that can be compiled into a\nself-contained executable (i.e. with libgccjit as the only dependency).\nThe generated code will attempt to replay the API calls that have been\nmade into the given context.\n\nThis may be useful when debugging the library or client code, for\nreducing a complicated recipe for reproducing a bug into a simpler\nform.  For example, consider client code that parses some source file\ninto some internal representation, and then walks this IR, calling into\nlibgccjit.  If this encounters a bug, a call to\n@cite{gcc_jit_context_dump_reproducer_to_file} will write out C code for\na much simpler executable that performs the equivalent calls into\nlibgccjit, without needing the client code and its data.\n\nTypically you need to supply @code{-Wno-unused-variable} when\ncompiling the generated file (since the result of each API call is\nassigned to a unique variable within the generated C source, and not\nall are necessarily then used).\n@end deffn\n\n@geindex gcc_jit_context_enable_dump (C function)\n@anchor{topics/contexts gcc_jit_context_enable_dump}@anchor{5e}\n@deffn {C Function} void           gcc_jit_context_enable_dump (gcc_jit_context@w{ }*ctxt, const char@w{ }*dumpname, char@w{ }**out_ptr)\n\nEnable the dumping of a specific set of internal state from the\ncompilation, capturing the result in-memory as a buffer.\n\nParameter \"dumpname\" corresponds to the equivalent gcc command-line\noption, without the \"-fdump-\" prefix.\nFor example, to get the equivalent of @code{-fdump-tree-vrp1},\nsupply @code{\"tree-vrp1\"}:\n\n@example\nstatic char *dump_vrp1;\n\nvoid\ncreate_code (gcc_jit_context *ctxt)\n@{\n   gcc_jit_context_enable_dump (ctxt, \"tree-vrp1\", &dump_vrp1);\n   /* (other API calls omitted for brevity) */\n@}\n@end example\n\n@noindent\n\nThe context directly stores the dumpname as a @code{(const char *)}, so\nthe passed string must outlive the context.\n\n@pxref{15,,gcc_jit_context_compile()} will capture the dump as a\ndynamically-allocated buffer, writing it to @code{*out_ptr}.\n\nThe caller becomes responsible for calling:\n\n@example\nfree (*out_ptr)\n@end example\n\n@noindent\n\neach time that @pxref{15,,gcc_jit_context_compile()} is called.\n@code{*out_ptr} will be written to, either with the address of a buffer,\nor with @code{NULL} if an error occurred.\n\n@cartouche\n@quotation Warning \nThis API entrypoint is likely to be less stable than the others.\nIn particular, both the precise dumpnames, and the format and content\nof the dumps are subject to change.\n\nIt exists primarily for writing the library's own test suite.\n@end quotation\n@end cartouche\n@end deffn\n\n@node Options<2>,,Debugging,Compilation contexts\n@anchor{topics/contexts options}@anchor{5f}\n@subsection Options\n\n\nOptions present in the initial release of libgccjit were handled using\nenums, whereas those added subsequently have their own per-option API\nentrypoints.\n\nAdding entrypoints for each new option means that client code that use\nthe new options can be identified directly from binary metadata, which\nwould not be possible if we instead extended the various\n@code{enum gcc_jit_*_option}.\n\n@menu\n* String Options:: \n* Boolean options:: \n* Integer options:: \n* Additional command-line options:: \n\n@end menu\n\n@node String Options,Boolean options,,Options<2>\n@anchor{topics/contexts string-options}@anchor{60}\n@subsubsection String Options\n\n\n@geindex gcc_jit_context_set_str_option (C function)\n@anchor{topics/contexts gcc_jit_context_set_str_option}@anchor{61}\n@deffn {C Function} void gcc_jit_context_set_str_option (gcc_jit_context@w{ }*ctxt, enum gcc_jit_str_option@w{ }opt, const char@w{ }*value)\n\nSet a string option of the context.\n\n@geindex gcc_jit_str_option (C type)\n@anchor{topics/contexts gcc_jit_str_option}@anchor{62}\n@deffn {C Type} enum gcc_jit_str_option\n@end deffn\n\nThe parameter @code{value} can be NULL.   If non-NULL, the call takes a\ncopy of the underlying string, so it is valid to pass in a pointer to\nan on-stack buffer.\n\nThere is just one string option specified this way:\n\n@geindex GCC_JIT_STR_OPTION_PROGNAME (C macro)\n@anchor{topics/contexts GCC_JIT_STR_OPTION_PROGNAME}@anchor{63}\n@deffn {C Macro} GCC_JIT_STR_OPTION_PROGNAME\n\nThe name of the program, for use as a prefix when printing error\nmessages to stderr.  If @cite{NULL}, or default, \"libgccjit.so\" is used.\n@end deffn\n@end deffn\n\n@node Boolean options,Integer options,String Options,Options<2>\n@anchor{topics/contexts boolean-options}@anchor{64}\n@subsubsection Boolean options\n\n\n@geindex gcc_jit_context_set_bool_option (C function)\n@anchor{topics/contexts gcc_jit_context_set_bool_option}@anchor{1b}\n@deffn {C Function} void gcc_jit_context_set_bool_option (gcc_jit_context@w{ }*ctxt, enum gcc_jit_bool_option@w{ }opt, int@w{ }value)\n\nSet a boolean option of the context.\nZero is \"false\" (the default), non-zero is \"true\".\n\n@geindex gcc_jit_bool_option (C type)\n@anchor{topics/contexts gcc_jit_bool_option}@anchor{65}\n@deffn {C Type} enum gcc_jit_bool_option\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DEBUGINFO (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DEBUGINFO}@anchor{42}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DEBUGINFO\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will attempt to do the right\nthing so that if you attach a debugger to the process, it will\nbe able to inspect variables and step through your code.\n\nNote that you can't step through code unless you set up source\nlocation information for the code (by creating and passing in\n@pxref{3b,,gcc_jit_location} instances).\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}@anchor{66}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will dump its initial\n\"tree\" representation of your code to stderr (before any\noptimizations).\n\nHere's some sample output (from the @cite{square} example):\n\n@example\n<statement_list 0x7f4875a62cc0\n   type <void_type 0x7f4875a64bd0 VOID\n       align 8 symtab 0 alias set -1 canonical type 0x7f4875a64bd0\n       pointer_to_this <pointer_type 0x7f4875a64c78>>\n   side-effects head 0x7f4875a761e0 tail 0x7f4875a761f8 stmts 0x7f4875a62d20 0x7f4875a62d00\n\n   stmt <label_expr 0x7f4875a62d20 type <void_type 0x7f4875a64bd0>\n       side-effects\n       arg 0 <label_decl 0x7f4875a79080 entry type <void_type 0x7f4875a64bd0>\n           VOID file (null) line 0 col 0\n           align 1 context <function_decl 0x7f4875a77500 square>>>\n   stmt <return_expr 0x7f4875a62d00\n       type <integer_type 0x7f4875a645e8 public SI\n           size <integer_cst 0x7f4875a623a0 constant 32>\n           unit size <integer_cst 0x7f4875a623c0 constant 4>\n           align 32 symtab 0 alias set -1 canonical type 0x7f4875a645e8 precision 32 min <integer_cst 0x7f4875a62340 -2147483648> max <integer_cst 0x7f4875a62360 2147483647>\n           pointer_to_this <pointer_type 0x7f4875a6b348>>\n       side-effects\n       arg 0 <modify_expr 0x7f4875a72a78 type <integer_type 0x7f4875a645e8>\n           side-effects arg 0 <result_decl 0x7f4875a7a000 D.54>\n           arg 1 <mult_expr 0x7f4875a72a50 type <integer_type 0x7f4875a645e8>\n               arg 0 <parm_decl 0x7f4875a79000 i> arg 1 <parm_decl 0x7f4875a79000 i>>>>>\n@end example\n\n@noindent\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE}@anchor{1c}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will dump the \"gimple\"\nrepresentation of your code to stderr, before any optimizations\nare performed.  The dump resembles C code:\n\n@example\nsquare (signed int i)\n@{\n  signed int D.56;\n\n  entry:\n  D.56 = i * i;\n  return D.56;\n@}\n@end example\n\n@noindent\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE}@anchor{1d}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will dump the final\ngenerated code to stderr, in the form of assembly language:\n\n@example\n    .file    \"fake.c\"\n    .text\n    .globl    square\n    .type    square, @@function\nsquare:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    movl    %edi, -4(%rbp)\n.L2:\n    movl    -4(%rbp), %eax\n    imull    -4(%rbp), %eax\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    square, .-square\n    .ident    \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.1-%@{gcc_release@})\"\n    .section    .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DUMP_SUMMARY (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_SUMMARY}@anchor{67}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_SUMMARY\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will print information to stderr\non the actions it is performing.\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING}@anchor{68}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING\n\nIf true, @pxref{15,,gcc_jit_context_compile()} will dump copious\namount of information on what it's doing to various\nfiles within a temporary directory.  Use\n@pxref{69,,GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES} (see below) to\nsee the results.  The files are intended to be human-readable,\nbut the exact files and their formats are subject to change.\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_SELFCHECK_GC (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_SELFCHECK_GC}@anchor{6a}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_SELFCHECK_GC\n\nIf true, libgccjit will aggressively run its garbage collector, to\nshake out bugs (greatly slowing down the compile).  This is likely\nto only be of interest to developers @emph{of} the library.  It is\nused when running the selftest suite.\n@end deffn\n\n@geindex GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES (C macro)\n@anchor{topics/contexts GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES}@anchor{69}\n@deffn {C Macro} GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES\n\nIf true, the @pxref{8,,gcc_jit_context} will not clean up intermediate files\nwritten to the filesystem, and will display their location on stderr.\n@end deffn\n@end deffn\n\n@geindex gcc_jit_context_set_bool_allow_unreachable_blocks (C function)\n@anchor{topics/contexts gcc_jit_context_set_bool_allow_unreachable_blocks}@anchor{6b}\n@deffn {C Function} void            gcc_jit_context_set_bool_allow_unreachable_blocks (gcc_jit_context@w{ }*ctxt, int@w{ }bool_value)\n\nBy default, libgccjit will issue an error about unreachable blocks\nwithin a function.\n\nThis entrypoint can be used to disable that error.\n\nThis entrypoint was added in @pxref{6c,,LIBGCCJIT_ABI_2}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_set_bool_use_external_driver (C function)\n@anchor{topics/contexts gcc_jit_context_set_bool_use_external_driver}@anchor{6d}\n@deffn {C Function} void            gcc_jit_context_set_bool_use_external_driver (gcc_jit_context@w{ }*ctxt, int@w{ }bool_value)\n\nlibgccjit internally generates assembler, and uses \"driver\" code\nfor converting it to other formats (e.g. shared libraries).\n\nBy default, libgccjit will use an embedded copy of the driver\ncode.\n\nThis option can be used to instead invoke an external driver executable\nas a subprocess.\n\nThis entrypoint was added in @pxref{6e,,LIBGCCJIT_ABI_5}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n@end example\n\n@noindent\n@end deffn\n\n@node Integer options,Additional command-line options,Boolean options,Options<2>\n@anchor{topics/contexts integer-options}@anchor{6f}\n@subsubsection Integer options\n\n\n@geindex gcc_jit_context_set_int_option (C function)\n@anchor{topics/contexts gcc_jit_context_set_int_option}@anchor{1e}\n@deffn {C Function} void gcc_jit_context_set_int_option (gcc_jit_context@w{ }*ctxt, enum gcc_jit_int_option@w{ }opt, int@w{ }value)\n\nSet an integer option of the context.\n\n@geindex gcc_jit_int_option (C type)\n@anchor{topics/contexts gcc_jit_int_option}@anchor{70}\n@deffn {C Type} enum gcc_jit_int_option\n@end deffn\n\nThere is just one integer option specified this way:\n\n@geindex GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL (C macro)\n@anchor{topics/contexts GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL}@anchor{1f}\n@deffn {C Macro} GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL\n\nHow much to optimize the code.\n\nValid values are 0-3, corresponding to GCC's command-line options\n-O0 through -O3.\n\nThe default value is 0 (unoptimized).\n@end deffn\n@end deffn\n\n@node Additional command-line options,,Integer options,Options<2>\n@anchor{topics/contexts additional-command-line-options}@anchor{71}\n@subsubsection Additional command-line options\n\n\n@geindex gcc_jit_context_add_command_line_option (C function)\n@anchor{topics/contexts gcc_jit_context_add_command_line_option}@anchor{72}\n@deffn {C Function} void gcc_jit_context_add_command_line_option (gcc_jit_context@w{ }*ctxt, const char@w{ }*optname)\n\nAdd an arbitrary gcc command-line option to the context, for use\nby @pxref{15,,gcc_jit_context_compile()} and\n@pxref{4a,,gcc_jit_context_compile_to_file()}.\n\nThe parameter @code{optname} must be non-NULL.  The underlying buffer is\ncopied, so that it does not need to outlive the call.\n\nExtra options added by @cite{gcc_jit_context_add_command_line_option} are\napplied @emph{after} the regular options above, potentially overriding them.\nOptions from parent contexts are inherited by child contexts; options\nfrom the parent are applied @emph{before} those from the child.\n\nFor example:\n\n@example\ngcc_jit_context_add_command_line_option (ctxt, \"-ffast-math\");\ngcc_jit_context_add_command_line_option (ctxt, \"-fverbose-asm\");\n@end example\n\n@noindent\n\nNote that only some options are likely to be meaningful; there is no\n\"frontend\" within libgccjit, so typically only those affecting\noptimization and code-generation are likely to be useful.\n\nThis entrypoint was added in @pxref{73,,LIBGCCJIT_ABI_1}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_command_line_option\n@end example\n\n@noindent\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Objects,Types,Compilation contexts,Topic Reference\n@anchor{topics/objects objects}@anchor{74}@anchor{topics/objects doc}@anchor{75}\n@section Objects\n\n\n@geindex gcc_jit_object (C type)\n@anchor{topics/objects gcc_jit_object}@anchor{e}\n@deffn {C Type} gcc_jit_object\n@end deffn\n\nAlmost every entity in the API (with the exception of\n@pxref{8,,gcc_jit_context *} and @pxref{16,,gcc_jit_result *}) is a\n\"contextual\" object, a @pxref{e,,gcc_jit_object *}\n\nA JIT object:\n\n@quotation\n\n\n@itemize *\n\n@item \nis associated with a @pxref{8,,gcc_jit_context *}.\n\n@item \nis automatically cleaned up for you when its context is released so\nyou don't need to manually track and cleanup all objects, just the\ncontexts.\n@end itemize\n@end quotation\n\nAlthough the API is C-based, there is a form of class hierarchy, which\nlooks like this:\n\n@example\n+- gcc_jit_object\n    +- gcc_jit_location\n    +- gcc_jit_type\n       +- gcc_jit_struct\n    +- gcc_jit_field\n    +- gcc_jit_function\n    +- gcc_jit_block\n    +- gcc_jit_rvalue\n        +- gcc_jit_lvalue\n           +- gcc_jit_param\n    +- gcc_jit_case\n@end example\n\n@noindent\n\nThere are casting methods for upcasting from subclasses to parent classes.\nFor example, @pxref{d,,gcc_jit_type_as_object()}:\n\n@example\ngcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n@end example\n\n@noindent\n\nThe object \"base class\" has the following operations:\n\n@geindex gcc_jit_object_get_context (C function)\n@anchor{topics/objects gcc_jit_object_get_context}@anchor{76}\n@deffn {C Function} gcc_jit_context *gcc_jit_object_get_context (gcc_jit_object@w{ }*obj)\n\nWhich context is \"obj\" within?\n@end deffn\n\n@geindex gcc_jit_object_get_debug_string (C function)\n@anchor{topics/objects gcc_jit_object_get_debug_string}@anchor{f}\n@deffn {C Function} const char *gcc_jit_object_get_debug_string (gcc_jit_object@w{ }*obj)\n\nGenerate a human-readable description for the given object.\n\nFor example,\n\n@example\nprintf (\"obj: %s\\n\", gcc_jit_object_get_debug_string (obj));\n@end example\n\n@noindent\n\nmight give this text on stdout:\n\n@example\nobj: 4.0 * (float)i\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nIf you call this on an object, the @cite{const char *} buffer is allocated\nand generated on the first call for that object, and the buffer will\nhave the same lifetime as the object  i.e. it will exist until the\nobject's context is released.\n@end quotation\n@end cartouche\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Types,Expressions,Objects,Topic Reference\n@anchor{topics/types doc}@anchor{77}@anchor{topics/types types}@anchor{78}\n@section Types\n\n\n@geindex gcc_jit_type (C type)\n@anchor{topics/types gcc_jit_type}@anchor{a}\n@deffn {C Type} gcc_jit_type\n\ngcc_jit_type represents a type within the library.\n@end deffn\n\n@geindex gcc_jit_type_as_object (C function)\n@anchor{topics/types gcc_jit_type_as_object}@anchor{d}\n@deffn {C Function} gcc_jit_object *gcc_jit_type_as_object (gcc_jit_type@w{ }*type)\n\nUpcast a type to an object.\n@end deffn\n\nTypes can be created in several ways:\n\n\n@itemize *\n\n@item \nfundamental types can be accessed using\n@pxref{b,,gcc_jit_context_get_type()}:\n\n@example\ngcc_jit_type *int_type = gcc_jit_context_get_type (GCC_JIT_TYPE_INT);\n@end example\n\n@noindent\n\nSee @pxref{b,,gcc_jit_context_get_type()} for the available types.\n\n@item \nderived types can be accessed by using functions such as\n@pxref{79,,gcc_jit_type_get_pointer()} and @pxref{7a,,gcc_jit_type_get_const()}:\n\n@example\ngcc_jit_type *const_int_star = gcc_jit_type_get_pointer (gcc_jit_type_get_const (int_type));\ngcc_jit_type *int_const_star = gcc_jit_type_get_const (gcc_jit_type_get_pointer (int_type));\n@end example\n\n@noindent\n\n@item \nby creating structures (see below).\n@end itemize\n\n@menu\n* Standard types:: \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile. \n* Structures and unions:: \n\n@end menu\n\n@node Standard types,Pointers const and volatile,,Types\n@anchor{topics/types standard-types}@anchor{7b}\n@subsection Standard types\n\n\n@geindex gcc_jit_context_get_type (C function)\n@anchor{topics/types gcc_jit_context_get_type}@anchor{b}\n@deffn {C Function} gcc_jit_type *gcc_jit_context_get_type (gcc_jit_context@w{ }*ctxt, enum gcc_jit_types@w{ }type_)\n\nAccess a specific type.  The available types are:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} \n@headitem\n\n@cite{enum gcc_jit_types} value\n\n@tab\n\nMeaning\n\n@item\n\n@code{GCC_JIT_TYPE_VOID}\n\n@tab\n\nC's @code{void} type.\n\n@item\n\n@code{GCC_JIT_TYPE_VOID_PTR}\n\n@tab\n\nC's @code{void *}.\n\n@item\n\n@code{GCC_JIT_TYPE_BOOL}\n\n@tab\n\nC++'s @code{bool} type; also C99's\n@code{_Bool} type, aka @code{bool} if\nusing stdbool.h.\n\n@item\n\n@code{GCC_JIT_TYPE_CHAR}\n\n@tab\n\nC's @code{char} (of some signedness)\n\n@item\n\n@code{GCC_JIT_TYPE_SIGNED_CHAR}\n\n@tab\n\nC's @code{signed char}\n\n@item\n\n@code{GCC_JIT_TYPE_UNSIGNED_CHAR}\n\n@tab\n\nC's @code{unsigned char}\n\n@item\n\n@code{GCC_JIT_TYPE_SHORT}\n\n@tab\n\nC's @code{short} (signed)\n\n@item\n\n@code{GCC_JIT_TYPE_UNSIGNED_SHORT}\n\n@tab\n\nC's @code{unsigned short}\n\n@item\n\n@code{GCC_JIT_TYPE_INT}\n\n@tab\n\nC's @code{int} (signed)\n\n@item\n\n@code{GCC_JIT_TYPE_UNSIGNED_INT}\n\n@tab\n\nC's @code{unsigned int}\n\n@item\n\n@code{GCC_JIT_TYPE_LONG}\n\n@tab\n\nC's @code{long} (signed)\n\n@item\n\n@code{GCC_JIT_TYPE_UNSIGNED_LONG}\n\n@tab\n\nC's @code{unsigned long}\n\n@item\n\n@code{GCC_JIT_TYPE_LONG_LONG}\n\n@tab\n\nC99's @code{long long} (signed)\n\n@item\n\n@code{GCC_JIT_TYPE_UNSIGNED_LONG_LONG}\n\n@tab\n\nC99's @code{unsigned long long}\n\n@item\n\n@code{GCC_JIT_TYPE_FLOAT}\n\n@tab\n\n@item\n\n@code{GCC_JIT_TYPE_DOUBLE}\n\n@tab\n\n@item\n\n@code{GCC_JIT_TYPE_LONG_DOUBLE}\n\n@tab\n\n@item\n\n@code{GCC_JIT_TYPE_CONST_CHAR_PTR}\n\n@tab\n\nC type: @code{(const char *)}\n\n@item\n\n@code{GCC_JIT_TYPE_SIZE_T}\n\n@tab\n\nC's @code{size_t} type\n\n@item\n\n@code{GCC_JIT_TYPE_FILE_PTR}\n\n@tab\n\nC type: @code{(FILE *)}\n\n@item\n\n@code{GCC_JIT_TYPE_COMPLEX_FLOAT}\n\n@tab\n\nC99's @code{_Complex float}\n\n@item\n\n@code{GCC_JIT_TYPE_COMPLEX_DOUBLE}\n\n@tab\n\nC99's @code{_Complex double}\n\n@item\n\n@code{GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE}\n\n@tab\n\nC99's @code{_Complex long double}\n\n@end multitable\n\n@end deffn\n\n@geindex gcc_jit_context_get_int_type (C function)\n@anchor{topics/types gcc_jit_context_get_int_type}@anchor{7c}\n@deffn {C Function} gcc_jit_type *           gcc_jit_context_get_int_type (gcc_jit_context@w{ }*ctxt, int@w{ }num_bytes, int@w{ }is_signed)\n\nAccess the integer type of the given size.\n@end deffn\n\n@node Pointers const and volatile,Structures and unions,Standard types,Types\n@anchor{topics/types pointers-const-and-volatile}@anchor{7d}\n@subsection Pointers, @cite{const}, and @cite{volatile}\n\n\n@geindex gcc_jit_type_get_pointer (C function)\n@anchor{topics/types gcc_jit_type_get_pointer}@anchor{79}\n@deffn {C Function} gcc_jit_type *gcc_jit_type_get_pointer (gcc_jit_type@w{ }*type)\n\nGiven type \"T\", get type \"T*\".\n@end deffn\n\n@geindex gcc_jit_type_get_const (C function)\n@anchor{topics/types gcc_jit_type_get_const}@anchor{7a}\n@deffn {C Function} gcc_jit_type *gcc_jit_type_get_const (gcc_jit_type@w{ }*type)\n\nGiven type \"T\", get type \"const T\".\n@end deffn\n\n@geindex gcc_jit_type_get_volatile (C function)\n@anchor{topics/types gcc_jit_type_get_volatile}@anchor{7e}\n@deffn {C Function} gcc_jit_type *gcc_jit_type_get_volatile (gcc_jit_type@w{ }*type)\n\nGiven type \"T\", get type \"volatile T\".\n@end deffn\n\n@geindex gcc_jit_context_new_array_type (C function)\n@anchor{topics/types gcc_jit_context_new_array_type}@anchor{7f}\n@deffn {C Function} gcc_jit_type *            gcc_jit_context_new_array_type (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*element_type, int@w{ }num_elements)\n\nGiven type \"T\", get type \"T[N]\" (for a constant N).\n@end deffn\n\n@node Structures and unions,,Pointers const and volatile,Types\n@anchor{topics/types structures-and-unions}@anchor{80}\n@subsection Structures and unions\n\n\n@geindex gcc_jit_struct (C type)\n@anchor{topics/types gcc_jit_struct}@anchor{81}\n@deffn {C Type} gcc_jit_struct\n@end deffn\n\nA compound type analagous to a C @cite{struct}.\n\n@geindex gcc_jit_field (C type)\n@anchor{topics/types gcc_jit_field}@anchor{82}\n@deffn {C Type} gcc_jit_field\n@end deffn\n\nA field within a @pxref{81,,gcc_jit_struct}.\n\nYou can model C @cite{struct} types by creating @pxref{81,,gcc_jit_struct *} and\n@pxref{82,,gcc_jit_field} instances, in either order:\n\n\n@itemize *\n\n@item \nby creating the fields, then the structure.  For example, to model:\n\n@example\nstruct coord @{double x; double y; @};\n@end example\n\n@noindent\n\nyou could call:\n\n@example\ngcc_jit_field *field_x =\n  gcc_jit_context_new_field (ctxt, NULL, double_type, \"x\");\ngcc_jit_field *field_y =\n  gcc_jit_context_new_field (ctxt, NULL, double_type, \"y\");\ngcc_jit_field *fields[2] = @{field_x, field_y@};\ngcc_jit_struct *coord =\n  gcc_jit_context_new_struct_type (ctxt, NULL, \"coord\", 2, fields);\n@end example\n\n@noindent\n\n@item \nby creating the structure, then populating it with fields, typically\nto allow modelling self-referential structs such as:\n\n@example\nstruct node @{ int m_hash; struct node *m_next; @};\n@end example\n\n@noindent\n\nlike this:\n\n@example\ngcc_jit_type *node =\n  gcc_jit_context_new_opaque_struct (ctxt, NULL, \"node\");\ngcc_jit_type *node_ptr =\n  gcc_jit_type_get_pointer (node);\ngcc_jit_field *field_hash =\n  gcc_jit_context_new_field (ctxt, NULL, int_type, \"m_hash\");\ngcc_jit_field *field_next =\n  gcc_jit_context_new_field (ctxt, NULL, node_ptr, \"m_next\");\ngcc_jit_field *fields[2] = @{field_hash, field_next@};\ngcc_jit_struct_set_fields (node, NULL, 2, fields);\n@end example\n\n@noindent\n@end itemize\n\n@geindex gcc_jit_context_new_field (C function)\n@anchor{topics/types gcc_jit_context_new_field}@anchor{83}\n@deffn {C Function} gcc_jit_field *           gcc_jit_context_new_field (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n\nConstruct a new field, with the given type and name.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n@end deffn\n\n@geindex gcc_jit_field_as_object (C function)\n@anchor{topics/types gcc_jit_field_as_object}@anchor{84}\n@deffn {C Function} gcc_jit_object *           gcc_jit_field_as_object (gcc_jit_field@w{ }*field)\n\nUpcast from field to object.\n@end deffn\n\n@geindex gcc_jit_context_new_struct_type (C function)\n@anchor{topics/types gcc_jit_context_new_struct_type}@anchor{85}\n@deffn {C Function} gcc_jit_struct *gcc_jit_context_new_struct_type (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, const char@w{ }*name, int@w{ }num_fields, gcc_jit_field@w{ }**fields)\n\n@quotation\n\nConstruct a new struct type, with the given name and fields.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of\nthe underlying string, so it is valid to pass in a pointer to an\non-stack buffer.\n@end quotation\n@end deffn\n\n@geindex gcc_jit_context_new_opaque_struct (C function)\n@anchor{topics/types gcc_jit_context_new_opaque_struct}@anchor{86}\n@deffn {C Function} gcc_jit_struct *         gcc_jit_context_new_opaque_struct (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, const char@w{ }*name)\n\nConstruct a new struct type, with the given name, but without\nspecifying the fields.   The fields can be omitted (in which case the\nsize of the struct is not known), or later specified using\n@pxref{87,,gcc_jit_struct_set_fields()}.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of\nthe underlying string, so it is valid to pass in a pointer to an\non-stack buffer.\n@end deffn\n\n@geindex gcc_jit_struct_as_type (C function)\n@anchor{topics/types gcc_jit_struct_as_type}@anchor{88}\n@deffn {C Function} gcc_jit_type *           gcc_jit_struct_as_type (gcc_jit_struct@w{ }*struct_type)\n\nUpcast from struct to type.\n@end deffn\n\n@geindex gcc_jit_struct_set_fields (C function)\n@anchor{topics/types gcc_jit_struct_set_fields}@anchor{87}\n@deffn {C Function} void           gcc_jit_struct_set_fields (gcc_jit_struct@w{ }*struct_type, gcc_jit_location@w{ }*loc, int@w{ }num_fields, gcc_jit_field@w{ }**fields)\n\nPopulate the fields of a formerly-opaque struct type.\n\nThis can only be called once on a given struct type.\n@end deffn\n\n@geindex gcc_jit_context_new_union_type (C function)\n@anchor{topics/types gcc_jit_context_new_union_type}@anchor{89}\n@deffn {C Function} gcc_jit_type *         gcc_jit_context_new_union_type (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, const char@w{ }*name, int@w{ }num_fields, gcc_jit_field@w{ }**fields)\n\nConstruct a new union type, with the given name and fields.\n\nThe parameter @code{name} must be non-NULL.  It is copied, so the input\nbuffer does not need to outlive the call.\n\nExample of use:\n\n@example\n\nunion int_or_float\n@{\n  int as_int;\n  float as_float;\n@};\n\nvoid\ncreate_code (gcc_jit_context *ctxt, void *user_data)\n@{\n  /* Let's try to inject the equivalent of:\n     float\n     test_union (int i)\n     @{\n        union int_or_float u;\n\tu.as_int = i;\n\treturn u.as_float;\n     @}\n  */\n  gcc_jit_type *int_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n  gcc_jit_type *float_type =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n  gcc_jit_field *as_int =\n    gcc_jit_context_new_field (ctxt,\n                               NULL,\n                               int_type,\n                               \"as_int\");\n  gcc_jit_field *as_float =\n    gcc_jit_context_new_field (ctxt,\n                               NULL,\n                               float_type,\n                               \"as_float\");\n  gcc_jit_field *fields[] = @{as_int, as_float@};\n  gcc_jit_type *union_type =\n    gcc_jit_context_new_union_type (ctxt, NULL,\n\t\t\t\t    \"int_or_float\", 2, fields);\n\n  /* Build the test function.  */\n  gcc_jit_param *param_i =\n    gcc_jit_context_new_param (ctxt, NULL, int_type, \"i\");\n  gcc_jit_function *test_fn =\n    gcc_jit_context_new_function (ctxt, NULL,\n                                  GCC_JIT_FUNCTION_EXPORTED,\n                                  float_type,\n                                  \"test_union\",\n                                  1, &param_i,\n                                  0);\n\n  gcc_jit_lvalue *u =\n    gcc_jit_function_new_local (test_fn, NULL,\n\t\t\t\tunion_type, \"u\");\n\n  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n\n  /* u.as_int = i; */\n  gcc_jit_block_add_assignment (\n    block,\n    NULL,\n    /* \"u.as_int = ...\" */\n    gcc_jit_lvalue_access_field (u,\n\t\t\t\t NULL,\n\t\t\t\t as_int),\n    gcc_jit_param_as_rvalue (param_i));\n\n  /* return u.as_float; */\n  gcc_jit_block_end_with_return (\n    block, NULL,\n    gcc_jit_rvalue_access_field (gcc_jit_lvalue_as_rvalue (u),\n\t\t\t\t NULL,\n\t\t\t\t as_float));\n@}\n\n\n@end example\n\n@noindent\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Expressions,Creating and using functions,Types,Topic Reference\n@anchor{topics/expressions expressions}@anchor{8a}@anchor{topics/expressions doc}@anchor{8b}\n@section Expressions\n\n\n@menu\n* Rvalues:: \n* Lvalues:: \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions. \n\nRvalues\n\n* Simple expressions:: \n* Unary Operations:: \n* Binary Operations:: \n* Comparisons:: \n* Function calls:: \n* Type-coercion:: \n\nLvalues\n\n* Global variables:: \n\n@end menu\n\n\n@node Rvalues,Lvalues,,Expressions\n@anchor{topics/expressions rvalues}@anchor{8c}\n@subsection Rvalues\n\n\n@geindex gcc_jit_rvalue (C type)\n@anchor{topics/expressions gcc_jit_rvalue}@anchor{13}\n@deffn {C Type} gcc_jit_rvalue\n@end deffn\n\nA @pxref{13,,gcc_jit_rvalue *} is an expression that can be computed.\n\nIt can be simple, e.g.:\n\n@quotation\n\n\n@itemize *\n\n@item \nan integer value e.g. @cite{0} or @cite{42}\n\n@item \na string literal e.g. @cite{\"Hello world\"}\n\n@item \na variable e.g. @cite{i}.  These are also lvalues (see below).\n@end itemize\n@end quotation\n\nor compound e.g.:\n\n@quotation\n\n\n@itemize *\n\n@item \na unary expression e.g. @cite{!cond}\n\n@item \na binary expression e.g. @cite{(a + b)}\n\n@item \na function call e.g. @cite{get_distance (&player_ship@comma{} &target)}\n\n@item \netc.\n@end itemize\n@end quotation\n\nEvery rvalue has an associated type, and the API will check to ensure\nthat types match up correctly (otherwise the context will emit an error).\n\n@geindex gcc_jit_rvalue_get_type (C function)\n@anchor{topics/expressions gcc_jit_rvalue_get_type}@anchor{8d}\n@deffn {C Function} gcc_jit_type *gcc_jit_rvalue_get_type (gcc_jit_rvalue@w{ }*rvalue)\n\nGet the type of this rvalue.\n@end deffn\n\n@geindex gcc_jit_rvalue_as_object (C function)\n@anchor{topics/expressions gcc_jit_rvalue_as_object}@anchor{14}\n@deffn {C Function} gcc_jit_object *gcc_jit_rvalue_as_object (gcc_jit_rvalue@w{ }*rvalue)\n\nUpcast the given rvalue to be an object.\n@end deffn\n\n@menu\n* Simple expressions:: \n* Unary Operations:: \n* Binary Operations:: \n* Comparisons:: \n* Function calls:: \n* Type-coercion:: \n\n@end menu\n\n@node Simple expressions,Unary Operations,,Rvalues\n@anchor{topics/expressions simple-expressions}@anchor{8e}\n@subsubsection Simple expressions\n\n\n@geindex gcc_jit_context_new_rvalue_from_int (C function)\n@anchor{topics/expressions gcc_jit_context_new_rvalue_from_int}@anchor{30}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_rvalue_from_int (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*numeric_type, int@w{ }value)\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{int} value.\n@end deffn\n\n@geindex gcc_jit_context_new_rvalue_from_long (C function)\n@anchor{topics/expressions gcc_jit_context_new_rvalue_from_long}@anchor{8f}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_rvalue_from_long (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*numeric_type, long@w{ }value)\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{long} value.\n@end deffn\n\n@geindex gcc_jit_context_zero (C function)\n@anchor{topics/expressions gcc_jit_context_zero}@anchor{2b}\n@deffn {C Function} gcc_jit_rvalue *gcc_jit_context_zero (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*numeric_type)\n\nGiven a numeric type (integer or floating point), get the rvalue for\nzero.  Essentially this is just a shortcut for:\n\n@example\ngcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 0)\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_one (C function)\n@anchor{topics/expressions gcc_jit_context_one}@anchor{2f}\n@deffn {C Function} gcc_jit_rvalue *gcc_jit_context_one (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*numeric_type)\n\nGiven a numeric type (integer or floating point), get the rvalue for\none.  Essentially this is just a shortcut for:\n\n@example\ngcc_jit_context_new_rvalue_from_int (ctxt, numeric_type, 1)\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_new_rvalue_from_double (C function)\n@anchor{topics/expressions gcc_jit_context_new_rvalue_from_double}@anchor{31}\n@deffn {C Function} gcc_jit_rvalue *            gcc_jit_context_new_rvalue_from_double (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*numeric_type, double@w{ }value)\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{double} value.\n@end deffn\n\n@geindex gcc_jit_context_new_rvalue_from_ptr (C function)\n@anchor{topics/expressions gcc_jit_context_new_rvalue_from_ptr}@anchor{90}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*pointer_type, void@w{ }*value)\n\nGiven a pointer type, build an rvalue for the given address.\n@end deffn\n\n@geindex gcc_jit_context_null (C function)\n@anchor{topics/expressions gcc_jit_context_null}@anchor{91}\n@deffn {C Function} gcc_jit_rvalue *gcc_jit_context_null (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*pointer_type)\n\nGiven a pointer type, build an rvalue for @code{NULL}.  Essentially this\nis just a shortcut for:\n\n@example\ngcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL)\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_new_string_literal (C function)\n@anchor{topics/expressions gcc_jit_context_new_string_literal}@anchor{92}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_string_literal (gcc_jit_context@w{ }*ctxt, const char@w{ }*value)\n\nGenerate an rvalue for the given NIL-terminated string, of type\n@code{GCC_JIT_TYPE_CONST_CHAR_PTR}.\n\nThe parameter @code{value} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n@end deffn\n\n@node Unary Operations,Binary Operations,Simple expressions,Rvalues\n@anchor{topics/expressions unary-operations}@anchor{93}\n@subsubsection Unary Operations\n\n\n@geindex gcc_jit_context_new_unary_op (C function)\n@anchor{topics/expressions gcc_jit_context_new_unary_op}@anchor{94}\n@deffn {C Function} gcc_jit_rvalue *            gcc_jit_context_new_unary_op (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_unary_op@w{ }op, gcc_jit_type@w{ }*result_type, gcc_jit_rvalue@w{ }*rvalue)\n\nBuild a unary operation out of an input rvalue.\n@end deffn\n\n@geindex gcc_jit_unary_op (C type)\n@anchor{topics/expressions gcc_jit_unary_op}@anchor{95}\n@deffn {C Type} enum gcc_jit_unary_op\n@end deffn\n\nThe available unary operations are:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxx} \n@headitem\n\nUnary Operation\n\n@tab\n\nC equivalent\n\n@item\n\n@pxref{96,,GCC_JIT_UNARY_OP_MINUS}\n\n@tab\n\n@cite{-(EXPR)}\n\n@item\n\n@pxref{97,,GCC_JIT_UNARY_OP_BITWISE_NEGATE}\n\n@tab\n\n@cite{~(EXPR)}\n\n@item\n\n@pxref{98,,GCC_JIT_UNARY_OP_LOGICAL_NEGATE}\n\n@tab\n\n@cite{!(EXPR)}\n\n@item\n\n@pxref{99,,GCC_JIT_UNARY_OP_ABS}\n\n@tab\n\n@cite{abs (EXPR)}\n\n@end multitable\n\n\n@geindex GCC_JIT_UNARY_OP_MINUS (C macro)\n@anchor{topics/expressions GCC_JIT_UNARY_OP_MINUS}@anchor{96}\n@deffn {C Macro} GCC_JIT_UNARY_OP_MINUS\n\nNegate an arithmetic value; analogous to:\n\n@example\n-(EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_UNARY_OP_BITWISE_NEGATE (C macro)\n@anchor{topics/expressions GCC_JIT_UNARY_OP_BITWISE_NEGATE}@anchor{97}\n@deffn {C Macro} GCC_JIT_UNARY_OP_BITWISE_NEGATE\n\nBitwise negation of an integer value (one's complement); analogous\nto:\n\n@example\n~(EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_UNARY_OP_LOGICAL_NEGATE (C macro)\n@anchor{topics/expressions GCC_JIT_UNARY_OP_LOGICAL_NEGATE}@anchor{98}\n@deffn {C Macro} GCC_JIT_UNARY_OP_LOGICAL_NEGATE\n\nLogical negation of an arithmetic or pointer value; analogous to:\n\n@example\n!(EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_UNARY_OP_ABS (C macro)\n@anchor{topics/expressions GCC_JIT_UNARY_OP_ABS}@anchor{99}\n@deffn {C Macro} GCC_JIT_UNARY_OP_ABS\n\nAbsolute value of an arithmetic expression; analogous to:\n\n@example\nabs (EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@node Binary Operations,Comparisons,Unary Operations,Rvalues\n@anchor{topics/expressions binary-operations}@anchor{9a}\n@subsubsection Binary Operations\n\n\n@geindex gcc_jit_context_new_binary_op (C function)\n@anchor{topics/expressions gcc_jit_context_new_binary_op}@anchor{12}\n@deffn {C Function} gcc_jit_rvalue *gcc_jit_context_new_binary_op (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_binary_op@w{ }op, gcc_jit_type@w{ }*result_type, gcc_jit_rvalue@w{ }*a, gcc_jit_rvalue@w{ }*b)\n\nBuild a binary operation out of two constituent rvalues.\n@end deffn\n\n@geindex gcc_jit_binary_op (C type)\n@anchor{topics/expressions gcc_jit_binary_op}@anchor{9b}\n@deffn {C Type} enum gcc_jit_binary_op\n@end deffn\n\nThe available binary operations are:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxx} \n@headitem\n\nBinary Operation\n\n@tab\n\nC equivalent\n\n@item\n\n@pxref{9c,,GCC_JIT_BINARY_OP_PLUS}\n\n@tab\n\n@cite{x + y}\n\n@item\n\n@pxref{9d,,GCC_JIT_BINARY_OP_MINUS}\n\n@tab\n\n@cite{x - y}\n\n@item\n\n@pxref{9e,,GCC_JIT_BINARY_OP_MULT}\n\n@tab\n\n@cite{x * y}\n\n@item\n\n@pxref{9f,,GCC_JIT_BINARY_OP_DIVIDE}\n\n@tab\n\n@cite{x / y}\n\n@item\n\n@pxref{a0,,GCC_JIT_BINARY_OP_MODULO}\n\n@tab\n\n@cite{x % y}\n\n@item\n\n@pxref{a1,,GCC_JIT_BINARY_OP_BITWISE_AND}\n\n@tab\n\n@cite{x & y}\n\n@item\n\n@pxref{a2,,GCC_JIT_BINARY_OP_BITWISE_XOR}\n\n@tab\n\n@cite{x ^ y}\n\n@item\n\n@pxref{a3,,GCC_JIT_BINARY_OP_BITWISE_OR}\n\n@tab\n\n@cite{x | y}\n\n@item\n\n@pxref{a4,,GCC_JIT_BINARY_OP_LOGICAL_AND}\n\n@tab\n\n@cite{x && y}\n\n@item\n\n@pxref{a5,,GCC_JIT_BINARY_OP_LOGICAL_OR}\n\n@tab\n\n@cite{x || y}\n\n@item\n\n@pxref{a6,,GCC_JIT_BINARY_OP_LSHIFT}\n\n@tab\n\n@cite{x << y}\n\n@item\n\n@pxref{a7,,GCC_JIT_BINARY_OP_RSHIFT}\n\n@tab\n\n@cite{x >> y}\n\n@end multitable\n\n\n@geindex GCC_JIT_BINARY_OP_PLUS (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_PLUS}@anchor{9c}\n@deffn {C Macro} GCC_JIT_BINARY_OP_PLUS\n\nAddition of arithmetic values; analogous to:\n\n@example\n(EXPR_A) + (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n\nFor pointer addition, use @pxref{a8,,gcc_jit_context_new_array_access()}.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_MINUS (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_MINUS}@anchor{9d}\n@deffn {C Macro} GCC_JIT_BINARY_OP_MINUS\n\nSubtraction of arithmetic values; analogous to:\n\n@example\n(EXPR_A) - (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_MULT (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_MULT}@anchor{9e}\n@deffn {C Macro} GCC_JIT_BINARY_OP_MULT\n\nMultiplication of a pair of arithmetic values; analogous to:\n\n@example\n(EXPR_A) * (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_DIVIDE (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_DIVIDE}@anchor{9f}\n@deffn {C Macro} GCC_JIT_BINARY_OP_DIVIDE\n\nQuotient of division of arithmetic values; analogous to:\n\n@example\n(EXPR_A) / (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n\nThe result type affects the kind of division: if the result type is\ninteger-based, then the result is truncated towards zero, whereas\na floating-point result type indicates floating-point division.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_MODULO (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_MODULO}@anchor{a0}\n@deffn {C Macro} GCC_JIT_BINARY_OP_MODULO\n\nRemainder of division of arithmetic values; analogous to:\n\n@example\n(EXPR_A) % (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_BITWISE_AND (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_AND}@anchor{a1}\n@deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_AND\n\nBitwise AND; analogous to:\n\n@example\n(EXPR_A) & (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_BITWISE_XOR (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_XOR}@anchor{a2}\n@deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_XOR\n\nBitwise exclusive OR; analogous to:\n\n@example\n(EXPR_A) ^ (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_BITWISE_OR (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_OR}@anchor{a3}\n@deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_OR\n\nBitwise inclusive OR; analogous to:\n\n@example\n(EXPR_A) | (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_LOGICAL_AND (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_AND}@anchor{a4}\n@deffn {C Macro} GCC_JIT_BINARY_OP_LOGICAL_AND\n\nLogical AND; analogous to:\n\n@example\n(EXPR_A) && (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_LOGICAL_OR (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_OR}@anchor{a5}\n@deffn {C Macro} GCC_JIT_BINARY_OP_LOGICAL_OR\n\nLogical OR; analogous to:\n\n@example\n(EXPR_A) || (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_LSHIFT (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_LSHIFT}@anchor{a6}\n@deffn {C Macro} GCC_JIT_BINARY_OP_LSHIFT\n\nLeft shift; analogous to:\n\n@example\n(EXPR_A) << (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex GCC_JIT_BINARY_OP_RSHIFT (C macro)\n@anchor{topics/expressions GCC_JIT_BINARY_OP_RSHIFT}@anchor{a7}\n@deffn {C Macro} GCC_JIT_BINARY_OP_RSHIFT\n\nRight shift; analogous to:\n\n@example\n(EXPR_A) >> (EXPR_B)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@node Comparisons,Function calls,Binary Operations,Rvalues\n@anchor{topics/expressions comparisons}@anchor{a9}\n@subsubsection Comparisons\n\n\n@geindex gcc_jit_context_new_comparison (C function)\n@anchor{topics/expressions gcc_jit_context_new_comparison}@anchor{2c}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_comparison (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_comparison@w{ }op, gcc_jit_rvalue@w{ }*a, gcc_jit_rvalue@w{ }*b)\n\nBuild a boolean rvalue out of the comparison of two other rvalues.\n@end deffn\n\n@geindex gcc_jit_comparison (C type)\n@anchor{topics/expressions gcc_jit_comparison}@anchor{aa}\n@deffn {C Type} enum gcc_jit_comparison\n@end deffn\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxx} \n@headitem\n\nComparison\n\n@tab\n\nC equivalent\n\n@item\n\n@code{GCC_JIT_COMPARISON_EQ}\n\n@tab\n\n@cite{x == y}\n\n@item\n\n@code{GCC_JIT_COMPARISON_NE}\n\n@tab\n\n@cite{x != y}\n\n@item\n\n@code{GCC_JIT_COMPARISON_LT}\n\n@tab\n\n@cite{x < y}\n\n@item\n\n@code{GCC_JIT_COMPARISON_LE}\n\n@tab\n\n@cite{x <= y}\n\n@item\n\n@code{GCC_JIT_COMPARISON_GT}\n\n@tab\n\n@cite{x > y}\n\n@item\n\n@code{GCC_JIT_COMPARISON_GE}\n\n@tab\n\n@cite{x >= y}\n\n@end multitable\n\n\n@node Function calls,Type-coercion,Comparisons,Rvalues\n@anchor{topics/expressions function-calls}@anchor{ab}\n@subsubsection Function calls\n\n\n@geindex gcc_jit_context_new_call (C function)\n@anchor{topics/expressions gcc_jit_context_new_call}@anchor{ac}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_call (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_function@w{ }*func, int@w{ }numargs, gcc_jit_rvalue@w{ }**args)\n\nGiven a function and the given table of argument rvalues, construct a\ncall to the function, with the result as an rvalue.\n\n@cartouche\n@quotation Note \n@pxref{ac,,gcc_jit_context_new_call()} merely builds a\n@pxref{13,,gcc_jit_rvalue} i.e. an expression that can be evaluated,\nperhaps as part of a more complicated expression.\nThe call @emph{won't} happen unless you add a statement to a function\nthat evaluates the expression.\n\nFor example, if you want to call a function and discard the result\n(or to call a function with @code{void} return type), use\n@pxref{ad,,gcc_jit_block_add_eval()}:\n\n@example\n/* Add \"(void)printf (arg0, arg1);\".  */\ngcc_jit_block_add_eval (\n  block, NULL,\n  gcc_jit_context_new_call (\n    ctxt,\n    NULL,\n    printf_func,\n    2, args));\n@end example\n\n@noindent\n@end quotation\n@end cartouche\n@end deffn\n\n@geindex gcc_jit_context_new_call_through_ptr (C function)\n@anchor{topics/expressions gcc_jit_context_new_call_through_ptr}@anchor{ae}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_call_through_ptr (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*fn_ptr, int@w{ }numargs, gcc_jit_rvalue@w{ }**args)\n\nGiven an rvalue of function pointer type, and the given table of\nargument rvalues, construct a call to the function pointer, with the\nresult as an rvalue.\n\n@cartouche\n@quotation Note \nThe same caveat as for @pxref{ac,,gcc_jit_context_new_call()} applies.\n@end quotation\n@end cartouche\n@end deffn\n\n@node Type-coercion,,Function calls,Rvalues\n@anchor{topics/expressions type-coercion}@anchor{af}\n@subsubsection Type-coercion\n\n\n@geindex gcc_jit_context_new_cast (C function)\n@anchor{topics/expressions gcc_jit_context_new_cast}@anchor{b0}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_cast (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue, gcc_jit_type@w{ }*type)\n\nGiven an rvalue of T, construct another rvalue of another type.\n\nCurrently only a limited set of conversions are possible:\n\n@quotation\n\n\n@itemize *\n\n@item \nint <-> float\n\n@item \nint <-> bool\n\n@item \nP*  <-> Q*, for pointer types P and Q\n@end itemize\n@end quotation\n@end deffn\n\n@node Lvalues,Working with pointers structs and unions,Rvalues,Expressions\n@anchor{topics/expressions lvalues}@anchor{b1}\n@subsection Lvalues\n\n\n@geindex gcc_jit_lvalue (C type)\n@anchor{topics/expressions gcc_jit_lvalue}@anchor{24}\n@deffn {C Type} gcc_jit_lvalue\n@end deffn\n\nAn lvalue is something that can of the @emph{left}-hand side of an assignment:\na storage area (such as a variable).  It is also usable as an rvalue,\nwhere the rvalue is computed by reading from the storage area.\n\n@geindex gcc_jit_lvalue_as_object (C function)\n@anchor{topics/expressions gcc_jit_lvalue_as_object}@anchor{b2}\n@deffn {C Function} gcc_jit_object *           gcc_jit_lvalue_as_object (gcc_jit_lvalue@w{ }*lvalue)\n\nUpcast an lvalue to be an object.\n@end deffn\n\n@geindex gcc_jit_lvalue_as_rvalue (C function)\n@anchor{topics/expressions gcc_jit_lvalue_as_rvalue}@anchor{b3}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_lvalue_as_rvalue (gcc_jit_lvalue@w{ }*lvalue)\n\nUpcast an lvalue to be an rvalue.\n@end deffn\n\n@geindex gcc_jit_lvalue_get_address (C function)\n@anchor{topics/expressions gcc_jit_lvalue_get_address}@anchor{b4}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_lvalue_get_address (gcc_jit_lvalue@w{ }*lvalue, gcc_jit_location@w{ }*loc)\n\nTake the address of an lvalue; analogous to:\n\n@example\n&(EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@menu\n* Global variables:: \n\n@end menu\n\n@node Global variables,,,Lvalues\n@anchor{topics/expressions global-variables}@anchor{b5}\n@subsubsection Global variables\n\n\n@geindex gcc_jit_context_new_global (C function)\n@anchor{topics/expressions gcc_jit_context_new_global}@anchor{b6}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_context_new_global (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_global_kind@w{ }kind, gcc_jit_type@w{ }*type, const char@w{ }*name)\n\nAdd a new global variable of the given type and name to the context.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n\nThe \"kind\" parameter determines the visibility of the \"global\" outside\nof the @pxref{16,,gcc_jit_result}:\n\n@geindex gcc_jit_global_kind (C type)\n@anchor{topics/expressions gcc_jit_global_kind}@anchor{b7}\n@deffn {C Type} enum gcc_jit_global_kind\n@end deffn\n\n@geindex GCC_JIT_GLOBAL_EXPORTED (C macro)\n@anchor{topics/expressions GCC_JIT_GLOBAL_EXPORTED}@anchor{b8}\n@deffn {C Macro} GCC_JIT_GLOBAL_EXPORTED\n\nGlobal is defined by the client code and is visible\nby name outside of this JIT context via\n@pxref{b9,,gcc_jit_result_get_global()} (and this value is required for\nthe global to be accessible via that entrypoint).\n@end deffn\n\n@geindex GCC_JIT_GLOBAL_INTERNAL (C macro)\n@anchor{topics/expressions GCC_JIT_GLOBAL_INTERNAL}@anchor{ba}\n@deffn {C Macro} GCC_JIT_GLOBAL_INTERNAL\n\nGlobal is defined by the client code, but is invisible\noutside of it.  Analogous to a \"static\" global within a .c file.\nSpecifically, the variable will only be visible within this\ncontext and within child contexts.\n@end deffn\n\n@geindex GCC_JIT_GLOBAL_IMPORTED (C macro)\n@anchor{topics/expressions GCC_JIT_GLOBAL_IMPORTED}@anchor{bb}\n@deffn {C Macro} GCC_JIT_GLOBAL_IMPORTED\n\nGlobal is not defined by the client code; we're merely\nreferring to it.  Analogous to using an \"extern\" global from a\nheader file.\n@end deffn\n@end deffn\n\n@node Working with pointers structs and unions,,Lvalues,Expressions\n@anchor{topics/expressions working-with-pointers-structs-and-unions}@anchor{bc}\n@subsection Working with pointers, structs and unions\n\n\n@geindex gcc_jit_rvalue_dereference (C function)\n@anchor{topics/expressions gcc_jit_rvalue_dereference}@anchor{bd}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_rvalue_dereference (gcc_jit_rvalue@w{ }*rvalue, gcc_jit_location@w{ }*loc)\n\nGiven an rvalue of pointer type @code{T *}, dereferencing the pointer,\ngetting an lvalue of type @code{T}.  Analogous to:\n\n@example\n*(EXPR)\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\nField access is provided separately for both lvalues and rvalues.\n\n@geindex gcc_jit_lvalue_access_field (C function)\n@anchor{topics/expressions gcc_jit_lvalue_access_field}@anchor{be}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_lvalue_access_field (gcc_jit_lvalue@w{ }*struct_, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n\nGiven an lvalue of struct or union type, access the given field,\ngetting an lvalue of the field's type.  Analogous to:\n\n@example\n(EXPR).field = ...;\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex gcc_jit_rvalue_access_field (C function)\n@anchor{topics/expressions gcc_jit_rvalue_access_field}@anchor{bf}\n@deffn {C Function} gcc_jit_rvalue *           gcc_jit_rvalue_access_field (gcc_jit_rvalue@w{ }*struct_, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n\nGiven an rvalue of struct or union type, access the given field\nas an rvalue.  Analogous to:\n\n@example\n(EXPR).field\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex gcc_jit_rvalue_dereference_field (C function)\n@anchor{topics/expressions gcc_jit_rvalue_dereference_field}@anchor{c0}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_rvalue_dereference_field (gcc_jit_rvalue@w{ }*ptr, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n\nGiven an rvalue of pointer type @code{T *} where T is of struct or union\ntype, access the given field as an lvalue.  Analogous to:\n\n@example\n(EXPR)->field\n@end example\n\n@noindent\n\nin C, itself equivalent to @code{(*EXPR).FIELD}.\n@end deffn\n\n@geindex gcc_jit_context_new_array_access (C function)\n@anchor{topics/expressions gcc_jit_context_new_array_access}@anchor{a8}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_context_new_array_access (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*ptr, gcc_jit_rvalue@w{ }*index)\n\nGiven an rvalue of pointer type @code{T *}, get at the element @cite{T} at\nthe given index, using standard C array indexing rules i.e. each\nincrement of @code{index} corresponds to @code{sizeof(T)} bytes.\nAnalogous to:\n\n@example\nPTR[INDEX]\n@end example\n\n@noindent\n\nin C (or, indeed, to @code{PTR + INDEX}).\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Creating and using functions,Source Locations,Expressions,Topic Reference\n@anchor{topics/functions doc}@anchor{c1}@anchor{topics/functions creating-and-using-functions}@anchor{c2}\n@section Creating and using functions\n\n\n@menu\n* Params:: \n* Functions:: \n* Blocks:: \n* Statements:: \n\n@end menu\n\n@node Params,Functions,,Creating and using functions\n@anchor{topics/functions params}@anchor{c3}\n@subsection Params\n\n\n@geindex gcc_jit_param (C type)\n@anchor{topics/functions gcc_jit_param}@anchor{25}\n@deffn {C Type} gcc_jit_param\n\nA @cite{gcc_jit_param} represents a parameter to a function.\n@end deffn\n\n@geindex gcc_jit_context_new_param (C function)\n@anchor{topics/functions gcc_jit_context_new_param}@anchor{10}\n@deffn {C Function} gcc_jit_param *           gcc_jit_context_new_param (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n\nIn preparation for creating a function, create a new parameter of the\ngiven type and name.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n@end deffn\n\nParameters are lvalues, and thus are also rvalues (and objects), so the\nfollowing upcasts are available:\n\n@geindex gcc_jit_param_as_lvalue (C function)\n@anchor{topics/functions gcc_jit_param_as_lvalue}@anchor{c4}\n@deffn {C Function} gcc_jit_lvalue *            gcc_jit_param_as_lvalue (gcc_jit_param@w{ }*param)\n\nUpcasting from param to lvalue.\n@end deffn\n\n@geindex gcc_jit_param_as_rvalue (C function)\n@anchor{topics/functions gcc_jit_param_as_rvalue}@anchor{c5}\n@deffn {C Function} gcc_jit_rvalue *            gcc_jit_param_as_rvalue (gcc_jit_param@w{ }*param)\n\nUpcasting from param to rvalue.\n@end deffn\n\n@geindex gcc_jit_param_as_object (C function)\n@anchor{topics/functions gcc_jit_param_as_object}@anchor{c6}\n@deffn {C Function} gcc_jit_object *            gcc_jit_param_as_object (gcc_jit_param@w{ }*param)\n\nUpcasting from param to object.\n@end deffn\n\n@node Functions,Blocks,Params,Creating and using functions\n@anchor{topics/functions functions}@anchor{c7}\n@subsection Functions\n\n\n@geindex gcc_jit_function (C type)\n@anchor{topics/functions gcc_jit_function}@anchor{29}\n@deffn {C Type} gcc_jit_function\n\nA @cite{gcc_jit_function} represents a function - either one that we're\ncreating ourselves, or one that we're referencing.\n@end deffn\n\n@geindex gcc_jit_context_new_function (C function)\n@anchor{topics/functions gcc_jit_context_new_function}@anchor{11}\n@deffn {C Function} gcc_jit_function *            gcc_jit_context_new_function (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_function_kind@w{ }kind, gcc_jit_type@w{ }*return_type, const char@w{ }*name, int@w{ }num_params, gcc_jit_param@w{ }**params, int@w{ }is_variadic)\n\nCreate a gcc_jit_function with the given name and parameters.\n\n@geindex gcc_jit_function_kind (C type)\n@anchor{topics/functions gcc_jit_function_kind}@anchor{c8}\n@deffn {C Type} enum gcc_jit_function_kind\n@end deffn\n\nThis enum controls the kind of function created, and has the following\nvalues:\n\n@quotation\n\n@geindex GCC_JIT_FUNCTION_EXPORTED (C macro)\n@anchor{topics/functions GCC_JIT_FUNCTION_EXPORTED}@anchor{c9}\n@deffn {C Macro} GCC_JIT_FUNCTION_EXPORTED\n\nFunction is defined by the client code and visible\nby name outside of the JIT.\n\nThis value is required if you want to extract machine code\nfor this function from a @pxref{16,,gcc_jit_result} via\n@pxref{17,,gcc_jit_result_get_code()}.\n@end deffn\n\n@geindex GCC_JIT_FUNCTION_INTERNAL (C macro)\n@anchor{topics/functions GCC_JIT_FUNCTION_INTERNAL}@anchor{ca}\n@deffn {C Macro} GCC_JIT_FUNCTION_INTERNAL\n\nFunction is defined by the client code, but is invisible\noutside of the JIT.  Analogous to a \"static\" function.\n@end deffn\n\n@geindex GCC_JIT_FUNCTION_IMPORTED (C macro)\n@anchor{topics/functions GCC_JIT_FUNCTION_IMPORTED}@anchor{cb}\n@deffn {C Macro} GCC_JIT_FUNCTION_IMPORTED\n\nFunction is not defined by the client code; we're merely\nreferring to it.  Analogous to using an \"extern\" function from a\nheader file.\n@end deffn\n\n@geindex GCC_JIT_FUNCTION_ALWAYS_INLINE (C macro)\n@anchor{topics/functions GCC_JIT_FUNCTION_ALWAYS_INLINE}@anchor{cc}\n@deffn {C Macro} GCC_JIT_FUNCTION_ALWAYS_INLINE\n\nFunction is only ever inlined into other functions, and is\ninvisible outside of the JIT.\n\nAnalogous to prefixing with @code{inline} and adding\n@code{__attribute__((always_inline))}\n\nInlining will only occur when the optimization level is\nabove 0; when optimization is off, this is essentially the\nsame as GCC_JIT_FUNCTION_INTERNAL.\n@end deffn\n@end quotation\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n@end deffn\n\n@geindex gcc_jit_context_get_builtin_function (C function)\n@anchor{topics/functions gcc_jit_context_get_builtin_function}@anchor{cd}\n@deffn {C Function} gcc_jit_function *gcc_jit_context_get_builtin_function (gcc_jit_context@w{ }*ctxt, const char@w{ }*name)\n@end deffn\n\n@geindex gcc_jit_function_as_object (C function)\n@anchor{topics/functions gcc_jit_function_as_object}@anchor{ce}\n@deffn {C Function} gcc_jit_object *           gcc_jit_function_as_object (gcc_jit_function@w{ }*func)\n\nUpcasting from function to object.\n@end deffn\n\n@geindex gcc_jit_function_get_param (C function)\n@anchor{topics/functions gcc_jit_function_get_param}@anchor{cf}\n@deffn {C Function} gcc_jit_param *            gcc_jit_function_get_param (gcc_jit_function@w{ }*func, int@w{ }index)\n\nGet the param of the given index (0-based).\n@end deffn\n\n@geindex gcc_jit_function_dump_to_dot (C function)\n@anchor{topics/functions gcc_jit_function_dump_to_dot}@anchor{33}\n@deffn {C Function} void             gcc_jit_function_dump_to_dot (gcc_jit_function@w{ }*func, const char@w{ }*path)\n\nEmit the function in graphviz format to the given path.\n@end deffn\n\n@geindex gcc_jit_function_new_local (C function)\n@anchor{topics/functions gcc_jit_function_new_local}@anchor{26}\n@deffn {C Function} gcc_jit_lvalue *           gcc_jit_function_new_local (gcc_jit_function@w{ }*func, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n\nCreate a new local variable within the function, of the given type and\nname.\n\nThe parameter @code{name} must be non-NULL.  The call takes a copy of the\nunderlying string, so it is valid to pass in a pointer to an on-stack\nbuffer.\n@end deffn\n\n@node Blocks,Statements,Functions,Creating and using functions\n@anchor{topics/functions blocks}@anchor{d0}\n@subsection Blocks\n\n\n@geindex gcc_jit_block (C type)\n@anchor{topics/functions gcc_jit_block}@anchor{28}\n@deffn {C Type} gcc_jit_block\n\nA @cite{gcc_jit_block} represents a basic block within a function  i.e. a\nsequence of statements with a single entry point and a single exit\npoint.\n\nThe first basic block that you create within a function will\nbe the entrypoint.\n\nEach basic block that you create within a function must be\nterminated, either with a conditional, a jump, a return, or a\nswitch.\n\nIt's legal to have multiple basic blocks that return within\none function.\n@end deffn\n\n@geindex gcc_jit_function_new_block (C function)\n@anchor{topics/functions gcc_jit_function_new_block}@anchor{d1}\n@deffn {C Function} gcc_jit_block *            gcc_jit_function_new_block (gcc_jit_function@w{ }*func, const char@w{ }*name)\n\nCreate a basic block of the given name.  The name may be NULL, but\nproviding meaningful names is often helpful when debugging: it may\nshow up in dumps of the internal representation, and in error\nmessages.  It is copied, so the input buffer does not need to outlive\nthe call; you can pass in a pointer to an on-stack buffer, e.g.:\n\n@example\nfor (pc = 0; pc < fn->fn_num_ops; pc++)\n @{\n   char buf[16];\n   sprintf (buf, \"instr%i\", pc);\n   state.op_blocks[pc] = gcc_jit_function_new_block (state.fn, buf);\n @}\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_as_object (C function)\n@anchor{topics/functions gcc_jit_block_as_object}@anchor{d2}\n@deffn {C Function} gcc_jit_object *            gcc_jit_block_as_object (gcc_jit_block@w{ }*block)\n\nUpcast from block to object.\n@end deffn\n\n@geindex gcc_jit_block_get_function (C function)\n@anchor{topics/functions gcc_jit_block_get_function}@anchor{d3}\n@deffn {C Function} gcc_jit_function *            gcc_jit_block_get_function (gcc_jit_block@w{ }*block)\n\nWhich function is this block within?\n@end deffn\n\n@node Statements,,Blocks,Creating and using functions\n@anchor{topics/functions statements}@anchor{d4}\n@subsection Statements\n\n\n@geindex gcc_jit_block_add_eval (C function)\n@anchor{topics/functions gcc_jit_block_add_eval}@anchor{ad}\n@deffn {C Function} void           gcc_jit_block_add_eval (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue)\n\nAdd evaluation of an rvalue, discarding the result\n(e.g. a function call that \"returns\" void).\n\nThis is equivalent to this C code:\n\n@example\n(void)expression;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_add_assignment (C function)\n@anchor{topics/functions gcc_jit_block_add_assignment}@anchor{2a}\n@deffn {C Function} void           gcc_jit_block_add_assignment (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_lvalue@w{ }*lvalue, gcc_jit_rvalue@w{ }*rvalue)\n\nAdd evaluation of an rvalue, assigning the result to the given\nlvalue.\n\nThis is roughly equivalent to this C code:\n\n@example\nlvalue = rvalue;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_add_assignment_op (C function)\n@anchor{topics/functions gcc_jit_block_add_assignment_op}@anchor{2e}\n@deffn {C Function} void           gcc_jit_block_add_assignment_op (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_lvalue@w{ }*lvalue, enum gcc_jit_binary_op@w{ }op, gcc_jit_rvalue@w{ }*rvalue)\n\nAdd evaluation of an rvalue, using the result to modify an\nlvalue.\n\nThis is analogous to \"+=\" and friends:\n\n@example\nlvalue += rvalue;\nlvalue *= rvalue;\nlvalue /= rvalue;\n@end example\n\n@noindent\n\netc.  For example:\n\n@example\n/* \"i++\" */\ngcc_jit_block_add_assignment_op (\n  loop_body, NULL,\n  i,\n  GCC_JIT_BINARY_OP_PLUS,\n  gcc_jit_context_one (ctxt, int_type));\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_add_comment (C function)\n@anchor{topics/functions gcc_jit_block_add_comment}@anchor{3d}\n@deffn {C Function} void           gcc_jit_block_add_comment (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, const char@w{ }*text)\n\nAdd a no-op textual comment to the internal representation of the\ncode.  It will be optimized away, but will be visible in the dumps\nseen via @pxref{66,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}\nand @pxref{1c,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE},\nand thus may be of use when debugging how your project's internal\nrepresentation gets converted to the libgccjit IR.\n\nThe parameter @code{text} must be non-NULL.  It is copied, so the input\nbuffer does not need to outlive the call.  For example:\n\n@example\nchar buf[100];\nsnprintf (buf, sizeof (buf),\n          \"op%i: %s\",\n          pc, opcode_names[op->op_opcode]);\ngcc_jit_block_add_comment (block, loc, buf);\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_end_with_conditional (C function)\n@anchor{topics/functions gcc_jit_block_end_with_conditional}@anchor{2d}\n@deffn {C Function} void           gcc_jit_block_end_with_conditional (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*boolval, gcc_jit_block@w{ }*on_true, gcc_jit_block@w{ }*on_false)\n\nTerminate a block by adding evaluation of an rvalue, branching on the\nresult to the appropriate successor block.\n\nThis is roughly equivalent to this C code:\n\n@example\nif (boolval)\n  goto on_true;\nelse\n  goto on_false;\n@end example\n\n@noindent\n\nblock, boolval, on_true, and on_false must be non-NULL.\n@end deffn\n\n@geindex gcc_jit_block_end_with_jump (C function)\n@anchor{topics/functions gcc_jit_block_end_with_jump}@anchor{d5}\n@deffn {C Function} void           gcc_jit_block_end_with_jump (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_block@w{ }*target)\n\nTerminate a block by adding a jump to the given target block.\n\nThis is roughly equivalent to this C code:\n\n@example\ngoto target;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_end_with_return (C function)\n@anchor{topics/functions gcc_jit_block_end_with_return}@anchor{d6}\n@deffn {C Function} void           gcc_jit_block_end_with_return (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue)\n\nTerminate a block by adding evaluation of an rvalue, returning the value.\n\nThis is roughly equivalent to this C code:\n\n@example\nreturn expression;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_end_with_void_return (C function)\n@anchor{topics/functions gcc_jit_block_end_with_void_return}@anchor{d7}\n@deffn {C Function} void           gcc_jit_block_end_with_void_return (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc)\n\nTerminate a block by adding a valueless return, for use within a function\nwith \"void\" return type.\n\nThis is equivalent to this C code:\n\n@example\nreturn;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_block_end_with_switch (C function)\n@anchor{topics/functions gcc_jit_block_end_with_switch}@anchor{d8}\n@deffn {C Function} void           gcc_jit_block_end_with_switch (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*expr, gcc_jit_block@w{ }*default_block, int@w{ }num_cases, gcc_jit_case@w{ }**cases)\n\nTerminate a block by adding evalation of an rvalue, then performing\na multiway branch.\n\nThis is roughly equivalent to this C code:\n\n@example\nswitch (expr)\n  @{\n  default:\n    goto default_block;\n\n  case C0.min_value ... C0.max_value:\n    goto C0.dest_block;\n\n  case C1.min_value ... C1.max_value:\n    goto C1.dest_block;\n\n  ...etc...\n\n  case C[N - 1].min_value ... C[N - 1].max_value:\n    goto C[N - 1].dest_block;\n@}\n@end example\n\n@noindent\n\n@code{block}, @code{expr}, @code{default_block} and @code{cases} must all be\nnon-NULL.\n\n@code{expr} must be of the same integer type as all of the @code{min_value}\nand @code{max_value} within the cases.\n\n@code{num_cases} must be >= 0.\n\nThe ranges of the cases must not overlap (or have duplicate\nvalues).\n\nThe API entrypoints relating to switch statements and cases:\n\n@quotation\n\n\n@itemize *\n\n@item \n@pxref{d8,,gcc_jit_block_end_with_switch()}\n\n@item \n@pxref{d9,,gcc_jit_case_as_object()}\n\n@item \n@pxref{da,,gcc_jit_context_new_case()}\n@end itemize\n@end quotation\n\nwere added in @pxref{db,,LIBGCCJIT_ABI_3}; you can test for their presence\nusing\n\n@example\n#ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n@end example\n\n@noindent\n\n@geindex gcc_jit_case (C type)\n@anchor{topics/functions gcc_jit_case}@anchor{dc}\n@deffn {C Type} gcc_jit_case\n@end deffn\n\nA @cite{gcc_jit_case} represents a case within a switch statement, and\nis created within a particular @pxref{8,,gcc_jit_context} using\n@pxref{da,,gcc_jit_context_new_case()}.\n\nEach case expresses a multivalued range of integer values.  You\ncan express single-valued cases by passing in the same value for\nboth @cite{min_value} and @cite{max_value}.\n\n@geindex gcc_jit_context_new_case (C function)\n@anchor{topics/functions gcc_jit_context_new_case}@anchor{da}\n@deffn {C Function} gcc_jit_case *           gcc_jit_context_new_case (gcc_jit_context@w{ }*ctxt, gcc_jit_rvalue@w{ }*min_value, gcc_jit_rvalue@w{ }*max_value, gcc_jit_block@w{ }*dest_block)\n\nCreate a new gcc_jit_case instance for use in a switch statement.\n@cite{min_value} and @cite{max_value} must be constants of an integer type,\nwhich must match that of the expression of the switch statement.\n\n@cite{dest_block} must be within the same function as the switch\nstatement.\n@end deffn\n\n@geindex gcc_jit_case_as_object (C function)\n@anchor{topics/functions gcc_jit_case_as_object}@anchor{d9}\n@deffn {C Function} gcc_jit_object *           gcc_jit_case_as_object (gcc_jit_case@w{ }*case_)\n\nUpcast from a case to an object.\n@end deffn\n\nHere's an example of creating a switch statement:\n\n@quotation\n\n@example\n\nvoid\ncreate_code (gcc_jit_context *ctxt, void *user_data)\n@{\n  /* Let's try to inject the equivalent of:\n      int\n      test_switch (int x)\n      @{\n\tswitch (x)\n\t  @{\n\t  case 0 ... 5:\n\t     return 3;\n\n\t  case 25 ... 27:\n\t     return 4;\n\n\t  case -42 ... -17:\n\t     return 83;\n\n\t  case 40:\n\t     return 8;\n\n\t  default:\n\t     return 10;\n\t  @}\n      @}\n   */\n  gcc_jit_type *t_int =\n    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n  gcc_jit_type *return_type = t_int;\n  gcc_jit_param *x =\n    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n  gcc_jit_param *params[1] = @{x@};\n  gcc_jit_function *func =\n    gcc_jit_context_new_function (ctxt, NULL,\n\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n\t\t\t\t  return_type,\n\t\t\t\t  \"test_switch\",\n\t\t\t\t  1, params, 0);\n\n  gcc_jit_block *b_initial =\n    gcc_jit_function_new_block (func, \"initial\");\n\n  gcc_jit_block *b_default =\n    gcc_jit_function_new_block (func, \"default\");\n  gcc_jit_block *b_case_0_5 =\n    gcc_jit_function_new_block (func, \"case_0_5\");\n  gcc_jit_block *b_case_25_27 =\n    gcc_jit_function_new_block (func, \"case_25_27\");\n  gcc_jit_block *b_case_m42_m17 =\n    gcc_jit_function_new_block (func, \"case_m42_m17\");\n  gcc_jit_block *b_case_40 =\n    gcc_jit_function_new_block (func, \"case_40\");\n\n  gcc_jit_case *cases[4] = @{\n    gcc_jit_context_new_case (\n      ctxt,\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 0),\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 5),\n      b_case_0_5),\n    gcc_jit_context_new_case (\n      ctxt,\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 25),\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 27),\n      b_case_25_27),\n    gcc_jit_context_new_case (\n      ctxt,\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, -42),\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, -17),\n      b_case_m42_m17),\n    gcc_jit_context_new_case (\n      ctxt,\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 40),\n      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 40),\n      b_case_40)\n  @};\n  gcc_jit_block_end_with_switch (\n    b_initial, NULL,\n    gcc_jit_param_as_rvalue (x),\n    b_default,\n    4, cases);\n\n  gcc_jit_block_end_with_return (\n    b_case_0_5, NULL,\n    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n  gcc_jit_block_end_with_return (\n    b_case_25_27, NULL,\n    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 4));\n  gcc_jit_block_end_with_return (\n    b_case_m42_m17, NULL,\n    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 83));\n  gcc_jit_block_end_with_return (\n    b_case_40, NULL,\n    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 8));\n  gcc_jit_block_end_with_return (\n    b_default, NULL,\n    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Source Locations,Compiling a context,Creating and using functions,Topic Reference\n@anchor{topics/locations source-locations}@anchor{dd}@anchor{topics/locations doc}@anchor{de}\n@section Source Locations\n\n\n@geindex gcc_jit_location (C type)\n@anchor{topics/locations gcc_jit_location}@anchor{3b}\n@deffn {C Type} gcc_jit_location\n\nA @cite{gcc_jit_location} encapsulates a source code location, so that\nyou can (optionally) associate locations in your language with\nstatements in the JIT-compiled code, allowing the debugger to\nsingle-step through your language.\n\n@cite{gcc_jit_location} instances are optional: you can always pass NULL to\nany API entrypoint accepting one.\n\nYou can construct them using @pxref{41,,gcc_jit_context_new_location()}.\n\nYou need to enable @pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n@pxref{8,,gcc_jit_context} for these locations to actually be usable by\nthe debugger:\n\n@example\ngcc_jit_context_set_bool_option (\n  ctxt,\n  GCC_JIT_BOOL_OPTION_DEBUGINFO,\n  1);\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_new_location (C function)\n@anchor{topics/locations gcc_jit_context_new_location}@anchor{41}\n@deffn {C Function} gcc_jit_location *           gcc_jit_context_new_location (gcc_jit_context@w{ }*ctxt, const char@w{ }*filename, int@w{ }line, int@w{ }column)\n\nCreate a @cite{gcc_jit_location} instance representing the given source\nlocation.\n\nThe parameter @code{filename} must be non-NULL.  The call takes a copy of\nthe underlying string, so it is valid to pass in a pointer to an\non-stack buffer.\n@end deffn\n\n@menu\n* Faking it:: \n\n@end menu\n\n@node Faking it,,,Source Locations\n@anchor{topics/locations faking-it}@anchor{df}\n@subsection Faking it\n\n\nIf you don't have source code for your internal representation, but need\nto debug, you can generate a C-like representation of the functions in\nyour context using @pxref{5a,,gcc_jit_context_dump_to_file()}:\n\n@example\ngcc_jit_context_dump_to_file (ctxt, \"/tmp/something.c\",\n                              1 /* update_locations */);\n@end example\n\n@noindent\n\nThis will dump C-like code to the given path.  If the @cite{update_locations}\nargument is true, this will also set up @cite{gcc_jit_location} information\nthroughout the context, pointing at the dump file as if it were a source\nfile, giving you @emph{something} you can step through in the debugger.\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Compiling a context,ABI and API compatibility,Source Locations,Topic Reference\n@anchor{topics/compilation compiling-a-context}@anchor{e0}@anchor{topics/compilation doc}@anchor{e1}\n@section Compiling a context\n\n\nOnce populated, a @pxref{8,,gcc_jit_context *} can be compiled to\nmachine code, either in-memory via @pxref{15,,gcc_jit_context_compile()} or\nto disk via @pxref{4a,,gcc_jit_context_compile_to_file()}.\n\nYou can compile a context multiple times (using either form of\ncompilation), although any errors that occur on the context will\nprevent any future compilation of that context.\n\n@menu\n* In-memory compilation:: \n* Ahead-of-time compilation:: \n\n@end menu\n\n@node In-memory compilation,Ahead-of-time compilation,,Compiling a context\n@anchor{topics/compilation in-memory-compilation}@anchor{e2}\n@subsection In-memory compilation\n\n\n@geindex gcc_jit_context_compile (C function)\n@anchor{topics/compilation gcc_jit_context_compile}@anchor{15}\n@deffn {C Function} gcc_jit_result *           gcc_jit_context_compile (gcc_jit_context@w{ }*ctxt)\n\nThis calls into GCC and builds the code, returning a\n@cite{gcc_jit_result *}.\n\nIf the result is non-NULL, the caller becomes responsible for\ncalling @pxref{39,,gcc_jit_result_release()} on it once they're done\nwith it.\n@end deffn\n\n@geindex gcc_jit_result (C type)\n@anchor{topics/compilation gcc_jit_result}@anchor{16}\n@deffn {C Type} gcc_jit_result\n\nA @cite{gcc_jit_result} encapsulates the result of compiling a context\nin-memory, and the lifetimes of any machine code functions or globals\nthat are within the result.\n@end deffn\n\n@geindex gcc_jit_result_get_code (C function)\n@anchor{topics/compilation gcc_jit_result_get_code}@anchor{17}\n@deffn {C Function} void *           gcc_jit_result_get_code (gcc_jit_result@w{ }*result, const char@w{ }*funcname)\n\nLocate a given function within the built machine code.\n\nFunctions are looked up by name.  For this to succeed, a function\nwith a name matching @cite{funcname} must have been created on\n@cite{result}'s context (or a parent context) via a call to\n@pxref{11,,gcc_jit_context_new_function()} with @cite{kind}\n@pxref{c9,,GCC_JIT_FUNCTION_EXPORTED}:\n\n@example\ngcc_jit_context_new_function (ctxt,\n                              any_location, /* or NULL */\n                              /* Required for func to be visible to\n                                 gcc_jit_result_get_code: */\n                              GCC_JIT_FUNCTION_EXPORTED,\n                              any_return_type,\n                              /* Must string-compare equal: */\n                              funcname,\n                              /* etc */);\n@end example\n\n@noindent\n\nIf such a function is not found (or @cite{result} or @cite{funcname} are\n@code{NULL}), an error message will be emitted on stderr and\n@code{NULL} will be returned.\n\nIf the function is found, the result will need to be cast to a\nfunction pointer of the correct type before it can be called.\n\nNote that the resulting machine code becomes invalid after\n@pxref{39,,gcc_jit_result_release()} is called on the\n@pxref{16,,gcc_jit_result *}; attempting to call it after that may lead\nto a segmentation fault.\n@end deffn\n\n@geindex gcc_jit_result_get_global (C function)\n@anchor{topics/compilation gcc_jit_result_get_global}@anchor{b9}\n@deffn {C Function} void *           gcc_jit_result_get_global (gcc_jit_result@w{ }*result, const char@w{ }*name)\n\nLocate a given global within the built machine code.\n\nGlobals are looked up by name.  For this to succeed, a global\nwith a name matching @cite{name} must have been created on\n@cite{result}'s context (or a parent context) via a call to\n@pxref{b6,,gcc_jit_context_new_global()} with @cite{kind}\n@pxref{b8,,GCC_JIT_GLOBAL_EXPORTED}.\n\nIf the global is found, the result will need to be cast to a\npointer of the correct type before it can be called.\n\nThis is a @emph{pointer} to the global, so e.g. for an @code{int} this is\nan @code{int *}.\n\nFor example, given an @code{int foo;} created this way:\n\n@example\ngcc_jit_lvalue *exported_global =\n  gcc_jit_context_new_global (ctxt,\n  any_location, /* or NULL */\n  GCC_JIT_GLOBAL_EXPORTED,\n  int_type,\n  \"foo\");\n@end example\n\n@noindent\n\nwe can access it like this:\n\n@example\nint *ptr_to_foo =\n  (int *)gcc_jit_result_get_global (result, \"foo\");\n@end example\n\n@noindent\n\nIf such a global is not found (or @cite{result} or @cite{name} are\n@code{NULL}), an error message will be emitted on stderr and\n@code{NULL} will be returned.\n\nNote that the resulting address becomes invalid after\n@pxref{39,,gcc_jit_result_release()} is called on the\n@pxref{16,,gcc_jit_result *}; attempting to use it after that may lead\nto a segmentation fault.\n@end deffn\n\n@geindex gcc_jit_result_release (C function)\n@anchor{topics/compilation gcc_jit_result_release}@anchor{39}\n@deffn {C Function} void           gcc_jit_result_release (gcc_jit_result@w{ }*result)\n\nOnce we're done with the code, this unloads the built .so file.\nThis cleans up the result; after calling this, it's no longer\nvalid to use the result, or any code or globals that were obtained\nby calling @pxref{17,,gcc_jit_result_get_code()} or\n@pxref{b9,,gcc_jit_result_get_global()} on it.\n@end deffn\n\n@node Ahead-of-time compilation,,In-memory compilation,Compiling a context\n@anchor{topics/compilation ahead-of-time-compilation}@anchor{e3}\n@subsection Ahead-of-time compilation\n\n\nAlthough libgccjit is primarily aimed at just-in-time compilation, it\ncan also be used for implementing more traditional ahead-of-time\ncompilers, via the @pxref{4a,,gcc_jit_context_compile_to_file()}\nAPI entrypoint.\n\n@geindex gcc_jit_context_compile_to_file (C function)\n@anchor{topics/compilation gcc_jit_context_compile_to_file}@anchor{4a}\n@deffn {C Function} void            gcc_jit_context_compile_to_file (gcc_jit_context@w{ }*ctxt, enum gcc_jit_output_kind@w{ }output_kind, const char@w{ }*output_path)\n\nCompile the @pxref{8,,gcc_jit_context *} to a file of the given\nkind.\n@end deffn\n\n@pxref{4a,,gcc_jit_context_compile_to_file()} ignores the suffix of\n@code{output_path}, and insteads uses the given\n@code{enum gcc_jit_output_kind} to decide what to do.\n\n@cartouche\n@quotation Note \nThis is different from the @code{gcc} program, which does make use of the\nsuffix of the output file when determining what to do.\n@end quotation\n@end cartouche\n\n@geindex gcc_jit_output_kind (C type)\n@anchor{topics/compilation gcc_jit_output_kind}@anchor{e4}\n@deffn {C Type} enum gcc_jit_output_kind\n@end deffn\n\nThe available kinds of output are:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxx} \n@headitem\n\nOutput kind\n\n@tab\n\nTypical suffix\n\n@item\n\n@pxref{e5,,GCC_JIT_OUTPUT_KIND_ASSEMBLER}\n\n@tab\n\n.s\n\n@item\n\n@pxref{e6,,GCC_JIT_OUTPUT_KIND_OBJECT_FILE}\n\n@tab\n\n.o\n\n@item\n\n@pxref{e7,,GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY}\n\n@tab\n\n.so or .dll\n\n@item\n\n@pxref{e8,,GCC_JIT_OUTPUT_KIND_EXECUTABLE}\n\n@tab\n\nNone, or .exe\n\n@end multitable\n\n\n@geindex GCC_JIT_OUTPUT_KIND_ASSEMBLER (C macro)\n@anchor{topics/compilation GCC_JIT_OUTPUT_KIND_ASSEMBLER}@anchor{e5}\n@deffn {C Macro} GCC_JIT_OUTPUT_KIND_ASSEMBLER\n\nCompile the context to an assembler file.\n@end deffn\n\n@geindex GCC_JIT_OUTPUT_KIND_OBJECT_FILE (C macro)\n@anchor{topics/compilation GCC_JIT_OUTPUT_KIND_OBJECT_FILE}@anchor{e6}\n@deffn {C Macro} GCC_JIT_OUTPUT_KIND_OBJECT_FILE\n\nCompile the context to an object file.\n@end deffn\n\n@geindex GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY (C macro)\n@anchor{topics/compilation GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY}@anchor{e7}\n@deffn {C Macro} GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY\n\nCompile the context to a dynamic library.\n\nThere is currently no support for specifying other libraries to link\nagainst.\n@end deffn\n\n@geindex GCC_JIT_OUTPUT_KIND_EXECUTABLE (C macro)\n@anchor{topics/compilation GCC_JIT_OUTPUT_KIND_EXECUTABLE}@anchor{e8}\n@deffn {C Macro} GCC_JIT_OUTPUT_KIND_EXECUTABLE\n\nCompile the context to an executable.\n\nThere is currently no support for specifying libraries to link\nagainst.\n@end deffn\n\n@c Copyright (C) 2015-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node ABI and API compatibility,Performance,Compiling a context,Topic Reference\n@anchor{topics/compatibility abi-and-api-compatibility}@anchor{e9}@anchor{topics/compatibility doc}@anchor{ea}\n@section ABI and API compatibility\n\n\nThe libgccjit developers strive for ABI and API backward-compatibility:\nprograms built against libgccjit.so stand a good chance of running\nwithout recompilation against newer versions of libgccjit.so, and\nought to recompile without modification against newer versions of\nlibgccjit.h.\n\n@cartouche\n@quotation Note \nThe libgccjit++.h C++ API is more experimental, and less\nlocked-down at this time.\n@end quotation\n@end cartouche\n\nAPI compatibility is achieved by extending the API rather than changing\nit.  For ABI compatiblity, we avoid bumping the SONAME, and instead use\nsymbol versioning to tag each symbol, so that a binary linked against\nlibgccjit.so is tagged according to the symbols that it uses.\n\nFor example, @pxref{72,,gcc_jit_context_add_command_line_option()} was added in\n@code{LIBGCCJIT_ABI_1}.  If a client program uses it, this can be detected\nfrom metadata by using @code{objdump}:\n\n@example\n$ objdump -p testsuite/jit/test-extra-options.c.exe | tail -n 8\n\nVersion References:\n  required from libgccjit.so.0:\n    0x00824161 0x00 04 LIBGCCJIT_ABI_1\n    0x00824160 0x00 03 LIBGCCJIT_ABI_0\n  required from libc.so.6:\n@end example\n\n@noindent\n\nYou can see the symbol tags provided by libgccjit.so using @code{objdump}:\n\n@example\n$ objdump -p libgccjit.so | less\n[...snip...]\nVersion definitions:\n1 0x01 0x0ff81f20 libgccjit.so.0\n2 0x00 0x00824160 LIBGCCJIT_ABI_0\n3 0x00 0x00824161 LIBGCCJIT_ABI_1\n        LIBGCCJIT_ABI_0\n[...snip...]\n@end example\n\n@noindent\n\n@menu\n* ABI symbol tags:: \n\nABI symbol tags\n\n* LIBGCCJIT_ABI_0:: \n* LIBGCCJIT_ABI_1:: \n* LIBGCCJIT_ABI_2:: \n* LIBGCCJIT_ABI_3:: \n* LIBGCCJIT_ABI_4:: \n* LIBGCCJIT_ABI_5:: \n\n@end menu\n\n\n@node ABI symbol tags,,,ABI and API compatibility\n@anchor{topics/compatibility abi-symbol-tags}@anchor{eb}\n@subsection ABI symbol tags\n\n\nThe initial release of libgccjit (in gcc 5.1) did not use symbol versioning.\n\nNewer releases use the following tags.\n\n@menu\n* LIBGCCJIT_ABI_0:: \n* LIBGCCJIT_ABI_1:: \n* LIBGCCJIT_ABI_2:: \n* LIBGCCJIT_ABI_3:: \n* LIBGCCJIT_ABI_4:: \n* LIBGCCJIT_ABI_5:: \n\n@end menu\n\n@node LIBGCCJIT_ABI_0,LIBGCCJIT_ABI_1,,ABI symbol tags\n@anchor{topics/compatibility libgccjit-abi-0}@anchor{ec}@anchor{topics/compatibility id1}@anchor{ed}\n@subsubsection @code{LIBGCCJIT_ABI_0}\n\n\nAll entrypoints in the initial release of libgccjit are tagged with\n@code{LIBGCCJIT_ABI_0}, to signify the transition to symbol versioning.\n\nBinaries built against older copies of @code{libgccjit.so} should\ncontinue to work, with this being handled transparently by the linker\n(see this post@footnote{https://gcc.gnu.org/ml/gcc-patches/2015-06/msg02126.html})\n\n@node LIBGCCJIT_ABI_1,LIBGCCJIT_ABI_2,LIBGCCJIT_ABI_0,ABI symbol tags\n@anchor{topics/compatibility libgccjit-abi-1}@anchor{73}@anchor{topics/compatibility id2}@anchor{ee}\n@subsubsection @code{LIBGCCJIT_ABI_1}\n\n\n@code{LIBGCCJIT_ABI_1} covers the addition of\n@pxref{72,,gcc_jit_context_add_command_line_option()}\n\n@node LIBGCCJIT_ABI_2,LIBGCCJIT_ABI_3,LIBGCCJIT_ABI_1,ABI symbol tags\n@anchor{topics/compatibility libgccjit-abi-2}@anchor{6c}@anchor{topics/compatibility id3}@anchor{ef}\n@subsubsection @code{LIBGCCJIT_ABI_2}\n\n\n@code{LIBGCCJIT_ABI_2} covers the addition of\n@pxref{6b,,gcc_jit_context_set_bool_allow_unreachable_blocks()}\n\n@node LIBGCCJIT_ABI_3,LIBGCCJIT_ABI_4,LIBGCCJIT_ABI_2,ABI symbol tags\n@anchor{topics/compatibility libgccjit-abi-3}@anchor{db}@anchor{topics/compatibility id4}@anchor{f0}\n@subsubsection @code{LIBGCCJIT_ABI_3}\n\n\n@code{LIBGCCJIT_ABI_3} covers the addition of switch statements via API\nentrypoints:\n\n@quotation\n\n\n@itemize *\n\n@item \n@pxref{d8,,gcc_jit_block_end_with_switch()}\n\n@item \n@pxref{d9,,gcc_jit_case_as_object()}\n\n@item \n@pxref{da,,gcc_jit_context_new_case()}\n@end itemize\n@end quotation\n\n@node LIBGCCJIT_ABI_4,LIBGCCJIT_ABI_5,LIBGCCJIT_ABI_3,ABI symbol tags\n@anchor{topics/compatibility id5}@anchor{f1}@anchor{topics/compatibility libgccjit-abi-4}@anchor{f2}\n@subsubsection @code{LIBGCCJIT_ABI_4}\n\n\n@code{LIBGCCJIT_ABI_4} covers the addition of timers via API\nentrypoints:\n\n@quotation\n\n\n@itemize *\n\n@item \n@pxref{f3,,gcc_jit_context_get_timer()}\n\n@item \n@pxref{f4,,gcc_jit_context_set_timer()}\n\n@item \n@pxref{f5,,gcc_jit_timer_new()}\n\n@item \n@pxref{f6,,gcc_jit_timer_release()}\n\n@item \n@pxref{f7,,gcc_jit_timer_push()}\n\n@item \n@pxref{f8,,gcc_jit_timer_pop()}\n\n@item \n@pxref{f9,,gcc_jit_timer_print()}\n@end itemize\n@end quotation\n\n@node LIBGCCJIT_ABI_5,,LIBGCCJIT_ABI_4,ABI symbol tags\n@anchor{topics/compatibility id6}@anchor{fa}@anchor{topics/compatibility libgccjit-abi-5}@anchor{6e}\n@subsubsection @code{LIBGCCJIT_ABI_5}\n\n\n@code{LIBGCCJIT_ABI_5} covers the addition of\n@pxref{6d,,gcc_jit_context_set_bool_use_external_driver()}\n\n@c Copyright (C) 2015-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Performance,,ABI and API compatibility,Topic Reference\n@anchor{topics/performance performance}@anchor{fb}@anchor{topics/performance doc}@anchor{fc}\n@section Performance\n\n\n@menu\n* The timing API:: \n\n@end menu\n\n@node The timing API,,,Performance\n@anchor{topics/performance the-timing-api}@anchor{fd}\n@subsection The timing API\n\n\nAs of GCC 6, libgccjit exposes a timing API, for printing reports on\nhow long was spent in different parts of code.\n\nYou can create a @pxref{fe,,gcc_jit_timer} instance, which will\nmeasure time spent since its creation.  The timer maintains a stack\nof \"timer items\": as control flow moves through your code, you can push\nand pop named items relating to your code onto the stack, and the timer\nwill account the time spent accordingly.\n\nYou can also asssociate a timer with a @pxref{8,,gcc_jit_context}, in\nwhich case the time spent inside compilation will be subdivided.\n\nFor example, the following code uses a timer, recording client items\n\"create_code\", \"compile\", and \"running code\":\n\n@example\n/* Create a timer.  */\ngcc_jit_timer *timer = gcc_jit_timer_new ();\nif (!timer)\n  @{\n     error (\"gcc_jit_timer_new failed\");\n     return -1;\n  @}\n\n/* Let's repeatedly compile and run some code, accumulating it\n   all into the timer.  */\nfor (int i = 0; i < num_iterations; i++)\n  @{\n    /* Create a context and associate it with the timer.  */\n    gcc_jit_context *ctxt = gcc_jit_context_acquire ();\n    if (!ctxt)\n      @{\n        error (\"gcc_jit_context_acquire failed\");\n        return -1;\n      @}\n    gcc_jit_context_set_timer (ctxt, timer);\n\n    /* Populate the context, timing it as client item \"create_code\".  */\n    gcc_jit_timer_push (timer, \"create_code\");\n    create_code (ctxt);\n    gcc_jit_timer_pop (timer, \"create_code\");\n\n    /* Compile the context, timing it as client item \"compile\".  */\n    gcc_jit_timer_push (timer, \"compile\");\n    result = gcc_jit_context_compile (ctxt);\n    gcc_jit_timer_pop (timer, \"compile\");\n\n    /* Run the generated code, timing it as client item \"running code\".  */\n    gcc_jit_timer_push (timer, \"running code\");\n    run_the_code (ctxt, result);\n    gcc_jit_timer_pop (timer, \"running code\");\n\n    /* Clean up.  */\n    gcc_jit_context_release (ctxt);\n    gcc_jit_result_release (result);\n@}\n\n/* Print the accumulated timings.  */\ngcc_jit_timer_print (timer, stderr);\ngcc_jit_timer_release (timer);\n@end example\n\n@noindent\n\ngiving output like this, showing the internal GCC items at the top, then\nclient items, then the total:\n\n@example\nExecution times (seconds)\nGCC items:\n phase setup             :   0.29 (14%) usr   0.00 ( 0%) sys   0.32 ( 5%) wall   10661 kB (50%) ggc\n phase parsing           :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     653 kB ( 3%) ggc\n phase finalize          :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n dump files              :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall       0 kB ( 0%) ggc\n callgraph construction  :   0.02 ( 1%) usr   0.01 ( 6%) sys   0.01 ( 0%) wall     242 kB ( 1%) ggc\n callgraph optimization  :   0.03 ( 2%) usr   0.00 ( 0%) sys   0.02 ( 0%) wall     142 kB ( 1%) ggc\n trivially dead code     :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n df scan insns           :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       9 kB ( 0%) ggc\n df live regs            :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall       0 kB ( 0%) ggc\n inline parameters       :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall      82 kB ( 0%) ggc\n tree CFG cleanup        :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n tree PHI insertion      :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.02 ( 0%) wall      64 kB ( 0%) ggc\n tree SSA other          :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.01 ( 0%) wall      18 kB ( 0%) ggc\n expand                  :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     398 kB ( 2%) ggc\n jump                    :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n loop init               :   0.01 ( 0%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall      67 kB ( 0%) ggc\n integrated RA           :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall    2468 kB (12%) ggc\n thread pro- & epilogue  :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     162 kB ( 1%) ggc\n final                   :   0.01 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall     216 kB ( 1%) ggc\n rest of compilation     :   1.37 (69%) usr   0.00 ( 0%) sys   1.13 (18%) wall    1391 kB ( 6%) ggc\n assemble JIT code       :   0.01 ( 1%) usr   0.00 ( 0%) sys   4.04 (66%) wall       0 kB ( 0%) ggc\n load JIT result         :   0.02 ( 1%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n JIT client code         :   0.00 ( 0%) usr   0.01 ( 6%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\nClient items:\n create_code             :   0.00 ( 0%) usr   0.01 ( 6%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n compile                 :   0.36 (18%) usr   0.15 (83%) sys   0.86 (14%) wall   14939 kB (70%) ggc\n running code            :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc\n TOTAL                   :   2.00             0.18             6.12              21444 kB\n@end example\n\n@noindent\n\nThe exact format is intended to be human-readable, and is subject to change.\n\n@geindex LIBGCCJIT_HAVE_TIMING_API (C macro)\n@anchor{topics/performance LIBGCCJIT_HAVE_TIMING_API}@anchor{ff}\n@deffn {C Macro} LIBGCCJIT_HAVE_TIMING_API\n\nThe timer API was added to libgccjit in GCC 6.\nThis macro is only defined in versions of libgccjit.h which have the\ntimer API, and so can be used to guard code that may need to compile\nagainst earlier releases:\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\ngcc_jit_timer *t = gcc_jit_timer_new ();\ngcc_jit_context_set_timer (ctxt, t);\n#endif\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_timer (C type)\n@anchor{topics/performance gcc_jit_timer}@anchor{fe}\n@deffn {C Type} gcc_jit_timer\n@end deffn\n\n@geindex gcc_jit_timer_new (C function)\n@anchor{topics/performance gcc_jit_timer_new}@anchor{f5}\n@deffn {C Function} gcc_jit_timer * gcc_jit_timer_new (void)\n\nCreate a @pxref{fe,,gcc_jit_timer} instance, and start timing:\n\n@example\ngcc_jit_timer *t = gcc_jit_timer_new ();\n@end example\n\n@noindent\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_timer_release (C function)\n@anchor{topics/performance gcc_jit_timer_release}@anchor{f6}\n@deffn {C Function} void gcc_jit_timer_release (gcc_jit_timer@w{ }*timer)\n\nRelease a @pxref{fe,,gcc_jit_timer} instance:\n\n@example\ngcc_jit_timer_release (t);\n@end example\n\n@noindent\n\nThis should be called exactly once on a timer.\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_set_timer (C function)\n@anchor{topics/performance gcc_jit_context_set_timer}@anchor{f4}\n@deffn {C Function} void gcc_jit_context_set_timer (gcc_jit_context@w{ }*ctxt, gcc_jit_timer@w{ }*timer)\n\nAssociate a @pxref{fe,,gcc_jit_timer} instance with a context:\n\n@example\ngcc_jit_context_set_timer (ctxt, t);\n@end example\n\n@noindent\n\nA timer instance can be shared between multiple\n@pxref{8,,gcc_jit_context} instances.\n\nTimers have no locking, so if you have a multithreaded program, you\nmust provide your own locks if more than one thread could be working\nwith the same timer via timer-associated contexts.\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_context_get_timer (C function)\n@anchor{topics/performance gcc_jit_context_get_timer}@anchor{f3}\n@deffn {C Function} gcc_jit_timer *gcc_jit_context_get_timer (gcc_jit_context@w{ }*ctxt)\n\nGet the timer associated with a context (if any).\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_timer_push (C function)\n@anchor{topics/performance gcc_jit_timer_push}@anchor{f7}\n@deffn {C Function} void gcc_jit_timer_push (gcc_jit_timer@w{ }*timer, const char@w{ }*item_name)\n\nPush the given item onto the timer's stack:\n\n@example\ngcc_jit_timer_push (t, \"running code\");\nrun_the_code (ctxt, result);\ngcc_jit_timer_pop (t, \"running code\");\n@end example\n\n@noindent\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_timer_pop (C function)\n@anchor{topics/performance gcc_jit_timer_pop}@anchor{f8}\n@deffn {C Function} void gcc_jit_timer_pop (gcc_jit_timer@w{ }*timer, const char@w{ }*item_name)\n\nPop the top item from the timer's stack.\n\nIf \"item_name\" is provided, it must match that of the top item.\nAlternatively, @code{NULL} can be passed in, to suppress checking.\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@geindex gcc_jit_timer_print (C function)\n@anchor{topics/performance gcc_jit_timer_print}@anchor{f9}\n@deffn {C Function} void gcc_jit_timer_print (gcc_jit_timer@w{ }*timer, FILE@w{ }*f_out)\n\nPrint timing information to the given stream about activity since\nthe timer was started.\n\nThis API entrypoint was added in @pxref{f2,,LIBGCCJIT_ABI_4}; you can test\nfor its presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_TIMING_API\n@end example\n\n@noindent\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node C++ bindings for libgccjit,Internals,Topic Reference,Top\n@anchor{cp/index c-bindings-for-libgccjit}@anchor{100}@anchor{cp/index doc}@anchor{101}\n@chapter C++ bindings for libgccjit\n\n\nThis document describes the C++ bindings to\nlibgccjit@footnote{http://gcc.gnu.org/wiki/JIT}, an API for embedding GCC\ninside programs and libraries.\n\nThe C++ bindings consist of a single header file @code{libgccjit++.h}.\n\nThis is a collection of \"thin\" wrapper classes around the C API.\nEverything is an inline function, implemented in terms of the C API,\nso there is nothing extra to link against.\n\nNote that libgccjit is currently of \"Alpha\" quality;\nthe APIs are not yet set in stone, and they shouldn't be used in\nproduction yet.\n\nContents:\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Tutorial: Tutorial<2>. \n* Topic Reference: Topic Reference<2>. \n\nTutorial\n\n* Tutorial part 1; \"Hello world\": Tutorial part 1 \"Hello world\"<2>. \n* Tutorial part 2; Creating a trivial machine code function: Tutorial part 2 Creating a trivial machine code function<2>. \n* Tutorial part 3; Loops and variables: Tutorial part 3 Loops and variables<2>. \n* Tutorial part 4; Adding JIT-compilation to a toy interpreter: Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>. \n\nTutorial part 2: Creating a trivial machine code function\n\n* Options: Options<3>. \n* Full example: Full example<3>. \n\nTutorial part 3: Loops and variables\n\n* Expressions; lvalues and rvalues: Expressions lvalues and rvalues<2>. \n* Control flow: Control flow<2>. \n* Visualizing the control flow graph: Visualizing the control flow graph<2>. \n* Full example: Full example<4>. \n\nTutorial part 4: Adding JIT-compilation to a toy interpreter\n\n* Our toy interpreter: Our toy interpreter<2>. \n* Compiling to machine code: Compiling to machine code<2>. \n* Setting things up: Setting things up<2>. \n* Populating the function: Populating the function<2>. \n* Verifying the control flow graph: Verifying the control flow graph<2>. \n* Compiling the context: Compiling the context<2>. \n* Single-stepping through the generated code: Single-stepping through the generated code<2>. \n* Examining the generated code: Examining the generated code<2>. \n* Putting it all together: Putting it all together<2>. \n* Behind the curtain; How does our code get optimized?: Behind the curtain How does our code get optimized?<2>. \n\nBehind the curtain: How does our code get optimized?\n\n* Optimizing away stack manipulation: Optimizing away stack manipulation<2>. \n* Elimination of tail recursion: Elimination of tail recursion<2>. \n\nTopic Reference\n\n* Compilation contexts: Compilation contexts<2>. \n* Objects: Objects<2>. \n* Types: Types<2>. \n* Expressions: Expressions<2>. \n* Creating and using functions: Creating and using functions<2>. \n* Source Locations: Source Locations<2>. \n* Compiling a context: Compiling a context<2>. \n\nCompilation contexts\n\n* Lifetime-management: Lifetime-management<2>. \n* Thread-safety: Thread-safety<2>. \n* Error-handling: Error-handling<3>. \n* Debugging: Debugging<2>. \n* Options: Options<4>. \n\nOptions\n\n* String Options: String Options<2>. \n* Boolean options: Boolean options<2>. \n* Integer options: Integer options<2>. \n* Additional command-line options: Additional command-line options<2>. \n\nTypes\n\n* Standard types: Standard types<2>. \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile<2>. \n* Structures and unions: Structures and unions<2>. \n\nExpressions\n\n* Rvalues: Rvalues<2>. \n* Lvalues: Lvalues<2>. \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions<2>. \n\nRvalues\n\n* Simple expressions: Simple expressions<2>. \n* Unary Operations: Unary Operations<2>. \n* Binary Operations: Binary Operations<2>. \n* Comparisons: Comparisons<2>. \n* Function calls: Function calls<2>. \n* Type-coercion: Type-coercion<2>. \n\nLvalues\n\n* Global variables: Global variables<2>. \n\nCreating and using functions\n\n* Params: Params<2>. \n* Functions: Functions<2>. \n* Blocks: Blocks<2>. \n* Statements: Statements<2>. \n\nSource Locations\n\n* Faking it: Faking it<2>. \n\nCompiling a context\n\n* In-memory compilation: In-memory compilation<2>. \n* Ahead-of-time compilation: Ahead-of-time compilation<2>. \n\n@end menu\n\n\n@node Tutorial<2>,Topic Reference<2>,,C++ bindings for libgccjit\n@anchor{cp/intro/index doc}@anchor{102}@anchor{cp/intro/index tutorial}@anchor{103}\n@section Tutorial\n\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Tutorial part 1; \"Hello world\": Tutorial part 1 \"Hello world\"<2>. \n* Tutorial part 2; Creating a trivial machine code function: Tutorial part 2 Creating a trivial machine code function<2>. \n* Tutorial part 3; Loops and variables: Tutorial part 3 Loops and variables<2>. \n* Tutorial part 4; Adding JIT-compilation to a toy interpreter: Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>. \n\n@end menu\n\n@node Tutorial part 1 \"Hello world\"<2>,Tutorial part 2 Creating a trivial machine code function<2>,,Tutorial<2>\n@anchor{cp/intro/tutorial01 doc}@anchor{104}@anchor{cp/intro/tutorial01 tutorial-part-1-hello-world}@anchor{105}\n@subsection Tutorial part 1: \"Hello world\"\n\n\nBefore we look at the details of the API, let's look at building and\nrunning programs that use the library.\n\nHere's a toy \"hello world\" program that uses the library's C++ API to\nsynthesize a call to @cite{printf} and uses it to write a message to stdout.\n\nDon't worry about the content of the program for now; we'll cover\nthe details in later parts of this tutorial.\n\n@quotation\n\n@example\n/* Smoketest example for libgccjit.so C++ API\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit++.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void\ncreate_code (gccjit::context ctxt)\n@{\n  /* Let's try to inject the equivalent of this C code:\n     void\n     greet (const char *name)\n     @{\n        printf (\"hello %s\\n\", name);\n     @}\n  */\n  gccjit::type void_type = ctxt.get_type (GCC_JIT_TYPE_VOID);\n  gccjit::type const_char_ptr_type =\n    ctxt.get_type (GCC_JIT_TYPE_CONST_CHAR_PTR);\n  gccjit::param param_name =\n    ctxt.new_param (const_char_ptr_type, \"name\");\n  std::vector<gccjit::param> func_params;\n  func_params.push_back (param_name);\n  gccjit::function func =\n    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                       void_type,\n                       \"greet\",\n                       func_params, 0);\n\n  gccjit::param param_format =\n    ctxt.new_param (const_char_ptr_type, \"format\");\n  std::vector<gccjit::param> printf_params;\n  printf_params.push_back (param_format);\n  gccjit::function printf_func =\n    ctxt.new_function (GCC_JIT_FUNCTION_IMPORTED,\n                       ctxt.get_type (GCC_JIT_TYPE_INT),\n                       \"printf\",\n                       printf_params, 1);\n\n  gccjit::block block = func.new_block ();\n  block.add_eval (ctxt.new_call (printf_func,\n                                 ctxt.new_rvalue (\"hello %s\\n\"),\n                                 param_name));\n  block.end_with_return ();\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  gccjit::context ctxt;\n  gcc_jit_result *result;\n\n  /* Get a \"context\" object for working with the library.  */\n  ctxt = gccjit::context::acquire ();\n\n  /* Set some options on the context.\n     Turn this on to see the code being generated, in assembler form.  */\n  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  result = ctxt.compile ();\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      exit (1);\n    @}\n\n  ctxt.release ();\n\n  /* Extract the generated code from \"result\".  */\n  typedef void (*fn_type) (const char *);\n  fn_type greet =\n    (fn_type)gcc_jit_result_get_code (result, \"greet\");\n  if (!greet)\n    @{\n      fprintf (stderr, \"NULL greet\");\n      exit (1);\n    @}\n\n  /* Now call the generated function: */\n  greet (\"world\");\n  fflush (stdout);\n\n  gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nCopy the above to @cite{tut01-hello-world.cc}.\n\nAssuming you have the jit library installed, build the test program\nusing:\n\n@example\n$ gcc \\\n    tut01-hello-world.cc \\\n    -o tut01-hello-world \\\n    -lgccjit\n@end example\n\n@noindent\n\nYou should then be able to run the built program:\n\n@example\n$ ./tut01-hello-world\nhello world\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 2 Creating a trivial machine code function<2>,Tutorial part 3 Loops and variables<2>,Tutorial part 1 \"Hello world\"<2>,Tutorial<2>\n@anchor{cp/intro/tutorial02 doc}@anchor{106}@anchor{cp/intro/tutorial02 tutorial-part-2-creating-a-trivial-machine-code-function}@anchor{107}\n@subsection Tutorial part 2: Creating a trivial machine code function\n\n\nConsider this C function:\n\n@example\nint square (int i)\n@{\n  return i * i;\n@}\n@end example\n\n@noindent\n\nHow can we construct this at run-time using libgccjit's C++ API?\n\nFirst we need to include the relevant header:\n\n@example\n#include <libgccjit++.h>\n@end example\n\n@noindent\n\nAll state associated with compilation is associated with a\n@code{gccjit::context}, which is a thin C++ wrapper around the C API's\n@pxref{8,,gcc_jit_context *}.\n\nCreate one using @pxref{108,,gccjit;;context;;acquire()}:\n\n@example\ngccjit::context ctxt;\nctxt = gccjit::context::acquire ();\n@end example\n\n@noindent\n\nThe JIT library has a system of types.  It is statically-typed: every\nexpression is of a specific type, fixed at compile-time.  In our example,\nall of the expressions are of the C @cite{int} type, so let's obtain this from\nthe context, as a @code{gccjit::type}, using\n@pxref{109,,gccjit;;context;;get_type()}:\n\n@example\ngccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n@end example\n\n@noindent\n\n@code{gccjit::type} is an example of a \"contextual\" object: every\nentity in the API is associated with a @code{gccjit::context}.\n\nMemory management is easy: all such \"contextual\" objects are automatically\ncleaned up for you when the context is released, using\n@pxref{10a,,gccjit;;context;;release()}:\n\n@example\nctxt.release ();\n@end example\n\n@noindent\n\nso you don't need to manually track and cleanup all objects, just the\ncontexts.\n\nAll of the C++ classes in the API are thin wrappers around pointers to\ntypes in the C API.\n\nThe C++ class hierarchy within the @code{gccjit} namespace looks like this:\n\n@example\n+- object\n    +- location\n    +- type\n       +- struct\n    +- field\n    +- function\n    +- block\n    +- rvalue\n        +- lvalue\n           +- param\n@end example\n\n@noindent\n\nOne thing you can do with a @code{gccjit::object} is\nto ask it for a human-readable description as a @code{std::string}, using\n@pxref{10b,,gccjit;;object;;get_debug_string()}:\n\n@example\nprintf (\"obj: %s\\n\", obj.get_debug_string ().c_str ());\n@end example\n\n@noindent\n\ngiving this text on stdout:\n\n@example\nobj: int\n@end example\n\n@noindent\n\nThis is invaluable when debugging.\n\nLet's create the function.  To do so, we first need to construct\nits single parameter, specifying its type and giving it a name,\nusing @pxref{10c,,gccjit;;context;;new_param()}:\n\n@example\ngccjit::param param_i = ctxt.new_param (int_type, \"i\");\n@end example\n\n@noindent\n\nand we can then make a vector of all of the params of the function,\nin this case just one:\n\n@example\nstd::vector<gccjit::param> params;\nparams.push_back (param_i);\n@end example\n\n@noindent\n\nNow we can create the function, using\n@code{gccjit::context::new_function()}:\n\n@example\ngccjit::function func =\n  ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                     int_type,\n                     \"square\",\n                     params,\n                     0);\n@end example\n\n@noindent\n\nTo define the code within the function, we must create basic blocks\ncontaining statements.\n\nEvery basic block contains a list of statements, eventually terminated\nby a statement that either returns, or jumps to another basic block.\n\nOur function has no control-flow, so we just need one basic block:\n\n@example\ngccjit::block block = func.new_block ();\n@end example\n\n@noindent\n\nOur basic block is relatively simple: it immediately terminates by\nreturning the value of an expression.\n\nWe can build the expression using @pxref{10d,,gccjit;;context;;new_binary_op()}:\n\n@example\ngccjit::rvalue expr =\n  ctxt.new_binary_op (\n    GCC_JIT_BINARY_OP_MULT, int_type,\n    param_i, param_i);\n@end example\n\n@noindent\n\nA @code{gccjit::rvalue} is another example of a\n@code{gccjit::object} subclass.  As before, we can print it with\n@pxref{10b,,gccjit;;object;;get_debug_string()}.\n\n@example\nprintf (\"expr: %s\\n\", expr.get_debug_string ().c_str ());\n@end example\n\n@noindent\n\ngiving this output:\n\n@example\nexpr: i * i\n@end example\n\n@noindent\n\nNote that @code{gccjit::rvalue} provides numerous overloaded operators\nwhich can be used to dramatically reduce the amount of typing needed.\nWe can build the above binary operation more directly with this one-liner:\n\n@example\ngccjit::rvalue expr = param_i * param_i;\n@end example\n\n@noindent\n\nCreating the expression in itself doesn't do anything; we have to add\nthis expression to a statement within the block.  In this case, we use it\nto build a return statement, which terminates the basic block:\n\n@example\nblock.end_with_return (expr);\n@end example\n\n@noindent\n\nOK, we've populated the context.  We can now compile it using\n@pxref{10e,,gccjit;;context;;compile()}:\n\n@example\ngcc_jit_result *result;\nresult = ctxt.compile ();\n@end example\n\n@noindent\n\nand get a @pxref{16,,gcc_jit_result *}.\n\nWe can now use @pxref{17,,gcc_jit_result_get_code()} to look up a specific\nmachine code routine within the result, in this case, the function we\ncreated above.\n\n@example\nvoid *fn_ptr = gcc_jit_result_get_code (result, \"square\");\nif (!fn_ptr)\n  @{\n    fprintf (stderr, \"NULL fn_ptr\");\n    goto error;\n  @}\n@end example\n\n@noindent\n\nWe can now cast the pointer to an appropriate function pointer type, and\nthen call it:\n\n@example\ntypedef int (*fn_type) (int);\nfn_type square = (fn_type)fn_ptr;\nprintf (\"result: %d\", square (5));\n@end example\n\n@noindent\n\n@example\nresult: 25\n@end example\n\n@noindent\n\n@menu\n* Options: Options<3>. \n* Full example: Full example<3>. \n\n@end menu\n\n@node Options<3>,Full example<3>,,Tutorial part 2 Creating a trivial machine code function<2>\n@anchor{cp/intro/tutorial02 options}@anchor{10f}\n@subsubsection Options\n\n\nTo get more information on what's going on, you can set debugging flags\non the context using @pxref{110,,gccjit;;context;;set_bool_option()}.\n\n@c (I'm deliberately not mentioning\n@c :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE` here since I think\n@c it's probably more of use to implementors than to users)\n\nSetting @pxref{1c,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE} will dump a\nC-like representation to stderr when you compile (GCC's \"GIMPLE\"\nrepresentation):\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);\nresult = ctxt.compile ();\n@end example\n\n@noindent\n\n@example\nsquare (signed int i)\n@{\n  signed int D.260;\n\n  entry:\n  D.260 = i * i;\n  return D.260;\n@}\n@end example\n\n@noindent\n\nWe can see the generated machine code in assembler form (on stderr) by\nsetting @pxref{1d,,GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE} on the context\nbefore compiling:\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 1);\nresult = ctxt.compile ();\n@end example\n\n@noindent\n\n@example\n      .file   \"fake.c\"\n      .text\n      .globl  square\n      .type   square, @@function\nsquare:\n.LFB6:\n      .cfi_startproc\n      pushq   %rbp\n      .cfi_def_cfa_offset 16\n      .cfi_offset 6, -16\n      movq    %rsp, %rbp\n      .cfi_def_cfa_register 6\n      movl    %edi, -4(%rbp)\n.L14:\n      movl    -4(%rbp), %eax\n      imull   -4(%rbp), %eax\n      popq    %rbp\n      .cfi_def_cfa 7, 8\n      ret\n      .cfi_endproc\n.LFE6:\n      .size   square, .-square\n      .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n      .section       .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nBy default, no optimizations are performed, the equivalent of GCC's\n@cite{-O0} option.  We can turn things up to e.g. @cite{-O3} by calling\n@pxref{111,,gccjit;;context;;set_int_option()} with\n@pxref{1f,,GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL}:\n\n@example\nctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n@end example\n\n@noindent\n\n@example\n      .file   \"fake.c\"\n      .text\n      .p2align 4,,15\n      .globl  square\n      .type   square, @@function\nsquare:\n.LFB7:\n      .cfi_startproc\n.L16:\n      movl    %edi, %eax\n      imull   %edi, %eax\n      ret\n      .cfi_endproc\n.LFE7:\n      .size   square, .-square\n      .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n      .section        .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nNaturally this has only a small effect on such a trivial function.\n\n@node Full example<3>,,Options<3>,Tutorial part 2 Creating a trivial machine code function<2>\n@anchor{cp/intro/tutorial02 full-example}@anchor{112}\n@subsubsection Full example\n\n\nHere's what the above looks like as a complete program:\n\n@quotation\n\n@example\n/* Usage example for libgccjit.so's C++ API\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit++.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid\ncreate_code (gccjit::context ctxt)\n@{\n  /* Let's try to inject the equivalent of this C code:\n\n      int square (int i)\n      @{\n        return i * i;\n      @}\n  */\n  gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n  gccjit::param param_i = ctxt.new_param (int_type, \"i\");\n  std::vector<gccjit::param> params;\n  params.push_back (param_i);\n  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                                             int_type,\n                                             \"square\",\n                                             params, 0);\n\n  gccjit::block block = func.new_block ();\n\n  gccjit::rvalue expr =\n    ctxt.new_binary_op (GCC_JIT_BINARY_OP_MULT, int_type,\n                        param_i, param_i);\n\n  block.end_with_return (expr);\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  /* Get a \"context\" object for working with the library.  */\n  gccjit::context ctxt = gccjit::context::acquire ();\n\n  /* Set some options on the context.\n     Turn this on to see the code being generated, in assembler form.  */\n  ctxt.set_bool_option (\n    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n    0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  gcc_jit_result *result = ctxt.compile ();\n\n  /* We're done with the context; we can release it: */\n  ctxt.release ();\n\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      return 1;\n    @}\n\n  /* Extract the generated code from \"result\".  */\n  void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n  if (!fn_ptr)\n     @{\n       fprintf (stderr, \"NULL fn_ptr\");\n       gcc_jit_result_release (result);\n       return 1;\n     @}\n\n  typedef int (*fn_type) (int);\n  fn_type square = (fn_type)fn_ptr;\n  printf (\"result: %d\\n\", square (5));\n\n  gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nBuilding and running it:\n\n@example\n$ gcc \\\n    tut02-square.cc \\\n    -o tut02-square \\\n    -lgccjit\n\n# Run the built program:\n$ ./tut02-square\nresult: 25\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 3 Loops and variables<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>,Tutorial part 2 Creating a trivial machine code function<2>,Tutorial<2>\n@anchor{cp/intro/tutorial03 tutorial-part-3-loops-and-variables}@anchor{113}@anchor{cp/intro/tutorial03 doc}@anchor{114}\n@subsection Tutorial part 3: Loops and variables\n\n\nConsider this C function:\n\n@quotation\n\n@example\nint loop_test (int n)\n@{\n  int sum = 0;\n  for (int i = 0; i < n; i++)\n    sum += i * i;\n  return sum;\n@}\n@end example\n\n@noindent\n@end quotation\n\nThis example demonstrates some more features of libgccjit, with local\nvariables and a loop.\n\nTo break this down into libgccjit terms, it's usually easier to reword\nthe @cite{for} loop as a @cite{while} loop, giving:\n\n@quotation\n\n@example\nint loop_test (int n)\n@{\n  int sum = 0;\n  int i = 0;\n  while (i < n)\n  @{\n    sum += i * i;\n    i++;\n  @}\n  return sum;\n@}\n@end example\n\n@noindent\n@end quotation\n\nHere's what the final control flow graph will look like:\n\n@quotation\n\n\n@float Figure\n\n@image{sum-of-squares,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\nAs before, we include the libgccjit++ header and make a\n@code{gccjit::context}.\n\n@example\n#include <libgccjit++.h>\n\nvoid test (void)\n@{\n  gccjit::context ctxt;\n  ctxt = gccjit::context::acquire ();\n@end example\n\n@noindent\n\nThe function works with the C @cite{int} type.\n\nIn the previous tutorial we acquired this via\n\n@example\ngccjit::type the_type = ctxt.get_type (ctxt, GCC_JIT_TYPE_INT);\n@end example\n\n@noindent\n\nthough we could equally well make it work on, say, @cite{double}:\n\n@example\ngccjit::type the_type = ctxt.get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n@end example\n\n@noindent\n\nFor integer types we can use @code{gccjit::context::get_int_type}\nto directly bind a specific type:\n\n@example\ngccjit::type the_type = ctxt.get_int_type <int> ();\n@end example\n\n@noindent\n\nLet's build the function:\n\n@example\ngcc_jit_param n = ctxt.new_param (the_type, \"n\");\nstd::vector<gccjit::param> params;\nparams.push_back (n);\ngccjit::function func =\n  ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                     return_type,\n                     \"loop_test\",\n                     params, 0);\n@end example\n\n@noindent\n\n@menu\n* Expressions; lvalues and rvalues: Expressions lvalues and rvalues<2>. \n* Control flow: Control flow<2>. \n* Visualizing the control flow graph: Visualizing the control flow graph<2>. \n* Full example: Full example<4>. \n\n@end menu\n\n@node Expressions lvalues and rvalues<2>,Control flow<2>,,Tutorial part 3 Loops and variables<2>\n@anchor{cp/intro/tutorial03 expressions-lvalues-and-rvalues}@anchor{115}\n@subsubsection Expressions: lvalues and rvalues\n\n\nThe base class of expression is the @code{gccjit::rvalue},\nrepresenting an expression that can be on the @emph{right}-hand side of\nan assignment: a value that can be computed somehow, and assigned\n@emph{to} a storage area (such as a variable).  It has a specific\n@code{gccjit::type}.\n\nAnothe important class is @code{gccjit::lvalue}.\nA @code{gccjit::lvalue}. is something that can of the @emph{left}-hand\nside of an assignment: a storage area (such as a variable).\n\nIn other words, every assignment can be thought of as:\n\n@example\nLVALUE = RVALUE;\n@end example\n\n@noindent\n\nNote that @code{gccjit::lvalue} is a subclass of\n@code{gccjit::rvalue}, where in an assignment of the form:\n\n@example\nLVALUE_A = LVALUE_B;\n@end example\n\n@noindent\n\nthe @cite{LVALUE_B} implies reading the current value of that storage\narea, assigning it into the @cite{LVALUE_A}.\n\nSo far the only expressions we've seen are from the previous tutorial:\n\n\n@enumerate \n\n@item \nthe multiplication @cite{i * i}:\n@end enumerate\n\n@quotation\n\n@example\ngccjit::rvalue expr =\n  ctxt.new_binary_op (\n    GCC_JIT_BINARY_OP_MULT, int_type,\n    param_i, param_i);\n\n/* Alternatively, using operator-overloading: */\ngccjit::rvalue expr = param_i * param_i;\n@end example\n\n@noindent\n\nwhich is a @code{gccjit::rvalue}, and\n@end quotation\n\n\n@enumerate 2\n\n@item \nthe various function parameters: @cite{param_i} and @cite{param_n}, instances of\n@code{gccjit::param}, which is a subclass of @code{gccjit::lvalue}\n(and, in turn, of @code{gccjit::rvalue}):\nwe can both read from and write to function parameters within the\nbody of a function.\n@end enumerate\n\nOur new example has a new kind of expression: we have two local\nvariables.  We create them by calling\n@pxref{116,,gccjit;;function;;new_local()}, supplying a type and a name:\n\n@example\n/* Build locals:  */\ngccjit::lvalue i = func.new_local (the_type, \"i\");\ngccjit::lvalue sum = func.new_local (the_type, \"sum\");\n@end example\n\n@noindent\n\nThese are instances of @code{gccjit::lvalue} - they can be read from\nand written to.\n\nNote that there is no precanned way to create @emph{and} initialize a variable\nlike in C:\n\n@example\nint i = 0;\n@end example\n\n@noindent\n\nInstead, having added the local to the function, we have to separately add\nan assignment of @cite{0} to @cite{local_i} at the beginning of the function.\n\n@node Control flow<2>,Visualizing the control flow graph<2>,Expressions lvalues and rvalues<2>,Tutorial part 3 Loops and variables<2>\n@anchor{cp/intro/tutorial03 control-flow}@anchor{117}\n@subsubsection Control flow\n\n\nThis function has a loop, so we need to build some basic blocks to\nhandle the control flow.  In this case, we need 4 blocks:\n\n\n@enumerate \n\n@item \nbefore the loop (initializing the locals)\n\n@item \nthe conditional at the top of the loop (comparing @cite{i < n})\n\n@item \nthe body of the loop\n\n@item \nafter the loop terminates (@cite{return sum})\n@end enumerate\n\nso we create these as @code{gccjit::block} instances within the\n@code{gccjit::function}:\n\n@example\ngccjit::block b_initial = func.new_block (\"initial\");\ngccjit::block b_loop_cond = func.new_block (\"loop_cond\");\ngccjit::block b_loop_body = func.new_block (\"loop_body\");\ngccjit::block b_after_loop = func.new_block (\"after_loop\");\n@end example\n\n@noindent\n\nWe now populate each block with statements.\n\nThe entry block @cite{b_initial} consists of initializations followed by a jump\nto the conditional.  We assign @cite{0} to @cite{i} and to @cite{sum}, using\n@pxref{118,,gccjit;;block;;add_assignment()} to add\nan assignment statement, and using @pxref{119,,gccjit;;context;;zero()} to get\nthe constant value @cite{0} for the relevant type for the right-hand side of\nthe assignment:\n\n@example\n/* sum = 0; */\nb_initial.add_assignment (sum, ctxt.zero (the_type));\n\n/* i = 0; */\nb_initial.add_assignment (i, ctxt.zero (the_type));\n@end example\n\n@noindent\n\nWe can then terminate the entry block by jumping to the conditional:\n\n@example\nb_initial.end_with_jump (b_loop_cond);\n@end example\n\n@noindent\n\nThe conditional block is equivalent to the line @cite{while (i < n)} from our\nC example. It contains a single statement: a conditional, which jumps to\none of two destination blocks depending on a boolean\n@code{gccjit::rvalue}, in this case the comparison of @cite{i} and @cite{n}.\n\nWe could build the comparison using @pxref{11a,,gccjit;;context;;new_comparison()}:\n\n@example\ngccjit::rvalue guard =\n  ctxt.new_comparison (GCC_JIT_COMPARISON_GE,\n                       i, n);\n@end example\n\n@noindent\n\nand can then use this to add @cite{b_loop_cond}'s sole statement, via\n@pxref{11b,,gccjit;;block;;end_with_conditional()}:\n\n@example\nb_loop_cond.end_with_conditional (guard,\n                                  b_after_loop, // on_true\n                                  b_loop_body); // on_false\n@end example\n\n@noindent\n\nHowever @code{gccjit::rvalue} has overloaded operators for this, so we\nexpress the conditional as\n\n@example\ngccjit::rvalue guard = (i >= n);\n@end example\n\n@noindent\n\nand hence we can write the block more concisely as:\n\n@example\nb_loop_cond.end_with_conditional (\n  i >= n,\n  b_after_loop, // on_true\n  b_loop_body); // on_false\n@end example\n\n@noindent\n\nNext, we populate the body of the loop.\n\nThe C statement @cite{sum += i * i;} is an assignment operation, where an\nlvalue is modified \"in-place\".  We use\n@pxref{11c,,gccjit;;block;;add_assignment_op()} to handle these operations:\n\n@example\n/* sum += i * i */\nb_loop_body.add_assignment_op (sum,\n                               GCC_JIT_BINARY_OP_PLUS,\n                               i * i);\n@end example\n\n@noindent\n\nThe @cite{i++} can be thought of as @cite{i += 1}, and can thus be handled in\na similar way.  We use @pxref{2f,,gcc_jit_context_one()} to get the constant\nvalue @cite{1} (for the relevant type) for the right-hand side\nof the assignment.\n\n@example\n/* i++ */\nb_loop_body.add_assignment_op (i,\n                               GCC_JIT_BINARY_OP_PLUS,\n                               ctxt.one (the_type));\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nFor numeric constants other than 0 or 1, we could use\n@pxref{11d,,gccjit;;context;;new_rvalue()}, which has overloads\nfor both @code{int} and @code{double}.\n@end quotation\n@end cartouche\n\nThe loop body completes by jumping back to the conditional:\n\n@example\nb_loop_body.end_with_jump (b_loop_cond);\n@end example\n\n@noindent\n\nFinally, we populate the @cite{b_after_loop} block, reached when the loop\nconditional is false.  We want to generate the equivalent of:\n\n@example\nreturn sum;\n@end example\n\n@noindent\n\nso the block is just one statement:\n\n@example\n/* return sum */\nb_after_loop.end_with_return (sum);\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nYou can intermingle block creation with statement creation,\nbut given that the terminator statements generally include references\nto other blocks, I find it's clearer to create all the blocks,\n@emph{then} all the statements.\n@end quotation\n@end cartouche\n\nWe've finished populating the function.  As before, we can now compile it\nto machine code:\n\n@example\ngcc_jit_result *result;\nresult = ctxt.compile ();\n\nctxt.release ();\n\nif (!result)\n  @{\n    fprintf (stderr, \"NULL result\");\n    return 1;\n  @}\n\ntypedef int (*loop_test_fn_type) (int);\nloop_test_fn_type loop_test =\n (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\nif (!loop_test)\n  @{\n    fprintf (stderr, \"NULL loop_test\");\n    gcc_jit_result_release (result);\n    return 1;\n  @}\nprintf (\"result: %d\", loop_test (10));\n@end example\n\n@noindent\n\n@example\nresult: 285\n@end example\n\n@noindent\n\n@node Visualizing the control flow graph<2>,Full example<4>,Control flow<2>,Tutorial part 3 Loops and variables<2>\n@anchor{cp/intro/tutorial03 visualizing-the-control-flow-graph}@anchor{11e}\n@subsubsection Visualizing the control flow graph\n\n\nYou can see the control flow graph of a function using\n@pxref{11f,,gccjit;;function;;dump_to_dot()}:\n\n@example\nfunc.dump_to_dot (\"/tmp/sum-of-squares.dot\");\n@end example\n\n@noindent\n\ngiving a .dot file in GraphViz format.\n\nYou can convert this to an image using @cite{dot}:\n\n@example\n$ dot -Tpng /tmp/sum-of-squares.dot -o /tmp/sum-of-squares.png\n@end example\n\n@noindent\n\nor use a viewer (my preferred one is xdot.py; see\n@indicateurl{https://github.com/jrfonseca/xdot.py}; on Fedora you can\ninstall it with @cite{yum install python-xdot}):\n\n@quotation\n\n\n@float Figure\n\n@image{sum-of-squares,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\n@node Full example<4>,,Visualizing the control flow graph<2>,Tutorial part 3 Loops and variables<2>\n@anchor{cp/intro/tutorial03 full-example}@anchor{120}\n@subsubsection Full example\n\n\n@quotation\n\n@example\n/* Usage example for libgccjit.so's C++ API\n   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING3.  If not see\n<http://www.gnu.org/licenses/>.  */\n\n#include <libgccjit++.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid\ncreate_code (gccjit::context ctxt)\n@{\n  /*\n    Simple sum-of-squares, to test conditionals and looping\n\n    int loop_test (int n)\n    @{\n      int i;\n      int sum = 0;\n      for (i = 0; i < n ; i ++)\n      @{\n\tsum += i * i;\n      @}\n      return sum;\n   */\n  gccjit::type the_type = ctxt.get_int_type <int> ();\n  gccjit::type return_type = the_type;\n\n  gccjit::param n = ctxt.new_param (the_type, \"n\");\n  std::vector<gccjit::param> params;\n  params.push_back (n);\n  gccjit::function func =\n    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                       return_type,\n                       \"loop_test\",\n                       params, 0);\n\n  /* Build locals:  */\n  gccjit::lvalue i = func.new_local (the_type, \"i\");\n  gccjit::lvalue sum = func.new_local (the_type, \"sum\");\n\n  gccjit::block b_initial = func.new_block (\"initial\");\n  gccjit::block b_loop_cond = func.new_block (\"loop_cond\");\n  gccjit::block b_loop_body = func.new_block (\"loop_body\");\n  gccjit::block b_after_loop = func.new_block (\"after_loop\");\n\n  /* sum = 0; */\n  b_initial.add_assignment (sum, ctxt.zero (the_type));\n\n  /* i = 0; */\n  b_initial.add_assignment (i, ctxt.zero (the_type));\n\n  b_initial.end_with_jump (b_loop_cond);\n\n  /* if (i >= n) */\n  b_loop_cond.end_with_conditional (\n    i >= n,\n    b_after_loop,\n    b_loop_body);\n\n  /* sum += i * i */\n  b_loop_body.add_assignment_op (sum,\n                                 GCC_JIT_BINARY_OP_PLUS,\n                                 i * i);\n\n  /* i++ */\n  b_loop_body.add_assignment_op (i,\n                                GCC_JIT_BINARY_OP_PLUS,\n                                ctxt.one (the_type));\n\n  b_loop_body.end_with_jump (b_loop_cond);\n\n  /* return sum */\n  b_after_loop.end_with_return (sum);\n@}\n\nint\nmain (int argc, char **argv)\n@{\n  gccjit::context ctxt;\n  gcc_jit_result *result = NULL;\n\n  /* Get a \"context\" object for working with the library.  */\n  ctxt = gccjit::context::acquire ();\n\n  /* Set some options on the context.\n     Turn this on to see the code being generated, in assembler form.  */\n  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n                        0);\n\n  /* Populate the context.  */\n  create_code (ctxt);\n\n  /* Compile the code.  */\n  result = ctxt.compile ();\n\n  ctxt.release ();\n\n  if (!result)\n    @{\n      fprintf (stderr, \"NULL result\");\n      return 1;\n    @}\n\n  /* Extract the generated code from \"result\".  */\n  typedef int (*loop_test_fn_type) (int);\n  loop_test_fn_type loop_test =\n    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n  if (!loop_test)\n    @{\n      fprintf (stderr, \"NULL loop_test\");\n      gcc_jit_result_release (result);\n      return 1;\n    @}\n\n  /* Run the generated code.  */\n  int val = loop_test (10);\n  printf(\"loop_test returned: %d\\n\", val);\n\n  gcc_jit_result_release (result);\n  return 0;\n@}\n\n@end example\n\n@noindent\n@end quotation\n\nBuilding and running it:\n\n@example\n$ gcc \\\n    tut03-sum-of-squares.cc \\\n    -o tut03-sum-of-squares \\\n    -lgccjit\n\n# Run the built program:\n$ ./tut03-sum-of-squares\nloop_test returned: 285\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>,,Tutorial part 3 Loops and variables<2>,Tutorial<2>\n@anchor{cp/intro/tutorial04 tutorial-part-4-adding-jit-compilation-to-a-toy-interpreter}@anchor{121}@anchor{cp/intro/tutorial04 doc}@anchor{122}\n@subsection Tutorial part 4: Adding JIT-compilation to a toy interpreter\n\n\nIn this example we construct a \"toy\" interpreter, and add JIT-compilation\nto it.\n\n@menu\n* Our toy interpreter: Our toy interpreter<2>. \n* Compiling to machine code: Compiling to machine code<2>. \n* Setting things up: Setting things up<2>. \n* Populating the function: Populating the function<2>. \n* Verifying the control flow graph: Verifying the control flow graph<2>. \n* Compiling the context: Compiling the context<2>. \n* Single-stepping through the generated code: Single-stepping through the generated code<2>. \n* Examining the generated code: Examining the generated code<2>. \n* Putting it all together: Putting it all together<2>. \n* Behind the curtain; How does our code get optimized?: Behind the curtain How does our code get optimized?<2>. \n\n@end menu\n\n@node Our toy interpreter<2>,Compiling to machine code<2>,,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 our-toy-interpreter}@anchor{123}\n@subsubsection Our toy interpreter\n\n\nIt's a stack-based interpreter, and is intended as a (very simple) example\nof the kind of bytecode interpreter seen in dynamic languages such as\nPython, Ruby etc.\n\nFor the sake of simplicity, our toy virtual machine is very limited:\n\n@quotation\n\n\n@itemize *\n\n@item \nThe only data type is @cite{int}\n\n@item \nIt can only work on one function at a time (so that the only\nfunction call that can be made is to recurse).\n\n@item \nFunctions can only take one parameter.\n\n@item \nFunctions have a stack of @cite{int} values.\n\n@item \nWe'll implement function call within the interpreter by calling a\nfunction in our implementation, rather than implementing our own\nframe stack.\n\n@item \nThe parser is only good enough to get the examples to work.\n@end itemize\n@end quotation\n\nNaturally, a real interpreter would be much more complicated that this.\n\nThe following operations are supported:\n\n\n@multitable {xxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxx} \n@headitem\n\nOperation\n\n@tab\n\nMeaning\n\n@tab\n\nOld Stack\n\n@tab\n\nNew Stack\n\n@item\n\nDUP\n\n@tab\n\nDuplicate top of stack.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[..., x, x]}\n\n@item\n\nROT\n\n@tab\n\nSwap top two elements\nof stack.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., y, x]}\n\n@item\n\nBINARY_ADD\n\n@tab\n\nAdd the top two elements\non the stack.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x+y)]}\n\n@item\n\nBINARY_SUBTRACT\n\n@tab\n\nLikewise, but subtract.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x-y)]}\n\n@item\n\nBINARY_MULT\n\n@tab\n\nLikewise, but multiply.\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x*y)]}\n\n@item\n\nBINARY_COMPARE_LT\n\n@tab\n\nCompare the top two\nelements on the stack\nand push a nonzero/zero\nif (x<y).\n\n@tab\n\n@code{[..., x, y]}\n\n@tab\n\n@code{[..., (x<y)]}\n\n@item\n\nRECURSE\n\n@tab\n\nRecurse, passing the top\nof the stack, and\npopping the result.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[..., fn(x)]}\n\n@item\n\nRETURN\n\n@tab\n\nReturn the top of the\nstack.\n\n@tab\n\n@code{[x]}\n\n@tab\n\n@code{[]}\n\n@item\n\nPUSH_CONST @cite{arg}\n\n@tab\n\nPush an int const.\n\n@tab\n\n@code{[...]}\n\n@tab\n\n@code{[..., arg]}\n\n@item\n\nJUMP_ABS_IF_TRUE @cite{arg}\n\n@tab\n\nPop; if top of stack was\nnonzero, jump to\n@code{arg}.\n\n@tab\n\n@code{[..., x]}\n\n@tab\n\n@code{[...]}\n\n@end multitable\n\n\nPrograms can be interpreted, disassembled, and compiled to machine code.\n\nThe interpreter reads @code{.toy} scripts.  Here's what a simple recursive\nfactorial program looks like, the script @code{factorial.toy}.\nThe parser ignores lines beginning with a @cite{#}.\n\n@quotation\n\n@example\n# Simple recursive factorial implementation, roughly equivalent to:\n#\n#  int factorial (int arg)\n#  @{\n#     if (arg < 2)\n#       return arg\n#     return arg * factorial (arg - 1)\n#  @}\n\n# Initial state:\n# stack: [arg]\n\n# 0:\nDUP\n# stack: [arg, arg]\n\n# 1:\nPUSH_CONST 2\n# stack: [arg, arg, 2]\n\n# 2:\nBINARY_COMPARE_LT\n# stack: [arg, (arg < 2)]\n\n# 3:\nJUMP_ABS_IF_TRUE 9\n# stack: [arg]\n\n# 4:\nDUP\n# stack: [arg, arg]\n\n# 5:\nPUSH_CONST 1\n# stack: [arg, arg, 1]\n\n# 6:\nBINARY_SUBTRACT\n# stack: [arg,  (arg - 1)\n\n# 7:\nRECURSE\n# stack: [arg, factorial(arg - 1)]\n\n# 8:\nBINARY_MULT\n# stack: [arg * factorial(arg - 1)]\n\n# 9:\nRETURN\n\n@end example\n\n@noindent\n@end quotation\n\nThe interpreter is a simple infinite loop with a big @code{switch} statement\nbased on what the next opcode is:\n\n@quotation\n\n@example\n\nint\ntoyvm_function::interpret (int arg, FILE *trace)\n@{\n  toyvm_frame frame;\n#define PUSH(ARG) (frame.push (ARG))\n#define POP(ARG) (frame.pop ())\n\n  frame.frm_function = this;\n  frame.frm_pc = 0;\n  frame.frm_cur_depth = 0;\n\n  PUSH (arg);\n\n  while (1)\n    @{\n      toyvm_op *op;\n      int x, y;\n      assert (frame.frm_pc < fn_num_ops);\n      op = &fn_ops[frame.frm_pc++];\n\n      if (trace)\n\t@{\n\t  frame.dump_stack (trace);\n\t  disassemble_op (op, frame.frm_pc, trace);\n\t@}\n\n      switch (op->op_opcode)\n\t@{\n\t  /* Ops taking no operand.  */\n\tcase DUP:\n\t  x = POP ();\n\t  PUSH (x);\n\t  PUSH (x);\n\t  break;\n\n\tcase ROT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (y);\n\t  PUSH (x);\n\t  break;\n\n\tcase BINARY_ADD:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x + y);\n\t  break;\n\n\tcase BINARY_SUBTRACT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x - y);\n\t  break;\n\n\tcase BINARY_MULT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x * y);\n\t  break;\n\n\tcase BINARY_COMPARE_LT:\n\t  y = POP ();\n\t  x = POP ();\n\t  PUSH (x < y);\n\t  break;\n\n\tcase RECURSE:\n\t  x = POP ();\n\t  x = interpret (x, trace);\n\t  PUSH (x);\n\t  break;\n\n\tcase RETURN:\n\t  return POP ();\n\n\t  /* Ops taking an operand.  */\n\tcase PUSH_CONST:\n\t  PUSH (op->op_operand);\n\t  break;\n\n\tcase JUMP_ABS_IF_TRUE:\n\t  x = POP ();\n\t  if (x)\n\t    frame.frm_pc = op->op_operand;\n\t  break;\n\n\tdefault:\n\t  assert (0); /* unknown opcode */\n\n\t@} /* end of switch on opcode */\n    @} /* end of while loop */\n\n#undef PUSH\n#undef POP\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Compiling to machine code<2>,Setting things up<2>,Our toy interpreter<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 compiling-to-machine-code}@anchor{124}\n@subsubsection Compiling to machine code\n\n\nWe want to generate machine code that can be cast to this type and\nthen directly executed in-process:\n\n@quotation\n\n@example\ntypedef int (*toyvm_compiled_func) (int);\n\n\n@end example\n\n@noindent\n@end quotation\n\nOur compiler isn't very sophisticated; it takes the implementation of\neach opcode above, and maps it directly to the operations supported by\nthe libgccjit API.\n\nHow should we handle the stack?  In theory we could calculate what the\nstack depth will be at each opcode, and optimize away the stack\nmanipulation \"by hand\".  We'll see below that libgccjit is able to do\nthis for us, so we'll implement stack manipulation\nin a direct way, by creating a @code{stack} array and @code{stack_depth}\nvariables, local within the generated function, equivalent to this C code:\n\n@example\nint stack_depth;\nint stack[MAX_STACK_DEPTH];\n@end example\n\n@noindent\n\nWe'll also have local variables @code{x} and @code{y} for use when implementing\nthe opcodes, equivalent to this:\n\n@example\nint x;\nint y;\n@end example\n\n@noindent\n\nThis means our compiler has the following state:\n\n@quotation\n\n@example\n\n  toyvm_function &toyvmfn;\n\n  gccjit::context ctxt;\n\n  gccjit::type int_type;\n  gccjit::type bool_type;\n  gccjit::type stack_type; /* int[MAX_STACK_DEPTH] */\n\n  gccjit::rvalue const_one;\n\n  gccjit::function fn;\n  gccjit::param param_arg;\n  gccjit::lvalue stack;\n  gccjit::lvalue stack_depth;\n  gccjit::lvalue x;\n  gccjit::lvalue y;\n\n  gccjit::location op_locs[MAX_OPS];\n  gccjit::block initial_block;\n  gccjit::block op_blocks[MAX_OPS];\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Setting things up<2>,Populating the function<2>,Compiling to machine code<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 setting-things-up}@anchor{125}\n@subsubsection Setting things up\n\n\nFirst we create our types:\n\n@quotation\n\n@example\n\nvoid\ncompilation_state::create_types ()\n@{\n  /* Create types.  */\n  int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n  bool_type = ctxt.get_type (GCC_JIT_TYPE_BOOL);\n  stack_type = ctxt.new_array_type (int_type, MAX_STACK_DEPTH);\n\n\n@end example\n\n@noindent\n@end quotation\n\nalong with extracting a useful @cite{int} constant:\n\n@quotation\n\n@example\n  const_one = ctxt.one (int_type);\n\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe'll implement push and pop in terms of the @code{stack} array and\n@code{stack_depth}.  Here are helper functions for adding statements to\na block, implementing pushing and popping values:\n\n@quotation\n\n@example\n\nvoid\ncompilation_state::add_push (gccjit::block block,\n                             gccjit::rvalue rvalue,\n                             gccjit::location loc)\n@{\n  /* stack[stack_depth] = RVALUE */\n  block.add_assignment (\n    /* stack[stack_depth] */\n    ctxt.new_array_access (\n      stack,\n      stack_depth,\n      loc),\n    rvalue,\n    loc);\n\n  /* \"stack_depth++;\".  */\n  block.add_assignment_op (\n    stack_depth,\n    GCC_JIT_BINARY_OP_PLUS,\n    const_one,\n    loc);\n@}\n\nvoid\ncompilation_state::add_pop (gccjit::block block,\n                            gccjit::lvalue lvalue,\n                            gccjit::location loc)\n@{\n  /* \"--stack_depth;\".  */\n  block.add_assignment_op (\n    stack_depth,\n    GCC_JIT_BINARY_OP_MINUS,\n    const_one,\n    loc);\n\n  /* \"LVALUE = stack[stack_depth];\".  */\n  block.add_assignment (\n    lvalue,\n    /* stack[stack_depth] */\n    ctxt.new_array_access (stack,\n                           stack_depth,\n                           loc),\n    loc);\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe will support single-stepping through the generated code in the\ndebugger, so we need to create @code{gccjit::location} instances, one\nper operation in the source code.  These will reference the lines of\ne.g. @code{factorial.toy}.\n\n@quotation\n\n@example\n\nvoid\ncompilation_state::create_locations ()\n@{\n  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n    @{\n      toyvm_op *op = &toyvmfn.fn_ops[pc];\n\n      op_locs[pc] = ctxt.new_location (toyvmfn.fn_filename,\n                                       op->op_linenum,\n                                       0); /* column */\n    @}\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n\nLet's create the function itself.  As usual, we create its parameter\nfirst, then use the parameter to create the function:\n\n@quotation\n\n@example\n\nvoid\ncompilation_state::create_function (const char *funcname)\n@{\n  std::vector <gccjit::param> params;\n  param_arg = ctxt.new_param (int_type, \"arg\", op_locs[0]);\n  params.push_back (param_arg);\n  fn = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                          int_type,\n                          funcname,\n                          params, 0,\n                          op_locs[0]);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe create the locals within the function.\n\n@quotation\n\n@example\n  stack = fn.new_local (stack_type, \"stack\");\n  stack_depth = fn.new_local (int_type, \"stack_depth\");\n  x = fn.new_local (int_type, \"x\");\n  y = fn.new_local (int_type, \"y\");\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Populating the function<2>,Verifying the control flow graph<2>,Setting things up<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 populating-the-function}@anchor{126}\n@subsubsection Populating the function\n\n\nThere's some one-time initialization, and the API treats the first block\nyou create as the entrypoint of the function, so we need to create that\nblock first:\n\n@quotation\n\n@example\n  initial_block = fn.new_block (\"initial\");\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now create blocks for each of the operations.  Most of these will\nbe consolidated into larger blocks when the optimizer runs.\n\n@quotation\n\n@example\n  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n    @{\n      char buf[16];\n      sprintf (buf, \"instr%i\", pc);\n      op_blocks[pc] = fn.new_block (buf);\n    @}\n\n\n@end example\n\n@noindent\n@end quotation\n\nNow that we have a block it can jump to when it's done, we can populate\nthe initial block:\n\n@quotation\n\n@example\n\n  /* \"stack_depth = 0;\".  */\n  initial_block.add_assignment (stack_depth,\n                                ctxt.zero (int_type),\n                                op_locs[0]);\n\n  /* \"PUSH (arg);\".  */\n  add_push (initial_block,\n\t    param_arg,\n            op_locs[0]);\n\n  /* ...and jump to insn 0.  */\n  initial_block.end_with_jump (op_blocks[0],\n                               op_locs[0]);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now populate the blocks for the individual operations.  We loop\nthrough them, adding instructions to their blocks:\n\n@quotation\n\n@example\n  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n    @{\n      gccjit::location loc = op_locs[pc];\n\n      gccjit::block block = op_blocks[pc];\n      gccjit::block next_block = (pc < toyvmfn.fn_num_ops\n                                  ? op_blocks[pc + 1]\n                                  : NULL);\n\n      toyvm_op *op;\n      op = &toyvmfn.fn_ops[pc];\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe're going to have another big @code{switch} statement for implementing\nthe opcodes, this time for compiling them, rather than interpreting\nthem.  It's helpful to have macros for implementing push and pop, so that\nwe can make the @code{switch} statement that's coming up look as much as\npossible like the one above within the interpreter:\n\n@example\n\n#define X_EQUALS_POP()\\\n      add_pop (block, x, loc)\n#define Y_EQUALS_POP()\\\n      add_pop (block, y, loc)\n#define PUSH_RVALUE(RVALUE)\\\n      add_push (block, (RVALUE), loc)\n#define PUSH_X()\\\n      PUSH_RVALUE (x)\n#define PUSH_Y() \\\n      PUSH_RVALUE (y)\n\n\n@end example\n\n@noindent\n\n@cartouche\n@quotation Note \nA particularly clever implementation would have an @emph{identical}\n@code{switch} statement shared by the interpreter and the compiler, with\nsome preprocessor \"magic\".  We're not doing that here, for the sake\nof simplicity.\n@end quotation\n@end cartouche\n\nWhen I first implemented this compiler, I accidentally missed an edit\nwhen copying and pasting the @code{Y_EQUALS_POP} macro, so that popping the\nstack into @code{y} instead erroneously assigned it to @code{x}, leaving @code{y}\nuninitialized.\n\nTo track this kind of thing down, we can use\n@pxref{127,,gccjit;;block;;add_comment()} to add descriptive comments\nto the internal representation.  This is invaluable when looking through\nthe generated IR for, say @code{factorial}:\n\n@quotation\n\n@example\n\n      block.add_comment (opcode_names[op->op_opcode], loc);\n\n\n@end example\n\n@noindent\n@end quotation\n\nWe can now write the big @code{switch} statement that implements the\nindividual opcodes, populating the relevant block with statements:\n\n@quotation\n\n@example\n\n      switch (op->op_opcode)\n\t@{\n\tcase DUP:\n\t  X_EQUALS_POP ();\n\t  PUSH_X ();\n\t  PUSH_X ();\n\t  break;\n\n\tcase ROT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_Y ();\n\t  PUSH_X ();\n\t  break;\n\n\tcase BINARY_ADD:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t   ctxt.new_binary_op (\n\t     GCC_JIT_BINARY_OP_PLUS,\n\t     int_type,\n             x, y,\n             loc));\n\t  break;\n\n\tcase BINARY_SUBTRACT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n           ctxt.new_binary_op (\n\t     GCC_JIT_BINARY_OP_MINUS,\n\t     int_type,\n             x, y,\n             loc));\n\t  break;\n\n\tcase BINARY_MULT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n           ctxt.new_binary_op (\n\t     GCC_JIT_BINARY_OP_MULT,\n\t     int_type,\n             x, y,\n             loc));\n\t  break;\n\n\tcase BINARY_COMPARE_LT:\n\t  Y_EQUALS_POP ();\n\t  X_EQUALS_POP ();\n\t  PUSH_RVALUE (\n\t     /* cast of bool to int */\n\t     ctxt.new_cast (\n\t       /* (x < y) as a bool */\n\t       ctxt.new_comparison (\n\t\t GCC_JIT_COMPARISON_LT,\n                 x, y,\n                 loc),\n\t       int_type,\n               loc));\n\t  break;\n\n\tcase RECURSE:\n\t  @{\n\t    X_EQUALS_POP ();\n\t    PUSH_RVALUE (\n\t      ctxt.new_call (\n\t\tfn,\n\t\tx,\n                loc));\n\t    break;\n\t  @}\n\n\tcase RETURN:\n\t  X_EQUALS_POP ();\n\t  block.end_with_return (x, loc);\n\t  break;\n\n\t  /* Ops taking an operand.  */\n\tcase PUSH_CONST:\n\t  PUSH_RVALUE (\n\t    ctxt.new_rvalue (int_type, op->op_operand));\n\t  break;\n\n\tcase JUMP_ABS_IF_TRUE:\n\t  X_EQUALS_POP ();\n\t  block.end_with_conditional (\n\t    /* \"(bool)x\".  */\n            ctxt.new_cast (x, bool_type, loc),\n\t    op_blocks[op->op_operand], /* on_true */\n\t    next_block, /* on_false */\n            loc); \n\t  break;\n\n\tdefault:\n\t  assert(0);\n\t@} /* end of switch on opcode */\n\n\n@end example\n\n@noindent\n@end quotation\n\nEvery block must be terminated, via a call to one of the\n@code{gccjit::block::end_with_} entrypoints.  This has been done for two\nof the opcodes, but we need to do it for the other ones, by jumping\nto the next block.\n\n@quotation\n\n@example\n      if (op->op_opcode != JUMP_ABS_IF_TRUE\n\t  && op->op_opcode != RETURN)\n\tblock.end_with_jump (next_block, loc);\n\n\n@end example\n\n@noindent\n@end quotation\n\nThis is analogous to simply incrementing the program counter.\n\n@node Verifying the control flow graph<2>,Compiling the context<2>,Populating the function<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 verifying-the-control-flow-graph}@anchor{128}\n@subsubsection Verifying the control flow graph\n\n\nHaving finished looping over the blocks, the context is complete.\n\nAs before, we can verify that the control flow and statements are sane by\nusing @pxref{11f,,gccjit;;function;;dump_to_dot()}:\n\n@example\nfn.dump_to_dot (\"/tmp/factorial.dot\");\n@end example\n\n@noindent\n\nand viewing the result.  Note how the label names, comments, and\nvariable names show up in the dump, to make it easier to spot\nerrors in our compiler.\n\n@quotation\n\n\n@float Figure\n\n@image{factorial,,,image of a control flow graph,png}\n\n@end float\n\n@end quotation\n\n@node Compiling the context<2>,Single-stepping through the generated code<2>,Verifying the control flow graph<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 compiling-the-context}@anchor{129}\n@subsubsection Compiling the context\n\n\nHaving finished looping over the blocks and populating them with\nstatements, the context is complete.\n\nWe can now compile it, extract machine code from the result, and\nrun it:\n\n@quotation\n\n@example\n\nclass compilation_result\n@{\npublic:\n  compilation_result (gcc_jit_result *result) :\n    m_result (result)\n  @{\n  @}\n  ~compilation_result ()\n  @{\n    gcc_jit_result_release (m_result);\n  @}\n\n  void *get_code (const char *funcname)\n  @{\n    return gcc_jit_result_get_code (m_result, funcname);\n  @}\n\nprivate:\n  gcc_jit_result *m_result;\n@};\n\n\n@end example\n\n@noindent\n\n@example\n  compilation_result compiler_result = fn->compile ();\n\n  const char *funcname = fn->get_function_name ();\n  toyvm_compiled_func code\n    = (toyvm_compiled_func)compiler_result.get_code (funcname);\n\n  printf (\"compiler result: %d\\n\",\n\t  code (atoi (argv[2])));\n\n\n@end example\n\n@noindent\n@end quotation\n\n@node Single-stepping through the generated code<2>,Examining the generated code<2>,Compiling the context<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 single-stepping-through-the-generated-code}@anchor{12a}\n@subsubsection Single-stepping through the generated code\n\n\nIt's possible to debug the generated code.  To do this we need to both:\n\n@quotation\n\n\n@itemize *\n\n@item \nSet up source code locations for our statements, so that we can\nmeaningfully step through the code.  We did this above by\ncalling @pxref{12b,,gccjit;;context;;new_location()} and using the\nresults.\n\n@item \nEnable the generation of debugging information, by setting\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n@code{gccjit::context} via\n@pxref{110,,gccjit;;context;;set_bool_option()}:\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO, 1);\n@end example\n\n@noindent\n@end itemize\n@end quotation\n\nHaving done this, we can put a breakpoint on the generated function:\n\n@example\n$ gdb --args ./toyvm factorial.toy 10\n(gdb) break factorial\nFunction \"factorial\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 1 (factorial) pending.\n(gdb) run\nBreakpoint 1, factorial (arg=10) at factorial.toy:14\n14    DUP\n@end example\n\n@noindent\n\nWe've set up location information, which references @code{factorial.toy}.\nThis allows us to use e.g. @code{list} to see where we are in the script:\n\n@example\n(gdb) list\n9\n10    # Initial state:\n11    # stack: [arg]\n12\n13    # 0:\n14    DUP\n15    # stack: [arg, arg]\n16\n17    # 1:\n18    PUSH_CONST 2\n@end example\n\n@noindent\n\nand to step through the function, examining the data:\n\n@example\n(gdb) n\n18    PUSH_CONST 2\n(gdb) n\n22    BINARY_COMPARE_LT\n(gdb) print stack\n$5 = @{10, 10, 2, 0, -7152, 32767, 0, 0@}\n(gdb) print stack_depth\n$6 = 3\n@end example\n\n@noindent\n\nYou'll see that the parts of the @code{stack} array that haven't been\ntouched yet are uninitialized.\n\n@cartouche\n@quotation Note \nTurning on optimizations may lead to unpredictable results when\nstepping through the generated code: the execution may appear to\n\"jump around\" the source code.  This is analogous to turning up the\noptimization level in a regular compiler.\n@end quotation\n@end cartouche\n\n@node Examining the generated code<2>,Putting it all together<2>,Single-stepping through the generated code<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 examining-the-generated-code}@anchor{12c}\n@subsubsection Examining the generated code\n\n\nHow good is the optimized code?\n\nWe can turn up optimizations, by calling\n@pxref{111,,gccjit;;context;;set_int_option()} with\n@pxref{1f,,GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL}:\n\n@example\nctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n@end example\n\n@noindent\n\nOne of GCC's internal representations is called \"gimple\".  A dump of the\ninitial gimple representation of the code can be seen by setting:\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);\n@end example\n\n@noindent\n\nWith optimization on and source locations displayed, this gives:\n\n@c We'll use \"c\" for gimple dumps\n\n@example\nfactorial (signed int arg)\n@{\n  <unnamed type> D.80;\n  signed int D.81;\n  signed int D.82;\n  signed int D.83;\n  signed int D.84;\n  signed int D.85;\n  signed int y;\n  signed int x;\n  signed int stack_depth;\n  signed int stack[8];\n\n  try\n    @{\n      initial:\n      stack_depth = 0;\n      stack[stack_depth] = arg;\n      stack_depth = stack_depth + 1;\n      goto instr0;\n      instr0:\n      /* DUP */:\n      stack_depth = stack_depth + -1;\n      x = stack[stack_depth];\n      stack[stack_depth] = x;\n      stack_depth = stack_depth + 1;\n      stack[stack_depth] = x;\n      stack_depth = stack_depth + 1;\n      goto instr1;\n      instr1:\n      /* PUSH_CONST */:\n      stack[stack_depth] = 2;\n      stack_depth = stack_depth + 1;\n      goto instr2;\n\n      /* etc */\n@end example\n\n@noindent\n\nYou can see the generated machine code in assembly form via:\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 1);\nresult = ctxt.compile ();\n@end example\n\n@noindent\n\nwhich shows that (on this x86_64 box) the compiler has unrolled the loop\nand is using MMX instructions to perform several multiplications\nsimultaneously:\n\n@example\n        .file   \"fake.c\"\n        .text\n.Ltext0:\n        .p2align 4,,15\n        .globl  factorial\n        .type   factorial, @@function\nfactorial:\n.LFB0:\n        .file 1 \"factorial.toy\"\n        .loc 1 14 0\n        .cfi_startproc\n.LVL0:\n.L2:\n        .loc 1 26 0\n        cmpl    $1, %edi\n        jle     .L13\n        leal    -1(%rdi), %edx\n        movl    %edx, %ecx\n        shrl    $2, %ecx\n        leal    0(,%rcx,4), %esi\n        testl   %esi, %esi\n        je      .L14\n        cmpl    $9, %edx\n        jbe     .L14\n        leal    -2(%rdi), %eax\n        movl    %eax, -16(%rsp)\n        leal    -3(%rdi), %eax\n        movd    -16(%rsp), %xmm0\n        movl    %edi, -16(%rsp)\n        movl    %eax, -12(%rsp)\n        movd    -16(%rsp), %xmm1\n        xorl    %eax, %eax\n        movl    %edx, -16(%rsp)\n        movd    -12(%rsp), %xmm4\n        movd    -16(%rsp), %xmm6\n        punpckldq       %xmm4, %xmm0\n        movdqa  .LC1(%rip), %xmm4\n        punpckldq       %xmm6, %xmm1\n        punpcklqdq      %xmm0, %xmm1\n        movdqa  .LC0(%rip), %xmm0\n        jmp     .L5\n        # etc - edited for brevity\n@end example\n\n@noindent\n\nThis is clearly overkill for a function that will likely overflow the\n@code{int} type before the vectorization is worthwhile - but then again, this\nis a toy example.\n\nTurning down the optimization level to 2:\n\n@example\nctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 2);\n@end example\n\n@noindent\n\nyields this code, which is simple enough to quote in its entirety:\n\n@example\n        .file   \"fake.c\"\n        .text\n        .p2align 4,,15\n        .globl  factorial\n        .type   factorial, @@function\nfactorial:\n.LFB0:\n        .cfi_startproc\n.L2:\n        cmpl    $1, %edi\n        jle     .L8\n        movl    $1, %edx\n        jmp     .L4\n        .p2align 4,,10\n        .p2align 3\n.L6:\n        movl    %eax, %edi\n.L4:\n.L5:\n        leal    -1(%rdi), %eax\n        imull   %edi, %edx\n        cmpl    $1, %eax\n        jne     .L6\n.L3:\n.L7:\n        imull   %edx, %eax\n        ret\n.L8:\n        movl    %edi, %eax\n        movl    $1, %edx\n        jmp     .L7\n        .cfi_endproc\n.LFE0:\n        .size   factorial, .-factorial\n        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-%@{gcc_release@})\"\n        .section        .note.GNU-stack,\"\",@@progbits\n@end example\n\n@noindent\n\nNote that the stack pushing and popping have been eliminated, as has the\nrecursive call (in favor of an iteration).\n\n@node Putting it all together<2>,Behind the curtain How does our code get optimized?<2>,Examining the generated code<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 putting-it-all-together}@anchor{12d}\n@subsubsection Putting it all together\n\n\nThe complete example can be seen in the source tree at\n@code{gcc/jit/docs/examples/tut04-toyvm/toyvm.cc}\n\nalong with a Makefile and a couple of sample .toy scripts:\n\n@example\n$ ls -al\ndrwxrwxr-x. 2 david david   4096 Sep 19 17:46 .\ndrwxrwxr-x. 3 david david   4096 Sep 19 15:26 ..\n-rw-rw-r--. 1 david david    615 Sep 19 12:43 factorial.toy\n-rw-rw-r--. 1 david david    834 Sep 19 13:08 fibonacci.toy\n-rw-rw-r--. 1 david david    238 Sep 19 14:22 Makefile\n-rw-rw-r--. 1 david david  16457 Sep 19 17:07 toyvm.cc\n\n$ make toyvm\ng++ -Wall -g -o toyvm toyvm.cc -lgccjit\n\n$ ./toyvm factorial.toy 10\ninterpreter result: 3628800\ncompiler result: 3628800\n\n$ ./toyvm fibonacci.toy 10\ninterpreter result: 55\ncompiler result: 55\n@end example\n\n@noindent\n\n@node Behind the curtain How does our code get optimized?<2>,,Putting it all together<2>,Tutorial part 4 Adding JIT-compilation to a toy interpreter<2>\n@anchor{cp/intro/tutorial04 behind-the-curtain-how-does-our-code-get-optimized}@anchor{12e}\n@subsubsection Behind the curtain: How does our code get optimized?\n\n\nOur example is done, but you may be wondering about exactly how the\ncompiler turned what we gave it into the machine code seen above.\n\nWe can examine what the compiler is doing in detail by setting:\n\n@example\nstate.ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING, 1);\nstate.ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES, 1);\n@end example\n\n@noindent\n\nThis will dump detailed information about the compiler's state to a\ndirectory under @code{/tmp}, and keep it from being cleaned up.\n\nThe precise names and their formats of these files is subject to change.\nHigher optimization levels lead to more files.\nHere's what I saw (edited for brevity; there were almost 200 files):\n\n@example\nintermediate files written to /tmp/libgccjit-KPQbGw\n$ ls /tmp/libgccjit-KPQbGw/\nfake.c.000i.cgraph\nfake.c.000i.type-inheritance\nfake.c.004t.gimple\nfake.c.007t.omplower\nfake.c.008t.lower\nfake.c.011t.eh\nfake.c.012t.cfg\nfake.c.014i.visibility\nfake.c.015i.early_local_cleanups\nfake.c.016t.ssa\n# etc\n@end example\n\n@noindent\n\nThe gimple code is converted into Static Single Assignment form,\nwith annotations for use when generating the debuginfo:\n\n@example\n$ less /tmp/libgccjit-KPQbGw/fake.c.016t.ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n  signed int _56;\n\ninitial:\n  stack_depth_3 = 0;\n  # DEBUG stack_depth => stack_depth_3\n  stack[stack_depth_3] = arg_5(D);\n  stack_depth_7 = stack_depth_3 + 1;\n  # DEBUG stack_depth => stack_depth_7\n  # DEBUG instr0 => NULL\n  # DEBUG /* DUP */ => NULL\n  stack_depth_8 = stack_depth_7 + -1;\n  # DEBUG stack_depth => stack_depth_8\n  x_9 = stack[stack_depth_8];\n  # DEBUG x => x_9\n  stack[stack_depth_8] = x_9;\n  stack_depth_11 = stack_depth_8 + 1;\n  # DEBUG stack_depth => stack_depth_11\n  stack[stack_depth_11] = x_9;\n  stack_depth_13 = stack_depth_11 + 1;\n  # DEBUG stack_depth => stack_depth_13\n  # DEBUG instr1 => NULL\n  # DEBUG /* PUSH_CONST */ => NULL\n  stack[stack_depth_13] = 2;\n\n  /* etc; edited for brevity */\n@end example\n\n@noindent\n\nWe can perhaps better see the code by turning off\n@pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to suppress all those @code{DEBUG}\nstatements, giving:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.016t.ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n  signed int _56;\n\ninitial:\n  stack_depth_3 = 0;\n  stack[stack_depth_3] = arg_5(D);\n  stack_depth_7 = stack_depth_3 + 1;\n  stack_depth_8 = stack_depth_7 + -1;\n  x_9 = stack[stack_depth_8];\n  stack[stack_depth_8] = x_9;\n  stack_depth_11 = stack_depth_8 + 1;\n  stack[stack_depth_11] = x_9;\n  stack_depth_13 = stack_depth_11 + 1;\n  stack[stack_depth_13] = 2;\n  stack_depth_15 = stack_depth_13 + 1;\n  stack_depth_16 = stack_depth_15 + -1;\n  y_17 = stack[stack_depth_16];\n  stack_depth_18 = stack_depth_16 + -1;\n  x_19 = stack[stack_depth_18];\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack[stack_depth_18] = _21;\n  stack_depth_23 = stack_depth_18 + 1;\n  stack_depth_24 = stack_depth_23 + -1;\n  x_25 = stack[stack_depth_24];\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  stack_depth_26 = stack_depth_24 + -1;\n  x_27 = stack[stack_depth_26];\n  stack[stack_depth_26] = x_27;\n  stack_depth_29 = stack_depth_26 + 1;\n  stack[stack_depth_29] = x_27;\n  stack_depth_31 = stack_depth_29 + 1;\n  stack[stack_depth_31] = 1;\n  stack_depth_33 = stack_depth_31 + 1;\n  stack_depth_34 = stack_depth_33 + -1;\n  y_35 = stack[stack_depth_34];\n  stack_depth_36 = stack_depth_34 + -1;\n  x_37 = stack[stack_depth_36];\n  _38 = x_37 - y_35;\n  stack[stack_depth_36] = _38;\n  stack_depth_40 = stack_depth_36 + 1;\n  stack_depth_41 = stack_depth_40 + -1;\n  x_42 = stack[stack_depth_41];\n  _44 = factorial (x_42);\n  stack[stack_depth_41] = _44;\n  stack_depth_46 = stack_depth_41 + 1;\n  stack_depth_47 = stack_depth_46 + -1;\n  y_48 = stack[stack_depth_47];\n  stack_depth_49 = stack_depth_47 + -1;\n  x_50 = stack[stack_depth_49];\n  _51 = x_50 * y_48;\n  stack[stack_depth_49] = _51;\n  stack_depth_53 = stack_depth_49 + 1;\n\n  # stack_depth_1 = PHI <stack_depth_24(2), stack_depth_53(3)>\ninstr9:\n/* RETURN */:\n  stack_depth_54 = stack_depth_1 + -1;\n  x_55 = stack[stack_depth_54];\n  _56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return _56;\n\n@}\n@end example\n\n@noindent\n\nNote in the above how all the @code{gccjit::block} instances we\ncreated have been consolidated into just 3 blocks in GCC's internal\nrepresentation: @code{initial}, @code{instr4} and @code{instr9}.\n\n@menu\n* Optimizing away stack manipulation: Optimizing away stack manipulation<2>. \n* Elimination of tail recursion: Elimination of tail recursion<2>. \n\n@end menu\n\n@node Optimizing away stack manipulation<2>,Elimination of tail recursion<2>,,Behind the curtain How does our code get optimized?<2>\n@anchor{cp/intro/tutorial04 optimizing-away-stack-manipulation}@anchor{12f}\n@subsubsection Optimizing away stack manipulation\n\n\nRecall our simple implementation of stack operations.  Let's examine\nhow the stack operations are optimized away.\n\nAfter a pass of constant-propagation, the depth of the stack at each\nopcode can be determined at compile-time:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.021t.ccp1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack[0] = arg_5(D);\n  x_9 = stack[0];\n  stack[0] = x_9;\n  stack[1] = x_9;\n  stack[2] = 2;\n  y_17 = stack[2];\n  x_19 = stack[1];\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack[1] = _21;\n  x_25 = stack[1];\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  x_27 = stack[0];\n  stack[0] = x_27;\n  stack[1] = x_27;\n  stack[2] = 1;\n  y_35 = stack[2];\n  x_37 = stack[1];\n  _38 = x_37 - y_35;\n  stack[1] = _38;\n  x_42 = stack[1];\n  _44 = factorial (x_42);\n  stack[1] = _44;\n  y_48 = stack[1];\n  x_50 = stack[0];\n  _51 = x_50 * y_48;\n  stack[0] = _51;\n\ninstr9:\n/* RETURN */:\n  x_55 = stack[0];\n  x_56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return x_56;\n\n@}\n@end example\n\n@noindent\n\nNote how, in the above, all those @code{stack_depth} values are now just\nconstants: we're accessing specific stack locations at each opcode.\n\nThe \"esra\" pass (\"Early Scalar Replacement of Aggregates\") breaks\nout our \"stack\" array into individual elements:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.024t.esra\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nCreated a replacement for stack offset: 0, size: 32: stack$0\nCreated a replacement for stack offset: 32, size: 32: stack$1\nCreated a replacement for stack offset: 64, size: 32: stack$2\n\nSymbols to be put in SSA form\n@{ D.89 D.90 D.91 @}\nIncremental SSA update started at block: 0\nNumber of blocks in CFG: 5\nNumber of blocks to update: 4 ( 80%)\n\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack$0_45 = arg_5(D);\n  x_9 = stack$0_45;\n  stack$0_39 = x_9;\n  stack$1_32 = x_9;\n  stack$2_30 = 2;\n  y_17 = stack$2_30;\n  x_19 = stack$1_32;\n  _20 = x_19 < y_17;\n  _21 = (signed int) _20;\n  stack$1_28 = _21;\n  x_25 = stack$1_28;\n  if (x_25 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  x_27 = stack$0_39;\n  stack$0_22 = x_27;\n  stack$1_14 = x_27;\n  stack$2_12 = 1;\n  y_35 = stack$2_12;\n  x_37 = stack$1_14;\n  _38 = x_37 - y_35;\n  stack$1_10 = _38;\n  x_42 = stack$1_10;\n  _44 = factorial (x_42);\n  stack$1_6 = _44;\n  y_48 = stack$1_6;\n  x_50 = stack$0_22;\n  _51 = x_50 * y_48;\n  stack$0_1 = _51;\n\n  # stack$0_52 = PHI <stack$0_39(2), stack$0_1(3)>\ninstr9:\n/* RETURN */:\n  x_55 = stack$0_52;\n  x_56 = x_55;\n  stack =@{v@} @{CLOBBER@};\n  return x_56;\n\n@}\n@end example\n\n@noindent\n\nHence at this point, all those pushes and pops of the stack are now\nsimply assignments to specific temporary variables.\n\nAfter some copy propagation, the stack manipulation has been completely\noptimized away:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.026t.copyprop1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int _44;\n  signed int _51;\n\ninitial:\n  stack$0_39 = arg_5(D);\n  _20 = arg_5(D) <= 1;\n  _21 = (signed int) _20;\n  if (_21 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _38 = arg_5(D) + -1;\n  _44 = factorial (_38);\n  _51 = arg_5(D) * _44;\n  stack$0_1 = _51;\n\n  # stack$0_52 = PHI <arg_5(D)(2), _51(3)>\ninstr9:\n/* RETURN */:\n  stack =@{v@} @{CLOBBER@};\n  return stack$0_52;\n\n@}\n@end example\n\n@noindent\n\nLater on, another pass finally eliminated @code{stack_depth} local and the\nunused parts of the @cite{stack`} array altogether:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.036t.release_ssa\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\nReleased 44 names, 314.29%, removed 44 holes\nfactorial (signed int arg)\n@{\n  signed int stack$0;\n  signed int mult_acc_1;\n  <unnamed type> _5;\n  signed int _6;\n  signed int _7;\n  signed int mul_tmp_10;\n  signed int mult_acc_11;\n  signed int mult_acc_13;\n\n  # arg_9 = PHI <arg_8(D)(0)>\n  # mult_acc_13 = PHI <1(0)>\ninitial:\n\n  <bb 5>:\n  # arg_4 = PHI <arg_9(2), _7(3)>\n  # mult_acc_1 = PHI <mult_acc_13(2), mult_acc_11(3)>\n  _5 = arg_4 <= 1;\n  _6 = (signed int) _5;\n  if (_6 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _7 = arg_4 + -1;\n  mult_acc_11 = mult_acc_1 * arg_4;\n  goto <bb 5>;\n\n  # stack$0_12 = PHI <arg_4(5)>\ninstr9:\n/* RETURN */:\n  mul_tmp_10 = mult_acc_1 * stack$0_12;\n  return mul_tmp_10;\n\n@}\n@end example\n\n@noindent\n\n@node Elimination of tail recursion<2>,,Optimizing away stack manipulation<2>,Behind the curtain How does our code get optimized?<2>\n@anchor{cp/intro/tutorial04 elimination-of-tail-recursion}@anchor{130}\n@subsubsection Elimination of tail recursion\n\n\nAnother significant optimization is the detection that the call to\n@code{factorial} is tail recursion, which can be eliminated in favor of\nan iteration:\n\n@example\n$ less /tmp/libgccjit-1Hywc0/fake.c.030t.tailr1\n@end example\n\n@noindent\n\n@example\n;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n\n\nSymbols to be put in SSA form\n@{ D.88 @}\nIncremental SSA update started at block: 0\nNumber of blocks in CFG: 5\nNumber of blocks to update: 4 ( 80%)\n\n\nfactorial (signed int arg)\n@{\n  signed int stack$2;\n  signed int stack$1;\n  signed int stack$0;\n  signed int stack[8];\n  signed int stack_depth;\n  signed int x;\n  signed int y;\n  signed int mult_acc_1;\n  <unnamed type> _20;\n  signed int _21;\n  signed int _38;\n  signed int mul_tmp_44;\n  signed int mult_acc_51;\n\n  # arg_5 = PHI <arg_39(D)(0), _38(3)>\n  # mult_acc_1 = PHI <1(0), mult_acc_51(3)>\ninitial:\n  _20 = arg_5 <= 1;\n  _21 = (signed int) _20;\n  if (_21 != 0)\n    goto <bb 4> (instr9);\n  else\n    goto <bb 3> (instr4);\n\ninstr4:\n/* DUP */:\n  _38 = arg_5 + -1;\n  mult_acc_51 = mult_acc_1 * arg_5;\n  goto <bb 2> (initial);\n\n  # stack$0_52 = PHI <arg_5(2)>\ninstr9:\n/* RETURN */:\n  stack =@{v@} @{CLOBBER@};\n  mul_tmp_44 = mult_acc_1 * stack$0_52;\n  return mul_tmp_44;\n\n@}\n@end example\n\n@noindent\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Topic Reference<2>,,Tutorial<2>,C++ bindings for libgccjit\n@anchor{cp/topics/index doc}@anchor{131}@anchor{cp/topics/index topic-reference}@anchor{132}\n@section Topic Reference\n\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@menu\n* Compilation contexts: Compilation contexts<2>. \n* Objects: Objects<2>. \n* Types: Types<2>. \n* Expressions: Expressions<2>. \n* Creating and using functions: Creating and using functions<2>. \n* Source Locations: Source Locations<2>. \n* Compiling a context: Compiling a context<2>. \n\nCompilation contexts\n\n* Lifetime-management: Lifetime-management<2>. \n* Thread-safety: Thread-safety<2>. \n* Error-handling: Error-handling<3>. \n* Debugging: Debugging<2>. \n* Options: Options<4>. \n\nOptions\n\n* String Options: String Options<2>. \n* Boolean options: Boolean options<2>. \n* Integer options: Integer options<2>. \n* Additional command-line options: Additional command-line options<2>. \n\nTypes\n\n* Standard types: Standard types<2>. \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile<2>. \n* Structures and unions: Structures and unions<2>. \n\nExpressions\n\n* Rvalues: Rvalues<2>. \n* Lvalues: Lvalues<2>. \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions<2>. \n\nRvalues\n\n* Simple expressions: Simple expressions<2>. \n* Unary Operations: Unary Operations<2>. \n* Binary Operations: Binary Operations<2>. \n* Comparisons: Comparisons<2>. \n* Function calls: Function calls<2>. \n* Type-coercion: Type-coercion<2>. \n\nLvalues\n\n* Global variables: Global variables<2>. \n\nCreating and using functions\n\n* Params: Params<2>. \n* Functions: Functions<2>. \n* Blocks: Blocks<2>. \n* Statements: Statements<2>. \n\nSource Locations\n\n* Faking it: Faking it<2>. \n\nCompiling a context\n\n* In-memory compilation: In-memory compilation<2>. \n* Ahead-of-time compilation: Ahead-of-time compilation<2>. \n\n@end menu\n\n\n@node Compilation contexts<2>,Objects<2>,,Topic Reference<2>\n@anchor{cp/topics/contexts compilation-contexts}@anchor{133}@anchor{cp/topics/contexts doc}@anchor{134}\n@subsection Compilation contexts\n\n\n@geindex gccjit;;context (C++ class)\n@anchor{cp/topics/contexts gccjit context}@anchor{135}\n@deffn {C++ Class} gccjit::context\n@end deffn\n\nThe top-level of the C++ API is the @pxref{135,,gccjit;;context} type.\n\nA @pxref{135,,gccjit;;context} instance encapsulates the state of a\ncompilation.\n\nYou can set up options on it, and add types, functions and code.\nInvoking @pxref{10e,,gccjit;;context;;compile()} on it gives you a\n@pxref{16,,gcc_jit_result *}.\n\nIt is a thin wrapper around the C API's @pxref{8,,gcc_jit_context *}.\n\n@menu\n* Lifetime-management: Lifetime-management<2>. \n* Thread-safety: Thread-safety<2>. \n* Error-handling: Error-handling<3>. \n* Debugging: Debugging<2>. \n* Options: Options<4>. \n\n@end menu\n\n@node Lifetime-management<2>,Thread-safety<2>,,Compilation contexts<2>\n@anchor{cp/topics/contexts lifetime-management}@anchor{136}\n@subsubsection Lifetime-management\n\n\nContexts are the unit of lifetime-management within the API: objects\nhave their lifetime bounded by the context they are created within, and\ncleanup of such objects is done for you when the context is released.\n\n@geindex gccjit;;context;;acquire (C++ function)\n@anchor{cp/topics/contexts gccjit context acquire}@anchor{108}\n@deffn {C++ Function} gccjit::context gccjit::context::acquire ()\n\nThis function acquires a new @pxref{135,,gccjit;;context} instance,\nwhich is independent of any others that may be present within this\nprocess.\n@end deffn\n\n@geindex gccjit;;context;;release (C++ function)\n@anchor{cp/topics/contexts gccjit context release}@anchor{10a}\n@deffn {C++ Function} void gccjit::context::release ()\n\nThis function releases all resources associated with the given context.\nBoth the context itself and all of its @code{gccjit::object *}\ninstances are cleaned up.  It should be called exactly once on a given\ncontext.\n\nIt is invalid to use the context or any of its \"contextual\" objects\nafter calling this.\n\n@example\nctxt.release ();\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;context;;new_child_context (C++ function)\n@anchor{cp/topics/contexts gccjit context new_child_context}@anchor{137}\n@deffn {C++ Function} gccjit::context gccjit::context::new_child_context ()\n\nGiven an existing JIT context, create a child context.\n\nThe child inherits a copy of all option-settings from the parent.\n\nThe child can reference objects created within the parent, but not\nvice-versa.\n\nThe lifetime of the child context must be bounded by that of the\nparent: you should release a child context before releasing the parent\ncontext.\n\nIf you use a function from a parent context within a child context,\nyou have to compile the parent context before you can compile the\nchild context, and the gccjit::result of the parent context must\noutlive the gccjit::result of the child context.\n\nThis allows caching of shared initializations.  For example, you could\ncreate types and declarations of global functions in a parent context\nonce within a process, and then create child contexts whenever a\nfunction or loop becomes hot. Each such child context can be used for\nJIT-compiling just one function or loop, but can reference types\nand helper functions created within the parent context.\n\nContexts can be arbitrarily nested, provided the above rules are\nfollowed, but it's probably not worth going above 2 or 3 levels, and\nthere will likely be a performance hit for such nesting.\n@end deffn\n\n@node Thread-safety<2>,Error-handling<3>,Lifetime-management<2>,Compilation contexts<2>\n@anchor{cp/topics/contexts thread-safety}@anchor{138}\n@subsubsection Thread-safety\n\n\nInstances of @pxref{135,,gccjit;;context} created via\n@pxref{108,,gccjit;;context;;acquire()} are independent from each other:\nonly one thread may use a given context at once, but multiple threads\ncould each have their own contexts without needing locks.\n\nContexts created via @pxref{137,,gccjit;;context;;new_child_context()} are\nrelated to their parent context.  They can be partitioned by their\nultimate ancestor into independent \"family trees\".   Only one thread\nwithin a process may use a given \"family tree\" of such contexts at once,\nand if you're using multiple threads you should provide your own locking\naround entire such context partitions.\n\n@node Error-handling<3>,Debugging<2>,Thread-safety<2>,Compilation contexts<2>\n@anchor{cp/topics/contexts error-handling}@anchor{139}\n@subsubsection Error-handling\n\n\n@c FIXME: How does error-handling work for C++ API?\n\nYou can only compile and get code from a context if no errors occur.\n\nIn general, if an error occurs when using an API entrypoint, it returns\nNULL.  You don't have to check everywhere for NULL results, since the\nAPI gracefully handles a NULL being passed in for any argument.\n\nErrors are printed on stderr and can be queried using\n@pxref{13a,,gccjit;;context;;get_first_error()}.\n\n@geindex gccjit;;context;;get_first_error (C++ function)\n@anchor{cp/topics/contexts gccjit context get_first_error__gccjit contextP}@anchor{13a}\n@deffn {C++ Function} const char* gccjit::context::get_first_error (gccjit::context* ctxt)\n\nReturns the first error message that occurred on the context.\n\nThe returned string is valid for the rest of the lifetime of the\ncontext.\n\nIf no errors occurred, this will be NULL.\n@end deffn\n\n@node Debugging<2>,Options<4>,Error-handling<3>,Compilation contexts<2>\n@anchor{cp/topics/contexts debugging}@anchor{13b}\n@subsubsection Debugging\n\n\n@geindex gccjit;;context;;dump_to_file (C++ function)\n@anchor{cp/topics/contexts gccjit context dump_to_file__ssCR i}@anchor{13c}\n@deffn {C++ Function} void gccjit::context::dump_to_file (const std::string& path, int update_locations)\n\nTo help with debugging: dump a C-like representation to the given path,\ndescribing what's been set up on the context.\n\nIf \"update_locations\" is true, then also set up @pxref{13d,,gccjit;;location}\ninformation throughout the context, pointing at the dump file as if it\nwere a source file.  This may be of use in conjunction with\n@code{GCCJIT::BOOL_OPTION_DEBUGINFO} to allow stepping through the\ncode in a debugger.\n@end deffn\n\n@geindex gccjit;;context;;dump_reproducer_to_file (C++ function)\n@anchor{cp/topics/contexts gccjit context dump_reproducer_to_file__gcc_jit_contextP cCP}@anchor{13e}\n@deffn {C++ Function} void gccjit::context::dump_reproducer_to_file (gcc_jit_context* ctxt, const char* path)\n\nThis is a thin wrapper around the C API\n@pxref{5d,,gcc_jit_context_dump_reproducer_to_file()}, and hence works the\nsame way.\n\nNote that the generated source is C code, not C++; this might be of use\nfor seeing what the C++ bindings are doing at the C level.\n@end deffn\n\n@node Options<4>,,Debugging<2>,Compilation contexts<2>\n@anchor{cp/topics/contexts options}@anchor{13f}\n@subsubsection Options\n\n\n@menu\n* String Options: String Options<2>. \n* Boolean options: Boolean options<2>. \n* Integer options: Integer options<2>. \n* Additional command-line options: Additional command-line options<2>. \n\n@end menu\n\n@node String Options<2>,Boolean options<2>,,Options<4>\n@anchor{cp/topics/contexts string-options}@anchor{140}\n@subsubsection String Options\n\n\n@geindex gccjit;;context;;set_str_option (C++ function)\n@anchor{cp/topics/contexts gccjit context set_str_option__enum cCP}@anchor{141}\n@deffn {C++ Function} void gccjit::context::set_str_option (enum gcc_jit_str_option, const char* value)\n\nSet a string option of the context.\n\nThis is a thin wrapper around the C API\n@pxref{61,,gcc_jit_context_set_str_option()}; the options have the same\nmeaning.\n@end deffn\n\n@node Boolean options<2>,Integer options<2>,String Options<2>,Options<4>\n@anchor{cp/topics/contexts boolean-options}@anchor{142}\n@subsubsection Boolean options\n\n\n@geindex gccjit;;context;;set_bool_option (C++ function)\n@anchor{cp/topics/contexts gccjit context set_bool_option__enum i}@anchor{110}\n@deffn {C++ Function} void gccjit::context::set_bool_option (enum gcc_jit_bool_option, int value)\n\nSet a boolean option of the context.\n\nThis is a thin wrapper around the C API\n@pxref{1b,,gcc_jit_context_set_bool_option()}; the options have the same\nmeaning.\n@end deffn\n\n@geindex gccjit;;context;;set_bool_allow_unreachable_blocks (C++ function)\n@anchor{cp/topics/contexts gccjit context set_bool_allow_unreachable_blocks__i}@anchor{143}\n@deffn {C++ Function} void gccjit::context::set_bool_allow_unreachable_blocks (int bool_value)\n\nBy default, libgccjit will issue an error about unreachable blocks\nwithin a function.\n\nThis entrypoint can be used to disable that error; it is a thin wrapper\naround the C API\n@pxref{6b,,gcc_jit_context_set_bool_allow_unreachable_blocks()}.\n\nThis entrypoint was added in @pxref{6c,,LIBGCCJIT_ABI_2}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;context;;set_bool_use_external_driver (C++ function)\n@anchor{cp/topics/contexts gccjit context set_bool_use_external_driver__i}@anchor{144}\n@deffn {C++ Function} void gccjit::context::set_bool_use_external_driver (int bool_value)\n\nlibgccjit internally generates assembler, and uses \"driver\" code\nfor converting it to other formats (e.g. shared libraries).\n\nBy default, libgccjit will use an embedded copy of the driver\ncode.\n\nThis option can be used to instead invoke an external driver executable\nas a subprocess; it is a thin wrapper around the C API\n@pxref{6d,,gcc_jit_context_set_bool_use_external_driver()}.\n\nThis entrypoint was added in @pxref{6e,,LIBGCCJIT_ABI_5}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver\n@end example\n\n@noindent\n@end deffn\n\n@node Integer options<2>,Additional command-line options<2>,Boolean options<2>,Options<4>\n@anchor{cp/topics/contexts integer-options}@anchor{145}\n@subsubsection Integer options\n\n\n@geindex gccjit;;context;;set_int_option (C++ function)\n@anchor{cp/topics/contexts gccjit context set_int_option__enum i}@anchor{111}\n@deffn {C++ Function} void gccjit::context::set_int_option (enum gcc_jit_int_option, int value)\n\nSet an integer option of the context.\n\nThis is a thin wrapper around the C API\n@pxref{1e,,gcc_jit_context_set_int_option()}; the options have the same\nmeaning.\n@end deffn\n\n@node Additional command-line options<2>,,Integer options<2>,Options<4>\n@anchor{cp/topics/contexts additional-command-line-options}@anchor{146}\n@subsubsection Additional command-line options\n\n\n@geindex gccjit;;context;;add_command_line_option (C++ function)\n@anchor{cp/topics/contexts gccjit context add_command_line_option__cCP}@anchor{147}\n@deffn {C++ Function} void gccjit::context::add_command_line_option (const char* optname)\n\nAdd an arbitrary gcc command-line option to the context for use\nwhen compiling.\n\nThis is a thin wrapper around the C API\n@pxref{72,,gcc_jit_context_add_command_line_option()}.\n\nThis entrypoint was added in @pxref{73,,LIBGCCJIT_ABI_1}; you can test for\nits presence using\n\n@example\n#ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_command_line_option\n@end example\n\n@noindent\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Objects<2>,Types<2>,Compilation contexts<2>,Topic Reference<2>\n@anchor{cp/topics/objects objects}@anchor{148}@anchor{cp/topics/objects doc}@anchor{149}\n@subsection Objects\n\n\n@geindex gccjit;;object (C++ class)\n@anchor{cp/topics/objects gccjit object}@anchor{14a}\n@deffn {C++ Class} gccjit::object\n@end deffn\n\nAlmost every entity in the API (with the exception of\n@pxref{135,,gccjit;;context} and @pxref{16,,gcc_jit_result *}) is a\n\"contextual\" object, a @pxref{14a,,gccjit;;object}.\n\nA JIT object:\n\n@quotation\n\n\n@itemize *\n\n@item \nis associated with a @pxref{135,,gccjit;;context}.\n\n@item \nis automatically cleaned up for you when its context is released so\nyou don't need to manually track and cleanup all objects, just the\ncontexts.\n@end itemize\n@end quotation\n\nThe C++ class hierarchy within the @code{gccjit} namespace looks like this:\n\n@example\n+- object\n    +- location\n    +- type\n       +- struct\n    +- field\n    +- function\n    +- block\n    +- rvalue\n        +- lvalue\n           +- param\n    +- case_\n@end example\n\n@noindent\n\nThe @pxref{14a,,gccjit;;object} base class has the following operations:\n\n@geindex gccjit;;object;;get_context (C++ function)\n@anchor{cp/topics/objects gccjit object get_contextC}@anchor{14b}\n@deffn {C++ Function} gccjit::context gccjit::object::get_context () const\n\nWhich context is the obj within?\n@end deffn\n\n@geindex gccjit;;object;;get_debug_string (C++ function)\n@anchor{cp/topics/objects gccjit object get_debug_stringC}@anchor{10b}\n@deffn {C++ Function} std::string gccjit::object::get_debug_string () const\n\nGenerate a human-readable description for the given object.\n\nFor example,\n\n@example\nprintf (\"obj: %s\\n\", obj.get_debug_string ().c_str ());\n@end example\n\n@noindent\n\nmight give this text on stdout:\n\n@example\nobj: 4.0 * (float)i\n@end example\n\n@noindent\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Types<2>,Expressions<2>,Objects<2>,Topic Reference<2>\n@anchor{cp/topics/types doc}@anchor{14c}@anchor{cp/topics/types types}@anchor{14d}\n@subsection Types\n\n\n@geindex gccjit;;type (C++ class)\n@anchor{cp/topics/types gccjit type}@anchor{14e}\n@deffn {C++ Class} gccjit::type\n\ngccjit::type represents a type within the library.  It is a subclass\nof @pxref{14a,,gccjit;;object}.\n@end deffn\n\nTypes can be created in several ways:\n\n\n@itemize *\n\n@item \nfundamental types can be accessed using\n@pxref{109,,gccjit;;context;;get_type()}:\n\n@example\ngccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n@end example\n\n@noindent\n\nor using the @code{gccjit::context::get_int_type} template:\n\n@example\ngccjit::type t = ctxt.get_int_type <unsigned short> ();\n@end example\n\n@noindent\n\nSee @pxref{b,,gcc_jit_context_get_type()} for the available types.\n\n@item \nderived types can be accessed by using functions such as\n@pxref{14f,,gccjit;;type;;get_pointer()} and @pxref{150,,gccjit;;type;;get_const()}:\n\n@example\ngccjit::type const_int_star = int_type.get_const ().get_pointer ();\ngccjit::type int_const_star = int_type.get_pointer ().get_const ();\n@end example\n\n@noindent\n\n@item \nby creating structures (see below).\n@end itemize\n\n@menu\n* Standard types: Standard types<2>. \n* Pointers@comma{} const@comma{} and volatile: Pointers const and volatile<2>. \n* Structures and unions: Structures and unions<2>. \n\n@end menu\n\n@node Standard types<2>,Pointers const and volatile<2>,,Types<2>\n@anchor{cp/topics/types standard-types}@anchor{151}\n@subsubsection Standard types\n\n\n@geindex gccjit;;context;;get_type (C++ function)\n@anchor{cp/topics/types gccjit context get_type__enum}@anchor{109}\n@deffn {C++ Function} gccjit::type gccjit::context::get_type (enum gcc_jit_types)\n\nAccess a specific type.  This is a thin wrapper around\n@pxref{b,,gcc_jit_context_get_type()}; the parameter has the same meaning.\n@end deffn\n\n@geindex gccjit;;context;;get_int_type (C++ function)\n@anchor{cp/topics/types gccjit context get_int_type__s i}@anchor{152}\n@deffn {C++ Function} gccjit::type gccjit::context::get_int_type (size_t num_bytes, int is_signed)\n\nAccess the integer type of the given size.\n@end deffn\n\n@geindex gccjit;;context;;get_int_type<T> (C++ function)\n@anchor{cp/topics/types gccjit context get_int_type T}@anchor{153}\n@deffn {C++ Function} gccjit::type gccjit::context::get_int_type<T> ()\n\nAccess the given integer type.  For example, you could map the\n@code{unsigned short} type into a gccjit::type via:\n\n@example\ngccjit::type t = ctxt.get_int_type <unsigned short> ();\n@end example\n\n@noindent\n@end deffn\n\n@node Pointers const and volatile<2>,Structures and unions<2>,Standard types<2>,Types<2>\n@anchor{cp/topics/types pointers-const-and-volatile}@anchor{154}\n@subsubsection Pointers, @cite{const}, and @cite{volatile}\n\n\n@geindex gccjit;;type;;get_pointer (C++ function)\n@anchor{cp/topics/types gccjit type get_pointer}@anchor{14f}\n@deffn {C++ Function} gccjit::type gccjit::type::get_pointer ()\n\nGiven type \"T\", get type \"T*\".\n@end deffn\n\n@c FIXME: get_const doesn't seem to exist\n\n@geindex gccjit;;type;;get_const (C++ function)\n@anchor{cp/topics/types gccjit type get_const}@anchor{150}\n@deffn {C++ Function} gccjit::type gccjit::type::get_const ()\n\nGiven type \"T\", get type \"const T\".\n@end deffn\n\n@geindex gccjit;;type;;get_volatile (C++ function)\n@anchor{cp/topics/types gccjit type get_volatile}@anchor{155}\n@deffn {C++ Function} gccjit::type gccjit::type::get_volatile ()\n\nGiven type \"T\", get type \"volatile T\".\n@end deffn\n\n@geindex gccjit;;context;;new_array_type (C++ function)\n@anchor{cp/topics/types gccjit context new_array_type__gccjit type i gccjit location}@anchor{156}\n@deffn {C++ Function} gccjit::type gccjit::context::new_array_type (gccjit::type element_type, int num_elements, gccjit::location loc)\n\nGiven type \"T\", get type \"T[N]\" (for a constant N).\nParam \"loc\" is optional.\n@end deffn\n\n@node Structures and unions<2>,,Pointers const and volatile<2>,Types<2>\n@anchor{cp/topics/types structures-and-unions}@anchor{157}\n@subsubsection Structures and unions\n\n\n@geindex gccjit;;struct_ (C++ class)\n@anchor{cp/topics/types gccjit struct_}@anchor{158}\n@deffn {C++ Class} gccjit::struct_\n@end deffn\n\nA compound type analagous to a C @cite{struct}.\n\n@pxref{158,,gccjit;;struct_} is a subclass of @pxref{14e,,gccjit;;type} (and thus\nof @pxref{14a,,gccjit;;object} in turn).\n\n@geindex gccjit;;field (C++ class)\n@anchor{cp/topics/types gccjit field}@anchor{159}\n@deffn {C++ Class} gccjit::field\n@end deffn\n\nA field within a @pxref{158,,gccjit;;struct_}.\n\n@pxref{159,,gccjit;;field} is a subclass of @pxref{14a,,gccjit;;object}.\n\nYou can model C @cite{struct} types by creating @pxref{158,,gccjit;;struct_} and\n@pxref{159,,gccjit;;field} instances, in either order:\n\n\n@itemize *\n\n@item \nby creating the fields, then the structure.  For example, to model:\n\n@example\nstruct coord @{double x; double y; @};\n@end example\n\n@noindent\n\nyou could call:\n\n@example\ngccjit::field field_x = ctxt.new_field (double_type, \"x\");\ngccjit::field field_y = ctxt.new_field (double_type, \"y\");\nstd::vector fields;\nfields.push_back (field_x);\nfields.push_back (field_y);\ngccjit::struct_ coord = ctxt.new_struct_type (\"coord\", fields);\n@end example\n\n@noindent\n\n@item \nby creating the structure, then populating it with fields, typically\nto allow modelling self-referential structs such as:\n\n@example\nstruct node @{ int m_hash; struct node *m_next; @};\n@end example\n\n@noindent\n\nlike this:\n\n@example\ngccjit::struct_ node = ctxt.new_opaque_struct_type (\"node\");\ngccjit::type node_ptr = node.get_pointer ();\ngccjit::field field_hash = ctxt.new_field (int_type, \"m_hash\");\ngccjit::field field_next = ctxt.new_field (node_ptr, \"m_next\");\nstd::vector fields;\nfields.push_back (field_hash);\nfields.push_back (field_next);\nnode.set_fields (fields);\n@end example\n\n@noindent\n@end itemize\n\n@c FIXME: the above API doesn't seem to exist yet\n\n@geindex gccjit;;context;;new_field (C++ function)\n@anchor{cp/topics/types gccjit context new_field__gccjit type cCP gccjit location}@anchor{15a}\n@deffn {C++ Function} gccjit::field gccjit::context::new_field (gccjit::type type, const char* name, gccjit::location loc)\n\nConstruct a new field, with the given type and name.\n@end deffn\n\n@geindex gccjit;;context;;new_struct_type (C++ function)\n@anchor{cp/topics/types gccjit context new_struct_type__ssCR std vector field R gccjit location}@anchor{15b}\n@deffn {C++ Function} gccjit::struct_ gccjit::context::new_struct_type (const std::string& name, std::vector<field>& fields, gccjit::location loc)\n\n@quotation\n\nConstruct a new struct type, with the given name and fields.\n@end quotation\n@end deffn\n\n@geindex gccjit;;context;;new_opaque_struct (C++ function)\n@anchor{cp/topics/types gccjit context new_opaque_struct__ssCR gccjit location}@anchor{15c}\n@deffn {C++ Function} gccjit::struct_ gccjit::context::new_opaque_struct (const std::string& name, gccjit::location loc)\n\nConstruct a new struct type, with the given name, but without\nspecifying the fields.   The fields can be omitted (in which case the\nsize of the struct is not known), or later specified using\n@pxref{87,,gcc_jit_struct_set_fields()}.\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Expressions<2>,Creating and using functions<2>,Types<2>,Topic Reference<2>\n@anchor{cp/topics/expressions expressions}@anchor{15d}@anchor{cp/topics/expressions doc}@anchor{15e}\n@subsection Expressions\n\n\n@menu\n* Rvalues: Rvalues<2>. \n* Lvalues: Lvalues<2>. \n* Working with pointers@comma{} structs and unions: Working with pointers structs and unions<2>. \n\nRvalues\n\n* Simple expressions: Simple expressions<2>. \n* Unary Operations: Unary Operations<2>. \n* Binary Operations: Binary Operations<2>. \n* Comparisons: Comparisons<2>. \n* Function calls: Function calls<2>. \n* Type-coercion: Type-coercion<2>. \n\nLvalues\n\n* Global variables: Global variables<2>. \n\n@end menu\n\n\n@node Rvalues<2>,Lvalues<2>,,Expressions<2>\n@anchor{cp/topics/expressions rvalues}@anchor{15f}\n@subsubsection Rvalues\n\n\n@geindex gccjit;;rvalue (C++ class)\n@anchor{cp/topics/expressions gccjit rvalue}@anchor{160}\n@deffn {C++ Class} gccjit::rvalue\n@end deffn\n\nA @pxref{160,,gccjit;;rvalue} is an expression that can be computed.  It is a\nsubclass of @pxref{14a,,gccjit;;object}, and is a thin wrapper around\n@pxref{13,,gcc_jit_rvalue *} from the C API.\n\nIt can be simple, e.g.:\n\n@quotation\n\n\n@itemize *\n\n@item \nan integer value e.g. @cite{0} or @cite{42}\n\n@item \na string literal e.g. @cite{\"Hello world\"}\n\n@item \na variable e.g. @cite{i}.  These are also lvalues (see below).\n@end itemize\n@end quotation\n\nor compound e.g.:\n\n@quotation\n\n\n@itemize *\n\n@item \na unary expression e.g. @cite{!cond}\n\n@item \na binary expression e.g. @cite{(a + b)}\n\n@item \na function call e.g. @cite{get_distance (&player_ship@comma{} &target)}\n\n@item \netc.\n@end itemize\n@end quotation\n\nEvery rvalue has an associated type, and the API will check to ensure\nthat types match up correctly (otherwise the context will emit an error).\n\n@geindex gccjit;;rvalue;;get_type (C++ function)\n@anchor{cp/topics/expressions gccjit rvalue get_type}@anchor{161}\n@deffn {C++ Function} gccjit::type gccjit::rvalue::get_type ()\n\nGet the type of this rvalue.\n@end deffn\n\n@menu\n* Simple expressions: Simple expressions<2>. \n* Unary Operations: Unary Operations<2>. \n* Binary Operations: Binary Operations<2>. \n* Comparisons: Comparisons<2>. \n* Function calls: Function calls<2>. \n* Type-coercion: Type-coercion<2>. \n\n@end menu\n\n@node Simple expressions<2>,Unary Operations<2>,,Rvalues<2>\n@anchor{cp/topics/expressions simple-expressions}@anchor{162}\n@subsubsection Simple expressions\n\n\n@geindex gccjit;;context;;new_rvalue (C++ function)\n@anchor{cp/topics/expressions gccjit context new_rvalue__gccjit type iC}@anchor{11d}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_rvalue (gccjit::type numeric_type, int value) const\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{int} value.\n@end deffn\n\n@geindex gccjit;;context;;new_rvalue (C++ function)\n@anchor{cp/topics/expressions gccjit context new_rvalue__gccjit type lC}@anchor{163}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_rvalue (gccjit::type numeric_type, long value) const\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{long} value.\n@end deffn\n\n@geindex gccjit;;context;;zero (C++ function)\n@anchor{cp/topics/expressions gccjit context zero__gccjit typeC}@anchor{119}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::zero (gccjit::type numeric_type) const\n\nGiven a numeric type (integer or floating point), get the rvalue for\nzero.  Essentially this is just a shortcut for:\n\n@example\nctxt.new_rvalue (numeric_type, 0)\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;context;;one (C++ function)\n@anchor{cp/topics/expressions gccjit context one__gccjit typeC}@anchor{164}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::one (gccjit::type numeric_type) const\n\nGiven a numeric type (integer or floating point), get the rvalue for\none.  Essentially this is just a shortcut for:\n\n@example\nctxt.new_rvalue (numeric_type, 1)\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;context;;new_rvalue (C++ function)\n@anchor{cp/topics/expressions gccjit context new_rvalue__gccjit type doubleC}@anchor{165}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_rvalue (gccjit::type numeric_type, double value) const\n\nGiven a numeric type (integer or floating point), build an rvalue for\nthe given constant @code{double} value.\n@end deffn\n\n@geindex gccjit;;context;;new_rvalue (C++ function)\n@anchor{cp/topics/expressions gccjit context new_rvalue__gccjit type voidPC}@anchor{166}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_rvalue (gccjit::type pointer_type, void* value) const\n\nGiven a pointer type, build an rvalue for the given address.\n@end deffn\n\n@geindex gccjit;;context;;new_rvalue (C++ function)\n@anchor{cp/topics/expressions gccjit context new_rvalue__ssCRC}@anchor{167}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_rvalue (const std::string& value) const\n\nGenerate an rvalue of type @code{GCC_JIT_TYPE_CONST_CHAR_PTR} for\nthe given string.  This is akin to a string literal.\n@end deffn\n\n@node Unary Operations<2>,Binary Operations<2>,Simple expressions<2>,Rvalues<2>\n@anchor{cp/topics/expressions unary-operations}@anchor{168}\n@subsubsection Unary Operations\n\n\n@geindex gccjit;;context;;new_unary_op (C++ function)\n@anchor{cp/topics/expressions gccjit context new_unary_op__enum gccjit type gccjit rvalue gccjit location}@anchor{169}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_unary_op (enum gcc_jit_unary_op, gccjit::type result_type, gccjit::rvalue rvalue, gccjit::location loc)\n\nBuild a unary operation out of an input rvalue.\n\nParameter @code{loc} is optional.\n\nThis is a thin wrapper around the C API's\n@pxref{94,,gcc_jit_context_new_unary_op()} and the available unary\noperations are documented there.\n@end deffn\n\nThere are shorter ways to spell the various specific kinds of unary\noperation:\n\n@geindex gccjit;;context;;new_minus (C++ function)\n@anchor{cp/topics/expressions gccjit context new_minus__gccjit type gccjit rvalue gccjit location}@anchor{16a}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_minus (gccjit::type result_type, gccjit::rvalue a, gccjit::location loc)\n\nNegate an arithmetic value; for example:\n\n@example\ngccjit::rvalue negpi = ctxt.new_minus (t_double, pi);\n@end example\n\n@noindent\n\nbuilds the equivalent of this C expression:\n\n@example\n-pi\n@end example\n\n@noindent\n@end deffn\n\n@geindex new_bitwise_negate (C++ function)\n@anchor{cp/topics/expressions new_bitwise_negate__gccjit type gccjit rvalue gccjit location}@anchor{16b}\n@deffn {C++ Function} gccjit::rvalue new_bitwise_negate (gccjit::type result_type, gccjit::rvalue a, gccjit::location loc)\n\nBitwise negation of an integer value (one's complement); for example:\n\n@example\ngccjit::rvalue mask = ctxt.new_bitwise_negate (t_int, a);\n@end example\n\n@noindent\n\nbuilds the equivalent of this C expression:\n\n@example\n~a\n@end example\n\n@noindent\n@end deffn\n\n@geindex new_logical_negate (C++ function)\n@anchor{cp/topics/expressions new_logical_negate__gccjit type gccjit rvalue gccjit location}@anchor{16c}\n@deffn {C++ Function} gccjit::rvalue new_logical_negate (gccjit::type result_type, gccjit::rvalue a, gccjit::location loc)\n\nLogical negation of an arithmetic or pointer value; for example:\n\n@example\ngccjit::rvalue guard = ctxt.new_logical_negate (t_bool, cond);\n@end example\n\n@noindent\n\nbuilds the equivalent of this C expression:\n\n@example\n!cond\n@end example\n\n@noindent\n@end deffn\n\nThe most concise way to spell them is with overloaded operators:\n\n@geindex operator- (C++ function)\n@anchor{cp/topics/expressions sub-operator__gccjit rvalue}@anchor{16d}\n@deffn {C++ Function} gccjit::rvalue operator- (gccjit::rvalue a)\n\n@example\ngccjit::rvalue negpi = -pi;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator~ (C++ function)\n@anchor{cp/topics/expressions inv-operator__gccjit rvalue}@anchor{16e}\n@deffn {C++ Function} gccjit::rvalue operator~ (gccjit::rvalue a)\n\n@example\ngccjit::rvalue mask = ~a;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator! (C++ function)\n@anchor{cp/topics/expressions not-operator__gccjit rvalue}@anchor{16f}\n@deffn {C++ Function} gccjit::rvalue operator! (gccjit::rvalue a)\n\n@example\ngccjit::rvalue guard = !cond;\n@end example\n\n@noindent\n@end deffn\n\n@node Binary Operations<2>,Comparisons<2>,Unary Operations<2>,Rvalues<2>\n@anchor{cp/topics/expressions binary-operations}@anchor{170}\n@subsubsection Binary Operations\n\n\n@geindex gccjit;;context;;new_binary_op (C++ function)\n@anchor{cp/topics/expressions gccjit context new_binary_op__enum gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{10d}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_binary_op (enum gcc_jit_binary_op, gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n\nBuild a binary operation out of two constituent rvalues.\n\nParameter @code{loc} is optional.\n\nThis is a thin wrapper around the C API's\n@pxref{12,,gcc_jit_context_new_binary_op()} and the available binary\noperations are documented there.\n@end deffn\n\nThere are shorter ways to spell the various specific kinds of binary\noperation:\n\n@geindex gccjit;;context;;new_plus (C++ function)\n@anchor{cp/topics/expressions gccjit context new_plus__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{171}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_plus (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_minus (C++ function)\n@anchor{cp/topics/expressions gccjit context new_minus__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{172}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_minus (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_mult (C++ function)\n@anchor{cp/topics/expressions gccjit context new_mult__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{173}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_mult (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_divide (C++ function)\n@anchor{cp/topics/expressions gccjit context new_divide__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{174}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_divide (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_modulo (C++ function)\n@anchor{cp/topics/expressions gccjit context new_modulo__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{175}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_modulo (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_bitwise_and (C++ function)\n@anchor{cp/topics/expressions gccjit context new_bitwise_and__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{176}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_bitwise_and (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_bitwise_xor (C++ function)\n@anchor{cp/topics/expressions gccjit context new_bitwise_xor__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{177}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_bitwise_xor (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_bitwise_or (C++ function)\n@anchor{cp/topics/expressions gccjit context new_bitwise_or__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{178}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_bitwise_or (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_logical_and (C++ function)\n@anchor{cp/topics/expressions gccjit context new_logical_and__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{179}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_logical_and (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_logical_or (C++ function)\n@anchor{cp/topics/expressions gccjit context new_logical_or__gccjit type gccjit rvalue gccjit rvalue gccjit location}@anchor{17a}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_logical_or (gccjit::type result_type, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\nThe most concise way to spell them is with overloaded operators:\n\n@geindex operator+ (C++ function)\n@anchor{cp/topics/expressions add-operator__gccjit rvalue gccjit rvalue}@anchor{17b}\n@deffn {C++ Function} gccjit::rvalue operator+ (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue sum = a + b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator- (C++ function)\n@anchor{cp/topics/expressions sub-operator__gccjit rvalue gccjit rvalue}@anchor{17c}\n@deffn {C++ Function} gccjit::rvalue operator- (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue diff = a - b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator* (C++ function)\n@anchor{cp/topics/expressions mul-operator__gccjit rvalue gccjit rvalue}@anchor{17d}\n@deffn {C++ Function} gccjit::rvalue operator* (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue prod = a * b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator/ (C++ function)\n@anchor{cp/topics/expressions div-operator__gccjit rvalue gccjit rvalue}@anchor{17e}\n@deffn {C++ Function} gccjit::rvalue operator/ (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue result = a / b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator% (C++ function)\n@anchor{cp/topics/expressions mod-operator__gccjit rvalue gccjit rvalue}@anchor{17f}\n@deffn {C++ Function} gccjit::rvalue operator% (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue mod = a % b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator& (C++ function)\n@anchor{cp/topics/expressions and-operator__gccjit rvalue gccjit rvalue}@anchor{180}\n@deffn {C++ Function} gccjit::rvalue operator& (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue x = a & b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator^ (C++ function)\n@anchor{cp/topics/expressions xor-operator__gccjit rvalue gccjit rvalue}@anchor{181}\n@deffn {C++ Function} gccjit::rvalue operator^ (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue x = a ^ b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator| (C++ function)\n@anchor{cp/topics/expressions or-operator__gccjit rvalue gccjit rvalue}@anchor{182}\n@deffn {C++ Function} gccjit::rvalue operator| (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue x = a | b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator&& (C++ function)\n@anchor{cp/topics/expressions sand-operator__gccjit rvalue gccjit rvalue}@anchor{183}\n@deffn {C++ Function} gccjit::rvalue operator&& (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = a && b;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator|| (C++ function)\n@anchor{cp/topics/expressions sor-operator__gccjit rvalue gccjit rvalue}@anchor{184}\n@deffn {C++ Function} gccjit::rvalue operator|| (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = a || b;\n@end example\n\n@noindent\n@end deffn\n\nThese can of course be combined, giving a terse way to build compound\nexpressions:\n\n@quotation\n\n@example\ngccjit::rvalue discriminant = (b * b) - (four * a * c);\n@end example\n\n@noindent\n@end quotation\n\n@node Comparisons<2>,Function calls<2>,Binary Operations<2>,Rvalues<2>\n@anchor{cp/topics/expressions comparisons}@anchor{185}\n@subsubsection Comparisons\n\n\n@geindex gccjit;;context;;new_comparison (C++ function)\n@anchor{cp/topics/expressions gccjit context new_comparison__enum gccjit rvalue gccjit rvalue gccjit location}@anchor{11a}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_comparison (enum gcc_jit_comparison, gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n\nBuild a boolean rvalue out of the comparison of two other rvalues.\n\nParameter @code{loc} is optional.\n\nThis is a thin wrapper around the C API's\n@pxref{2c,,gcc_jit_context_new_comparison()} and the available kinds\nof comparison are documented there.\n@end deffn\n\nThere are shorter ways to spell the various specific kinds of binary\noperation:\n\n@geindex gccjit;;context;;new_eq (C++ function)\n@anchor{cp/topics/expressions gccjit context new_eq__gccjit rvalue gccjit rvalue gccjit location}@anchor{186}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_eq (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_ne (C++ function)\n@anchor{cp/topics/expressions gccjit context new_ne__gccjit rvalue gccjit rvalue gccjit location}@anchor{187}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_ne (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_lt (C++ function)\n@anchor{cp/topics/expressions gccjit context new_lt__gccjit rvalue gccjit rvalue gccjit location}@anchor{188}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_lt (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_le (C++ function)\n@anchor{cp/topics/expressions gccjit context new_le__gccjit rvalue gccjit rvalue gccjit location}@anchor{189}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_le (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_gt (C++ function)\n@anchor{cp/topics/expressions gccjit context new_gt__gccjit rvalue gccjit rvalue gccjit location}@anchor{18a}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_gt (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\n@geindex gccjit;;context;;new_ge (C++ function)\n@anchor{cp/topics/expressions gccjit context new_ge__gccjit rvalue gccjit rvalue gccjit location}@anchor{18b}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_ge (gccjit::rvalue a, gccjit::rvalue b, gccjit::location loc)\n@end deffn\n\nThe most concise way to spell them is with overloaded operators:\n\n@geindex operator== (C++ function)\n@anchor{cp/topics/expressions eq-operator__gccjit rvalue gccjit rvalue}@anchor{18c}\n@deffn {C++ Function} gccjit::rvalue operator== (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = (a == ctxt.zero (t_int));\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator!= (C++ function)\n@anchor{cp/topics/expressions neq-operator__gccjit rvalue gccjit rvalue}@anchor{18d}\n@deffn {C++ Function} gccjit::rvalue operator!= (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = (i != j);\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator< (C++ function)\n@anchor{cp/topics/expressions lt-operator__gccjit rvalue gccjit rvalue}@anchor{18e}\n@deffn {C++ Function} gccjit::rvalue operator< (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = i < n;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator<= (C++ function)\n@anchor{cp/topics/expressions lte-operator__gccjit rvalue gccjit rvalue}@anchor{18f}\n@deffn {C++ Function} gccjit::rvalue operator<= (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = i <= n;\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator> (C++ function)\n@anchor{cp/topics/expressions gt-operator__gccjit rvalue gccjit rvalue}@anchor{190}\n@deffn {C++ Function} gccjit::rvalue operator> (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = (ch > limit);\n@end example\n\n@noindent\n@end deffn\n\n@geindex operator>= (C++ function)\n@anchor{cp/topics/expressions gte-operator__gccjit rvalue gccjit rvalue}@anchor{191}\n@deffn {C++ Function} gccjit::rvalue operator>= (gccjit::rvalue a, gccjit::rvalue b)\n\n@example\ngccjit::rvalue cond = (score >= ctxt.new_rvalue (t_int, 100));\n@end example\n\n@noindent\n@end deffn\n\n@c TODO: beyond this point\n\n@node Function calls<2>,Type-coercion<2>,Comparisons<2>,Rvalues<2>\n@anchor{cp/topics/expressions function-calls}@anchor{192}\n@subsubsection Function calls\n\n\n@geindex gcc_jit_context_new_call (C++ function)\n@anchor{cp/topics/expressions gcc_jit_context_new_call__gcc_jit_contextP gcc_jit_locationP gcc_jit_functionP i gcc_jit_rvaluePP}@anchor{193}\n@deffn {C++ Function} gcc_jit_rvalue* gcc_jit_context_new_call (gcc_jit_context* ctxt, gcc_jit_location* loc, gcc_jit_function* func, int numargs, gcc_jit_rvalue** args)\n\nGiven a function and the given table of argument rvalues, construct a\ncall to the function, with the result as an rvalue.\n\n@cartouche\n@quotation Note \n@code{gccjit::context::new_call()} merely builds a\n@pxref{160,,gccjit;;rvalue} i.e. an expression that can be evaluated,\nperhaps as part of a more complicated expression.\nThe call @emph{won't} happen unless you add a statement to a function\nthat evaluates the expression.\n\nFor example, if you want to call a function and discard the result\n(or to call a function with @code{void} return type), use\n@pxref{194,,gccjit;;block;;add_eval()}:\n\n@example\n/* Add \"(void)printf (arg0, arg1);\".  */\nblock.add_eval (ctxt.new_call (printf_func, arg0, arg1));\n@end example\n\n@noindent\n@end quotation\n@end cartouche\n@end deffn\n\n@node Type-coercion<2>,,Function calls<2>,Rvalues<2>\n@anchor{cp/topics/expressions type-coercion}@anchor{195}\n@subsubsection Type-coercion\n\n\n@geindex gccjit;;context;;new_cast (C++ function)\n@anchor{cp/topics/expressions gccjit context new_cast__gccjit rvalue gccjit type gccjit location}@anchor{196}\n@deffn {C++ Function} gccjit::rvalue gccjit::context::new_cast (gccjit::rvalue rvalue, gccjit::type type, gccjit::location loc)\n\nGiven an rvalue of T, construct another rvalue of another type.\n\nCurrently only a limited set of conversions are possible:\n\n@quotation\n\n\n@itemize *\n\n@item \nint <-> float\n\n@item \nint <-> bool\n\n@item \nP*  <-> Q*, for pointer types P and Q\n@end itemize\n@end quotation\n@end deffn\n\n@node Lvalues<2>,Working with pointers structs and unions<2>,Rvalues<2>,Expressions<2>\n@anchor{cp/topics/expressions lvalues}@anchor{197}\n@subsubsection Lvalues\n\n\n@geindex gccjit;;lvalue (C++ class)\n@anchor{cp/topics/expressions gccjit lvalue}@anchor{198}\n@deffn {C++ Class} gccjit::lvalue\n@end deffn\n\nAn lvalue is something that can of the @emph{left}-hand side of an assignment:\na storage area (such as a variable).  It is a subclass of\n@pxref{160,,gccjit;;rvalue}, where the rvalue is computed by reading from the\nstorage area.\n\nIt iss a thin wrapper around @pxref{24,,gcc_jit_lvalue *} from the C API.\n\n@geindex gccjit;;lvalue;;get_address (C++ function)\n@anchor{cp/topics/expressions gccjit lvalue get_address__gccjit location}@anchor{199}\n@deffn {C++ Function} gccjit::rvalue gccjit::lvalue::get_address (gccjit::location loc)\n\nTake the address of an lvalue; analogous to:\n\n@example\n&(EXPR)\n@end example\n\n@noindent\n\nin C.\n\nParameter \"loc\" is optional.\n@end deffn\n\n@menu\n* Global variables: Global variables<2>. \n\n@end menu\n\n@node Global variables<2>,,,Lvalues<2>\n@anchor{cp/topics/expressions global-variables}@anchor{19a}\n@subsubsection Global variables\n\n\n@geindex gccjit;;context;;new_global (C++ function)\n@anchor{cp/topics/expressions gccjit context new_global__enum gccjit type cCP gccjit location}@anchor{19b}\n@deffn {C++ Function} gccjit::lvalue gccjit::context::new_global (enum gcc_jit_global_kind, gccjit::type type, const char* name, gccjit::location loc)\n\nAdd a new global variable of the given type and name to the context.\n\nThis is a thin wrapper around @pxref{b6,,gcc_jit_context_new_global()} from\nthe C API; the \"kind\" parameter has the same meaning as there.\n@end deffn\n\n@node Working with pointers structs and unions<2>,,Lvalues<2>,Expressions<2>\n@anchor{cp/topics/expressions working-with-pointers-structs-and-unions}@anchor{19c}\n@subsubsection Working with pointers, structs and unions\n\n\n@geindex gccjit;;rvalue;;dereference (C++ function)\n@anchor{cp/topics/expressions gccjit rvalue dereference__gccjit location}@anchor{19d}\n@deffn {C++ Function} gccjit::lvalue gccjit::rvalue::dereference (gccjit::location loc)\n\nGiven an rvalue of pointer type @code{T *}, dereferencing the pointer,\ngetting an lvalue of type @code{T}.  Analogous to:\n\n@example\n*(EXPR)\n@end example\n\n@noindent\n\nin C.\n\nParameter \"loc\" is optional.\n@end deffn\n\nIf you don't need to specify the location, this can also be expressed using\nan overloaded operator:\n\n@geindex gccjit;;rvalue;;operator* (C++ function)\n@anchor{cp/topics/expressions gccjit rvalue mul-operator}@anchor{19e}\n@deffn {C++ Function} gccjit::lvalue gccjit::rvalue::operator* ()\n\n@example\ngccjit::lvalue content = *ptr;\n@end example\n\n@noindent\n@end deffn\n\nField access is provided separately for both lvalues and rvalues:\n\n@geindex gccjit;;lvalue;;access_field (C++ function)\n@anchor{cp/topics/expressions gccjit lvalue access_field__gccjit field gccjit location}@anchor{19f}\n@deffn {C++ Function} gccjit::lvalue gccjit::lvalue::access_field (gccjit::field field, gccjit::location loc)\n\nGiven an lvalue of struct or union type, access the given field,\ngetting an lvalue of the field's type.  Analogous to:\n\n@example\n(EXPR).field = ...;\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex gccjit;;rvalue;;access_field (C++ function)\n@anchor{cp/topics/expressions gccjit rvalue access_field__gccjit field gccjit location}@anchor{1a0}\n@deffn {C++ Function} gccjit::rvalue gccjit::rvalue::access_field (gccjit::field field, gccjit::location loc)\n\nGiven an rvalue of struct or union type, access the given field\nas an rvalue.  Analogous to:\n\n@example\n(EXPR).field\n@end example\n\n@noindent\n\nin C.\n@end deffn\n\n@geindex gccjit;;rvalue;;dereference_field (C++ function)\n@anchor{cp/topics/expressions gccjit rvalue dereference_field__gccjit field gccjit location}@anchor{1a1}\n@deffn {C++ Function} gccjit::lvalue gccjit::rvalue::dereference_field (gccjit::field field, gccjit::location loc)\n\nGiven an rvalue of pointer type @code{T *} where T is of struct or union\ntype, access the given field as an lvalue.  Analogous to:\n\n@example\n(EXPR)->field\n@end example\n\n@noindent\n\nin C, itself equivalent to @code{(*EXPR).FIELD}.\n@end deffn\n\n@geindex gccjit;;context;;new_array_access (C++ function)\n@anchor{cp/topics/expressions gccjit context new_array_access__gccjit rvalue gccjit rvalue gccjit location}@anchor{1a2}\n@deffn {C++ Function} gccjit::lvalue gccjit::context::new_array_access (gccjit::rvalue ptr, gccjit::rvalue index, gccjit::location loc)\n\nGiven an rvalue of pointer type @code{T *}, get at the element @cite{T} at\nthe given index, using standard C array indexing rules i.e. each\nincrement of @code{index} corresponds to @code{sizeof(T)} bytes.\nAnalogous to:\n\n@example\nPTR[INDEX]\n@end example\n\n@noindent\n\nin C (or, indeed, to @code{PTR + INDEX}).\n\nParameter \"loc\" is optional.\n@end deffn\n\nFor array accesses where you don't need to specify a @pxref{13d,,gccjit;;location},\ntwo overloaded operators are available:\n\n@quotation\n\ngccjit::lvalue gccjit::rvalue::operator[] (gccjit::rvalue index)\n\n@example\ngccjit::lvalue element = array[idx];\n@end example\n\n@noindent\n\ngccjit::lvalue gccjit::rvalue::operator[] (int index)\n\n@example\ngccjit::lvalue element = array[0];\n@end example\n\n@noindent\n@end quotation\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Creating and using functions<2>,Source Locations<2>,Expressions<2>,Topic Reference<2>\n@anchor{cp/topics/functions doc}@anchor{1a3}@anchor{cp/topics/functions creating-and-using-functions}@anchor{1a4}\n@subsection Creating and using functions\n\n\n@menu\n* Params: Params<2>. \n* Functions: Functions<2>. \n* Blocks: Blocks<2>. \n* Statements: Statements<2>. \n\n@end menu\n\n@node Params<2>,Functions<2>,,Creating and using functions<2>\n@anchor{cp/topics/functions params}@anchor{1a5}\n@subsubsection Params\n\n\n@geindex gccjit;;param (C++ class)\n@anchor{cp/topics/functions gccjit param}@anchor{1a6}\n@deffn {C++ Class} gccjit::param\n\nA @cite{gccjit::param} represents a parameter to a function.\n@end deffn\n\n@geindex gccjit;;context;;new_param (C++ function)\n@anchor{cp/topics/functions gccjit context new_param__gccjit type cCP gccjit location}@anchor{10c}\n@deffn {C++ Function} gccjit::param gccjit::context::new_param (gccjit::type type, const char* name, gccjit::location loc)\n\nIn preparation for creating a function, create a new parameter of the\ngiven type and name.\n@end deffn\n\n@pxref{1a6,,gccjit;;param} is a subclass of @pxref{198,,gccjit;;lvalue} (and thus\nof @pxref{160,,gccjit;;rvalue} and @pxref{14a,,gccjit;;object}).  It is a thin\nwrapper around the C API's @pxref{25,,gcc_jit_param *}.\n\n@node Functions<2>,Blocks<2>,Params<2>,Creating and using functions<2>\n@anchor{cp/topics/functions functions}@anchor{1a7}\n@subsubsection Functions\n\n\n@geindex gccjit;;function (C++ class)\n@anchor{cp/topics/functions gccjit function}@anchor{1a8}\n@deffn {C++ Class} gccjit::function\n\nA @cite{gccjit::function} represents a function - either one that we're\ncreating ourselves, or one that we're referencing.\n@end deffn\n\n@geindex gccjit;;context;;new_function (C++ function)\n@anchor{cp/topics/functions gccjit context new_function__enum gccjit type cCP std vector param R i gccjit location}@anchor{1a9}\n@deffn {C++ Function} gccjit::function gccjit::context::new_function (enum gcc_jit_function_kind, gccjit::type return_type, const char* name, std::vector<param>& params, int is_variadic, gccjit::location loc)\n\nCreate a gcc_jit_function with the given name and parameters.\n\nParameters \"is_variadic\" and \"loc\" are optional.\n\nThis is a wrapper around the C API's @pxref{11,,gcc_jit_context_new_function()}.\n@end deffn\n\n@geindex gccjit;;context;;get_builtin_function (C++ function)\n@anchor{cp/topics/functions gccjit context get_builtin_function__cCP}@anchor{1aa}\n@deffn {C++ Function} gccjit::function gccjit::context::get_builtin_function (const char* name)\n\nThis is a wrapper around the C API's\n@pxref{cd,,gcc_jit_context_get_builtin_function()}.\n@end deffn\n\n@geindex gccjit;;function;;get_param (C++ function)\n@anchor{cp/topics/functions gccjit function get_param__iC}@anchor{1ab}\n@deffn {C++ Function} gccjit::param gccjit::function::get_param (int index) const\n\nGet the param of the given index (0-based).\n@end deffn\n\n@geindex gccjit;;function;;dump_to_dot (C++ function)\n@anchor{cp/topics/functions gccjit function dump_to_dot__cCP}@anchor{11f}\n@deffn {C++ Function} void gccjit::function::dump_to_dot (const char* path)\n\nEmit the function in graphviz format to the given path.\n@end deffn\n\n@geindex gccjit;;function;;new_local (C++ function)\n@anchor{cp/topics/functions gccjit function new_local__gccjit type cCP gccjit location}@anchor{116}\n@deffn {C++ Function} gccjit::lvalue gccjit::function::new_local (gccjit::type type, const char* name, gccjit::location loc)\n\nCreate a new local variable within the function, of the given type and\nname.\n@end deffn\n\n@node Blocks<2>,Statements<2>,Functions<2>,Creating and using functions<2>\n@anchor{cp/topics/functions blocks}@anchor{1ac}\n@subsubsection Blocks\n\n\n@geindex gccjit;;block (C++ class)\n@anchor{cp/topics/functions gccjit block}@anchor{1ad}\n@deffn {C++ Class} gccjit::block\n\nA @cite{gccjit::block} represents a basic block within a function  i.e. a\nsequence of statements with a single entry point and a single exit\npoint.\n\n@pxref{1ad,,gccjit;;block} is a subclass of @pxref{14a,,gccjit;;object}.\n\nThe first basic block that you create within a function will\nbe the entrypoint.\n\nEach basic block that you create within a function must be\nterminated, either with a conditional, a jump, a return, or\na switch.\n\nIt's legal to have multiple basic blocks that return within\none function.\n@end deffn\n\n@geindex gccjit;;function;;new_block (C++ function)\n@anchor{cp/topics/functions gccjit function new_block__cCP}@anchor{1ae}\n@deffn {C++ Function} gccjit::block gccjit::function::new_block (const char* name)\n\nCreate a basic block of the given name.  The name may be NULL, but\nproviding meaningful names is often helpful when debugging: it may\nshow up in dumps of the internal representation, and in error\nmessages.\n@end deffn\n\n@node Statements<2>,,Blocks<2>,Creating and using functions<2>\n@anchor{cp/topics/functions statements}@anchor{1af}\n@subsubsection Statements\n\n\n@geindex gccjit;;block;;add_eval (C++ function)\n@anchor{cp/topics/functions gccjit block add_eval__gccjit rvalue gccjit location}@anchor{194}\n@deffn {C++ Function} void gccjit::block::add_eval (gccjit::rvalue rvalue, gccjit::location loc)\n\nAdd evaluation of an rvalue, discarding the result\n(e.g. a function call that \"returns\" void).\n\nThis is equivalent to this C code:\n\n@example\n(void)expression;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;block;;add_assignment (C++ function)\n@anchor{cp/topics/functions gccjit block add_assignment__gccjit lvalue gccjit rvalue gccjit location}@anchor{118}\n@deffn {C++ Function} void gccjit::block::add_assignment (gccjit::lvalue lvalue, gccjit::rvalue rvalue, gccjit::location loc)\n\nAdd evaluation of an rvalue, assigning the result to the given\nlvalue.\n\nThis is roughly equivalent to this C code:\n\n@example\nlvalue = rvalue;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;block;;add_assignment_op (C++ function)\n@anchor{cp/topics/functions gccjit block add_assignment_op__gccjit lvalue enum gccjit rvalue gccjit location}@anchor{11c}\n@deffn {C++ Function} void gccjit::block::add_assignment_op (gccjit::lvalue lvalue, enum gcc_jit_binary_op, gccjit::rvalue rvalue, gccjit::location loc)\n\nAdd evaluation of an rvalue, using the result to modify an\nlvalue.\n\nThis is analogous to \"+=\" and friends:\n\n@example\nlvalue += rvalue;\nlvalue *= rvalue;\nlvalue /= rvalue;\n@end example\n\n@noindent\n\netc.  For example:\n\n@example\n/* \"i++\" */\nloop_body.add_assignment_op (\n  i,\n  GCC_JIT_BINARY_OP_PLUS,\n  ctxt.one (int_type));\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;block;;add_comment (C++ function)\n@anchor{cp/topics/functions gccjit block add_comment__cCP gccjit location}@anchor{127}\n@deffn {C++ Function} void gccjit::block::add_comment (const char* text, gccjit::location loc)\n\nAdd a no-op textual comment to the internal representation of the\ncode.  It will be optimized away, but will be visible in the dumps\nseen via @pxref{66,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}\nand @pxref{1c,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE},\nand thus may be of use when debugging how your project's internal\nrepresentation gets converted to the libgccjit IR.\n\nParameter \"loc\" is optional.\n@end deffn\n\n@geindex gccjit;;block;;end_with_conditional (C++ function)\n@anchor{cp/topics/functions gccjit block end_with_conditional__gccjit rvalue gccjit block gccjit block gccjit location}@anchor{11b}\n@deffn {C++ Function} void gccjit::block::end_with_conditional (gccjit::rvalue boolval, gccjit::block on_true, gccjit::block on_false, gccjit::location loc)\n\nTerminate a block by adding evaluation of an rvalue, branching on the\nresult to the appropriate successor block.\n\nThis is roughly equivalent to this C code:\n\n@example\nif (boolval)\n  goto on_true;\nelse\n  goto on_false;\n@end example\n\n@noindent\n\nblock, boolval, on_true, and on_false must be non-NULL.\n@end deffn\n\n@geindex gccjit;;block;;end_with_jump (C++ function)\n@anchor{cp/topics/functions gccjit block end_with_jump__gccjit block gccjit location}@anchor{1b0}\n@deffn {C++ Function} void gccjit::block::end_with_jump (gccjit::block target, gccjit::location loc)\n\nTerminate a block by adding a jump to the given target block.\n\nThis is roughly equivalent to this C code:\n\n@example\ngoto target;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;block;;end_with_return (C++ function)\n@anchor{cp/topics/functions gccjit block end_with_return__gccjit rvalue gccjit location}@anchor{1b1}\n@deffn {C++ Function} void gccjit::block::end_with_return (gccjit::rvalue rvalue, gccjit::location loc)\n\nTerminate a block.\n\nBoth params are optional.\n\nAn rvalue must be provided for a function returning non-void, and\nmust not be provided by a function \"returning\" @cite{void}.\n\nIf an rvalue is provided, the block is terminated by evaluating the\nrvalue and returning the value.\n\nThis is roughly equivalent to this C code:\n\n@example\nreturn expression;\n@end example\n\n@noindent\n\nIf an rvalue is not provided, the block is terminated by adding a\nvalueless return, for use within a function with \"void\" return type.\n\nThis is equivalent to this C code:\n\n@example\nreturn;\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;block;;end_with_switch (C++ function)\n@anchor{cp/topics/functions gccjit block end_with_switch__gccjit rvalue gccjit block std vector gccjit case_ gccjit location}@anchor{1b2}\n@deffn {C++ Function} void gccjit::block::end_with_switch (gccjit::rvalue expr, gccjit::block default_block, std::vector<gccjit::case_> cases, gccjit::location loc)\n\nTerminate a block by adding evalation of an rvalue, then performing\na multiway branch.\n\nThis is roughly equivalent to this C code:\n\n@example\nswitch (expr)\n  @{\n  default:\n    goto default_block;\n\n  case C0.min_value ... C0.max_value:\n    goto C0.dest_block;\n\n  case C1.min_value ... C1.max_value:\n    goto C1.dest_block;\n\n  ...etc...\n\n  case C[N - 1].min_value ... C[N - 1].max_value:\n    goto C[N - 1].dest_block;\n@}\n@end example\n\n@noindent\n\n@code{expr} must be of the same integer type as all of the @code{min_value}\nand @code{max_value} within the cases.\n\nThe ranges of the cases must not overlap (or have duplicate\nvalues).\n\nThe API entrypoints relating to switch statements and cases:\n\n@quotation\n\n\n@itemize *\n\n@item \n@pxref{1b2,,gccjit;;block;;end_with_switch()}\n\n@item \n@pxref{1b3,,gccjit;;context;;new_case()}\n@end itemize\n@end quotation\n\nwere added in @pxref{db,,LIBGCCJIT_ABI_3}; you can test for their presence\nusing\n\n@example\n#ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n@end example\n\n@noindent\n\n@geindex gccjit;;block;;end_with_switch;;gccjit;;case_ (C++ class)\n@anchor{cp/topics/functions gccjit block end_with_switch gccjit case_}@anchor{1b4}\n@deffn {C++ Class} gccjit::case_\n@end deffn\n\nA @cite{gccjit::case_} represents a case within a switch statement, and\nis created within a particular @pxref{135,,gccjit;;context} using\n@pxref{1b3,,gccjit;;context;;new_case()}.  It is a subclass of\n@pxref{14a,,gccjit;;object}.\n\nEach case expresses a multivalued range of integer values.  You\ncan express single-valued cases by passing in the same value for\nboth @cite{min_value} and @cite{max_value}.\n\n@geindex gccjit;;block;;end_with_switch;;gccjit;;context;;new_case (C++ function)\n@anchor{cp/topics/functions gccjit block end_with_switch gccjit context new_case__gccjit rvalue gccjit rvalue gccjit block}@anchor{1b3}\n@deffn {C++ Function} gccjit::case_* gccjit::context::new_case (gccjit::rvalue min_value, gccjit::rvalue max_value, gccjit::block dest_block)\n\nCreate a new gccjit::case for use in a switch statement.\n@cite{min_value} and @cite{max_value} must be constants of an integer type,\nwhich must match that of the expression of the switch statement.\n\n@cite{dest_block} must be within the same function as the switch\nstatement.\n@end deffn\n\nHere's an example of creating a switch statement:\n\n@quotation\n\n@example\n\nvoid\ncreate_code (gcc_jit_context *c_ctxt, void *user_data)\n@{\n  /* Let's try to inject the equivalent of:\n      int\n      test_switch (int x)\n      @{\n\tswitch (x)\n\t  @{\n\t  case 0 ... 5:\n\t     return 3;\n\n\t  case 25 ... 27:\n\t     return 4;\n\n\t  case -42 ... -17:\n\t     return 83;\n\n\t  case 40:\n\t     return 8;\n\n\t  default:\n\t     return 10;\n\t  @}\n      @}\n   */\n  gccjit::context ctxt (c_ctxt);\n  gccjit::type t_int = ctxt.get_type (GCC_JIT_TYPE_INT);\n  gccjit::type return_type = t_int;\n  gccjit::param x = ctxt.new_param (t_int, \"x\");\n  std::vector <gccjit::param> params;\n  params.push_back (x);\n  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n                                             return_type,\n                                             \"test_switch\",\n                                             params, 0);\n\n  gccjit::block b_initial = func.new_block (\"initial\");\n\n  gccjit::block b_default = func.new_block (\"default\");\n  gccjit::block b_case_0_5 = func.new_block (\"case_0_5\");\n  gccjit::block b_case_25_27 = func.new_block (\"case_25_27\");\n  gccjit::block b_case_m42_m17 = func.new_block (\"case_m42_m17\");\n  gccjit::block b_case_40 = func.new_block (\"case_40\");\n\n  std::vector <gccjit::case_> cases;\n  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 0),\n                                  ctxt.new_rvalue (t_int, 5),\n                                  b_case_0_5));\n  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 25),\n                                  ctxt.new_rvalue (t_int, 27),\n                                  b_case_25_27));\n  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, -42),\n                                  ctxt.new_rvalue (t_int, -17),\n                                  b_case_m42_m17));\n  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 40),\n                                  ctxt.new_rvalue (t_int, 40),\n                                  b_case_40));\n  b_initial.end_with_switch (x,\n                             b_default,\n                             cases);\n\n  b_case_0_5.end_with_return (ctxt.new_rvalue (t_int, 3));\n  b_case_25_27.end_with_return (ctxt.new_rvalue (t_int, 4));\n  b_case_m42_m17.end_with_return (ctxt.new_rvalue (t_int, 83));\n  b_case_40.end_with_return (ctxt.new_rvalue (t_int, 8));\n  b_default.end_with_return (ctxt.new_rvalue (t_int, 10));\n@}\n\n\n@end example\n\n@noindent\n@end quotation\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Source Locations<2>,Compiling a context<2>,Creating and using functions<2>,Topic Reference<2>\n@anchor{cp/topics/locations source-locations}@anchor{1b5}@anchor{cp/topics/locations doc}@anchor{1b6}\n@subsection Source Locations\n\n\n@geindex gccjit;;location (C++ class)\n@anchor{cp/topics/locations gccjit location}@anchor{13d}\n@deffn {C++ Class} gccjit::location\n\nA @cite{gccjit::location} encapsulates a source code location, so that\nyou can (optionally) associate locations in your language with\nstatements in the JIT-compiled code, allowing the debugger to\nsingle-step through your language.\n\n@cite{gccjit::location} instances are optional: you can always omit them\nfrom any C++ API entrypoint accepting one.\n\nYou can construct them using @pxref{12b,,gccjit;;context;;new_location()}.\n\nYou need to enable @pxref{42,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n@pxref{135,,gccjit;;context} for these locations to actually be usable by\nthe debugger:\n\n@example\nctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO, 1);\n@end example\n\n@noindent\n@end deffn\n\n@geindex gccjit;;context;;new_location (C++ function)\n@anchor{cp/topics/locations gccjit context new_location__cCP i i}@anchor{12b}\n@deffn {C++ Function} gccjit::location gccjit::context::new_location (const char* filename, int line, int column)\n\nCreate a @cite{gccjit::location} instance representing the given source\nlocation.\n@end deffn\n\n@menu\n* Faking it: Faking it<2>. \n\n@end menu\n\n@node Faking it<2>,,,Source Locations<2>\n@anchor{cp/topics/locations faking-it}@anchor{1b7}\n@subsubsection Faking it\n\n\nIf you don't have source code for your internal representation, but need\nto debug, you can generate a C-like representation of the functions in\nyour context using @pxref{13c,,gccjit;;context;;dump_to_file()}:\n\n@example\nctxt.dump_to_file (\"/tmp/something.c\",\n                   1 /* update_locations */);\n@end example\n\n@noindent\n\nThis will dump C-like code to the given path.  If the @cite{update_locations}\nargument is true, this will also set up @cite{gccjit::location} information\nthroughout the context, pointing at the dump file as if it were a source\nfile, giving you @emph{something} you can step through in the debugger.\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Compiling a context<2>,,Source Locations<2>,Topic Reference<2>\n@anchor{cp/topics/compilation compiling-a-context}@anchor{1b8}@anchor{cp/topics/compilation doc}@anchor{1b9}\n@subsection Compiling a context\n\n\nOnce populated, a @pxref{135,,gccjit;;context} can be compiled to\nmachine code, either in-memory via @pxref{10e,,gccjit;;context;;compile()} or\nto disk via @pxref{1ba,,gccjit;;context;;compile_to_file()}.\n\nYou can compile a context multiple times (using either form of\ncompilation), although any errors that occur on the context will\nprevent any future compilation of that context.\n\n@menu\n* In-memory compilation: In-memory compilation<2>. \n* Ahead-of-time compilation: Ahead-of-time compilation<2>. \n\n@end menu\n\n@node In-memory compilation<2>,Ahead-of-time compilation<2>,,Compiling a context<2>\n@anchor{cp/topics/compilation in-memory-compilation}@anchor{1bb}\n@subsubsection In-memory compilation\n\n\n@geindex gccjit;;context;;compile (C++ function)\n@anchor{cp/topics/compilation gccjit context compile}@anchor{10e}\n@deffn {C++ Function} gcc_jit_result* gccjit::context::compile ()\n\nThis calls into GCC and builds the code, returning a\n@cite{gcc_jit_result *}.\n\nThis is a thin wrapper around the\n@pxref{15,,gcc_jit_context_compile()} API entrypoint.\n@end deffn\n\n@node Ahead-of-time compilation<2>,,In-memory compilation<2>,Compiling a context<2>\n@anchor{cp/topics/compilation ahead-of-time-compilation}@anchor{1bc}\n@subsubsection Ahead-of-time compilation\n\n\nAlthough libgccjit is primarily aimed at just-in-time compilation, it\ncan also be used for implementing more traditional ahead-of-time\ncompilers, via the @pxref{1ba,,gccjit;;context;;compile_to_file()} method.\n\n@geindex gccjit;;context;;compile_to_file (C++ function)\n@anchor{cp/topics/compilation gccjit context compile_to_file__enum cCP}@anchor{1ba}\n@deffn {C++ Function} void gccjit::context::compile_to_file (enum gcc_jit_output_kind, const char* output_path)\n\nCompile the @pxref{135,,gccjit;;context} to a file of the given\nkind.\n\nThis is a thin wrapper around the\n@pxref{4a,,gcc_jit_context_compile_to_file()} API entrypoint.\n@end deffn\n\n@c Copyright (C) 2014-2017 Free Software Foundation, Inc.\n@c Originally contributed by David Malcolm <dmalcolm@redhat.com>\n@c \n@c This is free software: you can redistribute it and/or modify it\n@c under the terms of the GNU General Public License as published by\n@c the Free Software Foundation, either version 3 of the License, or\n@c (at your option) any later version.\n@c \n@c This program is distributed in the hope that it will be useful, but\n@c WITHOUT ANY WARRANTY; without even the implied warranty of\n@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@c General Public License for more details.\n@c \n@c You should have received a copy of the GNU General Public License\n@c along with this program.  If not, see\n@c <http://www.gnu.org/licenses/>.\n\n@node Internals,Indices and tables,C++ bindings for libgccjit,Top\n@anchor{internals/index internals}@anchor{1bd}@anchor{internals/index doc}@anchor{1be}\n@chapter Internals\n\n\n@menu\n* Working on the JIT library:: \n* Running the test suite:: \n* Environment variables:: \n* Packaging notes:: \n* Overview of code structure:: \n* Design notes:: \n* Submitting patches:: \n\n@end menu\n\n@node Working on the JIT library,Running the test suite,,Internals\n@anchor{internals/index working-on-the-jit-library}@anchor{1bf}\n@section Working on the JIT library\n\n\nHaving checked out the source code (to \"src\"), you can configure and build\nthe JIT library like this:\n\n@example\nmkdir build\nmkdir install\nPREFIX=$(pwd)/install\ncd build\n../src/configure \\\n   --enable-host-shared \\\n   --enable-languages=jit,c++ \\\n   --disable-bootstrap \\\n   --enable-checking=release \\\n   --prefix=$PREFIX\nnice make -j4 # altering the \"4\" to however many cores you have\n@end example\n\n@noindent\n\nThis should build a libgccjit.so within jit/build/gcc:\n\n@example\n[build] $ file gcc/libgccjit.so*\ngcc/libgccjit.so:       symbolic link to `libgccjit.so.0'\ngcc/libgccjit.so.0:     symbolic link to `libgccjit.so.0.0.1'\ngcc/libgccjit.so.0.0.1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped\n@end example\n\n@noindent\n\nHere's what those configuration options mean:\n\n@geindex command line option; --enable-host-shared\n@anchor{internals/index cmdoption--enable-host-shared}@anchor{1c0}\n@deffn {Option} --enable-host-shared\n\nConfiguring with this option means that the compiler is built as\nposition-independent code, which incurs a slight performance hit,\nbut it necessary for a shared library.\n@end deffn\n\n@geindex command line option; --enable-languages=jit@comma{}c++\n@anchor{internals/index cmdoption--enable-languages}@anchor{1c1}\n@deffn {Option} --enable-languages=jit,c++\n\nThis specifies which frontends to build.  The JIT library looks like\na frontend to the rest of the code.\n\nThe C++ portion of the JIT test suite requires the C++ frontend to be\nenabled at configure-time, or you may see errors like this when\nrunning the test suite:\n\n@example\nxgcc: error: /home/david/jit/src/gcc/testsuite/jit.dg/test-quadratic.cc: C++ compiler not installed on this system\nc++: error trying to exec 'cc1plus': execvp: No such file or directory\n@end example\n\n@noindent\n@end deffn\n\n@geindex command line option; --disable-bootstrap\n@anchor{internals/index cmdoption--disable-bootstrap}@anchor{1c2}\n@deffn {Option} --disable-bootstrap\n\nFor hacking on the \"jit\" subdirectory, performing a full\nbootstrap can be overkill, since it's unused by a bootstrap.  However,\nwhen submitting patches, you should remove this option, to ensure that\nthe compiler can still bootstrap itself.\n@end deffn\n\n@geindex command line option; --enable-checking=release\n@anchor{internals/index cmdoption--enable-checking}@anchor{1c3}\n@deffn {Option} --enable-checking=release\n\nThe compile can perform extensive self-checking as it runs, useful when\ndebugging, but slowing things down.\n\nFor maximum speed, configure with @code{--enable-checking=release} to\ndisable this self-checking.\n@end deffn\n\n@node Running the test suite,Environment variables,Working on the JIT library,Internals\n@anchor{internals/index running-the-test-suite}@anchor{1c4}\n@section Running the test suite\n\n\n@example\n[build] $ cd gcc\n[gcc] $ make check-jit RUNTESTFLAGS=\"-v -v -v\"\n@end example\n\n@noindent\n\nA summary of the tests can then be seen in:\n\n@example\njit/build/gcc/testsuite/jit/jit.sum\n@end example\n\n@noindent\n\nand detailed logs in:\n\n@example\njit/build/gcc/testsuite/jit/jit.log\n@end example\n\n@noindent\n\nThe test executables can be seen as:\n\n@example\njit/build/gcc/testsuite/jit/*.exe\n@end example\n\n@noindent\n\nwhich can be run independently.\n\nYou can compile and run individual tests by passing \"jit.exp=TESTNAME\" to RUNTESTFLAGS e.g.:\n\n@example\n[gcc] $ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=test-factorial.c\"\n@end example\n\n@noindent\n\nand once a test has been compiled, you can debug it directly:\n\n@example\n[gcc] $ PATH=.:$PATH \\\n        LD_LIBRARY_PATH=. \\\n        LIBRARY_PATH=. \\\n          gdb --args \\\n            testsuite/jit/test-factorial.c.exe\n@end example\n\n@noindent\n\n@menu\n* Running under valgrind:: \n\n@end menu\n\n@node Running under valgrind,,,Running the test suite\n@anchor{internals/index running-under-valgrind}@anchor{1c5}\n@subsection Running under valgrind\n\n\nThe jit testsuite detects if RUN_UNDER_VALGRIND is present in the\nenvironment (with any value).  If it is present, it runs the test client\ncode under valgrind@footnote{http://valgrind.org},\nspecifcally, the default\nmemcheck@footnote{http://valgrind.org/docs/manual/mc-manual.html}\ntool with\n--leak-check=full@footnote{http://valgrind.org/docs/manual/mc-manual.html#opt.leak-check}.\n\nIt automatically parses the output from valgrind, injecting XFAIL results if\nany issues are found, or PASS results if the output is clean.  The output\nis saved to @code{TESTNAME.exe.valgrind.txt}.\n\nFor example, the following invocation verbosely runs the testcase\n@code{test-sum-of-squares.c} under valgrind, showing an issue:\n\n@example\n$ RUN_UNDER_VALGRIND= \\\n    make check-jit \\\n      RUNTESTFLAGS=\"-v -v -v jit.exp=test-sum-of-squares.c\"\n\n(...verbose log contains detailed valgrind errors, if any...)\n\n                === jit Summary ===\n\n# of expected passes            28\n# of expected failures          2\n\n$ less testsuite/jit/jit.sum\n(...other results...)\nXFAIL: jit.dg/test-sum-of-squares.c: test-sum-of-squares.c.exe.valgrind.txt: definitely lost: 8 bytes in 1 blocks\nXFAIL: jit.dg/test-sum-of-squares.c: test-sum-of-squares.c.exe.valgrind.txt: unsuppressed errors: 1\n(...other results...)\n\n$ less testsuite/jit/test-sum-of-squares.c.exe.valgrind.txt\n(...shows full valgrind report for this test case...)\n@end example\n\n@noindent\n\nWhen running under valgrind, it's best to have configured gcc with\n@code{--enable-valgrind-annotations}, which automatically suppresses\nvarious known false positives.\n\n@node Environment variables,Packaging notes,Running the test suite,Internals\n@anchor{internals/index environment-variables}@anchor{1c6}\n@section Environment variables\n\n\nWhen running client code against a locally-built libgccjit, three\nenvironment variables need to be set up:\n\n@geindex environment variable; LD_LIBRARY_PATH\n@anchor{internals/index envvar-LD_LIBRARY_PATH}@anchor{1c7}\n@deffn {Environment Variable} LD_LIBRARY_PATH\n\n@quotation\n\n@cite{libgccjit.so} is dynamically linked into client code, so if running\nagainst a locally-built library, @code{LD_LIBRARY_PATH} needs to be set\nup appropriately.  The library can be found within the \"gcc\"\nsubdirectory of the build tree:\n@end quotation\n\n@example\n$ file libgccjit.so*\nlibgccjit.so:       symbolic link to `libgccjit.so.0'\nlibgccjit.so.0:     symbolic link to `libgccjit.so.0.0.1'\nlibgccjit.so.0.0.1: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, not stripped\n@end example\n\n@noindent\n@end deffn\n\n@geindex environment variable; PATH\n@anchor{internals/index envvar-PATH}@anchor{1c8}\n@deffn {Environment Variable} PATH\n\nThe library uses a driver executable for converting from .s assembler\nfiles to .so shared libraries.  Specifically, it looks for a name\nexpanded from\n@code{$@{target_noncanonical@}-gcc-$@{gcc_BASEVER@}$@{exeext@}}\nsuch as @code{x86_64-unknown-linux-gnu-gcc-5.0.0}.\n\nHence @code{PATH} needs to include a directory where the library can\nlocate this executable.\n\nThe executable is normally installed to the installation bindir\n(e.g. /usr/bin), but a copy is also created within the \"gcc\"\nsubdirectory of the build tree for running the testsuite, and for ease\nof development.\n@end deffn\n\n@geindex environment variable; LIBRARY_PATH\n@anchor{internals/index envvar-LIBRARY_PATH}@anchor{1c9}\n@deffn {Environment Variable} LIBRARY_PATH\n\nThe driver executable invokes the linker, and the latter needs to locate\nsupport libraries needed by the generated code, or you will see errors\nlike:\n\n@example\nld: cannot find crtbeginS.o: No such file or directory\nld: cannot find -lgcc\nld: cannot find -lgcc_s\n@end example\n\n@noindent\n\nHence if running directly from a locally-built copy (without installing),\n@code{LIBRARY_PATH} needs to contain the \"gcc\" subdirectory of the build\ntree.\n@end deffn\n\nFor example, to run a binary that uses the library against a non-installed\nbuild of the library in LIBGCCJIT_BUILD_DIR you need an invocation of the\nclient code like this, to preprend the dir to each of the environment\nvariables:\n\n@example\n$ LD_LIBRARY_PATH=$(LIBGCCJIT_BUILD_DIR):$(LD_LIBRARY_PATH) \\\n  PATH=$(LIBGCCJIT_BUILD_DIR):$(PATH) \\\n  LIBRARY_PATH=$(LIBGCCJIT_BUILD_DIR):$(LIBRARY_PATH) \\\n    ./jit-hello-world\nhello world\n@end example\n\n@noindent\n\n@node Packaging notes,Overview of code structure,Environment variables,Internals\n@anchor{internals/index packaging-notes}@anchor{1ca}\n@section Packaging notes\n\n\nThe configure-time option @pxref{1c0,,--enable-host-shared} is needed when\nbuilding the jit in order to get position-independent code.  This will\nslow down the regular compiler by a few percent.  Hence when packaging gcc\nwith libgccjit, please configure and build twice:\n\n@quotation\n\n\n@itemize *\n\n@item \nonce without @pxref{1c0,,--enable-host-shared} for most languages, and\n\n@item \nonce with @pxref{1c0,,--enable-host-shared} for the jit\n@end itemize\n@end quotation\n\nFor example:\n\n@example\n# Configure and build with --enable-host-shared\n# for the jit:\nmkdir configuration-for-jit\npushd configuration-for-jit\n$(SRCDIR)/configure \\\n  --enable-host-shared \\\n  --enable-languages=jit \\\n  --prefix=$(DESTDIR)\nmake\npopd\n\n# Configure and build *without* --enable-host-shared\n# for maximum speed:\nmkdir standard-configuration\npushd standard-configuration\n$(SRCDIR)/configure \\\n  --enable-languages=all \\\n  --prefix=$(DESTDIR)\nmake\npopd\n\n# Both of the above are configured to install to $(DESTDIR)\n# Install the configuration with --enable-host-shared first\n# *then* the one without, so that the faster build\n# of \"cc1\" et al overwrites the slower build.\npushd configuration-for-jit\nmake install\npopd\n\npushd standard-configuration\nmake install\npopd\n@end example\n\n@noindent\n\n@node Overview of code structure,Design notes,Packaging notes,Internals\n@anchor{internals/index overview-of-code-structure}@anchor{1cb}\n@section Overview of code structure\n\n\nThe library is implemented in C++.  The source files have the @code{.c}\nextension for legacy reasons.\n\n\n@itemize *\n\n@item \n@code{libgccjit.c} implements the API entrypoints.  It performs error\nchecking, then calls into classes of the gcc::jit::recording namespace\nwithin @code{jit-recording.c} and @code{jit-recording.h}.\n\n@item \nThe gcc::jit::recording classes (within @code{jit-recording.c} and\n@code{jit-recording.h}) record the API calls that are made:\n\n@quotation\n\n@example\n\n  /* Indentation indicates inheritance: */\n  class context;\n  class memento;\n    class string;\n    class location;\n    class type;\n      class function_type;\n      class compound_type;\n        class struct_;\n\tclass union_;\n    class field;\n    class fields;\n    class function;\n    class block;\n    class rvalue;\n      class lvalue;\n        class local;\n\tclass global;\n        class param;\n    class statement;\n    class case_;\n\n\n@end example\n\n@noindent\n@end quotation\n\n@item \nWhen the context is compiled, the gcc::jit::playback classes (within\n@code{jit-playback.c} and @code{jit-playback.h}) replay the API calls\nwithin langhook:parse_file:\n\n@quotation\n\n@example\n\n  /* Indentation indicates inheritance: */\n  class context;\n  class wrapper;\n    class type;\n      class compound_type;\n    class field;\n    class function;\n    class block;\n    class rvalue;\n      class lvalue;\n        class param;\n    class source_file;\n    class source_line;\n    class location;\n    class case_;\n\n\n@end example\n\n@noindent\n\n@example\nClient Code   . Generated .            libgccjit.so\n              . code      .\n              .           . JIT API  . JIT \"Frontend\". (libbackend.a)\n....................................................................................\n   \u2502          .           .          .               .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502     .               .\n              .           .    V     .               .\n              .           .    \u2500\u2500> libgccjit.c       .\n              .           .        \u2502 (error-checking).\n              .           .        \u2502                 .\n              .           .        \u2500\u2500> jit-recording.c\n              .           .              (record API calls)\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500              .\n              .           .    \u2502     .               .\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_context_compile .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 start of recording::context::compile ()\n              .           .    \u2502     .               .\n              .           .    \u2502 start of playback::context::compile ()\n              .           .    \u2502   (create tempdir)  .\n              .           .    \u2502     .               .\n              .           .    \u2502 ACQUIRE MUTEX       .\n              .           .    \u2502     .               .\n              .           .    V\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> toplev::main (for now)\n              .           .          .               .       \u2502\n              .           .          .               .   (various code)\n              .           .          .               .       \u2502\n              .           .          .               .       V\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:parse_file\n              .           .          .    \u2502          .\n              .           .          .    \u2502 (jit_langhook_parse_file)\n              .           .          .    \u2502          .\n..........................................\u2502..................VVVVVVVVVVVVV...\n              .           .          .    \u2502          .       No GC in here\n              .           .          .    \u2502 jit-playback.c\n              .           .          .    \u2502   (playback of API calls)\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> creation of functions,\n              .           .          .               .     types, expression trees\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 etc\n              .           .          .    \u2502(handle_locations: add locations to\n              .           .          .    \u2502 linemap and associate them with trees)\n              .           .          .    \u2502          .\n              .           .          .    \u2502          .       No GC in here\n..........................................\u2502..................AAAAAAAAAAAAA...\n              .           .          .    \u2502 for each function\n              .           .          .    \u2500\u2500> postprocess\n              .           .          .        \u2502      .\n              .           .          .        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> cgraph_finalize_function\n              .           .          .        <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              .           .          .     <\u2500\u2500       .\n              .           .          .    \u2502          .\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> (end of\n              .           .          .               .       \u2502 langhook_parse_file)\n              .           .          .               .       \u2502\n              .           .          .               .   (various code)\n              .           .          .               .       \u2502\n              .           .          .               .       \u2193\n              .           .          .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 langhook:write_globals\n              .           .          .    \u2502          .\n              .           .          .    \u2502 (jit_langhook_write_globals)\n              .           .          .    \u2502          .\n              .           .          .    \u2502          .\n              .           .          .    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> finalize_compilation_unit\n              .           .          .               .       \u2502\n              .           .          .               .   (the middle\u2500end and backend)\n              .           .          .               .       \u2193\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::main\n              .           .    \u2502     .               .\n              .           .    V\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> toplev::finalize\n              .           .          .               . \u2502   (purge internal state)\n              .           .    <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 end of toplev::finalize\n              .           .    \u2502     .               .\n              .           .    V\u2500> playback::context::postprocess:\n              .           .      \u2502   .               .\n              .           .      \u2502   (assuming an in-memory compile):\n              .           .      \u2502   .               .\n              .           .      --> Convert assembler to DSO, via embedded\n              .           .          copy of driver:\n              .           .           driver::main ()\n              .           .             invocation of \"as\"\n              .           .             invocation of \"ld\"\n              .           .           driver::finalize ()\n              .           .      <----\n              .           .      \u2502   .               .\n              .           .      \u2502   . Load DSO (dlopen \"fake.so\")\n              .           .      \u2502   .               .\n              .           .      \u2502   . Bundle it up in a jit::result\n              .           .    <\u2500\u2500   .               .\n              .           .    \u2502     .               .\n              .           .    \u2502 RELEASE MUTEX       .\n              .           .    \u2502     .               .\n              .           .    \u2502 end of playback::context::compile ()\n              .           .    \u2502     .               .\n              .           .    \u2502 playback::context dtor\n              .           .     \u2500\u2500>  .               .\n              .           .       \u2502 Normally we cleanup the tempdir here:\n              .           .       \u2502   (\"fake.so\" is unlinked from the\n              .           .       \u2502    filesystem at this point)\n              .           .       \u2502 If the client code requested debuginfo, the\n              .           .       \u2502 cleanup happens later (in gcc_jit_result_release)\n              .           .       \u2502 to make it easier on the debugger (see PR jit/64206)\n              .           .    <\u2500\u2500   .               .\n              .           .    \u2502     .               .\n              .           .    \u2502 end of recording::context::compile ()\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_result_get_code .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 dlsym () within loaded DSO\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   Get (void*).           .          .               .\n   \u2502          .           .          .               .\n   \u2502 Call it  .           .          .               .\n   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>       .          .               .\n              .    \u2502      .          .               .\n              .    \u2502      .          .               .\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       .          .               .\n   \u2502          .           .          .               .\netc\u2502          .           .          .               .\n   \u2502          .           .          .               .\n   V          .           .  gcc_jit_result_release  .\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>      .               .\n              .           .    \u2502 dlclose () the loaded DSO\n              .           .    \u2502    (code becomes uncallable)\n              .           .    \u2502     .               .\n              .           .    \u2502 If the client code requested debuginfo, then\n              .           .    \u2502 cleanup of the tempdir was delayed.\n              .           .    \u2502 If that was the case, clean it up now.\n   <\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      .               .\n   \u2502          .           .          .               .\n\n@end example\n\n@noindent\n@end quotation\n@end itemize\n\nHere is a high-level summary from @code{jit-common.h}:\n\n@quotation\n\nIn order to allow jit objects to be usable outside of a compile\nwhilst working with the existing structure of GCC's code the\nC API is implemented in terms of a gcc::jit::recording::context,\nwhich records the calls made to it.\n\nWhen a gcc_jit_context is compiled, the recording context creates a\nplayback context.  The playback context invokes the bulk of the GCC\ncode, and within the \"frontend\" parsing hook, plays back the recorded\nAPI calls, creating GCC tree objects.\n\nSo there are two parallel families of classes: those relating to\nrecording, and those relating to playback:\n\n\n@itemize *\n\n@item \nVisibility: recording objects are exposed back to client code,\nwhereas playback objects are internal to the library.\n\n@item \nLifetime: recording objects have a lifetime equal to that of the\nrecording context that created them, whereas playback objects only\nexist within the frontend hook.\n\n@item \nMemory allocation: recording objects are allocated by the recording\ncontext, and automatically freed by it when the context is released,\nwhereas playback objects are allocated within the GC heap, and\ngarbage-collected; they can own GC-references.\n\n@item \nIntegration with rest of GCC: recording objects are unrelated to the\nrest of GCC, whereas playback objects are wrappers around \"tree\"\ninstances.  Hence you can't ask a recording rvalue or lvalue what its\ntype is, whereas you can for a playback rvalue of lvalue (since it\ncan work with the underlying GCC tree nodes).\n\n@item \nInstancing: There can be multiple recording contexts \"alive\" at once\n(albeit it only one compiling at once), whereas there can only be one\nplayback context alive at one time (since it interacts with the GC).\n@end itemize\n\nUltimately if GCC could support multiple GC heaps and contexts, and\nfiner-grained initialization, then this recording vs playback\ndistinction could be eliminated.\n\nDuring a playback, we associate objects from the recording with\ntheir counterparts during this playback.  For simplicity, we store this\nwithin the recording objects, as @code{void *m_playback_obj}, casting it to\nthe appropriate playback object subclass.  For these casts to make\nsense, the two class hierarchies need to have the same structure.\n\nNote that the playback objects that @code{m_playback_obj} points to are\nGC-allocated, but the recording objects don't own references:\nthese associations only exist within a part of the code where\nthe GC doesn't collect, and are set back to NULL before the GC can\nrun.\n@end quotation\n@anchor{internals/index example-of-log-file}@anchor{5c}\nAnother way to understand the structure of the code is to enable logging,\nvia @pxref{5b,,gcc_jit_context_set_logfile()}.  Here is an example of a log\ngenerated via this call:\n\n@example\nJIT: libgccjit (GCC) version 6.0.0 20150803 (experimental) (x86_64-pc-linux-gnu)\nJIT:\tcompiled by GNU C version 4.8.3 20140911 (Red Hat 4.8.3-7), GMP version 5.1.2, MPFR version 3.1.2, MPC version 1.0.1\nJIT: entering: gcc_jit_context_set_str_option\nJIT:  GCC_JIT_STR_OPTION_PROGNAME: \"./test-hello-world.c.exe\"\nJIT: exiting: gcc_jit_context_set_str_option\nJIT: entering: gcc_jit_context_set_int_option\nJIT:  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL: 3\nJIT: exiting: gcc_jit_context_set_int_option\nJIT: entering: gcc_jit_context_set_bool_option\nJIT:  GCC_JIT_BOOL_OPTION_DEBUGINFO: true\nJIT: exiting: gcc_jit_context_set_bool_option\nJIT: entering: gcc_jit_context_set_bool_option\nJIT:  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE: false\nJIT: exiting: gcc_jit_context_set_bool_option\nJIT: entering: gcc_jit_context_set_bool_option\nJIT:  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE: false\nJIT: exiting: gcc_jit_context_set_bool_option\nJIT: entering: gcc_jit_context_set_bool_option\nJIT:  GCC_JIT_BOOL_OPTION_SELFCHECK_GC: true\nJIT: exiting: gcc_jit_context_set_bool_option\nJIT: entering: gcc_jit_context_set_bool_option\nJIT:  GCC_JIT_BOOL_OPTION_DUMP_SUMMARY: false\nJIT: exiting: gcc_jit_context_set_bool_option\nJIT: entering: gcc_jit_context_get_type\nJIT: exiting: gcc_jit_context_get_type\nJIT: entering: gcc_jit_context_get_type\nJIT: exiting: gcc_jit_context_get_type\nJIT: entering: gcc_jit_context_new_param\nJIT: exiting: gcc_jit_context_new_param\nJIT: entering: gcc_jit_context_new_function\nJIT: exiting: gcc_jit_context_new_function\nJIT: entering: gcc_jit_context_new_param\nJIT: exiting: gcc_jit_context_new_param\nJIT: entering: gcc_jit_context_get_type\nJIT: exiting: gcc_jit_context_get_type\nJIT: entering: gcc_jit_context_new_function\nJIT: exiting: gcc_jit_context_new_function\nJIT: entering: gcc_jit_context_new_string_literal\nJIT: exiting: gcc_jit_context_new_string_literal\nJIT: entering: gcc_jit_function_new_block\nJIT: exiting: gcc_jit_function_new_block\nJIT: entering: gcc_jit_block_add_comment\nJIT: exiting: gcc_jit_block_add_comment\nJIT: entering: gcc_jit_context_new_call\nJIT: exiting: gcc_jit_context_new_call\nJIT: entering: gcc_jit_block_add_eval\nJIT: exiting: gcc_jit_block_add_eval\nJIT: entering: gcc_jit_block_end_with_void_return\nJIT: exiting: gcc_jit_block_end_with_void_return\nJIT: entering: gcc_jit_context_dump_reproducer_to_file\nJIT:  entering: void gcc::jit::recording::context::dump_reproducer_to_file(const char*)\nJIT:  exiting: void gcc::jit::recording::context::dump_reproducer_to_file(const char*)\nJIT: exiting: gcc_jit_context_dump_reproducer_to_file\nJIT: entering: gcc_jit_context_compile\nJIT:  in-memory compile of ctxt: 0x1283e20\nJIT:  entering: gcc::jit::result* gcc::jit::recording::context::compile()\nJIT:   GCC_JIT_STR_OPTION_PROGNAME: \"./test-hello-world.c.exe\"\nJIT:   GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL: 3\nJIT:   GCC_JIT_BOOL_OPTION_DEBUGINFO: true\nJIT:   GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE: false\nJIT:   GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE: false\nJIT:   GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE: false\nJIT:   GCC_JIT_BOOL_OPTION_DUMP_SUMMARY: false\nJIT:   GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING: false\nJIT:   GCC_JIT_BOOL_OPTION_SELFCHECK_GC: true\nJIT:   GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES: false\nJIT:   gcc_jit_context_set_bool_allow_unreachable_blocks: false\nJIT:   gcc_jit_context_set_bool_use_external_driver: false\nJIT:   entering: void gcc::jit::recording::context::validate()\nJIT:   exiting: void gcc::jit::recording::context::validate()\nJIT:   entering: gcc::jit::playback::context::context(gcc::jit::recording::context*)\nJIT:   exiting: gcc::jit::playback::context::context(gcc::jit::recording::context*)\nJIT:   entering: gcc::jit::playback::compile_to_memory::compile_to_memory(gcc::jit::recording::context*)\nJIT:   exiting: gcc::jit::playback::compile_to_memory::compile_to_memory(gcc::jit::recording::context*)\nJIT:   entering: void gcc::jit::playback::context::compile()\nJIT:    entering: gcc::jit::tempdir::tempdir(gcc::jit::logger*, int)\nJIT:    exiting: gcc::jit::tempdir::tempdir(gcc::jit::logger*, int)\nJIT:    entering: bool gcc::jit::tempdir::create()\nJIT:     m_path_template: /tmp/libgccjit-XXXXXX\nJIT:     m_path_tempdir: /tmp/libgccjit-CKq1M9\nJIT:    exiting: bool gcc::jit::tempdir::create()\nJIT:    entering: void gcc::jit::playback::context::acquire_mutex()\nJIT:    exiting: void gcc::jit::playback::context::acquire_mutex()\nJIT:    entering: void gcc::jit::playback::context::make_fake_args(vec<char*>*, const char*, vec<gcc::jit::recording::requested_dump>*)\nJIT:     reusing cached configure-time options\nJIT:     configure_time_options[0]: -mtune=generic\nJIT:     configure_time_options[1]: -march=x86-64\nJIT:    exiting: void gcc::jit::playback::context::make_fake_args(vec<char*>*, const char*, vec<gcc::jit::recording::requested_dump>*)\nJIT:    entering: toplev::main\nJIT:     argv[0]: ./test-hello-world.c.exe\nJIT:     argv[1]: /tmp/libgccjit-CKq1M9/fake.c\nJIT:     argv[2]: -fPIC\nJIT:     argv[3]: -O3\nJIT:     argv[4]: -g\nJIT:     argv[5]: -quiet\nJIT:     argv[6]: --param\nJIT:     argv[7]: ggc-min-expand=0\nJIT:     argv[8]: --param\nJIT:     argv[9]: ggc-min-heapsize=0\nJIT:     argv[10]: -mtune=generic\nJIT:     argv[11]: -march=x86-64\nJIT:     entering: bool jit_langhook_init()\nJIT:     exiting: bool jit_langhook_init()\nJIT:     entering: void gcc::jit::playback::context::replay()\nJIT:      entering: void gcc::jit::recording::context::replay_into(gcc::jit::replayer*)\nJIT:      exiting: void gcc::jit::recording::context::replay_into(gcc::jit::replayer*)\nJIT:      entering: void gcc::jit::recording::context::disassociate_from_playback()\nJIT:      exiting: void gcc::jit::recording::context::disassociate_from_playback()\nJIT:      entering: void gcc::jit::playback::context::handle_locations()\nJIT:      exiting: void gcc::jit::playback::context::handle_locations()\nJIT:      entering: void gcc::jit::playback::function::build_stmt_list()\nJIT:      exiting: void gcc::jit::playback::function::build_stmt_list()\nJIT:      entering: void gcc::jit::playback::function::build_stmt_list()\nJIT:      exiting: void gcc::jit::playback::function::build_stmt_list()\nJIT:      entering: void gcc::jit::playback::function::postprocess()\nJIT:      exiting: void gcc::jit::playback::function::postprocess()\nJIT:      entering: void gcc::jit::playback::function::postprocess()\nJIT:      exiting: void gcc::jit::playback::function::postprocess()\nJIT:     exiting: void gcc::jit::playback::context::replay()\nJIT:    exiting: toplev::main\nJIT:    entering: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\nJIT:    exiting: void gcc::jit::playback::context::extract_any_requested_dumps(vec<gcc::jit::recording::requested_dump>*)\nJIT:    entering: toplev::finalize\nJIT:    exiting: toplev::finalize\nJIT:    entering: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)\nJIT:     entering: void gcc::jit::playback::context::convert_to_dso(const char*)\nJIT:      entering: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)\nJIT:       entering: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)\nJIT:       exiting: void gcc::jit::playback::context::add_multilib_driver_arguments(vec<char*>*)\nJIT:       argv[0]: x86_64-unknown-linux-gnu-gcc-6.0.0\nJIT:       argv[1]: -m64\nJIT:       argv[2]: -shared\nJIT:       argv[3]: /tmp/libgccjit-CKq1M9/fake.s\nJIT:       argv[4]: -o\nJIT:       argv[5]: /tmp/libgccjit-CKq1M9/fake.so\nJIT:       argv[6]: -fno-use-linker-plugin\nJIT:       entering: void gcc::jit::playback::context::invoke_embedded_driver(const vec<char*>*)\nJIT:       exiting: void gcc::jit::playback::context::invoke_embedded_driver(const vec<char*>*)\nJIT:      exiting: void gcc::jit::playback::context::invoke_driver(const char*, const char*, const char*, timevar_id_t, bool, bool)\nJIT:     exiting: void gcc::jit::playback::context::convert_to_dso(const char*)\nJIT:     entering: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\nJIT:      GCC_JIT_BOOL_OPTION_DEBUGINFO was set: handing over tempdir to jit::result\nJIT:      entering: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\nJIT:      exiting: gcc::jit::result::result(gcc::jit::logger*, void*, gcc::jit::tempdir*)\nJIT:     exiting: gcc::jit::result* gcc::jit::playback::context::dlopen_built_dso()\nJIT:    exiting: virtual void gcc::jit::playback::compile_to_memory::postprocess(const char*)\nJIT:    entering: void gcc::jit::playback::context::release_mutex()\nJIT:    exiting: void gcc::jit::playback::context::release_mutex()\nJIT:   exiting: void gcc::jit::playback::context::compile()\nJIT:   entering: gcc::jit::playback::context::~context()\nJIT:   exiting: gcc::jit::playback::context::~context()\nJIT:  exiting: gcc::jit::result* gcc::jit::recording::context::compile()\nJIT:  gcc_jit_context_compile: returning (gcc_jit_result *)0x12f75d0\nJIT: exiting: gcc_jit_context_compile\nJIT: entering: gcc_jit_result_get_code\nJIT:  locating fnname: hello_world\nJIT:  entering: void* gcc::jit::result::get_code(const char*)\nJIT:  exiting: void* gcc::jit::result::get_code(const char*)\nJIT:  gcc_jit_result_get_code: returning (void *)0x7ff6b8cd87f0\nJIT: exiting: gcc_jit_result_get_code\nJIT: entering: gcc_jit_context_release\nJIT:  deleting ctxt: 0x1283e20\nJIT:  entering: gcc::jit::recording::context::~context()\nJIT:  exiting: gcc::jit::recording::context::~context()\nJIT: exiting: gcc_jit_context_release\nJIT: entering: gcc_jit_result_release\nJIT:  deleting result: 0x12f75d0\nJIT:  entering: virtual gcc::jit::result::~result()\nJIT:   entering: gcc::jit::tempdir::~tempdir()\nJIT:    unlinking .s file: /tmp/libgccjit-CKq1M9/fake.s\nJIT:    unlinking .so file: /tmp/libgccjit-CKq1M9/fake.so\nJIT:    removing tempdir: /tmp/libgccjit-CKq1M9\nJIT:   exiting: gcc::jit::tempdir::~tempdir()\nJIT:  exiting: virtual gcc::jit::result::~result()\nJIT: exiting: gcc_jit_result_release\nJIT: gcc::jit::logger::~logger()\n\n@end example\n\n@noindent\n\n@node Design notes,Submitting patches,Overview of code structure,Internals\n@anchor{internals/index design-notes}@anchor{1cc}\n@section Design notes\n\n\nIt should not be possible for client code to cause an internal compiler\nerror.  If this @emph{does} happen, the root cause should be isolated (perhaps\nusing @pxref{5d,,gcc_jit_context_dump_reproducer_to_file()}) and the cause\nshould be rejected via additional checking.  The checking ideally should\nbe within the libgccjit API entrypoints in libgccjit.c, since this is as\nclose as possible to the error; failing that, a good place is within\n@code{recording::context::validate ()} in jit-recording.c.\n\n@node Submitting patches,,Design notes,Internals\n@anchor{internals/index submitting-patches}@anchor{1cd}\n@section Submitting patches\n\n\nPlease read the contribution guidelines for gcc at\n@indicateurl{https://gcc.gnu.org/contribute.html}.\n\nPatches for the jit should be sent to both the\n@email{gcc-patches@@gcc.gnu.org} and @email{jit@@gcc.gnu.org} mailing lists,\nwith \"jit\" and \"PATCH\" in the Subject line.\n\nYou don't need to do a full bootstrap for code that just touches the\n@code{jit} and @code{testsuite/jit.dg} subdirectories.  However, please run\n@code{make check-jit} before submitting the patch, and mention the results\nin your email (along with the host triple that the tests were run on).\n\nA good patch should contain the information listed in the\ngcc contribution guide linked to above; for a @code{jit} patch, the patch\nshold contain:\n\n@quotation\n\n\n@itemize *\n\n@item \nthe code itself (for example, a new API entrypoint will typically\ntouch @code{libgccjit.h} and @code{.c}, along with support code in\n@code{jit-recording.[ch]} and @code{jit-playback.[ch]} as appropriate)\n\n@item \ntest coverage\n\n@item \ndocumentation for the C API\n\n@item \ndocumentation for the C++ API\n@end itemize\n@end quotation\n\nA patch that adds new API entrypoints should also contain:\n\n@quotation\n\n\n@itemize *\n\n@item \na feature macro in @code{libgccjit.h} so that client code that doesn't\nuse a \"configure\" mechanism can still easily detect the presence of\nthe entrypoint.  See e.g. @code{LIBGCCJIT_HAVE_SWITCH_STATEMENTS} (for\na category of entrypoints) and\n@code{LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks}\n(for an individual entrypoint).\n\n@item \na new ABI tag containing the new symbols (in @code{libgccjit.map}), so\nthat we can detect client code that uses them\n\n@item \nSupport for @pxref{5d,,gcc_jit_context_dump_reproducer_to_file()}.  Most\njit testcases attempt to dump their contexts to a .c file; @code{jit.exp}\nthen sanity-checks the generated c by compiling them (though\nnot running them).   A new API entrypoint\nneeds to \"know\" how to write itself back out to C (by implementing\n@code{gcc::jit::recording::memento::write_reproducer} for the appropriate\n@code{memento} subclass).\n\n@item \nC++ bindings for the new entrypoints (see @code{libgccjit++.h}); ideally\nwith test coverage, though the C++ API test coverage is admittedly\nspotty at the moment\n\n@item \ndocumentation for the new C entrypoints\n\n@item \ndocumentation for the new C++ entrypoints\n\n@item \ndocumentation for the new ABI tag (see @code{topics/compatibility.rst}).\n@end itemize\n@end quotation\n\nDepending on the patch you can either extend an existing test case, or\nadd a new test case.  If you add an entirely new testcase: @code{jit.exp}\nexpects jit testcases to begin with @code{test-}, or @code{test-error-} (for a\ntestcase that generates an error on a @pxref{8,,gcc_jit_context}).\n\nEvery new testcase that doesn't generate errors should also touch\n@code{gcc/testsuite/jit.dg/all-non-failing-tests.h}:\n\n@quotation\n\n\n@itemize *\n\n@item \nTestcases that don't generate errors should ideally be added to the\n@code{testcases} array in that file; this means that, in addition\nto being run standalone, they also get run within\n@code{test-combination.c} (which runs all successful tests inside one\nbig @pxref{8,,gcc_jit_context}), and @code{test-threads.c} (which runs all\nsuccessful tests in one process, each one running in a different\nthread on a different @pxref{8,,gcc_jit_context}).\n\n@cartouche\n@quotation Note \nGiven that exported functions within a @pxref{8,,gcc_jit_context}\nmust have unique names, and most testcases are run within\n@code{test-combination.c}, this means that every jit-compiled test\nfunction typically needs a name that's unique across the entire\ntest suite.\n@end quotation\n@end cartouche\n\n@item \nTestcases that aren't to be added to the @code{testcases} array should\ninstead add a comment to the file clarifying why they're not in that\narray. See the file for examples.\n@end itemize\n@end quotation\n\nTypically a patch that touches the .rst documentation will also need the\ntexinfo to be regenerated.  You can do this with\nSphinx 1.0@footnote{http://sphinx-doc.org/} or later by\nrunning @code{make texinfo} within @code{SRCDIR/gcc/jit/docs}.   Don't do this\nwithin the patch sent to the mailing list; it can often be relatively\nlarge and inconsequential (e.g. anchor renumbering), rather like generated\n\"configure\" changes from configure.ac.  You can regenerate it when\ncommitting to svn.\n\n@node Indices and tables,Index,Internals,Top\n@anchor{index indices-and-tables}@anchor{1ce}\n@unnumbered Indices and tables\n\n\n\n@itemize *\n\n@item \n@emph{genindex}\n\n@item \n@emph{modindex}\n\n@item \n@emph{search}\n@end itemize\n\n@c Some notes:\n@c \n@c The Sphinx C domain appears to lack explicit support for enum values,\n@c so I've been using :c:macro: for them.\n@c \n@c See http://sphinx-doc.org/domains.html#the-c-domain\n\n@node Index,,Indices and tables,Top\n@unnumbered Index\n\n\n@printindex ge\n\n@c %**end of body\n@bye\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/c-c++-common/tsan/tsan_barrier.h": "/* TSAN-invisible barriers.  Link with -ldl.  */\n#include <pthread.h>\n#include <dlfcn.h>\n\nstatic __typeof(pthread_barrier_wait) *barrier_wait;\n\nstatic\nvoid barrier_init (pthread_barrier_t *barrier, unsigned count)\n{\n  void *h = dlopen (\"libpthread.so.0\", RTLD_LAZY);\n  barrier_wait = (__typeof (pthread_barrier_wait) *)\n\t \t dlsym (h, \"pthread_barrier_wait\");\n  pthread_barrier_init (barrier, NULL, count);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.dg/tsan/tsan_barrier.h": "/* TSAN-invisible barriers.  Link with -ldl.  */\n#include <pthread.h>\n#include <dlfcn.h>\n\nstatic __typeof(pthread_barrier_wait) *barrier_wait;\n\nstatic\nvoid barrier_init (pthread_barrier_t *barrier, unsigned count)\n{\n  void *h = dlopen (\"libpthread.so.0\", RTLD_LAZY);\n  barrier_wait = (__typeof (pthread_barrier_wait) *)\n\t \t dlsym (h, \"pthread_barrier_wait\");\n  pthread_barrier_init (barrier, NULL, count);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/jit.dg/verify-dynamic-library.c": "/* For use by jit-verify-dynamic-library, used by\n   test-compile-to-dynamic-library.c.  */\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint\nmain (int argc, char **argv)\n{\n  void *handle;\n  void (*hello_world) (const char *name);\n  char *error;\n\n  handle = dlopen (\"./output-of-test-compile-to-dynamic-library.c.so\",\n\t\t   RTLD_NOW | RTLD_LOCAL);\n  if (!handle)\n    {\n      fprintf (stderr, \"dlopen failed: %s\\n\", dlerror());\n      exit (1);\n    }\n\n  /* Clear any existing error */\n  dlerror ();\n\n  /* This symbol is from the DSO built by\n     test-compile-to-dynamic-library.c.  */\n  *(void **) (&hello_world) = dlsym (handle, \"hello_world\");\n\n  if ((error = dlerror()) != NULL)\n    {\n      fprintf (stderr, \"dlsym failed: %s\\n\", error);\n      exit (2);\n    }\n\n  /* Call the function from the generated DSO.  */\n  hello_world (argv[0]);\n\n  dlclose (handle);\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/ext/mt_allocator/22309_thread.cc": "// { dg-require-sharedlib \"\" }\n// { dg-options \"-g -O2 -pthread -ldl\" { target *-*-linux* *-*-gnu* } }\n\n// Copyright (C) 2004-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this library; see the file COPYING3.  If not see\n// <http://www.gnu.org/licenses/>.\n\n#include <dlfcn.h>\n#include <pthread.h>\n#include <cstdlib>\n#include <stdexcept>\n\nvoid\ncheck_dlopen(void*& h)\n{\n  dlerror();\n  void* tmp = dlopen(\"./testsuite_shared.so\", RTLD_LAZY);\n  if (!tmp) \n    {\n      try \n\t{\n\t  // Throws std::logic_error on NULL string.\n\t  std::string error(dlerror());\n\t  throw std::runtime_error(error);\n\t}\n      catch (const std::logic_error&)\n\t{ }\n    }\n  h = tmp;\n}\n\nvoid\ncheck_dlsym(void*& h)\n{\n  dlerror();\n\n  typedef void (*function_type) (void);\n  function_type fn;\n  fn = reinterpret_cast<function_type>(dlsym(h, \"try_allocation\"));\n\n  try \n    {\n      std::string error(dlerror());\n      throw std::runtime_error(error);\n    }\n  catch (const std::logic_error&)\n    { }\n\n  fn();\n}\n\nvoid\ncheck_dlclose(void*& h)\n{\n  dlerror();\n  if (dlclose(h) != 0)\n    {\n      try \n\t{\n\t  std::string error(dlerror());\n\t  throw std::runtime_error(error);\n\t}\n      catch (const std::logic_error&)\n\t{ }\n    }\n}\n\nvoid*\ntf(void* arg)\n{\n  void* h;\n  check_dlopen(h);\n  check_dlsym(h);\n  check_dlclose(h);\n  return 0;\n}\n\n// libstdc++/22309\nint\nmain (void)\n{\n  pthread_t th;\n  pthread_create(&th, 0, tf, 0);\n  pthread_join(th, 0);\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/18_support/bad_exception/23591_thread-1.c": "// { dg-require-sharedlib \"\" }\n// { dg-skip-if \"invalid options for C\" { *-*-* } { \"-std=c++??\" \"-std=gnu++??\" } }\n// { dg-options \"-g -O2 -pthread -ldl -x c -fvtable-verify=none -Wno-pedantic\" { target *-*-linux* *-*-gnu* *-*-solaris2.1[2-9]* } }\n\n// Copyright (C) 2005-2017 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this library; see the file COPYING3.  If not see\n// <http://www.gnu.org/licenses/>.\n\n#include <pthread.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n// NB: This must be compiled and linked as a \"C\" executable.\nstatic void* run(void* arg)\n{\n  typedef void (*function_type) (void);\n  void* lib;\n  void (*cb)();\n\n  lib = dlopen(\"./testsuite_shared.so\", RTLD_NOW);\n  if (!lib)\n    {\n      printf(\"dlopen failed: %s\\n\", strerror(errno));\n      return 0;\n    }\n  cb = (function_type) dlsym(lib, \"try_throw_exception\");\n  if (!cb)\n    {\n      printf(\"dlsym failed: %s\\n\", strerror(errno));\n      return 0;\n    }\n  cb();\n  dlclose(lib);\n  return 0;\n}\n\n// libstdc++/23591\nint main(void)\n{\n  pthread_t pt;\n\n  if (pthread_create(&pt, 0, &run, 0) != 0)\n    return 1;\n  if (pthread_join(pt, 0) != 0)\n    return 1;\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/liboffloadmic/runtime/offload_util.cpp": "/*\n    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n      * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n      * Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n      * Neither the name of Intel Corporation nor the names of its\n        contributors may be used to endorse or promote products derived\n        from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include \"offload_util.h\"\n#include <errno.h>\n#include \"liboffload_error_codes.h\"\n\n#ifdef TARGET_WINNT\nvoid *thread_getspecific(pthread_key_t key)\n{\n    if (key == 0) {\n        return NULL;\n    }\n    else {\n        return TlsGetValue(key);\n    }\n}\n\nint thread_setspecific(pthread_key_t key, const void *value)\n{\n    return (TlsSetValue(key, (LPVOID)value)) ? 0 : GetLastError();\n}\n#endif // TARGET_WINNT\n\nbool __offload_parse_size_string(const char *str, uint64_t &new_size)\n{\n    uint64_t val;\n    char *suffix;\n\n    errno = 0;\n#ifdef TARGET_WINNT\n    val = strtoul(str, &suffix, 10);\n#else // TARGET_WINNT\n    val = strtoull(str, &suffix, 10);\n#endif // TARGET_WINNT\n    if (errno != 0 || suffix == str) {\n        return false;\n    }\n\n    if (suffix[0] == '\\0') {\n        // default is Kilobytes\n        new_size = val * 1024;\n        return true;\n    }\n    else if (suffix[1] == '\\0') {\n        // Optional suffixes: B (bytes), K (Kilobytes), M (Megabytes),\n        // G (Gigabytes), or T (Terabytes) specify the units.\n        switch (suffix[0]) {\n            case 'b':\n            case 'B':\n                new_size = val;\n                break;\n\n            case 'k':\n            case 'K':\n                new_size = val * 1024;\n                break;\n\n            case 'm':\n            case 'M':\n                new_size = val * 1024 * 1024;\n                break;\n\n            case 'g':\n            case 'G':\n                new_size = val * 1024 * 1024 * 1024;\n                break;\n\n            case 't':\n            case 'T':\n                new_size = val * 1024 * 1024 * 1024 * 1024;\n                break;\n\n            default:\n                return false;\n        }\n        return true;\n    }\n\n    return false;\n}\n\nbool __offload_parse_int_string(const char *str, int64_t &value)\n{\n    int64_t val;\n    char *suffix;\n\n    errno = 0;\n#ifdef TARGET_WINNT\n    val = strtol(str, &suffix, 0);\n#else\n    val = strtoll(str, &suffix, 0);\n#endif\n    if (errno == 0 && suffix != str && *suffix == '\\0') {\n        value = val;\n        return true;\n    }\n    return false;\n}\n\n#ifdef TARGET_WINNT\nextern void* DL_open(const char *path)\n{\n    void *handle;\n    int error_mode;\n\n    /*\n     * do not display message box with error if it the call below fails to\n     * load dynamic library.\n     */\n    error_mode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\n    /* load dynamic library */\n    handle = (void*) LoadLibrary(path);\n\n    /* restore error mode */\n    SetErrorMode(error_mode);\n\n    return handle;\n}\n\nextern int DL_addr(const void *addr, Dl_info *dl_info)\n{\n    MEMORY_BASIC_INFORMATION mem_info;\n    char mod_name[MAX_PATH];\n    HMODULE mod_handle;\n\n    /* Fill MEMORY_BASIC_INFORMATION struct */\n    if (!VirtualQuery(addr, &mem_info, sizeof(mem_info))) {\n        return 0;\n    }\n    mod_handle = (HMODULE)mem_info.AllocationBase;\n\n    /* ANSI file name for module */\n    if (!GetModuleFileNameA(mod_handle, (char*) mod_name, sizeof(mod_name))) {\n        return 0;\n    }\n    strcpy(dl_info->dli_fname, mod_name);\n    dl_info->dli_fbase = mem_info.BaseAddress;\n    dl_info->dli_saddr = addr;\n    strcpy(dl_info->dli_sname, mod_name);\n    return 1;\n}\n\n// Run once\nstatic BOOL CALLBACK __offload_run_once_wrapper(\n    PINIT_ONCE initOnce,\n    PVOID parameter,\n    PVOID *context\n)\n{\n    void (*init_routine)(void) = (void(*)(void)) parameter;\n    init_routine();\n    return true;\n}\n\nvoid __offload_run_once(OffloadOnceControl *ctrl, void (*func)(void))\n{\n    InitOnceExecuteOnce(ctrl, __offload_run_once_wrapper, (void*) func, 0);\n}\n#endif // TARGET_WINNT\n\n/* ARGSUSED */ // version is not used on windows\nvoid* DL_sym(void *handle, const char *name, const char *version)\n{\n#ifdef TARGET_WINNT\n    return GetProcAddress((HMODULE) handle, name);\n#else // TARGET_WINNT\n    if (version == 0) {\n        return dlsym(handle, name);\n    }\n    else {\n        return dlvsym(handle, name, version);\n    }\n#endif // TARGET_WINNT\n}\n\nint64_t get_el_value(\n                     char *base,\n                     int64_t offset,\n                     int64_t size)\n{\n    int64_t val = 0;\n    switch (size) {\n        case 1:\n            val = static_cast<int64_t>(*((char *)(base + offset)));\n            break;\n        case 2:\n            val = static_cast<int64_t>(*((short *)(base + offset)));\n            break;\n        case 4:\n            val = static_cast<int64_t>(*((int *)(base + offset)));\n            break;\n        default:\n            val = *((int64_t *)(base + offset));\n            break;\n    }\n    return val;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/liboffloadmic/runtime/emulator/coi_device.cpp": "/*\n    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n      * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n      * Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n      * Neither the name of Intel Corporation nor the names of its\n        contributors may be used to endorse or promote products derived\n        from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"coi_device.h\"\n\n#include \"coi_version_asm.h\"\n\n#define CYCLE_FREQUENCY     1000000000\n\n\nstatic uint32_t engine_index;\nstatic char *engine_dir;\n\n\nextern \"C\"\n{\n\nCOIRESULT\nSYMBOL_VERSION (COIBufferAddRef, 1) (void *ptr)\n{\n  COITRACE (\"COIBufferAddRef\");\n\n  /* Looks like we have nothing to do here.  */\n\n  return COI_SUCCESS;\n}\n\n\nCOIRESULT\nSYMBOL_VERSION (COIBufferReleaseRef, 1) (void *ptr)\n{\n  COITRACE (\"COIBufferReleaseRef\");\n\n  /* Looks like we have nothing to do here.  */\n\n  return COI_SUCCESS;\n}\n\n\nCOIRESULT\nSYMBOL_VERSION (COIEngineGetIndex, 1) (COI_ISA_TYPE *type,\n\t\t\t\t       uint32_t *index)\n{\n  COITRACE (\"COIEngineGetIndex\");\n\n  /* type is not used in liboffloadmic.  */\n  *index = engine_index;\n\n  return COI_SUCCESS;\n}\n\n\nCOIRESULT\nSYMBOL_VERSION (COIPipelineStartExecutingRunFunctions, 1) ()\n{\n  COITRACE (\"COIPipelineStartExecutingRunFunctions\");\n\n  /* Looks like we have nothing to do here.  */\n\n  return COI_SUCCESS;\n}\n\n\n/* The start routine for the COI pipeline thread.  */\n\nstatic void *\npipeline_thread_routine (void *in_pipeline_num)\n{\n  uint32_t pipeline_num = *(uint32_t *) in_pipeline_num;\n  free (in_pipeline_num);\n\n  /* Open pipes.  */\n  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n  MALLOCN (char *, pipe_host2tgt_path,\n\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"0000000000\"));\n  MALLOCN (char *, pipe_tgt2host_path,\n\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"0000000000\"));\n  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"%010d\", engine_dir,\n\t   pipeline_num);\n  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"%010d\", engine_dir,\n\t   pipeline_num);\n  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n  if (pipe_host2tgt < 0)\n    COIERRORN (\"Cannot open host-to-target pipe.\");\n  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n  if (pipe_tgt2host < 0)\n    COIERRORN (\"Cannot open target-to-host pipe.\");\n\n  free (pipe_host2tgt_path);\n  free (pipe_tgt2host_path);\n\n  while (1)\n    {\n      /* Read and execute command.  */\n      cmd_t cmd = CMD_PIPELINE_DESTROY;\n      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n\tCOIERRORN (\"Cannot read from pipe.\");\n\n      if (cmd == CMD_PIPELINE_DESTROY)\n\tbreak;\n      else if (cmd == CMD_PIPELINE_RUN_FUNCTION)\n\t{\n\t  /* Receive data from host.  */\n\t  void (*func) (uint32_t, void **, uint64_t *, void *, uint16_t, void *,\n\t\t\tuint16_t);\n\t  uint32_t buffer_count;\n\t  READN (pipe_host2tgt, &func, sizeof (void *));\n\t  READN (pipe_host2tgt, &buffer_count, sizeof (uint32_t));\n\t  void **buffers;\n\t  uint64_t *buffers_len;\n\t  MALLOCN (void **, buffers, buffer_count * sizeof (void *));\n\t  MALLOCN (uint64_t *, buffers_len, buffer_count * sizeof (uint64_t));\n\t  for (uint32_t i = 0; i < buffer_count; i++)\n\t    {\n\t      READN (pipe_host2tgt, &buffers_len[i], sizeof (uint64_t));\n\t      READN (pipe_host2tgt, &buffers[i], sizeof (void *));\n\t    }\n\t  uint16_t misc_data_len;\n\t  READN (pipe_host2tgt, &misc_data_len, sizeof (uint16_t));\n\t  void *misc_data = NULL;\n\t  if (misc_data_len > 0)\n\t    {\n\t      MALLOCN (void *, misc_data, misc_data_len);\n\t      READN (pipe_host2tgt, misc_data, misc_data_len);\n\t    }\n\t  uint16_t return_data_len;\n\t  READN (pipe_host2tgt, &return_data_len, sizeof (uint16_t));\n\t  void *return_data;\n\t  if (return_data_len > 0)\n\t    MALLOCN (void *, return_data, return_data_len);\n\n\t  /* Run function.  */\n\t  func (buffer_count, buffers, buffers_len, misc_data,\n\t\tmisc_data_len, return_data, return_data_len);\n\n\t  /* Send data to host if any or just send notification.  */\n\t  WRITEN (pipe_tgt2host, return_data_len > 0 ? return_data : &cmd,\n\t\t  return_data_len > 0 ? return_data_len : sizeof (cmd_t));\n\n\t  /* Clean up.  */\n\t  free (buffers);\n\t  free (buffers_len);\n\t  if (misc_data_len > 0)\n\t    free (misc_data);\n\t  if (return_data_len > 0)\n\t    free (return_data);\n\t}\n      else\n\tCOIERRORN (\"Unrecognizable command from host.\");\n    }\n\n  /* Close pipes.  */\n  if (close (pipe_host2tgt) < 0)\n    COIERRORN (\"Cannot close host-to-target pipe.\");\n  if (close (pipe_tgt2host) < 0)\n    COIERRORN (\"Cannot close target-to-host pipe.\");\n\n  return NULL;\n}\n\n\nCOIRESULT\nSYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n{\n  COITRACE (\"COIProcessWaitForShutdown\");\n\n  engine_dir = getenv (MIC_DIR_ENV);\n  char *mic_index = getenv (MIC_INDEX_ENV);\n  assert (engine_dir != NULL && mic_index != NULL);\n\n  /* Get engine index.  */\n  engine_index = atoi (mic_index);\n\n  /* Open main pipes.  */\n  char *pipe_host2tgt_path, *pipe_tgt2host_path;\n  MALLOC (char *, pipe_host2tgt_path,\n\t  strlen (engine_dir) + sizeof (PIPE_HOST2TGT_NAME \"mainpipe\"));\n  MALLOC (char *, pipe_tgt2host_path,\n\t  strlen (engine_dir) + sizeof (PIPE_TGT2HOST_NAME \"mainpipe\"));\n  sprintf (pipe_host2tgt_path, \"%s\" PIPE_HOST2TGT_NAME \"mainpipe\", engine_dir);\n  sprintf (pipe_tgt2host_path, \"%s\" PIPE_TGT2HOST_NAME \"mainpipe\", engine_dir);\n  int pipe_host2tgt = open (pipe_host2tgt_path, O_CLOEXEC | O_RDONLY);\n  if (pipe_host2tgt < 0)\n    COIERROR (\"Cannot open host-to-target main pipe.\");\n  int pipe_tgt2host = open (pipe_tgt2host_path, O_CLOEXEC | O_WRONLY);\n  if (pipe_tgt2host < 0)\n    COIERROR (\"Cannot open target-to-host main pipe.\");\n\n  /* Clean up.  */\n  free (pipe_host2tgt_path);\n  free (pipe_tgt2host_path);\n\n  /* Handler.  */\n  while (1)\n    {\n      /* Read and execute command.  */\n      cmd_t cmd = CMD_SHUTDOWN;\n      int cmd_len = read (pipe_host2tgt, &cmd, sizeof (cmd_t));\n      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n\tCOIERROR (\"Cannot read from main pipe.\");\n\n      switch (cmd)\n\t{\n\tcase CMD_BUFFER_COPY:\n\t  {\n\t    uint64_t len;\n\t    void *dest, *source;\n\n\t    /* Receive data from host.  */\n\t    READ (pipe_host2tgt, &dest, sizeof (void *));\n\t    READ (pipe_host2tgt, &source, sizeof (void *));\n\t    READ (pipe_host2tgt, &len, sizeof (uint64_t));\n\n\t    /* Copy.  */\n\t    memcpy (dest, source, len);\n\n\t    /* Notify host about completion.  */\n\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n\n\t    break;\n\t  }\n\tcase CMD_BUFFER_MAP:\n\t  {\n\t    char *name;\n\t    size_t len;\n\t    uint64_t buffer_len;\n\t    void *buffer;\n\n\t    /* Receive data from host.  */\n\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n\t    MALLOC (char *, name, len);\n\t    READ (pipe_host2tgt, name, len);\n\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n\n\t    /* Open shared memory.  */\n\t    int fd = shm_open (name, O_CLOEXEC | O_RDWR, S_IRUSR | S_IWUSR);\n\t    if (fd < 0)\n\t      COIERROR (\"Cannot open shared memory.\");\n\n\t    /* Map shared memory.  */\n\t    buffer = mmap (NULL, buffer_len, PROT_READ | PROT_WRITE,\n\t\t\t   MAP_SHARED, fd, 0);\n\t    if (buffer == NULL)\n\t      COIERROR (\"Cannot map shared memory.\");\n\n\t    /* Send data to host.  */\n\t    WRITE (pipe_tgt2host, &fd, sizeof (int));\n\t    WRITE (pipe_tgt2host, &buffer, sizeof (void *));\n\n\t    /* Clean up.  */\n\t    free (name);\n\n\t    break;\n\t  }\n\tcase CMD_BUFFER_UNMAP:\n\t  {\n\t    int fd;\n\t    uint64_t buffer_len;\n\t    void *buffer;\n\n\t    /* Receive data from host.  */\n\t    READ (pipe_host2tgt, &fd, sizeof (int));\n\t    READ (pipe_host2tgt, &buffer, sizeof (void *));\n\t    READ (pipe_host2tgt, &buffer_len, sizeof (uint64_t));\n\n\t    /* Unmap buffer.  */\n\t    if (munmap (buffer, buffer_len) < 0)\n\t      COIERROR (\"Cannot unmap shared memory.\");\n\n\t    /* Close shared memory.  */\n\t    if (close (fd) < 0)\n\t      COIERROR (\"Cannot close shared memory file.\");\n\n\t    /* Notify host about completion.  */\n\t    WRITE (pipe_tgt2host, &cmd, sizeof (cmd_t));\n\n\t    break;\n\t  }\n\tcase CMD_GET_FUNCTION_HANDLE:\n\t  {\n\t    char *name;\n\t    size_t len;\n\n\t    /* Receive data from host.  */\n\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n\t    MALLOC (char *, name, len);\n\t    READ (pipe_host2tgt, name, len);\n\n\t    /* Find function.  */\n\t    void *ptr = dlsym (RTLD_DEFAULT, name);\n\t    if (ptr == NULL)\n\t      COIERROR (\"Cannot find symbol %s.\", name);\n\n\t    /* Send data to host.  */\n\t    WRITE (pipe_tgt2host, &ptr, sizeof (void *));\n\n\t    /* Clean up.  */\n\t    free (name);\n\n\t    break;\n\t  }\n\tcase CMD_OPEN_LIBRARY:\n\t  {\n\t    char *lib_path;\n\t    size_t len;\n\n\t    /* Receive data from host.  */\n\t    READ (pipe_host2tgt, &len, sizeof (size_t));\n\t    MALLOC (char *, lib_path, len);\n\t    READ (pipe_host2tgt, lib_path, len);\n\n\t    /* Open library.  */\n\t    void *handle = dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL);\n\t    if (handle == NULL)\n\t      COIERROR (\"Cannot load %s: %s\", lib_path, dlerror ());\n\n\t    /* Send data to host.  */\n\t    WRITE (pipe_tgt2host, &handle, sizeof (void *));\n\n\t    /* Clean up.  */\n\t    free (lib_path);\n\n\t    break;\n\t  }\n\tcase CMD_CLOSE_LIBRARY:\n\t  {\n\t    /* Receive data from host.  */\n\t    void *handle;\n\t    READ (pipe_host2tgt, &handle, sizeof (void *));\n\n\t    dlclose (handle);\n\n\t    break;\n\t  }\n\tcase CMD_PIPELINE_CREATE:\n\t  {\n\t    /* Receive data from host.  */\n\t    uint32_t *pipeline_num;\n\t    MALLOC (uint32_t *, pipeline_num, sizeof (uint32_t));\n\t    READ (pipe_host2tgt, pipeline_num, sizeof (*pipeline_num));\n\n\t    /* Create a new thread for the pipeline.  */\n\t    pthread_t thread;\n\t    if (pthread_create (&thread, NULL, pipeline_thread_routine,\n\t\t\t\tpipeline_num))\n\t      COIERROR (\"Cannot create new thread.\");\n\t    break;\n\t  }\n\tcase CMD_SHUTDOWN:\n\t  if (close (pipe_host2tgt) < 0)\n\t    COIERROR (\"Cannot close host-to-target main pipe.\");\n\t  if (close (pipe_tgt2host) < 0)\n\t    COIERROR (\"Cannot close target-to-host main pipe.\");\n\t  return COI_SUCCESS;\n\tdefault:\n\t  COIERROR (\"Unrecognizable command from host.\");\n\t}\n    }\n\n  return COI_ERROR;\n}\n\n\n\nuint64_t\nSYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n{\n  COITRACE (\"COIPerfGetCycleFrequency\");\n\n  return (uint64_t) CYCLE_FREQUENCY;\n}\n\n} // extern \"C\"\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/config/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 56 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2009 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '/^# Generated shell functions inserted here/q' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_XSI_SHELLFNS\n\n  sed -n '/^# Generated shell functions inserted here/,$p' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\tif test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]][[,.]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES\n# --------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX\n# -----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nAC_LINK_IFELSE(AC_LANG_PROGRAM,[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`print -r -- -n 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*linux*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*linux*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[AC_CHECK_TOOL(AR, ar, false)\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1])\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`func_fallback_echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nvoid fnord () __attribute__((visibility(\"default\")));\n#endif\n\nvoid fnord () { int i=42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhaiku*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method == \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nconst struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-Xcompiler -fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\nAC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw* | cegcc*)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n        save_LDFLAGS=\"$LDFLAGS\"\n        LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n        AC_LINK_IFELSE(int foo(void) {},\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n        )\n        LDFLAGS=\"$save_LDFLAGS\"\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],\n    [[If ld is used when linking, flag to hardcode $libdir into a binary\n    during linking.  This must work even if $libdir does not exist]])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [fix_srcfile_path], [1],\n    [Fix the shell variable $srcfile for the compiler])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n        # as there is no search path for DLLs.\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n        _LT_TAGVAR(always_export_symbols, $1)=no\n        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n          # If the export-symbols file already is a .def file (1st line\n          # is EXPORTS), use it as is; otherwise, prepend...\n          _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    cp $export_symbols $output_objdir/$soname.def;\n          else\n\t    echo EXPORTS > $output_objdir/$soname.def;\n\t    cat $export_symbols >> $output_objdir/$soname.def;\n          fi~\n          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n        else\n          _LT_TAGVAR(ld_shlibs, $1)=no\n        fi\n        ;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() { }\n_LT_EOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${F77-\"f77\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${FC-\"f95\"}\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GCJ_CONFIG\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=\"$GCC\"\nGCC=yes\nCC=${GOC-\"gccgo\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n# LT_PROG_GO\n# -----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_XSI_SHELLFNS\n# ---------------------\n# Bourne and XSI compatible variants of some useful shell functions.\nm4_defun([_LT_PROG_XSI_SHELLFNS],\n[case $xsi_shell in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nfunc_stripname ()\n{\n  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n  # positional parameters, so assign one to ordinary parameter first.\n  func_stripname_result=${3}\n  func_stripname_result=${func_stripname_result#\"${1}\"}\n  func_stripname_result=${func_stripname_result%\"${2}\"}\n}\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=${1%%=*}\n  func_opt_split_arg=${1#*=}\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  case ${1} in\n    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n    *)    func_lo2o_result=${1} ;;\n  esac\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=${1%.*}.lo\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=$(( $[*] ))\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=${#1}\n}\n\n_LT_EOF\n    ;;\n  *) # Bourne compatible functions.\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n}\n\ndnl func_dirname_and_basename\ndnl A portable version of this function is already defined in general.m4sh\ndnl so there is no need for it here.\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n  case ${2} in\n    .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n    *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n}\n\n# sed scripts:\nmy_sed_long_opt='1s/^\\(-[[^=]]*\\)=.*/\\1/;q'\nmy_sed_long_arg='1s/^-[[^=]]*=//'\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=`$ECHO \"${1}\" | $SED \"$my_sed_long_opt\"`\n  func_opt_split_arg=`$ECHO \"${1}\" | $SED \"$my_sed_long_arg\"`\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[[^.]]*$/.lo/'`\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=`expr \"$[@]\"`\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=`expr \"$[1]\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n}\n\n_LT_EOF\nesac\n\ncase $lt_shell_append in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]+=\\$[2]\"\n}\n_LT_EOF\n    ;;\n  *)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]=\\$$[1]\\$[2]\"\n}\n\n_LT_EOF\n    ;;\n  esac\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/config/ltmain.sh": "# Generated from ltmain.m4sh.\n\n# libtool (GNU libtool 1.3134 2009-11-29) 2.2.7a\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --no-finish          let install mode avoid finish commands\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool 1.3134 2009-11-29) 2.2.7a\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=2.2.7a\nTIMESTAMP=\" 1.3134 2009-11-29\"\npackage_revision=1.3134\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\n# Only set LANG and LC_ALL to C if already set.\n# These must not be set unconditionally because not all systems understand\n# e.g. LANG=C (notably SCO).\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\n\n$lt_unset CDPATH\n\n\n\n\n\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\n: ${ECHO=$as_echo}\n: ${EGREP=\"/bin/grep -E\"}\n: ${FGREP=\"/bin/grep -F\"}\n: ${GREP=\"/bin/grep\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SED=\"/mount/endor/wildenhu/local-x86_64/bin/sed\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n  func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n}\n\n# Generated shell functions inserted here.\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=:\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname${mode+: }$mode: $*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname${mode+: }$mode: \"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname${mode+: }$mode: warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# //\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $SED -n '/^# Usage:/,/^#  *-h/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(automake --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(autoconf --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n     }' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    func_error \"missing argument for $1\"\n    exit_cmd=exit\n}\n\nexit_cmd=:\n\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\n# $mode is unset\nnonopt=\nexecute_dlfiles=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\nopt_dry_run=false\nopt_finish=:\nopt_duplicate_deps=false\nopt_silent=false\nopt_debug=:\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# Parse options once, thoroughly.  This comes as soon as possible in\n# the script to make things like `libtool --version' happen quickly.\n{\n\n  # Shorthand for --mode=foo, only valid as the first argument\n  case $1 in\n  clean|clea|cle|cl)\n    shift; set dummy --mode clean ${1+\"$@\"}; shift\n    ;;\n  compile|compil|compi|comp|com|co|c)\n    shift; set dummy --mode compile ${1+\"$@\"}; shift\n    ;;\n  execute|execut|execu|exec|exe|ex|e)\n    shift; set dummy --mode execute ${1+\"$@\"}; shift\n    ;;\n  finish|finis|fini|fin|fi|f)\n    shift; set dummy --mode finish ${1+\"$@\"}; shift\n    ;;\n  install|instal|insta|inst|ins|in|i)\n    shift; set dummy --mode install ${1+\"$@\"}; shift\n    ;;\n  link|lin|li|l)\n    shift; set dummy --mode link ${1+\"$@\"}; shift\n    ;;\n  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n    shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n    ;;\n  esac\n\n  # Parse non-mode specific arguments:\n  while test \"$#\" -gt 0; do\n    opt=\"$1\"\n    shift\n\n    case $opt in\n      --config)\t\tfunc_config\t\t\t\t\t;;\n\n      --debug)\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\topt_debug='set -x'\n\t\t\t$opt_debug\n\t\t\t;;\n\n      -dlopen)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\texecute_dlfiles=\"$execute_dlfiles $1\"\n\t\t\tshift\n\t\t\t;;\n\n      --dry-run | -n)\topt_dry_run=:\t\t\t\t\t;;\n      --features)       func_features\t\t\t\t\t;;\n      --finish)\t\tmode=\"finish\"\t\t\t\t\t;;\n      --no-finish)\topt_finish=false\t\t\t\t;;\n\n      --mode)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tcase $1 in\n\t\t\t  # Valid mode arguments:\n\t\t\t  clean)\t;;\n\t\t\t  compile)\t;;\n\t\t\t  execute)\t;;\n\t\t\t  finish)\t;;\n\t\t\t  install)\t;;\n\t\t\t  link)\t\t;;\n\t\t\t  relink)\t;;\n\t\t\t  uninstall)\t;;\n\n\t\t\t  # Catch anything else as an error\n\t\t\t  *) func_error \"invalid argument for $opt\"\n\t\t\t     exit_cmd=exit\n\t\t\t     break\n\t\t\t     ;;\n\t\t        esac\n\n\t\t\tmode=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\n      --preserve-dup-deps)\n\t\t\topt_duplicate_deps=:\t\t\t\t;;\n\n      --quiet|--silent)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=:\n\t\t\topt_verbose=false\n\t\t\t;;\n\n      --no-quiet|--no-silent)\n\t\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\t;;\n\n      --verbose| -v)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\topt_verbose=:\n\t\t\t;;\n\n      --no-verbose)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_verbose=false\n\t\t\t;;\n\n      --tag)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tpreserve_args=\"$preserve_args $opt $1\"\n\t\t\tfunc_enable_tag \"$1\"\t# tagname is set here\n\t\t\tshift\n\t\t\t;;\n\n      # Separate optargs to long options:\n      -dlopen=*|--mode=*|--tag=*)\n\t\t\tfunc_opt_split \"$opt\"\n\t\t\tset dummy \"$func_opt_split_opt\" \"$func_opt_split_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t\t;;\n      --help)\t\topt_help=:\t\t\t\t\t;;\n      --help-all)\topt_help=': help-all'\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t\t;;\n\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\"\t;;\n\n      *)\t\tnonopt=\"$opt\"\n\t\t\tbreak\n\t\t\t;;\n    esac\n  done\n\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* )\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps\n      ;;\n  esac\n\n  # Having warned about all mis-specified options, bail out if\n  # anything was wrong.\n  $exit_cmd $EXIT_FAILURE\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n$opt_help || {\n  # Sanity checks first:\n  func_check_version_match\n\n  if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n    func_fatal_configuration \"not configured to build any kind of library\"\n  fi\n\n  test -z \"$mode\" && func_fatal_error \"error: you must specify a MODE.\"\n\n\n  # Darwin sucks\n  eval \"std_shrext=\\\"$shrext_cmds\\\"\"\n\n\n  # Only execute mode is allowed to have -dlopen flags.\n  if test -n \"$execute_dlfiles\" && test \"$mode\" != execute; then\n    func_error \"unrecognized option \\`-dlopen'\"\n    $ECHO \"$help\" 1>&2\n    exit $EXIT_FAILURE\n  fi\n\n  # Change the help message to a mode-specific one.\n  generic_help=\"$help\"\n  help=\"Try \\`$progname --help --mode=$mode' for more information.\"\n}\n\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_ltwrapper_scriptname_result=\"\"\n    if func_ltwrapper_executable_p \"$1\"; then\n\tfunc_dirname_and_basename \"$1\" \"\" \".\"\n\tfunc_stripname '' '.exe' \"$func_basename_result\"\n\tfunc_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n    fi\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval \"cmd=\\\"$cmd\\\"\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n        func_quote_for_eval \"$arg\"\n\tCC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_quote_for_eval \"$arg\"\n\t      CC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          pie_flag=\"$pie_flag $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  later=\"$later $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_quote_for_eval \"$arg\"\n\t    lastarg=\"$lastarg $func_quote_for_eval_result\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  base_compile=\"$base_compile $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_quote_for_eval \"$lastarg\"\n      base_compile=\"$base_compile $func_quote_for_eval_result\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      removelist=\"$removelist $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    removelist=\"$removelist $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    if test -n \"$fix_srcfile_path\"; then\n      eval \"srcfile=\\\"$fix_srcfile_path\\\"\"\n    fi\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tcommand=\"$command -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tcommand=\"$command -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      command=\"$command$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to building PIC objects only\n  -prefer-non-pic   try to building non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $execute_dlfiles; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  dir=\"$dir/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval test -z \\\"\\$$shlibpath_var\\\"; then\n\teval $shlibpath_var=\\$dir\n      else\n\teval $shlibpath_var=\\$dir:\\$$shlibpath_var\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_quote_for_eval \"$file\"\n      args=\"$args $func_quote_for_eval_result\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libdirs=\"$nonopt\"\n    admincmds=\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for dir\n      do\n\tlibdirs=\"$libdirs $dir\"\n      done\n\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || admincmds=\"$admincmds\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    echo \"----------------------------------------------------------------------\"\n    echo \"Libraries have been installed in:\"\n    for libdir in $libdirs; do\n      $ECHO \"   $libdir\"\n    done\n    echo\n    echo \"If you ever happen to want to link against installed libraries\"\n    echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n    echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n    echo \"flag during linking and do at least one of the following:\"\n    if test -n \"$shlibpath_var\"; then\n      echo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n      echo \"     during execution\"\n    fi\n    if test -n \"$runpath_var\"; then\n      echo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n      echo \"     during linking\"\n    fi\n    if test -n \"$hardcode_libdir_flag_spec\"; then\n      libdir=LIBDIR\n      eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\n      $ECHO \"   - use the \\`$flag' linker flag\"\n    fi\n    if test -n \"$admincmds\"; then\n      $ECHO \"   - have your system administrator run these commands:$admincmds\"\n    fi\n    if test -f /etc/ld.so.conf; then\n      echo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n    fi\n    echo\n\n    echo \"See any operating system documentation about shared libraries for\"\n    case $host in\n      solaris2.[6789]|solaris2.1[0-9])\n        echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\techo \"pages.\"\n\t;;\n      *)\n        echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n        ;;\n    esac\n    echo \"----------------------------------------------------------------------\"\n    exit $EXIT_SUCCESS\n}\n\ntest \"$mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    install_prog=\"$install_prog$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfiles=\"$files $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      install_prog=\"$install_prog $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      install_shared_prog=\"$install_shared_prog $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tinstall_shared_prog=\"$install_shared_prog -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tstaticlibs=\"$staticlibs $file\"\n\t;;\n\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) current_libdirs=\"$current_libdirs $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) future_libdirs=\"$future_libdirs $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tdir=\"$dir$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && staticlibs=\"$staticlibs $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\" && $opt_finish; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_verbose \"extracting global C symbols from \\`$progfile'\"\n\t    $opt_dry_run || eval \"$NM $progfile | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      $EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      ${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' < \"$nlist\" > \"$export_symbols\"\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                echo EXPORTS > \"$output_objdir/$outputname.def\"\n                cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      ${SED} -e 's/\\([].[*^$]\\)/\\\\\\1/g' -e 's/^/ /' -e 's/$/$/' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"\n\t      $GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T\n\t      $MV \"$nlist\"T \"$nlist\"\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          echo EXPORTS > \"$output_objdir/$outputname.def\"\n\t          cat \"$nlist\" >> \"$output_objdir/$outputname.def\"\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n\t  $opt_dry_run || {\n\t    $ECHO \": $name \" >> \"$nlist\"\n\t    eval \"$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t  }\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\n\"\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* )\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* DATA imports from DLLs on WIN32 con't be const, because\n   runtime relocations are performed -- see ld's documentation\n   on pseudo-relocs.  */\"\n\t    lt_dlsym_const= ;;\n\t  *osf5*)\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* This system does not cope well with relocations in const data */\"\n\t    lt_dlsym_const= ;;\n\t  *)\n\t    lt_dlsym_const=const ;;\n\t  esac\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\nextern $lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\n$lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) symtab_cflags=\"$symtab_cflags $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    if $OBJDUMP -f \"$1\" | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pe-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      win32_nmres=`$NM -f posix -A \"$1\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\\\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\\"\\$relink_command\\\" 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t# fixup the dll searchpath if we need to.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n\"\n\tcase $host in\n\t# Backslashes separate directories on plain windows\n\t*-*-mingw | *-*-os2* | *-cegcc*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\n\t*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\tesac\n\t$ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_to_host_path arg\n#\n# Convert paths to host format when used with build tools.\n# Intended for use with \"native\" mingw (where libtool itself\n# is running under the msys shell), or in the following cross-\n# build environments:\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n# where wine is equipped with the `winepath' executable.\n# In the native mingw case, the (msys) shell automatically\n# converts paths for any non-msys applications it launches,\n# but that facility isn't available from inside the cwrapper.\n# Similar accommodations are necessary for $host mingw and\n# $build cygwin.  Calling this function does no harm for other\n# $host/$build combinations not listed above.\n#\n# ARG is the path (on $build) that should be converted to\n# the proper representation for $host. The result is stored\n# in $func_to_host_path_result.\nfunc_to_host_path ()\n{\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        case $build in\n          *mingw* ) # actually, msys\n            # awkward: cmd appends spaces to result\n            func_to_host_path_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n              $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_path_result=`cygpath -w \"$1\" |\n\t      $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # Unfortunately, winepath does not exit with a non-zero\n            # error code, so we are forced to check the contents of\n            # stdout. On the other hand, if the command is not\n            # found, the shell will set an exit code of 127 and print\n            # *an error message* to stdout. So we must check for both\n            # error code of zero AND non-empty stdout, which explains\n            # the odd construction:\n            func_to_host_path_tmp1=`winepath -w \"$1\" 2>/dev/null`\n            if test \"$?\" -eq 0 && test -n \"${func_to_host_path_tmp1}\"; then\n              func_to_host_path_result=`$ECHO \"$func_to_host_path_tmp1\" |\n                $SED -e \"$lt_sed_naive_backslashify\"`\n            else\n              # Allow warning below.\n              func_to_host_path_result=\n            fi\n            ;;\n        esac\n        if test -z \"$func_to_host_path_result\" ; then\n          func_error \"Could not determine host path corresponding to\"\n          func_error \"  \\`$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback:\n          func_to_host_path_result=\"$1\"\n        fi\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_path\n\n# func_to_host_pathlist arg\n#\n# Convert pathlists to host format when used with build tools.\n# See func_to_host_path(), above. This function supports the\n# following $build/$host combinations (but does no harm for\n# combinations not listed here):\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n#\n# Path separators are also converted from $build format to\n# $host format. If ARG begins or ends with a path separator\n# character, it is preserved (but converted to $host format)\n# on output.\n#\n# ARG is a pathlist (on $build) that should be converted to\n# the proper representation on $host. The result is stored\n# in $func_to_host_pathlist_result.\nfunc_to_host_pathlist ()\n{\n  func_to_host_pathlist_result=\"$1\"\n  if test -n \"$1\"; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        # Remove leading and trailing path separator characters from\n        # ARG. msys behavior is inconsistent here, cygpath turns them\n        # into '.;' and ';.', and winepath ignores them completely.\n\tfunc_stripname : : \"$1\"\n        func_to_host_pathlist_tmp1=$func_stripname_result\n        case $build in\n          *mingw* ) # Actually, msys.\n            # Awkward: cmd appends spaces to result.\n            func_to_host_pathlist_result=`\n\t      ( cmd //c echo \"$func_to_host_pathlist_tmp1\" ) 2>/dev/null |\n\t      $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_pathlist_result=`cygpath -w -p \"$func_to_host_pathlist_tmp1\" |\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # unfortunately, winepath doesn't convert pathlists\n            func_to_host_pathlist_result=\"\"\n            func_to_host_pathlist_oldIFS=$IFS\n            IFS=:\n            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do\n              IFS=$func_to_host_pathlist_oldIFS\n              if test -n \"$func_to_host_pathlist_f\" ; then\n                func_to_host_path \"$func_to_host_pathlist_f\"\n                if test -n \"$func_to_host_path_result\" ; then\n                  if test -z \"$func_to_host_pathlist_result\" ; then\n                    func_to_host_pathlist_result=\"$func_to_host_path_result\"\n                  else\n                    func_append func_to_host_pathlist_result \";$func_to_host_path_result\"\n                  fi\n                fi\n              fi\n            done\n            IFS=$func_to_host_pathlist_oldIFS\n            ;;\n        esac\n        if test -z \"$func_to_host_pathlist_result\"; then\n          func_error \"Could not determine the host path(s) corresponding to\"\n          func_error \"  \\`$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback. This may break if $1 contains DOS-style drive\n          # specifications. The fix is not to complicate the expression\n          # below, but for the user to provide a working wine installation\n          # with winepath so that path translation in the cross-to-mingw\n          # case works properly.\n          lt_replace_pathsep_nix_to_dos=\"s|:|;|g\"\n          func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp1\" |\\\n            $SED -e \"$lt_replace_pathsep_nix_to_dos\"`\n        fi\n        # Now, add the leading and trailing path separators back\n        case \"$1\" in\n          :* ) func_to_host_pathlist_result=\";$func_to_host_pathlist_result\"\n            ;;\n        esac\n        case \"$1\" in\n          *: ) func_append func_to_host_pathlist_result \";\"\n            ;;\n        esac\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_pathlist\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n\n   Currently, it simply execs the wrapper *script* \"$SHELL $output\",\n   but could eventually absorb all of the scripts functionality and\n   exec $objdir/$outputname directly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#undef LTWRAPPER_DEBUGPRINTF\n#if defined LT_DEBUGWRAPPER\n# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args\nstatic void\nltwrapper_debugprintf (const char *fmt, ...)\n{\n    va_list args;\n    va_start (args, fmt);\n    (void) vfprintf (stderr, fmt, args);\n    va_end (args);\n}\n#else\n# define LTWRAPPER_DEBUGPRINTF(args)\n#endif\n\nconst char *program_name = NULL;\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_fatal (const char *message, ...);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nconst char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_pathlist \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_pathlist \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n#define LTWRAPPER_OPTION_PREFIX_LENGTH  5\n\nstatic const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\n\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) argv[0]      : %s\\n\", argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) program_name : %s\\n\", program_name));\n\n  /* very simple arg parsing; don't want to rely on getopt */\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n    }\n\n  newargz = XMALLOC (char *, argc + 1);\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (\"Couldn't find %s\", argv[0]);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (before symlink chase) at : %s\\n\",\n\t\t\t  tmp_pathspec));\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (after symlink chase) at : %s\\n\",\n\t\t\t  actual_cwrapper_path));\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(main) libtool target name: %s\\n\",\n\t\t\t  target_name));\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (\"Unrecognized option in %s namespace: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\n  LTWRAPPER_DEBUGPRINTF     ((\"(main) lt_argv_zero : %s\\n\", (lt_argv_zero ? lt_argv_zero : \"<NULL>\")));\n  for (i = 0; i < newargc; i++)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"(main) newargz[%d]   : %s\\n\", i, (newargz[i] ? newargz[i] : \"<NULL>\")));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      LTWRAPPER_DEBUGPRINTF ((\"(main) failed to launch target \\\"%s\\\": errno = %d\\n\", lt_argv_zero, errno));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (\"Memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(check_executable)  : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(make_executable)   : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(find_executable)   : %s\\n\",\n\t\t\t  wrapper ? (*wrapper ? wrapper : \"EMPTY!\") : \"NULL!\"));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (\"getcwd failed\");\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (\"getcwd failed\");\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"checking path component for symlinks: %s\\n\",\n\t\t\t      tmp_pathspec));\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  char *errstr = strerror (errno);\n\t  lt_fatal (\"Error accessing file %s (%s)\", tmp_pathspec, errstr);\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (\"Could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nstatic void\nlt_error_core (int exit_status, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s: %s: \", program_name, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_setenv) setting '%s' to '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n              $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t           -e 's/^/  fputs (\"/' -e 's/$/\\\\n\", f);/'\n\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval \"$file_magic_cmd \\\"\\$1\\\" 2>/dev/null\" | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      dlfiles=\"$dlfiles $arg\"\n\t    else\n\t      dlprefiles=\"$dlprefiles $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) deplibs=\"$deplibs $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      moreargs=\"$moreargs $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      dlfiles=\"$dlfiles $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    dlprefiles=\"$dlprefiles $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) rpath=\"$rpath $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) xrpath=\"$xrpath $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  weak_libs=\"$weak_libs $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname '-L' '' \"$arg\"\n\tdir=$func_stripname_result\n\tif test -z \"$dir\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"*) ;;\n\t*)\n\t  deplibs=\"$deplibs -L$dir\"\n\t  lib_search_path=\"$lib_search_path $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-linux*)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tdeplibs=\"$deplibs $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) xrpath=\"$xrpath $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $wl$func_quote_for_eval_result\"\n\t  linker_flags=\"$linker_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler\n      # -r[0-9][0-9]* specifies the processor on the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler\n      # +DA*, +DD* enable 64-bit mode on the HP compiler\n      # -q* pass through compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* pass through architecture-specific\n      # compiler args for GCC\n      # -F/path gives path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC\n      # @file GCC response files\n      # -tp=* Portland pgcc target processor selection\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        compiler_flags=\"$compiler_flags $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tobjs=\"$objs $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tdlfiles=\"$dlfiles $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      dlprefiles=\"$dlprefiles $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tdeplibs=\"$deplibs $arg\"\n\told_deplibs=\"$old_deplibs $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  dlfiles=\"$dlfiles $arg\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  dlprefiles=\"$dlprefiles $arg\"\n\t  prev=\n\telse\n\t  deplibs=\"$deplibs $arg\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval \"arg=\\\"$export_dynamic_flag_spec\\\"\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval \"sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\"\n    eval \"sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_duplicate_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\tesac\n      fi\n      libs=\"$libs $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) specialdeplibs=\"$specialdeplibs $pre_post_deps\" ;;\n\t  esac\n\t  pre_post_deps=\"$pre_post_deps $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  case $lib in\n\t  *.la)\tfunc_source \"$lib\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) deplibs=\"$deplibs $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    compiler_flags=\"$compiler_flags $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    dir=$func_stripname_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) xrpath=\"$xrpath $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la) lib=\"$deplib\" ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      newdlprefiles=\"$newdlprefiles $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      newdlfiles=\"$newdlfiles $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) new_inherited_linker_flags=\"$new_inherited_linker_flags $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && dlfiles=\"$dlfiles $dlopen\"\n\t  test -n \"$dlpreopen\" && dlprefiles=\"$dlprefiles $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    convenience=\"$convenience $ladir/$objdir/$old_library\"\n\t    old_convenience=\"$old_convenience $ladir/$objdir/$old_library\"\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tfor l in $old_library $library_names; do\n\t  linklib=\"$l\"\n\tdone\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    dlprefiles=\"$dlprefiles $lib $dependency_libs\"\n\t  else\n\t    newdlfiles=\"$newdlfiles $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$libdir\"\n\t    absdir=\"$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t  # are required to link).\n\t  if test -n \"$old_library\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$old_library\"\n\t    # Keep a list of preopened convenience libraries to check\n\t    # that they are being used correctly in the link pass.\n\t    test -z \"$libdir\" && \\\n\t\tdlpreconveniencelibs=\"$dlpreconveniencelibs $dir/$old_library\"\n\t  # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t  elif test -n \"$dlname\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$dlname\"\n\t  else\n\t    newdlprefiles=\"$newdlprefiles $dir/$linklib\"\n\t  fi\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  newlib_search_path=\"$newlib_search_path $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) temp_rpath=\"$temp_rpath$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    eval \"libname=\\\"$libname_spec\\\"\"\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval \"soname=\\\"$soname_spec\\\"\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) compile_shlibpath=\"$compile_shlibpath$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) xrpath=\"$xrpath $temp_xrpath\";;\n\t\t   esac;;\n\t      *) temp_deplibs=\"$temp_deplibs $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  newlib_search_path=\"$newlib_search_path $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=\"$func_dirname_result\"\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      compiler_flags=\"$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      linker_flags=\"$linker_flags -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) lib_search_path=\"$lib_search_path $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\$$var\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\$tmp_libs\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  tmp_libs=\"$tmp_libs $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      objs=\"$objs$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\teval \"libname=\\\"$libname_spec\\\"\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\t  eval \"libname=\\\"$libname_spec\\\"\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  libobjs=\"$libobjs $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  verstring=\"$verstring:${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      libobjs=\"$libobjs $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       removelist=\"$removelist $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\toldlibs=\"$oldlibs $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  temp_xrpath=\"$temp_xrpath -R$libdir\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlfiles=\"$dlfiles $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlprefiles=\"$dlprefiles $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      deplibs=\"$deplibs -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  eval \"libname=\\\"$libname_spec\\\"\"\n\t\t  eval \"deplib_matches=\\\"$library_names_spec\\\"\"\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    eval \"libname=\\\"$libname_spec\\\"\"\n\t\t    eval \"deplib_matches=\\\"$library_names_spec\\\"\"\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\teval \"libname=\\\"$libname_spec\\\"\"\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval \"$file_magic_cmd \\\"\\$potlib\\\"\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tnewdeplibs=\"$newdeplibs $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\teval \"libname=\\\"$libname_spec\\\"\"\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    hardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t\tdep_rpath=\"$dep_rpath $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    if test -n \"$hardcode_libdir_flag_spec_ld\"; then\n\t      eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec_ld\\\"\"\n\t    else\n\t      eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    fi\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      rpath=\"$rpath$dir:\"\n\t    done\n\t    eval $runpath_var=\\$rpath\\$$runpath_var\n\t    export $runpath_var\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval $shlibpath_var=\\$shlibpath\\$$shlibpath_var\n\t  export $shlibpath_var\n\tfi\n\n\t# Get the real and link names of the library.\n\teval \"shared_ext=\\\"$shrext_cmds\\\"\"\n\teval \"library_names=\\\"$library_names_spec\\\"\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval \"soname=\\\"$soname_spec\\\"\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  linknames=\"$linknames $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  delfiles=\"$delfiles $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      eval \"cmd=\\\"$cmd\\\"\"\n\t      func_len \" $cmd\"\n\t      len=$func_len_result\n\t      if test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || $ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    tmp_deplibs=\"$tmp_deplibs $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval \"libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    generated=\"$generated $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    libobjs=\"$libobjs $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval \"flag=\\\"$thread_safe_flag_spec\\\"\"\n\t  linker_flags=\"$linker_flags $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || (cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U) || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval \"test_cmds=\\\"$module_expsym_cmds\\\"\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval \"test_cmds=\\\"$module_cmds\\\"\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval \"test_cmds=\\\"$archive_expsym_cmds\\\"\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval \"test_cmds=\\\"$archive_cmds\\\"\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    delfiles=\"$delfiles $output\"\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    delfiles=\"$delfiles $output\"\n\t    output=$firstobj\\\"$file_list_spec$output\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval \"test_cmds=\\\"$reload_cmds\\\"\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval \"concat_cmds=\\\"$reload_cmds\\\"\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval \"concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval \"concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\"\n\t      if test -n \"$last_robj\"; then\n\t        eval \"concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\"\n\t      fi\n\t      delfiles=\"$delfiles $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval \"concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\"\n\t      if test -n \"$last_robj\"; then\n\t\teval \"concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || $ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval \"libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval \"cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  libobjs=\"$libobjs $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval \"cmd=\\\"$cmd\\\"\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || (cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname) || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval \"tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || echo timestamp > $libobj || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      compile_command=\"$compile_command ${wl}-bind_at_load\"\n\t      finalize_command=\"$finalize_command ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      compile_command=\"$compile_command $compile_deplibs\"\n      finalize_command=\"$finalize_command $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval \"rpath=\\\" $hardcode_libdir_flag_spec\\\"\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval \"flag=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_perm_rpath=\"$finalize_perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval \"rpath=\\\" $hardcode_libdir_flag_spec\\\"\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    oldobjs=\"$oldobjs $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tgenerated=\"$generated $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\toldobjs=\"$oldobjs $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  oldobjs=\"$oldobjs $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      oldobjs=\"$oldobjs $gentop/$newobj\"\n\t      ;;\n\t    *) oldobjs=\"$oldobjs $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\teval \"cmds=\\\"$old_archive_cmds\\\"\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval \"test_cmds=\\\"$old_archive_cmds\\\"\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval \"concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval \"cmds=\\\"\\$concat_cmds\\\"\"\n\t  else\n\t    eval \"cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tnewdependency_libs=\"$newdependency_libs $libdir/$name\"\n\t\t;;\n\t      *) newdependency_libs=\"$newdependency_libs $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlfiles=\"$newdlfiles $libdir/$name\"\n\t\t;;\n\t      *) newdlfiles=\"$newdlfiles $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\tlibdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlprefiles=\"$newdlprefiles $libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlfiles=\"$newdlfiles $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlprefiles=\"$newdlprefiles $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$mode\" = link || test \"$mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) RM=\"$RM $arg\"; rmforce=yes ;;\n      -*) RM=\"$RM $arg\" ;;\n      *) files=\"$files $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    origobjdir=\"$objdir\"\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\tobjdir=\"$origobjdir\"\n      else\n\tobjdir=\"$dir/$origobjdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$mode\" = uninstall && objdir=\"$dir\"\n\n      # Remember objdir for removal later, being careful to avoid duplicates\n      if test \"$mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $objdir \"*) ;;\n\t  *) rmdirs=\"$rmdirs $objdir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    rmfiles=\"$rmfiles $objdir/$n\"\n\t  done\n\t  test -n \"$old_library\" && rmfiles=\"$rmfiles $objdir/$old_library\"\n\n\t  case \"$mode\" in\n\t  clean)\n\t    case \"  $library_names \" in\n\t    # \"  \" in the beginning catches empty $dlname\n\t    *\" $dlname \"*) ;;\n\t    *) rmfiles=\"$rmfiles $objdir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && rmfiles=\"$rmfiles $objdir/$name $objdir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    rmfiles=\"$rmfiles $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      rmfiles=\"$rmfiles $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    rmfiles=\"$rmfiles $objdir/$name $objdir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      rmfiles=\"$rmfiles $objdir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      rmfiles=\"$rmfiles $objdir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n    objdir=\"$origobjdir\"\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$mode\" = uninstall || test \"$mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/plugin/plugin_dlopen.go": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build linux,cgo darwin,cgo\n\npackage plugin\n\n/*\n#cgo linux LDFLAGS: -ldl\n#include <dlfcn.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <stdio.h>\n\nstatic uintptr_t pluginOpen(const char* path, char** err) {\n\tvoid* h = dlopen(path, RTLD_NOW|RTLD_GLOBAL);\n\tif (h == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn (uintptr_t)h;\n}\n\nstatic void* pluginLookup(uintptr_t h, const char* name, char** err) {\n\tvoid* r = dlsym((void*)h, name);\n\tif (r == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn r;\n}\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\nfunc open(name string) (*Plugin, error) {\n\tcPath := (*C.char)(C.malloc(C.PATH_MAX + 1))\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tcRelName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cRelName))\n\tif C.realpath(cRelName, cPath) == nil {\n\t\treturn nil, errors.New(\"plugin.Open(\" + name + \"): realpath failed\")\n\t}\n\n\tfilepath := C.GoString(cPath)\n\n\tpluginsMu.Lock()\n\tif p := plugins[filepath]; p != nil {\n\t\tpluginsMu.Unlock()\n\t\t<-p.loaded\n\t\treturn p, nil\n\t}\n\tvar cErr *C.char\n\th := C.pluginOpen(cPath, &cErr)\n\tif h == 0 {\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(\"plugin.Open: \" + C.GoString(cErr))\n\t}\n\t// TODO(crawshaw): look for plugin note, confirm it is a Go plugin\n\t// and it was built with the correct toolchain.\n\tif len(name) > 3 && name[len(name)-3:] == \".so\" {\n\t\tname = name[:len(name)-3]\n\t}\n\n\tpluginpath, syms, mismatchpkg := lastmoduleinit()\n\tif mismatchpkg != \"\" {\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(\"plugin.Open: plugin was built with a different version of package \" + mismatchpkg)\n\t}\n\tif plugins == nil {\n\t\tplugins = make(map[string]*Plugin)\n\t}\n\t// This function can be called from the init function of a plugin.\n\t// Drop a placeholder in the map so subsequent opens can wait on it.\n\tp := &Plugin{\n\t\tpluginpath: pluginpath,\n\t\tloaded:     make(chan struct{}),\n\t\tsyms:       syms,\n\t}\n\tplugins[filepath] = p\n\tpluginsMu.Unlock()\n\n\tinitStr := C.CString(pluginpath + \".init\")\n\tinitFuncPC := C.pluginLookup(h, initStr, &cErr)\n\tC.free(unsafe.Pointer(initStr))\n\tif initFuncPC != nil {\n\t\tinitFuncP := &initFuncPC\n\t\tinitFunc := *(*func())(unsafe.Pointer(&initFuncP))\n\t\tinitFunc()\n\t}\n\n\t// Fill out the value of each plugin symbol.\n\tfor symName, sym := range syms {\n\t\tisFunc := symName[0] == '.'\n\t\tif isFunc {\n\t\t\tdelete(syms, symName)\n\t\t\tsymName = symName[1:]\n\t\t}\n\n\t\tcname := C.CString(pluginpath + \".\" + symName)\n\t\tp := C.pluginLookup(h, cname, &cErr)\n\t\tC.free(unsafe.Pointer(cname))\n\t\tif p == nil {\n\t\t\treturn nil, errors.New(\"plugin.Open: could not find symbol \" + symName + \": \" + C.GoString(cErr))\n\t\t}\n\t\tvalp := (*[2]unsafe.Pointer)(unsafe.Pointer(&sym))\n\t\tif isFunc {\n\t\t\t(*valp)[1] = unsafe.Pointer(&p)\n\t\t} else {\n\t\t\t(*valp)[1] = p\n\t\t}\n\t\tsyms[symName] = sym\n\t}\n\tclose(p.loaded)\n\treturn p, nil\n}\n\nfunc lookup(p *Plugin, symName string) (Symbol, error) {\n\tif s := p.syms[symName]; s != nil {\n\t\treturn s, nil\n\t}\n\treturn nil, errors.New(\"plugin: symbol \" + symName + \" not found in plugin \" + p.pluginpath)\n}\n\nvar (\n\tpluginsMu sync.Mutex\n\tplugins   map[string]*Plugin\n)\n\n// lastmoduleinit is defined in package runtime\nfunc lastmoduleinit() (pluginpath string, syms map[string]interface{}, mismatchpkg string)\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libvtv/testsuite/other-tests/dlopen.cc": "#include <stdlib.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n\n\ntypedef void (*voidfn)(void);\n\nint failures = 0;\n\nvoid\n__vtv_verify_fail (void **data_set_ptr, const void *vtbl_pointer)\n{\n  failures++;\n  return;\n}\n\n\nint main()\n{\n  char so_name[] = \"so0.so\";\n  void * dlhandle = dlopen(so_name, RTLD_NOW);\n  if (!dlhandle)\n    {\n      fprintf(stderr, \"dlopen %s error: %s\\n\", so_name, dlerror());\n      exit(1);\n    }\n  voidfn so_entry = (voidfn)dlsym(dlhandle, \"so_entry_0\");\n  if (!so_entry)\n    {\n      fprintf(stderr, \"dlopen %s dlsym error: %s\\n\", so_name, dlerror());\n      exit(2);\n    }\n\n  so_entry();\n\n  dlclose(dlhandle);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libvtv/testsuite/other-tests/dlopen_mt.cc": "#include <stdlib.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#include \"vtv_utils.h\"\n#include \"vtv_rts.h\"\n#include \"pthread.h\"\n\n#define NUM_REPEATS 10\n#define NUM_THREADS 10\n#define NUM_SOS 100\n#define NUM_SOS_PER_THREAD (NUM_SOS/NUM_THREADS)\n\ntypedef void (*voidfn)(void);\n\nint failures = 0;\n\nvoid\n__vtv_verify_fail (void **data_set_ptr, const void *vtbl_pointer)\n{\n  failures++;\n  return;\n}\n\n\nvoid do_dlopen(int so_num)\n{\n  char so_name [sizeof(\"soxxx.so\")];\n  sprintf(so_name, \"so%d.so\", so_num);\n  //  printf(\"dl-opening %s\\n\", so_name);\n  void * dlhandle = dlopen(so_name, RTLD_NOW);\n  if (!dlhandle)\n    {\n      fprintf(stderr, \"dlopen so:%s error: %s\\n\", so_name, dlerror());\n      exit(1);\n    }\n  char so_entry [sizeof(\"so_entry_xxx\")];\n  sprintf(so_entry, \"so_entry_%d\", so_num);\n  voidfn so_entry_fn = (voidfn)dlsym(dlhandle, so_entry);\n  if (!so_entry_fn)\n    {\n      fprintf(stderr, \"so:%s dlsym error: %s\\n\", so_name, dlerror());\n      exit(2);\n    }\n\n  so_entry_fn();\n\n  dlclose(dlhandle);\n}\n\nvolatile int threads_completed_it = 0;\nvolatile int current_wave = -1;\n\nvoid * do_dlopens(void * ptid)\n{\n  for (int k = 0; k < NUM_REPEATS; k++)\n    {\n\n      for (int i = 0; i < NUM_SOS_PER_THREAD; i++)\n\t{\n\t  while (current_wave < (k*NUM_SOS_PER_THREAD + i)) /* from 0 to 99 */\n\t    ;\n\n          do_dlopen((NUM_SOS_PER_THREAD * *(int *)ptid) + i);\n\n\t  int old_value;\n\t  do {\n\t    old_value = threads_completed_it;\n\t  } while (!__sync_bool_compare_and_swap(&threads_completed_it, old_value, old_value + 1));\n\n\t  if (old_value == (NUM_THREADS - 1)) // Only one thread will do this.\n\t    {\n\t      threads_completed_it = 0;\n\t      printf(\"%c%d\", 13, current_wave + 1);\n\t      fflush(stdout);\n\t      current_wave++;\n\t    }\n\t}\n    }\n\n  return NULL;\n}\n\n\nint main()\n{\n  pthread_t thread_ids[NUM_THREADS];\n  int thread_nids[NUM_THREADS];\n\n  for (int t = 0; t < NUM_THREADS; t++ )\n  {\n    thread_nids[t] = t;\n    if (pthread_create(&thread_ids[t], NULL, do_dlopens, &thread_nids[t]) != 0)\n      {\n\tprintf(\"failed pthread_create\\n\");\n\texit(1);\n      }\n  }\n\n  current_wave = 0; // start the work on the other threads\n\n  for (int t = 0; t < NUM_THREADS; t++)\n    if (pthread_join(thread_ids[t], NULL) != 0)\n      { \n\tprintf(\"failed pthread_join\\n\");\n\texit(2);\n      }\n\n  printf(\"\\n\");\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/configure.ac": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ([2.64])\nAC_INIT(package-unused, version-unused, libsanitizer)\nAC_CONFIG_SRCDIR([include/sanitizer/common_interface_defs.h])\n\nAM_ENABLE_MULTILIB(, ..)\n\nAC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\nAC_ARG_ENABLE(version-specific-runtime-libs,\n[  --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory ],\n[case \"$enableval\" in\n yes) version_specific_libs=yes ;;\n no)  version_specific_libs=no ;;\n *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n esac],\n[version_specific_libs=no])\nAC_MSG_RESULT($version_specific_libs)\n\nAC_USE_SYSTEM_EXTENSIONS\n\n# Do not delete or change the following two lines.  For why, see\n# http://gcc.gnu.org/ml/libstdc++/2003-07/msg00451.html\nAC_CANONICAL_SYSTEM\ntarget_alias=${target_alias-$host_alias}\nAC_SUBST(target_alias)\nGCC_LIBSTDCXX_RAW_CXX_FLAGS\n\nAM_INIT_AUTOMAKE(foreign no-dist)\nAM_MAINTAINER_MODE\n\n# Calculate toolexeclibdir\n# Also toolexecdir, though it's only used in toolexeclibdir\ncase ${version_specific_libs} in\n  yes)\n    # Need the gcc compiler version to know where to install libraries\n    # and header files if --enable-version-specific-runtime-libs option\n    # is selected.\n    toolexecdir='$(libdir)/gcc/$(target_alias)'\n    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n    ;;\n  no)\n    if test -n \"$with_cross_host\" &&\n       test x\"$with_cross_host\" != x\"no\"; then\n      # Install a library built with a cross compiler in tooldir, not libdir.\n      toolexecdir='$(exec_prefix)/$(target_alias)'\n      toolexeclibdir='$(toolexecdir)/lib'\n    else\n      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n      toolexeclibdir='$(libdir)'\n    fi\n    multi_os_directory=`$CC -print-multi-os-directory`\n    case $multi_os_directory in\n      .) ;; # Avoid trailing /.\n      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n    esac\n    ;;\nesac\nAC_SUBST(toolexecdir)\nAC_SUBST(toolexeclibdir)\n\n# Checks for programs.\nAC_PROG_CC\nAC_PROG_CXX\nAM_PROG_AS\nAC_PROG_RANLIB\n\nAC_LIBTOOL_DLOPEN\nAM_PROG_LIBTOOL\n\nAC_PROG_AWK\ncase \"$AWK\" in\n\"\") AC_MSG_ERROR([can't build without awk]) ;;\nesac\n\nAC_SUBST(enable_shared)\nAC_SUBST(enable_static)\n\nAC_CHECK_SIZEOF([void *])\n\nif test \"${multilib}\" = \"yes\"; then\n  multilib_arg=\"--enable-multilib\"\nelse\n  multilib_arg=\nfi\n\n# Get target configury.\nunset TSAN_SUPPORTED\nunset LSAN_SUPPORTED\n. ${srcdir}/configure.tgt\nAM_CONDITIONAL(TSAN_SUPPORTED, [test \"x$TSAN_SUPPORTED\" = \"xyes\"])\nAM_CONDITIONAL(LSAN_SUPPORTED, [test \"x$LSAN_SUPPORTED\" = \"xyes\"])\n\n# Check for functions needed.\nAC_CHECK_FUNCS(clock_getres clock_gettime clock_settime)\n\n# Common libraries that we need to link against for all sanitizer libs.\nlink_sanitizer_common='-lpthread -lm'\n\n# At least for glibc, shm_open is in librt.  But don't pull that\n# in if it still doesn't give us the function we want.  This\n# test is copied from libgomp.\nAC_CHECK_LIB(rt, shm_open,\n  [link_sanitizer_common=\"-lrt $link_sanitizer_common\"])\n\n# Do a configure time check for -ldl\nAC_CHECK_LIB(dl, dlsym,\n  [link_sanitizer_common=\"-ldl $link_sanitizer_common\"])\n\n# Set up the set of additional libraries that we need to link against for libasan.\nlink_libasan=$link_sanitizer_common\nAC_SUBST(link_libasan)\n\n# Set up the set of additional libraries that we need to link against for libtsan.\nlink_libtsan=$link_sanitizer_common\nAC_SUBST(link_libtsan)\n\n# Set up the set of additional libraries that we need to link against for libubsan.\nlink_libubsan=$link_sanitizer_common\nAC_SUBST(link_libubsan)\n\n# Set up the set of additional libraries that we need to link against for liblsan.\nlink_liblsan=$link_sanitizer_common\nAC_SUBST(link_liblsan)\n\n\n# At least for glibc, clock_gettime is in librt.  But don't pull that\n# in if it still doesn't give us the function we want.  This\n# test is copied from libgomp.\nAC_CHECK_LIB(rt, clock_gettime,\n  [link_libasan=\"-lrt $link_libasan\"\nlink_libtsan=\"-lrt $link_libtsan\"\n# Other sanitizers do not override clock_* API\n])\n\ncase \"$host\" in\n  *-*-darwin*) MAC_INTERPOSE=true ; enable_static=no ;;\n  *) MAC_INTERPOSE=false ;;\nesac\nAM_CONDITIONAL(USING_MAC_INTERPOSE, $MAC_INTERPOSE)\n\nbacktrace_supported=yes\n\nAC_MSG_CHECKING([for necessary platform features])\ncase \"$target\" in\n  *-*-linux*)\n    # Some old Linux distributions miss required syscalls.\n    sanitizer_supported=no\n    AC_TRY_COMPILE([#include <sys/syscall.h>],[\n      syscall (__NR_gettid);\n      syscall (__NR_futex);\n      syscall (__NR_exit_group);\n    ], [sanitizer_supported=yes])\n    ;;\n  *)\n    sanitizer_supported=yes\n    ;;\nesac\nAC_MSG_RESULT($sanitizer_supported)\nAM_CONDITIONAL(SANITIZER_SUPPORTED, test \"$sanitizer_supported\" = yes)\n\n# Test for __sync support.\nAC_CACHE_CHECK([__sync extensions],\n[libsanitizer_cv_sys_sync],\n[if test -n \"${with_target_subdir}\"; then\n   libsanitizer_cv_sys_sync=yes\n else\n   AC_LINK_IFELSE(\n     [AC_LANG_PROGRAM([int i;],\n                      [__sync_bool_compare_and_swap (&i, i, i);\n                       __sync_lock_test_and_set (&i, 1);\n                       __sync_lock_release (&i);])],\n     [libsanitizer_cv_sys_sync=yes],\n     [libsanitizer_cv_sys_sync=no])\n fi])\nif test \"$libsanitizer_cv_sys_sync\" = \"yes\"; then\n  AC_DEFINE([HAVE_SYNC_FUNCTIONS], 1,\n\t    [Define to 1 if you have the __sync functions])\nfi\n\n# Test for __atomic support.\nAC_CACHE_CHECK([__atomic extensions],\n[libsanitizer_cv_sys_atomic],\n[if test -n \"${with_target_subdir}\"; then\n   libsanitizer_cv_sys_atomic=yes\n else\n   AC_LINK_IFELSE(\n     [AC_LANG_PROGRAM([int i;],\n     \t\t      [__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);])],\n     [libsanitizer_cv_sys_atomic=yes],\n     [libsanitizer_cv_sys_atomic=no])\n fi])\nif test \"$libsanitizer_cv_sys_atomic\" = \"yes\"; then\n  AC_DEFINE([HAVE_ATOMIC_FUNCTIONS], 1,\n\t    [Define to 1 if you have the __atomic functions])\nfi\n\n# The library needs to be able to read the executable itself.  Compile\n# a file to determine the executable format.  The awk script\n# filetype.awk prints out the file type.\nAC_CACHE_CHECK([output filetype],\n[libsanitizer_cv_sys_filetype],\n[filetype=\nAC_COMPILE_IFELSE(\n  [AC_LANG_PROGRAM([int i;], [int j;])],\n  [filetype=`${AWK} -f $srcdir/../libbacktrace/filetype.awk conftest.$ac_objext`],\n  [AC_MSG_FAILURE([compiler failed])])\nlibsanitizer_cv_sys_filetype=$filetype])\n\n# Match the file type to decide what files to compile.\nFORMAT_FILE=\ncase \"$libsanitizer_cv_sys_filetype\" in\nelf*) FORMAT_FILE=\"elf.lo\" ;;\n*) AC_MSG_WARN([could not determine output file type])\n   FORMAT_FILE=\"unknown.lo\"\n   backtrace_supported=no\n   ;;\nesac\nAC_SUBST(FORMAT_FILE)\n\n# ELF defines.\nelfsize=\ncase \"$libsanitizer_cv_sys_filetype\" in\nelf32) elfsize=32 ;;\nelf64) elfsize=64 ;;\nesac\nAC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n\nBACKTRACE_SUPPORTED=0\nif test \"$backtrace_supported\" = \"yes\"; then\n  BACKTRACE_SUPPORTED=1\nfi\nAC_SUBST(BACKTRACE_SUPPORTED)\n\nGCC_HEADER_STDINT(gstdint.h)\n\nAC_CHECK_HEADERS(sys/mman.h alloca.h)\nif test \"$ac_cv_header_sys_mman_h\" = \"no\"; then\n  have_mmap=no\nelse\n  if test -n \"${with_target_subdir}\"; then\n    # When built as a GCC target library, we can't do a link test.  We\n    # simply assume that if we have mman.h, we have mmap.\n    have_mmap=yes\n  else\n    AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n  fi\nfi\nif test \"$have_mmap\" = \"no\"; then\n  VIEW_FILE=read.lo\n  ALLOC_FILE=alloc.lo\nelse\n  VIEW_FILE=mmapio.lo\n  AC_PREPROC_IFELSE([\n#include <sys/mman.h>\n#if !defined(MAP_ANONYMOUS) && !defined(MAP_ANON)\n  #error no MAP_ANONYMOUS\n#endif\n], [ALLOC_FILE=mmap.lo], [ALLOC_FILE=alloc.lo])\nfi\nAC_SUBST(VIEW_FILE)\nAC_SUBST(ALLOC_FILE)\n\nBACKTRACE_USES_MALLOC=0\nif test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n  BACKTRACE_USES_MALLOC=1\nfi\nAC_SUBST(BACKTRACE_USES_MALLOC)\n\n# Don't care about thread support\nBACKTRACE_SUPPORTS_THREADS=0\nAC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n\n# Check for dl_iterate_phdr.\nAC_CHECK_HEADERS(link.h)\nif test \"$ac_cv_header_link_h\" = \"no\"; then\n  have_dl_iterate_phdr=no\nelse\n  # When built as a GCC target library, we can't do a link test.\n  AC_EGREP_HEADER([dl_iterate_phdr], [link.h], [have_dl_iterate_phdr=yes],\n\t\t  [have_dl_iterate_phdr=no])\n  case \"${host}\" in\n  *-*-solaris2.10*)\n    # Avoid dl_iterate_phdr on Solaris 10, where it is in the\n    # header file but is only in -ldl.\n    have_dl_iterate_phdr=no ;;\n  esac\nfi\nif test \"$have_dl_iterate_phdr\" = \"yes\"; then\n  AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\nfi\n\n# Check for the fcntl function.\nif test -n \"${with_target_subdir}\"; then\n   case \"${host}\" in\n   *-*-mingw*) have_fcntl=no ;;\n   *) have_fcntl=yes ;;\n   esac\nelse\n  AC_CHECK_FUNC(fcntl, [have_fcntl=yes], [have_fcntl=no])\nfi\nif test \"$have_fcntl\" = \"yes\"; then\n  AC_DEFINE([HAVE_FCNTL], 1,\n\t    [Define to 1 if you have the fcntl function])\nfi\n\nAC_CHECK_DECLS(strnlen)\n\n# Check for getexecname function.\nif test -n \"${with_target_subdir}\"; then\n   case \"${host}\" in\n   *-*-solaris2*) have_getexecname=yes ;;\n   *) have_getexecname=no ;;\n   esac\nelse\n  AC_CHECK_FUNC(getexecname, [have_getexecname=yes], [have_getexecname=no])\nfi\nif test \"$have_getexecname\" = \"yes\"; then\n  AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\nfi\n\n# Check for rpc/xdr.h\nAC_CHECK_HEADERS(rpc/xdr.h)\nif test x\"$ac_cv_header_rpc_xdr_h\" = xyes; then\n  rpc_defs=\"$rpc_defs -DHAVE_RPC_XDR_H=1\"\nelse\n  rpc_defs=\"$rpc_defs -DHAVE_RPC_XDR_H=0\"\nfi\n\n# Check for tirpc/rpc/xdr.h\nAC_CHECK_HEADERS(tirpc/rpc/xdr.h)\nif test x\"$ac_cv_header_tirpc_rpc_xdr_h\" = xyes; then\n  rpc_defs=\"$rpc_defs -DHAVE_TIRPC_RPC_XDR_H=1\"\nelse\n  rpc_defs=\"$rpc_defs -DHAVE_TIRPC_RPC_XDR_H=0\"\nfi\n\nAC_SUBST([RPC_DEFS], [$rpc_defs])\n\nAM_CONDITIONAL(LIBBACKTRACE_SUPPORTED,\n\t       [test \"x${BACKTRACE_SUPPORTED}x${BACKTRACE_USES_MALLOC}\" = \"x1x0\"])\n\nAH_BOTTOM([#include \"libbacktrace/backtrace-rename.h\"])\nAC_CONFIG_FILES([Makefile libsanitizer.spec libbacktrace/backtrace-supported.h])\nAC_CONFIG_HEADER(config.h)\n\nAC_CONFIG_FILES(AC_FOREACH([DIR], [interception sanitizer_common libbacktrace lsan asan ubsan], [DIR/Makefile ]),\n  [cat > vpsed$$ << \\_EOF\ns!`test -f '$<' || echo '$(srcdir)/'`!!\n_EOF\n   sed -f vpsed$$ $ac_file > tmp$$\n   mv tmp$$ $ac_file\n   rm vpsed$$\n   echo 'MULTISUBDIR =' >> $ac_file\n   ml_norecursion=yes\n   . ${multi_basedir}/config-ml.in\n   AS_UNSET([ml_norecursion])\n])\n\nif test \"x$TSAN_SUPPORTED\" = \"xyes\"; then\n  AC_CONFIG_FILES(AC_FOREACH([DIR], [tsan], [DIR/Makefile ]), \n    [cat > vpsed$$ << \\_EOF\ns!`test -f '$<' || echo '$(srcdir)/'`!!\n_EOF\n    sed -f vpsed$$ $ac_file > tmp$$\n    mv tmp$$ $ac_file\n    rm vpsed$$\n    echo 'MULTISUBDIR =' >> $ac_file\n    ml_norecursion=yes\n    . ${multi_basedir}/config-ml.in\n    AS_UNSET([ml_norecursion])\n])\nfi\n\nAC_SUBST([TSAN_TARGET_DEPENDENT_OBJECTS])\nAC_SUBST([SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS])\n\n# Determine what GCC version number to use in filesystem paths.\nGCC_BASE_VER\n\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/asan/asan_rtl.cc": "//===-- asan_rtl.cc -------------------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of AddressSanitizer, an address sanity checker.\n//\n// Main file of the ASan run-time library.\n//===----------------------------------------------------------------------===//\n\n#include \"asan_activation.h\"\n#include \"asan_allocator.h\"\n#include \"asan_interceptors.h\"\n#include \"asan_interface_internal.h\"\n#include \"asan_internal.h\"\n#include \"asan_mapping.h\"\n#include \"asan_poisoning.h\"\n#include \"asan_report.h\"\n#include \"asan_stack.h\"\n#include \"asan_stats.h\"\n#include \"asan_suppressions.h\"\n#include \"asan_thread.h\"\n#include \"sanitizer_common/sanitizer_atomic.h\"\n#include \"sanitizer_common/sanitizer_flags.h\"\n#include \"sanitizer_common/sanitizer_libc.h\"\n#include \"sanitizer_common/sanitizer_symbolizer.h\"\n#include \"lsan/lsan_common.h\"\n#include \"ubsan/ubsan_init.h\"\n#include \"ubsan/ubsan_platform.h\"\n\nuptr __asan_shadow_memory_dynamic_address;  // Global interface symbol.\nint __asan_option_detect_stack_use_after_return;  // Global interface symbol.\nuptr *__asan_test_only_reported_buggy_pointer;  // Used only for testing asan.\n\nnamespace __asan {\n\nuptr AsanMappingProfile[kAsanMappingProfileSize];\n\nstatic void AsanDie() {\n  static atomic_uint32_t num_calls;\n  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n    // Don't die twice - run a busy loop.\n    while (1) { }\n  }\n  if (flags()->sleep_before_dying) {\n    Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_before_dying);\n    SleepForSeconds(flags()->sleep_before_dying);\n  }\n  if (flags()->unmap_shadow_on_exit) {\n    if (kMidMemBeg) {\n      UnmapOrDie((void*)kLowShadowBeg, kMidMemBeg - kLowShadowBeg);\n      UnmapOrDie((void*)kMidMemEnd, kHighShadowEnd - kMidMemEnd);\n    } else {\n      UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n    }\n  }\n}\n\nstatic void AsanCheckFailed(const char *file, int line, const char *cond,\n                            u64 v1, u64 v2) {\n  Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n         line, cond, (uptr)v1, (uptr)v2);\n  // FIXME: check for infinite recursion without a thread-local counter here.\n  PRINT_CURRENT_STACK_CHECK();\n  Die();\n}\n\n// -------------------------- Globals --------------------- {{{1\nint asan_inited;\nbool asan_init_is_running;\n\n#if !ASAN_FIXED_MAPPING\nuptr kHighMemEnd, kMidMemBeg, kMidMemEnd;\n#endif\n\n// -------------------------- Misc ---------------- {{{1\nvoid ShowStatsAndAbort() {\n  __asan_print_accumulated_stats();\n  Die();\n}\n\n// ---------------------- mmap -------------------- {{{1\n// Reserve memory range [beg, end].\n// We need to use inclusive range because end+1 may not be representable.\nvoid ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n  CHECK_EQ((beg % GetMmapGranularity()), 0);\n  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n  uptr size = end - beg + 1;\n  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n  void *res = MmapFixedNoReserve(beg, size, name);\n  if (res != (void*)beg) {\n    Report(\"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n           \"Perhaps you're using ulimit -v\\n\", size);\n    Abort();\n  }\n  if (common_flags()->no_huge_pages_for_shadow)\n    NoHugePagesInRegion(beg, size);\n  if (common_flags()->use_madv_dontdump)\n    DontDumpShadowMemory(beg, size);\n}\n\n// --------------- LowLevelAllocateCallbac ---------- {{{1\nstatic void OnLowLevelAllocate(uptr ptr, uptr size) {\n  PoisonShadow(ptr, size, kAsanInternalHeapMagic);\n}\n\n// -------------------------- Run-time entry ------------------- {{{1\n// exported functions\n#define ASAN_REPORT_ERROR(type, is_write, size)                     \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\nvoid __asan_report_ ## type ## size(uptr addr) {                    \\\n  GET_CALLER_PC_BP_SP;                                              \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, true);    \\\n}                                                                   \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\nvoid __asan_report_exp_ ## type ## size(uptr addr, u32 exp) {       \\\n  GET_CALLER_PC_BP_SP;                                              \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, exp, true);  \\\n}                                                                   \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                             \\\nvoid __asan_report_ ## type ## size ## _noabort(uptr addr) {        \\\n  GET_CALLER_PC_BP_SP;                                              \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, false);   \\\n}                                                                   \\\n\nASAN_REPORT_ERROR(load, false, 1)\nASAN_REPORT_ERROR(load, false, 2)\nASAN_REPORT_ERROR(load, false, 4)\nASAN_REPORT_ERROR(load, false, 8)\nASAN_REPORT_ERROR(load, false, 16)\nASAN_REPORT_ERROR(store, true, 1)\nASAN_REPORT_ERROR(store, true, 2)\nASAN_REPORT_ERROR(store, true, 4)\nASAN_REPORT_ERROR(store, true, 8)\nASAN_REPORT_ERROR(store, true, 16)\n\n#define ASAN_REPORT_ERROR_N(type, is_write)                                 \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\nvoid __asan_report_ ## type ## _n(uptr addr, uptr size) {                   \\\n  GET_CALLER_PC_BP_SP;                                                      \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, true);            \\\n}                                                                           \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\nvoid __asan_report_exp_ ## type ## _n(uptr addr, uptr size, u32 exp) {      \\\n  GET_CALLER_PC_BP_SP;                                                      \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, exp, true);          \\\n}                                                                           \\\nextern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                     \\\nvoid __asan_report_ ## type ## _n_noabort(uptr addr, uptr size) {           \\\n  GET_CALLER_PC_BP_SP;                                                      \\\n  ReportGenericError(pc, bp, sp, addr, is_write, size, 0, false);           \\\n}                                                                           \\\n\nASAN_REPORT_ERROR_N(load, false)\nASAN_REPORT_ERROR_N(store, true)\n\n#define ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp_arg, fatal) \\\n    uptr sp = MEM_TO_SHADOW(addr);                                             \\\n    uptr s = size <= SHADOW_GRANULARITY ? *reinterpret_cast<u8 *>(sp)          \\\n                                        : *reinterpret_cast<u16 *>(sp);        \\\n    if (UNLIKELY(s)) {                                                         \\\n      if (UNLIKELY(size >= SHADOW_GRANULARITY ||                               \\\n                   ((s8)((addr & (SHADOW_GRANULARITY - 1)) + size - 1)) >=     \\\n                       (s8)s)) {                                               \\\n        if (__asan_test_only_reported_buggy_pointer) {                         \\\n          *__asan_test_only_reported_buggy_pointer = addr;                     \\\n        } else {                                                               \\\n          GET_CALLER_PC_BP_SP;                                                 \\\n          ReportGenericError(pc, bp, sp, addr, is_write, size, exp_arg,        \\\n                              fatal);                                          \\\n        }                                                                      \\\n      }                                                                        \\\n    }\n\n#define ASAN_MEMORY_ACCESS_CALLBACK(type, is_write, size)                      \\\n  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n  void __asan_##type##size(uptr addr) {                                        \\\n    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0, true)            \\\n  }                                                                            \\\n  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n  void __asan_exp_##type##size(uptr addr, u32 exp) {                           \\\n    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, exp, true)          \\\n  }                                                                            \\\n  extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                                      \\\n  void __asan_##type##size ## _noabort(uptr addr) {                            \\\n    ASAN_MEMORY_ACCESS_CALLBACK_BODY(type, is_write, size, 0, false)           \\\n  }                                                                            \\\n\nASAN_MEMORY_ACCESS_CALLBACK(load, false, 1)\nASAN_MEMORY_ACCESS_CALLBACK(load, false, 2)\nASAN_MEMORY_ACCESS_CALLBACK(load, false, 4)\nASAN_MEMORY_ACCESS_CALLBACK(load, false, 8)\nASAN_MEMORY_ACCESS_CALLBACK(load, false, 16)\nASAN_MEMORY_ACCESS_CALLBACK(store, true, 1)\nASAN_MEMORY_ACCESS_CALLBACK(store, true, 2)\nASAN_MEMORY_ACCESS_CALLBACK(store, true, 4)\nASAN_MEMORY_ACCESS_CALLBACK(store, true, 8)\nASAN_MEMORY_ACCESS_CALLBACK(store, true, 16)\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_loadN(uptr addr, uptr size) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, false, size, 0, true);\n  }\n}\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_exp_loadN(uptr addr, uptr size, u32 exp) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, false, size, exp, true);\n  }\n}\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_loadN_noabort(uptr addr, uptr size) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, false, size, 0, false);\n  }\n}\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_storeN(uptr addr, uptr size) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, true, size, 0, true);\n  }\n}\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_exp_storeN(uptr addr, uptr size, u32 exp) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, true, size, exp, true);\n  }\n}\n\nextern \"C\"\nNOINLINE INTERFACE_ATTRIBUTE\nvoid __asan_storeN_noabort(uptr addr, uptr size) {\n  if (__asan_region_is_poisoned(addr, size)) {\n    GET_CALLER_PC_BP_SP;\n    ReportGenericError(pc, bp, sp, addr, true, size, 0, false);\n  }\n}\n\n// Force the linker to keep the symbols for various ASan interface functions.\n// We want to keep those in the executable in order to let the instrumented\n// dynamic libraries access the symbol even if it is not used by the executable\n// itself. This should help if the build system is removing dead code at link\n// time.\nstatic NOINLINE void force_interface_symbols() {\n  volatile int fake_condition = 0;  // prevent dead condition elimination.\n  // __asan_report_* functions are noreturn, so we need a switch to prevent\n  // the compiler from removing any of them.\n  // clang-format off\n  switch (fake_condition) {\n    case 1: __asan_report_load1(0); break;\n    case 2: __asan_report_load2(0); break;\n    case 3: __asan_report_load4(0); break;\n    case 4: __asan_report_load8(0); break;\n    case 5: __asan_report_load16(0); break;\n    case 6: __asan_report_load_n(0, 0); break;\n    case 7: __asan_report_store1(0); break;\n    case 8: __asan_report_store2(0); break;\n    case 9: __asan_report_store4(0); break;\n    case 10: __asan_report_store8(0); break;\n    case 11: __asan_report_store16(0); break;\n    case 12: __asan_report_store_n(0, 0); break;\n    case 13: __asan_report_exp_load1(0, 0); break;\n    case 14: __asan_report_exp_load2(0, 0); break;\n    case 15: __asan_report_exp_load4(0, 0); break;\n    case 16: __asan_report_exp_load8(0, 0); break;\n    case 17: __asan_report_exp_load16(0, 0); break;\n    case 18: __asan_report_exp_load_n(0, 0, 0); break;\n    case 19: __asan_report_exp_store1(0, 0); break;\n    case 20: __asan_report_exp_store2(0, 0); break;\n    case 21: __asan_report_exp_store4(0, 0); break;\n    case 22: __asan_report_exp_store8(0, 0); break;\n    case 23: __asan_report_exp_store16(0, 0); break;\n    case 24: __asan_report_exp_store_n(0, 0, 0); break;\n    case 25: __asan_register_globals(nullptr, 0); break;\n    case 26: __asan_unregister_globals(nullptr, 0); break;\n    case 27: __asan_set_death_callback(nullptr); break;\n    case 28: __asan_set_error_report_callback(nullptr); break;\n    case 29: __asan_handle_no_return(); break;\n    case 30: __asan_address_is_poisoned(nullptr); break;\n    case 31: __asan_poison_memory_region(nullptr, 0); break;\n    case 32: __asan_unpoison_memory_region(nullptr, 0); break;\n    case 34: __asan_before_dynamic_init(nullptr); break;\n    case 35: __asan_after_dynamic_init(); break;\n    case 36: __asan_poison_stack_memory(0, 0); break;\n    case 37: __asan_unpoison_stack_memory(0, 0); break;\n    case 38: __asan_region_is_poisoned(0, 0); break;\n    case 39: __asan_describe_address(0); break;\n    case 40: __asan_set_shadow_00(0, 0); break;\n    case 41: __asan_set_shadow_f1(0, 0); break;\n    case 42: __asan_set_shadow_f2(0, 0); break;\n    case 43: __asan_set_shadow_f3(0, 0); break;\n    case 44: __asan_set_shadow_f5(0, 0); break;\n    case 45: __asan_set_shadow_f8(0, 0); break;\n  }\n  // clang-format on\n}\n\nstatic void asan_atexit() {\n  Printf(\"AddressSanitizer exit stats:\\n\");\n  __asan_print_accumulated_stats();\n  // Print AsanMappingProfile.\n  for (uptr i = 0; i < kAsanMappingProfileSize; i++) {\n    if (AsanMappingProfile[i] == 0) continue;\n    Printf(\"asan_mapping.h:%zd -- %zd\\n\", i, AsanMappingProfile[i]);\n  }\n}\n\nstatic void InitializeHighMemEnd() {\n#if !ASAN_FIXED_MAPPING\n  kHighMemEnd = GetMaxVirtualAddress();\n  // Increase kHighMemEnd to make sure it's properly\n  // aligned together with kHighMemBeg:\n  kHighMemEnd |= SHADOW_GRANULARITY * GetMmapGranularity() - 1;\n#endif  // !ASAN_FIXED_MAPPING\n  CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n}\n\nstatic void ProtectGap(uptr addr, uptr size) {\n  if (!flags()->protect_shadow_gap) {\n    // The shadow gap is unprotected, so there is a chance that someone\n    // is actually using this memory. Which means it needs a shadow...\n    uptr GapShadowBeg = RoundDownTo(MEM_TO_SHADOW(addr), GetPageSizeCached());\n    uptr GapShadowEnd =\n        RoundUpTo(MEM_TO_SHADOW(addr + size), GetPageSizeCached()) - 1;\n    if (Verbosity())\n      Printf(\"protect_shadow_gap=0:\"\n             \" not protecting shadow gap, allocating gap's shadow\\n\"\n             \"|| `[%p, %p]` || ShadowGap's shadow ||\\n\", GapShadowBeg,\n             GapShadowEnd);\n    ReserveShadowMemoryRange(GapShadowBeg, GapShadowEnd,\n                             \"unprotected gap shadow\");\n    return;\n  }\n  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n  if (addr == (uptr)res)\n    return;\n  // A few pages at the start of the address space can not be protected.\n  // But we really want to protect as much as possible, to prevent this memory\n  // being returned as a result of a non-FIXED mmap().\n  if (addr == kZeroBaseShadowStart) {\n    uptr step = GetMmapGranularity();\n    while (size > step && addr < kZeroBaseMaxShadowStart) {\n      addr += step;\n      size -= step;\n      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n      if (addr == (uptr)res)\n        return;\n    }\n  }\n\n  Report(\"ERROR: Failed to protect the shadow gap. \"\n         \"ASan cannot proceed correctly. ABORTING.\\n\");\n  DumpProcessMap();\n  Die();\n}\n\nstatic void PrintAddressSpaceLayout() {\n  Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n         (void*)kHighMemBeg, (void*)kHighMemEnd);\n  Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n         (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n  if (kMidMemBeg) {\n    Printf(\"|| `[%p, %p]` || ShadowGap3 ||\\n\",\n           (void*)kShadowGap3Beg, (void*)kShadowGap3End);\n    Printf(\"|| `[%p, %p]` || MidMem     ||\\n\",\n           (void*)kMidMemBeg, (void*)kMidMemEnd);\n    Printf(\"|| `[%p, %p]` || ShadowGap2 ||\\n\",\n           (void*)kShadowGap2Beg, (void*)kShadowGap2End);\n    Printf(\"|| `[%p, %p]` || MidShadow  ||\\n\",\n           (void*)kMidShadowBeg, (void*)kMidShadowEnd);\n  }\n  Printf(\"|| `[%p, %p]` || ShadowGap  ||\\n\",\n         (void*)kShadowGapBeg, (void*)kShadowGapEnd);\n  if (kLowShadowBeg) {\n    Printf(\"|| `[%p, %p]` || LowShadow  ||\\n\",\n           (void*)kLowShadowBeg, (void*)kLowShadowEnd);\n    Printf(\"|| `[%p, %p]` || LowMem     ||\\n\",\n           (void*)kLowMemBeg, (void*)kLowMemEnd);\n  }\n  Printf(\"MemToShadow(shadow): %p %p %p %p\",\n         (void*)MEM_TO_SHADOW(kLowShadowBeg),\n         (void*)MEM_TO_SHADOW(kLowShadowEnd),\n         (void*)MEM_TO_SHADOW(kHighShadowBeg),\n         (void*)MEM_TO_SHADOW(kHighShadowEnd));\n  if (kMidMemBeg) {\n    Printf(\" %p %p\",\n           (void*)MEM_TO_SHADOW(kMidShadowBeg),\n           (void*)MEM_TO_SHADOW(kMidShadowEnd));\n  }\n  Printf(\"\\n\");\n  Printf(\"redzone=%zu\\n\", (uptr)flags()->redzone);\n  Printf(\"max_redzone=%zu\\n\", (uptr)flags()->max_redzone);\n  Printf(\"quarantine_size_mb=%zuM\\n\", (uptr)flags()->quarantine_size_mb);\n  Printf(\"malloc_context_size=%zu\\n\",\n         (uptr)common_flags()->malloc_context_size);\n\n  Printf(\"SHADOW_SCALE: %d\\n\", (int)SHADOW_SCALE);\n  Printf(\"SHADOW_GRANULARITY: %d\\n\", (int)SHADOW_GRANULARITY);\n  Printf(\"SHADOW_OFFSET: 0x%zx\\n\", (uptr)SHADOW_OFFSET);\n  CHECK(SHADOW_SCALE >= 3 && SHADOW_SCALE <= 7);\n  if (kMidMemBeg)\n    CHECK(kMidShadowBeg > kLowShadowEnd &&\n          kMidMemBeg > kMidShadowEnd &&\n          kHighShadowBeg > kMidMemEnd);\n}\n\nstatic void AsanInitInternal() {\n  if (LIKELY(asan_inited)) return;\n  SanitizerToolName = \"AddressSanitizer\";\n  CHECK(!asan_init_is_running && \"ASan init calls itself!\");\n  asan_init_is_running = true;\n\n  CacheBinaryName();\n\n  // Initialize flags. This must be done early, because most of the\n  // initialization steps look at flags().\n  InitializeFlags();\n\n  AsanCheckIncompatibleRT();\n  AsanCheckDynamicRTPrereqs();\n  AvoidCVE_2016_2143();\n\n  SetCanPoisonMemory(flags()->poison_heap);\n  SetMallocContextSize(common_flags()->malloc_context_size);\n\n  InitializePlatformExceptionHandlers();\n\n  InitializeHighMemEnd();\n\n  // Make sure we are not statically linked.\n  AsanDoesNotSupportStaticLinkage();\n\n  // Install tool-specific callbacks in sanitizer_common.\n  AddDieCallback(AsanDie);\n  SetCheckFailedCallback(AsanCheckFailed);\n  SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n\n  __sanitizer_set_report_path(common_flags()->log_path);\n\n  __asan_option_detect_stack_use_after_return =\n      flags()->detect_stack_use_after_return;\n\n  // Re-exec ourselves if we need to set additional env or command line args.\n  MaybeReexec();\n\n  // Setup internal allocator callback.\n  SetLowLevelAllocateCallback(OnLowLevelAllocate);\n\n  InitializeAsanInterceptors();\n\n  // Enable system log (\"adb logcat\") on Android.\n  // Doing this before interceptors are initialized crashes in:\n  // AsanInitInternal -> android_log_write -> __interceptor_strcmp\n  AndroidLogInit();\n\n  ReplaceSystemMalloc();\n\n  // Set the shadow memory address to uninitialized.\n  __asan_shadow_memory_dynamic_address = kDefaultShadowSentinel;\n\n  uptr shadow_start = kLowShadowBeg;\n  // Detect if a dynamic shadow address must used and find a available location\n  // when necessary. When dynamic address is used, the macro |kLowShadowBeg|\n  // expands to |__asan_shadow_memory_dynamic_address| which is\n  // |kDefaultShadowSentinel|.\n  if (shadow_start == kDefaultShadowSentinel) {\n    __asan_shadow_memory_dynamic_address = 0;\n    CHECK_EQ(0, kLowShadowBeg);\n\n    uptr granularity = GetMmapGranularity();\n    uptr alignment = 8 * granularity;\n    uptr left_padding = granularity;\n    uptr space_size = kHighShadowEnd + left_padding;\n\n    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity);\n    CHECK_NE((uptr)0, shadow_start);\n    CHECK(IsAligned(shadow_start, alignment));\n  }\n  // Update the shadow memory address (potentially) used by instrumentation.\n  __asan_shadow_memory_dynamic_address = shadow_start;\n\n  if (kLowShadowBeg)\n    shadow_start -= GetMmapGranularity();\n  bool full_shadow_is_available =\n      MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n\n#if SANITIZER_LINUX && defined(__x86_64__) && defined(_LP64) &&                \\\n    !ASAN_FIXED_MAPPING\n  if (!full_shadow_is_available) {\n    kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n    kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x4fffffffffULL : 0;\n  }\n#endif\n\n  if (Verbosity()) PrintAddressSpaceLayout();\n\n  DisableCoreDumperIfNecessary();\n\n  if (full_shadow_is_available) {\n    // mmap the low shadow plus at least one page at the left.\n    if (kLowShadowBeg)\n      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n    // mmap the high shadow.\n    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n    // protect the gap.\n    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n    CHECK_EQ(kShadowGapEnd, kHighShadowBeg - 1);\n  } else if (kMidMemBeg &&\n      MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n      MemoryRangeIsAvailable(kMidMemEnd + 1, kHighShadowEnd)) {\n    CHECK(kLowShadowBeg != kLowShadowEnd);\n    // mmap the low shadow plus at least one page at the left.\n    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd, \"low shadow\");\n    // mmap the mid shadow.\n    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd, \"mid shadow\");\n    // mmap the high shadow.\n    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd, \"high shadow\");\n    // protect the gaps.\n    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n    ProtectGap(kShadowGap2Beg, kShadowGap2End - kShadowGap2Beg + 1);\n    ProtectGap(kShadowGap3Beg, kShadowGap3End - kShadowGap3Beg + 1);\n  } else {\n    Report(\"Shadow memory range interleaves with an existing memory mapping. \"\n           \"ASan cannot proceed correctly. ABORTING.\\n\");\n    Report(\"ASan shadow was supposed to be located in the [%p-%p] range.\\n\",\n           shadow_start, kHighShadowEnd);\n    DumpProcessMap();\n    Die();\n  }\n\n  AsanTSDInit(PlatformTSDDtor);\n  InstallDeadlySignalHandlers(AsanOnDeadlySignal);\n\n  AllocatorOptions allocator_options;\n  allocator_options.SetFrom(flags(), common_flags());\n  InitializeAllocator(allocator_options);\n\n  MaybeStartBackgroudThread();\n  SetSoftRssLimitExceededCallback(AsanSoftRssLimitExceededCallback);\n\n  // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n  // should be set to 1 prior to initializing the threads.\n  asan_inited = 1;\n  asan_init_is_running = false;\n\n  if (flags()->atexit)\n    Atexit(asan_atexit);\n\n  InitializeCoverage(common_flags()->coverage, common_flags()->coverage_dir);\n\n  // Now that ASan runtime is (mostly) initialized, deactivate it if\n  // necessary, so that it can be re-activated when requested.\n  if (flags()->start_deactivated)\n    AsanDeactivate();\n\n  // interceptors\n  InitTlsSize();\n\n  // Create main thread.\n  AsanThread *main_thread = AsanThread::Create(\n      /* start_routine */ nullptr, /* arg */ nullptr, /* parent_tid */ 0,\n      /* stack */ nullptr, /* detached */ true);\n  CHECK_EQ(0, main_thread->tid());\n  SetCurrentThread(main_thread);\n  main_thread->ThreadStart(internal_getpid(),\n                           /* signal_thread_is_registered */ nullptr);\n  force_interface_symbols();  // no-op.\n  SanitizerInitializeUnwinder();\n\n  if (CAN_SANITIZE_LEAKS) {\n    __lsan::InitCommonLsan();\n    if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n      Atexit(__lsan::DoLeakCheck);\n    }\n  }\n\n#if CAN_SANITIZE_UB\n  __ubsan::InitAsPlugin();\n#endif\n\n  InitializeSuppressions();\n\n  if (CAN_SANITIZE_LEAKS) {\n    // LateInitialize() calls dlsym, which can allocate an error string buffer\n    // in the TLS.  Let's ignore the allocation to avoid reporting a leak.\n    __lsan::ScopedInterceptorDisabler disabler;\n    Symbolizer::LateInitialize();\n  } else {\n    Symbolizer::LateInitialize();\n  }\n\n  VReport(1, \"AddressSanitizer Init done\\n\");\n}\n\n// Initialize as requested from some part of ASan runtime library (interceptors,\n// allocator, etc).\nvoid AsanInitFromRtl() {\n  AsanInitInternal();\n}\n\n#if ASAN_DYNAMIC\n// Initialize runtime in case it's LD_PRELOAD-ed into unsanitized executable\n// (and thus normal initializers from .preinit_array or modules haven't run).\n\nclass AsanInitializer {\npublic:  // NOLINT\n  AsanInitializer() {\n    AsanInitFromRtl();\n  }\n};\n\nstatic AsanInitializer asan_initializer;\n#endif  // ASAN_DYNAMIC\n\n} // namespace __asan\n\n// ---------------------- Interface ---------------- {{{1\nusing namespace __asan;  // NOLINT\n\nvoid NOINLINE __asan_handle_no_return() {\n  if (asan_init_is_running)\n    return;\n\n  int local_stack;\n  AsanThread *curr_thread = GetCurrentThread();\n  uptr PageSize = GetPageSizeCached();\n  uptr top, bottom;\n  if (curr_thread) {\n    top = curr_thread->stack_top();\n    bottom = ((uptr)&local_stack - PageSize) & ~(PageSize - 1);\n  } else {\n    // If we haven't seen this thread, try asking the OS for stack bounds.\n    uptr tls_addr, tls_size, stack_size;\n    GetThreadStackAndTls(/*main=*/false, &bottom, &stack_size, &tls_addr,\n                         &tls_size);\n    top = bottom + stack_size;\n  }\n  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n  if (top - bottom > kMaxExpectedCleanupSize) {\n    static bool reported_warning = false;\n    if (reported_warning)\n      return;\n    reported_warning = true;\n    Report(\"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n           \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n           \"False positive error reports may follow\\n\"\n           \"For details see \"\n           \"https://github.com/google/sanitizers/issues/189\\n\",\n           top, bottom, top - bottom, top - bottom);\n    return;\n  }\n  PoisonShadow(bottom, top - bottom, 0);\n  if (curr_thread && curr_thread->has_fake_stack())\n    curr_thread->fake_stack()->HandleNoReturn();\n}\n\nvoid NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n  SetUserDieCallback(callback);\n}\n\n// Initialize as requested from instrumented application code.\n// We use this call as a trigger to wake up ASan from deactivated state.\nvoid __asan_init() {\n  AsanActivate();\n  AsanInitInternal();\n}\n\nvoid __asan_version_mismatch_check() {\n  // Do nothing.\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/asan/asan_linux.cc": "//===-- asan_linux.cc -----------------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of AddressSanitizer, an address sanity checker.\n//\n// Linux-specific details.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_common/sanitizer_platform.h\"\n#if SANITIZER_FREEBSD || SANITIZER_LINUX\n\n#include \"asan_interceptors.h\"\n#include \"asan_internal.h\"\n#include \"asan_thread.h\"\n#include \"sanitizer_common/sanitizer_flags.h\"\n#include \"sanitizer_common/sanitizer_freebsd.h\"\n#include \"sanitizer_common/sanitizer_libc.h\"\n#include \"sanitizer_common/sanitizer_procmaps.h\"\n\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <unwind.h>\n\n#if SANITIZER_FREEBSD\n#include <sys/link_elf.h>\n#endif\n\n#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n#include <ucontext.h>\nextern \"C\" void* _DYNAMIC;\n#else\n#include <sys/ucontext.h>\n#include <link.h>\n#endif\n\n// x86-64 FreeBSD 9.2 and older define 'ucontext_t' incorrectly in\n// 32-bit mode.\n#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32) && \\\n  __FreeBSD_version <= 902001  // v9.2\n#define ucontext_t xucontext_t\n#endif\n\ntypedef enum {\n  ASAN_RT_VERSION_UNDEFINED = 0,\n  ASAN_RT_VERSION_DYNAMIC,\n  ASAN_RT_VERSION_STATIC,\n} asan_rt_version_t;\n\n// FIXME: perhaps also store abi version here?\nextern \"C\" {\nSANITIZER_INTERFACE_ATTRIBUTE\nasan_rt_version_t  __asan_rt_version;\n}\n\nnamespace __asan {\n\nvoid InitializePlatformInterceptors() {}\nvoid InitializePlatformExceptionHandlers() {}\n\nvoid *AsanDoesNotSupportStaticLinkage() {\n  // This will fail to link with -static.\n  return &_DYNAMIC;  // defined in link.h\n}\n\nvoid AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n  UNIMPLEMENTED();\n}\n\n#if SANITIZER_ANDROID\n// FIXME: should we do anything for Android?\nvoid AsanCheckDynamicRTPrereqs() {}\nvoid AsanCheckIncompatibleRT() {}\n#else\nstatic int FindFirstDSOCallback(struct dl_phdr_info *info, size_t size,\n                                void *data) {\n  // Continue until the first dynamic library is found\n  if (!info->dlpi_name || info->dlpi_name[0] == 0)\n    return 0;\n\n  // Ignore vDSO\n  if (internal_strncmp(info->dlpi_name, \"linux-\", sizeof(\"linux-\") - 1) == 0)\n    return 0;\n\n  *(const char **)data = info->dlpi_name;\n  return 1;\n}\n\nstatic bool IsDynamicRTName(const char *libname) {\n  return internal_strstr(libname, \"libclang_rt.asan\") ||\n    internal_strstr(libname, \"libasan.so\");\n}\n\nstatic void ReportIncompatibleRT() {\n  Report(\"Your application is linked against incompatible ASan runtimes.\\n\");\n  Die();\n}\n\nvoid AsanCheckDynamicRTPrereqs() {\n  if (!ASAN_DYNAMIC)\n    return;\n\n  // Ensure that dynamic RT is the first DSO in the list\n  const char *first_dso_name = nullptr;\n  dl_iterate_phdr(FindFirstDSOCallback, &first_dso_name);\n  if (first_dso_name && !IsDynamicRTName(first_dso_name)) {\n    Report(\"ASan runtime does not come first in initial library list; \"\n           \"you should either link runtime to your application or \"\n           \"manually preload it with LD_PRELOAD.\\n\");\n    Die();\n  }\n}\n\nvoid AsanCheckIncompatibleRT() {\n  if (ASAN_DYNAMIC) {\n    if (__asan_rt_version == ASAN_RT_VERSION_UNDEFINED) {\n      __asan_rt_version = ASAN_RT_VERSION_DYNAMIC;\n    } else if (__asan_rt_version != ASAN_RT_VERSION_DYNAMIC) {\n      ReportIncompatibleRT();\n    }\n  } else {\n    if (__asan_rt_version == ASAN_RT_VERSION_UNDEFINED) {\n      // Ensure that dynamic runtime is not present. We should detect it\n      // as early as possible, otherwise ASan interceptors could bind to\n      // the functions in dynamic ASan runtime instead of the functions in\n      // system libraries, causing crashes later in ASan initialization.\n      MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n      char filename[128];\n      while (proc_maps.Next(nullptr, nullptr, nullptr, filename,\n                            sizeof(filename), nullptr)) {\n        if (IsDynamicRTName(filename)) {\n          Report(\"Your application is linked against \"\n                 \"incompatible ASan runtimes.\\n\");\n          Die();\n        }\n      }\n      __asan_rt_version = ASAN_RT_VERSION_STATIC;\n    } else if (__asan_rt_version != ASAN_RT_VERSION_STATIC) {\n      ReportIncompatibleRT();\n    }\n  }\n}\n#endif // SANITIZER_ANDROID\n\n#if !SANITIZER_ANDROID\nvoid ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n  ucontext_t *ucp = (ucontext_t*)context;\n  *stack = (uptr)ucp->uc_stack.ss_sp;\n  *ssize = ucp->uc_stack.ss_size;\n}\n#else\nvoid ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n  UNIMPLEMENTED();\n}\n#endif\n\nvoid *AsanDlSymNext(const char *sym) {\n  return dlsym(RTLD_NEXT, sym);\n}\n\n} // namespace __asan\n\n#endif // SANITIZER_FREEBSD || SANITIZER_LINUX\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/asan/asan_malloc_linux.cc": "//===-- asan_malloc_linux.cc ----------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of AddressSanitizer, an address sanity checker.\n//\n// Linux-specific malloc interception.\n// We simply define functions like malloc, free, realloc, etc.\n// They will replace the corresponding libc functions automagically.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_common/sanitizer_platform.h\"\n#if SANITIZER_FREEBSD || SANITIZER_LINUX\n\n#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n#include \"asan_allocator.h\"\n#include \"asan_interceptors.h\"\n#include \"asan_internal.h\"\n#include \"asan_stack.h\"\n\n// ---------------------- Replacement functions ---------------- {{{1\nusing namespace __asan;  // NOLINT\n\nstatic uptr allocated_for_dlsym;\nstatic const uptr kDlsymAllocPoolSize = 1024;\nstatic uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n\nstatic bool IsInDlsymAllocPool(const void *ptr) {\n  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n  return off < sizeof(alloc_memory_for_dlsym);\n}\n\nstatic void *AllocateFromLocalPool(uptr size_in_bytes) {\n  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n  void *mem = (void*)&alloc_memory_for_dlsym[allocated_for_dlsym];\n  allocated_for_dlsym += size_in_words;\n  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n  return mem;\n}\n\nINTERCEPTOR(void, free, void *ptr) {\n  GET_STACK_TRACE_FREE;\n  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n    return;\n  asan_free(ptr, &stack, FROM_MALLOC);\n}\n\nINTERCEPTOR(void, cfree, void *ptr) {\n  GET_STACK_TRACE_FREE;\n  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n    return;\n  asan_free(ptr, &stack, FROM_MALLOC);\n}\n\nINTERCEPTOR(void*, malloc, uptr size) {\n  if (UNLIKELY(!asan_inited))\n    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n    return AllocateFromLocalPool(size);\n  GET_STACK_TRACE_MALLOC;\n  return asan_malloc(size, &stack);\n}\n\nINTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n  if (UNLIKELY(!asan_inited))\n    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n    return AllocateFromLocalPool(nmemb * size);\n  GET_STACK_TRACE_MALLOC;\n  return asan_calloc(nmemb, size, &stack);\n}\n\nINTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n    void *new_ptr;\n    if (UNLIKELY(!asan_inited)) {\n      new_ptr = AllocateFromLocalPool(size);\n    } else {\n      copy_size = size;\n      new_ptr = asan_malloc(copy_size, &stack);\n    }\n    internal_memcpy(new_ptr, ptr, copy_size);\n    return new_ptr;\n  }\n  return asan_realloc(ptr, size, &stack);\n}\n\nINTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n}\n\nINTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n}\n\nINTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  void *res = asan_memalign(boundary, size, &stack, FROM_MALLOC);\n  DTLS_on_libc_memalign(res, size);\n  return res;\n}\n\nINTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n  GET_CURRENT_PC_BP_SP;\n  (void)sp;\n  return asan_malloc_usable_size(ptr, pc, bp);\n}\n\n// We avoid including malloc.h for portability reasons.\n// man mallinfo says the fields are \"long\", but the implementation uses int.\n// It doesn't matter much -- we just need to make sure that the libc's mallinfo\n// is not called.\nstruct fake_mallinfo {\n  int x[10];\n};\n\nINTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n  struct fake_mallinfo res;\n  REAL(memset)(&res, 0, sizeof(res));\n  return res;\n}\n\nINTERCEPTOR(int, mallopt, int cmd, int value) {\n  return -1;\n}\n\nINTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  // Printf(\"posix_memalign: %zx %zu\\n\", alignment, size);\n  return asan_posix_memalign(memptr, alignment, size, &stack);\n}\n\nINTERCEPTOR(void*, valloc, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  return asan_valloc(size, &stack);\n}\n\nINTERCEPTOR(void*, pvalloc, uptr size) {\n  GET_STACK_TRACE_MALLOC;\n  return asan_pvalloc(size, &stack);\n}\n\nINTERCEPTOR(void, malloc_stats, void) {\n  __asan_print_accumulated_stats();\n}\n\n#if SANITIZER_ANDROID\n// Format of __libc_malloc_dispatch has changed in Android L.\n// While we are moving towards a solution that does not depend on bionic\n// internals, here is something to support both K* and L releases.\nstruct MallocDebugK {\n  void *(*malloc)(uptr bytes);\n  void (*free)(void *mem);\n  void *(*calloc)(uptr n_elements, uptr elem_size);\n  void *(*realloc)(void *oldMem, uptr bytes);\n  void *(*memalign)(uptr alignment, uptr bytes);\n  uptr (*malloc_usable_size)(void *mem);\n};\n\nstruct MallocDebugL {\n  void *(*calloc)(uptr n_elements, uptr elem_size);\n  void (*free)(void *mem);\n  fake_mallinfo (*mallinfo)(void);\n  void *(*malloc)(uptr bytes);\n  uptr (*malloc_usable_size)(void *mem);\n  void *(*memalign)(uptr alignment, uptr bytes);\n  int (*posix_memalign)(void **memptr, uptr alignment, uptr size);\n  void* (*pvalloc)(uptr size);\n  void *(*realloc)(void *oldMem, uptr bytes);\n  void* (*valloc)(uptr size);\n};\n\nALIGNED(32) const MallocDebugK asan_malloc_dispatch_k = {\n    WRAP(malloc),  WRAP(free),     WRAP(calloc),\n    WRAP(realloc), WRAP(memalign), WRAP(malloc_usable_size)};\n\nALIGNED(32) const MallocDebugL asan_malloc_dispatch_l = {\n    WRAP(calloc),         WRAP(free),               WRAP(mallinfo),\n    WRAP(malloc),         WRAP(malloc_usable_size), WRAP(memalign),\n    WRAP(posix_memalign), WRAP(pvalloc),            WRAP(realloc),\n    WRAP(valloc)};\n\nnamespace __asan {\nvoid ReplaceSystemMalloc() {\n  void **__libc_malloc_dispatch_p =\n      (void **)AsanDlSymNext(\"__libc_malloc_dispatch\");\n  if (__libc_malloc_dispatch_p) {\n    // Decide on K vs L dispatch format by the presence of\n    // __libc_malloc_default_dispatch export in libc.\n    void *default_dispatch_p = AsanDlSymNext(\"__libc_malloc_default_dispatch\");\n    if (default_dispatch_p)\n      *__libc_malloc_dispatch_p = (void *)&asan_malloc_dispatch_k;\n    else\n      *__libc_malloc_dispatch_p = (void *)&asan_malloc_dispatch_l;\n  }\n}\n}  // namespace __asan\n\n#else  // SANITIZER_ANDROID\n\nnamespace __asan {\nvoid ReplaceSystemMalloc() {\n}\n}  // namespace __asan\n#endif  // SANITIZER_ANDROID\n\n#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/interception/interception.h": "//===-- interception.h ------------------------------------------*- C++ -*-===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of AddressSanitizer, an address sanity checker.\n//\n// Machinery for providing replacements/wrappers for system functions.\n//===----------------------------------------------------------------------===//\n\n#ifndef INTERCEPTION_H\n#define INTERCEPTION_H\n\n#if !defined(__linux__) && !defined(__FreeBSD__) && \\\n  !defined(__APPLE__) && !defined(_WIN32)\n# error \"Interception doesn't work on this operating system.\"\n#endif\n\n#include \"sanitizer_common/sanitizer_internal_defs.h\"\n\n// These typedefs should be used only in the interceptor definitions to replace\n// the standard system types (e.g. SSIZE_T instead of ssize_t)\ntypedef __sanitizer::uptr    SIZE_T;\ntypedef __sanitizer::sptr    SSIZE_T;\ntypedef __sanitizer::sptr    PTRDIFF_T;\ntypedef __sanitizer::s64     INTMAX_T;\ntypedef __sanitizer::OFF_T   OFF_T;\ntypedef __sanitizer::OFF64_T OFF64_T;\n\n// How to add an interceptor:\n// Suppose you need to wrap/replace system function (generally, from libc):\n//      int foo(const char *bar, double baz);\n// You'll need to:\n//      1) define INTERCEPTOR(int, foo, const char *bar, double baz) { ... } in\n//         your source file. See the notes below for cases when\n//         INTERCEPTOR_WITH_SUFFIX(...) should be used instead.\n//      2) Call \"INTERCEPT_FUNCTION(foo)\" prior to the first call of \"foo\".\n//         INTERCEPT_FUNCTION(foo) evaluates to \"true\" iff the function was\n//         intercepted successfully.\n// You can access original function by calling REAL(foo)(bar, baz).\n// By default, REAL(foo) will be visible only inside your interceptor, and if\n// you want to use it in other parts of RTL, you'll need to:\n//      3a) add DECLARE_REAL(int, foo, const char*, double) to a\n//          header file.\n// However, if the call \"INTERCEPT_FUNCTION(foo)\" and definition for\n// INTERCEPTOR(..., foo, ...) are in different files, you'll instead need to:\n//      3b) add DECLARE_REAL_AND_INTERCEPTOR(int, foo, const char*, double)\n//          to a header file.\n\n// Notes: 1. Things may not work properly if macro INTERCEPTOR(...) {...} or\n//           DECLARE_REAL(...) are located inside namespaces.\n//        2. On Mac you can also use: \"OVERRIDE_FUNCTION(foo, zoo)\" to\n//           effectively redirect calls from \"foo\" to \"zoo\". In this case\n//           you aren't required to implement\n//           INTERCEPTOR(int, foo, const char *bar, double baz) {...}\n//           but instead you'll have to add\n//           DECLARE_REAL(int, foo, const char *bar, double baz) in your\n//           source file (to define a pointer to overriden function).\n//        3. Some Mac functions have symbol variants discriminated by\n//           additional suffixes, e.g. _$UNIX2003 (see\n//           https://developer.apple.com/library/mac/#releasenotes/Darwin/SymbolVariantsRelNotes/index.html\n//           for more details). To intercept such functions you need to use the\n//           INTERCEPTOR_WITH_SUFFIX(...) macro.\n\n// How it works:\n// To replace system functions on Linux we just need to declare functions\n// with same names in our library and then obtain the real function pointers\n// using dlsym().\n// There is one complication. A user may also intercept some of the functions\n// we intercept. To resolve this we declare our interceptors with __interceptor_\n// prefix, and then make actual interceptors weak aliases to __interceptor_\n// functions.\n//\n// This is not so on Mac OS, where the two-level namespace makes\n// our replacement functions invisible to other libraries. This may be overcomed\n// using the DYLD_FORCE_FLAT_NAMESPACE, but some errors loading the shared\n// libraries in Chromium were noticed when doing so.\n// Instead we create a dylib containing a __DATA,__interpose section that\n// associates library functions with their wrappers. When this dylib is\n// preloaded before an executable using DYLD_INSERT_LIBRARIES, it routes all\n// the calls to interposed functions done through stubs to the wrapper\n// functions.\n// As it's decided at compile time which functions are to be intercepted on Mac,\n// INTERCEPT_FUNCTION() is effectively a no-op on this system.\n\n#if defined(__APPLE__)\n#include <sys/cdefs.h>  // For __DARWIN_ALIAS_C().\n\n// Just a pair of pointers.\nstruct interpose_substitution {\n  const __sanitizer::uptr replacement;\n  const __sanitizer::uptr original;\n};\n\n// For a function foo() create a global pair of pointers { wrap_foo, foo } in\n// the __DATA,__interpose section.\n// As a result all the calls to foo() will be routed to wrap_foo() at runtime.\n#define INTERPOSER(func_name) __attribute__((used)) \\\nconst interpose_substitution substitution_##func_name[] \\\n    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n    { reinterpret_cast<const uptr>(WRAP(func_name)), \\\n      reinterpret_cast<const uptr>(func_name) } \\\n}\n\n// For a function foo() and a wrapper function bar() create a global pair\n// of pointers { bar, foo } in the __DATA,__interpose section.\n// As a result all the calls to foo() will be routed to bar() at runtime.\n#define INTERPOSER_2(func_name, wrapper_name) __attribute__((used)) \\\nconst interpose_substitution substitution_##func_name[] \\\n    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n    { reinterpret_cast<const uptr>(wrapper_name), \\\n      reinterpret_cast<const uptr>(func_name) } \\\n}\n\n# define WRAP(x) wrap_##x\n# define WRAPPER_NAME(x) \"wrap_\"#x\n# define INTERCEPTOR_ATTRIBUTE\n# define DECLARE_WRAPPER(ret_type, func, ...)\n\n#elif defined(_WIN32)\n# define WRAP(x) __asan_wrap_##x\n# define WRAPPER_NAME(x) \"__asan_wrap_\"#x\n# define INTERCEPTOR_ATTRIBUTE __declspec(dllexport)\n# define DECLARE_WRAPPER(ret_type, func, ...) \\\n    extern \"C\" ret_type func(__VA_ARGS__);\n# define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n    extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n#elif defined(__FreeBSD__)\n# define WRAP(x) __interceptor_ ## x\n# define WRAPPER_NAME(x) \"__interceptor_\" #x\n# define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n// FreeBSD's dynamic linker (incompliantly) gives non-weak symbols higher\n// priority than weak ones so weak aliases won't work for indirect calls\n// in position-independent (-fPIC / -fPIE) mode.\n# define DECLARE_WRAPPER(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__) \\\n     __attribute__((alias(\"__interceptor_\" #func), visibility(\"default\")));\n#else\n# define WRAP(x) __interceptor_ ## x\n# define WRAPPER_NAME(x) \"__interceptor_\" #x\n# define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n# define DECLARE_WRAPPER(ret_type, func, ...) \\\n    extern \"C\" ret_type func(__VA_ARGS__) \\\n    __attribute__((weak, alias(\"__interceptor_\" #func), visibility(\"default\")));\n#endif\n\n#if !defined(__APPLE__)\n# define PTR_TO_REAL(x) real_##x\n# define REAL(x) __interception::PTR_TO_REAL(x)\n# define FUNC_TYPE(x) x##_f\n\n# define DECLARE_REAL(ret_type, func, ...) \\\n    typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n    namespace __interception { \\\n      extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n    }\n# define ASSIGN_REAL(dst, src) REAL(dst) = REAL(src)\n#else  // __APPLE__\n# define REAL(x) x\n# define DECLARE_REAL(ret_type, func, ...) \\\n    extern \"C\" ret_type func(__VA_ARGS__);\n# define ASSIGN_REAL(x, y)\n#endif  // __APPLE__\n\n#define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n  DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n  extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n\n// Generally, you don't need to use DEFINE_REAL by itself, as INTERCEPTOR\n// macros does its job. In exceptional cases you may need to call REAL(foo)\n// without defining INTERCEPTOR(..., foo, ...). For example, if you override\n// foo with an interceptor for other function.\n#if !defined(__APPLE__)\n# define DEFINE_REAL(ret_type, func, ...) \\\n    typedef ret_type (*FUNC_TYPE(func))(__VA_ARGS__); \\\n    namespace __interception { \\\n      FUNC_TYPE(func) PTR_TO_REAL(func); \\\n    }\n#else\n# define DEFINE_REAL(ret_type, func, ...)\n#endif\n\n#if !defined(__APPLE__)\n#define INTERCEPTOR(ret_type, func, ...) \\\n  DEFINE_REAL(ret_type, func, __VA_ARGS__) \\\n  DECLARE_WRAPPER(ret_type, func, __VA_ARGS__) \\\n  extern \"C\" \\\n  INTERCEPTOR_ATTRIBUTE \\\n  ret_type WRAP(func)(__VA_ARGS__)\n\n// We don't need INTERCEPTOR_WITH_SUFFIX on non-Darwin for now.\n#define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n  INTERCEPTOR(ret_type, func, __VA_ARGS__)\n\n#else  // __APPLE__\n\n#define INTERCEPTOR_ZZZ(suffix, ret_type, func, ...) \\\n  extern \"C\" ret_type func(__VA_ARGS__) suffix; \\\n  extern \"C\" ret_type WRAP(func)(__VA_ARGS__); \\\n  INTERPOSER(func); \\\n  extern \"C\" INTERCEPTOR_ATTRIBUTE ret_type WRAP(func)(__VA_ARGS__)\n\n#define INTERCEPTOR(ret_type, func, ...) \\\n  INTERCEPTOR_ZZZ(/*no symbol variants*/, ret_type, func, __VA_ARGS__)\n\n#define INTERCEPTOR_WITH_SUFFIX(ret_type, func, ...) \\\n  INTERCEPTOR_ZZZ(__DARWIN_ALIAS_C(func), ret_type, func, __VA_ARGS__)\n\n// Override |overridee| with |overrider|.\n#define OVERRIDE_FUNCTION(overridee, overrider) \\\n  INTERPOSER_2(overridee, WRAP(overrider))\n#endif\n\n#if defined(_WIN32)\n# define INTERCEPTOR_WINAPI(ret_type, func, ...) \\\n    typedef ret_type (__stdcall *FUNC_TYPE(func))(__VA_ARGS__); \\\n    namespace __interception { \\\n      FUNC_TYPE(func) PTR_TO_REAL(func); \\\n    } \\\n    extern \"C\" \\\n    INTERCEPTOR_ATTRIBUTE \\\n    ret_type __stdcall WRAP(func)(__VA_ARGS__)\n#endif\n\n// ISO C++ forbids casting between pointer-to-function and pointer-to-object,\n// so we use casting via an integral type __interception::uptr,\n// assuming that system is POSIX-compliant. Using other hacks seem\n// challenging, as we don't even pass function type to\n// INTERCEPT_FUNCTION macro, only its name.\nnamespace __interception {\n#if defined(_WIN64)\ntypedef unsigned long long uptr;  // NOLINT\n#else\ntypedef unsigned long uptr;  // NOLINT\n#endif  // _WIN64\n}  // namespace __interception\n\n#define INCLUDED_FROM_INTERCEPTION_LIB\n\n#if defined(__linux__) || defined(__FreeBSD__)\n# include \"interception_linux.h\"\n# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)\n# define INTERCEPT_FUNCTION_VER(func, symver) \\\n    INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver)\n#elif defined(__APPLE__)\n# include \"interception_mac.h\"\n# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n# define INTERCEPT_FUNCTION_VER(func, symver) \\\n    INTERCEPT_FUNCTION_VER_MAC(func, symver)\n#else  // defined(_WIN32)\n# include \"interception_win.h\"\n# define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_WIN(func)\n# define INTERCEPT_FUNCTION_VER(func, symver) \\\n    INTERCEPT_FUNCTION_VER_WIN(func, symver)\n#endif\n\n#undef INCLUDED_FROM_INTERCEPTION_LIB\n\n#endif  // INTERCEPTION_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/interception/interception_linux.cc": "//===-- interception_linux.cc -----------------------------------*- C++ -*-===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of AddressSanitizer, an address sanity checker.\n//\n// Linux-specific interception methods.\n//===----------------------------------------------------------------------===//\n\n#if defined(__linux__) || defined(__FreeBSD__)\n#include \"interception.h\"\n\n#include <dlfcn.h>   // for dlsym() and dlvsym()\n\nnamespace __interception {\nbool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n    uptr real, uptr wrapper) {\n  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n  return real == wrapper;\n}\n\n#if !defined(__ANDROID__)  // android does not have dlvsym\nvoid *GetFuncAddrVer(const char *func_name, const char *ver) {\n  return dlvsym(RTLD_NEXT, func_name, ver);\n}\n#endif  // !defined(__ANDROID__)\n\n}  // namespace __interception\n\n\n#endif  // __linux__ || __FreeBSD__\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_mac.cc": "//===-- sanitizer_mac.cc --------------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between various sanitizers' runtime libraries and\n// implements OSX-specific functions.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_platform.h\"\n#if SANITIZER_MAC\n#include \"sanitizer_mac.h\"\n\n// Use 64-bit inodes in file operations. ASan does not support OS X 10.5, so\n// the clients will most certainly use 64-bit ones as well.\n#ifndef _DARWIN_USE_64_BIT_INODE\n#define _DARWIN_USE_64_BIT_INODE 1\n#endif\n#include <stdio.h>\n\n#include \"sanitizer_common.h\"\n#include \"sanitizer_flags.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_libc.h\"\n#include \"sanitizer_placement_new.h\"\n#include \"sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_procmaps.h\"\n\n#if !SANITIZER_IOS\n#include <crt_externs.h>  // for _NSGetEnviron\n#else\nextern char **environ;\n#endif\n\n#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n#define SANITIZER_OS_TRACE 1\n#include <os/trace.h>\n#else\n#define SANITIZER_OS_TRACE 0\n#endif\n\n#if !SANITIZER_IOS\n#include <crt_externs.h>  // for _NSGetArgv and _NSGetEnviron\n#else\nextern \"C\" {\n  extern char ***_NSGetArgv(void);\n}\n#endif\n\n#include <asl.h>\n#include <dlfcn.h>  // for dladdr()\n#include <errno.h>\n#include <fcntl.h>\n#include <libkern/OSAtomic.h>\n#include <mach-o/dyld.h>\n#include <mach/mach.h>\n#include <mach/vm_statistics.h>\n#include <pthread.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <util.h>\n\n// From <crt_externs.h>, but we don't have that file on iOS.\nextern \"C\" {\n  extern char ***_NSGetArgv(void);\n  extern char ***_NSGetEnviron(void);\n}\n\n// From <mach/mach_vm.h>, but we don't have that file on iOS.\nextern \"C\" {\n  extern kern_return_t mach_vm_region_recurse(\n    vm_map_t target_task,\n    mach_vm_address_t *address,\n    mach_vm_size_t *size,\n    natural_t *nesting_depth,\n    vm_region_recurse_info_t info,\n    mach_msg_type_number_t *infoCnt);\n}\n\nnamespace __sanitizer {\n\n#include \"sanitizer_syscall_generic.inc\"\n\n// Direct syscalls, don't call libmalloc hooks (but not available on 10.6).\nextern \"C\" void *__mmap(void *addr, size_t len, int prot, int flags, int fildes,\n                        off_t off) SANITIZER_WEAK_ATTRIBUTE;\nextern \"C\" int __munmap(void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n\n// ---------------------- sanitizer_libc.h\nuptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                   int fd, u64 offset) {\n  if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_ANALYSIS_TOOL);\n  if (__mmap) return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n  return (uptr)mmap(addr, length, prot, flags, fd, offset);\n}\n\nuptr internal_munmap(void *addr, uptr length) {\n  if (__munmap) return __munmap(addr, length);\n  return munmap(addr, length);\n}\n\nint internal_mprotect(void *addr, uptr length, int prot) {\n  return mprotect(addr, length, prot);\n}\n\nuptr internal_close(fd_t fd) {\n  return close(fd);\n}\n\nuptr internal_open(const char *filename, int flags) {\n  return open(filename, flags);\n}\n\nuptr internal_open(const char *filename, int flags, u32 mode) {\n  return open(filename, flags, mode);\n}\n\nuptr internal_read(fd_t fd, void *buf, uptr count) {\n  return read(fd, buf, count);\n}\n\nuptr internal_write(fd_t fd, const void *buf, uptr count) {\n  return write(fd, buf, count);\n}\n\nuptr internal_stat(const char *path, void *buf) {\n  return stat(path, (struct stat *)buf);\n}\n\nuptr internal_lstat(const char *path, void *buf) {\n  return lstat(path, (struct stat *)buf);\n}\n\nuptr internal_fstat(fd_t fd, void *buf) {\n  return fstat(fd, (struct stat *)buf);\n}\n\nuptr internal_filesize(fd_t fd) {\n  struct stat st;\n  if (internal_fstat(fd, &st))\n    return -1;\n  return (uptr)st.st_size;\n}\n\nuptr internal_dup2(int oldfd, int newfd) {\n  return dup2(oldfd, newfd);\n}\n\nuptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n  return readlink(path, buf, bufsize);\n}\n\nuptr internal_unlink(const char *path) {\n  return unlink(path);\n}\n\nuptr internal_sched_yield() {\n  return sched_yield();\n}\n\nvoid internal__exit(int exitcode) {\n  _exit(exitcode);\n}\n\nunsigned int internal_sleep(unsigned int seconds) {\n  return sleep(seconds);\n}\n\nuptr internal_getpid() {\n  return getpid();\n}\n\nint internal_sigaction(int signum, const void *act, void *oldact) {\n  return sigaction(signum,\n                   (struct sigaction *)act, (struct sigaction *)oldact);\n}\n\nvoid internal_sigfillset(__sanitizer_sigset_t *set) { sigfillset(set); }\n\nuptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n                          __sanitizer_sigset_t *oldset) {\n  return sigprocmask(how, set, oldset);\n}\n\n// Doesn't call pthread_atfork() handlers (but not available on 10.6).\nextern \"C\" pid_t __fork(void) SANITIZER_WEAK_ATTRIBUTE;\n\nint internal_fork() {\n  if (__fork)\n    return __fork();\n  return fork();\n}\n\nint internal_forkpty(int *amaster) {\n  int master, slave;\n  if (openpty(&master, &slave, nullptr, nullptr, nullptr) == -1) return -1;\n  int pid = internal_fork();\n  if (pid == -1) {\n    close(master);\n    close(slave);\n    return -1;\n  }\n  if (pid == 0) {\n    close(master);\n    if (login_tty(slave) != 0) {\n      // We already forked, there's not much we can do.  Let's quit.\n      Report(\"login_tty failed (errno %d)\\n\", errno);\n      internal__exit(1);\n    }\n  } else {\n    *amaster = master;\n    close(slave);\n  }\n  return pid;\n}\n\nuptr internal_rename(const char *oldpath, const char *newpath) {\n  return rename(oldpath, newpath);\n}\n\nuptr internal_ftruncate(fd_t fd, uptr size) {\n  return ftruncate(fd, size);\n}\n\nuptr internal_execve(const char *filename, char *const argv[],\n                     char *const envp[]) {\n  return execve(filename, argv, envp);\n}\n\nuptr internal_waitpid(int pid, int *status, int options) {\n  return waitpid(pid, status, options);\n}\n\n// ----------------- sanitizer_common.h\nbool FileExists(const char *filename) {\n  struct stat st;\n  if (stat(filename, &st))\n    return false;\n  // Sanity check: filename is a regular file.\n  return S_ISREG(st.st_mode);\n}\n\nuptr GetTid() {\n  // FIXME: This can potentially get truncated on 32-bit, where uptr is 4 bytes.\n  uint64_t tid;\n  pthread_threadid_np(nullptr, &tid);\n  return tid;\n}\n\nvoid GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                uptr *stack_bottom) {\n  CHECK(stack_top);\n  CHECK(stack_bottom);\n  uptr stacksize = pthread_get_stacksize_np(pthread_self());\n  // pthread_get_stacksize_np() returns an incorrect stack size for the main\n  // thread on Mavericks. See\n  // https://github.com/google/sanitizers/issues/261\n  if ((GetMacosVersion() >= MACOS_VERSION_MAVERICKS) && at_initialization &&\n      stacksize == (1 << 19))  {\n    struct rlimit rl;\n    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n    // Most often rl.rlim_cur will be the desired 8M.\n    if (rl.rlim_cur < kMaxThreadStackSize) {\n      stacksize = rl.rlim_cur;\n    } else {\n      stacksize = kMaxThreadStackSize;\n    }\n  }\n  void *stackaddr = pthread_get_stackaddr_np(pthread_self());\n  *stack_top = (uptr)stackaddr;\n  *stack_bottom = *stack_top - stacksize;\n}\n\nchar **GetEnviron() {\n#if !SANITIZER_IOS\n  char ***env_ptr = _NSGetEnviron();\n  if (!env_ptr) {\n    Report(\"_NSGetEnviron() returned NULL. Please make sure __asan_init() is \"\n           \"called after libSystem_initializer().\\n\");\n    CHECK(env_ptr);\n  }\n  char **environ = *env_ptr;\n#endif\n  CHECK(environ);\n  return environ;\n}\n\nconst char *GetEnv(const char *name) {\n  char **env = GetEnviron();\n  uptr name_len = internal_strlen(name);\n  while (*env != 0) {\n    uptr len = internal_strlen(*env);\n    if (len > name_len) {\n      const char *p = *env;\n      if (!internal_memcmp(p, name, name_len) &&\n          p[name_len] == '=') {  // Match.\n        return *env + name_len + 1;  // String starting after =.\n      }\n    }\n    env++;\n  }\n  return 0;\n}\n\nuptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n  CHECK_LE(kMaxPathLength, buf_len);\n\n  // On OS X the executable path is saved to the stack by dyld. Reading it\n  // from there is much faster than calling dladdr, especially for large\n  // binaries with symbols.\n  InternalScopedString exe_path(kMaxPathLength);\n  uint32_t size = exe_path.size();\n  if (_NSGetExecutablePath(exe_path.data(), &size) == 0 &&\n      realpath(exe_path.data(), buf) != 0) {\n    return internal_strlen(buf);\n  }\n  return 0;\n}\n\nuptr ReadLongProcessName(/*out*/char *buf, uptr buf_len) {\n  return ReadBinaryName(buf, buf_len);\n}\n\nvoid ReExec() {\n  UNIMPLEMENTED();\n}\n\nuptr GetPageSize() {\n  return sysconf(_SC_PAGESIZE);\n}\n\nBlockingMutex::BlockingMutex() {\n  internal_memset(this, 0, sizeof(*this));\n}\n\nvoid BlockingMutex::Lock() {\n  CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n  CHECK_EQ(OS_SPINLOCK_INIT, 0);\n  CHECK_NE(owner_, (uptr)pthread_self());\n  OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n  CHECK(!owner_);\n  owner_ = (uptr)pthread_self();\n}\n\nvoid BlockingMutex::Unlock() {\n  CHECK(owner_ == (uptr)pthread_self());\n  owner_ = 0;\n  OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n}\n\nvoid BlockingMutex::CheckLocked() {\n  CHECK_EQ((uptr)pthread_self(), owner_);\n}\n\nu64 NanoTime() {\n  return 0;\n}\n\nuptr GetTlsSize() {\n  return 0;\n}\n\nvoid InitTlsSize() {\n}\n\nvoid GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                          uptr *tls_addr, uptr *tls_size) {\n#if !SANITIZER_GO\n  uptr stack_top, stack_bottom;\n  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n  *stk_addr = stack_bottom;\n  *stk_size = stack_top - stack_bottom;\n  *tls_addr = 0;\n  *tls_size = 0;\n#else\n  *stk_addr = 0;\n  *stk_size = 0;\n  *tls_addr = 0;\n  *tls_size = 0;\n#endif\n}\n\nvoid ListOfModules::init() {\n  clear();\n  MemoryMappingLayout memory_mapping(false);\n  memory_mapping.DumpListOfModules(&modules_);\n}\n\nbool IsHandledDeadlySignal(int signum) {\n  if ((SANITIZER_WATCHOS || SANITIZER_TVOS) && !(SANITIZER_IOSSIM))\n    // Handling fatal signals on watchOS and tvOS devices is disallowed.\n    return false;\n  if (common_flags()->handle_abort && signum == SIGABRT)\n    return true;\n  return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n}\n\nMacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n\nMacosVersion GetMacosVersionInternal() {\n  int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n  char version[100];\n  uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n  for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n  // Get the version length.\n  CHECK_NE(sysctl(mib, 2, 0, &len, 0, 0), -1);\n  CHECK_LT(len, maxlen);\n  CHECK_NE(sysctl(mib, 2, version, &len, 0, 0), -1);\n  switch (version[0]) {\n    case '9': return MACOS_VERSION_LEOPARD;\n    case '1': {\n      switch (version[1]) {\n        case '0': return MACOS_VERSION_SNOW_LEOPARD;\n        case '1': return MACOS_VERSION_LION;\n        case '2': return MACOS_VERSION_MOUNTAIN_LION;\n        case '3': return MACOS_VERSION_MAVERICKS;\n        case '4': return MACOS_VERSION_YOSEMITE;\n        default:\n          if (IsDigit(version[1]))\n            return MACOS_VERSION_UNKNOWN_NEWER;\n          else\n            return MACOS_VERSION_UNKNOWN;\n      }\n    }\n    default: return MACOS_VERSION_UNKNOWN;\n  }\n}\n\nMacosVersion GetMacosVersion() {\n  atomic_uint32_t *cache =\n      reinterpret_cast<atomic_uint32_t*>(&cached_macos_version);\n  MacosVersion result =\n      static_cast<MacosVersion>(atomic_load(cache, memory_order_acquire));\n  if (result == MACOS_VERSION_UNINITIALIZED) {\n    result = GetMacosVersionInternal();\n    atomic_store(cache, result, memory_order_release);\n  }\n  return result;\n}\n\nuptr GetRSS() {\n  struct task_basic_info info;\n  unsigned count = TASK_BASIC_INFO_COUNT;\n  kern_return_t result =\n      task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &count);\n  if (UNLIKELY(result != KERN_SUCCESS)) {\n    Report(\"Cannot get task info. Error: %d\\n\", result);\n    Die();\n  }\n  return info.resident_size;\n}\n\nvoid *internal_start_thread(void(*func)(void *arg), void *arg) {\n  // Start the thread with signals blocked, otherwise it can steal user signals.\n  __sanitizer_sigset_t set, old;\n  internal_sigfillset(&set);\n  internal_sigprocmask(SIG_SETMASK, &set, &old);\n  pthread_t th;\n  pthread_create(&th, 0, (void*(*)(void *arg))func, arg);\n  internal_sigprocmask(SIG_SETMASK, &old, 0);\n  return th;\n}\n\nvoid internal_join_thread(void *th) { pthread_join((pthread_t)th, 0); }\n\n#if !SANITIZER_GO\nstatic BlockingMutex syslog_lock(LINKER_INITIALIZED);\n#endif\n\nvoid WriteOneLineToSyslog(const char *s) {\n#if !SANITIZER_GO\n  syslog_lock.CheckLocked();\n  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", s);\n#endif\n}\n\nvoid LogMessageOnPrintf(const char *str) {\n  // Log all printf output to CrashLog.\n  if (common_flags()->abort_on_error)\n    CRAppendCrashLogMessage(str);\n}\n\nvoid LogFullErrorReport(const char *buffer) {\n#if !SANITIZER_GO\n  // Log with os_trace. This will make it into the crash log.\n#if SANITIZER_OS_TRACE\n  if (GetMacosVersion() >= MACOS_VERSION_YOSEMITE) {\n    // os_trace requires the message (format parameter) to be a string literal.\n    if (internal_strncmp(SanitizerToolName, \"AddressSanitizer\",\n                         sizeof(\"AddressSanitizer\") - 1) == 0)\n      os_trace(\"Address Sanitizer reported a failure.\");\n    else if (internal_strncmp(SanitizerToolName, \"UndefinedBehaviorSanitizer\",\n                              sizeof(\"UndefinedBehaviorSanitizer\") - 1) == 0)\n      os_trace(\"Undefined Behavior Sanitizer reported a failure.\");\n    else if (internal_strncmp(SanitizerToolName, \"ThreadSanitizer\",\n                              sizeof(\"ThreadSanitizer\") - 1) == 0)\n      os_trace(\"Thread Sanitizer reported a failure.\");\n    else\n      os_trace(\"Sanitizer tool reported a failure.\");\n\n    if (common_flags()->log_to_syslog)\n      os_trace(\"Consult syslog for more information.\");\n  }\n#endif\n\n  // Log to syslog.\n  // The logging on OS X may call pthread_create so we need the threading\n  // environment to be fully initialized. Also, this should never be called when\n  // holding the thread registry lock since that may result in a deadlock. If\n  // the reporting thread holds the thread registry mutex, and asl_log waits\n  // for GCD to dispatch a new thread, the process will deadlock, because the\n  // pthread_create wrapper needs to acquire the lock as well.\n  BlockingMutexLock l(&syslog_lock);\n  if (common_flags()->log_to_syslog)\n    WriteToSyslog(buffer);\n\n  // The report is added to CrashLog as part of logging all of Printf output.\n#endif\n}\n\nSignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n#if defined(__x86_64__) || defined(__i386__)\n  ucontext_t *ucontext = static_cast<ucontext_t*>(context);\n  return ucontext->uc_mcontext->__es.__err & 2 /*T_PF_WRITE*/ ? WRITE : READ;\n#else\n  return UNKNOWN;\n#endif\n}\n\nvoid GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n  ucontext_t *ucontext = (ucontext_t*)context;\n# if defined(__aarch64__)\n  *pc = ucontext->uc_mcontext->__ss.__pc;\n#   if defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_8_0\n  *bp = ucontext->uc_mcontext->__ss.__fp;\n#   else\n  *bp = ucontext->uc_mcontext->__ss.__lr;\n#   endif\n  *sp = ucontext->uc_mcontext->__ss.__sp;\n# elif defined(__x86_64__)\n  *pc = ucontext->uc_mcontext->__ss.__rip;\n  *bp = ucontext->uc_mcontext->__ss.__rbp;\n  *sp = ucontext->uc_mcontext->__ss.__rsp;\n# elif defined(__arm__)\n  *pc = ucontext->uc_mcontext->__ss.__pc;\n  *bp = ucontext->uc_mcontext->__ss.__r[7];\n  *sp = ucontext->uc_mcontext->__ss.__sp;\n# elif defined(__i386__)\n  *pc = ucontext->uc_mcontext->__ss.__eip;\n  *bp = ucontext->uc_mcontext->__ss.__ebp;\n  *sp = ucontext->uc_mcontext->__ss.__esp;\n# else\n# error \"Unknown architecture\"\n# endif\n}\n\n#if !SANITIZER_GO\nstatic const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\nLowLevelAllocator allocator_for_env;\n\n// Change the value of the env var |name|, leaking the original value.\n// If |name_value| is NULL, the variable is deleted from the environment,\n// otherwise the corresponding \"NAME=value\" string is replaced with\n// |name_value|.\nvoid LeakyResetEnv(const char *name, const char *name_value) {\n  char **env = GetEnviron();\n  uptr name_len = internal_strlen(name);\n  while (*env != 0) {\n    uptr len = internal_strlen(*env);\n    if (len > name_len) {\n      const char *p = *env;\n      if (!internal_memcmp(p, name, name_len) && p[name_len] == '=') {\n        // Match.\n        if (name_value) {\n          // Replace the old value with the new one.\n          *env = const_cast<char*>(name_value);\n        } else {\n          // Shift the subsequent pointers back.\n          char **del = env;\n          do {\n            del[0] = del[1];\n          } while (*del++);\n        }\n      }\n    }\n    env++;\n  }\n}\n\nSANITIZER_WEAK_CXX_DEFAULT_IMPL\nbool ReexecDisabled() {\n  return false;\n}\n\nextern \"C\" SANITIZER_WEAK_ATTRIBUTE double dyldVersionNumber;\nstatic const double kMinDyldVersionWithAutoInterposition = 360.0;\n\nbool DyldNeedsEnvVariable() {\n  // Although sanitizer support was added to LLVM on OS X 10.7+, GCC users\n  // still may want use them on older systems. On older Darwin platforms, dyld\n  // doesn't export dyldVersionNumber symbol and we simply return true.\n  if (!&dyldVersionNumber) return true;\n  // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n  // DYLD_INSERT_LIBRARIES is not set. However, checking OS version via\n  // GetMacosVersion() doesn't work for the simulator. Let's instead check\n  // `dyldVersionNumber`, which is exported by dyld, against a known version\n  // number from the first OS release where this appeared.\n  return dyldVersionNumber < kMinDyldVersionWithAutoInterposition;\n}\n\nvoid MaybeReexec() {\n  if (ReexecDisabled()) return;\n\n  // Make sure the dynamic runtime library is preloaded so that the\n  // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n  // ourselves.\n  Dl_info info;\n  RAW_CHECK(dladdr((void*)((uptr)&__sanitizer_report_error_summary), &info));\n  char *dyld_insert_libraries =\n      const_cast<char*>(GetEnv(kDyldInsertLibraries));\n  uptr old_env_len = dyld_insert_libraries ?\n      internal_strlen(dyld_insert_libraries) : 0;\n  uptr fname_len = internal_strlen(info.dli_fname);\n  const char *dylib_name = StripModuleName(info.dli_fname);\n  uptr dylib_name_len = internal_strlen(dylib_name);\n\n  bool lib_is_in_env = dyld_insert_libraries &&\n                       internal_strstr(dyld_insert_libraries, dylib_name);\n  if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n    // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n    // library.\n    InternalScopedString program_name(1024);\n    uint32_t buf_size = program_name.size();\n    _NSGetExecutablePath(program_name.data(), &buf_size);\n    char *new_env = const_cast<char*>(info.dli_fname);\n    if (dyld_insert_libraries) {\n      // Append the runtime dylib name to the existing value of\n      // DYLD_INSERT_LIBRARIES.\n      new_env = (char*)allocator_for_env.Allocate(old_env_len + fname_len + 2);\n      internal_strncpy(new_env, dyld_insert_libraries, old_env_len);\n      new_env[old_env_len] = ':';\n      // Copy fname_len and add a trailing zero.\n      internal_strncpy(new_env + old_env_len + 1, info.dli_fname,\n                       fname_len + 1);\n      // Ok to use setenv() since the wrappers don't depend on the value of\n      // asan_inited.\n      setenv(kDyldInsertLibraries, new_env, /*overwrite*/1);\n    } else {\n      // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n      setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n    }\n    VReport(1, \"exec()-ing the program with\\n\");\n    VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n    VReport(1, \"to enable wrappers.\\n\");\n    execv(program_name.data(), *_NSGetArgv());\n\n    // We get here only if execv() failed.\n    Report(\"ERROR: The process is launched without DYLD_INSERT_LIBRARIES, \"\n           \"which is required for the sanitizer to work. We tried to set the \"\n           \"environment variable and re-execute itself, but execv() failed, \"\n           \"possibly because of sandbox restrictions. Make sure to launch the \"\n           \"executable with:\\n%s=%s\\n\", kDyldInsertLibraries, new_env);\n    RAW_CHECK(\"execv failed\" && 0);\n  }\n\n  // Verify that interceptors really work.  We'll use dlsym to locate\n  // \"pthread_create\", if interceptors are working, it should really point to\n  // \"wrap_pthread_create\" within our own dylib.\n  Dl_info info_pthread_create;\n  void *dlopen_addr = dlsym(RTLD_DEFAULT, \"pthread_create\");\n  RAW_CHECK(dladdr(dlopen_addr, &info_pthread_create));\n  if (internal_strcmp(info.dli_fname, info_pthread_create.dli_fname) != 0) {\n    Report(\n        \"ERROR: Interceptors are not working. This may be because %s is \"\n        \"loaded too late (e.g. via dlopen). Please launch the executable \"\n        \"with:\\n%s=%s\\n\",\n        SanitizerToolName, kDyldInsertLibraries, info.dli_fname);\n    RAW_CHECK(\"interceptors not installed\" && 0);\n  }\n\n  if (!lib_is_in_env)\n    return;\n\n  // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n  // the dylib from the environment variable, because interceptors are installed\n  // and we don't want our children to inherit the variable.\n\n  uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n  // Allocate memory to hold the previous env var name, its value, the '='\n  // sign and the '\\0' char.\n  char *new_env = (char*)allocator_for_env.Allocate(\n      old_env_len + 2 + env_name_len);\n  RAW_CHECK(new_env);\n  internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n  internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n  new_env[env_name_len] = '=';\n  char *new_env_pos = new_env + env_name_len + 1;\n\n  // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n  char *piece_start = dyld_insert_libraries;\n  char *piece_end = NULL;\n  char *old_env_end = dyld_insert_libraries + old_env_len;\n  do {\n    if (piece_start[0] == ':') piece_start++;\n    piece_end = internal_strchr(piece_start, ':');\n    if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n    if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n    uptr piece_len = piece_end - piece_start;\n\n    char *filename_start =\n        (char *)internal_memrchr(piece_start, '/', piece_len);\n    uptr filename_len = piece_len;\n    if (filename_start) {\n      filename_start += 1;\n      filename_len = piece_len - (filename_start - piece_start);\n    } else {\n      filename_start = piece_start;\n    }\n\n    // If the current piece isn't the runtime library name,\n    // append it to new_env.\n    if ((dylib_name_len != filename_len) ||\n        (internal_memcmp(filename_start, dylib_name, dylib_name_len) != 0)) {\n      if (new_env_pos != new_env + env_name_len + 1) {\n        new_env_pos[0] = ':';\n        new_env_pos++;\n      }\n      internal_strncpy(new_env_pos, piece_start, piece_len);\n      new_env_pos += piece_len;\n    }\n    // Move on to the next piece.\n    piece_start = piece_end;\n  } while (piece_start < old_env_end);\n\n  // Can't use setenv() here, because it requires the allocator to be\n  // initialized.\n  // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n  // a separate function called after InitializeAllocator().\n  if (new_env_pos == new_env + env_name_len + 1) new_env = NULL;\n  LeakyResetEnv(kDyldInsertLibraries, new_env);\n}\n#endif  // SANITIZER_GO\n\nchar **GetArgv() {\n  return *_NSGetArgv();\n}\n\nuptr FindAvailableMemoryRange(uptr shadow_size,\n                              uptr alignment,\n                              uptr left_padding) {\n  typedef vm_region_submap_short_info_data_64_t RegionInfo;\n  enum { kRegionInfoSize = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 };\n  // Start searching for available memory region past PAGEZERO, which is\n  // 4KB on 32-bit and 4GB on 64-bit.\n  mach_vm_address_t start_address =\n    (SANITIZER_WORDSIZE == 32) ? 0x000000001000 : 0x000100000000;\n\n  mach_vm_address_t address = start_address;\n  mach_vm_address_t free_begin = start_address;\n  kern_return_t kr = KERN_SUCCESS;\n  while (kr == KERN_SUCCESS) {\n    mach_vm_size_t vmsize = 0;\n    natural_t depth = 0;\n    RegionInfo vminfo;\n    mach_msg_type_number_t count = kRegionInfoSize;\n    kr = mach_vm_region_recurse(mach_task_self(), &address, &vmsize, &depth,\n                                (vm_region_info_t)&vminfo, &count);\n    if (free_begin != address) {\n      // We found a free region [free_begin..address-1].\n      uptr shadow_address = RoundUpTo((uptr)free_begin + left_padding,\n                                      alignment);\n      if (shadow_address + shadow_size < (uptr)address) {\n        return shadow_address;\n      }\n    }\n    // Move to the next region.\n    address += vmsize;\n    free_begin = address;\n  }\n\n  // We looked at all free regions and could not find one large enough.\n  return 0;\n}\n\n// FIXME implement on this platform.\nvoid GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) { }\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_MAC\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc": "//===-- sanitizer_common_interceptors.inc -----------------------*- C++ -*-===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// Common function interceptors for tools like AddressSanitizer,\n// ThreadSanitizer, MemorySanitizer, etc.\n//\n// This file should be included into the tool's interceptor file,\n// which has to define its own macros:\n//   COMMON_INTERCEPTOR_ENTER\n//   COMMON_INTERCEPTOR_ENTER_NOIGNORE\n//   COMMON_INTERCEPTOR_READ_RANGE\n//   COMMON_INTERCEPTOR_WRITE_RANGE\n//   COMMON_INTERCEPTOR_INITIALIZE_RANGE\n//   COMMON_INTERCEPTOR_DIR_ACQUIRE\n//   COMMON_INTERCEPTOR_FD_ACQUIRE\n//   COMMON_INTERCEPTOR_FD_RELEASE\n//   COMMON_INTERCEPTOR_FD_ACCESS\n//   COMMON_INTERCEPTOR_SET_THREAD_NAME\n//   COMMON_INTERCEPTOR_ON_DLOPEN\n//   COMMON_INTERCEPTOR_ON_EXIT\n//   COMMON_INTERCEPTOR_MUTEX_LOCK\n//   COMMON_INTERCEPTOR_MUTEX_UNLOCK\n//   COMMON_INTERCEPTOR_MUTEX_REPAIR\n//   COMMON_INTERCEPTOR_SET_PTHREAD_NAME\n//   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n//   COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n//===----------------------------------------------------------------------===//\n\n#include \"interception/interception.h\"\n#include \"sanitizer_addrhashmap.h\"\n#include \"sanitizer_placement_new.h\"\n#include \"sanitizer_platform_interceptors.h\"\n#include \"sanitizer_tls_get_addr.h\"\n\n#include <stdarg.h>\n\n#if SANITIZER_INTERCEPTOR_HOOKS\n#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)                                     \\\n  do {                                                                         \\\n    if (f)                                                                     \\\n      f(__VA_ARGS__);                                                          \\\n  } while (false);\n#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)                                  \\\n  extern \"C\" {                                                                 \\\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void f(__VA_ARGS__);  \\\n  } // extern \"C\"\n#else\n#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)\n#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)\n\n#endif  // SANITIZER_INTERCEPTOR_HOOKS\n\n#if SANITIZER_WINDOWS && !defined(va_copy)\n#define va_copy(dst, src) ((dst) = (src))\n#endif // _WIN32\n\n#if SANITIZER_FREEBSD\n#define pthread_setname_np pthread_set_name_np\n#define inet_aton __inet_aton\n#define inet_pton __inet_pton\n#define iconv __bsd_iconv\n#endif\n\n#ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n#define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_UNPOISON_PARAM\n#define COMMON_INTERCEPTOR_UNPOISON_PARAM(count) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FD_ACCESS\n#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_LOCK\n#define COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_UNLOCK\n#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_REPAIR\n#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_INVALID\n#define COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_HANDLE_RECVMSG\n#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) ((void)(msg))\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FILE_OPEN\n#define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FILE_CLOSE\n#define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_LIBRARY_LOADED\n#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_LIBRARY_UNLOADED\n#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_ENTER_NOIGNORE\n#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, ...) \\\n  COMMON_INTERCEPTOR_ENTER(ctx, __VA_ARGS__)\n#endif\n\n#ifndef COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (0)\n#endif\n\n#define COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, n)       \\\n    COMMON_INTERCEPTOR_READ_RANGE((ctx), (s),                       \\\n      common_flags()->strict_string_checks ? (len) + 1 : (n) )\n\n#define COMMON_INTERCEPTOR_READ_STRING(ctx, s, n)                   \\\n    COMMON_INTERCEPTOR_READ_STRING_OF_LEN((ctx), (s), REAL(strlen)(s), (n))\n\n#ifndef COMMON_INTERCEPTOR_ON_DLOPEN\n#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_GET_TLS_RANGE\n#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end) *begin = *end = 0;\n#endif\n\n#ifndef COMMON_INTERCEPTOR_ACQUIRE\n#define COMMON_INTERCEPTOR_ACQUIRE(ctx, u) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_RELEASE\n#define COMMON_INTERCEPTOR_RELEASE(ctx, u) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_USER_CALLBACK_START\n#define COMMON_INTERCEPTOR_USER_CALLBACK_START() {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_USER_CALLBACK_END\n#define COMMON_INTERCEPTOR_USER_CALLBACK_END() {}\n#endif\n\n#ifdef SANITIZER_NLDBL_VERSION\n#define COMMON_INTERCEPT_FUNCTION_LDBL(fn)                          \\\n    COMMON_INTERCEPT_FUNCTION_VER(fn, SANITIZER_NLDBL_VERSION)\n#else\n#define COMMON_INTERCEPT_FUNCTION_LDBL(fn)                          \\\n    COMMON_INTERCEPT_FUNCTION(fn)\n#endif\n\nstruct FileMetadata {\n  // For open_memstream().\n  char **addr;\n  SIZE_T *size;\n};\n\nstruct CommonInterceptorMetadata {\n  enum {\n    CIMT_INVALID = 0,\n    CIMT_FILE\n  } type;\n  union {\n    FileMetadata file;\n  };\n};\n\ntypedef AddrHashMap<CommonInterceptorMetadata, 31051> MetadataHashMap;\n\nstatic MetadataHashMap *interceptor_metadata_map;\n\n#if SI_NOT_WINDOWS\nUNUSED static void SetInterceptorMetadata(__sanitizer_FILE *addr,\n                                          const FileMetadata &file) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr);\n  CHECK(h.created());\n  h->type = CommonInterceptorMetadata::CIMT_FILE;\n  h->file = file;\n}\n\nUNUSED static const FileMetadata *GetInterceptorMetadata(\n    __sanitizer_FILE *addr) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr,\n                            /* remove */ false,\n                            /* create */ false);\n  if (h.exists()) {\n    CHECK(!h.created());\n    CHECK(h->type == CommonInterceptorMetadata::CIMT_FILE);\n    return &h->file;\n  } else {\n    return 0;\n  }\n}\n\nUNUSED static void DeleteInterceptorMetadata(void *addr) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr, true);\n  CHECK(h.exists());\n}\n#endif  // SI_NOT_WINDOWS\n\n#if SANITIZER_INTERCEPT_STRLEN\nINTERCEPTOR(SIZE_T, strlen, const char *s) {\n  // Sometimes strlen is called prior to InitializeCommonInterceptors,\n  // in which case the REAL(strlen) typically used in\n  // COMMON_INTERCEPTOR_ENTER will fail.  We use internal_strlen here\n  // to handle that.\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strlen(s);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strlen, s);\n  SIZE_T result = REAL(strlen)(s);\n  if (common_flags()->intercept_strlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, result + 1);\n  return result;\n}\n#define INIT_STRLEN COMMON_INTERCEPT_FUNCTION(strlen)\n#else\n#define INIT_STRLEN\n#endif\n\n#if SANITIZER_INTERCEPT_STRNLEN\nINTERCEPTOR(SIZE_T, strnlen, const char *s, SIZE_T maxlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnlen, s, maxlen);\n  SIZE_T length = REAL(strnlen)(s, maxlen);\n  if (common_flags()->intercept_strlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, Min(length + 1, maxlen));\n  return length;\n}\n#define INIT_STRNLEN COMMON_INTERCEPT_FUNCTION(strnlen)\n#else\n#define INIT_STRNLEN\n#endif\n\n#if SANITIZER_INTERCEPT_TEXTDOMAIN\nINTERCEPTOR(char*, textdomain, const char *domainname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, textdomain, domainname);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, domainname, 0);\n  char *domain = REAL(textdomain)(domainname);\n  if (domain) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(domain, REAL(strlen)(domain) + 1);\n  }\n  return domain;\n}\n#define INIT_TEXTDOMAIN COMMON_INTERCEPT_FUNCTION(textdomain)\n#else\n#define INIT_TEXTDOMAIN\n#endif\n\n#if SANITIZER_INTERCEPT_STRCMP\nstatic inline int CharCmpX(unsigned char c1, unsigned char c2) {\n  return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, uptr called_pc,\n                              const char *s1, const char *s2, int result)\n\nINTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcmp, s1, s2);\n  unsigned char c1, c2;\n  uptr i;\n  for (i = 0;; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (c1 != c2 || c1 == '\\0') break;\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n  int result = CharCmpX(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, GET_CALLER_PC(), s1,\n                             s2, result);\n  return result;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, uptr called_pc,\n                              const char *s1, const char *s2, uptr n,\n                              int result)\n\nINTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strncmp(s1, s2, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strncmp, s1, s2, size);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0; i < size; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (c1 != c2 || c1 == '\\0') break;\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, Min(i + 1, size));\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, Min(i + 1, size));\n  int result = CharCmpX(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, GET_CALLER_PC(), s1,\n                             s2, size, result);\n  return result;\n}\n\n#define INIT_STRCMP COMMON_INTERCEPT_FUNCTION(strcmp)\n#define INIT_STRNCMP COMMON_INTERCEPT_FUNCTION(strncmp)\n#else\n#define INIT_STRCMP\n#define INIT_STRNCMP\n#endif\n\n#if SANITIZER_INTERCEPT_STRCASECMP\nstatic inline int CharCaseCmp(unsigned char c1, unsigned char c2) {\n  int c1_low = ToLower(c1);\n  int c2_low = ToLower(c2);\n  return c1_low - c2_low;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasecmp, uptr called_pc,\n                              const char *s1, const char *s2, int result)\n\nINTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcasecmp, s1, s2);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0;; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n  int result = CharCaseCmp(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasecmp, GET_CALLER_PC(),\n                             s1, s2, result);\n  return result;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, uptr called_pc,\n                              const char *s1, const char *s2, uptr n,\n                              int result)\n\nINTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strncasecmp, s1, s2, n);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0; i < n; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n  }\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, n));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, n));\n  int result = CharCaseCmp(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, GET_CALLER_PC(),\n                             s1, s2, n, result);\n  return result;\n}\n\n#define INIT_STRCASECMP COMMON_INTERCEPT_FUNCTION(strcasecmp)\n#define INIT_STRNCASECMP COMMON_INTERCEPT_FUNCTION(strncasecmp)\n#else\n#define INIT_STRCASECMP\n#define INIT_STRNCASECMP\n#endif\n\n#if SANITIZER_INTERCEPT_STRSTR || SANITIZER_INTERCEPT_STRCASESTR\nstatic inline void StrstrCheck(void *ctx, char *r, const char *s1,\n                               const char *s2) {\n    uptr len1 = REAL(strlen)(s1);\n    uptr len2 = REAL(strlen)(s2);\n    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s1, len1,\n                                          r ? r - s1 + len2 : len1 + 1);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2 + 1);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_STRSTR\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strstr, uptr called_pc,\n                              const char *s1, const char *s2, char *result)\n\nINTERCEPTOR(char*, strstr, const char *s1, const char *s2) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strstr(s1, s2);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strstr, s1, s2);\n  char *r = REAL(strstr)(s1, s2);\n  if (common_flags()->intercept_strstr)\n    StrstrCheck(ctx, r, s1, s2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strstr, GET_CALLER_PC(), s1,\n                             s2, r);\n  return r;\n}\n\n#define INIT_STRSTR COMMON_INTERCEPT_FUNCTION(strstr);\n#else\n#define INIT_STRSTR\n#endif\n\n#if SANITIZER_INTERCEPT_STRCASESTR\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasestr, uptr called_pc,\n                              const char *s1, const char *s2, char *result)\n\nINTERCEPTOR(char*, strcasestr, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcasestr, s1, s2);\n  char *r = REAL(strcasestr)(s1, s2);\n  if (common_flags()->intercept_strstr)\n    StrstrCheck(ctx, r, s1, s2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasestr, GET_CALLER_PC(),\n                             s1, s2, r);\n  return r;\n}\n\n#define INIT_STRCASESTR COMMON_INTERCEPT_FUNCTION(strcasestr);\n#else\n#define INIT_STRCASESTR\n#endif\n\n#if SANITIZER_INTERCEPT_MEMMEM\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memmem, uptr called_pc,\n                              const void *s1, SIZE_T len1, const void *s2,\n                              SIZE_T len2, void *result)\n\nINTERCEPTOR(void*, memmem, const void *s1, SIZE_T len1, const void *s2,\n            SIZE_T len2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memmem, s1, len1, s2, len2);\n  void *r = REAL(memmem)(s1, len1, s2, len2);\n  if (common_flags()->intercept_memmem) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, len1);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2);\n  }\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memmem, GET_CALLER_PC(),\n                             s1, len1, s2, len2, r);\n  return r;\n}\n\n#define INIT_MEMMEM COMMON_INTERCEPT_FUNCTION(memmem);\n#else\n#define INIT_MEMMEM\n#endif  // SANITIZER_INTERCEPT_MEMMEM\n\n#if SANITIZER_INTERCEPT_STRCHR\nINTERCEPTOR(char*, strchr, const char *s, int c) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strchr(s, c);\n  COMMON_INTERCEPTOR_ENTER(ctx, strchr, s, c);\n  char *result = REAL(strchr)(s, c);\n  uptr len = internal_strlen(s);\n  uptr n = result ? result - s + 1 : len + 1;\n  if (common_flags()->intercept_strchr)\n    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, n);\n  return result;\n}\n#define INIT_STRCHR COMMON_INTERCEPT_FUNCTION(strchr)\n#else\n#define INIT_STRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_STRCHRNUL\nINTERCEPTOR(char*, strchrnul, const char *s, int c) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strchrnul, s, c);\n  char *result = REAL(strchrnul)(s, c);\n  uptr len = result - s + 1;\n  if (common_flags()->intercept_strchr)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s, len);\n  return result;\n}\n#define INIT_STRCHRNUL COMMON_INTERCEPT_FUNCTION(strchrnul)\n#else\n#define INIT_STRCHRNUL\n#endif\n\n#if SANITIZER_INTERCEPT_STRRCHR\nINTERCEPTOR(char*, strrchr, const char *s, int c) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strrchr(s, c);\n  COMMON_INTERCEPTOR_ENTER(ctx, strrchr, s, c);\n  uptr len = internal_strlen(s);\n  if (common_flags()->intercept_strchr)\n    COMMON_INTERCEPTOR_READ_STRING_OF_LEN(ctx, s, len, len + 1);\n  return REAL(strrchr)(s, c);\n}\n#define INIT_STRRCHR COMMON_INTERCEPT_FUNCTION(strrchr)\n#else\n#define INIT_STRRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_STRSPN\nINTERCEPTOR(SIZE_T, strspn, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strspn, s1, s2);\n  SIZE_T r = REAL(strspn)(s1, s2);\n  if (common_flags()->intercept_strspn) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n  }\n  return r;\n}\n\nINTERCEPTOR(SIZE_T, strcspn, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcspn, s1, s2);\n  SIZE_T r = REAL(strcspn)(s1, s2);\n  if (common_flags()->intercept_strspn) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n  }\n  return r;\n}\n\n#define INIT_STRSPN \\\n  COMMON_INTERCEPT_FUNCTION(strspn); \\\n  COMMON_INTERCEPT_FUNCTION(strcspn);\n#else\n#define INIT_STRSPN\n#endif\n\n#if SANITIZER_INTERCEPT_STRPBRK\nINTERCEPTOR(char *, strpbrk, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strpbrk, s1, s2);\n  char *r = REAL(strpbrk)(s1, s2);\n  if (common_flags()->intercept_strpbrk) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1,\n        r ? r - s1 + 1 : REAL(strlen)(s1) + 1);\n  }\n  return r;\n}\n\n#define INIT_STRPBRK COMMON_INTERCEPT_FUNCTION(strpbrk);\n#else\n#define INIT_STRPBRK\n#endif\n\n#if SANITIZER_INTERCEPT_MEMSET\nINTERCEPTOR(void*, memset, void *dst, int v, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memset(dst, v, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memset, dst, v, size);\n  if (common_flags()->intercept_intrin)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n  return REAL(memset)(dst, v, size);\n}\n\n#define INIT_MEMSET COMMON_INTERCEPT_FUNCTION(memset)\n#else\n#define INIT_MEMSET\n#endif\n\n#if SANITIZER_INTERCEPT_MEMMOVE\nINTERCEPTOR(void*, memmove, void *dst, const void *src, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memmove(dst, src, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memmove, dst, src, size);\n  if (common_flags()->intercept_intrin) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);\n  }\n  return REAL(memmove)(dst, src, size);\n}\n\n#define INIT_MEMMOVE COMMON_INTERCEPT_FUNCTION(memmove)\n#else\n#define INIT_MEMMOVE\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCPY\nINTERCEPTOR(void*, memcpy, void *dst, const void *src, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED) {\n    // On OS X, calling internal_memcpy here will cause memory corruptions,\n    // because memcpy and memmove are actually aliases of the same\n    // implementation.  We need to use internal_memmove here.\n    return internal_memmove(dst, src, size);\n  }\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memcpy, dst, src, size);\n  if (common_flags()->intercept_intrin) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);\n  }\n  // N.B.: If we switch this to internal_ we'll have to use internal_memmove\n  // due to memcpy being an alias of memmove on OS X.\n  return REAL(memcpy)(dst, src, size);\n}\n\n#define INIT_MEMCPY COMMON_INTERCEPT_FUNCTION(memcpy)\n#else\n#define INIT_MEMCPY\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCMP\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, uptr called_pc,\n                              const void *s1, const void *s2, uptr n,\n                              int result)\n\nINTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memcmp(a1, a2, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memcmp, a1, a2, size);\n  if (common_flags()->intercept_memcmp) {\n    if (common_flags()->strict_memcmp) {\n      // Check the entire regions even if the first bytes of the buffers are\n      // different.\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, a1, size);\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, a2, size);\n      // Fallthrough to REAL(memcmp) below.\n    } else {\n      unsigned char c1 = 0, c2 = 0;\n      const unsigned char *s1 = (const unsigned char*)a1;\n      const unsigned char *s2 = (const unsigned char*)a2;\n      uptr i;\n      for (i = 0; i < size; i++) {\n        c1 = s1[i];\n        c2 = s2[i];\n        if (c1 != c2) break;\n      }\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, size));\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, size));\n      int r = CharCmpX(c1, c2);\n      CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, GET_CALLER_PC(),\n                                 a1, a2, size, r);\n      return r;\n    }\n  }\n  int result = REAL(memcmp(a1, a2, size));\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, GET_CALLER_PC(), a1,\n                             a2, size, result);\n  return result;\n}\n\n#define INIT_MEMCMP COMMON_INTERCEPT_FUNCTION(memcmp)\n#else\n#define INIT_MEMCMP\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCHR\nINTERCEPTOR(void*, memchr, const void *s, int c, SIZE_T n) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memchr(s, c, n);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memchr, s, c, n);\n#if SANITIZER_WINDOWS\n  void *res;\n  if (REAL(memchr)) {\n    res = REAL(memchr)(s, c, n);\n  } else {\n    res = internal_memchr(s, c, n);\n  }\n#else\n  void *res = REAL(memchr)(s, c, n);\n#endif\n  uptr len = res ? (char *)res - (const char *)s + 1 : n;\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, len);\n  return res;\n}\n\n#define INIT_MEMCHR COMMON_INTERCEPT_FUNCTION(memchr)\n#else\n#define INIT_MEMCHR\n#endif\n\n#if SANITIZER_INTERCEPT_MEMRCHR\nINTERCEPTOR(void*, memrchr, const void *s, int c, SIZE_T n) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memrchr, s, c, n);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, n);\n  return REAL(memrchr)(s, c, n);\n}\n\n#define INIT_MEMRCHR COMMON_INTERCEPT_FUNCTION(memrchr)\n#else\n#define INIT_MEMRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_FREXP\nINTERCEPTOR(double, frexp, double x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexp, x, exp);\n  // Assuming frexp() always writes to |exp|.\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  double res = REAL(frexp)(x, exp);\n  return res;\n}\n\n#define INIT_FREXP COMMON_INTERCEPT_FUNCTION(frexp);\n#else\n#define INIT_FREXP\n#endif  // SANITIZER_INTERCEPT_FREXP\n\n#if SANITIZER_INTERCEPT_FREXPF_FREXPL\nINTERCEPTOR(float, frexpf, float x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexpf, x, exp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(frexpf)(x, exp);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  return res;\n}\n\nINTERCEPTOR(long double, frexpl, long double x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexpl, x, exp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(frexpl)(x, exp);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  return res;\n}\n\n#define INIT_FREXPF_FREXPL           \\\n  COMMON_INTERCEPT_FUNCTION(frexpf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(frexpl)\n#else\n#define INIT_FREXPF_FREXPL\n#endif  // SANITIZER_INTERCEPT_FREXPF_FREXPL\n\n#if SI_NOT_WINDOWS\nstatic void write_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n                        SIZE_T iovlen, SIZE_T maxlen) {\n  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec[i].iov_base, sz);\n    maxlen -= sz;\n  }\n}\n\nstatic void read_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n                       SIZE_T iovlen, SIZE_T maxlen) {\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec) * iovlen);\n  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec[i].iov_base, sz);\n    maxlen -= sz;\n  }\n}\n#endif\n\n#if SANITIZER_INTERCEPT_READ\nINTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(read)(fd, ptr, count);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_READ COMMON_INTERCEPT_FUNCTION(read)\n#else\n#define INIT_READ\n#endif\n\n#if SANITIZER_INTERCEPT_PREAD\nINTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREAD COMMON_INTERCEPT_FUNCTION(pread)\n#else\n#define INIT_PREAD\n#endif\n\n#if SANITIZER_INTERCEPT_PREAD64\nINTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREAD64 COMMON_INTERCEPT_FUNCTION(pread64)\n#else\n#define INIT_PREAD64\n#endif\n\n#if SANITIZER_INTERCEPT_READV\nINTERCEPTOR_WITH_SUFFIX(SSIZE_T, readv, int fd, __sanitizer_iovec *iov,\n                        int iovcnt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readv, fd, iov, iovcnt);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(readv)(fd, iov, iovcnt);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_READV COMMON_INTERCEPT_FUNCTION(readv)\n#else\n#define INIT_READV\n#endif\n\n#if SANITIZER_INTERCEPT_PREADV\nINTERCEPTOR(SSIZE_T, preadv, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, preadv, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(preadv)(fd, iov, iovcnt, offset);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREADV COMMON_INTERCEPT_FUNCTION(preadv)\n#else\n#define INIT_PREADV\n#endif\n\n#if SANITIZER_INTERCEPT_PREADV64\nINTERCEPTOR(SSIZE_T, preadv64, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, preadv64, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(preadv64)(fd, iov, iovcnt, offset);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREADV64 COMMON_INTERCEPT_FUNCTION(preadv64)\n#else\n#define INIT_PREADV64\n#endif\n\n#if SANITIZER_INTERCEPT_WRITE\nINTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(write)(fd, ptr, count);\n  // FIXME: this check should be _before_ the call to REAL(write), not after\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_WRITE COMMON_INTERCEPT_FUNCTION(write)\n#else\n#define INIT_WRITE\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITE\nINTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwrite)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_PWRITE COMMON_INTERCEPT_FUNCTION(pwrite)\n#else\n#define INIT_PWRITE\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITE64\nINTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwrite64)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_PWRITE64 COMMON_INTERCEPT_FUNCTION(pwrite64)\n#else\n#define INIT_PWRITE64\n#endif\n\n#if SANITIZER_INTERCEPT_WRITEV\nINTERCEPTOR_WITH_SUFFIX(SSIZE_T, writev, int fd, __sanitizer_iovec *iov,\n                        int iovcnt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, writev, fd, iov, iovcnt);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(writev)(fd, iov, iovcnt);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_WRITEV COMMON_INTERCEPT_FUNCTION(writev)\n#else\n#define INIT_WRITEV\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITEV\nINTERCEPTOR(SSIZE_T, pwritev, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwritev, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwritev)(fd, iov, iovcnt, offset);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_PWRITEV COMMON_INTERCEPT_FUNCTION(pwritev)\n#else\n#define INIT_PWRITEV\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITEV64\nINTERCEPTOR(SSIZE_T, pwritev64, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwritev64, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwritev64)(fd, iov, iovcnt, offset);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_PWRITEV64 COMMON_INTERCEPT_FUNCTION(pwritev64)\n#else\n#define INIT_PWRITEV64\n#endif\n\n#if SANITIZER_INTERCEPT_PRCTL\nINTERCEPTOR(int, prctl, int option, unsigned long arg2,\n            unsigned long arg3,                        // NOLINT\n            unsigned long arg4, unsigned long arg5) {  // NOLINT\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n  static const int PR_SET_NAME = 15;\n  int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n  if (option == PR_SET_NAME) {\n    char buff[16];\n    internal_strncpy(buff, (char *)arg2, 15);\n    buff[15] = 0;\n    COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, buff);\n  }\n  return res;\n}\n#define INIT_PRCTL COMMON_INTERCEPT_FUNCTION(prctl)\n#else\n#define INIT_PRCTL\n#endif  // SANITIZER_INTERCEPT_PRCTL\n\n#if SANITIZER_INTERCEPT_TIME\nINTERCEPTOR(unsigned long, time, unsigned long *t) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, time, t);\n  unsigned long local_t;\n  unsigned long res = REAL(time)(&local_t);\n  if (t && res != (unsigned long)-1) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, t, sizeof(*t));\n    *t = local_t;\n  }\n  return res;\n}\n#define INIT_TIME COMMON_INTERCEPT_FUNCTION(time);\n#else\n#define INIT_TIME\n#endif  // SANITIZER_INTERCEPT_TIME\n\n#if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\nstatic void unpoison_tm(void *ctx, __sanitizer_tm *tm) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n  if (tm->tm_zone) {\n    // Can not use COMMON_INTERCEPTOR_WRITE_RANGE here, because tm->tm_zone\n    // can point to shared memory and tsan would report a data race.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(tm->tm_zone,\n                                        REAL(strlen(tm->tm_zone)) + 1);\n  }\n}\nINTERCEPTOR(__sanitizer_tm *, localtime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, localtime, timep);\n  __sanitizer_tm *res = REAL(localtime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, localtime_r, unsigned long *timep, void *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, localtime_r, timep, result);\n  __sanitizer_tm *res = REAL(localtime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, gmtime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gmtime, timep);\n  __sanitizer_tm *res = REAL(gmtime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, gmtime_r, unsigned long *timep, void *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gmtime_r, timep, result);\n  __sanitizer_tm *res = REAL(gmtime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(char *, ctime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctime, timep);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ctime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctime_r, timep, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ctime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, asctime, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asctime, tm);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(asctime)(tm);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asctime_r, tm, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(asctime_r)(tm, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(long, mktime, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mktime, tm);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_sec, sizeof(tm->tm_sec));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_min, sizeof(tm->tm_min));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_hour, sizeof(tm->tm_hour));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mday, sizeof(tm->tm_mday));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mon, sizeof(tm->tm_mon));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_year, sizeof(tm->tm_year));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_isdst, sizeof(tm->tm_isdst));\n  long res = REAL(mktime)(tm);\n  if (res != -1) unpoison_tm(ctx, tm);\n  return res;\n}\n#define INIT_LOCALTIME_AND_FRIENDS        \\\n  COMMON_INTERCEPT_FUNCTION(localtime);   \\\n  COMMON_INTERCEPT_FUNCTION(localtime_r); \\\n  COMMON_INTERCEPT_FUNCTION(gmtime);      \\\n  COMMON_INTERCEPT_FUNCTION(gmtime_r);    \\\n  COMMON_INTERCEPT_FUNCTION(ctime);       \\\n  COMMON_INTERCEPT_FUNCTION(ctime_r);     \\\n  COMMON_INTERCEPT_FUNCTION(asctime);     \\\n  COMMON_INTERCEPT_FUNCTION(asctime_r);   \\\n  COMMON_INTERCEPT_FUNCTION(mktime);\n#else\n#define INIT_LOCALTIME_AND_FRIENDS\n#endif  // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n\n#if SANITIZER_INTERCEPT_STRPTIME\nINTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strptime, s, format, tm);\n  if (format)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, format, REAL(strlen)(format) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(strptime)(s, format, tm);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s, res ? res - s : 0);\n  if (res && tm) {\n    // Do not call unpoison_tm here, because strptime does not, in fact,\n    // initialize the entire struct tm. For example, tm_zone pointer is left\n    // uninitialized.\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n  }\n  return res;\n}\n#define INIT_STRPTIME COMMON_INTERCEPT_FUNCTION(strptime);\n#else\n#define INIT_STRPTIME\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF || SANITIZER_INTERCEPT_PRINTF\n#include \"sanitizer_common_interceptors_format.inc\"\n\n#define FORMAT_INTERCEPTOR_IMPL(name, vname, ...)                              \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    va_list ap;                                                                \\\n    va_start(ap, format);                                                      \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__, ap);                     \\\n    int res = WRAP(vname)(__VA_ARGS__, ap);                                    \\\n    va_end(ap);                                                                \\\n    return res;                                                                \\\n  }\n\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF\n\n#define VSCANF_INTERCEPTOR_IMPL(vname, allowGnuMalloc, ...)                    \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                         \\\n    va_list aq;                                                                \\\n    va_copy(aq, ap);                                                           \\\n    int res = REAL(vname)(__VA_ARGS__);                                        \\\n    if (res > 0)                                                               \\\n      scanf_common(ctx, res, allowGnuMalloc, format, aq);                      \\\n    va_end(aq);                                                                \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(int, vscanf, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vscanf, true, format, ap)\n\nINTERCEPTOR(int, vsscanf, const char *str, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vsscanf, true, str, format, ap)\n\nINTERCEPTOR(int, vfscanf, void *stream, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vfscanf, true, stream, format, ap)\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\nINTERCEPTOR(int, __isoc99_vscanf, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vscanf, false, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsscanf, const char *str, const char *format,\n            va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vsscanf, false, str, format, ap)\n\nINTERCEPTOR(int, __isoc99_vfscanf, void *stream, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n#endif  // SANITIZER_INTERCEPT_ISOC99_SCANF\n\nINTERCEPTOR(int, scanf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(scanf, vscanf, format)\n\nINTERCEPTOR(int, fscanf, void *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n\nINTERCEPTOR(int, sscanf, const char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\nINTERCEPTOR(int, __isoc99_scanf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n\nINTERCEPTOR(int, __isoc99_fscanf, void *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n\nINTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n#endif\n\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF\n#define INIT_SCANF                    \\\n  COMMON_INTERCEPT_FUNCTION(scanf);   \\\n  COMMON_INTERCEPT_FUNCTION(sscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(fscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(vscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(vsscanf); \\\n  COMMON_INTERCEPT_FUNCTION(vfscanf);\n#else\n#define INIT_SCANF\n#endif\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\n#define INIT_ISOC99_SCANF                      \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_scanf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_sscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_fscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsscanf); \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vfscanf);\n#else\n#define INIT_ISOC99_SCANF\n#endif\n\n#if SANITIZER_INTERCEPT_PRINTF\n\n#define VPRINTF_INTERCEPTOR_ENTER(vname, ...)                                  \\\n  void *ctx;                                                                   \\\n  COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                           \\\n  va_list aq;                                                                  \\\n  va_copy(aq, ap);\n\n#define VPRINTF_INTERCEPTOR_RETURN()                                           \\\n  va_end(aq);\n\n#define VPRINTF_INTERCEPTOR_IMPL(vname, ...)                                   \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, __VA_ARGS__);                             \\\n    if (common_flags()->check_printf)                                          \\\n      printf_common(ctx, format, aq);                                          \\\n    int res = REAL(vname)(__VA_ARGS__);                                        \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VSPRINTF_INTERCEPTOR_IMPL(vname, str, ...)                             \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, str, __VA_ARGS__)                         \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(str, __VA_ARGS__);                                   \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, res + 1);                       \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VSNPRINTF_INTERCEPTOR_IMPL(vname, str, size, ...)                      \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, str, size, __VA_ARGS__)                   \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(str, size, __VA_ARGS__);                             \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, Min(size, (SIZE_T)(res + 1)));  \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VASPRINTF_INTERCEPTOR_IMPL(vname, strp, ...)                           \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, strp, __VA_ARGS__)                        \\\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, strp, sizeof(char *));                 \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(strp, __VA_ARGS__);                                  \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *strp, res + 1);                     \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(int, vprintf, const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(vprintf, format, ap)\n\nINTERCEPTOR(int, vfprintf, __sanitizer_FILE *stream, const char *format,\n            va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(vfprintf, stream, format, ap)\n\nINTERCEPTOR(int, vsnprintf, char *str, SIZE_T size, const char *format,\n            va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n\n#if SANITIZER_INTERCEPT_PRINTF_L\nINTERCEPTOR(int, vsnprintf_l, char *str, SIZE_T size, void *loc,\n            const char *format, va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(vsnprintf_l, str, size, loc, format, ap)\n\nINTERCEPTOR(int, snprintf_l, char *str, SIZE_T size, void *loc,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(snprintf_l, vsnprintf_l, str, size, loc, format)\n#endif  // SANITIZER_INTERCEPT_PRINTF_L\n\nINTERCEPTOR(int, vsprintf, char *str, const char *format, va_list ap)\nVSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n\nINTERCEPTOR(int, vasprintf, char **strp, const char *format, va_list ap)\nVASPRINTF_INTERCEPTOR_IMPL(vasprintf, strp, format, ap)\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\nINTERCEPTOR(int, __isoc99_vprintf, const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(__isoc99_vprintf, format, ap)\n\nINTERCEPTOR(int, __isoc99_vfprintf, __sanitizer_FILE *stream,\n            const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(__isoc99_vfprintf, stream, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsnprintf, char *str, SIZE_T size, const char *format,\n            va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(__isoc99_vsnprintf, str, size, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsprintf, char *str, const char *format,\n            va_list ap)\nVSPRINTF_INTERCEPTOR_IMPL(__isoc99_vsprintf, str, format,\n                          ap)\n\n#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n\nINTERCEPTOR(int, printf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(printf, vprintf, format)\n\nINTERCEPTOR(int, fprintf, __sanitizer_FILE *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(fprintf, vfprintf, stream, format)\n\nINTERCEPTOR(int, sprintf, char *str, const char *format, ...) // NOLINT\nFORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format) // NOLINT\n\nINTERCEPTOR(int, snprintf, char *str, SIZE_T size, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(snprintf, vsnprintf, str, size, format)\n\nINTERCEPTOR(int, asprintf, char **strp, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(asprintf, vasprintf, strp, format)\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\nINTERCEPTOR(int, __isoc99_printf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_printf, __isoc99_vprintf, format)\n\nINTERCEPTOR(int, __isoc99_fprintf, __sanitizer_FILE *stream, const char *format,\n            ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_fprintf, __isoc99_vfprintf, stream, format)\n\nINTERCEPTOR(int, __isoc99_sprintf, char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_sprintf, __isoc99_vsprintf, str, format)\n\nINTERCEPTOR(int, __isoc99_snprintf, char *str, SIZE_T size,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n                        format)\n\n#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n\n#endif  // SANITIZER_INTERCEPT_PRINTF\n\n#if SANITIZER_INTERCEPT_PRINTF\n#define INIT_PRINTF                     \\\n  COMMON_INTERCEPT_FUNCTION(printf);    \\\n  COMMON_INTERCEPT_FUNCTION(sprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(snprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(asprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(fprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(vprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(vsprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(vsnprintf); \\\n  COMMON_INTERCEPT_FUNCTION(vasprintf); \\\n  COMMON_INTERCEPT_FUNCTION(vfprintf);\n#else\n#define INIT_PRINTF\n#endif\n\n#if SANITIZER_INTERCEPT_PRINTF_L\n#define INIT_PRINTF_L                     \\\n  COMMON_INTERCEPT_FUNCTION(snprintf_l);  \\\n  COMMON_INTERCEPT_FUNCTION(vsnprintf_l);\n#else\n#define INIT_PRINTF_L\n#endif\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\n#define INIT_ISOC99_PRINTF                       \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_printf);    \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_sprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_snprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_fprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsnprintf); \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vfprintf);\n#else\n#define INIT_ISOC99_PRINTF\n#endif\n\n#if SANITIZER_INTERCEPT_IOCTL\n#include \"sanitizer_common_interceptors_ioctl.inc\"\nINTERCEPTOR(int, ioctl, int d, unsigned long request, ...) {\n  // We need a frame pointer, because we call into ioctl_common_[pre|post] which\n  // can trigger a report and we need to be able to unwind through this\n  // function.  On Mac in debug mode we might not have a frame pointer, because\n  // ioctl_common_[pre|post] doesn't get inlined here.\n  ENABLE_FRAME_POINTER;\n\n  void *ctx;\n  va_list ap;\n  va_start(ap, request);\n  void *arg = va_arg(ap, void *);\n  va_end(ap);\n  COMMON_INTERCEPTOR_ENTER(ctx, ioctl, d, request, arg);\n\n  CHECK(ioctl_initialized);\n\n  // Note: TSan does not use common flags, and they are zero-initialized.\n  // This effectively disables ioctl handling in TSan.\n  if (!common_flags()->handle_ioctl) return REAL(ioctl)(d, request, arg);\n\n  // Although request is unsigned long, the rest of the interceptor uses it\n  // as just \"unsigned\" to save space, because we know that all values fit in\n  // \"unsigned\" - they are compile-time constants.\n\n  const ioctl_desc *desc = ioctl_lookup(request);\n  ioctl_desc decoded_desc;\n  if (!desc) {\n    VPrintf(2, \"Decoding unknown ioctl 0x%x\\n\", request);\n    if (!ioctl_decode(request, &decoded_desc))\n      Printf(\"WARNING: failed decoding unknown ioctl 0x%x\\n\", request);\n    else\n      desc = &decoded_desc;\n  }\n\n  if (desc) ioctl_common_pre(ctx, desc, d, request, arg);\n  int res = REAL(ioctl)(d, request, arg);\n  // FIXME: some ioctls have different return values for success and failure.\n  if (desc && res != -1) ioctl_common_post(ctx, desc, res, d, request, arg);\n  return res;\n}\n#define INIT_IOCTL \\\n  ioctl_init();    \\\n  COMMON_INTERCEPT_FUNCTION(ioctl);\n#else\n#define INIT_IOCTL\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS || \\\n    SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT || \\\n    SANITIZER_INTERCEPT_GETPWENT_R || SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\nstatic void unpoison_passwd(void *ctx, __sanitizer_passwd *pwd) {\n  if (pwd) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, sizeof(*pwd));\n    if (pwd->pw_name)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_name,\n                                          REAL(strlen)(pwd->pw_name) + 1);\n    if (pwd->pw_passwd)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_passwd,\n                                          REAL(strlen)(pwd->pw_passwd) + 1);\n#if !SANITIZER_ANDROID\n    if (pwd->pw_gecos)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_gecos,\n                                          REAL(strlen)(pwd->pw_gecos) + 1);\n#endif\n#if SANITIZER_MAC\n    if (pwd->pw_class)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_class,\n                                          REAL(strlen)(pwd->pw_class) + 1);\n#endif\n    if (pwd->pw_dir)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_dir,\n                                          REAL(strlen)(pwd->pw_dir) + 1);\n    if (pwd->pw_shell)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(pwd->pw_shell,\n                                          REAL(strlen)(pwd->pw_shell) + 1);\n  }\n}\n\nstatic void unpoison_group(void *ctx, __sanitizer_group *grp) {\n  if (grp) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, sizeof(*grp));\n    if (grp->gr_name)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_name,\n                                          REAL(strlen)(grp->gr_name) + 1);\n    if (grp->gr_passwd)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_passwd,\n                                          REAL(strlen)(grp->gr_passwd) + 1);\n    char **p = grp->gr_mem;\n    for (; *p; ++p) {\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(*p, REAL(strlen)(*p) + 1);\n    }\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(grp->gr_mem,\n                                        (p - grp->gr_mem + 1) * sizeof(*p));\n  }\n}\n#endif  // SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS ||\n        // SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT ||\n        // SANITIZER_INTERCEPT_GETPWENT_R ||\n        // SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n\n#if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\nINTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  __sanitizer_passwd *res = REAL(getpwnam)(name);\n  if (res) unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_passwd *, getpwuid, u32 uid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n  __sanitizer_passwd *res = REAL(getpwuid)(uid);\n  if (res) unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrnam, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  __sanitizer_group *res = REAL(getgrnam)(name);\n  if (res) unpoison_group(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrgid, u32 gid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n  __sanitizer_group *res = REAL(getgrgid)(gid);\n  if (res) unpoison_group(ctx, res);\n  return res;\n}\n#define INIT_GETPWNAM_AND_FRIENDS      \\\n  COMMON_INTERCEPT_FUNCTION(getpwnam); \\\n  COMMON_INTERCEPT_FUNCTION(getpwuid); \\\n  COMMON_INTERCEPT_FUNCTION(getgrnam); \\\n  COMMON_INTERCEPT_FUNCTION(getgrgid);\n#else\n#define INIT_GETPWNAM_AND_FRIENDS\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\nINTERCEPTOR(int, getpwnam_r, const char *name, __sanitizer_passwd *pwd,\n            char *buf, SIZE_T buflen, __sanitizer_passwd **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwnam_r)(name, pwd, buf, buflen, result);\n  if (!res) {\n    if (result && *result) unpoison_passwd(ctx, *result);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getpwuid_r, u32 uid, __sanitizer_passwd *pwd, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n  if (!res) {\n    if (result && *result) unpoison_passwd(ctx, *result);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getgrnam_r, const char *name, __sanitizer_group *grp,\n            char *buf, SIZE_T buflen, __sanitizer_group **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrnam_r)(name, grp, buf, buflen, result);\n  if (!res) {\n    if (result && *result) unpoison_group(ctx, *result);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getgrgid_r, u32 gid, __sanitizer_group *grp, char *buf,\n            SIZE_T buflen, __sanitizer_group **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n  if (!res) {\n    if (result && *result) unpoison_group(ctx, *result);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_GETPWNAM_R_AND_FRIENDS      \\\n  COMMON_INTERCEPT_FUNCTION(getpwnam_r); \\\n  COMMON_INTERCEPT_FUNCTION(getpwuid_r); \\\n  COMMON_INTERCEPT_FUNCTION(getgrnam_r); \\\n  COMMON_INTERCEPT_FUNCTION(getgrgid_r);\n#else\n#define INIT_GETPWNAM_R_AND_FRIENDS\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWENT\nINTERCEPTOR(__sanitizer_passwd *, getpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwent, dummy);\n  __sanitizer_passwd *res = REAL(getpwent)(dummy);\n  if (res) unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrent, dummy);\n  __sanitizer_group *res = REAL(getgrent)(dummy);\n  if (res) unpoison_group(ctx, res);;\n  return res;\n}\n#define INIT_GETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(getpwent); \\\n  COMMON_INTERCEPT_FUNCTION(getgrent);\n#else\n#define INIT_GETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_FGETPWENT\nINTERCEPTOR(__sanitizer_passwd *, fgetpwent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent, fp);\n  __sanitizer_passwd *res = REAL(fgetpwent)(fp);\n  if (res) unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, fgetgrent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent, fp);\n  __sanitizer_group *res = REAL(fgetgrent)(fp);\n  if (res) unpoison_group(ctx, res);\n  return res;\n}\n#define INIT_FGETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(fgetpwent); \\\n  COMMON_INTERCEPT_FUNCTION(fgetgrent);\n#else\n#define INIT_FGETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWENT_R\nINTERCEPTOR(int, getpwent_r, __sanitizer_passwd *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwent_r, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwent_r)(pwbuf, buf, buflen, pwbufp);\n  if (!res) {\n    if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\nINTERCEPTOR(int, fgetpwent_r, void *fp, __sanitizer_passwd *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent_r, fp, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fgetpwent_r)(fp, pwbuf, buf, buflen, pwbufp);\n  if (!res) {\n    if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\nINTERCEPTOR(int, getgrent_r, __sanitizer_group *pwbuf, char *buf, SIZE_T buflen,\n            __sanitizer_group **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrent_r, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrent_r)(pwbuf, buf, buflen, pwbufp);\n  if (!res) {\n    if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\nINTERCEPTOR(int, fgetgrent_r, void *fp, __sanitizer_group *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_group **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent_r, fp, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fgetgrent_r)(fp, pwbuf, buf, buflen, pwbufp);\n  if (!res) {\n    if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\n#define INIT_GETPWENT_R                   \\\n  COMMON_INTERCEPT_FUNCTION(getpwent_r);  \\\n  COMMON_INTERCEPT_FUNCTION(fgetpwent_r); \\\n  COMMON_INTERCEPT_FUNCTION(getgrent_r);  \\\n  COMMON_INTERCEPT_FUNCTION(fgetgrent_r);\n#else\n#define INIT_GETPWENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_SETPWENT\n// The only thing these interceptors do is disable any nested interceptors.\n// These functions may open nss modules and call uninstrumented functions from\n// them, and we don't want things like strlen() to trigger.\nINTERCEPTOR(void, setpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setpwent, dummy);\n  REAL(setpwent)(dummy);\n}\nINTERCEPTOR(void, endpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, endpwent, dummy);\n  REAL(endpwent)(dummy);\n}\nINTERCEPTOR(void, setgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setgrent, dummy);\n  REAL(setgrent)(dummy);\n}\nINTERCEPTOR(void, endgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, endgrent, dummy);\n  REAL(endgrent)(dummy);\n}\n#define INIT_SETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(setpwent); \\\n  COMMON_INTERCEPT_FUNCTION(endpwent); \\\n  COMMON_INTERCEPT_FUNCTION(setgrent); \\\n  COMMON_INTERCEPT_FUNCTION(endgrent);\n#else\n#define INIT_SETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_CLOCK_GETTIME\nINTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_getres, clk_id, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(clock_getres)(clk_id, tp);\n  if (!res && tp) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_gettime, clk_id, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(clock_gettime)(clk_id, tp);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_settime, clk_id, tp);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, tp, struct_timespec_sz);\n  return REAL(clock_settime)(clk_id, tp);\n}\n#define INIT_CLOCK_GETTIME                  \\\n  COMMON_INTERCEPT_FUNCTION(clock_getres);  \\\n  COMMON_INTERCEPT_FUNCTION(clock_gettime); \\\n  COMMON_INTERCEPT_FUNCTION(clock_settime);\n#else\n#define INIT_CLOCK_GETTIME\n#endif\n\n#if SANITIZER_INTERCEPT_GETITIMER\nINTERCEPTOR(int, getitimer, int which, void *curr_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getitimer, which, curr_value);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getitimer)(which, curr_value);\n  if (!res && curr_value) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerval_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setitimer, which, new_value, old_value);\n  if (new_value)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerval_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(setitimer)(which, new_value, old_value);\n  if (!res && old_value) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerval_sz);\n  }\n  return res;\n}\n#define INIT_GETITIMER                  \\\n  COMMON_INTERCEPT_FUNCTION(getitimer); \\\n  COMMON_INTERCEPT_FUNCTION(setitimer);\n#else\n#define INIT_GETITIMER\n#endif\n\n#if SANITIZER_INTERCEPT_GLOB\nstatic void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pglob, sizeof(*pglob));\n  // +1 for NULL pointer at the end.\n  if (pglob->gl_pathv)\n    COMMON_INTERCEPTOR_WRITE_RANGE(\n        ctx, pglob->gl_pathv, (pglob->gl_pathc + 1) * sizeof(*pglob->gl_pathv));\n  for (SIZE_T i = 0; i < pglob->gl_pathc; ++i) {\n    char *p = pglob->gl_pathv[i];\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, REAL(strlen)(p) + 1);\n  }\n}\n\nstatic THREADLOCAL __sanitizer_glob_t *pglob_copy;\n\nstatic void wrapped_gl_closedir(void *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  pglob_copy->gl_closedir(dir);\n}\n\nstatic void *wrapped_gl_readdir(void *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  return pglob_copy->gl_readdir(dir);\n}\n\nstatic void *wrapped_gl_opendir(const char *s) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_opendir(s);\n}\n\nstatic int wrapped_gl_lstat(const char *s, void *st) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_lstat(s, st);\n}\n\nstatic int wrapped_gl_stat(const char *s, void *st) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_stat(s, st);\n}\n\nstatic const __sanitizer_glob_t kGlobCopy = {\n      0,                  0,                   0,\n      0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n      wrapped_gl_opendir, wrapped_gl_lstat,    wrapped_gl_stat};\n\nINTERCEPTOR(int, glob, const char *pattern, int flags,\n            int (*errfunc)(const char *epath, int eerrno),\n            __sanitizer_glob_t *pglob) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n  __sanitizer_glob_t glob_copy;\n  internal_memcpy(&glob_copy, &kGlobCopy, sizeof(glob_copy));\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n    pglob_copy = &glob_copy;\n  }\n  int res = REAL(glob)(pattern, flags, errfunc, pglob);\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n  }\n  pglob_copy = 0;\n  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n  return res;\n}\n\nINTERCEPTOR(int, glob64, const char *pattern, int flags,\n            int (*errfunc)(const char *epath, int eerrno),\n            __sanitizer_glob_t *pglob) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, glob64, pattern, flags, errfunc, pglob);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n  __sanitizer_glob_t glob_copy;\n  internal_memcpy(&glob_copy, &kGlobCopy, sizeof(glob_copy));\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n    pglob_copy = &glob_copy;\n  }\n  int res = REAL(glob64)(pattern, flags, errfunc, pglob);\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n  }\n  pglob_copy = 0;\n  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n  return res;\n}\n#define INIT_GLOB                  \\\n  COMMON_INTERCEPT_FUNCTION(glob); \\\n  COMMON_INTERCEPT_FUNCTION(glob64);\n#else  // SANITIZER_INTERCEPT_GLOB\n#define INIT_GLOB\n#endif  // SANITIZER_INTERCEPT_GLOB\n\n#if SANITIZER_INTERCEPT_WAIT\n// According to sys/wait.h, wait(), waitid(), waitpid() may have symbol version\n// suffixes on Darwin. See the declaration of INTERCEPTOR_WITH_SUFFIX for\n// details.\nINTERCEPTOR_WITH_SUFFIX(int, wait, int *status) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait, status);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait)(status);\n  if (res != -1 && status)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n  return res;\n}\n// On FreeBSD id_t is always 64-bit wide.\n#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\nINTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, long long id, void *infop,\n                        int options) {\n#else\nINTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n                        int options) {\n#endif\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, waitid, idtype, id, infop, options);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(waitid)(idtype, id, infop, options);\n  if (res != -1 && infop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, infop, siginfo_t_sz);\n  return res;\n}\nINTERCEPTOR_WITH_SUFFIX(int, waitpid, int pid, int *status, int options) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, waitpid, pid, status, options);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(waitpid)(pid, status, options);\n  if (res != -1 && status)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n  return res;\n}\nINTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait3, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait3)(status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#if SANITIZER_ANDROID\nINTERCEPTOR(int, __wait4, int pid, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wait4, pid, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(__wait4)(pid, status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(__wait4);\n#else\nINTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait4)(pid, status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(wait4);\n#endif  // SANITIZER_ANDROID\n#define INIT_WAIT                     \\\n  COMMON_INTERCEPT_FUNCTION(wait);    \\\n  COMMON_INTERCEPT_FUNCTION(waitid);  \\\n  COMMON_INTERCEPT_FUNCTION(waitpid); \\\n  COMMON_INTERCEPT_FUNCTION(wait3);\n#else\n#define INIT_WAIT\n#define INIT_WAIT4\n#endif\n\n#if SANITIZER_INTERCEPT_INET\nINTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_ntop, af, src, dst, size);\n  uptr sz = __sanitizer_in_addr_sz(af);\n  if (sz) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sz);\n  // FIXME: figure out read size based on the address family.\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(inet_ntop)(af, src, dst, size);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_pton, af, src, dst);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, src, 0);\n  // FIXME: figure out read size based on the address family.\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(inet_pton)(af, src, dst);\n  if (res == 1) {\n    uptr sz = __sanitizer_in_addr_sz(af);\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n  }\n  return res;\n}\n#define INIT_INET                       \\\n  COMMON_INTERCEPT_FUNCTION(inet_ntop); \\\n  COMMON_INTERCEPT_FUNCTION(inet_pton);\n#else\n#define INIT_INET\n#endif\n\n#if SANITIZER_INTERCEPT_INET\nINTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_aton, cp, dst);\n  if (cp) COMMON_INTERCEPTOR_READ_RANGE(ctx, cp, REAL(strlen)(cp) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(inet_aton)(cp, dst);\n  if (res != 0) {\n    uptr sz = __sanitizer_in_addr_sz(af_inet);\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n  }\n  return res;\n}\n#define INIT_INET_ATON COMMON_INTERCEPT_FUNCTION(inet_aton);\n#else\n#define INIT_INET_ATON\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM\nINTERCEPTOR(int, pthread_getschedparam, uptr thread, int *policy, int *param) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getschedparam, thread, policy, param);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_getschedparam)(thread, policy, param);\n  if (res == 0) {\n    if (policy) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, policy, sizeof(*policy));\n    if (param) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, sizeof(*param));\n  }\n  return res;\n}\n#define INIT_PTHREAD_GETSCHEDPARAM \\\n  COMMON_INTERCEPT_FUNCTION(pthread_getschedparam);\n#else\n#define INIT_PTHREAD_GETSCHEDPARAM\n#endif\n\n#if SANITIZER_INTERCEPT_GETADDRINFO\nINTERCEPTOR(int, getaddrinfo, char *node, char *service,\n            struct __sanitizer_addrinfo *hints,\n            struct __sanitizer_addrinfo **out) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getaddrinfo, node, service, hints, out);\n  if (node) COMMON_INTERCEPTOR_READ_RANGE(ctx, node, REAL(strlen)(node) + 1);\n  if (service)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, service, REAL(strlen)(service) + 1);\n  if (hints)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hints, sizeof(__sanitizer_addrinfo));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getaddrinfo)(node, service, hints, out);\n  if (res == 0 && out) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, out, sizeof(*out));\n    struct __sanitizer_addrinfo *p = *out;\n    while (p) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n      if (p->ai_addr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_addr, p->ai_addrlen);\n      if (p->ai_canonname)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_canonname,\n                                       REAL(strlen)(p->ai_canonname) + 1);\n      p = p->ai_next;\n    }\n  }\n  return res;\n}\n#define INIT_GETADDRINFO COMMON_INTERCEPT_FUNCTION(getaddrinfo);\n#else\n#define INIT_GETADDRINFO\n#endif\n\n#if SANITIZER_INTERCEPT_GETNAMEINFO\nINTERCEPTOR(int, getnameinfo, void *sockaddr, unsigned salen, char *host,\n            unsigned hostlen, char *serv, unsigned servlen, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getnameinfo, sockaddr, salen, host, hostlen,\n                           serv, servlen, flags);\n  // FIXME: consider adding READ_RANGE(sockaddr, salen)\n  // There is padding in in_addr that may make this too noisy\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(getnameinfo)(sockaddr, salen, host, hostlen, serv, servlen, flags);\n  if (res == 0) {\n    if (host && hostlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, host, REAL(strlen)(host) + 1);\n    if (serv && servlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, serv, REAL(strlen)(serv) + 1);\n  }\n  return res;\n}\n#define INIT_GETNAMEINFO COMMON_INTERCEPT_FUNCTION(getnameinfo);\n#else\n#define INIT_GETNAMEINFO\n#endif\n\n#if SANITIZER_INTERCEPT_GETSOCKNAME\nINTERCEPTOR(int, getsockname, int sock_fd, void *addr, int *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getsockname, sock_fd, addr, addrlen);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n  int addrlen_in = *addrlen;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getsockname)(sock_fd, addr, addrlen);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addrlen_in, *addrlen));\n  }\n  return res;\n}\n#define INIT_GETSOCKNAME COMMON_INTERCEPT_FUNCTION(getsockname);\n#else\n#define INIT_GETSOCKNAME\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME || SANITIZER_INTERCEPT_GETHOSTBYNAME_R\nstatic void write_hostent(void *ctx, struct __sanitizer_hostent *h) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h, sizeof(__sanitizer_hostent));\n  if (h->h_name)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h->h_name, REAL(strlen)(h->h_name) + 1);\n  char **p = h->h_aliases;\n  while (*p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n    ++p;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(\n      ctx, h->h_aliases, (p - h->h_aliases + 1) * sizeof(*h->h_aliases));\n  p = h->h_addr_list;\n  while (*p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, h->h_length);\n    ++p;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(\n      ctx, h->h_addr_list, (p - h->h_addr_list + 1) * sizeof(*h->h_addr_list));\n}\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyname, char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname, name);\n  struct __sanitizer_hostent *res = REAL(gethostbyname)(name);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyaddr, void *addr, int len,\n            int type) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr, addr, len, type);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n  struct __sanitizer_hostent *res = REAL(gethostbyaddr)(addr, len, type);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n\nINTERCEPTOR(struct __sanitizer_hostent *, gethostent, int fake) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostent, fake);\n  struct __sanitizer_hostent *res = REAL(gethostent)(fake);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2, name, af);\n  struct __sanitizer_hostent *res = REAL(gethostbyname2)(name, af);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n#define INIT_GETHOSTBYNAME                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostent);    \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyaddr); \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyname); \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyname2);\n#else\n#define INIT_GETHOSTBYNAME\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME_R\nINTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n            char *buf, SIZE_T buflen, __sanitizer_hostent **result,\n            int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n                           h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYNAME_R COMMON_INTERCEPT_FUNCTION(gethostbyname_r);\n#else\n#define INIT_GETHOSTBYNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTENT_R\nINTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n            SIZE_T buflen, __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostent_r, ret, buf, buflen, result,\n                           h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostent_r)(ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTENT_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostent_r);\n#else\n#define INIT_GETHOSTENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYADDR_R\nINTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n            __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr_r, addr, len, type, ret, buf,\n                           buflen, result, h_errnop);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostbyaddr_r)(addr, len, type, ret, buf, buflen, result,\n                                  h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYADDR_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyaddr_r);\n#else\n#define INIT_GETHOSTBYADDR_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME2_R\nINTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n            __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2_r, name, af, ret, buf, buflen,\n                           result, h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(gethostbyname2_r)(name, af, ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYNAME2_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyname2_r);\n#else\n#define INIT_GETHOSTBYNAME2_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETSOCKOPT\nINTERCEPTOR(int, getsockopt, int sockfd, int level, int optname, void *optval,\n            int *optlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getsockopt, sockfd, level, optname, optval,\n                           optlen);\n  if (optlen) COMMON_INTERCEPTOR_READ_RANGE(ctx, optlen, sizeof(*optlen));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getsockopt)(sockfd, level, optname, optval, optlen);\n  if (res == 0)\n    if (optval && optlen) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, optval, *optlen);\n  return res;\n}\n#define INIT_GETSOCKOPT COMMON_INTERCEPT_FUNCTION(getsockopt);\n#else\n#define INIT_GETSOCKOPT\n#endif\n\n#if SANITIZER_INTERCEPT_ACCEPT\nINTERCEPTOR(int, accept, int fd, void *addr, unsigned *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, accept, fd, addr, addrlen);\n  unsigned addrlen0 = 0;\n  if (addrlen) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n    addrlen0 = *addrlen;\n  }\n  int fd2 = REAL(accept)(fd, addr, addrlen);\n  if (fd2 >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n    if (addr && addrlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n  }\n  return fd2;\n}\n#define INIT_ACCEPT COMMON_INTERCEPT_FUNCTION(accept);\n#else\n#define INIT_ACCEPT\n#endif\n\n#if SANITIZER_INTERCEPT_ACCEPT4\nINTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, accept4, fd, addr, addrlen, f);\n  unsigned addrlen0 = 0;\n  if (addrlen) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n    addrlen0 = *addrlen;\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int fd2 = REAL(accept4)(fd, addr, addrlen, f);\n  if (fd2 >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n    if (addr && addrlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n  }\n  return fd2;\n}\n#define INIT_ACCEPT4 COMMON_INTERCEPT_FUNCTION(accept4);\n#else\n#define INIT_ACCEPT4\n#endif\n\n#if SANITIZER_INTERCEPT_MODF\nINTERCEPTOR(double, modf, double x, double *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modf, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(modf)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\nINTERCEPTOR(float, modff, float x, float *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modff, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(modff)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\nINTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modfl, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(modfl)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\n#define INIT_MODF                   \\\n  COMMON_INTERCEPT_FUNCTION(modf);  \\\n  COMMON_INTERCEPT_FUNCTION(modff); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(modfl);\n#else\n#define INIT_MODF\n#endif\n\n#if SANITIZER_INTERCEPT_RECVMSG\nstatic void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                         SSIZE_T maxlen) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg, sizeof(*msg));\n  if (msg->msg_name && msg->msg_namelen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_name, msg->msg_namelen);\n  if (msg->msg_iov && msg->msg_iovlen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_iov,\n                                   sizeof(*msg->msg_iov) * msg->msg_iovlen);\n  write_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n  if (msg->msg_control && msg->msg_controllen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_control, msg->msg_controllen);\n}\n\nINTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n            int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recvmsg, fd, msg, flags);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(recvmsg)(fd, msg, flags);\n  if (res >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n    if (msg) {\n      write_msghdr(ctx, msg, res);\n      COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg);\n    }\n  }\n  return res;\n}\n#define INIT_RECVMSG COMMON_INTERCEPT_FUNCTION(recvmsg);\n#else\n#define INIT_RECVMSG\n#endif\n\n#if SANITIZER_INTERCEPT_SENDMSG\nstatic void read_msghdr_control(void *ctx, void *control, uptr controllen) {\n  const unsigned kCmsgDataOffset =\n      RoundUpTo(sizeof(__sanitizer_cmsghdr), sizeof(uptr));\n\n  char *p = (char *)control;\n  char *const control_end = p + controllen;\n  while (true) {\n    if (p + sizeof(__sanitizer_cmsghdr) > control_end) break;\n    __sanitizer_cmsghdr *cmsg = (__sanitizer_cmsghdr *)p;\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_len, sizeof(cmsg->cmsg_len));\n\n    if (p + RoundUpTo(cmsg->cmsg_len, sizeof(uptr)) > control_end) break;\n\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_level,\n                                  sizeof(cmsg->cmsg_level));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_type,\n                                  sizeof(cmsg->cmsg_type));\n\n    if (cmsg->cmsg_len > kCmsgDataOffset) {\n      char *data = p + kCmsgDataOffset;\n      unsigned data_len = cmsg->cmsg_len - kCmsgDataOffset;\n      if (data_len > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, data, data_len);\n    }\n\n    p += RoundUpTo(cmsg->cmsg_len, sizeof(uptr));\n  }\n}\n\nstatic void read_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                        SSIZE_T maxlen) {\n#define R(f) \\\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &msg->msg_##f, sizeof(msg->msg_##f))\n  R(name);\n  R(namelen);\n  R(iov);\n  R(iovlen);\n  R(control);\n  R(controllen);\n  R(flags);\n#undef R\n  if (msg->msg_name && msg->msg_namelen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, msg->msg_name, msg->msg_namelen);\n  if (msg->msg_iov && msg->msg_iovlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, msg->msg_iov,\n                                  sizeof(*msg->msg_iov) * msg->msg_iovlen);\n  read_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n  if (msg->msg_control && msg->msg_controllen)\n    read_msghdr_control(ctx, msg->msg_control, msg->msg_controllen);\n}\n\nINTERCEPTOR(SSIZE_T, sendmsg, int fd, struct __sanitizer_msghdr *msg,\n            int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sendmsg, fd, msg, flags);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  SSIZE_T res = REAL(sendmsg)(fd, msg, flags);\n  if (common_flags()->intercept_send && res >= 0 && msg)\n    read_msghdr(ctx, msg, res);\n  return res;\n}\n#define INIT_SENDMSG COMMON_INTERCEPT_FUNCTION(sendmsg);\n#else\n#define INIT_SENDMSG\n#endif\n\n#if SANITIZER_INTERCEPT_GETPEERNAME\nINTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpeername, sockfd, addr, addrlen);\n  unsigned addr_sz;\n  if (addrlen) addr_sz = *addrlen;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpeername)(sockfd, addr, addrlen);\n  if (!res && addr && addrlen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addr_sz, *addrlen));\n  return res;\n}\n#define INIT_GETPEERNAME COMMON_INTERCEPT_FUNCTION(getpeername);\n#else\n#define INIT_GETPEERNAME\n#endif\n\n#if SANITIZER_INTERCEPT_SYSINFO\nINTERCEPTOR(int, sysinfo, void *info) {\n  void *ctx;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  COMMON_INTERCEPTOR_ENTER(ctx, sysinfo, info);\n  int res = REAL(sysinfo)(info);\n  if (!res && info)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, struct_sysinfo_sz);\n  return res;\n}\n#define INIT_SYSINFO COMMON_INTERCEPT_FUNCTION(sysinfo);\n#else\n#define INIT_SYSINFO\n#endif\n\n#if SANITIZER_INTERCEPT_READDIR\nINTERCEPTOR(__sanitizer_dirent *, opendir, const char *path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, opendir, path);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  __sanitizer_dirent *res = REAL(opendir)(path);\n  if (res)\n    COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_dirent *res = REAL(readdir)(dirp);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n  return res;\n}\n\nINTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n            __sanitizer_dirent **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir_r, dirp, entry, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(readdir_r)(dirp, entry, result);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (*result)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n  }\n  return res;\n}\n\n#define INIT_READDIR                  \\\n  COMMON_INTERCEPT_FUNCTION(opendir); \\\n  COMMON_INTERCEPT_FUNCTION(readdir); \\\n  COMMON_INTERCEPT_FUNCTION(readdir_r);\n#else\n#define INIT_READDIR\n#endif\n\n#if SANITIZER_INTERCEPT_READDIR64\nINTERCEPTOR(__sanitizer_dirent64 *, readdir64, void *dirp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir64, dirp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_dirent64 *res = REAL(readdir64)(dirp);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n  return res;\n}\n\nINTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n            __sanitizer_dirent64 **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir64_r, dirp, entry, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(readdir64_r)(dirp, entry, result);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (*result)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n  }\n  return res;\n}\n#define INIT_READDIR64                  \\\n  COMMON_INTERCEPT_FUNCTION(readdir64); \\\n  COMMON_INTERCEPT_FUNCTION(readdir64_r);\n#else\n#define INIT_READDIR64\n#endif\n\n#if SANITIZER_INTERCEPT_PTRACE\nINTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ptrace, request, pid, addr, data);\n  __sanitizer_iovec local_iovec;\n\n  if (data) {\n    if (request == ptrace_setregs)\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_regs_struct_sz);\n    else if (request == ptrace_setfpregs)\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n    else if (request == ptrace_setfpxregs)\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n    else if (request == ptrace_setvfpregs)\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n    else if (request == ptrace_setsiginfo)\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, siginfo_t_sz);\n    // Some kernel might zero the iovec::iov_base in case of invalid\n    // write access.  In this case copy the invalid address for further\n    // inspection.\n    else if (request == ptrace_setregset || request == ptrace_getregset) {\n      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec));\n      local_iovec = *iovec;\n      if (request == ptrace_setregset)\n        COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec->iov_base, iovec->iov_len);\n    }\n  }\n\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  uptr res = REAL(ptrace)(request, pid, addr, data);\n\n  if (!res && data) {\n    // Note that PEEK* requests assign different meaning to the return value.\n    // This function does not handle them (nor does it need to).\n    if (request == ptrace_getregs)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_regs_struct_sz);\n    else if (request == ptrace_getfpregs)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n    else if (request == ptrace_getfpxregs)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n    else if (request == ptrace_getvfpregs)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n    else if (request == ptrace_getsiginfo)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n    else if (request == ptrace_geteventmsg)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(unsigned long));\n    else if (request == ptrace_getregset) {\n      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec, sizeof(*iovec));\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, local_iovec.iov_base,\n                                     local_iovec.iov_len);\n    }\n  }\n  return res;\n}\n\n#define INIT_PTRACE COMMON_INTERCEPT_FUNCTION(ptrace);\n#else\n#define INIT_PTRACE\n#endif\n\n#if SANITIZER_INTERCEPT_SETLOCALE\nINTERCEPTOR(char *, setlocale, int category, char *locale) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setlocale, category, locale);\n  if (locale)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n  char *res = REAL(setlocale)(category, locale);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n\n#define INIT_SETLOCALE COMMON_INTERCEPT_FUNCTION(setlocale);\n#else\n#define INIT_SETLOCALE\n#endif\n\n#if SANITIZER_INTERCEPT_GETCWD\nINTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getcwd, buf, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(getcwd)(buf, size);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_GETCWD COMMON_INTERCEPT_FUNCTION(getcwd);\n#else\n#define INIT_GETCWD\n#endif\n\n#if SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME\nINTERCEPTOR(char *, get_current_dir_name, int fake) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name, fake);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(get_current_dir_name)(fake);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n\n#define INIT_GET_CURRENT_DIR_NAME \\\n  COMMON_INTERCEPT_FUNCTION(get_current_dir_name);\n#else\n#define INIT_GET_CURRENT_DIR_NAME\n#endif\n\nUNUSED static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n  CHECK(endptr);\n  if (nptr == *endptr) {\n    // No digits were found at strtol call, we need to find out the last\n    // symbol accessed by strtoll on our own.\n    // We get this symbol by skipping leading blanks and optional +/- sign.\n    while (IsSpace(*nptr)) nptr++;\n    if (*nptr == '+' || *nptr == '-') nptr++;\n    *endptr = const_cast<char *>(nptr);\n  }\n  CHECK(*endptr >= nptr);\n}\n\nUNUSED static inline void StrtolFixAndCheck(void *ctx, const char *nptr,\n                             char **endptr, char *real_endptr, int base) {\n  if (endptr) {\n    *endptr = real_endptr;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n  }\n  // If base has unsupported value, strtol can exit with EINVAL\n  // without reading any characters. So do additional checks only\n  // if base is valid.\n  bool is_valid_base = (base == 0) || (2 <= base && base <= 36);\n  if (is_valid_base) {\n    FixRealStrtolEndptr(nptr, &real_endptr);\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, nptr, is_valid_base ?\n                                 (real_endptr - nptr) + 1 : 0);\n}\n\n\n#if SANITIZER_INTERCEPT_STRTOIMAX\nINTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtoimax, nptr, endptr, base);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *real_endptr;\n  INTMAX_T res = REAL(strtoimax)(nptr, &real_endptr, base);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  return res;\n}\n\nINTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtoumax, nptr, endptr, base);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *real_endptr;\n  INTMAX_T res = REAL(strtoumax)(nptr, &real_endptr, base);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  return res;\n}\n\n#define INIT_STRTOIMAX                  \\\n  COMMON_INTERCEPT_FUNCTION(strtoimax); \\\n  COMMON_INTERCEPT_FUNCTION(strtoumax);\n#else\n#define INIT_STRTOIMAX\n#endif\n\n#if SANITIZER_INTERCEPT_MBSTOWCS\nINTERCEPTOR(SIZE_T, mbstowcs, wchar_t *dest, const char *src, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbstowcs, dest, src, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbstowcs)(dest, src, len);\n  if (res != (SIZE_T) - 1 && dest) {\n    SIZE_T write_cnt = res + (res < len);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, mbsrtowcs, wchar_t *dest, const char **src, SIZE_T len,\n            void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbsrtowcs, dest, src, len, ps);\n  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbsrtowcs)(dest, src, len, ps);\n  if (res != (SIZE_T)(-1) && dest && src) {\n    // This function, and several others, may or may not write the terminating\n    // \\0 character. They write it iff they clear *src.\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\n#define INIT_MBSTOWCS                  \\\n  COMMON_INTERCEPT_FUNCTION(mbstowcs); \\\n  COMMON_INTERCEPT_FUNCTION(mbsrtowcs);\n#else\n#define INIT_MBSTOWCS\n#endif\n\n#if SANITIZER_INTERCEPT_MBSNRTOWCS\nINTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n            SIZE_T len, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbsnrtowcs, dest, src, nms, len, ps);\n  if (src) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n  }\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbsnrtowcs)(dest, src, nms, len, ps);\n  if (res != (SIZE_T)(-1) && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\n#define INIT_MBSNRTOWCS COMMON_INTERCEPT_FUNCTION(mbsnrtowcs);\n#else\n#define INIT_MBSNRTOWCS\n#endif\n\n#if SANITIZER_INTERCEPT_WCSTOMBS\nINTERCEPTOR(SIZE_T, wcstombs, char *dest, const wchar_t *src, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcstombs, dest, src, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcstombs)(dest, src, len);\n  if (res != (SIZE_T) - 1 && dest) {\n    SIZE_T write_cnt = res + (res < len);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, wcsrtombs, char *dest, const wchar_t **src, SIZE_T len,\n            void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsrtombs, dest, src, len, ps);\n  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcsrtombs)(dest, src, len, ps);\n  if (res != (SIZE_T) - 1 && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\n#define INIT_WCSTOMBS                  \\\n  COMMON_INTERCEPT_FUNCTION(wcstombs); \\\n  COMMON_INTERCEPT_FUNCTION(wcsrtombs);\n#else\n#define INIT_WCSTOMBS\n#endif\n\n#if SANITIZER_INTERCEPT_WCSNRTOMBS\nINTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n            SIZE_T len, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsnrtombs, dest, src, nms, len, ps);\n  if (src) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n  }\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcsnrtombs)(dest, src, nms, len, ps);\n  if (res != ((SIZE_T)-1) && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\n#define INIT_WCSNRTOMBS COMMON_INTERCEPT_FUNCTION(wcsnrtombs);\n#else\n#define INIT_WCSNRTOMBS\n#endif\n\n\n#if SANITIZER_INTERCEPT_WCRTOMB\nINTERCEPTOR(SIZE_T, wcrtomb, char *dest, wchar_t src, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcrtomb, dest, src, ps);\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcrtomb)(dest, src, ps);\n  if (res != ((SIZE_T)-1) && dest) {\n    SIZE_T write_cnt = res;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\n#define INIT_WCRTOMB COMMON_INTERCEPT_FUNCTION(wcrtomb);\n#else\n#define INIT_WCRTOMB\n#endif\n\n#if SANITIZER_INTERCEPT_TCGETATTR\nINTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tcgetattr, fd, termios_p);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(tcgetattr)(fd, termios_p);\n  if (!res && termios_p)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, termios_p, struct_termios_sz);\n  return res;\n}\n\n#define INIT_TCGETATTR COMMON_INTERCEPT_FUNCTION(tcgetattr);\n#else\n#define INIT_TCGETATTR\n#endif\n\n#if SANITIZER_INTERCEPT_REALPATH\nINTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, realpath, path, resolved_path);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n\n  // Workaround a bug in glibc where dlsym(RTLD_NEXT, ...) returns the oldest\n  // version of a versioned symbol. For realpath(), this gives us something\n  // (called __old_realpath) that does not handle NULL in the second argument.\n  // Handle it as part of the interceptor.\n  char *allocated_path = nullptr;\n  if (!resolved_path)\n    allocated_path = resolved_path = (char *)WRAP(malloc)(path_max + 1);\n\n  char *res = REAL(realpath)(path, resolved_path);\n  if (allocated_path && !res) WRAP(free)(allocated_path);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_REALPATH COMMON_INTERCEPT_FUNCTION(realpath);\n#else\n#define INIT_REALPATH\n#endif\n\n#if SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME\nINTERCEPTOR(char *, canonicalize_file_name, const char *path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, canonicalize_file_name, path);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  char *res = REAL(canonicalize_file_name)(path);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_CANONICALIZE_FILE_NAME \\\n  COMMON_INTERCEPT_FUNCTION(canonicalize_file_name);\n#else\n#define INIT_CANONICALIZE_FILE_NAME\n#endif\n\n#if SANITIZER_INTERCEPT_CONFSTR\nINTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, confstr, name, buf, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(confstr)(name, buf, len);\n  if (buf && res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res < len ? res : len);\n  return res;\n}\n#define INIT_CONFSTR COMMON_INTERCEPT_FUNCTION(confstr);\n#else\n#define INIT_CONFSTR\n#endif\n\n#if SANITIZER_INTERCEPT_SCHED_GETAFFINITY\nINTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sched_getaffinity, pid, cpusetsize, mask);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sched_getaffinity)(pid, cpusetsize, mask);\n  if (mask && !res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n  return res;\n}\n#define INIT_SCHED_GETAFFINITY COMMON_INTERCEPT_FUNCTION(sched_getaffinity);\n#else\n#define INIT_SCHED_GETAFFINITY\n#endif\n\n#if SANITIZER_INTERCEPT_SCHED_GETPARAM\nINTERCEPTOR(int, sched_getparam, int pid, void *param) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sched_getparam, pid, param);\n  int res = REAL(sched_getparam)(pid, param);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, struct_sched_param_sz);\n  return res;\n}\n#define INIT_SCHED_GETPARAM COMMON_INTERCEPT_FUNCTION(sched_getparam);\n#else\n#define INIT_SCHED_GETPARAM\n#endif\n\n#if SANITIZER_INTERCEPT_STRERROR\nINTERCEPTOR(char *, strerror, int errnum) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n  char *res = REAL(strerror)(errnum);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_STRERROR COMMON_INTERCEPT_FUNCTION(strerror);\n#else\n#define INIT_STRERROR\n#endif\n\n#if SANITIZER_INTERCEPT_STRERROR_R\nINTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(strerror_r)(errnum, buf, buflen);\n  // There are 2 versions of strerror_r:\n  //  * POSIX version returns 0 on success, negative error code on failure,\n  //    writes message to buf.\n  //  * GNU version returns message pointer, which points to either buf or some\n  //    static storage.\n  SIZE_T posix_res = (SIZE_T)res;\n  if (posix_res < 1024 || posix_res > (SIZE_T) - 1024) {\n    // POSIX version. Spec is not clear on whether buf is NULL-terminated.\n    // At least on OSX, buf contents are valid even when the call fails.\n    SIZE_T sz = internal_strnlen(buf, buflen);\n    if (sz < buflen) ++sz;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n  } else {\n    // GNU version.\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_STRERROR_R COMMON_INTERCEPT_FUNCTION(strerror_r);\n#else\n#define INIT_STRERROR_R\n#endif\n\n#if SANITIZER_INTERCEPT_XPG_STRERROR_R\nINTERCEPTOR(int, __xpg_strerror_r, int errnum, char *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xpg_strerror_r, errnum, buf, buflen);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(__xpg_strerror_r)(errnum, buf, buflen);\n  // This version always returns a null-terminated string.\n  if (buf && buflen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  return res;\n}\n#define INIT_XPG_STRERROR_R COMMON_INTERCEPT_FUNCTION(__xpg_strerror_r);\n#else\n#define INIT_XPG_STRERROR_R\n#endif\n\n#if SANITIZER_INTERCEPT_SCANDIR\ntypedef int (*scandir_filter_f)(const struct __sanitizer_dirent *);\ntypedef int (*scandir_compar_f)(const struct __sanitizer_dirent **,\n                                const struct __sanitizer_dirent **);\n\nstatic THREADLOCAL scandir_filter_f scandir_filter;\nstatic THREADLOCAL scandir_compar_f scandir_compar;\n\nstatic int wrapped_scandir_filter(const struct __sanitizer_dirent *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n  return scandir_filter(dir);\n}\n\nstatic int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n                                  const struct __sanitizer_dirent **b) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n  return scandir_compar(a, b);\n}\n\nINTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n            scandir_filter_f filter, scandir_compar_f compar) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, scandir, dirp, namelist, filter, compar);\n  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n  scandir_filter = filter;\n  scandir_compar = compar;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(scandir)(dirp, namelist,\n                          filter ? wrapped_scandir_filter : nullptr,\n                          compar ? wrapped_scandir_compar : nullptr);\n  scandir_filter = nullptr;\n  scandir_compar = nullptr;\n  if (namelist && res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n    for (int i = 0; i < res; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n                                     (*namelist)[i]->d_reclen);\n  }\n  return res;\n}\n#define INIT_SCANDIR COMMON_INTERCEPT_FUNCTION(scandir);\n#else\n#define INIT_SCANDIR\n#endif\n\n#if SANITIZER_INTERCEPT_SCANDIR64\ntypedef int (*scandir64_filter_f)(const struct __sanitizer_dirent64 *);\ntypedef int (*scandir64_compar_f)(const struct __sanitizer_dirent64 **,\n                                  const struct __sanitizer_dirent64 **);\n\nstatic THREADLOCAL scandir64_filter_f scandir64_filter;\nstatic THREADLOCAL scandir64_compar_f scandir64_compar;\n\nstatic int wrapped_scandir64_filter(const struct __sanitizer_dirent64 *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n  return scandir64_filter(dir);\n}\n\nstatic int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n                                    const struct __sanitizer_dirent64 **b) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n  return scandir64_compar(a, b);\n}\n\nINTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n            scandir64_filter_f filter, scandir64_compar_f compar) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, scandir64, dirp, namelist, filter, compar);\n  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n  scandir64_filter = filter;\n  scandir64_compar = compar;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(scandir64)(dirp, namelist,\n                      filter ? wrapped_scandir64_filter : nullptr,\n                      compar ? wrapped_scandir64_compar : nullptr);\n  scandir64_filter = nullptr;\n  scandir64_compar = nullptr;\n  if (namelist && res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n    for (int i = 0; i < res; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n                                     (*namelist)[i]->d_reclen);\n  }\n  return res;\n}\n#define INIT_SCANDIR64 COMMON_INTERCEPT_FUNCTION(scandir64);\n#else\n#define INIT_SCANDIR64\n#endif\n\n#if SANITIZER_INTERCEPT_GETGROUPS\nINTERCEPTOR(int, getgroups, int size, u32 *lst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgroups, size, lst);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgroups)(size, lst);\n  if (res >= 0 && lst && size > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n  return res;\n}\n#define INIT_GETGROUPS COMMON_INTERCEPT_FUNCTION(getgroups);\n#else\n#define INIT_GETGROUPS\n#endif\n\n#if SANITIZER_INTERCEPT_POLL\nstatic void read_pollfd(void *ctx, __sanitizer_pollfd *fds,\n                        __sanitizer_nfds_t nfds) {\n  for (unsigned i = 0; i < nfds; ++i) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].fd, sizeof(fds[i].fd));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].events, sizeof(fds[i].events));\n  }\n}\n\nstatic void write_pollfd(void *ctx, __sanitizer_pollfd *fds,\n                         __sanitizer_nfds_t nfds) {\n  for (unsigned i = 0; i < nfds; ++i)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &fds[i].revents,\n                                   sizeof(fds[i].revents));\n}\n\nINTERCEPTOR(int, poll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n            int timeout) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, poll, fds, nfds, timeout);\n  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(poll)(fds, nfds, timeout);\n  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n  return res;\n}\n#define INIT_POLL COMMON_INTERCEPT_FUNCTION(poll);\n#else\n#define INIT_POLL\n#endif\n\n#if SANITIZER_INTERCEPT_PPOLL\nINTERCEPTOR(int, ppoll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n            void *timeout_ts, __sanitizer_sigset_t *sigmask) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ppoll, fds, nfds, timeout_ts, sigmask);\n  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n  if (timeout_ts)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout_ts, struct_timespec_sz);\n  // FIXME: read sigmask when all of sigemptyset, etc are intercepted.\n  int res =\n      COMMON_INTERCEPTOR_BLOCK_REAL(ppoll)(fds, nfds, timeout_ts, sigmask);\n  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n  return res;\n}\n#define INIT_PPOLL COMMON_INTERCEPT_FUNCTION(ppoll);\n#else\n#define INIT_PPOLL\n#endif\n\n#if SANITIZER_INTERCEPT_WORDEXP\nINTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wordexp, s, p, flags);\n  if (s) COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wordexp)(s, p, flags);\n  if (!res && p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    if (p->we_wordc)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->we_wordv,\n                                     sizeof(*p->we_wordv) * p->we_wordc);\n    for (uptr i = 0; i < p->we_wordc; ++i) {\n      char *w = p->we_wordv[i];\n      if (w) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, w, REAL(strlen)(w) + 1);\n    }\n  }\n  return res;\n}\n#define INIT_WORDEXP COMMON_INTERCEPT_FUNCTION(wordexp);\n#else\n#define INIT_WORDEXP\n#endif\n\n#if SANITIZER_INTERCEPT_SIGWAIT\nINTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigwait, set, sig);\n  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigwait)(set, sig);\n  if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n  return res;\n}\n#define INIT_SIGWAIT COMMON_INTERCEPT_FUNCTION(sigwait);\n#else\n#define INIT_SIGWAIT\n#endif\n\n#if SANITIZER_INTERCEPT_SIGWAITINFO\nINTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigwaitinfo, set, info);\n  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigwaitinfo)(set, info);\n  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n  return res;\n}\n#define INIT_SIGWAITINFO COMMON_INTERCEPT_FUNCTION(sigwaitinfo);\n#else\n#define INIT_SIGWAITINFO\n#endif\n\n#if SANITIZER_INTERCEPT_SIGTIMEDWAIT\nINTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n            void *timeout) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigtimedwait, set, info, timeout);\n  if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigtimedwait)(set, info, timeout);\n  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n  return res;\n}\n#define INIT_SIGTIMEDWAIT COMMON_INTERCEPT_FUNCTION(sigtimedwait);\n#else\n#define INIT_SIGTIMEDWAIT\n#endif\n\n#if SANITIZER_INTERCEPT_SIGSETOPS\nINTERCEPTOR(int, sigemptyset, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigemptyset, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigemptyset)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n\nINTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigfillset, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigfillset)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n#define INIT_SIGSETOPS                    \\\n  COMMON_INTERCEPT_FUNCTION(sigemptyset); \\\n  COMMON_INTERCEPT_FUNCTION(sigfillset);\n#else\n#define INIT_SIGSETOPS\n#endif\n\n#if SANITIZER_INTERCEPT_SIGPENDING\nINTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigpending, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigpending)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n#define INIT_SIGPENDING COMMON_INTERCEPT_FUNCTION(sigpending);\n#else\n#define INIT_SIGPENDING\n#endif\n\n#if SANITIZER_INTERCEPT_SIGPROCMASK\nINTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n            __sanitizer_sigset_t *oldset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigprocmask, how, set, oldset);\n  // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigprocmask)(how, set, oldset);\n  if (!res && oldset)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n  return res;\n}\n#define INIT_SIGPROCMASK COMMON_INTERCEPT_FUNCTION(sigprocmask);\n#else\n#define INIT_SIGPROCMASK\n#endif\n\n#if SANITIZER_INTERCEPT_BACKTRACE\nINTERCEPTOR(int, backtrace, void **buffer, int size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, backtrace, buffer, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(backtrace)(buffer, size);\n  if (res && buffer)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buffer, res * sizeof(*buffer));\n  return res;\n}\n\nINTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, backtrace_symbols, buffer, size);\n  if (buffer && size)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, size * sizeof(*buffer));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char **res = REAL(backtrace_symbols)(buffer, size);\n  if (res && size) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, size * sizeof(*res));\n    for (int i = 0; i < size; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res[i], REAL(strlen(res[i])) + 1);\n  }\n  return res;\n}\n#define INIT_BACKTRACE                  \\\n  COMMON_INTERCEPT_FUNCTION(backtrace); \\\n  COMMON_INTERCEPT_FUNCTION(backtrace_symbols);\n#else\n#define INIT_BACKTRACE\n#endif\n\n#if SANITIZER_INTERCEPT__EXIT\nINTERCEPTOR(void, _exit, int status) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _exit, status);\n  COMMON_INTERCEPTOR_USER_CALLBACK_START();\n  int status1 = COMMON_INTERCEPTOR_ON_EXIT(ctx);\n  COMMON_INTERCEPTOR_USER_CALLBACK_END();\n  if (status == 0) status = status1;\n  REAL(_exit)(status);\n}\n#define INIT__EXIT COMMON_INTERCEPT_FUNCTION(_exit);\n#else\n#define INIT__EXIT\n#endif\n\n#if SANITIZER_INTERCEPT_PHTREAD_MUTEX\nINTERCEPTOR(int, pthread_mutex_lock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_lock, m);\n  int res = REAL(pthread_mutex_lock)(m);\n  if (res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n  if (res == 0 || res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\nINTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_unlock, m);\n  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n  int res = REAL(pthread_mutex_unlock)(m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\n#define INIT_PTHREAD_MUTEX_LOCK COMMON_INTERCEPT_FUNCTION(pthread_mutex_lock)\n#define INIT_PTHREAD_MUTEX_UNLOCK \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutex_unlock)\n#else\n#define INIT_PTHREAD_MUTEX_LOCK\n#define INIT_PTHREAD_MUTEX_UNLOCK\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT || SANITIZER_INTERCEPT_GETMNTENT_R\nstatic void write_mntent(void *ctx, __sanitizer_mntent *mnt) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt, sizeof(*mnt));\n  if (mnt->mnt_fsname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_fsname,\n                                   REAL(strlen)(mnt->mnt_fsname) + 1);\n  if (mnt->mnt_dir)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_dir,\n                                   REAL(strlen)(mnt->mnt_dir) + 1);\n  if (mnt->mnt_type)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_type,\n                                   REAL(strlen)(mnt->mnt_type) + 1);\n  if (mnt->mnt_opts)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_opts,\n                                   REAL(strlen)(mnt->mnt_opts) + 1);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT\nINTERCEPTOR(__sanitizer_mntent *, getmntent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getmntent, fp);\n  __sanitizer_mntent *res = REAL(getmntent)(fp);\n  if (res) write_mntent(ctx, res);\n  return res;\n}\n#define INIT_GETMNTENT COMMON_INTERCEPT_FUNCTION(getmntent);\n#else\n#define INIT_GETMNTENT\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT_R\nINTERCEPTOR(__sanitizer_mntent *, getmntent_r, void *fp,\n            __sanitizer_mntent *mntbuf, char *buf, int buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getmntent_r, fp, mntbuf, buf, buflen);\n  __sanitizer_mntent *res = REAL(getmntent_r)(fp, mntbuf, buf, buflen);\n  if (res) write_mntent(ctx, res);\n  return res;\n}\n#define INIT_GETMNTENT_R COMMON_INTERCEPT_FUNCTION(getmntent_r);\n#else\n#define INIT_GETMNTENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_STATFS\nINTERCEPTOR(int, statfs, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statfs, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statfs)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatfs, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatfs)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n  return res;\n}\n#define INIT_STATFS                  \\\n  COMMON_INTERCEPT_FUNCTION(statfs); \\\n  COMMON_INTERCEPT_FUNCTION(fstatfs);\n#else\n#define INIT_STATFS\n#endif\n\n#if SANITIZER_INTERCEPT_STATFS64\nINTERCEPTOR(int, statfs64, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statfs64, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statfs64)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatfs64, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs64, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatfs64)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n  return res;\n}\n#define INIT_STATFS64                  \\\n  COMMON_INTERCEPT_FUNCTION(statfs64); \\\n  COMMON_INTERCEPT_FUNCTION(fstatfs64);\n#else\n#define INIT_STATFS64\n#endif\n\n#if SANITIZER_INTERCEPT_STATVFS\nINTERCEPTOR(int, statvfs, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statvfs, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statvfs)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatvfs, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatvfs)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n  return res;\n}\n#define INIT_STATVFS                  \\\n  COMMON_INTERCEPT_FUNCTION(statvfs); \\\n  COMMON_INTERCEPT_FUNCTION(fstatvfs);\n#else\n#define INIT_STATVFS\n#endif\n\n#if SANITIZER_INTERCEPT_STATVFS64\nINTERCEPTOR(int, statvfs64, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statvfs64, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statvfs64)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatvfs64, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs64, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatvfs64)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n  return res;\n}\n#define INIT_STATVFS64                  \\\n  COMMON_INTERCEPT_FUNCTION(statvfs64); \\\n  COMMON_INTERCEPT_FUNCTION(fstatvfs64);\n#else\n#define INIT_STATVFS64\n#endif\n\n#if SANITIZER_INTERCEPT_INITGROUPS\nINTERCEPTOR(int, initgroups, char *user, u32 group) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, initgroups, user, group);\n  if (user) COMMON_INTERCEPTOR_READ_RANGE(ctx, user, REAL(strlen)(user) + 1);\n  int res = REAL(initgroups)(user, group);\n  return res;\n}\n#define INIT_INITGROUPS COMMON_INTERCEPT_FUNCTION(initgroups);\n#else\n#define INIT_INITGROUPS\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_NTOA_ATON\nINTERCEPTOR(char *, ether_ntoa, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa, addr);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  char *res = REAL(ether_ntoa)(addr);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(__sanitizer_ether_addr *, ether_aton, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton, buf);\n  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  __sanitizer_ether_addr *res = REAL(ether_aton)(buf);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, sizeof(*res));\n  return res;\n}\n#define INIT_ETHER_NTOA_ATON             \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntoa); \\\n  COMMON_INTERCEPT_FUNCTION(ether_aton);\n#else\n#define INIT_ETHER_NTOA_ATON\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_HOST\nINTERCEPTOR(int, ether_ntohost, char *hostname, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntohost, hostname, addr);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_ntohost)(hostname, addr);\n  if (!res && hostname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  return res;\n}\nINTERCEPTOR(int, ether_hostton, char *hostname, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_hostton, hostname, addr);\n  if (hostname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_hostton)(hostname, addr);\n  if (!res && addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n  return res;\n}\nINTERCEPTOR(int, ether_line, char *line, __sanitizer_ether_addr *addr,\n            char *hostname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_line, line, addr, hostname);\n  if (line) COMMON_INTERCEPTOR_READ_RANGE(ctx, line, REAL(strlen)(line) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_line)(line, addr, hostname);\n  if (!res) {\n    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n    if (hostname)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  }\n  return res;\n}\n#define INIT_ETHER_HOST                     \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntohost); \\\n  COMMON_INTERCEPT_FUNCTION(ether_hostton); \\\n  COMMON_INTERCEPT_FUNCTION(ether_line);\n#else\n#define INIT_ETHER_HOST\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_R\nINTERCEPTOR(char *, ether_ntoa_r, __sanitizer_ether_addr *addr, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa_r, addr, buf);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ether_ntoa_r)(addr, buf);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(__sanitizer_ether_addr *, ether_aton_r, char *buf,\n            __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton_r, buf, addr);\n  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_ether_addr *res = REAL(ether_aton_r)(buf, addr);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(*res));\n  return res;\n}\n#define INIT_ETHER_R                       \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntoa_r); \\\n  COMMON_INTERCEPT_FUNCTION(ether_aton_r);\n#else\n#define INIT_ETHER_R\n#endif\n\n#if SANITIZER_INTERCEPT_SHMCTL\nINTERCEPTOR(int, shmctl, int shmid, int cmd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, shmctl, shmid, cmd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(shmctl)(shmid, cmd, buf);\n  if (res >= 0) {\n    unsigned sz = 0;\n    if (cmd == shmctl_ipc_stat || cmd == shmctl_shm_stat)\n      sz = sizeof(__sanitizer_shmid_ds);\n    else if (cmd == shmctl_ipc_info)\n      sz = struct_shminfo_sz;\n    else if (cmd == shmctl_shm_info)\n      sz = struct_shm_info_sz;\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n  }\n  return res;\n}\n#define INIT_SHMCTL COMMON_INTERCEPT_FUNCTION(shmctl);\n#else\n#define INIT_SHMCTL\n#endif\n\n#if SANITIZER_INTERCEPT_RANDOM_R\nINTERCEPTOR(int, random_r, void *buf, u32 *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, random_r, buf, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(random_r)(buf, result);\n  if (!res && result)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_RANDOM_R COMMON_INTERCEPT_FUNCTION(random_r);\n#else\n#define INIT_RANDOM_R\n#endif\n\n// FIXME: under ASan the REAL() call below may write to freed memory and corrupt\n// its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET ||              \\\n    SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED || \\\n    SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GET ||         \\\n    SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GET ||        \\\n    SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GET ||          \\\n    SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GET\n#define INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(fn, sz)            \\\n  INTERCEPTOR(int, fn, void *attr, void *r) {                  \\\n    void *ctx;                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, fn, attr, r);                \\\n    int res = REAL(fn)(attr, r);                               \\\n    if (!res && r) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, r, sz); \\\n    return res;                                                \\\n  }\n#define INTERCEPTOR_PTHREAD_ATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_attr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_MUTEXATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_mutexattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_RWLOCKATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_rwlockattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_CONDATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_condattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_BARRIERATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_barrierattr_get##what, sz)\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET\nINTERCEPTOR_PTHREAD_ATTR_GET(detachstate, sizeof(int))\nINTERCEPTOR_PTHREAD_ATTR_GET(guardsize, sizeof(SIZE_T))\nINTERCEPTOR_PTHREAD_ATTR_GET(schedparam, struct_sched_param_sz)\nINTERCEPTOR_PTHREAD_ATTR_GET(schedpolicy, sizeof(int))\nINTERCEPTOR_PTHREAD_ATTR_GET(scope, sizeof(int))\nINTERCEPTOR_PTHREAD_ATTR_GET(stacksize, sizeof(SIZE_T))\nINTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getstack, attr, addr, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_attr_getstack)(attr, addr, size);\n  if (!res) {\n    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n    if (size) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, size, sizeof(*size));\n  }\n  return res;\n}\n\n// We may need to call the real pthread_attr_getstack from the run-time\n// in sanitizer_common, but we don't want to include the interception headers\n// there. So, just define this function here.\nnamespace __sanitizer {\nextern \"C\" {\nint real_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n  return REAL(pthread_attr_getstack)(attr, addr, size);\n}\n}  // extern \"C\"\n}  // namespace __sanitizer\n\n#define INIT_PTHREAD_ATTR_GET                             \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getdetachstate); \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getguardsize);   \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedparam);  \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedpolicy); \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getscope);       \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstacksize);   \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstack);\n#else\n#define INIT_PTHREAD_ATTR_GET\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED\nINTERCEPTOR_PTHREAD_ATTR_GET(inheritsched, sizeof(int))\n\n#define INIT_PTHREAD_ATTR_GETINHERITSCHED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getinheritsched);\n#else\n#define INIT_PTHREAD_ATTR_GETINHERITSCHED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP\nINTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n            void *cpuset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getaffinity_np, attr, cpusetsize,\n                           cpuset);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_attr_getaffinity_np)(attr, cpusetsize, cpuset);\n  if (!res && cpusetsize && cpuset)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cpuset, cpusetsize);\n  return res;\n}\n\n#define INIT_PTHREAD_ATTR_GETAFFINITY_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getaffinity_np);\n#else\n#define INIT_PTHREAD_ATTR_GETAFFINITY_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getpshared);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(type, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETTYPE \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_gettype);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETTYPE\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(protocol, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprotocol);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(prioceiling, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprioceiling);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust_np, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust_np);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_RWLOCKATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getpshared);\n#else\n#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP\nINTERCEPTOR_PTHREAD_RWLOCKATTR_GET(kind_np, sizeof(int))\n#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getkind_np);\n#else\n#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_CONDATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_CONDATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getpshared);\n#else\n#define INIT_PTHREAD_CONDATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK\nINTERCEPTOR_PTHREAD_CONDATTR_GET(clock, sizeof(int))\n#define INIT_PTHREAD_CONDATTR_GETCLOCK \\\n  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getclock);\n#else\n#define INIT_PTHREAD_CONDATTR_GETCLOCK\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_BARRIERATTR_GET(pshared, sizeof(int)) // !mac !android\n#define INIT_PTHREAD_BARRIERATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_barrierattr_getpshared);\n#else\n#define INIT_PTHREAD_BARRIERATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_TMPNAM\nINTERCEPTOR(char *, tmpnam, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam, s);\n  char *res = REAL(tmpnam)(s);\n  if (res) {\n    if (s)\n      // FIXME: under ASan the call below may write to freed memory and corrupt\n      // its metadata. See\n      // https://github.com/google/sanitizers/issues/321.\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n    else\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_TMPNAM COMMON_INTERCEPT_FUNCTION(tmpnam);\n#else\n#define INIT_TMPNAM\n#endif\n\n#if SANITIZER_INTERCEPT_TMPNAM_R\nINTERCEPTOR(char *, tmpnam_r, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam_r, s);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(tmpnam_r)(s);\n  if (res && s) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  return res;\n}\n#define INIT_TMPNAM_R COMMON_INTERCEPT_FUNCTION(tmpnam_r);\n#else\n#define INIT_TMPNAM_R\n#endif\n\n#if SANITIZER_INTERCEPT_TTYNAME_R\nINTERCEPTOR(int, ttyname_r, int fd, char *name, SIZE_T namesize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ttyname_r, fd, name, namesize);\n  int res = REAL(ttyname_r)(fd, name, namesize);\n  if (res == 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  return res;\n}\n#define INIT_TTYNAME_R COMMON_INTERCEPT_FUNCTION(ttyname_r);\n#else\n#define INIT_TTYNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_TEMPNAM\nINTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tempnam, dir, pfx);\n  if (dir) COMMON_INTERCEPTOR_READ_RANGE(ctx, dir, REAL(strlen)(dir) + 1);\n  if (pfx) COMMON_INTERCEPTOR_READ_RANGE(ctx, pfx, REAL(strlen)(pfx) + 1);\n  char *res = REAL(tempnam)(dir, pfx);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_TEMPNAM COMMON_INTERCEPT_FUNCTION(tempnam);\n#else\n#define INIT_TEMPNAM\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP\nINTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, name, 0);\n  COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name);\n  return REAL(pthread_setname_np)(thread, name);\n}\n#define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n#else\n#define INIT_PTHREAD_SETNAME_NP\n#endif\n\n#if SANITIZER_INTERCEPT_SINCOS\nINTERCEPTOR(void, sincos, double x, double *sin, double *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincos, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincos)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\nINTERCEPTOR(void, sincosf, float x, float *sin, float *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincosf, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincosf)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\nINTERCEPTOR(void, sincosl, long double x, long double *sin, long double *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincosl, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincosl)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\n#define INIT_SINCOS                   \\\n  COMMON_INTERCEPT_FUNCTION(sincos);  \\\n  COMMON_INTERCEPT_FUNCTION(sincosf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(sincosl);\n#else\n#define INIT_SINCOS\n#endif\n\n#if SANITIZER_INTERCEPT_REMQUO\nINTERCEPTOR(double, remquo, double x, double y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquo, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(remquo)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\nINTERCEPTOR(float, remquof, float x, float y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquof, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(remquof)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\nINTERCEPTOR(long double, remquol, long double x, long double y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquol, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(remquol)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\n#define INIT_REMQUO                   \\\n  COMMON_INTERCEPT_FUNCTION(remquo);  \\\n  COMMON_INTERCEPT_FUNCTION(remquof); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(remquol);\n#else\n#define INIT_REMQUO\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMA\nextern int signgam;\nINTERCEPTOR(double, lgamma, double x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgamma, x);\n  double res = REAL(lgamma)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\nINTERCEPTOR(float, lgammaf, float x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf, x);\n  float res = REAL(lgammaf)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\nINTERCEPTOR(long double, lgammal, long double x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammal, x);\n  long double res = REAL(lgammal)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\n#define INIT_LGAMMA                   \\\n  COMMON_INTERCEPT_FUNCTION(lgamma);  \\\n  COMMON_INTERCEPT_FUNCTION(lgammaf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(lgammal);\n#else\n#define INIT_LGAMMA\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMA_R\nINTERCEPTOR(double, lgamma_r, double x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgamma_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(lgamma_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\nINTERCEPTOR(float, lgammaf_r, float x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(lgammaf_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\n#define INIT_LGAMMA_R                   \\\n  COMMON_INTERCEPT_FUNCTION(lgamma_r);  \\\n  COMMON_INTERCEPT_FUNCTION(lgammaf_r);\n#else\n#define INIT_LGAMMA_R\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMAL_R\nINTERCEPTOR(long double, lgammal_r, long double x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammal_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(lgammal_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\n#define INIT_LGAMMAL_R COMMON_INTERCEPT_FUNCTION_LDBL(lgammal_r);\n#else\n#define INIT_LGAMMAL_R\n#endif\n\n#if SANITIZER_INTERCEPT_DRAND48_R\nINTERCEPTOR(int, drand48_r, void *buffer, double *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, drand48_r, buffer, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(drand48_r)(buffer, result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, lrand48_r, void *buffer, long *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lrand48_r, buffer, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(lrand48_r)(buffer, result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_DRAND48_R                  \\\n  COMMON_INTERCEPT_FUNCTION(drand48_r); \\\n  COMMON_INTERCEPT_FUNCTION(lrand48_r);\n#else\n#define INIT_DRAND48_R\n#endif\n\n#if SANITIZER_INTERCEPT_RAND_R\nINTERCEPTOR(int, rand_r, unsigned *seedp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, rand_r, seedp);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, seedp, sizeof(*seedp));\n  return REAL(rand_r)(seedp);\n}\n#define INIT_RAND_R COMMON_INTERCEPT_FUNCTION(rand_r);\n#else\n#define INIT_RAND_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETLINE\nINTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getline, lineptr, n, stream);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(getline)(lineptr, n, stream);\n  if (res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n  }\n  return res;\n}\n\n// FIXME: under ASan the call below may write to freed memory and corrupt its\n// metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define GETDELIM_INTERCEPTOR_IMPL(vname)                                       \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, lineptr, n, delim, stream);           \\\n    SSIZE_T res = REAL(vname)(lineptr, n, delim, stream);                      \\\n    if (res > 0) {                                                             \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));          \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));                      \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);                  \\\n    }                                                                          \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(SSIZE_T, __getdelim, char **lineptr, SIZE_T *n, int delim,\n            void *stream)\nGETDELIM_INTERCEPTOR_IMPL(__getdelim)\n\n// There's no __getdelim() on FreeBSD so we supply the getdelim() interceptor\n// with its own body.\nINTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n            void *stream)\nGETDELIM_INTERCEPTOR_IMPL(getdelim)\n\n#define INIT_GETLINE                     \\\n  COMMON_INTERCEPT_FUNCTION(getline);    \\\n  COMMON_INTERCEPT_FUNCTION(__getdelim); \\\n  COMMON_INTERCEPT_FUNCTION(getdelim);\n#else\n#define INIT_GETLINE\n#endif\n\n#if SANITIZER_INTERCEPT_ICONV\nINTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n            char **outbuf, SIZE_T *outbytesleft) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, iconv, cd, inbuf, inbytesleft, outbuf,\n                           outbytesleft);\n  if (inbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, inbytesleft, sizeof(*inbytesleft));\n  if (inbuf && inbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *inbuf, *inbytesleft);\n  if (outbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, outbytesleft, sizeof(*outbytesleft));\n  void *outbuf_orig = outbuf ? *outbuf : nullptr;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(iconv)(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n  if (res != (SIZE_T) - 1 && outbuf && *outbuf > outbuf_orig) {\n    SIZE_T sz = (char *)*outbuf - (char *)outbuf_orig;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, outbuf_orig, sz);\n  }\n  return res;\n}\n#define INIT_ICONV COMMON_INTERCEPT_FUNCTION(iconv);\n#else\n#define INIT_ICONV\n#endif\n\n#if SANITIZER_INTERCEPT_TIMES\nINTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, times, tms);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_clock_t res = REAL(times)(tms);\n  if (res != (__sanitizer_clock_t)-1 && tms)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tms, struct_tms_sz);\n  return res;\n}\n#define INIT_TIMES COMMON_INTERCEPT_FUNCTION(times);\n#else\n#define INIT_TIMES\n#endif\n\n#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n#if !SANITIZER_S390\n#define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_addr)\n// If you see any crashes around this functions, there are 2 known issues with\n// it: 1. __tls_get_addr can be called with mis-aligned stack due to:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066\n// 2. It can be called recursively if sanitizer code uses __tls_get_addr\n// to access thread local variables (it should not happen normally,\n// because sanitizers use initial-exec tls model).\nINTERCEPTOR(void *, __tls_get_addr, void *arg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr, arg);\n  void *res = REAL(__tls_get_addr)(arg);\n  uptr tls_begin, tls_end;\n  COMMON_INTERCEPTOR_GET_TLS_RANGE(&tls_begin, &tls_end);\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, tls_begin, tls_end);\n  if (dtv) {\n    // New DTLS block has been allocated.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n  }\n  return res;\n}\n#if SANITIZER_PPC\n// On PowerPC, we also need to intercept __tls_get_addr_opt, which has\n// mostly the same semantics as __tls_get_addr, but its presence enables\n// some optimizations in linker (which are safe to ignore here).\nextern \"C\" __attribute__((alias(\"__interceptor___tls_get_addr\"),\n                          visibility(\"default\")))\nvoid *__tls_get_addr_opt(void *arg);\n#endif\n#else // SANITIZER_S390\n// On s390, we have to intercept two functions here:\n// - __tls_get_addr_internal, which is a glibc-internal function that is like\n//   the usual __tls_get_addr, but returns a TP-relative offset instead of\n//   a proper pointer.  It is used by dlsym for TLS symbols.\n// - __tls_get_offset, which is like the above, but also takes a GOT-relative\n//   descriptor offset as an argument instead of a pointer.  GOT address\n//   is passed in r12, so it's necessary to write it in assembly.  This is\n//   the function used by the compiler.\nextern \"C\" uptr __tls_get_offset_wrapper(void *arg, uptr (*fn)(void *arg));\n#define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_offset)\nDEFINE_REAL(uptr, __tls_get_offset, void *arg)\nextern \"C\" uptr __tls_get_offset(void *arg);\nextern \"C\" uptr __interceptor___tls_get_offset(void *arg);\nINTERCEPTOR(uptr, __tls_get_addr_internal, void *arg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr_internal, arg);\n  uptr res = __tls_get_offset_wrapper(arg, REAL(__tls_get_offset));\n  uptr tp = reinterpret_cast<uptr>(__builtin_thread_pointer());\n  void *ptr = reinterpret_cast<void *>(res + tp);\n  uptr tls_begin, tls_end;\n  COMMON_INTERCEPTOR_GET_TLS_RANGE(&tls_begin, &tls_end);\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, ptr, tls_begin, tls_end);\n  if (dtv) {\n    // New DTLS block has been allocated.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n  }\n  return res;\n}\n// We need a hidden symbol aliasing the above, so that we can jump\n// directly to it from the assembly below.\nextern \"C\" __attribute__((alias(\"__interceptor___tls_get_addr_internal\"),\n                          visibility(\"hidden\")))\nuptr __tls_get_addr_hidden(void *arg);\n// Now carefully intercept __tls_get_offset.\nasm(\n  \".text\\n\"\n// The __intercept_ version has to exist, so that gen_dynamic_list.py\n// exports our symbol.\n  \".weak __tls_get_offset\\n\"\n  \".type __tls_get_offset, @function\\n\"\n  \"__tls_get_offset:\\n\"\n  \".global __interceptor___tls_get_offset\\n\"\n  \".type __interceptor___tls_get_offset, @function\\n\"\n  \"__interceptor___tls_get_offset:\\n\"\n#ifdef __s390x__\n  \"la %r2, 0(%r2,%r12)\\n\"\n  \"jg __tls_get_addr_hidden\\n\"\n#else\n  \"basr %r3,0\\n\"\n  \"0: la %r2,0(%r2,%r12)\\n\"\n  \"l %r4,1f-0b(%r3)\\n\"\n  \"b 0(%r4,%r3)\\n\"\n  \"1: .long __tls_get_addr_hidden - 0b\\n\"\n#endif\n  \".size __interceptor___tls_get_offset, .-__interceptor___tls_get_offset\\n\"\n// Assembly wrapper to call REAL(__tls_get_offset)(arg)\n  \".type __tls_get_offset_wrapper, @function\\n\"\n  \"__tls_get_offset_wrapper:\\n\"\n#ifdef __s390x__\n  \"sgr %r2,%r12\\n\"\n#else\n  \"sr %r2,%r12\\n\"\n#endif\n  \"br %r3\\n\"\n  \".size __tls_get_offset_wrapper, .-__tls_get_offset_wrapper\\n\"\n);\n#endif // SANITIZER_S390\n#else\n#define INIT_TLS_GET_ADDR\n#endif\n\n#if SANITIZER_INTERCEPT_LISTXATTR\nINTERCEPTOR(SSIZE_T, listxattr, const char *path, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, listxattr, path, list, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(listxattr)(path, list, size);\n  // Here and below, size == 0 is a special case where nothing is written to the\n  // buffer, and res contains the desired buffer size.\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, llistxattr, const char *path, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, llistxattr, path, list, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(llistxattr)(path, list, size);\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, flistxattr, int fd, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, flistxattr, fd, list, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(flistxattr)(fd, list, size);\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\n#define INIT_LISTXATTR                   \\\n  COMMON_INTERCEPT_FUNCTION(listxattr);  \\\n  COMMON_INTERCEPT_FUNCTION(llistxattr); \\\n  COMMON_INTERCEPT_FUNCTION(flistxattr);\n#else\n#define INIT_LISTXATTR\n#endif\n\n#if SANITIZER_INTERCEPT_GETXATTR\nINTERCEPTOR(SSIZE_T, getxattr, const char *path, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getxattr, path, name, value, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(getxattr)(path, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, lgetxattr, const char *path, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgetxattr, path, name, value, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(lgetxattr)(path, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, fgetxattr, int fd, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetxattr, fd, name, value, size);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(fgetxattr)(fd, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\n#define INIT_GETXATTR                   \\\n  COMMON_INTERCEPT_FUNCTION(getxattr);  \\\n  COMMON_INTERCEPT_FUNCTION(lgetxattr); \\\n  COMMON_INTERCEPT_FUNCTION(fgetxattr);\n#else\n#define INIT_GETXATTR\n#endif\n\n#if SANITIZER_INTERCEPT_GETRESID\nINTERCEPTOR(int, getresuid, void *ruid, void *euid, void *suid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getresuid, ruid, euid, suid);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getresuid)(ruid, euid, suid);\n  if (res >= 0) {\n    if (ruid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ruid, uid_t_sz);\n    if (euid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, euid, uid_t_sz);\n    if (suid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, suid, uid_t_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, getresgid, void *rgid, void *egid, void *sgid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getresgid, rgid, egid, sgid);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getresgid)(rgid, egid, sgid);\n  if (res >= 0) {\n    if (rgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rgid, gid_t_sz);\n    if (egid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, egid, gid_t_sz);\n    if (sgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sgid, gid_t_sz);\n  }\n  return res;\n}\n#define INIT_GETRESID                   \\\n  COMMON_INTERCEPT_FUNCTION(getresuid); \\\n  COMMON_INTERCEPT_FUNCTION(getresgid);\n#else\n#define INIT_GETRESID\n#endif\n\n#if SANITIZER_INTERCEPT_GETIFADDRS\n// As long as getifaddrs()/freeifaddrs() use calloc()/free(), we don't need to\n// intercept freeifaddrs(). If that ceases to be the case, we might need to\n// intercept it to poison the memory again.\nINTERCEPTOR(int, getifaddrs, __sanitizer_ifaddrs **ifap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getifaddrs, ifap);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getifaddrs)(ifap);\n  if (res == 0 && ifap) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifap, sizeof(void *));\n    __sanitizer_ifaddrs *p = *ifap;\n    while (p) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(__sanitizer_ifaddrs));\n      if (p->ifa_name)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_name,\n                                       REAL(strlen)(p->ifa_name) + 1);\n      if (p->ifa_addr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_addr, struct_sockaddr_sz);\n      if (p->ifa_netmask)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_netmask, struct_sockaddr_sz);\n      // On Linux this is a union, but the other member also points to a\n      // struct sockaddr, so the following is sufficient.\n      if (p->ifa_dstaddr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_dstaddr, struct_sockaddr_sz);\n      // FIXME(smatveev): Unpoison p->ifa_data as well.\n      p = p->ifa_next;\n    }\n  }\n  return res;\n}\n#define INIT_GETIFADDRS                  \\\n  COMMON_INTERCEPT_FUNCTION(getifaddrs);\n#else\n#define INIT_GETIFADDRS\n#endif\n\n#if SANITIZER_INTERCEPT_IF_INDEXTONAME\nINTERCEPTOR(char *, if_indextoname, unsigned int ifindex, char* ifname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, if_indextoname, ifindex, ifname);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(if_indextoname)(ifindex, ifname);\n  if (res && ifname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n  return res;\n}\nINTERCEPTOR(unsigned int, if_nametoindex, const char* ifname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, if_nametoindex, ifname);\n  if (ifname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n  return REAL(if_nametoindex)(ifname);\n}\n#define INIT_IF_INDEXTONAME                  \\\n  COMMON_INTERCEPT_FUNCTION(if_indextoname); \\\n  COMMON_INTERCEPT_FUNCTION(if_nametoindex);\n#else\n#define INIT_IF_INDEXTONAME\n#endif\n\n#if SANITIZER_INTERCEPT_CAPGET\nINTERCEPTOR(int, capget, void *hdrp, void *datap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, capget, hdrp, datap);\n  if (hdrp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(capget)(hdrp, datap);\n  if (res == 0 && datap)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datap, __user_cap_data_struct_sz);\n  // We can also return -1 and write to hdrp->version if the version passed in\n  // hdrp->version is unsupported. But that's not a trivial condition to check,\n  // and anyway COMMON_INTERCEPTOR_READ_RANGE protects us to some extent.\n  return res;\n}\nINTERCEPTOR(int, capset, void *hdrp, const void *datap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, capset, hdrp, datap);\n  if (hdrp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n  if (datap)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, datap, __user_cap_data_struct_sz);\n  return REAL(capset)(hdrp, datap);\n}\n#define INIT_CAPGET                  \\\n  COMMON_INTERCEPT_FUNCTION(capget); \\\n  COMMON_INTERCEPT_FUNCTION(capset);\n#else\n#define INIT_CAPGET\n#endif\n\n#if SANITIZER_INTERCEPT_AEABI_MEM\nDECLARE_REAL_AND_INTERCEPTOR(void *, memmove, void *, const void *, uptr)\nDECLARE_REAL_AND_INTERCEPTOR(void *, memcpy, void *, const void *, uptr)\nDECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr)\n\nINTERCEPTOR(void *, __aeabi_memmove, void *to, const void *from, uptr size) {\n  return WRAP(memmove)(to, from, size);\n}\nINTERCEPTOR(void *, __aeabi_memmove4, void *to, const void *from, uptr size) {\n  return WRAP(memmove)(to, from, size);\n}\nINTERCEPTOR(void *, __aeabi_memmove8, void *to, const void *from, uptr size) {\n  return WRAP(memmove)(to, from, size);\n}\nINTERCEPTOR(void *, __aeabi_memcpy, void *to, const void *from, uptr size) {\n  return WRAP(memcpy)(to, from, size);\n}\nINTERCEPTOR(void *, __aeabi_memcpy4, void *to, const void *from, uptr size) {\n  return WRAP(memcpy)(to, from, size);\n}\nINTERCEPTOR(void *, __aeabi_memcpy8, void *to, const void *from, uptr size) {\n  return WRAP(memcpy)(to, from, size);\n}\n// Note the argument order.\nINTERCEPTOR(void *, __aeabi_memset, void *block, uptr size, int c) {\n  return WRAP(memset)(block, c, size);\n}\nINTERCEPTOR(void *, __aeabi_memset4, void *block, uptr size, int c) {\n  return WRAP(memset)(block, c, size);\n}\nINTERCEPTOR(void *, __aeabi_memset8, void *block, uptr size, int c) {\n  return WRAP(memset)(block, c, size);\n}\nINTERCEPTOR(void *, __aeabi_memclr, void *block, uptr size) {\n  return WRAP(memset)(block, 0, size);\n}\nINTERCEPTOR(void *, __aeabi_memclr4, void *block, uptr size) {\n  return WRAP(memset)(block, 0, size);\n}\nINTERCEPTOR(void *, __aeabi_memclr8, void *block, uptr size) {\n  return WRAP(memset)(block, 0, size);\n}\n#define INIT_AEABI_MEM                         \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove4); \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove8); \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy8);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset8);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr8);\n#else\n#define INIT_AEABI_MEM\n#endif  // SANITIZER_INTERCEPT_AEABI_MEM\n\n#if SANITIZER_INTERCEPT___BZERO\nDECLARE_REAL_AND_INTERCEPTOR(void *, memset, void *, int, uptr);\n\nINTERCEPTOR(void *, __bzero, void *block, uptr size) {\n  return WRAP(memset)(block, 0, size);\n}\n#define INIT___BZERO COMMON_INTERCEPT_FUNCTION(__bzero);\n#else\n#define INIT___BZERO\n#endif  // SANITIZER_INTERCEPT___BZERO\n\n#if SANITIZER_INTERCEPT_FTIME\nINTERCEPTOR(int, ftime, __sanitizer_timeb *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ftime, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ftime)(tp);\n  if (tp)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, sizeof(*tp));\n  return res;\n}\n#define INIT_FTIME COMMON_INTERCEPT_FUNCTION(ftime);\n#else\n#define INIT_FTIME\n#endif  // SANITIZER_INTERCEPT_FTIME\n\n#if SANITIZER_INTERCEPT_XDR\nINTERCEPTOR(void, xdrmem_create, __sanitizer_XDR *xdrs, uptr addr,\n            unsigned size, int op) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdrmem_create, xdrs, addr, size, op);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(xdrmem_create)(xdrs, addr, size, op);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n  if (op == __sanitizer_XDR_ENCODE) {\n    // It's not obvious how much data individual xdr_ routines write.\n    // Simply unpoison the entire target buffer in advance.\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (void *)addr, size);\n  }\n}\n\nINTERCEPTOR(void, xdrstdio_create, __sanitizer_XDR *xdrs, void *file, int op) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdrstdio_create, xdrs, file, op);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(xdrstdio_create)(xdrs, file, op);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n}\n\n// FIXME: under ASan the call below may write to freed memory and corrupt\n// its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define XDR_INTERCEPTOR(F, T)                             \\\n  INTERCEPTOR(int, F, __sanitizer_XDR *xdrs, T *p) {      \\\n    void *ctx;                                            \\\n    COMMON_INTERCEPTOR_ENTER(ctx, F, xdrs, p);            \\\n    if (p && xdrs->x_op == __sanitizer_XDR_ENCODE)        \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));  \\\n    int res = REAL(F)(xdrs, p);                           \\\n    if (res && p && xdrs->x_op == __sanitizer_XDR_DECODE) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p)); \\\n    return res;                                           \\\n  }\n\nXDR_INTERCEPTOR(xdr_short, short)\nXDR_INTERCEPTOR(xdr_u_short, unsigned short)\nXDR_INTERCEPTOR(xdr_int, int)\nXDR_INTERCEPTOR(xdr_u_int, unsigned)\nXDR_INTERCEPTOR(xdr_long, long)\nXDR_INTERCEPTOR(xdr_u_long, unsigned long)\nXDR_INTERCEPTOR(xdr_hyper, long long)\nXDR_INTERCEPTOR(xdr_u_hyper, unsigned long long)\nXDR_INTERCEPTOR(xdr_longlong_t, long long)\nXDR_INTERCEPTOR(xdr_u_longlong_t, unsigned long long)\nXDR_INTERCEPTOR(xdr_int8_t, u8)\nXDR_INTERCEPTOR(xdr_uint8_t, u8)\nXDR_INTERCEPTOR(xdr_int16_t, u16)\nXDR_INTERCEPTOR(xdr_uint16_t, u16)\nXDR_INTERCEPTOR(xdr_int32_t, u32)\nXDR_INTERCEPTOR(xdr_uint32_t, u32)\nXDR_INTERCEPTOR(xdr_int64_t, u64)\nXDR_INTERCEPTOR(xdr_uint64_t, u64)\nXDR_INTERCEPTOR(xdr_quad_t, long long)\nXDR_INTERCEPTOR(xdr_u_quad_t, unsigned long long)\nXDR_INTERCEPTOR(xdr_bool, bool)\nXDR_INTERCEPTOR(xdr_enum, int)\nXDR_INTERCEPTOR(xdr_char, char)\nXDR_INTERCEPTOR(xdr_u_char, unsigned char)\nXDR_INTERCEPTOR(xdr_float, float)\nXDR_INTERCEPTOR(xdr_double, double)\n\n// FIXME: intercept xdr_array, opaque, union, vector, reference, pointer,\n// wrapstring, sizeof\n\nINTERCEPTOR(int, xdr_bytes, __sanitizer_XDR *xdrs, char **p, unsigned *sizep,\n            unsigned maxsize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdr_bytes, xdrs, p, sizep, maxsize);\n  if (p && sizep && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sizep, sizeof(*sizep));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, *sizep);\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(xdr_bytes)(xdrs, p, sizep, maxsize);\n  if (p && sizep && xdrs->x_op == __sanitizer_XDR_DECODE) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizep, sizeof(*sizep));\n    if (res && *p && *sizep) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, *sizep);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, xdr_string, __sanitizer_XDR *xdrs, char **p,\n            unsigned maxsize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdr_string, xdrs, p, maxsize);\n  if (p && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(xdr_string)(xdrs, p, maxsize);\n  if (p && xdrs->x_op == __sanitizer_XDR_DECODE) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    if (res && *p)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n  }\n  return res;\n}\n\n#define INIT_XDR                               \\\n  COMMON_INTERCEPT_FUNCTION(xdrmem_create);    \\\n  COMMON_INTERCEPT_FUNCTION(xdrstdio_create);  \\\n  COMMON_INTERCEPT_FUNCTION(xdr_short);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_short);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int);          \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_int);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_long);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_long);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_hyper);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_hyper);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_longlong_t);   \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_longlong_t); \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int8_t);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint8_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int16_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint16_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int32_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint32_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int64_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint64_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_quad_t);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_quad_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_bool);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_enum);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_char);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_char);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_float);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_double);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_bytes);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_string);\n#else\n#define INIT_XDR\n#endif  // SANITIZER_INTERCEPT_XDR\n\n#if SANITIZER_INTERCEPT_TSEARCH\nINTERCEPTOR(void *, tsearch, void *key, void **rootp,\n            int (*compar)(const void *, const void *)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tsearch, key, rootp, compar);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  void *res = REAL(tsearch)(key, rootp, compar);\n  if (res && *(void **)res == key)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(void *));\n  return res;\n}\n#define INIT_TSEARCH COMMON_INTERCEPT_FUNCTION(tsearch);\n#else\n#define INIT_TSEARCH\n#endif\n\n#if SANITIZER_INTERCEPT_LIBIO_INTERNALS || SANITIZER_INTERCEPT_FOPEN || \\\n    SANITIZER_INTERCEPT_OPEN_MEMSTREAM\nvoid unpoison_file(__sanitizer_FILE *fp) {\n#if SANITIZER_HAS_STRUCT_FILE\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp, sizeof(*fp));\n  if (fp->_IO_read_base && fp->_IO_read_base < fp->_IO_read_end)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_read_base,\n                                        fp->_IO_read_end - fp->_IO_read_base);\n#endif  // SANITIZER_HAS_STRUCT_FILE\n}\n#endif\n\n#if SANITIZER_INTERCEPT_LIBIO_INTERNALS\n// These guys are called when a .c source is built with -O2.\nINTERCEPTOR(int, __uflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __uflow, fp);\n  int res = REAL(__uflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __underflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __underflow, fp);\n  int res = REAL(__underflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __overflow, __sanitizer_FILE *fp, int ch) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __overflow, fp, ch);\n  int res = REAL(__overflow)(fp, ch);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __wuflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wuflow, fp);\n  int res = REAL(__wuflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __wunderflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wunderflow, fp);\n  int res = REAL(__wunderflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __woverflow, __sanitizer_FILE *fp, int ch) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __woverflow, fp, ch);\n  int res = REAL(__woverflow)(fp, ch);\n  unpoison_file(fp);\n  return res;\n}\n#define INIT_LIBIO_INTERNALS               \\\n  COMMON_INTERCEPT_FUNCTION(__uflow);      \\\n  COMMON_INTERCEPT_FUNCTION(__underflow);  \\\n  COMMON_INTERCEPT_FUNCTION(__overflow);   \\\n  COMMON_INTERCEPT_FUNCTION(__wuflow);     \\\n  COMMON_INTERCEPT_FUNCTION(__wunderflow); \\\n  COMMON_INTERCEPT_FUNCTION(__woverflow);\n#else\n#define INIT_LIBIO_INTERNALS\n#endif\n\n#if SANITIZER_INTERCEPT_FOPEN\nINTERCEPTOR(__sanitizer_FILE *, fopen, const char *path, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopen, path, mode);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fopen)(path, mode);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, fdopen, int fd, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fdopen, fd, mode);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fdopen)(fd, mode);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, freopen, const char *path, const char *mode,\n            __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, freopen, path, mode, fp);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  __sanitizer_FILE *res = REAL(freopen)(path, mode, fp);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_FOPEN                   \\\n  COMMON_INTERCEPT_FUNCTION(fopen);  \\\n  COMMON_INTERCEPT_FUNCTION(fdopen); \\\n  COMMON_INTERCEPT_FUNCTION(freopen);\n#else\n#define INIT_FOPEN\n#endif\n\n#if SANITIZER_INTERCEPT_FOPEN64\nINTERCEPTOR(__sanitizer_FILE *, fopen64, const char *path, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopen64, path, mode);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fopen64)(path, mode);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, freopen64, const char *path, const char *mode,\n            __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, freopen64, path, mode, fp);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  __sanitizer_FILE *res = REAL(freopen64)(path, mode, fp);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_FOPEN64                  \\\n  COMMON_INTERCEPT_FUNCTION(fopen64); \\\n  COMMON_INTERCEPT_FUNCTION(freopen64);\n#else\n#define INIT_FOPEN64\n#endif\n\n#if SANITIZER_INTERCEPT_OPEN_MEMSTREAM\nINTERCEPTOR(__sanitizer_FILE *, open_memstream, char **ptr, SIZE_T *sizeloc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, open_memstream, ptr, sizeloc);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_FILE *res = REAL(open_memstream)(ptr, sizeloc);\n  if (res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n    unpoison_file(res);\n    FileMetadata file = {ptr, sizeloc};\n    SetInterceptorMetadata(res, file);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, open_wmemstream, wchar_t **ptr,\n            SIZE_T *sizeloc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, open_wmemstream, ptr, sizeloc);\n  __sanitizer_FILE *res = REAL(open_wmemstream)(ptr, sizeloc);\n  if (res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n    unpoison_file(res);\n    FileMetadata file = {(char **)ptr, sizeloc};\n    SetInterceptorMetadata(res, file);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, fmemopen, void *buf, SIZE_T size,\n            const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fmemopen, buf, size, mode);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_FILE *res = REAL(fmemopen)(buf, size, mode);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_OPEN_MEMSTREAM                   \\\n  COMMON_INTERCEPT_FUNCTION(open_memstream);  \\\n  COMMON_INTERCEPT_FUNCTION(open_wmemstream); \\\n  COMMON_INTERCEPT_FUNCTION(fmemopen);\n#else\n#define INIT_OPEN_MEMSTREAM\n#endif\n\n#if SANITIZER_INTERCEPT_OBSTACK\nstatic void initialize_obstack(__sanitizer_obstack *obstack) {\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack, sizeof(*obstack));\n  if (obstack->chunk)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack->chunk,\n                                        sizeof(*obstack->chunk));\n}\n\nINTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack, int sz,\n            int align, void *(*alloc_fn)(uptr arg, uptr sz),\n            void (*free_fn)(uptr arg, void *p)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin_1, obstack, sz, align, alloc_fn,\n                           free_fn);\n  int res = REAL(_obstack_begin_1)(obstack, sz, align, alloc_fn, free_fn);\n  if (res) initialize_obstack(obstack);\n  return res;\n}\nINTERCEPTOR(int, _obstack_begin, __sanitizer_obstack *obstack, int sz,\n            int align, void *(*alloc_fn)(uptr sz), void (*free_fn)(void *p)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin, obstack, sz, align, alloc_fn,\n                           free_fn);\n  int res = REAL(_obstack_begin)(obstack, sz, align, alloc_fn, free_fn);\n  if (res) initialize_obstack(obstack);\n  return res;\n}\nINTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack, int length) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_newchunk, obstack, length);\n  REAL(_obstack_newchunk)(obstack, length);\n  if (obstack->chunk)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(\n        obstack->chunk, obstack->next_free - (char *)obstack->chunk);\n}\n#define INIT_OBSTACK                           \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_begin_1); \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_begin);   \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_newchunk);\n#else\n#define INIT_OBSTACK\n#endif\n\n#if SANITIZER_INTERCEPT_FFLUSH\nINTERCEPTOR(int, fflush, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fflush, fp);\n  int res = REAL(fflush)(fp);\n  // FIXME: handle fp == NULL\n  if (fp) {\n    const FileMetadata *m = GetInterceptorMetadata(fp);\n    if (m) COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n  }\n  return res;\n}\n#define INIT_FFLUSH COMMON_INTERCEPT_FUNCTION(fflush);\n#else\n#define INIT_FFLUSH\n#endif\n\n#if SANITIZER_INTERCEPT_FCLOSE\nINTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fclose, fp);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  const FileMetadata *m = GetInterceptorMetadata(fp);\n  int res = REAL(fclose)(fp);\n  if (m) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n    DeleteInterceptorMetadata(fp);\n  }\n  return res;\n}\n#define INIT_FCLOSE COMMON_INTERCEPT_FUNCTION(fclose);\n#else\n#define INIT_FCLOSE\n#endif\n\n#if SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\nINTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlopen, filename, flag);\n  if (filename) COMMON_INTERCEPTOR_READ_STRING(ctx, filename, 0);\n  COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag);\n  void *res = REAL(dlopen)(filename, flag);\n  COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res);\n  return res;\n}\n\nINTERCEPTOR(int, dlclose, void *handle) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlclose, handle);\n  int res = REAL(dlclose)(handle);\n  COMMON_INTERCEPTOR_LIBRARY_UNLOADED();\n  return res;\n}\n#define INIT_DLOPEN_DLCLOSE          \\\n  COMMON_INTERCEPT_FUNCTION(dlopen); \\\n  COMMON_INTERCEPT_FUNCTION(dlclose);\n#else\n#define INIT_DLOPEN_DLCLOSE\n#endif\n\n#if SANITIZER_INTERCEPT_GETPASS\nINTERCEPTOR(char *, getpass, const char *prompt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpass, prompt);\n  if (prompt)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, prompt, REAL(strlen)(prompt)+1);\n  char *res = REAL(getpass)(prompt);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res)+1);\n  return res;\n}\n\n#define INIT_GETPASS COMMON_INTERCEPT_FUNCTION(getpass);\n#else\n#define INIT_GETPASS\n#endif\n\n#if SANITIZER_INTERCEPT_TIMERFD\nINTERCEPTOR(int, timerfd_settime, int fd, int flags, void *new_value,\n            void *old_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_settime, fd, flags, new_value,\n                           old_value);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerspec_sz);\n  int res = REAL(timerfd_settime)(fd, flags, new_value, old_value);\n  if (res != -1 && old_value)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerspec_sz);\n  return res;\n}\n\nINTERCEPTOR(int, timerfd_gettime, int fd, void *curr_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_gettime, fd, curr_value);\n  int res = REAL(timerfd_gettime)(fd, curr_value);\n  if (res != -1 && curr_value)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerspec_sz);\n  return res;\n}\n#define INIT_TIMERFD                          \\\n  COMMON_INTERCEPT_FUNCTION(timerfd_settime); \\\n  COMMON_INTERCEPT_FUNCTION(timerfd_gettime);\n#else\n#define INIT_TIMERFD\n#endif\n\n#if SANITIZER_INTERCEPT_MLOCKX\n// Linux kernel has a bug that leads to kernel deadlock if a process\n// maps TBs of memory and then calls mlock().\nstatic void MlockIsUnsupported() {\n  static atomic_uint8_t printed;\n  if (atomic_exchange(&printed, 1, memory_order_relaxed))\n    return;\n  VPrintf(1, \"%s ignores mlock/mlockall/munlock/munlockall\\n\",\n          SanitizerToolName);\n}\n\nINTERCEPTOR(int, mlock, const void *addr, uptr len) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, munlock, const void *addr, uptr len) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, mlockall, int flags) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, munlockall, void) {\n  MlockIsUnsupported();\n  return 0;\n}\n\n#define INIT_MLOCKX                                                            \\\n  COMMON_INTERCEPT_FUNCTION(mlock);                                            \\\n  COMMON_INTERCEPT_FUNCTION(munlock);                                          \\\n  COMMON_INTERCEPT_FUNCTION(mlockall);                                         \\\n  COMMON_INTERCEPT_FUNCTION(munlockall);\n\n#else\n#define INIT_MLOCKX\n#endif  // SANITIZER_INTERCEPT_MLOCKX\n\n#if SANITIZER_INTERCEPT_FOPENCOOKIE\nstruct WrappedCookie {\n  void *real_cookie;\n  __sanitizer_cookie_io_functions_t real_io_funcs;\n};\n\nstatic uptr wrapped_read(void *cookie, char *buf, uptr size) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_read real_read = wrapped_cookie->real_io_funcs.read;\n  return real_read ? real_read(wrapped_cookie->real_cookie, buf, size) : 0;\n}\n\nstatic uptr wrapped_write(void *cookie, const char *buf, uptr size) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_write real_write = wrapped_cookie->real_io_funcs.write;\n  return real_write ? real_write(wrapped_cookie->real_cookie, buf, size) : size;\n}\n\nstatic int wrapped_seek(void *cookie, u64 *offset, int whence) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(offset, sizeof(*offset));\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_seek real_seek = wrapped_cookie->real_io_funcs.seek;\n  return real_seek ? real_seek(wrapped_cookie->real_cookie, offset, whence)\n                   : -1;\n}\n\nstatic int wrapped_close(void *cookie) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_close real_close = wrapped_cookie->real_io_funcs.close;\n  int res = real_close ? real_close(wrapped_cookie->real_cookie) : 0;\n  InternalFree(wrapped_cookie);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_FILE *, fopencookie, void *cookie, const char *mode,\n            __sanitizer_cookie_io_functions_t io_funcs) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopencookie, cookie, mode, io_funcs);\n  WrappedCookie *wrapped_cookie =\n      (WrappedCookie *)InternalAlloc(sizeof(WrappedCookie));\n  wrapped_cookie->real_cookie = cookie;\n  wrapped_cookie->real_io_funcs = io_funcs;\n  __sanitizer_FILE *res =\n      REAL(fopencookie)(wrapped_cookie, mode, {wrapped_read, wrapped_write,\n                                               wrapped_seek, wrapped_close});\n  return res;\n}\n\n#define INIT_FOPENCOOKIE COMMON_INTERCEPT_FUNCTION(fopencookie);\n#else\n#define INIT_FOPENCOOKIE\n#endif  // SANITIZER_INTERCEPT_FOPENCOOKIE\n\n#if SANITIZER_INTERCEPT_SEM\nINTERCEPTOR(int, sem_init, __sanitizer_sem_t *s, int pshared, unsigned value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_init, s, pshared, value);\n  // Workaround a bug in glibc's \"old\" semaphore implementation by\n  // zero-initializing the sem_t contents. This has to be done here because\n  // interceptors bind to the lowest symbols version by default, hitting the\n  // buggy code path while the non-sanitized build of the same code works fine.\n  REAL(memset)(s, 0, sizeof(*s));\n  int res = REAL(sem_init)(s, pshared, value);\n  return res;\n}\n\nINTERCEPTOR(int, sem_destroy, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_destroy, s);\n  int res = REAL(sem_destroy)(s);\n  return res;\n}\n\nINTERCEPTOR(int, sem_wait, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_wait, s);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_wait)(s);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_trywait, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_trywait, s);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_trywait)(s);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_timedwait, __sanitizer_sem_t *s, void *abstime) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_timedwait, s, abstime);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, abstime, struct_timespec_sz);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_timedwait)(s, abstime);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_post, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_post, s);\n  COMMON_INTERCEPTOR_RELEASE(ctx, (uptr)s);\n  int res = REAL(sem_post)(s);\n  return res;\n}\n\nINTERCEPTOR(int, sem_getvalue, __sanitizer_sem_t *s, int *sval) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_getvalue, s, sval);\n  int res = REAL(sem_getvalue)(s, sval);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sval, sizeof(*sval));\n  }\n  return res;\n}\n#define INIT_SEM                                                               \\\n  COMMON_INTERCEPT_FUNCTION(sem_init);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_destroy);                                      \\\n  COMMON_INTERCEPT_FUNCTION(sem_wait);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_trywait);                                      \\\n  COMMON_INTERCEPT_FUNCTION(sem_timedwait);                                    \\\n  COMMON_INTERCEPT_FUNCTION(sem_post);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_getvalue);\n#else\n#define INIT_SEM\n#endif // SANITIZER_INTERCEPT_SEM\n\n#if SANITIZER_INTERCEPT_PTHREAD_SETCANCEL\nINTERCEPTOR(int, pthread_setcancelstate, int state, int *oldstate) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcancelstate, state, oldstate);\n  int res = REAL(pthread_setcancelstate)(state, oldstate);\n  if (res == 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldstate, sizeof(*oldstate));\n  return res;\n}\n\nINTERCEPTOR(int, pthread_setcanceltype, int type, int *oldtype) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcanceltype, type, oldtype);\n  int res = REAL(pthread_setcanceltype)(type, oldtype);\n  if (res == 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldtype, sizeof(*oldtype));\n  return res;\n}\n#define INIT_PTHREAD_SETCANCEL                                                 \\\n  COMMON_INTERCEPT_FUNCTION(pthread_setcancelstate);                           \\\n  COMMON_INTERCEPT_FUNCTION(pthread_setcanceltype);\n#else\n#define INIT_PTHREAD_SETCANCEL\n#endif\n\n#if SANITIZER_INTERCEPT_MINCORE\nINTERCEPTOR(int, mincore, void *addr, uptr length, unsigned char *vec) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mincore, addr, length, vec);\n  int res = REAL(mincore)(addr, length, vec);\n  if (res == 0) {\n    uptr page_size = GetPageSizeCached();\n    uptr vec_size = ((length + page_size - 1) & (~(page_size - 1))) / page_size;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, vec, vec_size);\n  }\n  return res;\n}\n#define INIT_MINCORE COMMON_INTERCEPT_FUNCTION(mincore);\n#else\n#define INIT_MINCORE\n#endif\n\n#if SANITIZER_INTERCEPT_PROCESS_VM_READV\nINTERCEPTOR(SSIZE_T, process_vm_readv, int pid, __sanitizer_iovec *local_iov,\n            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n            uptr flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_readv, pid, local_iov, liovcnt,\n                           remote_iov, riovcnt, flags);\n  SSIZE_T res = REAL(process_vm_readv)(pid, local_iov, liovcnt, remote_iov,\n                                       riovcnt, flags);\n  if (res > 0)\n    write_iovec(ctx, local_iov, liovcnt, res);\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, process_vm_writev, int pid, __sanitizer_iovec *local_iov,\n            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n            uptr flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_writev, pid, local_iov, liovcnt,\n                           remote_iov, riovcnt, flags);\n  SSIZE_T res = REAL(process_vm_writev)(pid, local_iov, liovcnt, remote_iov,\n                                        riovcnt, flags);\n  if (res > 0)\n    read_iovec(ctx, local_iov, liovcnt, res);\n  return res;\n}\n#define INIT_PROCESS_VM_READV                                                  \\\n  COMMON_INTERCEPT_FUNCTION(process_vm_readv);                                 \\\n  COMMON_INTERCEPT_FUNCTION(process_vm_writev);\n#else\n#define INIT_PROCESS_VM_READV\n#endif\n\n#if SANITIZER_INTERCEPT_CTERMID\nINTERCEPTOR(char *, ctermid, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctermid, s);\n  char *res = REAL(ctermid)(s);\n  if (res) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_CTERMID COMMON_INTERCEPT_FUNCTION(ctermid);\n#else\n#define INIT_CTERMID\n#endif\n\n#if SANITIZER_INTERCEPT_CTERMID_R\nINTERCEPTOR(char *, ctermid_r, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctermid_r, s);\n  char *res = REAL(ctermid_r)(s);\n  if (res) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_CTERMID_R COMMON_INTERCEPT_FUNCTION(ctermid_r);\n#else\n#define INIT_CTERMID_R\n#endif\n\n#if SANITIZER_INTERCEPT_RECV_RECVFROM\nINTERCEPTOR(SSIZE_T, recv, int fd, void *buf, SIZE_T len, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recv, fd, buf, len, flags);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(recv)(fd, buf, len, flags);\n  if (res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  }\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, recvfrom, int fd, void *buf, SIZE_T len, int flags,\n            void *srcaddr, int *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recvfrom, fd, buf, len, flags, srcaddr,\n                           addrlen);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SIZE_T srcaddr_sz;\n  if (srcaddr) srcaddr_sz = *addrlen;\n  (void)srcaddr_sz;  // prevent \"set but not used\" warning\n  SSIZE_T res = REAL(recvfrom)(fd, buf, len, flags, srcaddr, addrlen);\n  if (res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, Min((SIZE_T)res, len));\n    if (srcaddr)\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(srcaddr,\n                                          Min((SIZE_T)*addrlen, srcaddr_sz));\n  }\n  return res;\n}\n#define INIT_RECV_RECVFROM          \\\n  COMMON_INTERCEPT_FUNCTION(recv);  \\\n  COMMON_INTERCEPT_FUNCTION(recvfrom);\n#else\n#define INIT_RECV_RECVFROM\n#endif\n\n#if SANITIZER_INTERCEPT_SEND_SENDTO\nINTERCEPTOR(SSIZE_T, send, int fd, void *buf, SIZE_T len, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, send, fd, buf, len, flags);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  SSIZE_T res = REAL(send)(fd, buf, len, flags);\n  if (common_flags()->intercept_send && res > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, sendto, int fd, void *buf, SIZE_T len, int flags,\n            void *dstaddr, int addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sendto, fd, buf, len, flags, dstaddr, addrlen);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  // Can't check dstaddr as it may have uninitialized padding at the end.\n  SSIZE_T res = REAL(sendto)(fd, buf, len, flags, dstaddr, addrlen);\n  if (common_flags()->intercept_send && res > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  return res;\n}\n#define INIT_SEND_SENDTO           \\\n  COMMON_INTERCEPT_FUNCTION(send); \\\n  COMMON_INTERCEPT_FUNCTION(sendto);\n#else\n#define INIT_SEND_SENDTO\n#endif\n\n#if SANITIZER_INTERCEPT_EVENTFD_READ_WRITE\nINTERCEPTOR(int, eventfd_read, int fd, u64 *value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, eventfd_read, fd, value);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  int res = REAL(eventfd_read)(fd, value);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, sizeof(*value));\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return res;\n}\nINTERCEPTOR(int, eventfd_write, int fd, u64 value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, eventfd_write, fd, value);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  int res = REAL(eventfd_write)(fd, value);\n  return res;\n}\n#define INIT_EVENTFD_READ_WRITE            \\\n  COMMON_INTERCEPT_FUNCTION(eventfd_read); \\\n  COMMON_INTERCEPT_FUNCTION(eventfd_write)\n#else\n#define INIT_EVENTFD_READ_WRITE\n#endif\n\n#if SANITIZER_INTERCEPT_STAT\nINTERCEPTOR(int, stat, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, stat, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(stat)(path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT_STAT COMMON_INTERCEPT_FUNCTION(stat)\n#else\n#define INIT_STAT\n#endif\n\n#if SANITIZER_INTERCEPT___XSTAT\nINTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xstat, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__xstat)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT___XSTAT COMMON_INTERCEPT_FUNCTION(__xstat)\n#else\n#define INIT___XSTAT\n#endif\n\n#if SANITIZER_INTERCEPT___XSTAT64\nINTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xstat64, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__xstat64)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat64_sz);\n  return res;\n}\n#define INIT___XSTAT64 COMMON_INTERCEPT_FUNCTION(__xstat64)\n#else\n#define INIT___XSTAT64\n#endif\n\n#if SANITIZER_INTERCEPT___LXSTAT\nINTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __lxstat, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__lxstat)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT___LXSTAT COMMON_INTERCEPT_FUNCTION(__lxstat)\n#else\n#define INIT___LXSTAT\n#endif\n\n#if SANITIZER_INTERCEPT___LXSTAT64\nINTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __lxstat64, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__lxstat64)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat64_sz);\n  return res;\n}\n#define INIT___LXSTAT64 COMMON_INTERCEPT_FUNCTION(__lxstat64)\n#else\n#define INIT___LXSTAT64\n#endif\n\n// FIXME: add other *stat interceptor\n\nstatic void InitializeCommonInterceptors() {\n  static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n  interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n\n  INIT_TEXTDOMAIN;\n  INIT_STRLEN;\n  INIT_STRNLEN;\n  INIT_STRCMP;\n  INIT_STRNCMP;\n  INIT_STRCASECMP;\n  INIT_STRNCASECMP;\n  INIT_STRSTR;\n  INIT_STRCASESTR;\n  INIT_STRCHR;\n  INIT_STRCHRNUL;\n  INIT_STRRCHR;\n  INIT_STRSPN;\n  INIT_STRPBRK;\n  INIT_MEMSET;\n  INIT_MEMMOVE;\n  INIT_MEMCPY;\n  INIT_MEMCHR;\n  INIT_MEMCMP;\n  INIT_MEMRCHR;\n  INIT_MEMMEM;\n  INIT_READ;\n  INIT_PREAD;\n  INIT_PREAD64;\n  INIT_READV;\n  INIT_PREADV;\n  INIT_PREADV64;\n  INIT_WRITE;\n  INIT_PWRITE;\n  INIT_PWRITE64;\n  INIT_WRITEV;\n  INIT_PWRITEV;\n  INIT_PWRITEV64;\n  INIT_PRCTL;\n  INIT_LOCALTIME_AND_FRIENDS;\n  INIT_STRPTIME;\n  INIT_SCANF;\n  INIT_ISOC99_SCANF;\n  INIT_PRINTF;\n  INIT_PRINTF_L;\n  INIT_ISOC99_PRINTF;\n  INIT_FREXP;\n  INIT_FREXPF_FREXPL;\n  INIT_GETPWNAM_AND_FRIENDS;\n  INIT_GETPWNAM_R_AND_FRIENDS;\n  INIT_GETPWENT;\n  INIT_FGETPWENT;\n  INIT_GETPWENT_R;\n  INIT_SETPWENT;\n  INIT_CLOCK_GETTIME;\n  INIT_GETITIMER;\n  INIT_TIME;\n  INIT_GLOB;\n  INIT_WAIT;\n  INIT_WAIT4;\n  INIT_INET;\n  INIT_PTHREAD_GETSCHEDPARAM;\n  INIT_GETADDRINFO;\n  INIT_GETNAMEINFO;\n  INIT_GETSOCKNAME;\n  INIT_GETHOSTBYNAME;\n  INIT_GETHOSTBYNAME_R;\n  INIT_GETHOSTBYNAME2_R;\n  INIT_GETHOSTBYADDR_R;\n  INIT_GETHOSTENT_R;\n  INIT_GETSOCKOPT;\n  INIT_ACCEPT;\n  INIT_ACCEPT4;\n  INIT_MODF;\n  INIT_RECVMSG;\n  INIT_SENDMSG;\n  INIT_GETPEERNAME;\n  INIT_IOCTL;\n  INIT_INET_ATON;\n  INIT_SYSINFO;\n  INIT_READDIR;\n  INIT_READDIR64;\n  INIT_PTRACE;\n  INIT_SETLOCALE;\n  INIT_GETCWD;\n  INIT_GET_CURRENT_DIR_NAME;\n  INIT_STRTOIMAX;\n  INIT_MBSTOWCS;\n  INIT_MBSNRTOWCS;\n  INIT_WCSTOMBS;\n  INIT_WCSNRTOMBS;\n  INIT_WCRTOMB;\n  INIT_TCGETATTR;\n  INIT_REALPATH;\n  INIT_CANONICALIZE_FILE_NAME;\n  INIT_CONFSTR;\n  INIT_SCHED_GETAFFINITY;\n  INIT_SCHED_GETPARAM;\n  INIT_STRERROR;\n  INIT_STRERROR_R;\n  INIT_XPG_STRERROR_R;\n  INIT_SCANDIR;\n  INIT_SCANDIR64;\n  INIT_GETGROUPS;\n  INIT_POLL;\n  INIT_PPOLL;\n  INIT_WORDEXP;\n  INIT_SIGWAIT;\n  INIT_SIGWAITINFO;\n  INIT_SIGTIMEDWAIT;\n  INIT_SIGSETOPS;\n  INIT_SIGPENDING;\n  INIT_SIGPROCMASK;\n  INIT_BACKTRACE;\n  INIT__EXIT;\n  INIT_PTHREAD_MUTEX_LOCK;\n  INIT_PTHREAD_MUTEX_UNLOCK;\n  INIT_GETMNTENT;\n  INIT_GETMNTENT_R;\n  INIT_STATFS;\n  INIT_STATFS64;\n  INIT_STATVFS;\n  INIT_STATVFS64;\n  INIT_INITGROUPS;\n  INIT_ETHER_NTOA_ATON;\n  INIT_ETHER_HOST;\n  INIT_ETHER_R;\n  INIT_SHMCTL;\n  INIT_RANDOM_R;\n  INIT_PTHREAD_ATTR_GET;\n  INIT_PTHREAD_ATTR_GETINHERITSCHED;\n  INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n  INIT_PTHREAD_MUTEXATTR_GETPSHARED;\n  INIT_PTHREAD_MUTEXATTR_GETTYPE;\n  INIT_PTHREAD_MUTEXATTR_GETPROTOCOL;\n  INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING;\n  INIT_PTHREAD_MUTEXATTR_GETROBUST;\n  INIT_PTHREAD_MUTEXATTR_GETROBUST_NP;\n  INIT_PTHREAD_RWLOCKATTR_GETPSHARED;\n  INIT_PTHREAD_RWLOCKATTR_GETKIND_NP;\n  INIT_PTHREAD_CONDATTR_GETPSHARED;\n  INIT_PTHREAD_CONDATTR_GETCLOCK;\n  INIT_PTHREAD_BARRIERATTR_GETPSHARED;\n  INIT_TMPNAM;\n  INIT_TMPNAM_R;\n  INIT_TTYNAME_R;\n  INIT_TEMPNAM;\n  INIT_PTHREAD_SETNAME_NP;\n  INIT_SINCOS;\n  INIT_REMQUO;\n  INIT_LGAMMA;\n  INIT_LGAMMA_R;\n  INIT_LGAMMAL_R;\n  INIT_DRAND48_R;\n  INIT_RAND_R;\n  INIT_GETLINE;\n  INIT_ICONV;\n  INIT_TIMES;\n  INIT_TLS_GET_ADDR;\n  INIT_LISTXATTR;\n  INIT_GETXATTR;\n  INIT_GETRESID;\n  INIT_GETIFADDRS;\n  INIT_IF_INDEXTONAME;\n  INIT_CAPGET;\n  INIT_AEABI_MEM;\n  INIT___BZERO;\n  INIT_FTIME;\n  INIT_XDR;\n  INIT_TSEARCH;\n  INIT_LIBIO_INTERNALS;\n  INIT_FOPEN;\n  INIT_FOPEN64;\n  INIT_OPEN_MEMSTREAM;\n  INIT_OBSTACK;\n  INIT_FFLUSH;\n  INIT_FCLOSE;\n  INIT_DLOPEN_DLCLOSE;\n  INIT_GETPASS;\n  INIT_TIMERFD;\n  INIT_MLOCKX;\n  INIT_FOPENCOOKIE;\n  INIT_SEM;\n  INIT_PTHREAD_SETCANCEL;\n  INIT_MINCORE;\n  INIT_PROCESS_VM_READV;\n  INIT_CTERMID;\n  INIT_CTERMID_R;\n  INIT_RECV_RECVFROM;\n  INIT_SEND_SENDTO;\n  INIT_STAT;\n  INIT_EVENTFD_READ_WRITE;\n  INIT___XSTAT;\n  INIT___XSTAT64;\n  INIT___LXSTAT;\n  INIT___LXSTAT64;\n  // FIXME: add other *stat interceptors.\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc": "//===-- sanitizer_malloc_mac.inc --------------------------------*- C++ -*-===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains Mac-specific malloc interceptors and a custom zone\n// implementation, which together replace the system allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_common/sanitizer_platform.h\"\n#if !SANITIZER_MAC\n#error \"This file should only be compiled on Darwin.\"\n#endif\n\n#include <AvailabilityMacros.h>\n#include <CoreFoundation/CFBase.h>\n#include <dlfcn.h>\n#include <malloc/malloc.h>\n#include <sys/mman.h>\n\n#include \"interception/interception.h\"\n#include \"sanitizer_common/sanitizer_mac.h\"\n\n// Similar code is used in Google Perftools,\n// https://github.com/gperftools/gperftools.\n\nstatic malloc_zone_t sanitizer_zone;\n\nINTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n                             vm_size_t start_size, unsigned zone_flags) {\n  COMMON_MALLOC_ENTER();\n  uptr page_size = GetPageSizeCached();\n  uptr allocated_size = RoundUpTo(sizeof(sanitizer_zone), page_size);\n  COMMON_MALLOC_MEMALIGN(page_size, allocated_size);\n  malloc_zone_t *new_zone = (malloc_zone_t *)p;\n  internal_memcpy(new_zone, &sanitizer_zone, sizeof(sanitizer_zone));\n  new_zone->zone_name = NULL;  // The name will be changed anyway.\n  if (GetMacosVersion() >= MACOS_VERSION_LION) {\n    // Prevent the client app from overwriting the zone contents.\n    // Library functions that need to modify the zone will set PROT_WRITE on it.\n    // This matches the behavior of malloc_create_zone() on OSX 10.7 and higher.\n    mprotect(new_zone, allocated_size, PROT_READ);\n  }\n  return new_zone;\n}\n\nINTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n  COMMON_MALLOC_ENTER();\n  return &sanitizer_zone;\n}\n\nINTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n  // FIXME: ASan should support purgeable allocations.\n  // https://github.com/google/sanitizers/issues/139\n  COMMON_MALLOC_ENTER();\n  return &sanitizer_zone;\n}\n\nINTERCEPTOR(void, malloc_make_purgeable, void *ptr) {\n  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n  // for now.\n  COMMON_MALLOC_ENTER();\n}\n\nINTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n  // for now.\n  COMMON_MALLOC_ENTER();\n  // Must return 0 if the contents were not purged since the last call to\n  // malloc_make_purgeable().\n  return 0;\n}\n\nINTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n  COMMON_MALLOC_ENTER();\n  // Allocate |sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + internal_strlen(name)|\n  // bytes.\n  size_t buflen =\n      sizeof(COMMON_MALLOC_ZONE_NAME \"-\") + (name ? internal_strlen(name) : 0);\n  InternalScopedString new_name(buflen);\n  if (name && zone->introspect == sanitizer_zone.introspect) {\n    new_name.append(COMMON_MALLOC_ZONE_NAME \"-%s\", name);\n    name = new_name.data();\n  }\n\n  // Call the system malloc's implementation for both external and our zones,\n  // since that appropriately changes VM region protections on the zone.\n  REAL(malloc_set_zone_name)(zone, name);\n}\n\nINTERCEPTOR(void *, malloc, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_MALLOC(size);\n  return p;\n}\n\nINTERCEPTOR(void, free, void *ptr) {\n  COMMON_MALLOC_ENTER();\n  if (!ptr) return;\n  COMMON_MALLOC_FREE(ptr);\n}\n\nINTERCEPTOR(void *, realloc, void *ptr, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_REALLOC(ptr, size);\n  return p;\n}\n\nINTERCEPTOR(void *, calloc, size_t nmemb, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_CALLOC(nmemb, size);\n  return p;\n}\n\nINTERCEPTOR(void *, valloc, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_VALLOC(size);\n  return p;\n}\n\nINTERCEPTOR(size_t, malloc_good_size, size_t size) {\n  COMMON_MALLOC_ENTER();\n  return sanitizer_zone.introspect->good_size(&sanitizer_zone, size);\n}\n\nINTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n  COMMON_MALLOC_ENTER();\n  CHECK(memptr);\n  COMMON_MALLOC_MEMALIGN(alignment, size);\n  if (p) {\n    *memptr = p;\n    return 0;\n  }\n  return -1;\n}\n\nnamespace {\n\n// TODO(glider): the __sanitizer_mz_* functions should be united with the Linux\n// wrappers, as they are basically copied from there.\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nsize_t __sanitizer_mz_size(malloc_zone_t* zone, const void* ptr) {\n  COMMON_MALLOC_SIZE(ptr);\n  return size;\n}\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid *__sanitizer_mz_malloc(malloc_zone_t *zone, uptr size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_MALLOC(size);\n  return p;\n}\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid *__sanitizer_mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n  if (UNLIKELY(!COMMON_MALLOC_SANITIZER_INITIALIZED)) {\n    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n    const size_t kCallocPoolSize = 1024;\n    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n    static size_t allocated;\n    size_t size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n    allocated += size_in_words;\n    CHECK(allocated < kCallocPoolSize);\n    return mem;\n  }\n  COMMON_MALLOC_CALLOC(nmemb, size);\n  return p;\n}\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid *__sanitizer_mz_valloc(malloc_zone_t *zone, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_VALLOC(size);\n  return p;\n}\n\n// TODO(glider): the allocation callbacks need to be refactored.\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_mz_free(malloc_zone_t *zone, void *ptr) {\n  if (!ptr) return;\n  COMMON_MALLOC_FREE(ptr);\n}\n\n#define GET_ZONE_FOR_PTR(ptr) \\\n  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid *__sanitizer_mz_realloc(malloc_zone_t *zone, void *ptr, size_t new_size) {\n  if (!ptr) {\n    COMMON_MALLOC_MALLOC(new_size);\n    return p;\n  } else {\n    COMMON_MALLOC_SIZE(ptr);\n    if (size) {\n      COMMON_MALLOC_REALLOC(ptr, new_size);\n      return p;\n    } else {\n      // We can't recover from reallocating an unknown address, because\n      // this would require reading at most |new_size| bytes from\n      // potentially unaccessible memory.\n      GET_ZONE_FOR_PTR(ptr);\n      COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name);\n      return nullptr;\n    }\n  }\n}\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_mz_destroy(malloc_zone_t* zone) {\n  // A no-op -- we will not be destroyed!\n  Report(\"__sanitizer_mz_destroy() called -- ignoring\\n\");\n}\n\nextern \"C\"\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid *__sanitizer_mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n  COMMON_MALLOC_ENTER();\n  COMMON_MALLOC_MEMALIGN(align, size);\n  return p;\n}\n\n// This function is currently unused, and we build with -Werror.\n#if 0\nvoid __sanitizer_mz_free_definite_size(\n    malloc_zone_t* zone, void *ptr, size_t size) {\n  // TODO(glider): check that |size| is valid.\n  UNIMPLEMENTED();\n}\n#endif\n\nkern_return_t mi_enumerator(task_t task, void *,\n                            unsigned type_mask, vm_address_t zone_address,\n                            memory_reader_t reader,\n                            vm_range_recorder_t recorder) {\n  // Should enumerate all the pointers we have.  Seems like a lot of work.\n  return KERN_FAILURE;\n}\n\nsize_t mi_good_size(malloc_zone_t *zone, size_t size) {\n  // I think it's always safe to return size, but we maybe could do better.\n  return size;\n}\n\nboolean_t mi_check(malloc_zone_t *zone) {\n  UNIMPLEMENTED();\n}\n\nvoid mi_print(malloc_zone_t *zone, boolean_t verbose) {\n  UNIMPLEMENTED();\n}\n\nvoid mi_log(malloc_zone_t *zone, void *address) {\n  // I don't think we support anything like this\n}\n\nvoid mi_force_lock(malloc_zone_t *zone) {\n  COMMON_MALLOC_FORCE_LOCK();\n}\n\nvoid mi_force_unlock(malloc_zone_t *zone) {\n  COMMON_MALLOC_FORCE_UNLOCK();\n}\n\nvoid mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {\n  COMMON_MALLOC_FILL_STATS(zone, stats);\n}\n\nboolean_t mi_zone_locked(malloc_zone_t *zone) {\n  // UNIMPLEMENTED();\n  return false;\n}\n\n}  // unnamed namespace\n\nnamespace COMMON_MALLOC_NAMESPACE {\n\nvoid ReplaceSystemMalloc() {\n  static malloc_introspection_t sanitizer_zone_introspection;\n  // Ok to use internal_memset, these places are not performance-critical.\n  internal_memset(&sanitizer_zone_introspection, 0,\n                  sizeof(sanitizer_zone_introspection));\n\n  sanitizer_zone_introspection.enumerator = &mi_enumerator;\n  sanitizer_zone_introspection.good_size = &mi_good_size;\n  sanitizer_zone_introspection.check = &mi_check;\n  sanitizer_zone_introspection.print = &mi_print;\n  sanitizer_zone_introspection.log = &mi_log;\n  sanitizer_zone_introspection.force_lock = &mi_force_lock;\n  sanitizer_zone_introspection.force_unlock = &mi_force_unlock;\n  sanitizer_zone_introspection.statistics = &mi_statistics;\n  sanitizer_zone_introspection.zone_locked = &mi_zone_locked;\n\n  internal_memset(&sanitizer_zone, 0, sizeof(malloc_zone_t));\n\n  // Use version 6 for OSX >= 10.6.\n  sanitizer_zone.version = 6;\n  sanitizer_zone.zone_name = COMMON_MALLOC_ZONE_NAME;\n  sanitizer_zone.size = &__sanitizer_mz_size;\n  sanitizer_zone.malloc = &__sanitizer_mz_malloc;\n  sanitizer_zone.calloc = &__sanitizer_mz_calloc;\n  sanitizer_zone.valloc = &__sanitizer_mz_valloc;\n  sanitizer_zone.free = &__sanitizer_mz_free;\n  sanitizer_zone.realloc = &__sanitizer_mz_realloc;\n  sanitizer_zone.destroy = &__sanitizer_mz_destroy;\n  sanitizer_zone.batch_malloc = 0;\n  sanitizer_zone.batch_free = 0;\n  sanitizer_zone.free_definite_size = 0;\n  sanitizer_zone.memalign = &__sanitizer_mz_memalign;\n  sanitizer_zone.introspect = &sanitizer_zone_introspection;\n\n  // Register the zone.\n  malloc_zone_register(&sanitizer_zone);\n}\n\n}  // namespace COMMON_MALLOC_NAMESPACE\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc": "//===-- sanitizer_symbolizer_posix_libcdep.cc -----------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer\n// run-time libraries.\n// POSIX-specific implementation of symbolizer parts.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_platform.h\"\n#if SANITIZER_POSIX\n#include \"sanitizer_allocator_internal.h\"\n#include \"sanitizer_common.h\"\n#include \"sanitizer_flags.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_linux.h\"\n#include \"sanitizer_placement_new.h\"\n#include \"sanitizer_posix.h\"\n#include \"sanitizer_procmaps.h\"\n#include \"sanitizer_symbolizer_internal.h\"\n#include \"sanitizer_symbolizer_libbacktrace.h\"\n#include \"sanitizer_symbolizer_mac.h\"\n\n#include <dlfcn.h>   // for dlsym()\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#if SANITIZER_MAC\n#include <util.h>  // for forkpty()\n#endif  // SANITIZER_MAC\n\n// C++ demangling function, as required by Itanium C++ ABI. This is weak,\n// because we do not require a C++ ABI library to be linked to a program\n// using sanitizers; if it's not present, we'll just use the mangled name.\nnamespace __cxxabiv1 {\n  extern \"C\" SANITIZER_WEAK_ATTRIBUTE\n  char *__cxa_demangle(const char *mangled, char *buffer,\n                                  size_t *length, int *status);\n}\n\nnamespace __sanitizer {\n\n// Attempts to demangle the name via __cxa_demangle from __cxxabiv1.\nconst char *DemangleCXXABI(const char *name) {\n  // FIXME: __cxa_demangle aggressively insists on allocating memory.\n  // There's not much we can do about that, short of providing our\n  // own demangler (libc++abi's implementation could be adapted so that\n  // it does not allocate). For now, we just call it anyway, and we leak\n  // the returned value.\n  if (__cxxabiv1::__cxa_demangle)\n    if (const char *demangled_name =\n          __cxxabiv1::__cxa_demangle(name, 0, 0, 0))\n      return demangled_name;\n\n  return name;\n}\n\n// As of now, there are no headers for the Swift runtime. Once they are\n// present, we will weakly link since we do not require Swift runtime to be\n// linked.\ntypedef char *(*swift_demangle_ft)(const char *mangledName,\n                                   size_t mangledNameLength, char *outputBuffer,\n                                   size_t *outputBufferSize, uint32_t flags);\nstatic swift_demangle_ft swift_demangle_f;\n\n// This must not happen lazily at symbolication time, because dlsym uses\n// malloc and thread-local storage, which is not a good thing to do during\n// symbolication.\nstatic void InitializeSwiftDemangler() {\n  swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, \"swift_demangle\");\n}\n\n// Attempts to demangle a Swift name. The demangler will return nullptr if a\n// non-Swift name is passed in.\nconst char *DemangleSwift(const char *name) {\n  if (!name) return nullptr;\n\n  // Check if we are dealing with a Swift mangled name first.\n  if (name[0] != '_' || name[1] != 'T') {\n    return nullptr;\n  }\n\n  if (swift_demangle_f)\n    return swift_demangle_f(name, internal_strlen(name), 0, 0, 0);\n\n  return nullptr;\n}\n\nconst char *DemangleSwiftAndCXX(const char *name) {\n  if (!name) return nullptr;\n  if (const char *swift_demangled_name = DemangleSwift(name))\n    return swift_demangled_name;\n  return DemangleCXXABI(name);\n}\n\nbool SymbolizerProcess::StartSymbolizerSubprocess() {\n  if (!FileExists(path_)) {\n    if (!reported_invalid_path_) {\n      Report(\"WARNING: invalid path to external symbolizer!\\n\");\n      reported_invalid_path_ = true;\n    }\n    return false;\n  }\n\n  int pid;\n  if (use_forkpty_) {\n#if SANITIZER_MAC\n    fd_t fd = kInvalidFd;\n\n    // forkpty redirects stdout and stderr into a single stream, so we would\n    // receive error messages as standard replies. To avoid that, let's dup\n    // stderr and restore it in the child.\n    int saved_stderr = dup(STDERR_FILENO);\n    CHECK_GE(saved_stderr, 0);\n\n    // Use forkpty to disable buffering in the new terminal.\n    pid = internal_forkpty(&fd);\n    if (pid == -1) {\n      // forkpty() failed.\n      Report(\"WARNING: failed to fork external symbolizer (errno: %d)\\n\",\n             errno);\n      return false;\n    } else if (pid == 0) {\n      // Child subprocess.\n\n      // Restore stderr.\n      CHECK_GE(dup2(saved_stderr, STDERR_FILENO), 0);\n      close(saved_stderr);\n\n      const char *argv[kArgVMax];\n      GetArgV(path_, argv);\n      execv(path_, const_cast<char **>(&argv[0]));\n      internal__exit(1);\n    }\n\n    // Continue execution in parent process.\n    input_fd_ = output_fd_ = fd;\n\n    close(saved_stderr);\n\n    // Disable echo in the new terminal, disable CR.\n    struct termios termflags;\n    tcgetattr(fd, &termflags);\n    termflags.c_oflag &= ~ONLCR;\n    termflags.c_lflag &= ~ECHO;\n    tcsetattr(fd, TCSANOW, &termflags);\n#else  // SANITIZER_MAC\n    UNIMPLEMENTED();\n#endif  // SANITIZER_MAC\n  } else {\n    int *infd = NULL;\n    int *outfd = NULL;\n    // The client program may close its stdin and/or stdout and/or stderr\n    // thus allowing socketpair to reuse file descriptors 0, 1 or 2.\n    // In this case the communication between the forked processes may be\n    // broken if either the parent or the child tries to close or duplicate\n    // these descriptors. The loop below produces two pairs of file\n    // descriptors, each greater than 2 (stderr).\n    int sock_pair[5][2];\n    for (int i = 0; i < 5; i++) {\n      if (pipe(sock_pair[i]) == -1) {\n        for (int j = 0; j < i; j++) {\n          internal_close(sock_pair[j][0]);\n          internal_close(sock_pair[j][1]);\n        }\n        Report(\"WARNING: Can't create a socket pair to start \"\n               \"external symbolizer (errno: %d)\\n\", errno);\n        return false;\n      } else if (sock_pair[i][0] > 2 && sock_pair[i][1] > 2) {\n        if (infd == NULL) {\n          infd = sock_pair[i];\n        } else {\n          outfd = sock_pair[i];\n          for (int j = 0; j < i; j++) {\n            if (sock_pair[j] == infd) continue;\n            internal_close(sock_pair[j][0]);\n            internal_close(sock_pair[j][1]);\n          }\n          break;\n        }\n      }\n    }\n    CHECK(infd);\n    CHECK(outfd);\n\n    const char *argv[kArgVMax];\n    GetArgV(path_, argv);\n    pid = StartSubprocess(path_, argv, /* stdin */ outfd[0],\n                          /* stdout */ infd[1]);\n    if (pid < 0) {\n      internal_close(infd[0]);\n      internal_close(outfd[1]);\n      return false;\n    }\n\n    input_fd_ = infd[0];\n    output_fd_ = outfd[1];\n  }\n\n  // Check that symbolizer subprocess started successfully.\n  SleepForMillis(kSymbolizerStartupTimeMillis);\n  if (!IsProcessRunning(pid)) {\n    // Either waitpid failed, or child has already exited.\n    Report(\"WARNING: external symbolizer didn't start up correctly!\\n\");\n    return false;\n  }\n\n  return true;\n}\n\nclass Addr2LineProcess : public SymbolizerProcess {\n public:\n  Addr2LineProcess(const char *path, const char *module_name)\n      : SymbolizerProcess(path), module_name_(internal_strdup(module_name)) {}\n\n  const char *module_name() const { return module_name_; }\n\n private:\n  void GetArgV(const char *path_to_binary,\n               const char *(&argv)[kArgVMax]) const override {\n    int i = 0;\n    argv[i++] = path_to_binary;\n    argv[i++] = \"-iCfe\";\n    argv[i++] = module_name_;\n    argv[i++] = nullptr;\n  }\n\n  bool ReachedEndOfOutput(const char *buffer, uptr length) const override;\n\n  bool ReadFromSymbolizer(char *buffer, uptr max_length) override {\n    if (!SymbolizerProcess::ReadFromSymbolizer(buffer, max_length))\n      return false;\n    // We should cut out output_terminator_ at the end of given buffer,\n    // appended by addr2line to mark the end of its meaningful output.\n    // We cannot scan buffer from it's beginning, because it is legal for it\n    // to start with output_terminator_ in case given offset is invalid. So,\n    // scanning from second character.\n    char *garbage = internal_strstr(buffer + 1, output_terminator_);\n    // This should never be NULL since buffer must end up with\n    // output_terminator_.\n    CHECK(garbage);\n    // Trim the buffer.\n    garbage[0] = '\\0';\n    return true;\n  }\n\n  const char *module_name_;  // Owned, leaked.\n  static const char output_terminator_[];\n};\n\nconst char Addr2LineProcess::output_terminator_[] = \"??\\n??:0\\n\";\n\nbool Addr2LineProcess::ReachedEndOfOutput(const char *buffer,\n                                          uptr length) const {\n  const size_t kTerminatorLen = sizeof(output_terminator_) - 1;\n  // Skip, if we read just kTerminatorLen bytes, because Addr2Line output\n  // should consist at least of two pairs of lines:\n  // 1. First one, corresponding to given offset to be symbolized\n  // (may be equal to output_terminator_, if offset is not valid).\n  // 2. Second one for output_terminator_, itself to mark the end of output.\n  if (length <= kTerminatorLen) return false;\n  // Addr2Line output should end up with output_terminator_.\n  return !internal_memcmp(buffer + length - kTerminatorLen,\n                          output_terminator_, kTerminatorLen);\n}\n\nclass Addr2LinePool : public SymbolizerTool {\n public:\n  explicit Addr2LinePool(const char *addr2line_path,\n                         LowLevelAllocator *allocator)\n      : addr2line_path_(addr2line_path), allocator_(allocator),\n        addr2line_pool_(16) {}\n\n  bool SymbolizePC(uptr addr, SymbolizedStack *stack) override {\n    if (const char *buf =\n            SendCommand(stack->info.module, stack->info.module_offset)) {\n      ParseSymbolizePCOutput(buf, stack);\n      return true;\n    }\n    return false;\n  }\n\n  bool SymbolizeData(uptr addr, DataInfo *info) override {\n    return false;\n  }\n\n private:\n  const char *SendCommand(const char *module_name, uptr module_offset) {\n    Addr2LineProcess *addr2line = 0;\n    for (uptr i = 0; i < addr2line_pool_.size(); ++i) {\n      if (0 ==\n          internal_strcmp(module_name, addr2line_pool_[i]->module_name())) {\n        addr2line = addr2line_pool_[i];\n        break;\n      }\n    }\n    if (!addr2line) {\n      addr2line =\n          new(*allocator_) Addr2LineProcess(addr2line_path_, module_name);\n      addr2line_pool_.push_back(addr2line);\n    }\n    CHECK_EQ(0, internal_strcmp(module_name, addr2line->module_name()));\n    char buffer[kBufferSize];\n    internal_snprintf(buffer, kBufferSize, \"0x%zx\\n0x%zx\\n\",\n                      module_offset, dummy_address_);\n    return addr2line->SendCommand(buffer);\n  }\n\n  static const uptr kBufferSize = 64;\n  const char *addr2line_path_;\n  LowLevelAllocator *allocator_;\n  InternalMmapVector<Addr2LineProcess*> addr2line_pool_;\n  static const uptr dummy_address_ =\n      FIRST_32_SECOND_64(UINT32_MAX, UINT64_MAX);\n};\n\n#if SANITIZER_SUPPORTS_WEAK_HOOKS\nextern \"C\" {\nSANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\nbool __sanitizer_symbolize_code(const char *ModuleName, u64 ModuleOffset,\n                                char *Buffer, int MaxLength);\nSANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\nbool __sanitizer_symbolize_data(const char *ModuleName, u64 ModuleOffset,\n                                char *Buffer, int MaxLength);\nSANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\nvoid __sanitizer_symbolize_flush();\nSANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\nint __sanitizer_symbolize_demangle(const char *Name, char *Buffer,\n                                   int MaxLength);\n}  // extern \"C\"\n\nclass InternalSymbolizer : public SymbolizerTool {\n public:\n  static InternalSymbolizer *get(LowLevelAllocator *alloc) {\n    if (__sanitizer_symbolize_code != 0 &&\n        __sanitizer_symbolize_data != 0) {\n      return new(*alloc) InternalSymbolizer();\n    }\n    return 0;\n  }\n\n  bool SymbolizePC(uptr addr, SymbolizedStack *stack) override {\n    bool result = __sanitizer_symbolize_code(\n        stack->info.module, stack->info.module_offset, buffer_, kBufferSize);\n    if (result) ParseSymbolizePCOutput(buffer_, stack);\n    return result;\n  }\n\n  bool SymbolizeData(uptr addr, DataInfo *info) override {\n    bool result = __sanitizer_symbolize_data(info->module, info->module_offset,\n                                             buffer_, kBufferSize);\n    if (result) {\n      ParseSymbolizeDataOutput(buffer_, info);\n      info->start += (addr - info->module_offset);  // Add the base address.\n    }\n    return result;\n  }\n\n  void Flush() override {\n    if (__sanitizer_symbolize_flush)\n      __sanitizer_symbolize_flush();\n  }\n\n  const char *Demangle(const char *name) override {\n    if (__sanitizer_symbolize_demangle) {\n      for (uptr res_length = 1024;\n           res_length <= InternalSizeClassMap::kMaxSize;) {\n        char *res_buff = static_cast<char*>(InternalAlloc(res_length));\n        uptr req_length =\n            __sanitizer_symbolize_demangle(name, res_buff, res_length);\n        if (req_length > res_length) {\n          res_length = req_length + 1;\n          InternalFree(res_buff);\n          continue;\n        }\n        return res_buff;\n      }\n    }\n    return name;\n  }\n\n private:\n  InternalSymbolizer() { }\n\n  static const int kBufferSize = 16 * 1024;\n  static const int kMaxDemangledNameSize = 1024;\n  char buffer_[kBufferSize];\n};\n#else  // SANITIZER_SUPPORTS_WEAK_HOOKS\n\nclass InternalSymbolizer : public SymbolizerTool {\n public:\n  static InternalSymbolizer *get(LowLevelAllocator *alloc) { return 0; }\n};\n\n#endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n\nconst char *Symbolizer::PlatformDemangle(const char *name) {\n  return DemangleSwiftAndCXX(name);\n}\n\nvoid Symbolizer::PlatformPrepareForSandboxing() {}\n\nstatic SymbolizerTool *ChooseExternalSymbolizer(LowLevelAllocator *allocator) {\n  const char *path = common_flags()->external_symbolizer_path;\n  const char *binary_name = path ? StripModuleName(path) : \"\";\n  if (path && path[0] == '\\0') {\n    VReport(2, \"External symbolizer is explicitly disabled.\\n\");\n    return nullptr;\n  } else if (!internal_strcmp(binary_name, \"llvm-symbolizer\")) {\n    VReport(2, \"Using llvm-symbolizer at user-specified path: %s\\n\", path);\n    return new(*allocator) LLVMSymbolizer(path, allocator);\n  } else if (!internal_strcmp(binary_name, \"atos\")) {\n#if SANITIZER_MAC\n    VReport(2, \"Using atos at user-specified path: %s\\n\", path);\n    return new(*allocator) AtosSymbolizer(path, allocator);\n#else  // SANITIZER_MAC\n    Report(\"ERROR: Using `atos` is only supported on Darwin.\\n\");\n    Die();\n#endif  // SANITIZER_MAC\n  } else if (!internal_strcmp(binary_name, \"addr2line\")) {\n    VReport(2, \"Using addr2line at user-specified path: %s\\n\", path);\n    return new(*allocator) Addr2LinePool(path, allocator);\n  } else if (path) {\n    Report(\"ERROR: External symbolizer path is set to '%s' which isn't \"\n           \"a known symbolizer. Please set the path to the llvm-symbolizer \"\n           \"binary or other known tool.\\n\", path);\n    Die();\n  }\n\n  // Otherwise symbolizer program is unknown, let's search $PATH\n  CHECK(path == nullptr);\n  if (const char *found_path = FindPathToBinary(\"llvm-symbolizer\")) {\n    VReport(2, \"Using llvm-symbolizer found at: %s\\n\", found_path);\n    return new(*allocator) LLVMSymbolizer(found_path, allocator);\n  }\n#if SANITIZER_MAC\n  if (const char *found_path = FindPathToBinary(\"atos\")) {\n    VReport(2, \"Using atos found at: %s\\n\", found_path);\n    return new(*allocator) AtosSymbolizer(found_path, allocator);\n  }\n#endif  // SANITIZER_MAC\n  if (common_flags()->allow_addr2line) {\n    if (const char *found_path = FindPathToBinary(\"addr2line\")) {\n      VReport(2, \"Using addr2line found at: %s\\n\", found_path);\n      return new(*allocator) Addr2LinePool(found_path, allocator);\n    }\n  }\n  return nullptr;\n}\n\nstatic void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n                                  LowLevelAllocator *allocator) {\n  if (!common_flags()->symbolize) {\n    VReport(2, \"Symbolizer is disabled.\\n\");\n    return;\n  }\n  if (IsReportingOOM()) {\n    VReport(2, \"Cannot use internal symbolizer: out of memory\\n\");\n  } else if (SymbolizerTool *tool = InternalSymbolizer::get(allocator)) {\n    VReport(2, \"Using internal symbolizer.\\n\");\n    list->push_back(tool);\n    return;\n  }\n  if (SymbolizerTool *tool = LibbacktraceSymbolizer::get(allocator)) {\n    VReport(2, \"Using libbacktrace symbolizer.\\n\");\n    list->push_back(tool);\n    return;\n  }\n\n  if (SymbolizerTool *tool = ChooseExternalSymbolizer(allocator)) {\n    list->push_back(tool);\n  }\n\n#if SANITIZER_MAC\n  VReport(2, \"Using dladdr symbolizer.\\n\");\n  list->push_back(new(*allocator) DlAddrSymbolizer());\n#endif  // SANITIZER_MAC\n}\n\nSymbolizer *Symbolizer::PlatformInit() {\n  IntrusiveList<SymbolizerTool> list;\n  list.clear();\n  ChooseSymbolizerTools(&list, &symbolizer_allocator_);\n  return new(symbolizer_allocator_) Symbolizer(list);\n}\n\nvoid Symbolizer::LateInitialize() {\n  Symbolizer::GetOrInit();\n  InitializeSwiftDemangler();\n}\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_POSIX\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc": "//===-- sanitizer_unwind_linux_libcdep.cc ---------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the unwind.h-based (aka \"slow\") stack unwinding routines\n// available to the tools on Linux, Android, and FreeBSD.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_platform.h\"\n#if SANITIZER_FREEBSD || SANITIZER_LINUX\n#include \"sanitizer_common.h\"\n#include \"sanitizer_stacktrace.h\"\n\n#if SANITIZER_ANDROID\n#include <dlfcn.h>  // for dlopen()\n#endif\n\n#if SANITIZER_FREEBSD\n#define _GNU_SOURCE  // to declare _Unwind_Backtrace() from <unwind.h>\n#endif\n#include <unwind.h>\n\nnamespace __sanitizer {\n\n//------------------------- SlowUnwindStack -----------------------------------\n\ntypedef struct {\n  uptr absolute_pc;\n  uptr stack_top;\n  uptr stack_size;\n} backtrace_frame_t;\n\nextern \"C\" {\ntypedef void *(*acquire_my_map_info_list_func)();\ntypedef void (*release_my_map_info_list_func)(void *map);\ntypedef sptr (*unwind_backtrace_signal_arch_func)(\n    void *siginfo, void *sigcontext, void *map_info_list,\n    backtrace_frame_t *backtrace, uptr ignore_depth, uptr max_depth);\nacquire_my_map_info_list_func acquire_my_map_info_list;\nrelease_my_map_info_list_func release_my_map_info_list;\nunwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n} // extern \"C\"\n\n#if SANITIZER_ANDROID\nvoid SanitizerInitializeUnwinder() {\n  if (AndroidGetApiLevel() >= ANDROID_LOLLIPOP_MR1) return;\n\n  // Pre-lollipop Android can not unwind through signal handler frames with\n  // libgcc unwinder, but it has a libcorkscrew.so library with the necessary\n  // workarounds.\n  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n  if (!p) {\n    VReport(1,\n            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n            \"in SEGV reports.\");\n    return;\n  }\n  acquire_my_map_info_list =\n      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n  release_my_map_info_list =\n      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n      p, \"unwind_backtrace_signal_arch\");\n  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n      !unwind_backtrace_signal_arch) {\n    VReport(1,\n            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n            \"You may see broken stack traces in SEGV reports.\");\n    acquire_my_map_info_list = 0;\n    unwind_backtrace_signal_arch = 0;\n    release_my_map_info_list = 0;\n  }\n}\n#endif\n\n#ifdef __arm__\n#define UNWIND_STOP _URC_END_OF_STACK\n#define UNWIND_CONTINUE _URC_NO_REASON\n#else\n#define UNWIND_STOP _URC_NORMAL_STOP\n#define UNWIND_CONTINUE _URC_NO_REASON\n#endif\n\nuptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n#if defined(__arm__) && !SANITIZER_MAC\n  uptr val;\n  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n  // Clear the Thumb bit.\n  return val & ~(uptr)1;\n#else\n  return _Unwind_GetIP(ctx);\n#endif\n}\n\nstruct UnwindTraceArg {\n  BufferedStackTrace *stack;\n  u32 max_depth;\n};\n\n_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n  UnwindTraceArg *arg = (UnwindTraceArg*)param;\n  CHECK_LT(arg->stack->size, arg->max_depth);\n  uptr pc = Unwind_GetIP(ctx);\n  const uptr kPageSize = GetPageSizeCached();\n  // Let's assume that any pointer in the 0th page (i.e. <0x1000 on i386 and\n  // x86_64) is invalid and stop unwinding here.  If we're adding support for\n  // a platform where this isn't true, we need to reconsider this check.\n  if (pc < kPageSize) return UNWIND_STOP;\n  arg->stack->trace_buffer[arg->stack->size++] = pc;\n  if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n  return UNWIND_CONTINUE;\n}\n\nvoid BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n  CHECK_GE(max_depth, 2);\n  size = 0;\n  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n  _Unwind_Backtrace(Unwind_Trace, &arg);\n  // We need to pop a few frames so that pc is on top.\n  uptr to_pop = LocatePcInTrace(pc);\n  // trace_buffer[0] belongs to the current function so we always pop it,\n  // unless there is only 1 frame in the stack trace (1 frame is always better\n  // than 0!).\n  // 1-frame stacks don't normally happen, but this depends on the actual\n  // unwinder implementation (libgcc, libunwind, etc) which is outside of our\n  // control.\n  if (to_pop == 0 && size > 1)\n    to_pop = 1;\n  PopStackFrames(to_pop);\n  trace_buffer[0] = pc;\n}\n\nvoid BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n                                                    u32 max_depth) {\n  CHECK_GE(max_depth, 2);\n  if (!unwind_backtrace_signal_arch) {\n    SlowUnwindStack(pc, max_depth);\n    return;\n  }\n\n  void *map = acquire_my_map_info_list();\n  CHECK(map);\n  InternalScopedBuffer<backtrace_frame_t> frames(kStackTraceMax);\n  // siginfo argument appears to be unused.\n  sptr res = unwind_backtrace_signal_arch(/* siginfo */ 0, context, map,\n                                          frames.data(),\n                                          /* ignore_depth */ 0, max_depth);\n  release_my_map_info_list(map);\n  if (res < 0) return;\n  CHECK_LE((uptr)res, kStackTraceMax);\n\n  size = 0;\n  // +2 compensate for libcorkscrew unwinder returning addresses of call\n  // instructions instead of raw return addresses.\n  for (sptr i = 0; i < res; ++i)\n    trace_buffer[size++] = frames[i].absolute_pc + 2;\n}\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc": "//===-- sanitizer_linux_libcdep.cc ----------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer\n// run-time libraries and implements linux-specific functions from\n// sanitizer_libc.h.\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_platform.h\"\n\n#if SANITIZER_FREEBSD || SANITIZER_LINUX\n\n#include \"sanitizer_allocator_internal.h\"\n#include \"sanitizer_atomic.h\"\n#include \"sanitizer_common.h\"\n#include \"sanitizer_flags.h\"\n#include \"sanitizer_freebsd.h\"\n#include \"sanitizer_linux.h\"\n#include \"sanitizer_placement_new.h\"\n#include \"sanitizer_procmaps.h\"\n#include \"sanitizer_stacktrace.h\"\n\n#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n#include <dlfcn.h>  // for dlsym()\n#endif\n\n#include <link.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/resource.h>\n#include <syslog.h>\n\n#if SANITIZER_FREEBSD\n#include <pthread_np.h>\n#include <osreldate.h>\n#define pthread_getattr_np pthread_attr_get_np\n#endif\n\n#if SANITIZER_LINUX\n#include <sys/prctl.h>\n#endif\n\n#if SANITIZER_ANDROID\n#include <android/api-level.h>\n#endif\n\n#if SANITIZER_ANDROID && __ANDROID_API__ < 21\n#include <android/log.h>\n#endif\n\n#if !SANITIZER_ANDROID\n#include <elf.h>\n#include <unistd.h>\n#endif\n\nnamespace __sanitizer {\n\nSANITIZER_WEAK_ATTRIBUTE int\nreal_sigaction(int signum, const void *act, void *oldact);\n\nint internal_sigaction(int signum, const void *act, void *oldact) {\n#if !SANITIZER_GO\n  if (&real_sigaction)\n    return real_sigaction(signum, act, oldact);\n#endif\n  return sigaction(signum, (const struct sigaction *)act,\n                   (struct sigaction *)oldact);\n}\n\nvoid GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                uptr *stack_bottom) {\n  CHECK(stack_top);\n  CHECK(stack_bottom);\n  if (at_initialization) {\n    // This is the main thread. Libpthread may not be initialized yet.\n    struct rlimit rl;\n    CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n\n    // Find the mapping that contains a stack variable.\n    MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n    uptr start, end, offset;\n    uptr prev_end = 0;\n    while (proc_maps.Next(&start, &end, &offset, nullptr, 0,\n          /* protection */nullptr)) {\n      if ((uptr)&rl < end)\n        break;\n      prev_end = end;\n    }\n    CHECK((uptr)&rl >= start && (uptr)&rl < end);\n\n    // Get stacksize from rlimit, but clip it so that it does not overlap\n    // with other mappings.\n    uptr stacksize = rl.rlim_cur;\n    if (stacksize > end - prev_end)\n      stacksize = end - prev_end;\n    // When running with unlimited stack size, we still want to set some limit.\n    // The unlimited stack size is caused by 'ulimit -s unlimited'.\n    // Also, for some reason, GNU make spawns subprocesses with unlimited stack.\n    if (stacksize > kMaxThreadStackSize)\n      stacksize = kMaxThreadStackSize;\n    *stack_top = end;\n    *stack_bottom = end - stacksize;\n    return;\n  }\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n  uptr stacksize = 0;\n  void *stackaddr = nullptr;\n  my_pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n  pthread_attr_destroy(&attr);\n\n  CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n  *stack_top = (uptr)stackaddr + stacksize;\n  *stack_bottom = (uptr)stackaddr;\n}\n\n#if !SANITIZER_GO\nbool SetEnv(const char *name, const char *value) {\n  void *f = dlsym(RTLD_NEXT, \"setenv\");\n  if (!f)\n    return false;\n  typedef int(*setenv_ft)(const char *name, const char *value, int overwrite);\n  setenv_ft setenv_f;\n  CHECK_EQ(sizeof(setenv_f), sizeof(f));\n  internal_memcpy(&setenv_f, &f, sizeof(f));\n  return setenv_f(name, value, 1) == 0;\n}\n#endif\n\nbool SanitizerSetThreadName(const char *name) {\n#ifdef PR_SET_NAME\n  return 0 == prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);  // NOLINT\n#else\n  return false;\n#endif\n}\n\nbool SanitizerGetThreadName(char *name, int max_len) {\n#ifdef PR_GET_NAME\n  char buff[17];\n  if (prctl(PR_GET_NAME, (unsigned long)buff, 0, 0, 0))  // NOLINT\n    return false;\n  internal_strncpy(name, buff, max_len);\n  name[max_len] = 0;\n  return true;\n#else\n  return false;\n#endif\n}\n\n#ifndef __GLIBC_PREREQ\n#define __GLIBC_PREREQ(x, y) 0\n#endif\n\n#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\nstatic uptr g_tls_size;\n\nvoid InitTlsSize() {\n// all current supported platforms have 16 bytes stack alignment\n  const size_t kStackAlign = 16;\n  size_t tls_size = 0;\n  size_t tls_align = 0;\n  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n#if defined(__i386__) && !__GLIBC_PREREQ(2, 27)\n  /* On i?86, _dl_get_tls_static_info used to be internal_function, i.e.\n     __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal\n     function in 2.27 and later.  */\n  if (!dlvsym(RTLD_NEXT, \"glob\", \"GLIBC_2.27\")) {\n    typedef void (*get_tls_func)(size_t*, size_t*)\n      __attribute__((regparm(3), stdcall));\n    get_tls_func get_tls;\n    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n    internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n                    sizeof(get_tls_static_info_ptr));\n    CHECK_NE(get_tls, 0);\n    get_tls(&tls_size, &tls_align);\n  } else\n#endif\n  {\n    typedef void (*get_tls_func)(size_t*, size_t*);\n    get_tls_func get_tls;\n    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n    internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n                    sizeof(get_tls_static_info_ptr));\n    CHECK_NE(get_tls, 0);\n    get_tls(&tls_size, &tls_align);\n  }\n  if (tls_align < kStackAlign)\n    tls_align = kStackAlign;\n  g_tls_size = RoundUpTo(tls_size, tls_align);\n}\n#else\nvoid InitTlsSize() { }\n#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n\n#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n    || defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__)) \\\n    && SANITIZER_LINUX && !SANITIZER_ANDROID\n// sizeof(struct pthread) from glibc.\nstatic atomic_uintptr_t kThreadDescriptorSize;\n\nuptr ThreadDescriptorSize() {\n  uptr val = atomic_load(&kThreadDescriptorSize, memory_order_relaxed);\n  if (val)\n    return val;\n#if defined(__x86_64__) || defined(__i386__)\n#ifdef _CS_GNU_LIBC_VERSION\n  char buf[64];\n  uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n  if (len < sizeof(buf) && internal_strncmp(buf, \"glibc 2.\", 8) == 0) {\n    char *end;\n    int minor = internal_simple_strtoll(buf + 8, &end, 10);\n    if (end != buf + 8 && (*end == '\\0' || *end == '.')) {\n      int patch = 0;\n      if (*end == '.')\n        // strtoll will return 0 if no valid conversion could be performed\n        patch = internal_simple_strtoll(end + 1, nullptr, 10);\n\n      /* sizeof(struct pthread) values from various glibc versions.  */\n      if (SANITIZER_X32)\n        val = 1728;  // Assume only one particular version for x32.\n      else if (minor <= 3)\n        val = FIRST_32_SECOND_64(1104, 1696);\n      else if (minor == 4)\n        val = FIRST_32_SECOND_64(1120, 1728);\n      else if (minor == 5)\n        val = FIRST_32_SECOND_64(1136, 1728);\n      else if (minor <= 9)\n        val = FIRST_32_SECOND_64(1136, 1712);\n      else if (minor == 10)\n        val = FIRST_32_SECOND_64(1168, 1776);\n      else if (minor == 11 || (minor == 12 && patch == 1))\n        val = FIRST_32_SECOND_64(1168, 2288);\n      else if (minor <= 14)\n        val = FIRST_32_SECOND_64(1168, 2304);\n      else\n        val = FIRST_32_SECOND_64(1216, 2304);\n    }\n    if (val)\n      atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n    return val;\n  }\n#endif\n#elif defined(__mips__)\n  // TODO(sagarthakur): add more values as per different glibc versions.\n  val = FIRST_32_SECOND_64(1152, 1776);\n  if (val)\n    atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n  return val;\n#elif defined(__aarch64__)\n  // The sizeof (struct pthread) is the same from GLIBC 2.17 to 2.22.\n  val = 1776;\n  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n  return val;\n#elif defined(__powerpc64__)\n  val = 1776; // from glibc.ppc64le 2.20-8.fc21\n  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n  return val;\n#elif defined(__s390__)\n  val = FIRST_32_SECOND_64(1152, 1776); // valid for glibc 2.22\n  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n#endif\n  return 0;\n}\n\n// The offset at which pointer to self is located in the thread descriptor.\nconst uptr kThreadSelfOffset = FIRST_32_SECOND_64(8, 16);\n\nuptr ThreadSelfOffset() {\n  return kThreadSelfOffset;\n}\n\n#if defined(__mips__) || defined(__powerpc64__)\n// TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n// head structure. It lies before the static tls blocks.\nstatic uptr TlsPreTcbSize() {\n# if defined(__mips__)\n  const uptr kTcbHead = 16; // sizeof (tcbhead_t)\n# elif defined(__powerpc64__)\n  const uptr kTcbHead = 88; // sizeof (tcbhead_t)\n# endif\n  const uptr kTlsAlign = 16;\n  const uptr kTlsPreTcbSize =\n    (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n  InitTlsSize();\n  g_tls_size = (g_tls_size + kTlsPreTcbSize + kTlsAlign -1) & ~(kTlsAlign - 1);\n  return kTlsPreTcbSize;\n}\n#endif\n\nuptr ThreadSelf() {\n  uptr descr_addr;\n# if defined(__i386__)\n  asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n# elif defined(__x86_64__)\n  asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n# elif defined(__mips__)\n  // MIPS uses TLS variant I. The thread pointer (in hardware register $29)\n  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n  // TCB and the size of pthread_descr.\n  const uptr kTlsTcbOffset = 0x7000;\n  uptr thread_pointer;\n  asm volatile(\".set push;\\\n                .set mips64r2;\\\n                rdhwr %0,$29;\\\n                .set pop\" : \"=r\" (thread_pointer));\n  descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n# elif defined(__aarch64__)\n  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n                                      ThreadDescriptorSize();\n# elif defined(__s390__)\n  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n# elif defined(__powerpc64__)\n  // PPC64LE uses TLS variant I. The thread pointer (in GPR 13)\n  // points to the end of the TCB + 0x7000. The pthread_descr structure is\n  // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n  // TCB and the size of pthread_descr.\n  const uptr kTlsTcbOffset = 0x7000;\n  uptr thread_pointer;\n  asm(\"addi %0,13,%1\" : \"=r\"(thread_pointer) : \"I\"(-kTlsTcbOffset));\n  descr_addr = thread_pointer - TlsPreTcbSize();\n# else\n#  error \"unsupported CPU arch\"\n# endif\n  return descr_addr;\n}\n#endif  // (x86_64 || i386 || MIPS) && SANITIZER_LINUX\n\n#if SANITIZER_FREEBSD\nstatic void **ThreadSelfSegbase() {\n  void **segbase = 0;\n# if defined(__i386__)\n  // sysarch(I386_GET_GSBASE, segbase);\n  __asm __volatile(\"mov %%gs:0, %0\" : \"=r\" (segbase));\n# elif defined(__x86_64__)\n  // sysarch(AMD64_GET_FSBASE, segbase);\n  __asm __volatile(\"movq %%fs:0, %0\" : \"=r\" (segbase));\n# else\n#  error \"unsupported CPU arch for FreeBSD platform\"\n# endif\n  return segbase;\n}\n\nuptr ThreadSelf() {\n  return (uptr)ThreadSelfSegbase()[2];\n}\n#endif  // SANITIZER_FREEBSD\n\n#if !SANITIZER_GO\nstatic void GetTls(uptr *addr, uptr *size) {\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\n# if defined(__x86_64__) || defined(__i386__) || defined(__s390__)\n  *addr = ThreadSelf();\n  *size = GetTlsSize();\n  *addr -= *size;\n  *addr += ThreadDescriptorSize();\n# elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__)\n  *addr = ThreadSelf();\n  *size = GetTlsSize();\n# else\n  *addr = 0;\n  *size = 0;\n# endif\n#elif SANITIZER_FREEBSD\n  void** segbase = ThreadSelfSegbase();\n  *addr = 0;\n  *size = 0;\n  if (segbase != 0) {\n    // tcbalign = 16\n    // tls_size = round(tls_static_space, tcbalign);\n    // dtv = segbase[1];\n    // dtv[2] = segbase - tls_static_space;\n    void **dtv = (void**) segbase[1];\n    *addr = (uptr) dtv[2];\n    *size = (*addr == 0) ? 0 : ((uptr) segbase[0] - (uptr) dtv[2]);\n  }\n#elif SANITIZER_ANDROID\n  *addr = 0;\n  *size = 0;\n#else\n# error \"Unknown OS\"\n#endif\n}\n#endif\n\n#if !SANITIZER_GO\nuptr GetTlsSize() {\n#if SANITIZER_FREEBSD || SANITIZER_ANDROID\n  uptr addr, size;\n  GetTls(&addr, &size);\n  return size;\n#else\n  return g_tls_size;\n#endif\n}\n#endif\n\nvoid GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                          uptr *tls_addr, uptr *tls_size) {\n#if SANITIZER_GO\n  // Stub implementation for Go.\n  *stk_addr = *stk_size = *tls_addr = *tls_size = 0;\n#else\n  GetTls(tls_addr, tls_size);\n\n  uptr stack_top, stack_bottom;\n  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n  *stk_addr = stack_bottom;\n  *stk_size = stack_top - stack_bottom;\n\n  if (!main) {\n    // If stack and tls intersect, make them non-intersecting.\n    if (*tls_addr > *stk_addr && *tls_addr < *stk_addr + *stk_size) {\n      CHECK_GT(*tls_addr + *tls_size, *stk_addr);\n      CHECK_LE(*tls_addr + *tls_size, *stk_addr + *stk_size);\n      *stk_size -= *tls_size;\n      *tls_addr = *stk_addr + *stk_size;\n    }\n  }\n#endif\n}\n\n# if !SANITIZER_FREEBSD\ntypedef ElfW(Phdr) Elf_Phdr;\n# elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2\n#  define Elf_Phdr XElf32_Phdr\n#  define dl_phdr_info xdl_phdr_info\n#  define dl_iterate_phdr(c, b) xdl_iterate_phdr((c), (b))\n# endif\n\nstruct DlIteratePhdrData {\n  InternalMmapVector<LoadedModule> *modules;\n  bool first;\n};\n\nstatic int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n  DlIteratePhdrData *data = (DlIteratePhdrData*)arg;\n  InternalScopedString module_name(kMaxPathLength);\n  if (data->first) {\n    data->first = false;\n    // First module is the binary itself.\n    ReadBinaryNameCached(module_name.data(), module_name.size());\n  } else if (info->dlpi_name) {\n    module_name.append(\"%s\", info->dlpi_name);\n  }\n  if (module_name[0] == '\\0')\n    return 0;\n  LoadedModule cur_module;\n  cur_module.set(module_name.data(), info->dlpi_addr);\n  for (int i = 0; i < info->dlpi_phnum; i++) {\n    const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n    if (phdr->p_type == PT_LOAD) {\n      uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n      uptr cur_end = cur_beg + phdr->p_memsz;\n      bool executable = phdr->p_flags & PF_X;\n      cur_module.addAddressRange(cur_beg, cur_end, executable);\n    }\n  }\n  data->modules->push_back(cur_module);\n  return 0;\n}\n\n#if SANITIZER_ANDROID && __ANDROID_API__ < 21\nextern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n    int (*)(struct dl_phdr_info *, size_t, void *), void *);\n#endif\n\nvoid ListOfModules::init() {\n  clear();\n#if SANITIZER_ANDROID && __ANDROID_API__ <= 22\n  u32 api_level = AndroidGetApiLevel();\n  // Fall back to /proc/maps if dl_iterate_phdr is unavailable or broken.\n  // The runtime check allows the same library to work with\n  // both K and L (and future) Android releases.\n  if (api_level <= ANDROID_LOLLIPOP_MR1) { // L or earlier\n    MemoryMappingLayout memory_mapping(false);\n    memory_mapping.DumpListOfModules(&modules_);\n    return;\n  }\n#endif\n  DlIteratePhdrData data = {&modules_, true};\n  dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n}\n\n// getrusage does not give us the current RSS, only the max RSS.\n// Still, this is better than nothing if /proc/self/statm is not available\n// for some reason, e.g. due to a sandbox.\nstatic uptr GetRSSFromGetrusage() {\n  struct rusage usage;\n  if (getrusage(RUSAGE_SELF, &usage))  // Failed, probably due to a sandbox.\n    return 0;\n  return usage.ru_maxrss << 10;  // ru_maxrss is in Kb.\n}\n\nuptr GetRSS() {\n  if (!common_flags()->can_use_proc_maps_statm)\n    return GetRSSFromGetrusage();\n  fd_t fd = OpenFile(\"/proc/self/statm\", RdOnly);\n  if (fd == kInvalidFd)\n    return GetRSSFromGetrusage();\n  char buf[64];\n  uptr len = internal_read(fd, buf, sizeof(buf) - 1);\n  internal_close(fd);\n  if ((sptr)len <= 0)\n    return 0;\n  buf[len] = 0;\n  // The format of the file is:\n  // 1084 89 69 11 0 79 0\n  // We need the second number which is RSS in pages.\n  char *pos = buf;\n  // Skip the first number.\n  while (*pos >= '0' && *pos <= '9')\n    pos++;\n  // Skip whitespaces.\n  while (!(*pos >= '0' && *pos <= '9') && *pos != 0)\n    pos++;\n  // Read the number.\n  uptr rss = 0;\n  while (*pos >= '0' && *pos <= '9')\n    rss = rss * 10 + *pos++ - '0';\n  return rss * GetPageSizeCached();\n}\n\n// 64-bit Android targets don't provide the deprecated __android_log_write.\n// Starting with the L release, syslog() works and is preferable to\n// __android_log_write.\n#if SANITIZER_LINUX\n\n#if SANITIZER_ANDROID\nstatic atomic_uint8_t android_log_initialized;\n\nvoid AndroidLogInit() {\n  openlog(GetProcessName(), 0, LOG_USER);\n  atomic_store(&android_log_initialized, 1, memory_order_release);\n}\n\nstatic bool ShouldLogAfterPrintf() {\n  return atomic_load(&android_log_initialized, memory_order_acquire);\n}\n#else\nvoid AndroidLogInit() {}\n\nstatic bool ShouldLogAfterPrintf() { return true; }\n#endif  // SANITIZER_ANDROID\n\nvoid WriteOneLineToSyslog(const char *s) {\n#if SANITIZER_ANDROID &&__ANDROID_API__ < 21\n  __android_log_write(ANDROID_LOG_INFO, NULL, s);\n#else\n  syslog(LOG_INFO, \"%s\", s);\n#endif\n}\n\nvoid LogMessageOnPrintf(const char *str) {\n  if (common_flags()->log_to_syslog && ShouldLogAfterPrintf())\n    WriteToSyslog(str);\n}\n\n#endif // SANITIZER_LINUX\n\n} // namespace __sanitizer\n\n#endif // SANITIZER_FREEBSD || SANITIZER_LINUX\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/lsan/lsan_interceptors.cc": "//=-- lsan_interceptors.cc ------------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of LeakSanitizer.\n// Interceptors for standalone LSan.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"interception/interception.h\"\n#include \"sanitizer_common/sanitizer_allocator.h\"\n#include \"sanitizer_common/sanitizer_atomic.h\"\n#include \"sanitizer_common/sanitizer_common.h\"\n#include \"sanitizer_common/sanitizer_flags.h\"\n#include \"sanitizer_common/sanitizer_internal_defs.h\"\n#include \"sanitizer_common/sanitizer_linux.h\"\n#include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n#include \"lsan.h\"\n#include \"lsan_allocator.h\"\n#include \"lsan_common.h\"\n#include \"lsan_thread.h\"\n\nusing namespace __lsan;\n\nextern \"C\" {\nint pthread_attr_init(void *attr);\nint pthread_attr_destroy(void *attr);\nint pthread_attr_getdetachstate(void *attr, int *v);\nint pthread_key_create(unsigned *key, void (*destructor)(void* v));\nint pthread_setspecific(unsigned key, const void *v);\n}\n\n#define ENSURE_LSAN_INITED do {   \\\n  CHECK(!lsan_init_is_running);   \\\n  if (!lsan_inited)               \\\n    __lsan_init();                \\\n} while (0)\n\n///// Malloc/free interceptors. /////\n\nconst bool kAlwaysClearMemory = true;\n\nnamespace std {\n  struct nothrow_t;\n}\n\nINTERCEPTOR(void*, malloc, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  return Allocate(stack, size, 1, kAlwaysClearMemory);\n}\n\nINTERCEPTOR(void, free, void *p) {\n  ENSURE_LSAN_INITED;\n  Deallocate(p);\n}\n\nINTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n  if (lsan_init_is_running) {\n    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n    const uptr kCallocPoolSize = 1024;\n    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n    static uptr allocated;\n    uptr size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n    allocated += size_in_words;\n    CHECK(allocated < kCallocPoolSize);\n    return mem;\n  }\n  if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return nullptr;\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  size *= nmemb;\n  return Allocate(stack, size, 1, true);\n}\n\nINTERCEPTOR(void*, realloc, void *q, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  return Reallocate(stack, q, size, 1);\n}\n\nINTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n}\n\nINTERCEPTOR(void*, aligned_alloc, uptr alignment, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n}\n\nINTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  *memptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n  // FIXME: Return ENOMEM if user requested more than max alloc size.\n  return 0;\n}\n\nINTERCEPTOR(void *, __libc_memalign, uptr alignment, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  void *res = Allocate(stack, size, alignment, kAlwaysClearMemory);\n  DTLS_on_libc_memalign(res, size);\n  return res;\n}\n\nINTERCEPTOR(void*, valloc, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  if (size == 0)\n    size = GetPageSizeCached();\n  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n}\n\nINTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n  ENSURE_LSAN_INITED;\n  return GetMallocUsableSize(ptr);\n}\n\nstruct fake_mallinfo {\n  int x[10];\n};\n\nINTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n  struct fake_mallinfo res;\n  internal_memset(&res, 0, sizeof(res));\n  return res;\n}\n\nINTERCEPTOR(int, mallopt, int cmd, int value) {\n  return -1;\n}\n\nINTERCEPTOR(void*, pvalloc, uptr size) {\n  ENSURE_LSAN_INITED;\n  GET_STACK_TRACE_MALLOC;\n  uptr PageSize = GetPageSizeCached();\n  size = RoundUpTo(size, PageSize);\n  if (size == 0) {\n    // pvalloc(0) should allocate one page.\n    size = PageSize;\n  }\n  return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n}\n\nINTERCEPTOR(void, cfree, void *p) ALIAS(WRAPPER_NAME(free));\n\n#define OPERATOR_NEW_BODY                              \\\n  ENSURE_LSAN_INITED;                                  \\\n  GET_STACK_TRACE_MALLOC;                              \\\n  return Allocate(stack, size, 1, kAlwaysClearMemory);\n\nINTERCEPTOR_ATTRIBUTE\nvoid *operator new(uptr size) { OPERATOR_NEW_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid *operator new[](uptr size) { OPERATOR_NEW_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid *operator new(uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n\n#define OPERATOR_DELETE_BODY \\\n  ENSURE_LSAN_INITED;        \\\n  Deallocate(ptr);\n\nINTERCEPTOR_ATTRIBUTE\nvoid operator delete(void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid operator delete[](void *ptr) NOEXCEPT { OPERATOR_DELETE_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid operator delete(void *ptr, std::nothrow_t const&) { OPERATOR_DELETE_BODY; }\nINTERCEPTOR_ATTRIBUTE\nvoid operator delete[](void *ptr, std::nothrow_t const &) {\n  OPERATOR_DELETE_BODY;\n}\n\n///// Thread initialization and finalization. /////\n\nstatic unsigned g_thread_finalize_key;\n\nstatic void thread_finalize(void *v) {\n  uptr iter = (uptr)v;\n  if (iter > 1) {\n    if (pthread_setspecific(g_thread_finalize_key, (void*)(iter - 1))) {\n      Report(\"LeakSanitizer: failed to set thread key.\\n\");\n      Die();\n    }\n    return;\n  }\n  ThreadFinish();\n}\n\nstruct ThreadParam {\n  void *(*callback)(void *arg);\n  void *param;\n  atomic_uintptr_t tid;\n};\n\nextern \"C\" void *__lsan_thread_start_func(void *arg) {\n  ThreadParam *p = (ThreadParam*)arg;\n  void* (*callback)(void *arg) = p->callback;\n  void *param = p->param;\n  // Wait until the last iteration to maximize the chance that we are the last\n  // destructor to run.\n  if (pthread_setspecific(g_thread_finalize_key,\n                          (void*)GetPthreadDestructorIterations())) {\n    Report(\"LeakSanitizer: failed to set thread key.\\n\");\n    Die();\n  }\n  int tid = 0;\n  while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n    internal_sched_yield();\n  SetCurrentThread(tid);\n  ThreadStart(tid, GetTid());\n  atomic_store(&p->tid, 0, memory_order_release);\n  return callback(param);\n}\n\nINTERCEPTOR(int, pthread_create, void *th, void *attr,\n            void *(*callback)(void *), void *param) {\n  ENSURE_LSAN_INITED;\n  EnsureMainThreadIDIsCorrect();\n  __sanitizer_pthread_attr_t myattr;\n  if (!attr) {\n    pthread_attr_init(&myattr);\n    attr = &myattr;\n  }\n  AdjustStackSize(attr);\n  int detached = 0;\n  pthread_attr_getdetachstate(attr, &detached);\n  ThreadParam p;\n  p.callback = callback;\n  p.param = param;\n  atomic_store(&p.tid, 0, memory_order_relaxed);\n  int res;\n  {\n    // Ignore all allocations made by pthread_create: thread stack/TLS may be\n    // stored by pthread for future reuse even after thread destruction, and\n    // the linked list it's stored in doesn't even hold valid pointers to the\n    // objects, the latter are calculated by obscure pointer arithmetic.\n    ScopedInterceptorDisabler disabler;\n    res = REAL(pthread_create)(th, attr, __lsan_thread_start_func, &p);\n  }\n  if (res == 0) {\n    int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th, detached);\n    CHECK_NE(tid, 0);\n    atomic_store(&p.tid, tid, memory_order_release);\n    while (atomic_load(&p.tid, memory_order_acquire) != 0)\n      internal_sched_yield();\n  }\n  if (attr == &myattr)\n    pthread_attr_destroy(&myattr);\n  return res;\n}\n\nINTERCEPTOR(int, pthread_join, void *th, void **ret) {\n  ENSURE_LSAN_INITED;\n  int tid = ThreadTid((uptr)th);\n  int res = REAL(pthread_join)(th, ret);\n  if (res == 0)\n    ThreadJoin(tid);\n  return res;\n}\n\nnamespace __lsan {\n\nvoid InitializeInterceptors() {\n  INTERCEPT_FUNCTION(malloc);\n  INTERCEPT_FUNCTION(free);\n  INTERCEPT_FUNCTION(cfree);\n  INTERCEPT_FUNCTION(calloc);\n  INTERCEPT_FUNCTION(realloc);\n  INTERCEPT_FUNCTION(memalign);\n  INTERCEPT_FUNCTION(posix_memalign);\n  INTERCEPT_FUNCTION(__libc_memalign);\n  INTERCEPT_FUNCTION(valloc);\n  INTERCEPT_FUNCTION(pvalloc);\n  INTERCEPT_FUNCTION(malloc_usable_size);\n  INTERCEPT_FUNCTION(mallinfo);\n  INTERCEPT_FUNCTION(mallopt);\n  INTERCEPT_FUNCTION(pthread_create);\n  INTERCEPT_FUNCTION(pthread_join);\n\n  if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n    Report(\"LeakSanitizer: failed to create thread key.\\n\");\n    Die();\n  }\n}\n\n} // namespace __lsan\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libsanitizer/tsan/tsan_interceptors.cc": "//===-- tsan_interceptors.cc ----------------------------------------------===//\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer (TSan), a race detector.\n//\n// FIXME: move as many interceptors as possible into\n// sanitizer_common/sanitizer_common_interceptors.inc\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_common/sanitizer_atomic.h\"\n#include \"sanitizer_common/sanitizer_libc.h\"\n#include \"sanitizer_common/sanitizer_linux.h\"\n#include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_common/sanitizer_placement_new.h\"\n#include \"sanitizer_common/sanitizer_stacktrace.h\"\n#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n#include \"interception/interception.h\"\n#include \"tsan_interceptors.h\"\n#include \"tsan_interface.h\"\n#include \"tsan_platform.h\"\n#include \"tsan_suppressions.h\"\n#include \"tsan_rtl.h\"\n#include \"tsan_mman.h\"\n#include \"tsan_fd.h\"\n\n#if SANITIZER_POSIX\n#include \"sanitizer_common/sanitizer_posix.h\"\n#endif\n\nusing namespace __tsan;  // NOLINT\n\n#if SANITIZER_FREEBSD || SANITIZER_MAC\n#define __errno_location __error\n#define stdout __stdoutp\n#define stderr __stderrp\n#endif\n\n#if SANITIZER_ANDROID\n#define __errno_location __errno\n#define mallopt(a, b)\n#endif\n\n#if SANITIZER_LINUX || SANITIZER_FREEBSD\n#define PTHREAD_CREATE_DETACHED 1\n#elif SANITIZER_MAC\n#define PTHREAD_CREATE_DETACHED 2\n#endif\n\n\n#ifdef __mips__\nconst int kSigCount = 129;\n#else\nconst int kSigCount = 65;\n#endif\n\nstruct my_siginfo_t {\n  // The size is determined by looking at sizeof of real siginfo_t on linux.\n  u64 opaque[128 / sizeof(u64)];\n};\n\n#ifdef __mips__\nstruct ucontext_t {\n  u64 opaque[768 / sizeof(u64) + 1];\n};\n#else\nstruct ucontext_t {\n  // The size is determined by looking at sizeof of real ucontext_t on linux.\n  u64 opaque[936 / sizeof(u64) + 1];\n};\n#endif\n\n#if defined(__x86_64__) || defined(__mips__) || SANITIZER_PPC64V1\n#define PTHREAD_ABI_BASE  \"GLIBC_2.3.2\"\n#elif defined(__aarch64__) || SANITIZER_PPC64V2\n#define PTHREAD_ABI_BASE  \"GLIBC_2.17\"\n#endif\n\nextern \"C\" int pthread_attr_init(void *attr);\nextern \"C\" int pthread_attr_destroy(void *attr);\nDECLARE_REAL(int, pthread_attr_getdetachstate, void *, void *)\nextern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\nextern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\nextern \"C\" int pthread_setspecific(unsigned key, const void *v);\nDECLARE_REAL(int, pthread_mutexattr_gettype, void *, void *)\nDECLARE_REAL(int, fflush, __sanitizer_FILE *fp)\nDECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr size)\nDECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\nextern \"C\" void *pthread_self();\nextern \"C\" void _exit(int status);\nextern \"C\" int *__errno_location();\nextern \"C\" int fileno_unlocked(void *stream);\nextern \"C\" int dirfd(void *dirp);\n#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID\nextern \"C\" int mallopt(int param, int value);\n#endif\nextern __sanitizer_FILE *stdout, *stderr;\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC\nconst int PTHREAD_MUTEX_RECURSIVE = 1;\nconst int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n#else\nconst int PTHREAD_MUTEX_RECURSIVE = 2;\nconst int PTHREAD_MUTEX_RECURSIVE_NP = 2;\n#endif\nconst int EINVAL = 22;\nconst int EBUSY = 16;\nconst int EOWNERDEAD = 130;\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC\nconst int EPOLL_CTL_ADD = 1;\n#endif\nconst int SIGILL = 4;\nconst int SIGABRT = 6;\nconst int SIGFPE = 8;\nconst int SIGSEGV = 11;\nconst int SIGPIPE = 13;\nconst int SIGTERM = 15;\n#if defined(__mips__) || SANITIZER_FREEBSD || SANITIZER_MAC\nconst int SIGBUS = 10;\nconst int SIGSYS = 12;\n#else\nconst int SIGBUS = 7;\nconst int SIGSYS = 31;\n#endif\nvoid *const MAP_FAILED = (void*)-1;\n#if !SANITIZER_MAC\nconst int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n#endif\nconst int MAP_FIXED = 0x10;\ntypedef long long_t;  // NOLINT\n\n// From /usr/include/unistd.h\n# define F_ULOCK 0      /* Unlock a previously locked region.  */\n# define F_LOCK  1      /* Lock a region for exclusive use.  */\n# define F_TLOCK 2      /* Test and lock a region for exclusive use.  */\n# define F_TEST  3      /* Test a region for other processes locks.  */\n\n#define errno (*__errno_location())\n\ntypedef void (*sighandler_t)(int sig);\ntypedef void (*sigactionhandler_t)(int sig, my_siginfo_t *siginfo, void *uctx);\n\n#if SANITIZER_ANDROID\nstruct sigaction_t {\n  u32 sa_flags;\n  union {\n    sighandler_t sa_handler;\n    sigactionhandler_t sa_sigaction;\n  };\n  __sanitizer_sigset_t sa_mask;\n  void (*sa_restorer)();\n};\n#else\nstruct sigaction_t {\n#ifdef __mips__\n  u32 sa_flags;\n#endif\n  union {\n    sighandler_t sa_handler;\n    sigactionhandler_t sa_sigaction;\n  };\n#if SANITIZER_FREEBSD\n  int sa_flags;\n  __sanitizer_sigset_t sa_mask;\n#elif SANITIZER_MAC\n  __sanitizer_sigset_t sa_mask;\n  int sa_flags;\n#else\n  __sanitizer_sigset_t sa_mask;\n#ifndef __mips__\n  int sa_flags;\n#endif\n  void (*sa_restorer)();\n#endif\n};\n#endif\n\nconst sighandler_t SIG_DFL = (sighandler_t)0;\nconst sighandler_t SIG_IGN = (sighandler_t)1;\nconst sighandler_t SIG_ERR = (sighandler_t)-1;\n#if SANITIZER_FREEBSD || SANITIZER_MAC\nconst int SA_SIGINFO = 0x40;\nconst int SIG_SETMASK = 3;\n#elif defined(__mips__)\nconst int SA_SIGINFO = 8;\nconst int SIG_SETMASK = 3;\n#else\nconst int SA_SIGINFO = 4;\nconst int SIG_SETMASK = 2;\n#endif\n\n#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED \\\n  (!cur_thread()->is_inited)\n\nstatic sigaction_t sigactions[kSigCount];\n\nnamespace __tsan {\nstruct SignalDesc {\n  bool armed;\n  bool sigaction;\n  my_siginfo_t siginfo;\n  ucontext_t ctx;\n};\n\nstruct ThreadSignalContext {\n  int int_signal_send;\n  atomic_uintptr_t in_blocking_func;\n  atomic_uintptr_t have_pending_signals;\n  SignalDesc pending_signals[kSigCount];\n  // emptyset and oldset are too big for stack.\n  __sanitizer_sigset_t emptyset;\n  __sanitizer_sigset_t oldset;\n};\n\n// The object is 64-byte aligned, because we want hot data to be located in\n// a single cache line if possible (it's accessed in every interceptor).\nstatic ALIGNED(64) char libignore_placeholder[sizeof(LibIgnore)];\nstatic LibIgnore *libignore() {\n  return reinterpret_cast<LibIgnore*>(&libignore_placeholder[0]);\n}\n\nvoid InitializeLibIgnore() {\n  const SuppressionContext &supp = *Suppressions();\n  const uptr n = supp.SuppressionCount();\n  for (uptr i = 0; i < n; i++) {\n    const Suppression *s = supp.SuppressionAt(i);\n    if (0 == internal_strcmp(s->type, kSuppressionLib))\n      libignore()->AddIgnoredLibrary(s->templ);\n  }\n  libignore()->OnLibraryLoaded(0);\n}\n\n}  // namespace __tsan\n\nstatic ThreadSignalContext *SigCtx(ThreadState *thr) {\n  ThreadSignalContext *ctx = (ThreadSignalContext*)thr->signal_ctx;\n  if (ctx == 0 && !thr->is_dead) {\n    ctx = (ThreadSignalContext*)MmapOrDie(sizeof(*ctx), \"ThreadSignalContext\");\n    MemoryResetRange(thr, (uptr)&SigCtx, (uptr)ctx, sizeof(*ctx));\n    thr->signal_ctx = ctx;\n  }\n  return ctx;\n}\n\n#if !SANITIZER_MAC\nstatic unsigned g_thread_finalize_key;\n#endif\n\nScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                     uptr pc)\n    : thr_(thr)\n    , pc_(pc)\n    , in_ignored_lib_(false) {\n  Initialize(thr);\n  if (!thr_->is_inited)\n    return;\n  if (!thr_->ignore_interceptors)\n    FuncEntry(thr, pc);\n  DPrintf(\"#%d: intercept %s()\\n\", thr_->tid, fname);\n  if (!thr_->in_ignored_lib && libignore()->IsIgnored(pc)) {\n    in_ignored_lib_ = true;\n    thr_->in_ignored_lib = true;\n    ThreadIgnoreBegin(thr_, pc_);\n  }\n  if (flags()->ignore_interceptors_accesses) ThreadIgnoreBegin(thr_, pc_);\n}\n\nScopedInterceptor::~ScopedInterceptor() {\n  if (!thr_->is_inited)\n    return;\n  if (flags()->ignore_interceptors_accesses) ThreadIgnoreEnd(thr_, pc_);\n  if (in_ignored_lib_) {\n    thr_->in_ignored_lib = false;\n    ThreadIgnoreEnd(thr_, pc_);\n  }\n  if (!thr_->ignore_interceptors) {\n    ProcessPendingSignals(thr_);\n    FuncExit(thr_);\n    CheckNoLocks(thr_);\n  }\n}\n\nvoid ScopedInterceptor::UserCallbackStart() {\n  if (flags()->ignore_interceptors_accesses) ThreadIgnoreEnd(thr_, pc_);\n  if (in_ignored_lib_) {\n    thr_->in_ignored_lib = false;\n    ThreadIgnoreEnd(thr_, pc_);\n  }\n}\n\nvoid ScopedInterceptor::UserCallbackEnd() {\n  if (in_ignored_lib_) {\n    thr_->in_ignored_lib = true;\n    ThreadIgnoreBegin(thr_, pc_);\n  }\n  if (flags()->ignore_interceptors_accesses) ThreadIgnoreBegin(thr_, pc_);\n}\n\n#define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n#if SANITIZER_FREEBSD\n# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION(func)\n#else\n# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION_VER(func, ver)\n#endif\n\n#define READ_STRING_OF_LEN(thr, pc, s, len, n)                 \\\n  MemoryAccessRange((thr), (pc), (uptr)(s),                         \\\n    common_flags()->strict_string_checks ? (len) + 1 : (n), false)\n\n#define READ_STRING(thr, pc, s, n)                             \\\n    READ_STRING_OF_LEN((thr), (pc), (s), internal_strlen(s), (n))\n\n#define BLOCK_REAL(name) (BlockingCall(thr), REAL(name))\n\nstruct BlockingCall {\n  explicit BlockingCall(ThreadState *thr)\n      : thr(thr)\n      , ctx(SigCtx(thr)) {\n    for (;;) {\n      atomic_store(&ctx->in_blocking_func, 1, memory_order_relaxed);\n      if (atomic_load(&ctx->have_pending_signals, memory_order_relaxed) == 0)\n        break;\n      atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n      ProcessPendingSignals(thr);\n    }\n    // When we are in a \"blocking call\", we process signals asynchronously\n    // (right when they arrive). In this context we do not expect to be\n    // executing any user/runtime code. The known interceptor sequence when\n    // this is not true is: pthread_join -> munmap(stack). It's fine\n    // to ignore munmap in this case -- we handle stack shadow separately.\n    thr->ignore_interceptors++;\n  }\n\n  ~BlockingCall() {\n    thr->ignore_interceptors--;\n    atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n  }\n\n  ThreadState *thr;\n  ThreadSignalContext *ctx;\n};\n\nTSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n  SCOPED_TSAN_INTERCEPTOR(sleep, sec);\n  unsigned res = BLOCK_REAL(sleep)(sec);\n  AfterSleep(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, usleep, long_t usec) {\n  SCOPED_TSAN_INTERCEPTOR(usleep, usec);\n  int res = BLOCK_REAL(usleep)(usec);\n  AfterSleep(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n  SCOPED_TSAN_INTERCEPTOR(nanosleep, req, rem);\n  int res = BLOCK_REAL(nanosleep)(req, rem);\n  AfterSleep(thr, pc);\n  return res;\n}\n\n// The sole reason tsan wraps atexit callbacks is to establish synchronization\n// between callback setup and callback execution.\nstruct AtExitCtx {\n  void (*f)();\n  void *arg;\n};\n\nstatic void at_exit_wrapper(void *arg) {\n  ThreadState *thr = cur_thread();\n  uptr pc = 0;\n  Acquire(thr, pc, (uptr)arg);\n  AtExitCtx *ctx = (AtExitCtx*)arg;\n  ((void(*)(void *arg))ctx->f)(ctx->arg);\n  InternalFree(ctx);\n}\n\nstatic int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n      void *arg, void *dso);\n\n#if !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n  if (cur_thread()->in_symbolizer)\n    return 0;\n  // We want to setup the atexit callback even if we are in ignored lib\n  // or after fork.\n  SCOPED_INTERCEPTOR_RAW(atexit, f);\n  return setup_at_exit_wrapper(thr, pc, (void(*)())f, 0, 0);\n}\n#endif\n\nTSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n  if (cur_thread()->in_symbolizer)\n    return 0;\n  SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n  return setup_at_exit_wrapper(thr, pc, (void(*)())f, arg, dso);\n}\n\nstatic int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n      void *arg, void *dso) {\n  AtExitCtx *ctx = (AtExitCtx*)InternalAlloc(sizeof(AtExitCtx));\n  ctx->f = f;\n  ctx->arg = arg;\n  Release(thr, pc, (uptr)ctx);\n  // Memory allocation in __cxa_atexit will race with free during exit,\n  // because we do not see synchronization around atexit callback list.\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(__cxa_atexit)(at_exit_wrapper, ctx, dso);\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n\n#if !SANITIZER_MAC\nstatic void on_exit_wrapper(int status, void *arg) {\n  ThreadState *thr = cur_thread();\n  uptr pc = 0;\n  Acquire(thr, pc, (uptr)arg);\n  AtExitCtx *ctx = (AtExitCtx*)arg;\n  ((void(*)(int status, void *arg))ctx->f)(status, ctx->arg);\n  InternalFree(ctx);\n}\n\nTSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n  if (cur_thread()->in_symbolizer)\n    return 0;\n  SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n  AtExitCtx *ctx = (AtExitCtx*)InternalAlloc(sizeof(AtExitCtx));\n  ctx->f = (void(*)())f;\n  ctx->arg = arg;\n  Release(thr, pc, (uptr)ctx);\n  // Memory allocation in __cxa_atexit will race with free during exit,\n  // because we do not see synchronization around atexit callback list.\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(on_exit)(on_exit_wrapper, ctx);\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n#endif\n\n// Cleanup old bufs.\nstatic void JmpBufGarbageCollect(ThreadState *thr, uptr sp) {\n  for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n    JmpBuf *buf = &thr->jmp_bufs[i];\n    if (buf->sp <= sp) {\n      uptr sz = thr->jmp_bufs.Size();\n      internal_memcpy(buf, &thr->jmp_bufs[sz - 1], sizeof(*buf));\n      thr->jmp_bufs.PopBack();\n      i--;\n    }\n  }\n}\n\nstatic void SetJmp(ThreadState *thr, uptr sp, uptr mangled_sp) {\n  if (!thr->is_inited)  // called from libc guts during bootstrap\n    return;\n  // Cleanup old bufs.\n  JmpBufGarbageCollect(thr, sp);\n  // Remember the buf.\n  JmpBuf *buf = thr->jmp_bufs.PushBack();\n  buf->sp = sp;\n  buf->mangled_sp = mangled_sp;\n  buf->shadow_stack_pos = thr->shadow_stack_pos;\n  ThreadSignalContext *sctx = SigCtx(thr);\n  buf->int_signal_send = sctx ? sctx->int_signal_send : 0;\n  buf->in_blocking_func = sctx ?\n      atomic_load(&sctx->in_blocking_func, memory_order_relaxed) :\n      false;\n  buf->in_signal_handler = atomic_load(&thr->in_signal_handler,\n      memory_order_relaxed);\n}\n\nstatic void LongJmp(ThreadState *thr, uptr *env) {\n#ifdef __powerpc__\n  uptr mangled_sp = env[0];\n#elif SANITIZER_FREEBSD || SANITIZER_MAC\n  uptr mangled_sp = env[2];\n#elif defined(SANITIZER_LINUX)\n# ifdef __aarch64__\n  uptr mangled_sp = env[13];\n# elif defined(__mips64)\n  uptr mangled_sp = env[1];\n# else\n  uptr mangled_sp = env[6];\n# endif\n#endif\n  // Find the saved buf by mangled_sp.\n  for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n    JmpBuf *buf = &thr->jmp_bufs[i];\n    if (buf->mangled_sp == mangled_sp) {\n      CHECK_GE(thr->shadow_stack_pos, buf->shadow_stack_pos);\n      // Unwind the stack.\n      while (thr->shadow_stack_pos > buf->shadow_stack_pos)\n        FuncExit(thr);\n      ThreadSignalContext *sctx = SigCtx(thr);\n      if (sctx) {\n        sctx->int_signal_send = buf->int_signal_send;\n        atomic_store(&sctx->in_blocking_func, buf->in_blocking_func,\n            memory_order_relaxed);\n      }\n      atomic_store(&thr->in_signal_handler, buf->in_signal_handler,\n          memory_order_relaxed);\n      JmpBufGarbageCollect(thr, buf->sp - 1);  // do not collect buf->sp\n      return;\n    }\n  }\n  Printf(\"ThreadSanitizer: can't find longjmp buf\\n\");\n  CHECK(0);\n}\n\n// FIXME: put everything below into a common extern \"C\" block?\nextern \"C\" void __tsan_setjmp(uptr sp, uptr mangled_sp) {\n  SetJmp(cur_thread(), sp, mangled_sp);\n}\n\n#if SANITIZER_MAC\nTSAN_INTERCEPTOR(int, setjmp, void *env);\nTSAN_INTERCEPTOR(int, _setjmp, void *env);\nTSAN_INTERCEPTOR(int, sigsetjmp, void *env);\n#else  // SANITIZER_MAC\n// Not called.  Merely to satisfy TSAN_INTERCEPT().\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor_setjmp(void *env);\nextern \"C\" int __interceptor_setjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n\n// FIXME: any reason to have a separate declaration?\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor__setjmp(void *env);\nextern \"C\" int __interceptor__setjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor_sigsetjmp(void *env);\nextern \"C\" int __interceptor_sigsetjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor___sigsetjmp(void *env);\nextern \"C\" int __interceptor___sigsetjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n\nextern \"C\" int setjmp(void *env);\nextern \"C\" int _setjmp(void *env);\nextern \"C\" int sigsetjmp(void *env);\nextern \"C\" int __sigsetjmp(void *env);\nDEFINE_REAL(int, setjmp, void *env)\nDEFINE_REAL(int, _setjmp, void *env)\nDEFINE_REAL(int, sigsetjmp, void *env)\nDEFINE_REAL(int, __sigsetjmp, void *env)\n#endif  // SANITIZER_MAC\n\nTSAN_INTERCEPTOR(void, longjmp, uptr *env, int val) {\n  // Note: if we call REAL(longjmp) in the context of ScopedInterceptor,\n  // bad things will happen. We will jump over ScopedInterceptor dtor and can\n  // leave thr->in_ignored_lib set.\n  {\n    SCOPED_INTERCEPTOR_RAW(longjmp, env, val);\n  }\n  LongJmp(cur_thread(), env);\n  REAL(longjmp)(env, val);\n}\n\nTSAN_INTERCEPTOR(void, siglongjmp, uptr *env, int val) {\n  {\n    SCOPED_INTERCEPTOR_RAW(siglongjmp, env, val);\n  }\n  LongJmp(cur_thread(), env);\n  REAL(siglongjmp)(env, val);\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(void*, malloc, uptr size) {\n  if (cur_thread()->in_symbolizer)\n    return InternalAlloc(size);\n  void *p = 0;\n  {\n    SCOPED_INTERCEPTOR_RAW(malloc, size);\n    p = user_alloc(thr, pc, size);\n  }\n  invoke_malloc_hook(p, size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n  SCOPED_TSAN_INTERCEPTOR(__libc_memalign, align, sz);\n  return user_alloc(thr, pc, sz, align);\n}\n\nTSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n  if (cur_thread()->in_symbolizer)\n    return InternalCalloc(size, n);\n  void *p = 0;\n  {\n    SCOPED_INTERCEPTOR_RAW(calloc, size, n);\n    p = user_calloc(thr, pc, size, n);\n  }\n  invoke_malloc_hook(p, n * size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n  if (cur_thread()->in_symbolizer)\n    return InternalRealloc(p, size);\n  if (p)\n    invoke_free_hook(p);\n  {\n    SCOPED_INTERCEPTOR_RAW(realloc, p, size);\n    p = user_realloc(thr, pc, p, size);\n  }\n  invoke_malloc_hook(p, size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void, free, void *p) {\n  if (p == 0)\n    return;\n  if (cur_thread()->in_symbolizer)\n    return InternalFree(p);\n  invoke_free_hook(p);\n  SCOPED_INTERCEPTOR_RAW(free, p);\n  user_free(thr, pc, p);\n}\n\nTSAN_INTERCEPTOR(void, cfree, void *p) {\n  if (p == 0)\n    return;\n  if (cur_thread()->in_symbolizer)\n    return InternalFree(p);\n  invoke_free_hook(p);\n  SCOPED_INTERCEPTOR_RAW(cfree, p);\n  user_free(thr, pc, p);\n}\n\nTSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n  SCOPED_INTERCEPTOR_RAW(malloc_usable_size, p);\n  return user_alloc_usable_size(p);\n}\n#endif\n\nTSAN_INTERCEPTOR(char*, strcpy, char *dst, const char *src) {  // NOLINT\n  SCOPED_TSAN_INTERCEPTOR(strcpy, dst, src);  // NOLINT\n  uptr srclen = internal_strlen(src);\n  MemoryAccessRange(thr, pc, (uptr)dst, srclen + 1, true);\n  MemoryAccessRange(thr, pc, (uptr)src, srclen + 1, false);\n  return REAL(strcpy)(dst, src);  // NOLINT\n}\n\nTSAN_INTERCEPTOR(char*, strncpy, char *dst, char *src, uptr n) {\n  SCOPED_TSAN_INTERCEPTOR(strncpy, dst, src, n);\n  uptr srclen = internal_strnlen(src, n);\n  MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n  MemoryAccessRange(thr, pc, (uptr)src, min(srclen + 1, n), false);\n  return REAL(strncpy)(dst, src, n);\n}\n\nTSAN_INTERCEPTOR(char*, strdup, const char *str) {\n  SCOPED_TSAN_INTERCEPTOR(strdup, str);\n  // strdup will call malloc, so no instrumentation is required here.\n  return REAL(strdup)(str);\n}\n\nstatic bool fix_mmap_addr(void **addr, long_t sz, int flags) {\n  if (*addr) {\n    if (!IsAppMem((uptr)*addr) || !IsAppMem((uptr)*addr + sz - 1)) {\n      if (flags & MAP_FIXED) {\n        errno = EINVAL;\n        return false;\n      } else {\n        *addr = 0;\n      }\n    }\n  }\n  return true;\n}\n\nTSAN_INTERCEPTOR(void *, mmap, void *addr, SIZE_T sz, int prot, int flags,\n                 int fd, OFF_T off) {\n  SCOPED_TSAN_INTERCEPTOR(mmap, addr, sz, prot, flags, fd, off);\n  if (!fix_mmap_addr(&addr, sz, flags))\n    return MAP_FAILED;\n  void *res = REAL(mmap)(addr, sz, prot, flags, fd, off);\n  if (res != MAP_FAILED) {\n    if (fd > 0)\n      FdAccess(thr, pc, fd);\n\n    if (thr->ignore_reads_and_writes == 0)\n      MemoryRangeImitateWrite(thr, pc, (uptr)res, sz);\n    else\n      MemoryResetRange(thr, pc, (uptr)res, sz);\n  }\n  return res;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void *, mmap64, void *addr, SIZE_T sz, int prot, int flags,\n                 int fd, OFF64_T off) {\n  SCOPED_TSAN_INTERCEPTOR(mmap64, addr, sz, prot, flags, fd, off);\n  if (!fix_mmap_addr(&addr, sz, flags))\n    return MAP_FAILED;\n  void *res = REAL(mmap64)(addr, sz, prot, flags, fd, off);\n  if (res != MAP_FAILED) {\n    if (fd > 0)\n      FdAccess(thr, pc, fd);\n\n    if (thr->ignore_reads_and_writes == 0)\n      MemoryRangeImitateWrite(thr, pc, (uptr)res, sz);\n    else\n      MemoryResetRange(thr, pc, (uptr)res, sz);\n  }\n  return res;\n}\n#define TSAN_MAYBE_INTERCEPT_MMAP64 TSAN_INTERCEPT(mmap64)\n#else\n#define TSAN_MAYBE_INTERCEPT_MMAP64\n#endif\n\nTSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n  SCOPED_TSAN_INTERCEPTOR(munmap, addr, sz);\n  if (sz != 0) {\n    // If sz == 0, munmap will return EINVAL and don't unmap any memory.\n    DontNeedShadowFor((uptr)addr, sz);\n    ScopedGlobalProcessor sgp;\n    ctx->metamap.ResetRange(thr->proc(), (uptr)addr, (uptr)sz);\n  }\n  int res = REAL(munmap)(addr, sz);\n  return res;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n  return user_alloc(thr, pc, sz, align);\n}\n#define TSAN_MAYBE_INTERCEPT_MEMALIGN TSAN_INTERCEPT(memalign)\n#else\n#define TSAN_MAYBE_INTERCEPT_MEMALIGN\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n  return user_alloc(thr, pc, sz, align);\n}\n\nTSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(valloc, sz);\n  return user_alloc(thr, pc, sz, GetPageSizeCached());\n}\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(pvalloc, sz);\n  sz = RoundUp(sz, GetPageSizeCached());\n  return user_alloc(thr, pc, sz, GetPageSizeCached());\n}\n#define TSAN_MAYBE_INTERCEPT_PVALLOC TSAN_INTERCEPT(pvalloc)\n#else\n#define TSAN_MAYBE_INTERCEPT_PVALLOC\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(posix_memalign, memptr, align, sz);\n  *memptr = user_alloc(thr, pc, sz, align);\n  return 0;\n}\n#endif\n\n// __cxa_guard_acquire and friends need to be intercepted in a special way -\n// regular interceptors will break statically-linked libstdc++. Linux\n// interceptors are especially defined as weak functions (so that they don't\n// cause link errors when user defines them as well). So they silently\n// auto-disable themselves when such symbol is already present in the binary. If\n// we link libstdc++ statically, it will bring own __cxa_guard_acquire which\n// will silently replace our interceptor.  That's why on Linux we simply export\n// these interceptors with INTERFACE_ATTRIBUTE.\n// On OS X, we don't support statically linking, so we just use a regular\n// interceptor.\n#if SANITIZER_MAC\n#define STDCXX_INTERCEPTOR TSAN_INTERCEPTOR\n#else\n#define STDCXX_INTERCEPTOR(rettype, name, ...) \\\n  extern \"C\" rettype INTERFACE_ATTRIBUTE name(__VA_ARGS__)\n#endif\n\n// Used in thread-safe function static initialization.\nSTDCXX_INTERCEPTOR(int, __cxa_guard_acquire, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_acquire, g);\n  for (;;) {\n    u32 cmp = atomic_load(g, memory_order_acquire);\n    if (cmp == 0) {\n      if (atomic_compare_exchange_strong(g, &cmp, 1<<16, memory_order_relaxed))\n        return 1;\n    } else if (cmp == 1) {\n      Acquire(thr, pc, (uptr)g);\n      return 0;\n    } else {\n      internal_sched_yield();\n    }\n  }\n}\n\nSTDCXX_INTERCEPTOR(void, __cxa_guard_release, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_release, g);\n  Release(thr, pc, (uptr)g);\n  atomic_store(g, 1, memory_order_release);\n}\n\nSTDCXX_INTERCEPTOR(void, __cxa_guard_abort, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_abort, g);\n  atomic_store(g, 0, memory_order_relaxed);\n}\n\nnamespace __tsan {\nvoid DestroyThreadState() {\n  ThreadState *thr = cur_thread();\n  Processor *proc = thr->proc();\n  ThreadFinish(thr);\n  ProcUnwire(proc, thr);\n  ProcDestroy(proc);\n  ThreadSignalContext *sctx = thr->signal_ctx;\n  if (sctx) {\n    thr->signal_ctx = 0;\n    UnmapOrDie(sctx, sizeof(*sctx));\n  }\n  DTLS_Destroy();\n  cur_thread_finalize();\n}\n}  // namespace __tsan\n\n#if !SANITIZER_MAC\nstatic void thread_finalize(void *v) {\n  uptr iter = (uptr)v;\n  if (iter > 1) {\n    if (pthread_setspecific(g_thread_finalize_key, (void*)(iter - 1))) {\n      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n      Die();\n    }\n    return;\n  }\n  DestroyThreadState();\n}\n#endif\n\n\nstruct ThreadParam {\n  void* (*callback)(void *arg);\n  void *param;\n  atomic_uintptr_t tid;\n};\n\nextern \"C\" void *__tsan_thread_start_func(void *arg) {\n  ThreadParam *p = (ThreadParam*)arg;\n  void* (*callback)(void *arg) = p->callback;\n  void *param = p->param;\n  int tid = 0;\n  {\n    ThreadState *thr = cur_thread();\n    // Thread-local state is not initialized yet.\n    ScopedIgnoreInterceptors ignore;\n#if !SANITIZER_MAC\n    ThreadIgnoreBegin(thr, 0);\n    if (pthread_setspecific(g_thread_finalize_key,\n                            (void *)GetPthreadDestructorIterations())) {\n      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n      Die();\n    }\n    ThreadIgnoreEnd(thr, 0);\n#endif\n    while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n      internal_sched_yield();\n    Processor *proc = ProcCreate();\n    ProcWire(proc, thr);\n    ThreadStart(thr, tid, GetTid());\n    atomic_store(&p->tid, 0, memory_order_release);\n  }\n  void *res = callback(param);\n  // Prevent the callback from being tail called,\n  // it mixes up stack traces.\n  volatile int foo = 42;\n  foo++;\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_create,\n    void *th, void *attr, void *(*callback)(void*), void * param) {\n  SCOPED_INTERCEPTOR_RAW(pthread_create, th, attr, callback, param);\n  if (ctx->after_multithreaded_fork) {\n    if (flags()->die_after_fork) {\n      Report(\"ThreadSanitizer: starting new threads after multi-threaded \"\n          \"fork is not supported. Dying (set die_after_fork=0 to override)\\n\");\n      Die();\n    } else {\n      VPrintf(1, \"ThreadSanitizer: starting new threads after multi-threaded \"\n          \"fork is not supported (pid %d). Continuing because of \"\n          \"die_after_fork=0, but you are on your own\\n\", internal_getpid());\n    }\n  }\n  __sanitizer_pthread_attr_t myattr;\n  if (attr == 0) {\n    pthread_attr_init(&myattr);\n    attr = &myattr;\n  }\n  int detached = 0;\n  REAL(pthread_attr_getdetachstate)(attr, &detached);\n  AdjustStackSize(attr);\n\n  ThreadParam p;\n  p.callback = callback;\n  p.param = param;\n  atomic_store(&p.tid, 0, memory_order_relaxed);\n  int res = -1;\n  {\n    // Otherwise we see false positives in pthread stack manipulation.\n    ScopedIgnoreInterceptors ignore;\n    ThreadIgnoreBegin(thr, pc);\n    res = REAL(pthread_create)(th, attr, __tsan_thread_start_func, &p);\n    ThreadIgnoreEnd(thr, pc);\n  }\n  if (res == 0) {\n    int tid = ThreadCreate(thr, pc, *(uptr*)th,\n                           detached == PTHREAD_CREATE_DETACHED);\n    CHECK_NE(tid, 0);\n    // Synchronization on p.tid serves two purposes:\n    // 1. ThreadCreate must finish before the new thread starts.\n    //    Otherwise the new thread can call pthread_detach, but the pthread_t\n    //    identifier is not yet registered in ThreadRegistry by ThreadCreate.\n    // 2. ThreadStart must finish before this thread continues.\n    //    Otherwise, this thread can call pthread_detach and reset thr->sync\n    //    before the new thread got a chance to acquire from it in ThreadStart.\n    atomic_store(&p.tid, tid, memory_order_release);\n    while (atomic_load(&p.tid, memory_order_acquire) != 0)\n      internal_sched_yield();\n  }\n  if (attr == &myattr)\n    pthread_attr_destroy(&myattr);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n  SCOPED_INTERCEPTOR_RAW(pthread_join, th, ret);\n  int tid = ThreadTid(thr, pc, (uptr)th);\n  ThreadIgnoreBegin(thr, pc);\n  int res = BLOCK_REAL(pthread_join)(th, ret);\n  ThreadIgnoreEnd(thr, pc);\n  if (res == 0) {\n    ThreadJoin(thr, pc, tid);\n  }\n  return res;\n}\n\nDEFINE_REAL_PTHREAD_FUNCTIONS\n\nTSAN_INTERCEPTOR(int, pthread_detach, void *th) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_detach, th);\n  int tid = ThreadTid(thr, pc, (uptr)th);\n  int res = REAL(pthread_detach)(th);\n  if (res == 0) {\n    ThreadDetach(thr, pc, tid);\n  }\n  return res;\n}\n\n// Problem:\n// NPTL implementation of pthread_cond has 2 versions (2.2.5 and 2.3.2).\n// pthread_cond_t has different size in the different versions.\n// If call new REAL functions for old pthread_cond_t, they will corrupt memory\n// after pthread_cond_t (old cond is smaller).\n// If we call old REAL functions for new pthread_cond_t, we will lose  some\n// functionality (e.g. old functions do not support waiting against\n// CLOCK_REALTIME).\n// Proper handling would require to have 2 versions of interceptors as well.\n// But this is messy, in particular requires linker scripts when sanitizer\n// runtime is linked into a shared library.\n// Instead we assume we don't have dynamic libraries built against old\n// pthread (2.2.5 is dated by 2002). And provide legacy_pthread_cond flag\n// that allows to work with old libraries (but this mode does not support\n// some features, e.g. pthread_condattr_getpshared).\nstatic void *init_cond(void *c, bool force = false) {\n  // sizeof(pthread_cond_t) >= sizeof(uptr) in both versions.\n  // So we allocate additional memory on the side large enough to hold\n  // any pthread_cond_t object. Always call new REAL functions, but pass\n  // the aux object to them.\n  // Note: the code assumes that PTHREAD_COND_INITIALIZER initializes\n  // first word of pthread_cond_t to zero.\n  // It's all relevant only for linux.\n  if (!common_flags()->legacy_pthread_cond)\n    return c;\n  atomic_uintptr_t *p = (atomic_uintptr_t*)c;\n  uptr cond = atomic_load(p, memory_order_acquire);\n  if (!force && cond != 0)\n    return (void*)cond;\n  void *newcond = WRAP(malloc)(pthread_cond_t_sz);\n  internal_memset(newcond, 0, pthread_cond_t_sz);\n  if (atomic_compare_exchange_strong(p, &cond, (uptr)newcond,\n      memory_order_acq_rel))\n    return newcond;\n  WRAP(free)(newcond);\n  return (void*)cond;\n}\n\nstruct CondMutexUnlockCtx {\n  ScopedInterceptor *si;\n  ThreadState *thr;\n  uptr pc;\n  void *m;\n};\n\nstatic void cond_mutex_unlock(CondMutexUnlockCtx *arg) {\n  // pthread_cond_wait interceptor has enabled async signal delivery\n  // (see BlockingCall below). Disable async signals since we are running\n  // tsan code. Also ScopedInterceptor and BlockingCall destructors won't run\n  // since the thread is cancelled, so we have to manually execute them\n  // (the thread still can run some user code due to pthread_cleanup_push).\n  ThreadSignalContext *ctx = SigCtx(arg->thr);\n  CHECK_EQ(atomic_load(&ctx->in_blocking_func, memory_order_relaxed), 1);\n  atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n  MutexLock(arg->thr, arg->pc, (uptr)arg->m);\n  // Undo BlockingCall ctor effects.\n  arg->thr->ignore_interceptors--;\n  arg->si->~ScopedInterceptor();\n}\n\nINTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n  void *cond = init_cond(c, true);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_init, cond, a);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), true);\n  return REAL(pthread_cond_init)(cond, a);\n}\n\nstatic int cond_wait(ThreadState *thr, uptr pc, ScopedInterceptor *si,\n                     int (*fn)(void *c, void *m, void *abstime), void *c,\n                     void *m, void *t) {\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  MutexUnlock(thr, pc, (uptr)m);\n  CondMutexUnlockCtx arg = {si, thr, pc, m};\n  int res = 0;\n  // This ensures that we handle mutex lock even in case of pthread_cancel.\n  // See test/tsan/cond_cancel.cc.\n  {\n    // Enable signal delivery while the thread is blocked.\n    BlockingCall bc(thr);\n    res = call_pthread_cancel_with_cleanup(\n        fn, c, m, t, (void (*)(void *arg))cond_mutex_unlock, &arg);\n  }\n  if (res == errno_EOWNERDEAD) MutexRepair(thr, pc, (uptr)m);\n  MutexLock(thr, pc, (uptr)m);\n  return res;\n}\n\nINTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_wait, cond, m);\n  return cond_wait(thr, pc, &si, (int (*)(void *c, void *m, void *abstime))REAL(\n                                     pthread_cond_wait),\n                   cond, m, 0);\n}\n\nINTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait, cond, m, abstime);\n  return cond_wait(thr, pc, &si, REAL(pthread_cond_timedwait), cond, m,\n                   abstime);\n}\n\n#if SANITIZER_MAC\nINTERCEPTOR(int, pthread_cond_timedwait_relative_np, void *c, void *m,\n            void *reltime) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait_relative_np, cond, m, reltime);\n  return cond_wait(thr, pc, &si, REAL(pthread_cond_timedwait_relative_np), cond,\n                   m, reltime);\n}\n#endif\n\nINTERCEPTOR(int, pthread_cond_signal, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_signal, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  return REAL(pthread_cond_signal)(cond);\n}\n\nINTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_broadcast, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  return REAL(pthread_cond_broadcast)(cond);\n}\n\nINTERCEPTOR(int, pthread_cond_destroy, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_destroy, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), true);\n  int res = REAL(pthread_cond_destroy)(cond);\n  if (common_flags()->legacy_pthread_cond) {\n    // Free our aux cond and zero the pointer to not leave dangling pointers.\n    WRAP(free)(cond);\n    atomic_store((atomic_uintptr_t*)c, 0, memory_order_relaxed);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_init, void *m, void *a) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_init, m, a);\n  int res = REAL(pthread_mutex_init)(m, a);\n  if (res == 0) {\n    bool recursive = false;\n    if (a) {\n      int type = 0;\n      if (REAL(pthread_mutexattr_gettype)(a, &type) == 0)\n        recursive = (type == PTHREAD_MUTEX_RECURSIVE\n            || type == PTHREAD_MUTEX_RECURSIVE_NP);\n    }\n    MutexCreate(thr, pc, (uptr)m, false, recursive, false);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_destroy, m);\n  int res = REAL(pthread_mutex_destroy)(m);\n  if (res == 0 || res == EBUSY) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_trylock, m);\n  int res = REAL(pthread_mutex_trylock)(m);\n  if (res == EOWNERDEAD)\n    MutexRepair(thr, pc, (uptr)m);\n  if (res == 0 || res == EOWNERDEAD)\n    MutexLock(thr, pc, (uptr)m, /*rec=*/1, /*try_lock=*/true);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_timedlock, m, abstime);\n  int res = REAL(pthread_mutex_timedlock)(m, abstime);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n  int res = REAL(pthread_spin_init)(m, pshared);\n  if (res == 0) {\n    MutexCreate(thr, pc, (uptr)m, false, false, false);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_destroy, m);\n  int res = REAL(pthread_spin_destroy)(m);\n  if (res == 0) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_lock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_lock, m);\n  int res = REAL(pthread_spin_lock)(m);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_trylock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_trylock, m);\n  int res = REAL(pthread_spin_trylock)(m);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m, /*rec=*/1, /*try_lock=*/true);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_unlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_unlock, m);\n  MutexUnlock(thr, pc, (uptr)m);\n  int res = REAL(pthread_spin_unlock)(m);\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_init, void *m, void *a) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_init, m, a);\n  int res = REAL(pthread_rwlock_init)(m, a);\n  if (res == 0) {\n    MutexCreate(thr, pc, (uptr)m, true, false, false);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_destroy, m);\n  int res = REAL(pthread_rwlock_destroy)(m);\n  if (res == 0) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_rdlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_rdlock, m);\n  int res = REAL(pthread_rwlock_rdlock)(m);\n  if (res == 0) {\n    MutexReadLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_tryrdlock, m);\n  int res = REAL(pthread_rwlock_tryrdlock)(m);\n  if (res == 0) {\n    MutexReadLock(thr, pc, (uptr)m, /*try_lock=*/true);\n  }\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedrdlock, m, abstime);\n  int res = REAL(pthread_rwlock_timedrdlock)(m, abstime);\n  if (res == 0) {\n    MutexReadLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_wrlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_wrlock, m);\n  int res = REAL(pthread_rwlock_wrlock)(m);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_trywrlock, m);\n  int res = REAL(pthread_rwlock_trywrlock)(m);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m, /*rec=*/1, /*try_lock=*/true);\n  }\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedwrlock, m, abstime);\n  int res = REAL(pthread_rwlock_timedwrlock)(m, abstime);\n  if (res == 0) {\n    MutexLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_unlock, m);\n  MutexReadOrWriteUnlock(thr, pc, (uptr)m);\n  int res = REAL(pthread_rwlock_unlock)(m);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_init)(b, a, count);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_barrier_destroy, void *b) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_destroy, b);\n  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_destroy)(b);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_wait, b);\n  Release(thr, pc, (uptr)b);\n  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_wait)(b);\n  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n  if (res == 0 || res == PTHREAD_BARRIER_SERIAL_THREAD) {\n    Acquire(thr, pc, (uptr)b);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n  SCOPED_INTERCEPTOR_RAW(pthread_once, o, f);\n  if (o == 0 || f == 0)\n    return EINVAL;\n  atomic_uint32_t *a;\n  if (!SANITIZER_MAC)\n    a = static_cast<atomic_uint32_t*>(o);\n  else  // On OS X, pthread_once_t has a header with a long-sized signature.\n    a = static_cast<atomic_uint32_t*>((void *)((char *)o + sizeof(long_t)));\n  u32 v = atomic_load(a, memory_order_acquire);\n  if (v == 0 && atomic_compare_exchange_strong(a, &v, 1,\n                                               memory_order_relaxed)) {\n    (*f)();\n    if (!thr->in_ignored_lib)\n      Release(thr, pc, (uptr)o);\n    atomic_store(a, 2, memory_order_release);\n  } else {\n    while (v != 2) {\n      internal_sched_yield();\n      v = atomic_load(a, memory_order_acquire);\n    }\n    if (!thr->in_ignored_lib)\n      Acquire(thr, pc, (uptr)o);\n  }\n  return 0;\n}\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat, version, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat)(version, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT___FXSTAT TSAN_INTERCEPT(__fxstat)\n#else\n#define TSAN_MAYBE_INTERCEPT___FXSTAT\n#endif\n\nTSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_ANDROID\n  SCOPED_TSAN_INTERCEPTOR(fstat, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(fstat)(fd, buf);\n#else\n  SCOPED_TSAN_INTERCEPTOR(__fxstat, 0, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat)(0, fd, buf);\n#endif\n}\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat64, version, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat64)(version, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT___FXSTAT64 TSAN_INTERCEPT(__fxstat64)\n#else\n#define TSAN_MAYBE_INTERCEPT___FXSTAT64\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat64, 0, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat64)(0, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT_FSTAT64 TSAN_INTERCEPT(fstat64)\n#else\n#define TSAN_MAYBE_INTERCEPT_FSTAT64\n#endif\n\nTSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(open, name, flags, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(open)(name, flags, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, open64, const char *name, int flags, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(open64, name, flags, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(open64)(name, flags, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_OPEN64 TSAN_INTERCEPT(open64)\n#else\n#define TSAN_MAYBE_INTERCEPT_OPEN64\n#endif\n\nTSAN_INTERCEPTOR(int, creat, const char *name, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(creat, name, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(creat)(name, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, creat64, const char *name, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(creat64, name, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(creat64)(name, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_CREAT64 TSAN_INTERCEPT(creat64)\n#else\n#define TSAN_MAYBE_INTERCEPT_CREAT64\n#endif\n\nTSAN_INTERCEPTOR(int, dup, int oldfd) {\n  SCOPED_TSAN_INTERCEPTOR(dup, oldfd);\n  int newfd = REAL(dup)(oldfd);\n  if (oldfd >= 0 && newfd >= 0 && newfd != oldfd)\n    FdDup(thr, pc, oldfd, newfd, true);\n  return newfd;\n}\n\nTSAN_INTERCEPTOR(int, dup2, int oldfd, int newfd) {\n  SCOPED_TSAN_INTERCEPTOR(dup2, oldfd, newfd);\n  int newfd2 = REAL(dup2)(oldfd, newfd);\n  if (oldfd >= 0 && newfd2 >= 0 && newfd2 != oldfd)\n    FdDup(thr, pc, oldfd, newfd2, false);\n  return newfd2;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(dup3, oldfd, newfd, flags);\n  int newfd2 = REAL(dup3)(oldfd, newfd, flags);\n  if (oldfd >= 0 && newfd2 >= 0 && newfd2 != oldfd)\n    FdDup(thr, pc, oldfd, newfd2, false);\n  return newfd2;\n}\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(eventfd, initval, flags);\n  int fd = REAL(eventfd)(initval, flags);\n  if (fd >= 0)\n    FdEventCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_EVENTFD TSAN_INTERCEPT(eventfd)\n#else\n#define TSAN_MAYBE_INTERCEPT_EVENTFD\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(signalfd, fd, mask, flags);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  fd = REAL(signalfd)(fd, mask, flags);\n  if (fd >= 0)\n    FdSignalCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_SIGNALFD TSAN_INTERCEPT(signalfd)\n#else\n#define TSAN_MAYBE_INTERCEPT_SIGNALFD\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, inotify_init, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(inotify_init, fake);\n  int fd = REAL(inotify_init)(fake);\n  if (fd >= 0)\n    FdInotifyCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT TSAN_INTERCEPT(inotify_init)\n#else\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, inotify_init1, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(inotify_init1, flags);\n  int fd = REAL(inotify_init1)(flags);\n  if (fd >= 0)\n    FdInotifyCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1 TSAN_INTERCEPT(inotify_init1)\n#else\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1\n#endif\n\nTSAN_INTERCEPTOR(int, socket, int domain, int type, int protocol) {\n  SCOPED_TSAN_INTERCEPTOR(socket, domain, type, protocol);\n  int fd = REAL(socket)(domain, type, protocol);\n  if (fd >= 0)\n    FdSocketCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, socketpair, int domain, int type, int protocol, int *fd) {\n  SCOPED_TSAN_INTERCEPTOR(socketpair, domain, type, protocol, fd);\n  int res = REAL(socketpair)(domain, type, protocol, fd);\n  if (res == 0 && fd[0] >= 0 && fd[1] >= 0)\n    FdPipeCreate(thr, pc, fd[0], fd[1]);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, connect, int fd, void *addr, unsigned addrlen) {\n  SCOPED_TSAN_INTERCEPTOR(connect, fd, addr, addrlen);\n  FdSocketConnecting(thr, pc, fd);\n  int res = REAL(connect)(fd, addr, addrlen);\n  if (res == 0 && fd >= 0)\n    FdSocketConnect(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, bind, int fd, void *addr, unsigned addrlen) {\n  SCOPED_TSAN_INTERCEPTOR(bind, fd, addr, addrlen);\n  int res = REAL(bind)(fd, addr, addrlen);\n  if (fd > 0 && res == 0)\n    FdAccess(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, listen, int fd, int backlog) {\n  SCOPED_TSAN_INTERCEPTOR(listen, fd, backlog);\n  int res = REAL(listen)(fd, backlog);\n  if (fd > 0 && res == 0)\n    FdAccess(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, close, int fd) {\n  SCOPED_TSAN_INTERCEPTOR(close, fd);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  return REAL(close)(fd);\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, __close, int fd) {\n  SCOPED_TSAN_INTERCEPTOR(__close, fd);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  return REAL(__close)(fd);\n}\n#define TSAN_MAYBE_INTERCEPT___CLOSE TSAN_INTERCEPT(__close)\n#else\n#define TSAN_MAYBE_INTERCEPT___CLOSE\n#endif\n\n// glibc guts\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n  SCOPED_TSAN_INTERCEPTOR(__res_iclose, state, free_addr);\n  int fds[64];\n  int cnt = ExtractResolvFDs(state, fds, ARRAY_SIZE(fds));\n  for (int i = 0; i < cnt; i++) {\n    if (fds[i] > 0)\n      FdClose(thr, pc, fds[i]);\n  }\n  REAL(__res_iclose)(state, free_addr);\n}\n#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE TSAN_INTERCEPT(__res_iclose)\n#else\n#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE\n#endif\n\nTSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n  SCOPED_TSAN_INTERCEPTOR(pipe, pipefd);\n  int res = REAL(pipe)(pipefd);\n  if (res == 0 && pipefd[0] >= 0 && pipefd[1] >= 0)\n    FdPipeCreate(thr, pc, pipefd[0], pipefd[1]);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(pipe2, pipefd, flags);\n  int res = REAL(pipe2)(pipefd, flags);\n  if (res == 0 && pipefd[0] >= 0 && pipefd[1] >= 0)\n    FdPipeCreate(thr, pc, pipefd[0], pipefd[1]);\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, unlink, char *path) {\n  SCOPED_TSAN_INTERCEPTOR(unlink, path);\n  Release(thr, pc, File2addr(path));\n  int res = REAL(unlink)(path);\n  return res;\n}\n\nTSAN_INTERCEPTOR(void*, tmpfile, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(tmpfile, fake);\n  void *res = REAL(tmpfile)(fake);\n  if (res) {\n    int fd = fileno_unlocked(res);\n    if (fd >= 0)\n      FdFileCreate(thr, pc, fd);\n  }\n  return res;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, tmpfile64, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(tmpfile64, fake);\n  void *res = REAL(tmpfile64)(fake);\n  if (res) {\n    int fd = fileno_unlocked(res);\n    if (fd >= 0)\n      FdFileCreate(thr, pc, fd);\n  }\n  return res;\n}\n#define TSAN_MAYBE_INTERCEPT_TMPFILE64 TSAN_INTERCEPT(tmpfile64)\n#else\n#define TSAN_MAYBE_INTERCEPT_TMPFILE64\n#endif\n\nTSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  {\n    SCOPED_TSAN_INTERCEPTOR(fread, ptr, size, nmemb, f);\n    MemoryAccessRange(thr, pc, (uptr)ptr, size * nmemb, true);\n  }\n  return REAL(fread)(ptr, size, nmemb, f);\n}\n\nTSAN_INTERCEPTOR(uptr, fwrite, const void *p, uptr size, uptr nmemb, void *f) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  {\n    SCOPED_TSAN_INTERCEPTOR(fwrite, p, size, nmemb, f);\n    MemoryAccessRange(thr, pc, (uptr)p, size * nmemb, false);\n  }\n  return REAL(fwrite)(p, size, nmemb, f);\n}\n\nstatic void FlushStreams() {\n  // Flushing all the streams here may freeze the process if a child thread is\n  // performing file stream operations at the same time.\n  REAL(fflush)(stdout);\n  REAL(fflush)(stderr);\n}\n\nTSAN_INTERCEPTOR(void, abort, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(abort, fake);\n  FlushStreams();\n  REAL(abort)(fake);\n}\n\nTSAN_INTERCEPTOR(int, puts, const char *s) {\n  SCOPED_TSAN_INTERCEPTOR(puts, s);\n  MemoryAccessRange(thr, pc, (uptr)s, internal_strlen(s), false);\n  return REAL(puts)(s);\n}\n\nTSAN_INTERCEPTOR(int, rmdir, char *path) {\n  SCOPED_TSAN_INTERCEPTOR(rmdir, path);\n  Release(thr, pc, Dir2addr(path));\n  int res = REAL(rmdir)(path);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, closedir, void *dirp) {\n  SCOPED_TSAN_INTERCEPTOR(closedir, dirp);\n  if (dirp) {\n    int fd = dirfd(dirp);\n    FdClose(thr, pc, fd);\n  }\n  return REAL(closedir)(dirp);\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, epoll_create, int size) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_create, size);\n  int fd = REAL(epoll_create)(size);\n  if (fd >= 0)\n    FdPollCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, epoll_create1, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_create1, flags);\n  int fd = REAL(epoll_create1)(flags);\n  if (fd >= 0)\n    FdPollCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  if (epfd >= 0 && fd >= 0)\n    FdAccess(thr, pc, fd);\n  if (op == EPOLL_CTL_ADD && epfd >= 0)\n    FdRelease(thr, pc, epfd);\n  int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  int res = BLOCK_REAL(epoll_wait)(epfd, ev, cnt, timeout);\n  if (res > 0 && epfd >= 0)\n    FdAcquire(thr, pc, epfd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, epoll_pwait, int epfd, void *ev, int cnt, int timeout,\n                 void *sigmask) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_pwait, epfd, ev, cnt, timeout, sigmask);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  int res = BLOCK_REAL(epoll_pwait)(epfd, ev, cnt, timeout, sigmask);\n  if (res > 0 && epfd >= 0)\n    FdAcquire(thr, pc, epfd);\n  return res;\n}\n\n#define TSAN_MAYBE_INTERCEPT_EPOLL \\\n    TSAN_INTERCEPT(epoll_create); \\\n    TSAN_INTERCEPT(epoll_create1); \\\n    TSAN_INTERCEPT(epoll_ctl); \\\n    TSAN_INTERCEPT(epoll_wait); \\\n    TSAN_INTERCEPT(epoll_pwait)\n#else\n#define TSAN_MAYBE_INTERCEPT_EPOLL\n#endif\n\n// The following functions are intercepted merely to process pending signals.\n// If program blocks signal X, we must deliver the signal before the function\n// returns. Similarly, if program unblocks a signal (or returns from sigsuspend)\n// it's better to deliver the signal straight away.\nTSAN_INTERCEPTOR(int, sigsuspend, const __sanitizer_sigset_t *mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigsuspend, mask);\n  return REAL(sigsuspend)(mask);\n}\n\nTSAN_INTERCEPTOR(int, sigblock, int mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigblock, mask);\n  return REAL(sigblock)(mask);\n}\n\nTSAN_INTERCEPTOR(int, sigsetmask, int mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigsetmask, mask);\n  return REAL(sigsetmask)(mask);\n}\n\nTSAN_INTERCEPTOR(int, pthread_sigmask, int how, const __sanitizer_sigset_t *set,\n    __sanitizer_sigset_t *oldset) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_sigmask, how, set, oldset);\n  return REAL(pthread_sigmask)(how, set, oldset);\n}\n\nnamespace __tsan {\n\nstatic void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,\n    bool sigact, int sig, my_siginfo_t *info, void *uctx) {\n  if (acquire)\n    Acquire(thr, 0, (uptr)&sigactions[sig]);\n  // Signals are generally asynchronous, so if we receive a signals when\n  // ignores are enabled we should disable ignores. This is critical for sync\n  // and interceptors, because otherwise we can miss syncronization and report\n  // false races.\n  int ignore_reads_and_writes = thr->ignore_reads_and_writes;\n  int ignore_interceptors = thr->ignore_interceptors;\n  int ignore_sync = thr->ignore_sync;\n  if (!ctx->after_multithreaded_fork) {\n    thr->ignore_reads_and_writes = 0;\n    thr->fast_state.ClearIgnoreBit();\n    thr->ignore_interceptors = 0;\n    thr->ignore_sync = 0;\n  }\n  // Ensure that the handler does not spoil errno.\n  const int saved_errno = errno;\n  errno = 99;\n  // This code races with sigaction. Be careful to not read sa_sigaction twice.\n  // Also need to remember pc for reporting before the call,\n  // because the handler can reset it.\n  volatile uptr pc = sigact ?\n     (uptr)sigactions[sig].sa_sigaction :\n     (uptr)sigactions[sig].sa_handler;\n  if (pc != (uptr)SIG_DFL && pc != (uptr)SIG_IGN) {\n    if (sigact)\n      ((sigactionhandler_t)pc)(sig, info, uctx);\n    else\n      ((sighandler_t)pc)(sig);\n  }\n  if (!ctx->after_multithreaded_fork) {\n    thr->ignore_reads_and_writes = ignore_reads_and_writes;\n    if (ignore_reads_and_writes)\n      thr->fast_state.SetIgnoreBit();\n    thr->ignore_interceptors = ignore_interceptors;\n    thr->ignore_sync = ignore_sync;\n  }\n  // We do not detect errno spoiling for SIGTERM,\n  // because some SIGTERM handlers do spoil errno but reraise SIGTERM,\n  // tsan reports false positive in such case.\n  // It's difficult to properly detect this situation (reraise),\n  // because in async signal processing case (when handler is called directly\n  // from rtl_generic_sighandler) we have not yet received the reraised\n  // signal; and it looks too fragile to intercept all ways to reraise a signal.\n  if (flags()->report_bugs && !sync && sig != SIGTERM && errno != 99) {\n    VarSizeStackTrace stack;\n    // StackTrace::GetNestInstructionPc(pc) is used because return address is\n    // expected, OutputReport() will undo this.\n    ObtainCurrentStack(thr, StackTrace::GetNextInstructionPc(pc), &stack);\n    ThreadRegistryLock l(ctx->thread_registry);\n    ScopedReport rep(ReportTypeErrnoInSignal);\n    if (!IsFiredSuppression(ctx, ReportTypeErrnoInSignal, stack)) {\n      rep.AddStack(stack, true);\n      OutputReport(thr, rep);\n    }\n  }\n  errno = saved_errno;\n}\n\nvoid ProcessPendingSignals(ThreadState *thr) {\n  ThreadSignalContext *sctx = SigCtx(thr);\n  if (sctx == 0 ||\n      atomic_load(&sctx->have_pending_signals, memory_order_relaxed) == 0)\n    return;\n  atomic_store(&sctx->have_pending_signals, 0, memory_order_relaxed);\n  atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n  internal_sigfillset(&sctx->emptyset);\n  int res = REAL(pthread_sigmask)(SIG_SETMASK, &sctx->emptyset, &sctx->oldset);\n  CHECK_EQ(res, 0);\n  for (int sig = 0; sig < kSigCount; sig++) {\n    SignalDesc *signal = &sctx->pending_signals[sig];\n    if (signal->armed) {\n      signal->armed = false;\n      CallUserSignalHandler(thr, false, true, signal->sigaction, sig,\n          &signal->siginfo, &signal->ctx);\n    }\n  }\n  res = REAL(pthread_sigmask)(SIG_SETMASK, &sctx->oldset, 0);\n  CHECK_EQ(res, 0);\n  atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n}\n\n}  // namespace __tsan\n\nstatic bool is_sync_signal(ThreadSignalContext *sctx, int sig) {\n  return sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n      sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE || sig == SIGSYS ||\n      // If we are sending signal to ourselves, we must process it now.\n      (sctx && sig == sctx->int_signal_send);\n}\n\nvoid ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n    my_siginfo_t *info, void *ctx) {\n  ThreadState *thr = cur_thread();\n  ThreadSignalContext *sctx = SigCtx(thr);\n  if (sig < 0 || sig >= kSigCount) {\n    VPrintf(1, \"ThreadSanitizer: ignoring signal %d\\n\", sig);\n    return;\n  }\n  // Don't mess with synchronous signals.\n  const bool sync = is_sync_signal(sctx, sig);\n  if (sync ||\n      // If we are in blocking function, we can safely process it now\n      // (but check if we are in a recursive interceptor,\n      // i.e. pthread_join()->munmap()).\n      (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed))) {\n    atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n    if (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed)) {\n      atomic_store(&sctx->in_blocking_func, 0, memory_order_relaxed);\n      CallUserSignalHandler(thr, sync, true, sigact, sig, info, ctx);\n      atomic_store(&sctx->in_blocking_func, 1, memory_order_relaxed);\n    } else {\n      // Be very conservative with when we do acquire in this case.\n      // It's unsafe to do acquire in async handlers, because ThreadState\n      // can be in inconsistent state.\n      // SIGSYS looks relatively safe -- it's synchronous and can actually\n      // need some global state.\n      bool acq = (sig == SIGSYS);\n      CallUserSignalHandler(thr, sync, acq, sigact, sig, info, ctx);\n    }\n    atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n    return;\n  }\n\n  if (sctx == 0)\n    return;\n  SignalDesc *signal = &sctx->pending_signals[sig];\n  if (signal->armed == false) {\n    signal->armed = true;\n    signal->sigaction = sigact;\n    if (info)\n      internal_memcpy(&signal->siginfo, info, sizeof(*info));\n    if (ctx)\n      internal_memcpy(&signal->ctx, ctx, sizeof(signal->ctx));\n    atomic_store(&sctx->have_pending_signals, 1, memory_order_relaxed);\n  }\n}\n\nstatic void rtl_sighandler(int sig) {\n  rtl_generic_sighandler(false, sig, 0, 0);\n}\n\nstatic void rtl_sigaction(int sig, my_siginfo_t *info, void *ctx) {\n  rtl_generic_sighandler(true, sig, info, ctx);\n}\n\nTSAN_INTERCEPTOR(int, sigaction, int sig, sigaction_t *act, sigaction_t *old) {\n  // Note: if we call REAL(sigaction) directly for any reason without proxying\n  // the signal handler through rtl_sigaction, very bad things will happen.\n  // The handler will run synchronously and corrupt tsan per-thread state.\n  SCOPED_INTERCEPTOR_RAW(sigaction, sig, act, old);\n  if (old)\n    internal_memcpy(old, &sigactions[sig], sizeof(*old));\n  if (act == 0)\n    return 0;\n  // Copy act into sigactions[sig].\n  // Can't use struct copy, because compiler can emit call to memcpy.\n  // Can't use internal_memcpy, because it copies byte-by-byte,\n  // and signal handler reads the sa_handler concurrently. It it can read\n  // some bytes from old value and some bytes from new value.\n  // Use volatile to prevent insertion of memcpy.\n  sigactions[sig].sa_handler = *(volatile sighandler_t*)&act->sa_handler;\n  sigactions[sig].sa_flags = *(volatile int*)&act->sa_flags;\n  internal_memcpy(&sigactions[sig].sa_mask, &act->sa_mask,\n      sizeof(sigactions[sig].sa_mask));\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC\n  sigactions[sig].sa_restorer = act->sa_restorer;\n#endif\n  sigaction_t newact;\n  internal_memcpy(&newact, act, sizeof(newact));\n  internal_sigfillset(&newact.sa_mask);\n  if (act->sa_handler != SIG_IGN && act->sa_handler != SIG_DFL) {\n    if (newact.sa_flags & SA_SIGINFO)\n      newact.sa_sigaction = rtl_sigaction;\n    else\n      newact.sa_handler = rtl_sighandler;\n  }\n  ReleaseStore(thr, pc, (uptr)&sigactions[sig]);\n  int res = REAL(sigaction)(sig, &newact, 0);\n  return res;\n}\n\nTSAN_INTERCEPTOR(sighandler_t, signal, int sig, sighandler_t h) {\n  sigaction_t act;\n  act.sa_handler = h;\n  internal_memset(&act.sa_mask, -1, sizeof(act.sa_mask));\n  act.sa_flags = 0;\n  sigaction_t old;\n  int res = sigaction(sig, &act, &old);\n  if (res)\n    return SIG_ERR;\n  return old.sa_handler;\n}\n\nTSAN_INTERCEPTOR(int, raise, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(raise, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  sctx->int_signal_send = sig;\n  int res = REAL(raise)(sig);\n  CHECK_EQ(sctx->int_signal_send, sig);\n  sctx->int_signal_send = prev;\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, kill, int pid, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(kill, pid, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  if (pid == (int)internal_getpid()) {\n    sctx->int_signal_send = sig;\n  }\n  int res = REAL(kill)(pid, sig);\n  if (pid == (int)internal_getpid()) {\n    CHECK_EQ(sctx->int_signal_send, sig);\n    sctx->int_signal_send = prev;\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_kill, void *tid, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_kill, tid, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  if (tid == pthread_self()) {\n    sctx->int_signal_send = sig;\n  }\n  int res = REAL(pthread_kill)(tid, sig);\n  if (tid == pthread_self()) {\n    CHECK_EQ(sctx->int_signal_send, sig);\n    sctx->int_signal_send = prev;\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, gettimeofday, void *tv, void *tz) {\n  SCOPED_TSAN_INTERCEPTOR(gettimeofday, tv, tz);\n  // It's intercepted merely to process pending signals.\n  return REAL(gettimeofday)(tv, tz);\n}\n\nTSAN_INTERCEPTOR(int, getaddrinfo, void *node, void *service,\n    void *hints, void *rv) {\n  SCOPED_TSAN_INTERCEPTOR(getaddrinfo, node, service, hints, rv);\n  // We miss atomic synchronization in getaddrinfo,\n  // and can report false race between malloc and free\n  // inside of getaddrinfo. So ignore memory accesses.\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(getaddrinfo)(node, service, hints, rv);\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, fork, int fake) {\n  if (cur_thread()->in_symbolizer)\n    return REAL(fork)(fake);\n  SCOPED_INTERCEPTOR_RAW(fork, fake);\n  ForkBefore(thr, pc);\n  int pid;\n  {\n    // On OS X, REAL(fork) can call intercepted functions (OSSpinLockLock), and\n    // we'll assert in CheckNoLocks() unless we ignore interceptors.\n    ScopedIgnoreInterceptors ignore;\n    pid = REAL(fork)(fake);\n  }\n  if (pid == 0) {\n    // child\n    ForkChildAfter(thr, pc);\n    FdOnFork(thr, pc);\n  } else if (pid > 0) {\n    // parent\n    ForkParentAfter(thr, pc);\n  } else {\n    // error\n    ForkParentAfter(thr, pc);\n  }\n  return pid;\n}\n\nTSAN_INTERCEPTOR(int, vfork, int fake) {\n  // Some programs (e.g. openjdk) call close for all file descriptors\n  // in the child process. Under tsan it leads to false positives, because\n  // address space is shared, so the parent process also thinks that\n  // the descriptors are closed (while they are actually not).\n  // This leads to false positives due to missed synchronization.\n  // Strictly saying this is undefined behavior, because vfork child is not\n  // allowed to call any functions other than exec/exit. But this is what\n  // openjdk does, so we want to handle it.\n  // We could disable interceptors in the child process. But it's not possible\n  // to simply intercept and wrap vfork, because vfork child is not allowed\n  // to return from the function that calls vfork, and that's exactly what\n  // we would do. So this would require some assembly trickery as well.\n  // Instead we simply turn vfork into fork.\n  return WRAP(fork)(fake);\n}\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\ntypedef int (*dl_iterate_phdr_cb_t)(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                                    void *data);\nstruct dl_iterate_phdr_data {\n  ThreadState *thr;\n  uptr pc;\n  dl_iterate_phdr_cb_t cb;\n  void *data;\n};\n\nstatic bool IsAppNotRodata(uptr addr) {\n  return IsAppMem(addr) && *(u64*)MemToShadow(addr) != kShadowRodata;\n}\n\nstatic int dl_iterate_phdr_cb(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                              void *data) {\n  dl_iterate_phdr_data *cbdata = (dl_iterate_phdr_data *)data;\n  // dlopen/dlclose allocate/free dynamic-linker-internal memory, which is later\n  // accessible in dl_iterate_phdr callback. But we don't see synchronization\n  // inside of dynamic linker, so we \"unpoison\" it here in order to not\n  // produce false reports. Ignoring malloc/free in dlopen/dlclose is not enough\n  // because some libc functions call __libc_dlopen.\n  if (info && IsAppNotRodata((uptr)info->dlpi_name))\n    MemoryResetRange(cbdata->thr, cbdata->pc, (uptr)info->dlpi_name,\n                     internal_strlen(info->dlpi_name));\n  int res = cbdata->cb(info, size, cbdata->data);\n  // Perform the check one more time in case info->dlpi_name was overwritten\n  // by user callback.\n  if (info && IsAppNotRodata((uptr)info->dlpi_name))\n    MemoryResetRange(cbdata->thr, cbdata->pc, (uptr)info->dlpi_name,\n                     internal_strlen(info->dlpi_name));\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, dl_iterate_phdr, dl_iterate_phdr_cb_t cb, void *data) {\n  SCOPED_TSAN_INTERCEPTOR(dl_iterate_phdr, cb, data);\n  dl_iterate_phdr_data cbdata;\n  cbdata.thr = thr;\n  cbdata.pc = pc;\n  cbdata.cb = cb;\n  cbdata.data = data;\n  int res = REAL(dl_iterate_phdr)(dl_iterate_phdr_cb, &cbdata);\n  return res;\n}\n#endif\n\nstatic int OnExit(ThreadState *thr) {\n  int status = Finalize(thr);\n  FlushStreams();\n  return status;\n}\n\nstruct TsanInterceptorContext {\n  ThreadState *thr;\n  const uptr caller_pc;\n  const uptr pc;\n};\n\n#if !SANITIZER_MAC\nstatic void HandleRecvmsg(ThreadState *thr, uptr pc,\n    __sanitizer_msghdr *msg) {\n  int fds[64];\n  int cnt = ExtractRecvmsgFDs(msg, fds, ARRAY_SIZE(fds));\n  for (int i = 0; i < cnt; i++)\n    FdEventCreate(thr, pc, fds[i]);\n}\n#endif\n\n#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n// Causes interceptor recursion (getaddrinfo() and fopen())\n#undef SANITIZER_INTERCEPT_GETADDRINFO\n// There interceptors do not seem to be strictly necessary for tsan.\n// But we see cases where the interceptors consume 70% of execution time.\n// Memory blocks passed to fgetgrent_r are \"written to\" by tsan several times.\n// First, there is some recursion (getgrnam_r calls fgetgrent_r), and each\n// function \"writes to\" the buffer. Then, the same memory is \"written to\"\n// twice, first as buf and then as pwbufp (both of them refer to the same\n// addresses).\n#undef SANITIZER_INTERCEPT_GETPWENT\n#undef SANITIZER_INTERCEPT_GETPWENT_R\n#undef SANITIZER_INTERCEPT_FGETPWENT\n#undef SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n#undef SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n// We define our own.\n#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n#define NEED_TLS_GET_ADDR\n#endif\n#undef SANITIZER_INTERCEPT_TLS_GET_ADDR\n\n#define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n#define COMMON_INTERCEPT_FUNCTION_VER(name, ver)                          \\\n  INTERCEPT_FUNCTION_VER(name, ver)\n\n#define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size)                    \\\n  MemoryAccessRange(((TsanInterceptorContext *)ctx)->thr,                 \\\n                    ((TsanInterceptorContext *)ctx)->pc, (uptr)ptr, size, \\\n                    true)\n\n#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size)                       \\\n  MemoryAccessRange(((TsanInterceptorContext *) ctx)->thr,                  \\\n                    ((TsanInterceptorContext *) ctx)->pc, (uptr) ptr, size, \\\n                    false)\n\n#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)      \\\n  SCOPED_TSAN_INTERCEPTOR(func, __VA_ARGS__);         \\\n  TsanInterceptorContext _ctx = {thr, caller_pc, pc}; \\\n  ctx = (void *)&_ctx;                                \\\n  (void) ctx;\n\n#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, func, ...) \\\n  SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__);              \\\n  TsanInterceptorContext _ctx = {thr, caller_pc, pc};     \\\n  ctx = (void *)&_ctx;                                    \\\n  (void) ctx;\n\n#define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) \\\n  Acquire(thr, pc, File2addr(path));                  \\\n  if (file) {                                         \\\n    int fd = fileno_unlocked(file);                   \\\n    if (fd >= 0) FdFileCreate(thr, pc, fd);           \\\n  }\n\n#define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) \\\n  if (file) {                                    \\\n    int fd = fileno_unlocked(file);              \\\n    if (fd >= 0) FdClose(thr, pc, fd);           \\\n  }\n\n#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) \\\n  libignore()->OnLibraryLoaded(filename)\n\n#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() \\\n  libignore()->OnLibraryUnloaded()\n\n#define COMMON_INTERCEPTOR_ACQUIRE(ctx, u) \\\n  Acquire(((TsanInterceptorContext *) ctx)->thr, pc, u)\n\n#define COMMON_INTERCEPTOR_RELEASE(ctx, u) \\\n  Release(((TsanInterceptorContext *) ctx)->thr, pc, u)\n\n#define COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path) \\\n  Acquire(((TsanInterceptorContext *) ctx)->thr, pc, Dir2addr(path))\n\n#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n  FdAcquire(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) \\\n  FdRelease(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) \\\n  FdAccess(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, newfd) \\\n  FdSocketAccept(((TsanInterceptorContext *) ctx)->thr, pc, fd, newfd)\n\n#define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) \\\n  ThreadSetName(((TsanInterceptorContext *) ctx)->thr, name)\n\n#define COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name) \\\n  __tsan::ctx->thread_registry->SetThreadNameByUserId(thread, name)\n\n#define COMMON_INTERCEPTOR_BLOCK_REAL(name) BLOCK_REAL(name)\n\n#define COMMON_INTERCEPTOR_ON_EXIT(ctx) \\\n  OnExit(((TsanInterceptorContext *) ctx)->thr)\n\n#define COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m) \\\n  MutexLock(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) \\\n  MutexUnlock(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) \\\n  MutexRepair(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m) \\\n  MutexInvalidAccess(((TsanInterceptorContext *)ctx)->thr, \\\n                     ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#if !SANITIZER_MAC\n#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) \\\n  HandleRecvmsg(((TsanInterceptorContext *)ctx)->thr, \\\n      ((TsanInterceptorContext *)ctx)->pc, msg)\n#endif\n\n#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end)                           \\\n  if (TsanThread *t = GetCurrentThread()) {                                    \\\n    *begin = t->tls_begin();                                                   \\\n    *end = t->tls_end();                                                       \\\n  } else {                                                                     \\\n    *begin = *end = 0;                                                         \\\n  }\n\n#define COMMON_INTERCEPTOR_USER_CALLBACK_START() \\\n  SCOPED_TSAN_INTERCEPTOR_USER_CALLBACK_START()\n\n#define COMMON_INTERCEPTOR_USER_CALLBACK_END() \\\n  SCOPED_TSAN_INTERCEPTOR_USER_CALLBACK_END()\n\n#include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n\n#define TSAN_SYSCALL() \\\n  ThreadState *thr = cur_thread(); \\\n  if (thr->ignore_interceptors) \\\n    return; \\\n  ScopedSyscall scoped_syscall(thr) \\\n/**/\n\nstruct ScopedSyscall {\n  ThreadState *thr;\n\n  explicit ScopedSyscall(ThreadState *thr)\n      : thr(thr) {\n    Initialize(thr);\n  }\n\n  ~ScopedSyscall() {\n    ProcessPendingSignals(thr);\n  }\n};\n\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC\nstatic void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n  TSAN_SYSCALL();\n  MemoryAccessRange(thr, pc, p, s, write);\n}\n\nstatic void syscall_acquire(uptr pc, uptr addr) {\n  TSAN_SYSCALL();\n  Acquire(thr, pc, addr);\n  DPrintf(\"syscall_acquire(%p)\\n\", addr);\n}\n\nstatic void syscall_release(uptr pc, uptr addr) {\n  TSAN_SYSCALL();\n  DPrintf(\"syscall_release(%p)\\n\", addr);\n  Release(thr, pc, addr);\n}\n\nstatic void syscall_fd_close(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  FdClose(thr, pc, fd);\n}\n\nstatic USED void syscall_fd_acquire(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  FdAcquire(thr, pc, fd);\n  DPrintf(\"syscall_fd_acquire(%p)\\n\", fd);\n}\n\nstatic USED void syscall_fd_release(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  DPrintf(\"syscall_fd_release(%p)\\n\", fd);\n  FdRelease(thr, pc, fd);\n}\n\nstatic void syscall_pre_fork(uptr pc) {\n  TSAN_SYSCALL();\n  ForkBefore(thr, pc);\n}\n\nstatic void syscall_post_fork(uptr pc, int pid) {\n  TSAN_SYSCALL();\n  if (pid == 0) {\n    // child\n    ForkChildAfter(thr, pc);\n    FdOnFork(thr, pc);\n  } else if (pid > 0) {\n    // parent\n    ForkParentAfter(thr, pc);\n  } else {\n    // error\n    ForkParentAfter(thr, pc);\n  }\n}\n#endif\n\n#define COMMON_SYSCALL_PRE_READ_RANGE(p, s) \\\n  syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), false)\n\n#define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) \\\n  syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), true)\n\n#define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n  do {                                       \\\n    (void)(p);                               \\\n    (void)(s);                               \\\n  } while (false)\n\n#define COMMON_SYSCALL_POST_WRITE_RANGE(p, s) \\\n  do {                                        \\\n    (void)(p);                                \\\n    (void)(s);                                \\\n  } while (false)\n\n#define COMMON_SYSCALL_ACQUIRE(addr) \\\n    syscall_acquire(GET_CALLER_PC(), (uptr)(addr))\n\n#define COMMON_SYSCALL_RELEASE(addr) \\\n    syscall_release(GET_CALLER_PC(), (uptr)(addr))\n\n#define COMMON_SYSCALL_FD_CLOSE(fd) syscall_fd_close(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_FD_ACQUIRE(fd) syscall_fd_acquire(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_FD_RELEASE(fd) syscall_fd_release(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_PRE_FORK() \\\n  syscall_pre_fork(GET_CALLER_PC())\n\n#define COMMON_SYSCALL_POST_FORK(res) \\\n  syscall_post_fork(GET_CALLER_PC(), res)\n\n#include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n\n#ifdef NEED_TLS_GET_ADDR\n// Define own interceptor instead of sanitizer_common's for three reasons:\n// 1. It must not process pending signals.\n//    Signal handlers may contain MOVDQA instruction (see below).\n// 2. It must be as simple as possible to not contain MOVDQA.\n// 3. Sanitizer_common version uses COMMON_INTERCEPTOR_INITIALIZE_RANGE which\n//    is empty for tsan (meant only for msan).\n// Note: __tls_get_addr can be called with mis-aligned stack due to:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066\n// So the interceptor must work with mis-aligned stack, in particular, does not\n// execute MOVDQA with stack addresses.\nTSAN_INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n  void *res = REAL(__tls_get_addr)(arg);\n  ThreadState *thr = cur_thread();\n  if (!thr)\n    return res;\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, thr->tls_addr, thr->tls_size);\n  if (!dtv)\n    return res;\n  // New DTLS block has been allocated.\n  MemoryResetRange(thr, 0, dtv->beg, dtv->size);\n  return res;\n}\n#endif\n\nnamespace __tsan {\n\nstatic void finalize(void *arg) {\n  ThreadState *thr = cur_thread();\n  int status = Finalize(thr);\n  // Make sure the output is not lost.\n  FlushStreams();\n  if (status)\n    Die();\n}\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\nstatic void unreachable() {\n  Report(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n  Die();\n}\n#endif\n\nvoid InitializeInterceptors() {\n#if !SANITIZER_MAC\n  // We need to setup it early, because functions like dlsym() can call it.\n  REAL(memset) = internal_memset;\n  REAL(memcpy) = internal_memcpy;\n#endif\n\n  // Instruct libc malloc to consume less memory.\n#if SANITIZER_LINUX\n  mallopt(1, 0);  // M_MXFAST\n  mallopt(-3, 32*1024);  // M_MMAP_THRESHOLD\n#endif\n\n  InitializeCommonInterceptors();\n\n#if !SANITIZER_MAC\n  // We can not use TSAN_INTERCEPT to get setjmp addr,\n  // because it does &setjmp and setjmp is not present in some versions of libc.\n  using __interception::GetRealFunctionAddress;\n  GetRealFunctionAddress(\"setjmp\", (uptr*)&REAL(setjmp), 0, 0);\n  GetRealFunctionAddress(\"_setjmp\", (uptr*)&REAL(_setjmp), 0, 0);\n  GetRealFunctionAddress(\"sigsetjmp\", (uptr*)&REAL(sigsetjmp), 0, 0);\n  GetRealFunctionAddress(\"__sigsetjmp\", (uptr*)&REAL(__sigsetjmp), 0, 0);\n#endif\n\n  TSAN_INTERCEPT(longjmp);\n  TSAN_INTERCEPT(siglongjmp);\n\n  TSAN_INTERCEPT(malloc);\n  TSAN_INTERCEPT(__libc_memalign);\n  TSAN_INTERCEPT(calloc);\n  TSAN_INTERCEPT(realloc);\n  TSAN_INTERCEPT(free);\n  TSAN_INTERCEPT(cfree);\n  TSAN_INTERCEPT(mmap);\n  TSAN_MAYBE_INTERCEPT_MMAP64;\n  TSAN_INTERCEPT(munmap);\n  TSAN_MAYBE_INTERCEPT_MEMALIGN;\n  TSAN_INTERCEPT(valloc);\n  TSAN_MAYBE_INTERCEPT_PVALLOC;\n  TSAN_INTERCEPT(posix_memalign);\n\n  TSAN_INTERCEPT(strcpy);  // NOLINT\n  TSAN_INTERCEPT(strncpy);\n  TSAN_INTERCEPT(strdup);\n\n  TSAN_INTERCEPT(pthread_create);\n  TSAN_INTERCEPT(pthread_join);\n  TSAN_INTERCEPT(pthread_detach);\n\n  TSAN_INTERCEPT_VER(pthread_cond_init, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_signal, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_broadcast, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_wait, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_timedwait, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_destroy, PTHREAD_ABI_BASE);\n\n  TSAN_INTERCEPT(pthread_mutex_init);\n  TSAN_INTERCEPT(pthread_mutex_destroy);\n  TSAN_INTERCEPT(pthread_mutex_trylock);\n  TSAN_INTERCEPT(pthread_mutex_timedlock);\n\n  TSAN_INTERCEPT(pthread_spin_init);\n  TSAN_INTERCEPT(pthread_spin_destroy);\n  TSAN_INTERCEPT(pthread_spin_lock);\n  TSAN_INTERCEPT(pthread_spin_trylock);\n  TSAN_INTERCEPT(pthread_spin_unlock);\n\n  TSAN_INTERCEPT(pthread_rwlock_init);\n  TSAN_INTERCEPT(pthread_rwlock_destroy);\n  TSAN_INTERCEPT(pthread_rwlock_rdlock);\n  TSAN_INTERCEPT(pthread_rwlock_tryrdlock);\n  TSAN_INTERCEPT(pthread_rwlock_timedrdlock);\n  TSAN_INTERCEPT(pthread_rwlock_wrlock);\n  TSAN_INTERCEPT(pthread_rwlock_trywrlock);\n  TSAN_INTERCEPT(pthread_rwlock_timedwrlock);\n  TSAN_INTERCEPT(pthread_rwlock_unlock);\n\n  TSAN_INTERCEPT(pthread_barrier_init);\n  TSAN_INTERCEPT(pthread_barrier_destroy);\n  TSAN_INTERCEPT(pthread_barrier_wait);\n\n  TSAN_INTERCEPT(pthread_once);\n\n  TSAN_INTERCEPT(fstat);\n  TSAN_MAYBE_INTERCEPT___FXSTAT;\n  TSAN_MAYBE_INTERCEPT_FSTAT64;\n  TSAN_MAYBE_INTERCEPT___FXSTAT64;\n  TSAN_INTERCEPT(open);\n  TSAN_MAYBE_INTERCEPT_OPEN64;\n  TSAN_INTERCEPT(creat);\n  TSAN_MAYBE_INTERCEPT_CREAT64;\n  TSAN_INTERCEPT(dup);\n  TSAN_INTERCEPT(dup2);\n  TSAN_INTERCEPT(dup3);\n  TSAN_MAYBE_INTERCEPT_EVENTFD;\n  TSAN_MAYBE_INTERCEPT_SIGNALFD;\n  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT;\n  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1;\n  TSAN_INTERCEPT(socket);\n  TSAN_INTERCEPT(socketpair);\n  TSAN_INTERCEPT(connect);\n  TSAN_INTERCEPT(bind);\n  TSAN_INTERCEPT(listen);\n  TSAN_MAYBE_INTERCEPT_EPOLL;\n  TSAN_INTERCEPT(close);\n  TSAN_MAYBE_INTERCEPT___CLOSE;\n  TSAN_MAYBE_INTERCEPT___RES_ICLOSE;\n  TSAN_INTERCEPT(pipe);\n  TSAN_INTERCEPT(pipe2);\n\n  TSAN_INTERCEPT(unlink);\n  TSAN_INTERCEPT(tmpfile);\n  TSAN_MAYBE_INTERCEPT_TMPFILE64;\n  TSAN_INTERCEPT(fread);\n  TSAN_INTERCEPT(fwrite);\n  TSAN_INTERCEPT(abort);\n  TSAN_INTERCEPT(puts);\n  TSAN_INTERCEPT(rmdir);\n  TSAN_INTERCEPT(closedir);\n\n  TSAN_INTERCEPT(sigaction);\n  TSAN_INTERCEPT(signal);\n  TSAN_INTERCEPT(sigsuspend);\n  TSAN_INTERCEPT(sigblock);\n  TSAN_INTERCEPT(sigsetmask);\n  TSAN_INTERCEPT(pthread_sigmask);\n  TSAN_INTERCEPT(raise);\n  TSAN_INTERCEPT(kill);\n  TSAN_INTERCEPT(pthread_kill);\n  TSAN_INTERCEPT(sleep);\n  TSAN_INTERCEPT(usleep);\n  TSAN_INTERCEPT(nanosleep);\n  TSAN_INTERCEPT(gettimeofday);\n  TSAN_INTERCEPT(getaddrinfo);\n\n  TSAN_INTERCEPT(fork);\n  TSAN_INTERCEPT(vfork);\n#if !SANITIZER_ANDROID\n  TSAN_INTERCEPT(dl_iterate_phdr);\n#endif\n  TSAN_INTERCEPT(on_exit);\n  TSAN_INTERCEPT(__cxa_atexit);\n  TSAN_INTERCEPT(_exit);\n\n#ifdef NEED_TLS_GET_ADDR\n  TSAN_INTERCEPT(__tls_get_addr);\n#endif\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\n  // Need to setup it, because interceptors check that the function is resolved.\n  // But atexit is emitted directly into the module, so can't be resolved.\n  REAL(atexit) = (int(*)(void(*)()))unreachable;\n#endif\n\n  if (REAL(__cxa_atexit)(&finalize, 0, 0)) {\n    Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n    Die();\n  }\n\n#if !SANITIZER_MAC\n  if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n    Printf(\"ThreadSanitizer: failed to create thread key\\n\");\n    Die();\n  }\n#endif\n\n  FdInit();\n}\n\n}  // namespace __tsan\n\n// Invisible barrier for tests.\n// There were several unsuccessful iterations for this functionality:\n// 1. Initially it was implemented in user code using\n//    REAL(pthread_barrier_wait). But pthread_barrier_wait is not supported on\n//    MacOS. Futexes are linux-specific for this matter.\n// 2. Then we switched to atomics+usleep(10). But usleep produced parasitic\n//    \"as-if synchronized via sleep\" messages in reports which failed some\n//    output tests.\n// 3. Then we switched to atomics+sched_yield. But this produced tons of tsan-\n//    visible events, which lead to \"failed to restore stack trace\" failures.\n// Note that no_sanitize_thread attribute does not turn off atomic interception\n// so attaching it to the function defined in user code does not help.\n// That's why we now have what we have.\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nvoid __tsan_testonly_barrier_init(u64 *barrier, u32 count) {\n  if (count >= (1 << 8)) {\n      Printf(\"barrier_init: count is too large (%d)\\n\", count);\n      Die();\n  }\n  // 8 lsb is thread count, the remaining are count of entered threads.\n  *barrier = count;\n}\n\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nvoid __tsan_testonly_barrier_wait(u64 *barrier) {\n  unsigned old = __atomic_fetch_add(barrier, 1 << 8, __ATOMIC_RELAXED);\n  unsigned old_epoch = (old >> 8) / (old & 0xff);\n  for (;;) {\n    unsigned cur = __atomic_load_n(barrier, __ATOMIC_RELAXED);\n    unsigned cur_epoch = (cur >> 8) / (cur & 0xff);\n    if (cur_epoch != old_epoch)\n      return;\n    internal_sched_yield();\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgcc/config/darwin-crt3.c": "/* __cxa_atexit backwards-compatibility support for Darwin.\n   Copyright (C) 2006-2017 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 3, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nUnder Section 7 of GPL version 3, you are granted additional\npermissions described in the GCC Runtime Library Exception, version\n3.1, as published by the Free Software Foundation.\n\nYou should have received a copy of the GNU General Public License and\na copy of the GCC Runtime Library Exception along with this program;\nsee the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n<http://www.gnu.org/licenses/>.  */\n\n/* Don't do anything if we are compiling for a kext multilib. */\n#ifdef __PIC__\n\n#include \"tconfig.h\"\n#include \"tsystem.h\"\n\n#include <dlfcn.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* This file works around two different problems.\n\n   The first problem is that there is no __cxa_atexit on Mac OS versions\n   before 10.4.  It fixes this by providing a complete atexit and\n   __cxa_atexit emulation called from the regular atexit.\n\n   The second problem is that on all shipping versions of Mac OS,\n   __cxa_finalize and exit() don't work right: they don't run routines\n   that were registered while other atexit routines are running.  This\n   is worked around by wrapping each atexit/__cxa_atexit routine with\n   our own routine which ensures that any __cxa_atexit calls while it\n   is running are honoured.\n\n   There are still problems which this does not solve.  Before 10.4,\n   shared objects linked with previous compilers won't have their\n   atexit calls properly interleaved with code compiled with newer\n   compilers.  Also, atexit routines registered from shared objects\n   linked with previous compilers won't get the bug fix.  */\n\ntypedef int (*cxa_atexit_p)(void (*func) (void*), void* arg, const void* dso);\ntypedef void (*cxa_finalize_p)(const void *dso);\ntypedef int (*atexit_p)(void (*func)(void));\n\n/* These are from \"keymgr.h\".  */\nextern void *_keymgr_get_and_lock_processwide_ptr (unsigned key);\nextern int _keymgr_get_and_lock_processwide_ptr_2 (unsigned, void **);\nextern int _keymgr_set_and_unlock_processwide_ptr (unsigned key, void *ptr);\n\nextern void *__keymgr_global[];\ntypedef struct _Sinfo_Node {\n        unsigned int size ;             /*size of this node*/\n        unsigned short major_version ;  /*API major version.*/\n        unsigned short minor_version ;  /*API minor version.*/\n        } _Tinfo_Node ;\n\n#ifdef __ppc__\n#define CHECK_KEYMGR_ERROR(e) \\\n  (((_Tinfo_Node *)__keymgr_global[2])->major_version >= 4 ? (e) : 0)\n#else\n#define CHECK_KEYMGR_ERROR(e) (e)\n#endif\n\n/* Our globals are stored under this keymgr index.  */\n#define KEYMGR_ATEXIT_LIST\t14\n\n/* The different kinds of callback routines.  */\ntypedef void (*atexit_callback)(void);\ntypedef void (*cxa_atexit_callback)(void *);\n\n/* This structure holds a routine to call.  There may be extra fields\n   at the end of the structure that this code doesn't know about.  */\nstruct one_atexit_routine \n{\n  union {\n    atexit_callback ac;\n    cxa_atexit_callback cac;\n  } callback;\n  /* has_arg is 0/2/4 if 'ac' is live, 1/3/5 if 'cac' is live.  \n     Higher numbers indicate a later version of the structure that this\n     code doesn't understand and will ignore.  */\n  int has_arg;\n  void * arg;\n};\n\nstruct atexit_routine_list\n{\n  struct atexit_routine_list * next;\n  struct one_atexit_routine r;\n};\n\n/* The various possibilities for status of atexit().  */\nenum atexit_status {\n  atexit_status_unknown = 0,\n  atexit_status_missing = 1,\n  atexit_status_broken = 2,\n  atexit_status_working = 16\n};\n\nstruct keymgr_atexit_list\n{\n  /* Version of this list.  This code knows only about version 0.\n     If the version is higher than 0, this code may add new atexit routines\n     but should not attempt to run the list.  */\n  short version;\n  /* 1 if an atexit routine is currently being run by this code, 0\n     otherwise.  */\n  char running_routines;\n  /* Holds a value from 'enum atexit_status'.  */\n  unsigned char atexit_status;\n  /* The list of atexit and cxa_atexit routines registered.  If\n   atexit_status_missing it contains all routines registered while\n   linked with this code.  If atexit_status_broken it contains all\n   routines registered during cxa_finalize while linked with this\n   code.  */\n  struct atexit_routine_list *l;\n  /* &__cxa_atexit; set if atexit_status >= atexit_status_broken.  */\n  cxa_atexit_p cxa_atexit_f;\n  /* &__cxa_finalize; set if atexit_status >= atexit_status_broken.  */\n  cxa_finalize_p cxa_finalize_f;\n  /* &atexit; set if atexit_status >= atexit_status_working\n     or atexit_status == atexit_status_missing.  */\n  atexit_p atexit_f;\n};\n\n/* Return 0 if __cxa_atexit has the bug it has in Mac OS 10.4: it\n   fails to call routines registered while an atexit routine is\n   running.  Return 1 if it works properly, and -1 if an error occurred.  */\n\nstruct atexit_data \n{\n  int result;\n  cxa_atexit_p cxa_atexit;\n};\n\nstatic void cxa_atexit_check_2 (void *arg)\n{\n  ((struct atexit_data *)arg)->result = 1;\n}\n\nstatic void cxa_atexit_check_1 (void *arg)\n{\n  struct atexit_data * aed = arg;\n  if (aed->cxa_atexit (cxa_atexit_check_2, arg, arg) != 0)\n    aed->result = -1;\n}\n\nstatic int\ncheck_cxa_atexit (cxa_atexit_p cxa_atexit, cxa_finalize_p cxa_finalize)\n{\n  struct atexit_data aed = { 0, cxa_atexit };\n\n  /* We re-use &aed as the 'dso' parameter, since it's a unique address.  */\n  if (cxa_atexit (cxa_atexit_check_1, &aed, &aed) != 0)\n    return -1;\n  cxa_finalize (&aed);\n  if (aed.result == 0)\n    {\n      /* Call __cxa_finalize again to make sure that cxa_atexit_check_2\n\t is removed from the list before AED goes out of scope.  */\n      cxa_finalize (&aed);\n      aed.result = 0;\n    }\n  return aed.result;\n}\n\n#ifdef __ppc__\n/* This comes from Csu.  It works only before 10.4.  The prototype has\n   been altered a bit to avoid casting.  */\nextern int _dyld_func_lookup(const char *dyld_func_name,\n     void *address) __attribute__((visibility(\"hidden\")));\n\nstatic void our_atexit (void);\n\n/* We're running on 10.3.9.  Find the address of the system atexit()\n   function.  So easy to say, so hard to do.  */\nstatic atexit_p\nfind_atexit_10_3 (void)\n{\n  unsigned int (*dyld_image_count_fn)(void);\n  const char *(*dyld_get_image_name_fn)(unsigned int image_index);\n  const void *(*dyld_get_image_header_fn)(unsigned int image_index);\n  const void *(*NSLookupSymbolInImage_fn)(const void *image, \n\t\t\t\t\t  const char *symbolName,\n\t\t\t\t\t  unsigned int options);\n  void *(*NSAddressOfSymbol_fn)(const void *symbol);\n  unsigned i, count;\n  \n  /* Find some dyld functions.  */\n  _dyld_func_lookup(\"__dyld_image_count\", &dyld_image_count_fn);\n  _dyld_func_lookup(\"__dyld_get_image_name\", &dyld_get_image_name_fn);\n  _dyld_func_lookup(\"__dyld_get_image_header\", &dyld_get_image_header_fn);\n  _dyld_func_lookup(\"__dyld_NSLookupSymbolInImage\", &NSLookupSymbolInImage_fn);\n  _dyld_func_lookup(\"__dyld_NSAddressOfSymbol\", &NSAddressOfSymbol_fn);\n\n  /* If any of these don't exist, that's an error.  */\n  if (! dyld_image_count_fn || ! dyld_get_image_name_fn\n      || ! dyld_get_image_header_fn || ! NSLookupSymbolInImage_fn\n      || ! NSAddressOfSymbol_fn)\n    return NULL;\n  \n  count = dyld_image_count_fn ();\n  for (i = 0; i < count; i++)\n    {\n      const char * path = dyld_get_image_name_fn (i);\n      const void * image;\n      const void * symbol;\n      \n      if (strcmp (path, \"/usr/lib/libSystem.B.dylib\") != 0)\n\tcontinue;\n      image = dyld_get_image_header_fn (i);\n      if (! image)\n\treturn NULL;\n      /* '4' is NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR.  */\n      symbol = NSLookupSymbolInImage_fn (image, \"_atexit\", 4);\n      if (! symbol)\n\treturn NULL;\n      return NSAddressOfSymbol_fn (symbol);\n    }\n  return NULL;\n}\n#endif\n\n/* Create (if necessary), find, lock, fill in, and return our globals.  \n   Return NULL on error, in which case the globals will not be locked.  \n   The caller should call keymgr_set_and_unlock.  */\nstatic struct keymgr_atexit_list *\nget_globals (void)\n{\n  struct keymgr_atexit_list * r;\n  \n#ifdef __ppc__\n  /* 10.3.9 doesn't have _keymgr_get_and_lock_processwide_ptr_2 so the\n     PPC side can't use it.  On 10.4 this just means the error gets\n     reported a little later when\n     _keymgr_set_and_unlock_processwide_ptr finds that the key was\n     never locked.  */\n  r = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n#else\n  void * rr;\n  if (_keymgr_get_and_lock_processwide_ptr_2 (KEYMGR_ATEXIT_LIST, &rr))\n    return NULL;\n  r = rr;\n#endif\n  \n  if (r == NULL)\n    {\n      r = calloc (sizeof (struct keymgr_atexit_list), 1);\n      if (! r)\n\treturn NULL;\n    }\n\n  if (r->atexit_status == atexit_status_unknown)\n    {\n      void *handle;\n\n      handle = dlopen (\"/usr/lib/libSystem.B.dylib\", RTLD_NOLOAD);\n      if (!handle)\n\t{\n#ifdef __ppc__\n\t  r->atexit_status = atexit_status_missing;\n\t  r->atexit_f = find_atexit_10_3 ();\n\t  if (! r->atexit_f)\n\t    goto error;\n\t  if (r->atexit_f (our_atexit))\n\t    goto error;\n#else\n\t  goto error;\n#endif\n\t}\n      else\n\t{\n\t  int chk_result;\n\n\t  r->cxa_atexit_f = (cxa_atexit_p)dlsym (handle, \"__cxa_atexit\");\n\t  r->cxa_finalize_f = (cxa_finalize_p)dlsym (handle, \"__cxa_finalize\");\n\t  if (! r->cxa_atexit_f || ! r->cxa_finalize_f)\n\t    goto error;\n\n\t  chk_result = check_cxa_atexit (r->cxa_atexit_f, r->cxa_finalize_f);\n\t  if (chk_result == -1)\n\t    goto error;\n\t  else if (chk_result == 0)\n\t    r->atexit_status = atexit_status_broken;\n\t  else\n\t    {\n\t      r->atexit_f = (atexit_p)dlsym (handle, \"atexit\");\n\t      if (! r->atexit_f)\n\t\tgoto error;\n\t      r->atexit_status = atexit_status_working;\n\t    }\n\t}\n    }\n\n  return r;\n  \n error:\n  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, r);\n  return NULL;\n}\n\n/* Add TO_ADD to ATEXIT_LIST.  ATEXIT_LIST may be NULL but is\n   always the result of calling _keymgr_get_and_lock_processwide_ptr and\n   so KEYMGR_ATEXIT_LIST is known to be locked; this routine is responsible\n   for unlocking it.  */\n\nstatic int\nadd_routine (struct keymgr_atexit_list * g,\n\t     const struct one_atexit_routine * to_add)\n{\n  struct atexit_routine_list * s\n    = malloc (sizeof (struct atexit_routine_list));\n  int result;\n  \n  if (!s)\n    {\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n      return -1;\n    }\n  s->r = *to_add;\n  s->next = g->l;\n  g->l = s;\n  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n  return CHECK_KEYMGR_ERROR (result) == 0 ? 0 : -1;\n}\n\n/* This runs the routines in G->L up to STOP.  */\nstatic struct keymgr_atexit_list *\nrun_routines (struct keymgr_atexit_list *g,\n\t      struct atexit_routine_list *stop)\n{\n  for (;;)\n    {\n      struct atexit_routine_list * cur = g->l;\n      if (! cur || cur == stop)\n\tbreak;\n      g->l = cur->next;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n\n      switch (cur->r.has_arg) {\n      case 0: case 2: case 4:\n\tcur->r.callback.ac ();\n\tbreak;\n      case 1: case 3: case 5:\n\tcur->r.callback.cac (cur->r.arg);\n\tbreak;\n      default:\n\t/* Don't understand, so don't call it.  */\n\tbreak;\n      }\n      free (cur);\n\n      g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n      if (! g)\n\tbreak;\n    }\n  return g;\n}\n\n/* Call the routine described by ROUTINE_PARAM and then call any\n   routines added to KEYMGR_ATEXIT_LIST while that routine was\n   running, all with in_cxa_finalize set.  */\n\nstatic void\ncxa_atexit_wrapper (void* routine_param)\n{\n  struct one_atexit_routine * routine = routine_param;\n  struct keymgr_atexit_list *g;\n  struct atexit_routine_list * base = NULL;\n  char prev_running = 0;\n  \n  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (g)\n    {\n      prev_running = g->running_routines;\n      g->running_routines = 1;\n      base = g->l;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n    }\n\n  if (routine->has_arg)\n    routine->callback.cac (routine->arg);\n  else\n    routine->callback.ac ();\n\n  if (g)\n    g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (g)\n    g = run_routines (g, base);\n  if (g)\n    {\n      g->running_routines = prev_running;\n      _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n    }\n}\n\n#ifdef __ppc__\n/* This code is used while running on 10.3.9, when __cxa_atexit doesn't\n   exist in the system library.  10.3.9 only supported regular PowerPC,\n   so this code isn't necessary on x86 or ppc64.  */\n\n/* This routine is called from the system atexit(); it runs everything\n   registered on the KEYMGR_ATEXIT_LIST.  */\n\nstatic void\nour_atexit (void)\n{\n  struct keymgr_atexit_list *g;\n  char prev_running;\n\n  g = _keymgr_get_and_lock_processwide_ptr (KEYMGR_ATEXIT_LIST);\n  if (! g || g->version != 0 || g->atexit_status != atexit_status_missing)\n    return;\n  \n  prev_running = g->running_routines;\n  g->running_routines = 1;\n  g = run_routines (g, NULL);\n  if (! g)\n    return;\n  g->running_routines = prev_running;\n  _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n}\n#endif\n\n/* This is our wrapper around atexit and __cxa_atexit.  It will return\n   nonzero if an error occurs, and otherwise:\n   - if in_cxa_finalize is set, or running on 10.3.9, add R to\n     KEYMGR_ATEXIT_LIST; or\n   - call the system __cxa_atexit to add cxa_atexit_wrapper with an argument\n     that indicates how cxa_atexit_wrapper should call R.  */\n\nstatic int\natexit_common (const struct one_atexit_routine *r, const void *dso)\n{\n  struct keymgr_atexit_list *g = get_globals ();\n\n  if (! g)\n    return -1;\n  \n  if (g->running_routines || g->atexit_status == atexit_status_missing)\n    return add_routine (g, r);\n\n  if (g->atexit_status >= atexit_status_working)\n    {\n      int result;\n      if (r->has_arg)\n\t{\n\t  cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n\t\t\t\t\t\t\t   g);\n\t  if (CHECK_KEYMGR_ERROR (result))\n\t    return -1;\n\t  return cxa_atexit (r->callback.cac, r->arg, dso);\n\t}\n      else\n\t{\n\t  atexit_p atexit_f = g->atexit_f;\n\t  result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST,\n\t\t\t\t\t\t\t   g);\n\t  if (CHECK_KEYMGR_ERROR (result))\n\t    return -1;\n\t  return atexit_f (r->callback.ac);\n\t}\n    }\n  else\n    {\n      cxa_atexit_p cxa_atexit = g->cxa_atexit_f;\n      struct one_atexit_routine *alloced;\n      int result;\n\n      result = _keymgr_set_and_unlock_processwide_ptr (KEYMGR_ATEXIT_LIST, g);\n      if (CHECK_KEYMGR_ERROR (result))\n\treturn -1;\n\n      alloced = malloc (sizeof (struct one_atexit_routine));\n      if (! alloced)\n\treturn -1;\n      *alloced = *r;\n      return cxa_atexit (cxa_atexit_wrapper, alloced, dso);\n    }\n}\n\n/* These are the actual replacement routines; they just funnel into\n   atexit_common.  */\n\nint __cxa_atexit (cxa_atexit_callback func, void* arg, \n\t\t  const void* dso) __attribute__((visibility(\"hidden\")));\n\nint\n__cxa_atexit (cxa_atexit_callback func, void* arg, const void* dso)\n{\n  struct one_atexit_routine r;\n  r.callback.cac = func;\n  r.has_arg = 1;\n  r.arg = arg;\n  return atexit_common (&r, dso);\n}\n\nint atexit (atexit_callback func) __attribute__((visibility(\"hidden\")));\n\n/* Use __dso_handle to allow even bundles that call atexit() to be unloaded\n   on 10.4.  */\nextern void __dso_handle;\n\nint\natexit (atexit_callback func)\n{\n  struct one_atexit_routine r;\n  r.callback.ac = func;\n  r.has_arg = 0;\n  return atexit_common (&r, &__dso_handle);\n}\n\n#endif /* __PIC__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/lto-plugin/lto-symtab.c": "/* Program to read the IL symbol table.\n   Copyright (C) 2008-2017 Free Software Foundation, Inc.\n   Contributed by Rafael Avila de Espindola (espindola@google.com).\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n\n#include <fcntl.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"plugin-api.h\"\n#include \"../gcc/lto/common.h\"\n\n/* The presence of gelf.h is checked by the toplevel configure script.  */\n# include <gelf.h>\n\nstatic ld_plugin_claim_file_handler claim_file_handler;\nstatic ld_plugin_all_symbols_read_handler all_symbols_read_handler;\nstatic ld_plugin_cleanup_handler cleanup_handler;\nstatic void *plugin_handle;\n\nstruct file_handle {\n  unsigned nsyms;\n  struct ld_plugin_symbol *syms;\n};\n\nstatic struct file_handle **all_file_handles = NULL;\nstatic unsigned int num_file_handles;\n\n/* Write NSYMS symbols from file HANDLE in SYMS. */\n\nstatic enum ld_plugin_status\nget_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms)\n{\n  unsigned i;\n  struct file_handle *h = (struct file_handle *) handle;\n  assert (h->nsyms == nsyms);\n\n  for (i = 0; i < nsyms; i++)\n    syms[i] = h->syms[i];\n\n  return LDPS_OK;\n}\n\n/* Register HANDLER as the callback for notifying the plugin that all symbols\n   have been read. */\n\nstatic enum ld_plugin_status\nregister_all_symbols_read (ld_plugin_all_symbols_read_handler handler)\n{\n  all_symbols_read_handler = handler;\n  return LDPS_OK;\n}\n\n/* Register HANDLER as the callback for claiming a file. */\n\nstatic enum ld_plugin_status\nregister_claim_file(ld_plugin_claim_file_handler handler)\n{\n  claim_file_handler = handler;\n  return LDPS_OK;\n}\n\n/* Register HANDLER as the callback to removing temporary files. */\n\nstatic enum ld_plugin_status\nregister_cleanup (ld_plugin_cleanup_handler handler)\n{\n  cleanup_handler = handler;\n  return LDPS_OK;\n}\n\n/* For a file identified by HANDLE, add NSYMS symbols from SYMS. */\n\nstatic enum ld_plugin_status\nadd_symbols (void *handle, int nsyms,\n\t     const struct ld_plugin_symbol *syms)\n{\n  int i;\n  struct file_handle *h = (struct file_handle *) handle;\n  h->nsyms = nsyms;\n  h->syms = calloc (nsyms, sizeof (struct ld_plugin_symbol));\n  assert (h->syms);\n\n  for (i = 0; i < nsyms; i++)\n    {\n      h->syms[i] = syms[i];\n      h->syms[i].name = strdup (h->syms[i].name);\n      if (h->syms[i].version)\n\th->syms[i].version = strdup (h->syms[i].version);\n      if (h->syms[i].comdat_key)\n\th->syms[i].comdat_key = strdup (h->syms[i].comdat_key);\n    }\n\n  return LDPS_OK;\n}\n\nstruct ld_plugin_tv tv[] = {\n  {LDPT_REGISTER_CLAIM_FILE_HOOK,\n   {.tv_register_claim_file = register_claim_file}\n  },\n  {LDPT_ADD_SYMBOLS,\n   {.tv_add_symbols = add_symbols}\n  },\n\n  {LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK,\n   {.tv_register_all_symbols_read = register_all_symbols_read}\n  },\n  {LDPT_GET_SYMBOLS,\n   {.tv_get_symbols = get_symbols}\n  },\n  {LDPT_REGISTER_CLEANUP_HOOK,\n   {.tv_register_cleanup = register_cleanup}\n  },\n  {0, {0}}\n};\n\n/* Load a plugin from a file named NAME. */\n\nstatic void\nload_plugin (const char *name)\n{\n  ld_plugin_onload onload;\n  plugin_handle = dlopen (name, RTLD_LAZY);\n\n  assert (plugin_handle != NULL);\n  onload = dlsym (plugin_handle, \"onload\");\n  assert (onload);\n  onload (tv);\n  assert (claim_file_handler);\n}\n\n/* Send object to the plugin. The file (archive or object) name is NAME.\n   FD is an open file descriptor. The object data starts at OFFSET and is\n   FILESIZE bytes long. */\n\nstatic void\nregister_object (const char *name, int fd, off_t offset, off_t filesize)\n{\n  int claimed;\n  struct ld_plugin_input_file file;\n  void *handle;\n\n  num_file_handles++;\n  all_file_handles = realloc (all_file_handles, num_file_handles\n\t\t\t      * sizeof (struct file_handle *));\n  assert (all_file_handles);\n\n  all_file_handles[num_file_handles - 1] = calloc (1,\n\t\t\t\t\t\t   sizeof (struct file_handle));\n  handle = all_file_handles[num_file_handles - 1];\n  assert (handle);\n\n  file.name = (char *) name;\n  file.fd = fd;\n  file.offset = offset;\n  file.filesize = filesize;\n\n  file.handle = handle;\n\n  claim_file_handler (&file, &claimed);\n}\n\n/* Send file named NAME to the plugin. */\n\nstatic void\nregister_file (const char *name)\n{\n int fd = open (name, O_RDONLY);\n Elf *elf;\n\n assert (fd >= 0);\n\n elf = elf_begin (fd, ELF_C_READ, NULL);\n assert (elf);\n\n Elf_Kind kind = elf_kind (elf);\n\n assert (kind == ELF_K_ELF || kind == ELF_K_AR);\n\n if (kind == ELF_K_AR)\n   {\n     Elf *member = elf_begin (fd, ELF_C_READ, elf);\n     while (member)\n       {\n\t Elf_Arhdr *h = elf_getarhdr (member);\n\t assert (h);\n\n\t if (h->ar_name[0] != '/')\n\t   {\n\t     off_t offset = elf_getbase (member);\n\t     register_object (name, fd, offset, h->ar_size);\n\t   }\n\n\t Elf_Cmd cmd = elf_next (member);\n\t elf_end (member);\n\t member = elf_begin (fd, cmd, elf);\n       }\n   }\n else /* Single File */\n   register_object (name, fd, 0, 0);\n\n elf_end (elf);\n}\n\n/* Fake symbol resolution for testing. */\n\nstatic void\nresolve (void)\n{\n  unsigned j;\n  for (j = 0; j < num_file_handles; j++)\n    {\n      struct file_handle *handle = all_file_handles[j];\n      unsigned int nsyms = handle->nsyms;\n      struct ld_plugin_symbol *syms = handle->syms;\n      unsigned i;\n      for (i = 0; i < nsyms; i++)\n\t{\n\t  switch (syms[i].def)\n\t    {\n\t    case LDPK_DEF:\n\t    case LDPK_WEAKDEF:\n\t    case LDPK_COMMON:\n\t      syms[i].resolution =  LDPR_PREVAILING_DEF;\n\t      break;\n\t    case LDPK_UNDEF:\n\t    case LDPK_WEAKUNDEF:\n\t      syms[i].resolution =  LDPR_RESOLVED_IR;\n\t      break;\n\t    }\n\t}\n    }\n}\n\n/* Print all symbol information. */\n\nstatic void\nprint (void)\n{\n  unsigned j;\n  for (j = 0; j < num_file_handles; j++)\n    {\n      struct file_handle *handle = all_file_handles[j];\n      unsigned int nsyms = handle->nsyms;\n      struct ld_plugin_symbol *syms = handle->syms;\n      unsigned i;\n      for (i = 0; i < nsyms; i++)\n\t{\n\t  printf(\"name: %s; \", syms[i].name);\n\t  if (syms[i].version)\n\t     printf(\"version: %s;\", syms[i].version);\n\t  else\n\t    printf(\"not versioned; \");\n\t  printf(\"kind: %s; \", lto_kind_str[syms[i].def]);\n\t  printf(\"visibility: %s; \", lto_visibility_str[syms[i].visibility]);\n\t  printf(\"size: %\" PRId64 \"; \", syms[i].size);\n\t  if (syms[i].comdat_key)\n\t    printf(\"comdat_key: %s; \", syms[i].comdat_key);\n\t  else\n\t    printf(\"no comdat_key; \");\n\t  printf (\"resolution: %s\\n\", lto_resolution_str[syms[i].resolution]);\n\t}\n    }\n}\n\n/* Unload the plugin. */\n\nstatic void\nunload_plugin (void)\n{\n  unsigned err = dlclose (plugin_handle);\n  assert (err == 0);\n  claim_file_handler = 0;\n  all_symbols_read_handler = 0;\n}\n\n/* Free all memory allocated by us that hasn't been freed yet. */\n\nstatic void\nfree_all (void)\n{\n  unsigned j;\n  for (j = 0; j < num_file_handles; j++)\n    {\n      struct file_handle *handle = all_file_handles[j];\n      unsigned int nsyms = handle->nsyms;\n      struct ld_plugin_symbol *syms = handle->syms;\n      unsigned i;\n      for (i = 0; i < nsyms; i++)\n\t{\n\t  free (syms[i].name);\n\t  syms[i].name = 0;\n\t  if (syms[i].version)\n\t    {\n\t      free (syms[i].version);\n\t      syms[i].version = 0;\n\t    }\n\t  if (syms[i].comdat_key)\n\t    {\n\t      free (syms[i].comdat_key);\n\t      syms[i].comdat_key = 0;\n\t    }\n\t}\n      free (syms);\n      handle->syms = NULL;\n      handle->nsyms = 0;\n      free (all_file_handles[j]);\n      all_file_handles[j] = NULL;\n    }\n\n  free (all_file_handles);\n  all_file_handles = NULL;\n  num_file_handles = 0;\n}\n\nint\nmain(int argc, char *argv[])\n{\n  const char *plugin;\n  unsigned int i;\n  assert (argc >= 3);\n  plugin = argv[1];\n\n  load_plugin (plugin);\n\n  for (i = 2; i < argc; i++)\n    register_file (argv[i]);\n\n  resolve ();\n\n  print ();\n\n  all_symbols_read_handler ();\n\n  free_all ();\n\n  cleanup_handler ();\n\n  unload_plugin ();\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgomp/target.c": "/* Copyright (C) 2013-2017 Free Software Foundation, Inc.\n   Contributed by Jakub Jelinek <jakub@redhat.com>.\n\n   This file is part of the GNU Offloading and Multi Processing Library\n   (libgomp).\n\n   Libgomp is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n   more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* This file contains the support of offloading.  */\n\n#include \"config.h\"\n#include \"libgomp.h\"\n#include \"oacc-plugin.h\"\n#include \"oacc-int.h\"\n#include \"gomp-constants.h\"\n#include <limits.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>  /* For PRIu64.  */\n#endif\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n\n#ifdef PLUGIN_SUPPORT\n#include <dlfcn.h>\n#include \"plugin-suffix.h\"\n#endif\n\nstatic void gomp_target_init (void);\n\n/* The whole initialization code for offloading plugins is only run one.  */\nstatic pthread_once_t gomp_is_initialized = PTHREAD_ONCE_INIT;\n\n/* Mutex for offload image registration.  */\nstatic gomp_mutex_t register_lock;\n\n/* This structure describes an offload image.\n   It contains type of the target device, pointer to host table descriptor, and\n   pointer to target data.  */\nstruct offload_image_descr {\n  unsigned version;\n  enum offload_target_type type;\n  const void *host_table;\n  const void *target_data;\n};\n\n/* Array of descriptors of offload images.  */\nstatic struct offload_image_descr *offload_images;\n\n/* Total number of offload images.  */\nstatic int num_offload_images;\n\n/* Array of descriptors for all available devices.  */\nstatic struct gomp_device_descr *devices;\n\n/* Total number of available devices.  */\nstatic int num_devices;\n\n/* Number of GOMP_OFFLOAD_CAP_OPENMP_400 devices.  */\nstatic int num_devices_openmp;\n\n/* Similar to gomp_realloc, but release register_lock before gomp_fatal.  */\n\nstatic void *\ngomp_realloc_unlock (void *old, size_t size)\n{\n  void *ret = realloc (old, size);\n  if (ret == NULL)\n    {\n      gomp_mutex_unlock (&register_lock);\n      gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n    }\n  return ret;\n}\n\nattribute_hidden void\ngomp_init_targets_once (void)\n{\n  (void) pthread_once (&gomp_is_initialized, gomp_target_init);\n}\n\nattribute_hidden int\ngomp_get_num_devices (void)\n{\n  gomp_init_targets_once ();\n  return num_devices_openmp;\n}\n\nstatic struct gomp_device_descr *\nresolve_device (int device_id)\n{\n  if (device_id == GOMP_DEVICE_ICV)\n    {\n      struct gomp_task_icv *icv = gomp_icv (false);\n      device_id = icv->default_device_var;\n    }\n\n  if (device_id < 0 || device_id >= gomp_get_num_devices ())\n    return NULL;\n\n  gomp_mutex_lock (&devices[device_id].lock);\n  if (devices[device_id].state == GOMP_DEVICE_UNINITIALIZED)\n    gomp_init_device (&devices[device_id]);\n  else if (devices[device_id].state == GOMP_DEVICE_FINALIZED)\n    {\n      gomp_mutex_unlock (&devices[device_id].lock);\n      return NULL;\n    }\n  gomp_mutex_unlock (&devices[device_id].lock);\n\n  return &devices[device_id];\n}\n\n\nstatic inline splay_tree_key\ngomp_map_lookup (splay_tree mem_map, splay_tree_key key)\n{\n  if (key->host_start != key->host_end)\n    return splay_tree_lookup (mem_map, key);\n\n  key->host_end++;\n  splay_tree_key n = splay_tree_lookup (mem_map, key);\n  key->host_end--;\n  if (n)\n    return n;\n  key->host_start--;\n  n = splay_tree_lookup (mem_map, key);\n  key->host_start++;\n  if (n)\n    return n;\n  return splay_tree_lookup (mem_map, key);\n}\n\nstatic inline splay_tree_key\ngomp_map_0len_lookup (splay_tree mem_map, splay_tree_key key)\n{\n  if (key->host_start != key->host_end)\n    return splay_tree_lookup (mem_map, key);\n\n  key->host_end++;\n  splay_tree_key n = splay_tree_lookup (mem_map, key);\n  key->host_end--;\n  return n;\n}\n\nstatic inline void\ngomp_device_copy (struct gomp_device_descr *devicep,\n\t\t  bool (*copy_func) (int, void *, const void *, size_t),\n\t\t  const char *dst, void *dstaddr,\n\t\t  const char *src, const void *srcaddr,\n\t\t  size_t size)\n{\n  if (!copy_func (devicep->target_id, dstaddr, srcaddr, size))\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"Copying of %s object [%p..%p) to %s object [%p..%p) failed\",\n\t\t  src, srcaddr, srcaddr + size, dst, dstaddr, dstaddr + size);\n    }\n}\n\nstatic void\ngomp_copy_host2dev (struct gomp_device_descr *devicep,\n\t\t    void *d, const void *h, size_t sz)\n{\n  gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n}\n\nstatic void\ngomp_copy_dev2host (struct gomp_device_descr *devicep,\n\t\t    void *h, const void *d, size_t sz)\n{\n  gomp_device_copy (devicep, devicep->dev2host_func, \"host\", h, \"dev\", d, sz);\n}\n\nstatic void\ngomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)\n{\n  if (!devicep->free_func (devicep->target_id, devptr))\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"error in freeing device memory block at %p\", devptr);\n    }\n}\n\n/* Handle the case where gomp_map_lookup, splay_tree_lookup or\n   gomp_map_0len_lookup found oldn for newn.\n   Helper function of gomp_map_vars.  */\n\nstatic inline void\ngomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n\t\t\tsplay_tree_key newn, struct target_var_desc *tgt_var,\n\t\t\tunsigned char kind)\n{\n  tgt_var->key = oldn;\n  tgt_var->copy_from = GOMP_MAP_COPY_FROM_P (kind);\n  tgt_var->always_copy_from = GOMP_MAP_ALWAYS_FROM_P (kind);\n  tgt_var->offset = newn->host_start - oldn->host_start;\n  tgt_var->length = newn->host_end - newn->host_start;\n\n  if ((kind & GOMP_MAP_FLAG_FORCE)\n      || oldn->host_start > newn->host_start\n      || oldn->host_end < newn->host_end)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"Trying to map into device [%p..%p) object when \"\n\t\t  \"[%p..%p) is already mapped\",\n\t\t  (void *) newn->host_start, (void *) newn->host_end,\n\t\t  (void *) oldn->host_start, (void *) oldn->host_end);\n    }\n\n  if (GOMP_MAP_ALWAYS_TO_P (kind))\n    gomp_copy_host2dev (devicep,\n\t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n\t\t\t\t  + newn->host_start - oldn->host_start),\n\t\t\t(void *) newn->host_start,\n\t\t\tnewn->host_end - newn->host_start);\n\n  if (oldn->refcount != REFCOUNT_INFINITY)\n    oldn->refcount++;\n}\n\nstatic int\nget_kind (bool short_mapkind, void *kinds, int idx)\n{\n  return short_mapkind ? ((unsigned short *) kinds)[idx]\n\t\t       : ((unsigned char *) kinds)[idx];\n}\n\nstatic void\ngomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n\t\t  uintptr_t target_offset, uintptr_t bias)\n{\n  struct gomp_device_descr *devicep = tgt->device_descr;\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n\n  cur_node.host_start = host_ptr;\n  if (cur_node.host_start == (uintptr_t) NULL)\n    {\n      cur_node.tgt_offset = (uintptr_t) NULL;\n      /* FIXME: see comment about coalescing host/dev transfers below.  */\n      gomp_copy_host2dev (devicep,\n\t\t\t  (void *) (tgt->tgt_start + target_offset),\n\t\t\t  (void *) &cur_node.tgt_offset,\n\t\t\t  sizeof (void *));\n      return;\n    }\n  /* Add bias to the pointer value.  */\n  cur_node.host_start += bias;\n  cur_node.host_end = cur_node.host_start;\n  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n  if (n == NULL)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"Pointer target of array section wasn't mapped\");\n    }\n  cur_node.host_start -= n->host_start;\n  cur_node.tgt_offset\n    = n->tgt->tgt_start + n->tgt_offset + cur_node.host_start;\n  /* At this point tgt_offset is target address of the\n     array section.  Now subtract bias to get what we want\n     to initialize the pointer with.  */\n  cur_node.tgt_offset -= bias;\n  /* FIXME: see comment about coalescing host/dev transfers below.  */\n  gomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + target_offset),\n\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n}\n\nstatic void\ngomp_map_fields_existing (struct target_mem_desc *tgt, splay_tree_key n,\n\t\t\t  size_t first, size_t i, void **hostaddrs,\n\t\t\t  size_t *sizes, void *kinds)\n{\n  struct gomp_device_descr *devicep = tgt->device_descr;\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n  int kind;\n  const bool short_mapkind = true;\n  const int typemask = short_mapkind ? 0xff : 0x7;\n\n  cur_node.host_start = (uintptr_t) hostaddrs[i];\n  cur_node.host_end = cur_node.host_start + sizes[i];\n  splay_tree_key n2 = splay_tree_lookup (mem_map, &cur_node);\n  kind = get_kind (short_mapkind, kinds, i);\n  if (n2\n      && n2->tgt == n->tgt\n      && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n    {\n      gomp_map_vars_existing (devicep, n2, &cur_node,\n\t\t\t      &tgt->list[i], kind & typemask);\n      return;\n    }\n  if (sizes[i] == 0)\n    {\n      if (cur_node.host_start > (uintptr_t) hostaddrs[first - 1])\n\t{\n\t  cur_node.host_start--;\n\t  n2 = splay_tree_lookup (mem_map, &cur_node);\n\t  cur_node.host_start++;\n\t  if (n2\n\t      && n2->tgt == n->tgt\n\t      && n2->host_start - n->host_start\n\t\t == n2->tgt_offset - n->tgt_offset)\n\t    {\n\t      gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n\t\t\t\t      kind & typemask);\n\t      return;\n\t    }\n\t}\n      cur_node.host_end++;\n      n2 = splay_tree_lookup (mem_map, &cur_node);\n      cur_node.host_end--;\n      if (n2\n\t  && n2->tgt == n->tgt\n\t  && n2->host_start - n->host_start == n2->tgt_offset - n->tgt_offset)\n\t{\n\t  gomp_map_vars_existing (devicep, n2, &cur_node, &tgt->list[i],\n\t\t\t\t  kind & typemask);\n\t  return;\n\t}\n    }\n  gomp_mutex_unlock (&devicep->lock);\n  gomp_fatal (\"Trying to map into device [%p..%p) structure element when \"\n\t      \"other mapped elements from the same structure weren't mapped \"\n\t      \"together with it\", (void *) cur_node.host_start,\n\t      (void *) cur_node.host_end);\n}\n\nstatic inline uintptr_t\ngomp_map_val (struct target_mem_desc *tgt, void **hostaddrs, size_t i)\n{\n  if (tgt->list[i].key != NULL)\n    return tgt->list[i].key->tgt->tgt_start\n\t   + tgt->list[i].key->tgt_offset\n\t   + tgt->list[i].offset;\n  if (tgt->list[i].offset == ~(uintptr_t) 0)\n    return (uintptr_t) hostaddrs[i];\n  if (tgt->list[i].offset == ~(uintptr_t) 1)\n    return 0;\n  if (tgt->list[i].offset == ~(uintptr_t) 2)\n    return tgt->list[i + 1].key->tgt->tgt_start\n\t   + tgt->list[i + 1].key->tgt_offset\n\t   + tgt->list[i + 1].offset\n\t   + (uintptr_t) hostaddrs[i]\n\t   - (uintptr_t) hostaddrs[i + 1];\n  return tgt->tgt_start + tgt->list[i].offset;\n}\n\nattribute_hidden struct target_mem_desc *\ngomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n\t       void **hostaddrs, void **devaddrs, size_t *sizes, void *kinds,\n\t       bool short_mapkind, enum gomp_map_vars_kind pragma_kind)\n{\n  size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n  bool has_firstprivate = false;\n  const int rshift = short_mapkind ? 8 : 3;\n  const int typemask = short_mapkind ? 0xff : 0x7;\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n  struct target_mem_desc *tgt\n    = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n  tgt->list_count = mapnum;\n  tgt->refcount = pragma_kind == GOMP_MAP_VARS_ENTER_DATA ? 0 : 1;\n  tgt->device_descr = devicep;\n\n  if (mapnum == 0)\n    {\n      tgt->tgt_start = 0;\n      tgt->tgt_end = 0;\n      return tgt;\n    }\n\n  tgt_align = sizeof (void *);\n  tgt_size = 0;\n  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n    {\n      size_t align = 4 * sizeof (void *);\n      tgt_align = align;\n      tgt_size = mapnum * sizeof (void *);\n    }\n\n  gomp_mutex_lock (&devicep->lock);\n  if (devicep->state == GOMP_DEVICE_FINALIZED)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      free (tgt);\n      return NULL;\n    }\n\n  for (i = 0; i < mapnum; i++)\n    {\n      int kind = get_kind (short_mapkind, kinds, i);\n      if (hostaddrs[i] == NULL\n\t  || (kind & typemask) == GOMP_MAP_FIRSTPRIVATE_INT)\n\t{\n\t  tgt->list[i].key = NULL;\n\t  tgt->list[i].offset = ~(uintptr_t) 0;\n\t  continue;\n\t}\n      else if ((kind & typemask) == GOMP_MAP_USE_DEVICE_PTR)\n\t{\n\t  cur_node.host_start = (uintptr_t) hostaddrs[i];\n\t  cur_node.host_end = cur_node.host_start;\n\t  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n\t  if (n == NULL)\n\t    {\n\t      gomp_mutex_unlock (&devicep->lock);\n\t      gomp_fatal (\"use_device_ptr pointer wasn't mapped\");\n\t    }\n\t  cur_node.host_start -= n->host_start;\n\t  hostaddrs[i]\n\t    = (void *) (n->tgt->tgt_start + n->tgt_offset\n\t\t\t+ cur_node.host_start);\n\t  tgt->list[i].key = NULL;\n\t  tgt->list[i].offset = ~(uintptr_t) 0;\n\t  continue;\n\t}\n      else if ((kind & typemask) == GOMP_MAP_STRUCT)\n\t{\n\t  size_t first = i + 1;\n\t  size_t last = i + sizes[i];\n\t  cur_node.host_start = (uintptr_t) hostaddrs[i];\n\t  cur_node.host_end = (uintptr_t) hostaddrs[last]\n\t\t\t      + sizes[last];\n\t  tgt->list[i].key = NULL;\n\t  tgt->list[i].offset = ~(uintptr_t) 2;\n\t  splay_tree_key n = splay_tree_lookup (mem_map, &cur_node);\n\t  if (n == NULL)\n\t    {\n\t      size_t align = (size_t) 1 << (kind >> rshift);\n\t      if (tgt_align < align)\n\t\ttgt_align = align;\n\t      tgt_size -= (uintptr_t) hostaddrs[first]\n\t\t\t  - (uintptr_t) hostaddrs[i];\n\t      tgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t      tgt_size += cur_node.host_end - (uintptr_t) hostaddrs[i];\n\t      not_found_cnt += last - i;\n\t      for (i = first; i <= last; i++)\n\t\ttgt->list[i].key = NULL;\n\t      i--;\n\t      continue;\n\t    }\n\t  for (i = first; i <= last; i++)\n\t    gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n\t\t\t\t      sizes, kinds);\n\t  i--;\n\t  continue;\n\t}\n      else if ((kind & typemask) == GOMP_MAP_ALWAYS_POINTER)\n\t{\n\t  tgt->list[i].key = NULL;\n\t  tgt->list[i].offset = ~(uintptr_t) 1;\n\t  has_firstprivate = true;\n\t  continue;\n\t}\n      cur_node.host_start = (uintptr_t) hostaddrs[i];\n      if (!GOMP_MAP_POINTER_P (kind & typemask))\n\tcur_node.host_end = cur_node.host_start + sizes[i];\n      else\n\tcur_node.host_end = cur_node.host_start + sizeof (void *);\n      if ((kind & typemask) == GOMP_MAP_FIRSTPRIVATE)\n\t{\n\t  tgt->list[i].key = NULL;\n\n\t  size_t align = (size_t) 1 << (kind >> rshift);\n\t  if (tgt_align < align)\n\t    tgt_align = align;\n\t  tgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t  tgt_size += cur_node.host_end - cur_node.host_start;\n\t  has_firstprivate = true;\n\t  continue;\n\t}\n      splay_tree_key n;\n      if ((kind & typemask) == GOMP_MAP_ZERO_LEN_ARRAY_SECTION)\n\t{\n\t  n = gomp_map_0len_lookup (mem_map, &cur_node);\n\t  if (!n)\n\t    {\n\t      tgt->list[i].key = NULL;\n\t      tgt->list[i].offset = ~(uintptr_t) 1;\n\t      continue;\n\t    }\n\t}\n      else\n\tn = splay_tree_lookup (mem_map, &cur_node);\n      if (n && n->refcount != REFCOUNT_LINK)\n\tgomp_map_vars_existing (devicep, n, &cur_node, &tgt->list[i],\n\t\t\t\tkind & typemask);\n      else\n\t{\n\t  tgt->list[i].key = NULL;\n\n\t  size_t align = (size_t) 1 << (kind >> rshift);\n\t  not_found_cnt++;\n\t  if (tgt_align < align)\n\t    tgt_align = align;\n\t  tgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t  tgt_size += cur_node.host_end - cur_node.host_start;\n\t  if ((kind & typemask) == GOMP_MAP_TO_PSET)\n\t    {\n\t      size_t j;\n\t      for (j = i + 1; j < mapnum; j++)\n\t\tif (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds, j)\n\t\t\t\t\t & typemask))\n\t\t  break;\n\t\telse if ((uintptr_t) hostaddrs[j] < cur_node.host_start\n\t\t\t || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n\t\t\t     > cur_node.host_end))\n\t\t  break;\n\t\telse\n\t\t  {\n\t\t    tgt->list[j].key = NULL;\n\t\t    i++;\n\t\t  }\n\t    }\n\t}\n    }\n\n  if (devaddrs)\n    {\n      if (mapnum != 1)\n\t{\n\t  gomp_mutex_unlock (&devicep->lock);\n\t  gomp_fatal (\"unexpected aggregation\");\n\t}\n      tgt->to_free = devaddrs[0];\n      tgt->tgt_start = (uintptr_t) tgt->to_free;\n      tgt->tgt_end = tgt->tgt_start + sizes[0];\n    }\n  else if (not_found_cnt || pragma_kind == GOMP_MAP_VARS_TARGET)\n    {\n      /* Allocate tgt_align aligned tgt_size block of memory.  */\n      /* FIXME: Perhaps change interface to allocate properly aligned\n\t memory.  */\n      tgt->to_free = devicep->alloc_func (devicep->target_id,\n\t\t\t\t\t  tgt_size + tgt_align - 1);\n      if (!tgt->to_free)\n\t{\n\t  gomp_mutex_unlock (&devicep->lock);\n\t  gomp_fatal (\"device memory allocation fail\");\n\t}\n\n      tgt->tgt_start = (uintptr_t) tgt->to_free;\n      tgt->tgt_start = (tgt->tgt_start + tgt_align - 1) & ~(tgt_align - 1);\n      tgt->tgt_end = tgt->tgt_start + tgt_size;\n    }\n  else\n    {\n      tgt->to_free = NULL;\n      tgt->tgt_start = 0;\n      tgt->tgt_end = 0;\n    }\n\n  tgt_size = 0;\n  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n    tgt_size = mapnum * sizeof (void *);\n\n  tgt->array = NULL;\n  if (not_found_cnt || has_firstprivate)\n    {\n      if (not_found_cnt)\n\ttgt->array = gomp_malloc (not_found_cnt * sizeof (*tgt->array));\n      splay_tree_node array = tgt->array;\n      size_t j, field_tgt_offset = 0, field_tgt_clear = ~(size_t) 0;\n      uintptr_t field_tgt_base = 0;\n\n      for (i = 0; i < mapnum; i++)\n\tif (tgt->list[i].key == NULL)\n\t  {\n\t    int kind = get_kind (short_mapkind, kinds, i);\n\t    if (hostaddrs[i] == NULL)\n\t      continue;\n\t    switch (kind & typemask)\n\t      {\n\t\tsize_t align, len, first, last;\n\t\tsplay_tree_key n;\n\t      case GOMP_MAP_FIRSTPRIVATE:\n\t\talign = (size_t) 1 << (kind >> rshift);\n\t\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t\ttgt->list[i].offset = tgt_size;\n\t\tlen = sizes[i];\n\t\tgomp_copy_host2dev (devicep,\n\t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n\t\t\t\t    (void *) hostaddrs[i], len);\n\t\ttgt_size += len;\n\t\tcontinue;\n\t      case GOMP_MAP_FIRSTPRIVATE_INT:\n\t      case GOMP_MAP_USE_DEVICE_PTR:\n\t      case GOMP_MAP_ZERO_LEN_ARRAY_SECTION:\n\t\tcontinue;\n\t      case GOMP_MAP_STRUCT:\n\t\tfirst = i + 1;\n\t\tlast = i + sizes[i];\n\t\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n\t\tcur_node.host_end = (uintptr_t) hostaddrs[last]\n\t\t\t\t    + sizes[last];\n\t\tif (tgt->list[first].key != NULL)\n\t\t  continue;\n\t\tn = splay_tree_lookup (mem_map, &cur_node);\n\t\tif (n == NULL)\n\t\t  {\n\t\t    size_t align = (size_t) 1 << (kind >> rshift);\n\t\t    tgt_size -= (uintptr_t) hostaddrs[first]\n\t\t\t\t- (uintptr_t) hostaddrs[i];\n\t\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t\t    tgt_size += (uintptr_t) hostaddrs[first]\n\t\t\t\t- (uintptr_t) hostaddrs[i];\n\t\t    field_tgt_base = (uintptr_t) hostaddrs[first];\n\t\t    field_tgt_offset = tgt_size;\n\t\t    field_tgt_clear = last;\n\t\t    tgt_size += cur_node.host_end\n\t\t\t\t- (uintptr_t) hostaddrs[first];\n\t\t    continue;\n\t\t  }\n\t\tfor (i = first; i <= last; i++)\n\t\t  gomp_map_fields_existing (tgt, n, first, i, hostaddrs,\n\t\t\t\t\t    sizes, kinds);\n\t\ti--;\n\t\tcontinue;\n\t      case GOMP_MAP_ALWAYS_POINTER:\n\t\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n\t\tcur_node.host_end = cur_node.host_start + sizeof (void *);\n\t\tn = splay_tree_lookup (mem_map, &cur_node);\n\t\tif (n == NULL\n\t\t    || n->host_start > cur_node.host_start\n\t\t    || n->host_end < cur_node.host_end)\n\t\t  {\n\t\t    gomp_mutex_unlock (&devicep->lock);\n\t\t    gomp_fatal (\"always pointer not mapped\");\n\t\t  }\n\t\tif ((get_kind (short_mapkind, kinds, i - 1) & typemask)\n\t\t    != GOMP_MAP_ALWAYS_POINTER)\n\t\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i - 1);\n\t\tif (cur_node.tgt_offset)\n\t\t  cur_node.tgt_offset -= sizes[i];\n\t\tgomp_copy_host2dev (devicep,\n\t\t\t\t    (void *) (n->tgt->tgt_start\n\t\t\t\t\t      + n->tgt_offset\n\t\t\t\t\t      + cur_node.host_start\n\t\t\t\t\t      - n->host_start),\n\t\t\t\t    (void *) &cur_node.tgt_offset,\n\t\t\t\t    sizeof (void *));\n\t\tcur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n\t\t\t\t      + cur_node.host_start - n->host_start;\n\t\tcontinue;\n\t      default:\n\t\tbreak;\n\t      }\n\t    splay_tree_key k = &array->key;\n\t    k->host_start = (uintptr_t) hostaddrs[i];\n\t    if (!GOMP_MAP_POINTER_P (kind & typemask))\n\t      k->host_end = k->host_start + sizes[i];\n\t    else\n\t      k->host_end = k->host_start + sizeof (void *);\n\t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n\t    if (n && n->refcount != REFCOUNT_LINK)\n\t      gomp_map_vars_existing (devicep, n, k, &tgt->list[i],\n\t\t\t\t      kind & typemask);\n\t    else\n\t      {\n\t\tk->link_key = NULL;\n\t\tif (n && n->refcount == REFCOUNT_LINK)\n\t\t  {\n\t\t    /* Replace target address of the pointer with target address\n\t\t       of mapped object in the splay tree.  */\n\t\t    splay_tree_remove (mem_map, n);\n\t\t    k->link_key = n;\n\t\t  }\n\t\tsize_t align = (size_t) 1 << (kind >> rshift);\n\t\ttgt->list[i].key = k;\n\t\tk->tgt = tgt;\n\t\tif (field_tgt_clear != ~(size_t) 0)\n\t\t  {\n\t\t    k->tgt_offset = k->host_start - field_tgt_base\n\t\t\t\t    + field_tgt_offset;\n\t\t    if (i == field_tgt_clear)\n\t\t      field_tgt_clear = ~(size_t) 0;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    tgt_size = (tgt_size + align - 1) & ~(align - 1);\n\t\t    k->tgt_offset = tgt_size;\n\t\t    tgt_size += k->host_end - k->host_start;\n\t\t  }\n\t\ttgt->list[i].copy_from = GOMP_MAP_COPY_FROM_P (kind & typemask);\n\t\ttgt->list[i].always_copy_from\n\t\t  = GOMP_MAP_ALWAYS_FROM_P (kind & typemask);\n\t\ttgt->list[i].offset = 0;\n\t\ttgt->list[i].length = k->host_end - k->host_start;\n\t\tk->refcount = 1;\n\t\ttgt->refcount++;\n\t\tarray->left = NULL;\n\t\tarray->right = NULL;\n\t\tsplay_tree_insert (mem_map, array);\n\t\tswitch (kind & typemask)\n\t\t  {\n\t\t  case GOMP_MAP_ALLOC:\n\t\t  case GOMP_MAP_FROM:\n\t\t  case GOMP_MAP_FORCE_ALLOC:\n\t\t  case GOMP_MAP_FORCE_FROM:\n\t\t  case GOMP_MAP_ALWAYS_FROM:\n\t\t    break;\n\t\t  case GOMP_MAP_TO:\n\t\t  case GOMP_MAP_TOFROM:\n\t\t  case GOMP_MAP_FORCE_TO:\n\t\t  case GOMP_MAP_FORCE_TOFROM:\n\t\t  case GOMP_MAP_ALWAYS_TO:\n\t\t  case GOMP_MAP_ALWAYS_TOFROM:\n\t\t    /* FIXME: Perhaps add some smarts, like if copying\n\t\t       several adjacent fields from host to target, use some\n\t\t       host buffer to avoid sending each var individually.  */\n\t\t    gomp_copy_host2dev (devicep,\n\t\t\t\t\t(void *) (tgt->tgt_start\n\t\t\t\t\t\t  + k->tgt_offset),\n\t\t\t\t\t(void *) k->host_start,\n\t\t\t\t\tk->host_end - k->host_start);\n\t\t    break;\n\t\t  case GOMP_MAP_POINTER:\n\t\t    gomp_map_pointer (tgt, (uintptr_t) *(void **) k->host_start,\n\t\t\t\t      k->tgt_offset, sizes[i]);\n\t\t    break;\n\t\t  case GOMP_MAP_TO_PSET:\n\t\t    /* FIXME: see above FIXME comment.  */\n\t\t    gomp_copy_host2dev (devicep,\n\t\t\t\t\t(void *) (tgt->tgt_start\n\t\t\t\t\t\t  + k->tgt_offset),\n\t\t\t\t\t(void *) k->host_start,\n\t\t\t\t\tk->host_end - k->host_start);\n\n\t\t    for (j = i + 1; j < mapnum; j++)\n\t\t      if (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds,\n\t\t\t\t\t\t\t j)\n\t\t\t\t\t       & typemask))\n\t\t\tbreak;\n\t\t      else if ((uintptr_t) hostaddrs[j] < k->host_start\n\t\t\t       || ((uintptr_t) hostaddrs[j] + sizeof (void *)\n\t\t\t\t   > k->host_end))\n\t\t\tbreak;\n\t\t      else\n\t\t\t{\n\t\t\t  tgt->list[j].key = k;\n\t\t\t  tgt->list[j].copy_from = false;\n\t\t\t  tgt->list[j].always_copy_from = false;\n\t\t\t  if (k->refcount != REFCOUNT_INFINITY)\n\t\t\t    k->refcount++;\n\t\t\t  gomp_map_pointer (tgt,\n\t\t\t\t\t    (uintptr_t) *(void **) hostaddrs[j],\n\t\t\t\t\t    k->tgt_offset\n\t\t\t\t\t    + ((uintptr_t) hostaddrs[j]\n\t\t\t\t\t       - k->host_start),\n\t\t\t\t\t    sizes[j]);\n\t\t\t  i++;\n\t\t\t}\n\t\t    break;\n\t\t  case GOMP_MAP_FORCE_PRESENT:\n\t\t    {\n\t\t      /* We already looked up the memory region above and it\n\t\t\t was missing.  */\n\t\t      size_t size = k->host_end - k->host_start;\n\t\t      gomp_mutex_unlock (&devicep->lock);\n#ifdef HAVE_INTTYPES_H\n\t\t      gomp_fatal (\"present clause: !acc_is_present (%p, \"\n\t\t\t\t  \"%\"PRIu64\" (0x%\"PRIx64\"))\",\n\t\t\t\t  (void *) k->host_start,\n\t\t\t\t  (uint64_t) size, (uint64_t) size);\n#else\n\t\t      gomp_fatal (\"present clause: !acc_is_present (%p, \"\n\t\t\t\t  \"%lu (0x%lx))\", (void *) k->host_start,\n\t\t\t\t  (unsigned long) size, (unsigned long) size);\n#endif\n\t\t    }\n\t\t    break;\n\t\t  case GOMP_MAP_FORCE_DEVICEPTR:\n\t\t    assert (k->host_end - k->host_start == sizeof (void *));\n\t\t    gomp_copy_host2dev (devicep,\n\t\t\t\t\t(void *) (tgt->tgt_start\n\t\t\t\t\t\t  + k->tgt_offset),\n\t\t\t\t\t(void *) k->host_start,\n\t\t\t\t\tsizeof (void *));\n\t\t    break;\n\t\t  default:\n\t\t    gomp_mutex_unlock (&devicep->lock);\n\t\t    gomp_fatal (\"%s: unhandled kind 0x%.2x\", __FUNCTION__,\n\t\t\t\tkind);\n\t\t  }\n\n\t\tif (k->link_key)\n\t\t  {\n\t\t    /* Set link pointer on target to the device address of the\n\t\t       mapped object.  */\n\t\t    void *tgt_addr = (void *) (tgt->tgt_start + k->tgt_offset);\n\t\t    devicep->host2dev_func (devicep->target_id,\n\t\t\t\t\t    (void *) n->tgt_offset,\n\t\t\t\t\t    &tgt_addr, sizeof (void *));\n\t\t  }\n\t\tarray++;\n\t      }\n\t  }\n    }\n\n  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n    {\n      for (i = 0; i < mapnum; i++)\n\t{\n\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);\n\t  /* FIXME: see above FIXME comment.  */\n\t  gomp_copy_host2dev (devicep,\n\t\t\t      (void *) (tgt->tgt_start + i * sizeof (void *)),\n\t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n\t}\n    }\n\n  /* If the variable from \"omp target enter data\" map-list was already mapped,\n     tgt is not needed.  Otherwise tgt will be freed by gomp_unmap_vars or\n     gomp_exit_data.  */\n  if (pragma_kind == GOMP_MAP_VARS_ENTER_DATA && tgt->refcount == 0)\n    {\n      free (tgt);\n      tgt = NULL;\n    }\n\n  gomp_mutex_unlock (&devicep->lock);\n  return tgt;\n}\n\nstatic void\ngomp_unmap_tgt (struct target_mem_desc *tgt)\n{\n  /* Deallocate on target the tgt->tgt_start .. tgt->tgt_end region.  */\n  if (tgt->tgt_end)\n    gomp_free_device_memory (tgt->device_descr, tgt->to_free);\n\n  free (tgt->array);\n  free (tgt);\n}\n\n/* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant\n   variables back from device to host: if it is false, it is assumed that this\n   has been done already.  */\n\nattribute_hidden void\ngomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n{\n  struct gomp_device_descr *devicep = tgt->device_descr;\n\n  if (tgt->list_count == 0)\n    {\n      free (tgt);\n      return;\n    }\n\n  gomp_mutex_lock (&devicep->lock);\n  if (devicep->state == GOMP_DEVICE_FINALIZED)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      free (tgt->array);\n      free (tgt);\n      return;\n    }\n\n  size_t i;\n  for (i = 0; i < tgt->list_count; i++)\n    {\n      splay_tree_key k = tgt->list[i].key;\n      if (k == NULL)\n\tcontinue;\n\n      bool do_unmap = false;\n      if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n\tk->refcount--;\n      else if (k->refcount == 1)\n\t{\n\t  k->refcount--;\n\t  do_unmap = true;\n\t}\n\n      if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)\n\t  || tgt->list[i].always_copy_from)\n\tgomp_copy_dev2host (devicep,\n\t\t\t    (void *) (k->host_start + tgt->list[i].offset),\n\t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n\t\t\t\t      + tgt->list[i].offset),\n\t\t\t    tgt->list[i].length);\n      if (do_unmap)\n\t{\n\t  splay_tree_remove (&devicep->mem_map, k);\n\t  if (k->link_key)\n\t    splay_tree_insert (&devicep->mem_map,\n\t\t\t       (splay_tree_node) k->link_key);\n\t  if (k->tgt->refcount > 1)\n\t    k->tgt->refcount--;\n\t  else\n\t    gomp_unmap_tgt (k->tgt);\n\t}\n    }\n\n  if (tgt->refcount > 1)\n    tgt->refcount--;\n  else\n    gomp_unmap_tgt (tgt);\n\n  gomp_mutex_unlock (&devicep->lock);\n}\n\nstatic void\ngomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n\t     size_t *sizes, void *kinds, bool short_mapkind)\n{\n  size_t i;\n  struct splay_tree_key_s cur_node;\n  const int typemask = short_mapkind ? 0xff : 0x7;\n\n  if (!devicep)\n    return;\n\n  if (mapnum == 0)\n    return;\n\n  gomp_mutex_lock (&devicep->lock);\n  if (devicep->state == GOMP_DEVICE_FINALIZED)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      return;\n    }\n\n  for (i = 0; i < mapnum; i++)\n    if (sizes[i])\n      {\n\tcur_node.host_start = (uintptr_t) hostaddrs[i];\n\tcur_node.host_end = cur_node.host_start + sizes[i];\n\tsplay_tree_key n = splay_tree_lookup (&devicep->mem_map, &cur_node);\n\tif (n)\n\t  {\n\t    int kind = get_kind (short_mapkind, kinds, i);\n\t    if (n->host_start > cur_node.host_start\n\t\t|| n->host_end < cur_node.host_end)\n\t      {\n\t\tgomp_mutex_unlock (&devicep->lock);\n\t\tgomp_fatal (\"Trying to update [%p..%p) object when \"\n\t\t\t    \"only [%p..%p) is mapped\",\n\t\t\t    (void *) cur_node.host_start,\n\t\t\t    (void *) cur_node.host_end,\n\t\t\t    (void *) n->host_start,\n\t\t\t    (void *) n->host_end);\n\t      }\n\n\n\t    void *hostaddr = (void *) cur_node.host_start;\n\t    void *devaddr = (void *) (n->tgt->tgt_start + n->tgt_offset\n\t\t\t\t      + cur_node.host_start - n->host_start);\n\t    size_t size = cur_node.host_end - cur_node.host_start;\n\n\t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n\t      gomp_copy_host2dev (devicep, devaddr, hostaddr, size);\n\t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n\t      gomp_copy_dev2host (devicep, hostaddr, devaddr, size);\n\t  }\n      }\n  gomp_mutex_unlock (&devicep->lock);\n}\n\n/* Load image pointed by TARGET_DATA to the device, specified by DEVICEP.\n   And insert to splay tree the mapping between addresses from HOST_TABLE and\n   from loaded target image.  We rely in the host and device compiler\n   emitting variable and functions in the same order.  */\n\nstatic void\ngomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n\t\t\t   const void *host_table, const void *target_data,\n\t\t\t   bool is_register_lock)\n{\n  void **host_func_table = ((void ***) host_table)[0];\n  void **host_funcs_end  = ((void ***) host_table)[1];\n  void **host_var_table  = ((void ***) host_table)[2];\n  void **host_vars_end   = ((void ***) host_table)[3];\n\n  /* The func table contains only addresses, the var table contains addresses\n     and corresponding sizes.  */\n  int num_funcs = host_funcs_end - host_func_table;\n  int num_vars  = (host_vars_end - host_var_table) / 2;\n\n  /* Load image to device and get target addresses for the image.  */\n  struct addr_pair *target_table = NULL;\n  int i, num_target_entries;\n\n  num_target_entries\n    = devicep->load_image_func (devicep->target_id, version,\n\t\t\t\ttarget_data, &target_table);\n\n  if (num_target_entries != num_funcs + num_vars)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      if (is_register_lock)\n\tgomp_mutex_unlock (&register_lock);\n      gomp_fatal (\"Cannot map target functions or variables\"\n\t\t  \" (expected %u, have %u)\", num_funcs + num_vars,\n\t\t  num_target_entries);\n    }\n\n  /* Insert host-target address mapping into splay tree.  */\n  struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n  tgt->array = gomp_malloc ((num_funcs + num_vars) * sizeof (*tgt->array));\n  tgt->refcount = REFCOUNT_INFINITY;\n  tgt->tgt_start = 0;\n  tgt->tgt_end = 0;\n  tgt->to_free = NULL;\n  tgt->prev = NULL;\n  tgt->list_count = 0;\n  tgt->device_descr = devicep;\n  splay_tree_node array = tgt->array;\n\n  for (i = 0; i < num_funcs; i++)\n    {\n      splay_tree_key k = &array->key;\n      k->host_start = (uintptr_t) host_func_table[i];\n      k->host_end = k->host_start + 1;\n      k->tgt = tgt;\n      k->tgt_offset = target_table[i].start;\n      k->refcount = REFCOUNT_INFINITY;\n      k->link_key = NULL;\n      array->left = NULL;\n      array->right = NULL;\n      splay_tree_insert (&devicep->mem_map, array);\n      array++;\n    }\n\n  /* Most significant bit of the size in host and target tables marks\n     \"omp declare target link\" variables.  */\n  const uintptr_t link_bit = 1ULL << (sizeof (uintptr_t) * __CHAR_BIT__ - 1);\n  const uintptr_t size_mask = ~link_bit;\n\n  for (i = 0; i < num_vars; i++)\n    {\n      struct addr_pair *target_var = &target_table[num_funcs + i];\n      uintptr_t target_size = target_var->end - target_var->start;\n\n      if ((uintptr_t) host_var_table[i * 2 + 1] != target_size)\n\t{\n\t  gomp_mutex_unlock (&devicep->lock);\n\t  if (is_register_lock)\n\t    gomp_mutex_unlock (&register_lock);\n\t  gomp_fatal (\"Cannot map target variables (size mismatch)\");\n\t}\n\n      splay_tree_key k = &array->key;\n      k->host_start = (uintptr_t) host_var_table[i * 2];\n      k->host_end\n\t= k->host_start + (size_mask & (uintptr_t) host_var_table[i * 2 + 1]);\n      k->tgt = tgt;\n      k->tgt_offset = target_var->start;\n      k->refcount = target_size & link_bit ? REFCOUNT_LINK : REFCOUNT_INFINITY;\n      k->link_key = NULL;\n      array->left = NULL;\n      array->right = NULL;\n      splay_tree_insert (&devicep->mem_map, array);\n      array++;\n    }\n\n  free (target_table);\n}\n\n/* Unload the mappings described by target_data from device DEVICE_P.\n   The device must be locked.   */\n\nstatic void\ngomp_unload_image_from_device (struct gomp_device_descr *devicep,\n\t\t\t       unsigned version,\n\t\t\t       const void *host_table, const void *target_data)\n{\n  void **host_func_table = ((void ***) host_table)[0];\n  void **host_funcs_end  = ((void ***) host_table)[1];\n  void **host_var_table  = ((void ***) host_table)[2];\n  void **host_vars_end   = ((void ***) host_table)[3];\n\n  /* The func table contains only addresses, the var table contains addresses\n     and corresponding sizes.  */\n  int num_funcs = host_funcs_end - host_func_table;\n  int num_vars  = (host_vars_end - host_var_table) / 2;\n\n  struct splay_tree_key_s k;\n  splay_tree_key node = NULL;\n\n  /* Find mapping at start of node array */\n  if (num_funcs || num_vars)\n    {\n      k.host_start = (num_funcs ? (uintptr_t) host_func_table[0]\n\t\t      : (uintptr_t) host_var_table[0]);\n      k.host_end = k.host_start + 1;\n      node = splay_tree_lookup (&devicep->mem_map, &k);\n    }\n\n  if (!devicep->unload_image_func (devicep->target_id, version, target_data))\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"image unload fail\");\n    }\n\n  /* Remove mappings from splay tree.  */\n  int i;\n  for (i = 0; i < num_funcs; i++)\n    {\n      k.host_start = (uintptr_t) host_func_table[i];\n      k.host_end = k.host_start + 1;\n      splay_tree_remove (&devicep->mem_map, &k);\n    }\n\n  /* Most significant bit of the size in host and target tables marks\n     \"omp declare target link\" variables.  */\n  const uintptr_t link_bit = 1ULL << (sizeof (uintptr_t) * __CHAR_BIT__ - 1);\n  const uintptr_t size_mask = ~link_bit;\n  bool is_tgt_unmapped = false;\n\n  for (i = 0; i < num_vars; i++)\n    {\n      k.host_start = (uintptr_t) host_var_table[i * 2];\n      k.host_end\n\t= k.host_start + (size_mask & (uintptr_t) host_var_table[i * 2 + 1]);\n\n      if (!(link_bit & (uintptr_t) host_var_table[i * 2 + 1]))\n\tsplay_tree_remove (&devicep->mem_map, &k);\n      else\n\t{\n\t  splay_tree_key n = splay_tree_lookup (&devicep->mem_map, &k);\n\t  splay_tree_remove (&devicep->mem_map, n);\n\t  if (n->link_key)\n\t    {\n\t      if (n->tgt->refcount > 1)\n\t\tn->tgt->refcount--;\n\t      else\n\t\t{\n\t\t  is_tgt_unmapped = true;\n\t\t  gomp_unmap_tgt (n->tgt);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (node && !is_tgt_unmapped)\n    {\n      free (node->tgt);\n      free (node);\n    }\n}\n\n/* This function should be called from every offload image while loading.\n   It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n   the target, and TARGET_DATA needed by target plugin.  */\n\nvoid\nGOMP_offload_register_ver (unsigned version, const void *host_table,\n\t\t\t   int target_type, const void *target_data)\n{\n  int i;\n\n  if (GOMP_VERSION_LIB (version) > GOMP_VERSION)\n    gomp_fatal (\"Library too old for offload (version %u < %u)\",\n\t\tGOMP_VERSION, GOMP_VERSION_LIB (version));\n  \n  gomp_mutex_lock (&register_lock);\n\n  /* Load image to all initialized devices.  */\n  for (i = 0; i < num_devices; i++)\n    {\n      struct gomp_device_descr *devicep = &devices[i];\n      gomp_mutex_lock (&devicep->lock);\n      if (devicep->type == target_type\n\t  && devicep->state == GOMP_DEVICE_INITIALIZED)\n\tgomp_load_image_to_device (devicep, version,\n\t\t\t\t   host_table, target_data, true);\n      gomp_mutex_unlock (&devicep->lock);\n    }\n\n  /* Insert image to array of pending images.  */\n  offload_images\n    = gomp_realloc_unlock (offload_images,\n\t\t\t   (num_offload_images + 1)\n\t\t\t   * sizeof (struct offload_image_descr));\n  offload_images[num_offload_images].version = version;\n  offload_images[num_offload_images].type = target_type;\n  offload_images[num_offload_images].host_table = host_table;\n  offload_images[num_offload_images].target_data = target_data;\n\n  num_offload_images++;\n  gomp_mutex_unlock (&register_lock);\n}\n\nvoid\nGOMP_offload_register (const void *host_table, int target_type,\n\t\t       const void *target_data)\n{\n  GOMP_offload_register_ver (0, host_table, target_type, target_data);\n}\n\n/* This function should be called from every offload image while unloading.\n   It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n   the target, and TARGET_DATA needed by target plugin.  */\n\nvoid\nGOMP_offload_unregister_ver (unsigned version, const void *host_table,\n\t\t\t     int target_type, const void *target_data)\n{\n  int i;\n\n  gomp_mutex_lock (&register_lock);\n\n  /* Unload image from all initialized devices.  */\n  for (i = 0; i < num_devices; i++)\n    {\n      struct gomp_device_descr *devicep = &devices[i];\n      gomp_mutex_lock (&devicep->lock);\n      if (devicep->type == target_type\n\t  && devicep->state == GOMP_DEVICE_INITIALIZED)\n\tgomp_unload_image_from_device (devicep, version,\n\t\t\t\t       host_table, target_data);\n      gomp_mutex_unlock (&devicep->lock);\n    }\n\n  /* Remove image from array of pending images.  */\n  for (i = 0; i < num_offload_images; i++)\n    if (offload_images[i].target_data == target_data)\n      {\n\toffload_images[i] = offload_images[--num_offload_images];\n\tbreak;\n      }\n\n  gomp_mutex_unlock (&register_lock);\n}\n\nvoid\nGOMP_offload_unregister (const void *host_table, int target_type,\n\t\t\t const void *target_data)\n{\n  GOMP_offload_unregister_ver (0, host_table, target_type, target_data);\n}\n\n/* This function initializes the target device, specified by DEVICEP.  DEVICEP\n   must be locked on entry, and remains locked on return.  */\n\nattribute_hidden void\ngomp_init_device (struct gomp_device_descr *devicep)\n{\n  int i;\n  if (!devicep->init_device_func (devicep->target_id))\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      gomp_fatal (\"device initialization failed\");\n    }\n\n  /* Load to device all images registered by the moment.  */\n  for (i = 0; i < num_offload_images; i++)\n    {\n      struct offload_image_descr *image = &offload_images[i];\n      if (image->type == devicep->type)\n\tgomp_load_image_to_device (devicep, image->version,\n\t\t\t\t   image->host_table, image->target_data,\n\t\t\t\t   false);\n    }\n\n  devicep->state = GOMP_DEVICE_INITIALIZED;\n}\n\nattribute_hidden void\ngomp_unload_device (struct gomp_device_descr *devicep)\n{\n  if (devicep->state == GOMP_DEVICE_INITIALIZED)\n    {\n      unsigned i;\n      \n      /* Unload from device all images registered at the moment.  */\n      for (i = 0; i < num_offload_images; i++)\n\t{\n\t  struct offload_image_descr *image = &offload_images[i];\n\t  if (image->type == devicep->type)\n\t    gomp_unload_image_from_device (devicep, image->version,\n\t\t\t\t\t   image->host_table,\n\t\t\t\t\t   image->target_data);\n\t}\n    }\n}\n\n/* Free address mapping tables.  MM must be locked on entry, and remains locked\n   on return.  */\n\nattribute_hidden void\ngomp_free_memmap (struct splay_tree_s *mem_map)\n{\n  while (mem_map->root)\n    {\n      struct target_mem_desc *tgt = mem_map->root->key.tgt;\n\n      splay_tree_remove (mem_map, &mem_map->root->key);\n      free (tgt->array);\n      free (tgt);\n    }\n}\n\n/* Host fallback for GOMP_target{,_ext} routines.  */\n\nstatic void\ngomp_target_fallback (void (*fn) (void *), void **hostaddrs)\n{\n  struct gomp_thread old_thr, *thr = gomp_thread ();\n  old_thr = *thr;\n  memset (thr, '\\0', sizeof (*thr));\n  if (gomp_places_list)\n    {\n      thr->place = old_thr.place;\n      thr->ts.place_partition_len = gomp_places_list_len;\n    }\n  fn (hostaddrs);\n  gomp_free_thread (thr);\n  *thr = old_thr;\n}\n\n/* Calculate alignment and size requirements of a private copy of data shared\n   as GOMP_MAP_FIRSTPRIVATE and store them to TGT_ALIGN and TGT_SIZE.  */\n\nstatic inline void\ncalculate_firstprivate_requirements (size_t mapnum, size_t *sizes,\n\t\t\t\t     unsigned short *kinds, size_t *tgt_align,\n\t\t\t\t     size_t *tgt_size)\n{\n  size_t i;\n  for (i = 0; i < mapnum; i++)\n    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n      {\n\tsize_t align = (size_t) 1 << (kinds[i] >> 8);\n\tif (*tgt_align < align)\n\t  *tgt_align = align;\n\t*tgt_size = (*tgt_size + align - 1) & ~(align - 1);\n\t*tgt_size += sizes[i];\n      }\n}\n\n/* Copy data shared as GOMP_MAP_FIRSTPRIVATE to DST.  */\n\nstatic inline void\ncopy_firstprivate_data (char *tgt, size_t mapnum, void **hostaddrs,\n\t\t\tsize_t *sizes, unsigned short *kinds, size_t tgt_align,\n\t\t\tsize_t tgt_size)\n{\n  uintptr_t al = (uintptr_t) tgt & (tgt_align - 1);\n  if (al)\n    tgt += tgt_align - al;\n  tgt_size = 0;\n  size_t i;\n  for (i = 0; i < mapnum; i++)\n    if ((kinds[i] & 0xff) == GOMP_MAP_FIRSTPRIVATE)\n      {\n\tsize_t align = (size_t) 1 << (kinds[i] >> 8);\n\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n\tmemcpy (tgt + tgt_size, hostaddrs[i], sizes[i]);\n\thostaddrs[i] = tgt + tgt_size;\n\ttgt_size = tgt_size + sizes[i];\n      }\n}\n\n/* Helper function of GOMP_target{,_ext} routines.  */\n\nstatic void *\ngomp_get_target_fn_addr (struct gomp_device_descr *devicep,\n\t\t\t void (*host_fn) (void *))\n{\n  if (devicep->capabilities & GOMP_OFFLOAD_CAP_NATIVE_EXEC)\n    return (void *) host_fn;\n  else\n    {\n      gomp_mutex_lock (&devicep->lock);\n      if (devicep->state == GOMP_DEVICE_FINALIZED)\n\t{\n\t  gomp_mutex_unlock (&devicep->lock);\n\t  return NULL;\n\t}\n\n      struct splay_tree_key_s k;\n      k.host_start = (uintptr_t) host_fn;\n      k.host_end = k.host_start + 1;\n      splay_tree_key tgt_fn = splay_tree_lookup (&devicep->mem_map, &k);\n      gomp_mutex_unlock (&devicep->lock);\n      if (tgt_fn == NULL)\n\treturn NULL;\n\n      return (void *) tgt_fn->tgt_offset;\n    }\n}\n\n/* Called when encountering a target directive.  If DEVICE\n   is GOMP_DEVICE_ICV, it means use device-var ICV.  If it is\n   GOMP_DEVICE_HOST_FALLBACK (or any value\n   larger than last available hw device), use host fallback.\n   FN is address of host code, UNUSED is part of the current ABI, but\n   we're not actually using it.  HOSTADDRS, SIZES and KINDS are arrays\n   with MAPNUM entries, with addresses of the host objects,\n   sizes of the host objects (resp. for pointer kind pointer bias\n   and assumed sizeof (void *) size) and kinds.  */\n\nvoid\nGOMP_target (int device, void (*fn) (void *), const void *unused,\n\t     size_t mapnum, void **hostaddrs, size_t *sizes,\n\t     unsigned char *kinds)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  void *fn_addr;\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      /* All shared memory devices should use the GOMP_target_ext function.  */\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM\n      || !(fn_addr = gomp_get_target_fn_addr (devicep, fn)))\n    return gomp_target_fallback (fn, hostaddrs);\n\n  struct target_mem_desc *tgt_vars\n    = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n\t\t     GOMP_MAP_VARS_TARGET);\n  devicep->run_func (devicep->target_id, fn_addr, (void *) tgt_vars->tgt_start,\n\t\t     NULL);\n  gomp_unmap_vars (tgt_vars, true);\n}\n\n/* Like GOMP_target, but KINDS is 16-bit, UNUSED is no longer present,\n   and several arguments have been added:\n   FLAGS is a bitmask, see GOMP_TARGET_FLAG_* in gomp-constants.h.\n   DEPEND is array of dependencies, see GOMP_task for details.\n\n   ARGS is a pointer to an array consisting of a variable number of both\n   device-independent and device-specific arguments, which can take one two\n   elements where the first specifies for which device it is intended, the type\n   and optionally also the value.  If the value is not present in the first\n   one, the whole second element the actual value.  The last element of the\n   array is a single NULL.  Among the device independent can be for example\n   NUM_TEAMS and THREAD_LIMIT.\n\n   NUM_TEAMS is positive if GOMP_teams will be called in the body with\n   that value, or 1 if teams construct is not present, or 0, if\n   teams construct does not have num_teams clause and so the choice is\n   implementation defined, and -1 if it can't be determined on the host\n   what value will GOMP_teams have on the device.\n   THREAD_LIMIT similarly is positive if GOMP_teams will be called in the\n   body with that value, or 0, if teams construct does not have thread_limit\n   clause or the teams construct is not present, or -1 if it can't be\n   determined on the host what value will GOMP_teams have on the device.  */\n\nvoid\nGOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n\t\t void **hostaddrs, size_t *sizes, unsigned short *kinds,\n\t\t unsigned int flags, void **depend, void **args)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n  size_t tgt_align = 0, tgt_size = 0;\n  bool fpc_done = false;\n\n  if (flags & GOMP_TARGET_FLAG_NOWAIT)\n    {\n      struct gomp_thread *thr = gomp_thread ();\n      /* Create a team if we don't have any around, as nowait\n\t target tasks make sense to run asynchronously even when\n\t outside of any parallel.  */\n      if (__builtin_expect (thr->ts.team == NULL, 0))\n\t{\n\t  struct gomp_team *team = gomp_new_team (1);\n\t  struct gomp_task *task = thr->task;\n\t  struct gomp_task_icv *icv = task ? &task->icv : &gomp_global_icv;\n\t  team->prev_ts = thr->ts;\n\t  thr->ts.team = team;\n\t  thr->ts.team_id = 0;\n\t  thr->ts.work_share = &team->work_shares[0];\n\t  thr->ts.last_work_share = NULL;\n#ifdef HAVE_SYNC_BUILTINS\n\t  thr->ts.single_count = 0;\n#endif\n\t  thr->ts.static_trip = 0;\n\t  thr->task = &team->implicit_task[0];\n\t  gomp_init_task (thr->task, NULL, icv);\n\t  if (task)\n\t    {\n\t      thr->task = task;\n\t      gomp_end_task ();\n\t      free (task);\n\t      thr->task = &team->implicit_task[0];\n\t    }\n\t  else\n\t    pthread_setspecific (gomp_thread_destructor, thr);\n\t}\n      if (thr->ts.team\n\t  && !thr->task->final_task)\n\t{\n\t  gomp_create_target_task (devicep, fn, mapnum, hostaddrs,\n\t\t\t\t   sizes, kinds, flags, depend, args,\n\t\t\t\t   GOMP_TARGET_TASK_BEFORE_MAP);\n\t  return;\n\t}\n    }\n\n  /* If there are depend clauses, but nowait is not present\n     (or we are in a final task), block the parent task until the\n     dependencies are resolved and then just continue with the rest\n     of the function as if it is a merged task.  */\n  if (depend != NULL)\n    {\n      struct gomp_thread *thr = gomp_thread ();\n      if (thr->task && thr->task->depend_hash)\n\t{\n\t  /* If we might need to wait, copy firstprivate now.  */\n\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n\t\t\t\t\t       &tgt_align, &tgt_size);\n\t  if (tgt_align)\n\t    {\n\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n\t\t\t\t      tgt_align, tgt_size);\n\t    }\n\t  fpc_done = true;\n\t  gomp_task_maybe_wait_for_dependencies (depend);\n\t}\n    }\n\n  void *fn_addr;\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || !(fn_addr = gomp_get_target_fn_addr (devicep, fn))\n      || (devicep->can_run_func && !devicep->can_run_func (fn_addr)))\n    {\n      if (!fpc_done)\n\t{\n\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n\t\t\t\t\t       &tgt_align, &tgt_size);\n\t  if (tgt_align)\n\t    {\n\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n\t\t\t\t      tgt_align, tgt_size);\n\t    }\n\t}\n      gomp_target_fallback (fn, hostaddrs);\n      return;\n    }\n\n  struct target_mem_desc *tgt_vars;\n  if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    {\n      if (!fpc_done)\n\t{\n\t  calculate_firstprivate_requirements (mapnum, sizes, kinds,\n\t\t\t\t\t       &tgt_align, &tgt_size);\n\t  if (tgt_align)\n\t    {\n\t      char *tgt = gomp_alloca (tgt_size + tgt_align - 1);\n\t      copy_firstprivate_data (tgt, mapnum, hostaddrs, sizes, kinds,\n\t\t\t\t      tgt_align, tgt_size);\n\t    }\n\t}\n      tgt_vars = NULL;\n    }\n  else\n    tgt_vars = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds,\n\t\t\t      true, GOMP_MAP_VARS_TARGET);\n  devicep->run_func (devicep->target_id, fn_addr,\n\t\t     tgt_vars ? (void *) tgt_vars->tgt_start : hostaddrs,\n\t\t     args);\n  if (tgt_vars)\n    gomp_unmap_vars (tgt_vars, true);\n}\n\n/* Host fallback for GOMP_target_data{,_ext} routines.  */\n\nstatic void\ngomp_target_data_fallback (void)\n{\n  struct gomp_task_icv *icv = gomp_icv (false);\n  if (icv->target_data)\n    {\n      /* Even when doing a host fallback, if there are any active\n         #pragma omp target data constructs, need to remember the\n         new #pragma omp target data, otherwise GOMP_target_end_data\n         would get out of sync.  */\n      struct target_mem_desc *tgt\n\t= gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, false,\n\t\t\t GOMP_MAP_VARS_DATA);\n      tgt->prev = icv->target_data;\n      icv->target_data = tgt;\n    }\n}\n\nvoid\nGOMP_target_data (int device, const void *unused, size_t mapnum,\n\t\t  void **hostaddrs, size_t *sizes, unsigned char *kinds)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM))\n    return gomp_target_data_fallback ();\n\n  struct target_mem_desc *tgt\n    = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n\t\t     GOMP_MAP_VARS_DATA);\n  struct gomp_task_icv *icv = gomp_icv (true);\n  tgt->prev = icv->target_data;\n  icv->target_data = tgt;\n}\n\nvoid\nGOMP_target_data_ext (int device, size_t mapnum, void **hostaddrs,\n\t\t      size_t *sizes, unsigned short *kinds)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return gomp_target_data_fallback ();\n\n  struct target_mem_desc *tgt\n    = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, true,\n\t\t     GOMP_MAP_VARS_DATA);\n  struct gomp_task_icv *icv = gomp_icv (true);\n  tgt->prev = icv->target_data;\n  icv->target_data = tgt;\n}\n\nvoid\nGOMP_target_end_data (void)\n{\n  struct gomp_task_icv *icv = gomp_icv (false);\n  if (icv->target_data)\n    {\n      struct target_mem_desc *tgt = icv->target_data;\n      icv->target_data = tgt->prev;\n      gomp_unmap_vars (tgt, true);\n    }\n}\n\nvoid\nGOMP_target_update (int device, const void *unused, size_t mapnum,\n\t\t    void **hostaddrs, size_t *sizes, unsigned char *kinds)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return;\n\n  gomp_update (devicep, mapnum, hostaddrs, sizes, kinds, false);\n}\n\nvoid\nGOMP_target_update_ext (int device, size_t mapnum, void **hostaddrs,\n\t\t\tsize_t *sizes, unsigned short *kinds,\n\t\t\tunsigned int flags, void **depend)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  /* If there are depend clauses, but nowait is not present,\n     block the parent task until the dependencies are resolved\n     and then just continue with the rest of the function as if it\n     is a merged task.  Until we are able to schedule task during\n     variable mapping or unmapping, ignore nowait if depend clauses\n     are not present.  */\n  if (depend != NULL)\n    {\n      struct gomp_thread *thr = gomp_thread ();\n      if (thr->task && thr->task->depend_hash)\n\t{\n\t  if ((flags & GOMP_TARGET_FLAG_NOWAIT)\n\t      && thr->ts.team\n\t      && !thr->task->final_task)\n\t    {\n\t      if (gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n\t\t\t\t\t   mapnum, hostaddrs, sizes, kinds,\n\t\t\t\t\t   flags | GOMP_TARGET_FLAG_UPDATE,\n\t\t\t\t\t   depend, NULL, GOMP_TARGET_TASK_DATA))\n\t\treturn;\n\t    }\n\t  else\n\t    {\n\t      struct gomp_team *team = thr->ts.team;\n\t      /* If parallel or taskgroup has been cancelled, don't start new\n\t\t tasks.  */\n\t      if (team\n\t\t  && (gomp_team_barrier_cancelled (&team->barrier)\n\t\t      || (thr->task->taskgroup\n\t\t\t  && thr->task->taskgroup->cancelled)))\n\t\treturn;\n\n\t      gomp_task_maybe_wait_for_dependencies (depend);\n\t    }\n\t}\n    }\n\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return;\n\n  struct gomp_thread *thr = gomp_thread ();\n  struct gomp_team *team = thr->ts.team;\n  /* If parallel or taskgroup has been cancelled, don't start new tasks.  */\n  if (team\n      && (gomp_team_barrier_cancelled (&team->barrier)\n\t  || (thr->task->taskgroup && thr->task->taskgroup->cancelled)))\n    return;\n\n  gomp_update (devicep, mapnum, hostaddrs, sizes, kinds, true);\n}\n\nstatic void\ngomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n\t\tvoid **hostaddrs, size_t *sizes, unsigned short *kinds)\n{\n  const int typemask = 0xff;\n  size_t i;\n  gomp_mutex_lock (&devicep->lock);\n  if (devicep->state == GOMP_DEVICE_FINALIZED)\n    {\n      gomp_mutex_unlock (&devicep->lock);\n      return;\n    }\n\n  for (i = 0; i < mapnum; i++)\n    {\n      struct splay_tree_key_s cur_node;\n      unsigned char kind = kinds[i] & typemask;\n      switch (kind)\n\t{\n\tcase GOMP_MAP_FROM:\n\tcase GOMP_MAP_ALWAYS_FROM:\n\tcase GOMP_MAP_DELETE:\n\tcase GOMP_MAP_RELEASE:\n\tcase GOMP_MAP_ZERO_LEN_ARRAY_SECTION:\n\tcase GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION:\n\t  cur_node.host_start = (uintptr_t) hostaddrs[i];\n\t  cur_node.host_end = cur_node.host_start + sizes[i];\n\t  splay_tree_key k = (kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n\t\t\t      || kind == GOMP_MAP_ZERO_LEN_ARRAY_SECTION)\n\t    ? gomp_map_0len_lookup (&devicep->mem_map, &cur_node)\n\t    : splay_tree_lookup (&devicep->mem_map, &cur_node);\n\t  if (!k)\n\t    continue;\n\n\t  if (k->refcount > 0 && k->refcount != REFCOUNT_INFINITY)\n\t    k->refcount--;\n\t  if ((kind == GOMP_MAP_DELETE\n\t       || kind == GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION)\n\t      && k->refcount != REFCOUNT_INFINITY)\n\t    k->refcount = 0;\n\n\t  if ((kind == GOMP_MAP_FROM && k->refcount == 0)\n\t      || kind == GOMP_MAP_ALWAYS_FROM)\n\t    gomp_copy_dev2host (devicep, (void *) cur_node.host_start,\n\t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n\t\t\t\t\t  + cur_node.host_start\n\t\t\t\t\t  - k->host_start),\n\t\t\t\tcur_node.host_end - cur_node.host_start);\n\t  if (k->refcount == 0)\n\t    {\n\t      splay_tree_remove (&devicep->mem_map, k);\n\t      if (k->link_key)\n\t\tsplay_tree_insert (&devicep->mem_map,\n\t\t\t\t   (splay_tree_node) k->link_key);\n\t      if (k->tgt->refcount > 1)\n\t\tk->tgt->refcount--;\n\t      else\n\t\tgomp_unmap_tgt (k->tgt);\n\t    }\n\n\t  break;\n\tdefault:\n\t  gomp_mutex_unlock (&devicep->lock);\n\t  gomp_fatal (\"GOMP_target_enter_exit_data unhandled kind 0x%.2x\",\n\t\t      kind);\n\t}\n    }\n\n  gomp_mutex_unlock (&devicep->lock);\n}\n\nvoid\nGOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n\t\t\t     size_t *sizes, unsigned short *kinds,\n\t\t\t     unsigned int flags, void **depend)\n{\n  struct gomp_device_descr *devicep = resolve_device (device);\n\n  /* If there are depend clauses, but nowait is not present,\n     block the parent task until the dependencies are resolved\n     and then just continue with the rest of the function as if it\n     is a merged task.  Until we are able to schedule task during\n     variable mapping or unmapping, ignore nowait if depend clauses\n     are not present.  */\n  if (depend != NULL)\n    {\n      struct gomp_thread *thr = gomp_thread ();\n      if (thr->task && thr->task->depend_hash)\n\t{\n\t  if ((flags & GOMP_TARGET_FLAG_NOWAIT)\n\t      && thr->ts.team\n\t      && !thr->task->final_task)\n\t    {\n\t      if (gomp_create_target_task (devicep, (void (*) (void *)) NULL,\n\t\t\t\t\t   mapnum, hostaddrs, sizes, kinds,\n\t\t\t\t\t   flags, depend, NULL,\n\t\t\t\t\t   GOMP_TARGET_TASK_DATA))\n\t\treturn;\n\t    }\n\t  else\n\t    {\n\t      struct gomp_team *team = thr->ts.team;\n\t      /* If parallel or taskgroup has been cancelled, don't start new\n\t\t tasks.  */\n\t      if (team\n\t\t  && (gomp_team_barrier_cancelled (&team->barrier)\n\t\t      || (thr->task->taskgroup\n\t\t\t  && thr->task->taskgroup->cancelled)))\n\t\treturn;\n\n\t      gomp_task_maybe_wait_for_dependencies (depend);\n\t    }\n\t}\n    }\n\n  if (devicep == NULL\n      || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return;\n\n  struct gomp_thread *thr = gomp_thread ();\n  struct gomp_team *team = thr->ts.team;\n  /* If parallel or taskgroup has been cancelled, don't start new tasks.  */\n  if (team\n      && (gomp_team_barrier_cancelled (&team->barrier)\n\t  || (thr->task->taskgroup && thr->task->taskgroup->cancelled)))\n    return;\n\n  size_t i;\n  if ((flags & GOMP_TARGET_FLAG_EXIT_DATA) == 0)\n    for (i = 0; i < mapnum; i++)\n      if ((kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n\t{\n\t  gomp_map_vars (devicep, sizes[i] + 1, &hostaddrs[i], NULL, &sizes[i],\n\t\t\t &kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n\t  i += sizes[i];\n\t}\n      else\n\tgomp_map_vars (devicep, 1, &hostaddrs[i], NULL, &sizes[i], &kinds[i],\n\t\t       true, GOMP_MAP_VARS_ENTER_DATA);\n  else\n    gomp_exit_data (devicep, mapnum, hostaddrs, sizes, kinds);\n}\n\nbool\ngomp_target_task_fn (void *data)\n{\n  struct gomp_target_task *ttask = (struct gomp_target_task *) data;\n  struct gomp_device_descr *devicep = ttask->devicep;\n\n  if (ttask->fn != NULL)\n    {\n      void *fn_addr;\n      if (devicep == NULL\n\t  || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t  || !(fn_addr = gomp_get_target_fn_addr (devicep, ttask->fn))\n\t  || (devicep->can_run_func && !devicep->can_run_func (fn_addr)))\n\t{\n\t  ttask->state = GOMP_TARGET_TASK_FALLBACK;\n\t  gomp_target_fallback (ttask->fn, ttask->hostaddrs);\n\t  return false;\n\t}\n\n      if (ttask->state == GOMP_TARGET_TASK_FINISHED)\n\t{\n\t  if (ttask->tgt)\n\t    gomp_unmap_vars (ttask->tgt, true);\n\t  return false;\n\t}\n\n      void *actual_arguments;\n      if (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n\t{\n\t  ttask->tgt = NULL;\n\t  actual_arguments = ttask->hostaddrs;\n\t}\n      else\n\t{\n\t  ttask->tgt = gomp_map_vars (devicep, ttask->mapnum, ttask->hostaddrs,\n\t\t\t\t      NULL, ttask->sizes, ttask->kinds, true,\n\t\t\t\t      GOMP_MAP_VARS_TARGET);\n\t  actual_arguments = (void *) ttask->tgt->tgt_start;\n\t}\n      ttask->state = GOMP_TARGET_TASK_READY_TO_RUN;\n\n      devicep->async_run_func (devicep->target_id, fn_addr, actual_arguments,\n\t\t\t       ttask->args, (void *) ttask);\n      return true;\n    }\n  else if (devicep == NULL\n\t   || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t   || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return false;\n\n  size_t i;\n  if (ttask->flags & GOMP_TARGET_FLAG_UPDATE)\n    gomp_update (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n\t\t ttask->kinds, true);\n  else if ((ttask->flags & GOMP_TARGET_FLAG_EXIT_DATA) == 0)\n    for (i = 0; i < ttask->mapnum; i++)\n      if ((ttask->kinds[i] & 0xff) == GOMP_MAP_STRUCT)\n\t{\n\t  gomp_map_vars (devicep, ttask->sizes[i] + 1, &ttask->hostaddrs[i],\n\t\t\t NULL, &ttask->sizes[i], &ttask->kinds[i], true,\n\t\t\t GOMP_MAP_VARS_ENTER_DATA);\n\t  i += ttask->sizes[i];\n\t}\n      else\n\tgomp_map_vars (devicep, 1, &ttask->hostaddrs[i], NULL, &ttask->sizes[i],\n\t\t       &ttask->kinds[i], true, GOMP_MAP_VARS_ENTER_DATA);\n  else\n    gomp_exit_data (devicep, ttask->mapnum, ttask->hostaddrs, ttask->sizes,\n\t\t    ttask->kinds);\n  return false;\n}\n\nvoid\nGOMP_teams (unsigned int num_teams, unsigned int thread_limit)\n{\n  if (thread_limit)\n    {\n      struct gomp_task_icv *icv = gomp_icv (true);\n      icv->thread_limit_var\n\t= thread_limit > INT_MAX ? UINT_MAX : thread_limit;\n    }\n  (void) num_teams;\n}\n\nvoid *\nomp_target_alloc (size_t size, int device_num)\n{\n  if (device_num == GOMP_DEVICE_HOST_FALLBACK)\n    return malloc (size);\n\n  if (device_num < 0)\n    return NULL;\n\n  struct gomp_device_descr *devicep = resolve_device (device_num);\n  if (devicep == NULL)\n    return NULL;\n\n  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return malloc (size);\n\n  gomp_mutex_lock (&devicep->lock);\n  void *ret = devicep->alloc_func (devicep->target_id, size);\n  gomp_mutex_unlock (&devicep->lock);\n  return ret;\n}\n\nvoid\nomp_target_free (void *device_ptr, int device_num)\n{\n  if (device_ptr == NULL)\n    return;\n\n  if (device_num == GOMP_DEVICE_HOST_FALLBACK)\n    {\n      free (device_ptr);\n      return;\n    }\n\n  if (device_num < 0)\n    return;\n\n  struct gomp_device_descr *devicep = resolve_device (device_num);\n  if (devicep == NULL)\n    return;\n\n  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    {\n      free (device_ptr);\n      return;\n    }\n\n  gomp_mutex_lock (&devicep->lock);\n  gomp_free_device_memory (devicep, device_ptr);\n  gomp_mutex_unlock (&devicep->lock);\n}\n\nint\nomp_target_is_present (void *ptr, int device_num)\n{\n  if (ptr == NULL)\n    return 1;\n\n  if (device_num == GOMP_DEVICE_HOST_FALLBACK)\n    return 1;\n\n  if (device_num < 0)\n    return 0;\n\n  struct gomp_device_descr *devicep = resolve_device (device_num);\n  if (devicep == NULL)\n    return 0;\n\n  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return 1;\n\n  gomp_mutex_lock (&devicep->lock);\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n\n  cur_node.host_start = (uintptr_t) ptr;\n  cur_node.host_end = cur_node.host_start;\n  splay_tree_key n = gomp_map_0len_lookup (mem_map, &cur_node);\n  int ret = n != NULL;\n  gomp_mutex_unlock (&devicep->lock);\n  return ret;\n}\n\nint\nomp_target_memcpy (void *dst, void *src, size_t length, size_t dst_offset,\n\t\t   size_t src_offset, int dst_device_num, int src_device_num)\n{\n  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n  bool ret;\n\n  if (dst_device_num != GOMP_DEVICE_HOST_FALLBACK)\n    {\n      if (dst_device_num < 0)\n\treturn EINVAL;\n\n      dst_devicep = resolve_device (dst_device_num);\n      if (dst_devicep == NULL)\n\treturn EINVAL;\n\n      if (!(dst_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t  || dst_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n\tdst_devicep = NULL;\n    }\n  if (src_device_num != GOMP_DEVICE_HOST_FALLBACK)\n    {\n      if (src_device_num < 0)\n\treturn EINVAL;\n\n      src_devicep = resolve_device (src_device_num);\n      if (src_devicep == NULL)\n\treturn EINVAL;\n\n      if (!(src_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t  || src_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n\tsrc_devicep = NULL;\n    }\n  if (src_devicep == NULL && dst_devicep == NULL)\n    {\n      memcpy ((char *) dst + dst_offset, (char *) src + src_offset, length);\n      return 0;\n    }\n  if (src_devicep == NULL)\n    {\n      gomp_mutex_lock (&dst_devicep->lock);\n      ret = dst_devicep->host2dev_func (dst_devicep->target_id,\n\t\t\t\t\t(char *) dst + dst_offset,\n\t\t\t\t\t(char *) src + src_offset, length);\n      gomp_mutex_unlock (&dst_devicep->lock);\n      return (ret ? 0 : EINVAL);\n    }\n  if (dst_devicep == NULL)\n    {\n      gomp_mutex_lock (&src_devicep->lock);\n      ret = src_devicep->dev2host_func (src_devicep->target_id,\n\t\t\t\t\t(char *) dst + dst_offset,\n\t\t\t\t\t(char *) src + src_offset, length);\n      gomp_mutex_unlock (&src_devicep->lock);\n      return (ret ? 0 : EINVAL);\n    }\n  if (src_devicep == dst_devicep)\n    {\n      gomp_mutex_lock (&src_devicep->lock);\n      ret = src_devicep->dev2dev_func (src_devicep->target_id,\n\t\t\t\t       (char *) dst + dst_offset,\n\t\t\t\t       (char *) src + src_offset, length);\n      gomp_mutex_unlock (&src_devicep->lock);\n      return (ret ? 0 : EINVAL);\n    }\n  return EINVAL;\n}\n\nstatic int\nomp_target_memcpy_rect_worker (void *dst, void *src, size_t element_size,\n\t\t\t       int num_dims, const size_t *volume,\n\t\t\t       const size_t *dst_offsets,\n\t\t\t       const size_t *src_offsets,\n\t\t\t       const size_t *dst_dimensions,\n\t\t\t       const size_t *src_dimensions,\n\t\t\t       struct gomp_device_descr *dst_devicep,\n\t\t\t       struct gomp_device_descr *src_devicep)\n{\n  size_t dst_slice = element_size;\n  size_t src_slice = element_size;\n  size_t j, dst_off, src_off, length;\n  int i, ret;\n\n  if (num_dims == 1)\n    {\n      if (__builtin_mul_overflow (element_size, volume[0], &length)\n\t  || __builtin_mul_overflow (element_size, dst_offsets[0], &dst_off)\n\t  || __builtin_mul_overflow (element_size, src_offsets[0], &src_off))\n\treturn EINVAL;\n      if (dst_devicep == NULL && src_devicep == NULL)\n\t{\n\t  memcpy ((char *) dst + dst_off, (char *) src + src_off, length);\n\t  ret = 1;\n\t}\n      else if (src_devicep == NULL)\n\tret = dst_devicep->host2dev_func (dst_devicep->target_id,\n\t\t\t\t\t  (char *) dst + dst_off,\n\t\t\t\t\t  (char *) src + src_off, length);\n      else if (dst_devicep == NULL)\n\tret = src_devicep->dev2host_func (src_devicep->target_id,\n\t\t\t\t\t  (char *) dst + dst_off,\n\t\t\t\t\t  (char *) src + src_off, length);\n      else if (src_devicep == dst_devicep)\n\tret = src_devicep->dev2dev_func (src_devicep->target_id,\n\t\t\t\t\t (char *) dst + dst_off,\n\t\t\t\t\t (char *) src + src_off, length);\n      else\n\tret = 0;\n      return ret ? 0 : EINVAL;\n    }\n\n  /* FIXME: it would be nice to have some plugin function to handle\n     num_dims == 2 and num_dims == 3 more efficiently.  Larger ones can\n     be handled in the generic recursion below, and for host-host it\n     should be used even for any num_dims >= 2.  */\n\n  for (i = 1; i < num_dims; i++)\n    if (__builtin_mul_overflow (dst_slice, dst_dimensions[i], &dst_slice)\n\t|| __builtin_mul_overflow (src_slice, src_dimensions[i], &src_slice))\n      return EINVAL;\n  if (__builtin_mul_overflow (dst_slice, dst_offsets[0], &dst_off)\n      || __builtin_mul_overflow (src_slice, src_offsets[0], &src_off))\n    return EINVAL;\n  for (j = 0; j < volume[0]; j++)\n    {\n      ret = omp_target_memcpy_rect_worker ((char *) dst + dst_off,\n\t\t\t\t\t   (char *) src + src_off,\n\t\t\t\t\t   element_size, num_dims - 1,\n\t\t\t\t\t   volume + 1, dst_offsets + 1,\n\t\t\t\t\t   src_offsets + 1, dst_dimensions + 1,\n\t\t\t\t\t   src_dimensions + 1, dst_devicep,\n\t\t\t\t\t   src_devicep);\n      if (ret)\n\treturn ret;\n      dst_off += dst_slice;\n      src_off += src_slice;\n    }\n  return 0;\n}\n\nint\nomp_target_memcpy_rect (void *dst, void *src, size_t element_size,\n\t\t\tint num_dims, const size_t *volume,\n\t\t\tconst size_t *dst_offsets,\n\t\t\tconst size_t *src_offsets,\n\t\t\tconst size_t *dst_dimensions,\n\t\t\tconst size_t *src_dimensions,\n\t\t\tint dst_device_num, int src_device_num)\n{\n  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n\n  if (!dst && !src)\n    return INT_MAX;\n\n  if (dst_device_num != GOMP_DEVICE_HOST_FALLBACK)\n    {\n      if (dst_device_num < 0)\n\treturn EINVAL;\n\n      dst_devicep = resolve_device (dst_device_num);\n      if (dst_devicep == NULL)\n\treturn EINVAL;\n\n      if (!(dst_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t  || dst_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n\tdst_devicep = NULL;\n    }\n  if (src_device_num != GOMP_DEVICE_HOST_FALLBACK)\n    {\n      if (src_device_num < 0)\n\treturn EINVAL;\n\n      src_devicep = resolve_device (src_device_num);\n      if (src_devicep == NULL)\n\treturn EINVAL;\n\n      if (!(src_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n\t  || src_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n\tsrc_devicep = NULL;\n    }\n\n  if (src_devicep != NULL && dst_devicep != NULL && src_devicep != dst_devicep)\n    return EINVAL;\n\n  if (src_devicep)\n    gomp_mutex_lock (&src_devicep->lock);\n  else if (dst_devicep)\n    gomp_mutex_lock (&dst_devicep->lock);\n  int ret = omp_target_memcpy_rect_worker (dst, src, element_size, num_dims,\n\t\t\t\t\t   volume, dst_offsets, src_offsets,\n\t\t\t\t\t   dst_dimensions, src_dimensions,\n\t\t\t\t\t   dst_devicep, src_devicep);\n  if (src_devicep)\n    gomp_mutex_unlock (&src_devicep->lock);\n  else if (dst_devicep)\n    gomp_mutex_unlock (&dst_devicep->lock);\n  return ret;\n}\n\nint\nomp_target_associate_ptr (void *host_ptr, void *device_ptr, size_t size,\n\t\t\t  size_t device_offset, int device_num)\n{\n  if (device_num == GOMP_DEVICE_HOST_FALLBACK)\n    return EINVAL;\n\n  if (device_num < 0)\n    return EINVAL;\n\n  struct gomp_device_descr *devicep = resolve_device (device_num);\n  if (devicep == NULL)\n    return EINVAL;\n\n  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n    return EINVAL;\n\n  gomp_mutex_lock (&devicep->lock);\n\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n  int ret = EINVAL;\n\n  cur_node.host_start = (uintptr_t) host_ptr;\n  cur_node.host_end = cur_node.host_start + size;\n  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n  if (n)\n    {\n      if (n->tgt->tgt_start + n->tgt_offset\n\t  == (uintptr_t) device_ptr + device_offset\n\t  && n->host_start <= cur_node.host_start\n\t  && n->host_end >= cur_node.host_end)\n\tret = 0;\n    }\n  else\n    {\n      struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n      tgt->array = gomp_malloc (sizeof (*tgt->array));\n      tgt->refcount = 1;\n      tgt->tgt_start = 0;\n      tgt->tgt_end = 0;\n      tgt->to_free = NULL;\n      tgt->prev = NULL;\n      tgt->list_count = 0;\n      tgt->device_descr = devicep;\n      splay_tree_node array = tgt->array;\n      splay_tree_key k = &array->key;\n      k->host_start = cur_node.host_start;\n      k->host_end = cur_node.host_end;\n      k->tgt = tgt;\n      k->tgt_offset = (uintptr_t) device_ptr + device_offset;\n      k->refcount = REFCOUNT_INFINITY;\n      array->left = NULL;\n      array->right = NULL;\n      splay_tree_insert (&devicep->mem_map, array);\n      ret = 0;\n    }\n  gomp_mutex_unlock (&devicep->lock);\n  return ret;\n}\n\nint\nomp_target_disassociate_ptr (void *ptr, int device_num)\n{\n  if (device_num == GOMP_DEVICE_HOST_FALLBACK)\n    return EINVAL;\n\n  if (device_num < 0)\n    return EINVAL;\n\n  struct gomp_device_descr *devicep = resolve_device (device_num);\n  if (devicep == NULL)\n    return EINVAL;\n\n  if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n    return EINVAL;\n\n  gomp_mutex_lock (&devicep->lock);\n\n  struct splay_tree_s *mem_map = &devicep->mem_map;\n  struct splay_tree_key_s cur_node;\n  int ret = EINVAL;\n\n  cur_node.host_start = (uintptr_t) ptr;\n  cur_node.host_end = cur_node.host_start;\n  splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n  if (n\n      && n->host_start == cur_node.host_start\n      && n->refcount == REFCOUNT_INFINITY\n      && n->tgt->tgt_start == 0\n      && n->tgt->to_free == NULL\n      && n->tgt->refcount == 1\n      && n->tgt->list_count == 0)\n    {\n      splay_tree_remove (&devicep->mem_map, n);\n      gomp_unmap_tgt (n->tgt);\n      ret = 0;\n    }\n\n  gomp_mutex_unlock (&devicep->lock);\n  return ret;\n}\n\n#ifdef PLUGIN_SUPPORT\n\n/* This function tries to load a plugin for DEVICE.  Name of plugin is passed\n   in PLUGIN_NAME.\n   The handles of the found functions are stored in the corresponding fields\n   of DEVICE.  The function returns TRUE on success and FALSE otherwise.  */\n\nstatic bool\ngomp_load_plugin_for_device (struct gomp_device_descr *device,\n\t\t\t     const char *plugin_name)\n{\n  const char *err = NULL, *last_missing = NULL;\n\n  void *plugin_handle = dlopen (plugin_name, RTLD_LAZY);\n  if (!plugin_handle)\n    goto dl_fail;\n\n  /* Check if all required functions are available in the plugin and store\n     their handlers.  None of the symbols can legitimately be NULL,\n     so we don't need to check dlerror all the time.  */\n#define DLSYM(f)\t\t\t\t\t\t\t\\\n  if (!(device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #f)))\t\\\n    goto dl_fail\n  /* Similar, but missing functions are not an error.  Return false if\n     failed, true otherwise.  */\n#define DLSYM_OPT(f, n)\t\t\t\t\t\t\t\\\n  ((device->f##_func = dlsym (plugin_handle, \"GOMP_OFFLOAD_\" #n))\t\\\n   || (last_missing = #n, 0))\n\n  DLSYM (version);\n  if (device->version_func () != GOMP_VERSION)\n    {\n      err = \"plugin version mismatch\";\n      goto fail;\n    }\n\n  DLSYM (get_name);\n  DLSYM (get_caps);\n  DLSYM (get_type);\n  DLSYM (get_num_devices);\n  DLSYM (init_device);\n  DLSYM (fini_device);\n  DLSYM (load_image);\n  DLSYM (unload_image);\n  DLSYM (alloc);\n  DLSYM (free);\n  DLSYM (dev2host);\n  DLSYM (host2dev);\n  device->capabilities = device->get_caps_func ();\n  if (device->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n    {\n      DLSYM (run);\n      DLSYM (async_run);\n      DLSYM_OPT (can_run, can_run);\n      DLSYM (dev2dev);\n    }\n  if (device->capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n    {\n      if (!DLSYM_OPT (openacc.exec, openacc_exec)\n\t  || !DLSYM_OPT (openacc.register_async_cleanup,\n\t\t\t openacc_register_async_cleanup)\n\t  || !DLSYM_OPT (openacc.async_test, openacc_async_test)\n\t  || !DLSYM_OPT (openacc.async_test_all, openacc_async_test_all)\n\t  || !DLSYM_OPT (openacc.async_wait, openacc_async_wait)\n\t  || !DLSYM_OPT (openacc.async_wait_async, openacc_async_wait_async)\n\t  || !DLSYM_OPT (openacc.async_wait_all, openacc_async_wait_all)\n\t  || !DLSYM_OPT (openacc.async_wait_all_async,\n\t\t\t openacc_async_wait_all_async)\n\t  || !DLSYM_OPT (openacc.async_set_async, openacc_async_set_async)\n\t  || !DLSYM_OPT (openacc.create_thread_data,\n\t\t\t openacc_create_thread_data)\n\t  || !DLSYM_OPT (openacc.destroy_thread_data,\n\t\t\t openacc_destroy_thread_data))\n\t{\n\t  /* Require all the OpenACC handlers if we have\n\t     GOMP_OFFLOAD_CAP_OPENACC_200.  */\n\t  err = \"plugin missing OpenACC handler function\";\n\t  goto fail;\n\t}\n\n      unsigned cuda = 0;\n      cuda += DLSYM_OPT (openacc.cuda.get_current_device,\n\t\t\t openacc_cuda_get_current_device);\n      cuda += DLSYM_OPT (openacc.cuda.get_current_context,\n\t\t\t openacc_cuda_get_current_context);\n      cuda += DLSYM_OPT (openacc.cuda.get_stream, openacc_cuda_get_stream);\n      cuda += DLSYM_OPT (openacc.cuda.set_stream, openacc_cuda_set_stream);\n      if (cuda && cuda != 4)\n\t{\n\t  /* Make sure all the CUDA functions are there if any of them are.  */\n\t  err = \"plugin missing OpenACC CUDA handler function\";\n\t  goto fail;\n\t}\n    }\n#undef DLSYM\n#undef DLSYM_OPT\n\n  return 1;\n\n dl_fail:\n  err = dlerror ();\n fail:\n  gomp_error (\"while loading %s: %s\", plugin_name, err);\n  if (last_missing)\n    gomp_error (\"missing function was %s\", last_missing);\n  if (plugin_handle)\n    dlclose (plugin_handle);\n\n  return 0;\n}\n\n/* This function finalizes all initialized devices.  */\n\nstatic void\ngomp_target_fini (void)\n{\n  int i;\n  for (i = 0; i < num_devices; i++)\n    {\n      bool ret = true;\n      struct gomp_device_descr *devicep = &devices[i];\n      gomp_mutex_lock (&devicep->lock);\n      if (devicep->state == GOMP_DEVICE_INITIALIZED)\n\t{\n\t  ret = devicep->fini_device_func (devicep->target_id);\n\t  devicep->state = GOMP_DEVICE_FINALIZED;\n\t}\n      gomp_mutex_unlock (&devicep->lock);\n      if (!ret)\n\tgomp_fatal (\"device finalization failed\");\n    }\n}\n\n/* This function initializes the runtime needed for offloading.\n   It parses the list of offload targets and tries to load the plugins for\n   these targets.  On return, the variables NUM_DEVICES and NUM_DEVICES_OPENMP\n   will be set, and the array DEVICES initialized, containing descriptors for\n   corresponding devices, first the GOMP_OFFLOAD_CAP_OPENMP_400 ones, follows\n   by the others.  */\n\nstatic void\ngomp_target_init (void)\n{\n  const char *prefix =\"libgomp-plugin-\";\n  const char *suffix = SONAME_SUFFIX (1);\n  const char *cur, *next;\n  char *plugin_name;\n  int i, new_num_devices;\n\n  num_devices = 0;\n  devices = NULL;\n\n  cur = OFFLOAD_TARGETS;\n  if (*cur)\n    do\n      {\n\tstruct gomp_device_descr current_device;\n\n\tnext = strchr (cur, ',');\n\n\tplugin_name = (char *) malloc (1 + (next ? next - cur : strlen (cur))\n\t\t\t\t       + strlen (prefix) + strlen (suffix));\n\tif (!plugin_name)\n\t  {\n\t    num_devices = 0;\n\t    break;\n\t  }\n\n\tstrcpy (plugin_name, prefix);\n\tstrncat (plugin_name, cur, next ? next - cur : strlen (cur));\n\tstrcat (plugin_name, suffix);\n\n\tif (gomp_load_plugin_for_device (&current_device, plugin_name))\n\t  {\n\t    new_num_devices = current_device.get_num_devices_func ();\n\t    if (new_num_devices >= 1)\n\t      {\n\t\t/* Augment DEVICES and NUM_DEVICES.  */\n\n\t\tdevices = realloc (devices, (num_devices + new_num_devices)\n\t\t\t\t   * sizeof (struct gomp_device_descr));\n\t\tif (!devices)\n\t\t  {\n\t\t    num_devices = 0;\n\t\t    free (plugin_name);\n\t\t    break;\n\t\t  }\n\n\t\tcurrent_device.name = current_device.get_name_func ();\n\t\t/* current_device.capabilities has already been set.  */\n\t\tcurrent_device.type = current_device.get_type_func ();\n\t\tcurrent_device.mem_map.root = NULL;\n\t\tcurrent_device.state = GOMP_DEVICE_UNINITIALIZED;\n\t\tcurrent_device.openacc.data_environ = NULL;\n\t\tfor (i = 0; i < new_num_devices; i++)\n\t\t  {\n\t\t    current_device.target_id = i;\n\t\t    devices[num_devices] = current_device;\n\t\t    gomp_mutex_init (&devices[num_devices].lock);\n\t\t    num_devices++;\n\t\t  }\n\t      }\n\t  }\n\n\tfree (plugin_name);\n\tcur = next + 1;\n      }\n    while (next);\n\n  /* In DEVICES, sort the GOMP_OFFLOAD_CAP_OPENMP_400 ones first, and set\n     NUM_DEVICES_OPENMP.  */\n  struct gomp_device_descr *devices_s\n    = malloc (num_devices * sizeof (struct gomp_device_descr));\n  if (!devices_s)\n    {\n      num_devices = 0;\n      free (devices);\n      devices = NULL;\n    }\n  num_devices_openmp = 0;\n  for (i = 0; i < num_devices; i++)\n    if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n      devices_s[num_devices_openmp++] = devices[i];\n  int num_devices_after_openmp = num_devices_openmp;\n  for (i = 0; i < num_devices; i++)\n    if (!(devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENMP_400))\n      devices_s[num_devices_after_openmp++] = devices[i];\n  free (devices);\n  devices = devices_s;\n\n  for (i = 0; i < num_devices; i++)\n    {\n      /* The 'devices' array can be moved (by the realloc call) until we have\n\t found all the plugins, so registering with the OpenACC runtime (which\n\t takes a copy of the pointer argument) must be delayed until now.  */\n      if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n\tgoacc_register (&devices[i]);\n    }\n\n  if (atexit (gomp_target_fini) != 0)\n    gomp_fatal (\"atexit failed\");\n}\n\n#else /* PLUGIN_SUPPORT */\n/* If dlfcn.h is unavailable we always fallback to host execution.\n   GOMP_target* routines are just stubs for this case.  */\nstatic void\ngomp_target_init (void)\n{\n}\n#endif /* PLUGIN_SUPPORT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgomp/plugin/plugin-hsa.c": "/* Plugin for HSAIL execution.\n\n   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n\n   Contributed by Martin Jambor <mjambor@suse.cz> and\n   Martin Liska <mliska@suse.cz>.\n\n   This file is part of the GNU Offloading and Multi Processing Library\n   (libgomp).\n\n   Libgomp is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n   more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <hsa.h>\n#include <plugin/hsa_ext_finalize.h>\n#include <dlfcn.h>\n#include \"libgomp-plugin.h\"\n#include \"gomp-constants.h\"\n\n/* Secure getenv() which returns NULL if running as SUID/SGID.  */\n#ifndef HAVE_SECURE_GETENV\n#ifdef HAVE___SECURE_GETENV\n#define secure_getenv __secure_getenv\n#elif defined (HAVE_UNISTD_H) && defined(HAVE_GETUID) && defined(HAVE_GETEUID) \\\n  && defined(HAVE_GETGID) && defined(HAVE_GETEGID)\n\n#include <unistd.h>\n\n/* Implementation of secure_getenv() for targets where it is not provided but\n   we have at least means to test real and effective IDs. */\n\nstatic char *\nsecure_getenv (const char *name)\n{\n  if ((getuid () == geteuid ()) && (getgid () == getegid ()))\n    return getenv (name);\n  else\n    return NULL;\n}\n\n#else\n#define secure_getenv getenv\n#endif\n#endif\n\n/* As an HSA runtime is dlopened, following structure defines function\n   pointers utilized by the HSA plug-in.  */\n\nstruct hsa_runtime_fn_info\n{\n  /* HSA runtime.  */\n  hsa_status_t (*hsa_status_string_fn) (hsa_status_t status,\n\t\t\t\t\tconst char **status_string);\n  hsa_status_t (*hsa_agent_get_info_fn) (hsa_agent_t agent,\n\t\t\t\t\t hsa_agent_info_t attribute,\n\t\t\t\t\t void *value);\n  hsa_status_t (*hsa_init_fn) (void);\n  hsa_status_t (*hsa_iterate_agents_fn)\n    (hsa_status_t (*callback)(hsa_agent_t agent, void *data), void *data);\n  hsa_status_t (*hsa_region_get_info_fn) (hsa_region_t region,\n\t\t\t\t\t  hsa_region_info_t attribute,\n\t\t\t\t\t  void *value);\n  hsa_status_t (*hsa_queue_create_fn)\n    (hsa_agent_t agent, uint32_t size, hsa_queue_type_t type,\n     void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),\n     void *data, uint32_t private_segment_size,\n     uint32_t group_segment_size, hsa_queue_t **queue);\n  hsa_status_t (*hsa_agent_iterate_regions_fn)\n    (hsa_agent_t agent,\n     hsa_status_t (*callback)(hsa_region_t region, void *data), void *data);\n  hsa_status_t (*hsa_executable_destroy_fn) (hsa_executable_t executable);\n  hsa_status_t (*hsa_executable_create_fn)\n    (hsa_profile_t profile, hsa_executable_state_t executable_state,\n     const char *options, hsa_executable_t *executable);\n  hsa_status_t (*hsa_executable_global_variable_define_fn)\n    (hsa_executable_t executable, const char *variable_name, void *address);\n  hsa_status_t (*hsa_executable_load_code_object_fn)\n    (hsa_executable_t executable, hsa_agent_t agent,\n     hsa_code_object_t code_object, const char *options);\n  hsa_status_t (*hsa_executable_freeze_fn)(hsa_executable_t executable,\n\t\t\t\t\t   const char *options);\n  hsa_status_t (*hsa_signal_create_fn) (hsa_signal_value_t initial_value,\n\t\t\t\t\tuint32_t num_consumers,\n\t\t\t\t\tconst hsa_agent_t *consumers,\n\t\t\t\t\thsa_signal_t *signal);\n  hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,\n\t\t\t\t\t  void **ptr);\n  hsa_status_t (*hsa_memory_free_fn) (void *ptr);\n  hsa_status_t (*hsa_signal_destroy_fn) (hsa_signal_t signal);\n  hsa_status_t (*hsa_executable_get_symbol_fn)\n    (hsa_executable_t executable, const char *module_name,\n     const char *symbol_name, hsa_agent_t agent, int32_t call_convention,\n     hsa_executable_symbol_t *symbol);\n  hsa_status_t (*hsa_executable_symbol_get_info_fn)\n    (hsa_executable_symbol_t executable_symbol,\n     hsa_executable_symbol_info_t attribute, void *value);\n  uint64_t (*hsa_queue_add_write_index_release_fn) (const hsa_queue_t *queue,\n\t\t\t\t\t\t    uint64_t value);\n  uint64_t (*hsa_queue_load_read_index_acquire_fn) (const hsa_queue_t *queue);\n  void (*hsa_signal_store_relaxed_fn) (hsa_signal_t signal,\n\t\t\t\t       hsa_signal_value_t value);\n  void (*hsa_signal_store_release_fn) (hsa_signal_t signal,\n\t\t\t\t       hsa_signal_value_t value);\n  hsa_signal_value_t (*hsa_signal_wait_acquire_fn)\n    (hsa_signal_t signal, hsa_signal_condition_t condition,\n     hsa_signal_value_t compare_value, uint64_t timeout_hint,\n     hsa_wait_state_t wait_state_hint);\n  hsa_signal_value_t (*hsa_signal_load_acquire_fn) (hsa_signal_t signal);\n  hsa_status_t (*hsa_queue_destroy_fn) (hsa_queue_t *queue);\n\n  /* HSA finalizer.  */\n  hsa_status_t (*hsa_ext_program_add_module_fn) (hsa_ext_program_t program,\n\t\t\t\t\t\t hsa_ext_module_t module);\n  hsa_status_t (*hsa_ext_program_create_fn)\n    (hsa_machine_model_t machine_model, hsa_profile_t profile,\n     hsa_default_float_rounding_mode_t default_float_rounding_mode,\n     const char *options, hsa_ext_program_t *program);\n  hsa_status_t (*hsa_ext_program_destroy_fn) (hsa_ext_program_t program);\n  hsa_status_t (*hsa_ext_program_finalize_fn)\n    (hsa_ext_program_t program,hsa_isa_t isa,\n     int32_t call_convention, hsa_ext_control_directives_t control_directives,\n     const char *options, hsa_code_object_type_t code_object_type,\n     hsa_code_object_t *code_object);\n};\n\n/* HSA runtime functions that are initialized in init_hsa_context.  */\n\nstatic struct hsa_runtime_fn_info hsa_fns;\n\n/* Keep the following GOMP prefixed structures in sync with respective parts of\n   the compiler.  */\n\n/* Structure describing the run-time and grid properties of an HSA kernel\n   lauch.  */\n\nstruct GOMP_kernel_launch_attributes\n{\n  /* Number of dimensions the workload has.  Maximum number is 3.  */\n  uint32_t ndim;\n  /* Size of the grid in the three respective dimensions.  */\n  uint32_t gdims[3];\n  /* Size of work-groups in the respective dimensions.  */\n  uint32_t wdims[3];\n};\n\n/* Collection of information needed for a dispatch of a kernel from a\n   kernel.  */\n\nstruct GOMP_hsa_kernel_dispatch\n{\n  /* Pointer to a command queue associated with a kernel dispatch agent.  */\n  void *queue;\n  /* Pointer to reserved memory for OMP data struct copying.  */\n  void *omp_data_memory;\n  /* Pointer to a memory space used for kernel arguments passing.  */\n  void *kernarg_address;\n  /* Kernel object.  */\n  uint64_t object;\n  /* Synchronization signal used for dispatch synchronization.  */\n  uint64_t signal;\n  /* Private segment size.  */\n  uint32_t private_segment_size;\n  /* Group segment size.  */\n  uint32_t group_segment_size;\n  /* Number of children kernel dispatches.  */\n  uint64_t kernel_dispatch_count;\n  /* Debug purpose argument.  */\n  uint64_t debug;\n  /* Levels-var ICV.  */\n  uint64_t omp_level;\n  /* Kernel dispatch structures created for children kernel dispatches.  */\n  struct GOMP_hsa_kernel_dispatch **children_dispatches;\n  /* Number of threads.  */\n  uint32_t omp_num_threads;\n};\n\n/* Part of the libgomp plugin interface.  Return the name of the accelerator,\n   which is \"hsa\".  */\n\nconst char *\nGOMP_OFFLOAD_get_name (void)\n{\n  return \"hsa\";\n}\n\n/* Part of the libgomp plugin interface.  Return the specific capabilities the\n   HSA accelerator have.  */\n\nunsigned int\nGOMP_OFFLOAD_get_caps (void)\n{\n  return GOMP_OFFLOAD_CAP_SHARED_MEM | GOMP_OFFLOAD_CAP_OPENMP_400;\n}\n\n/* Part of the libgomp plugin interface.  Identify as HSA accelerator.  */\n\nint\nGOMP_OFFLOAD_get_type (void)\n{\n  return OFFLOAD_TARGET_TYPE_HSA;\n}\n\n/* Return the libgomp version number we're compatible with.  There is\n   no requirement for cross-version compatibility.  */\n\nunsigned\nGOMP_OFFLOAD_version (void)\n{\n  return GOMP_VERSION;\n}\n\n/* Flag to decide whether print to stderr information about what is going on.\n   Set in init_debug depending on environment variables.  */\n\nstatic bool debug;\n\n/* Flag to decide if the runtime should suppress a possible fallback to host\n   execution.  */\n\nstatic bool suppress_host_fallback;\n\n/* Flag to locate HSA runtime shared library that is dlopened\n   by this plug-in.  */\n\nstatic const char *hsa_runtime_lib;\n\n/* Flag to decide if the runtime should support also CPU devices (can be\n   a simulator).  */\n\nstatic bool support_cpu_devices;\n\n/* Initialize debug and suppress_host_fallback according to the environment.  */\n\nstatic void\ninit_enviroment_variables (void)\n{\n  if (secure_getenv (\"HSA_DEBUG\"))\n    debug = true;\n  else\n    debug = false;\n\n  if (secure_getenv (\"HSA_SUPPRESS_HOST_FALLBACK\"))\n    suppress_host_fallback = true;\n  else\n    suppress_host_fallback = false;\n\n  hsa_runtime_lib = secure_getenv (\"HSA_RUNTIME_LIB\");\n  if (hsa_runtime_lib == NULL)\n    hsa_runtime_lib = HSA_RUNTIME_LIB \"libhsa-runtime64.so\";\n\n  support_cpu_devices = secure_getenv (\"HSA_SUPPORT_CPU_DEVICES\");\n}\n\n/* Print a logging message with PREFIX to stderr if HSA_DEBUG value\n   is set to true.  */\n\n#define HSA_LOG(prefix, ...) \\\n  do \\\n  { \\\n    if (debug) \\\n      { \\\n\tfprintf (stderr, prefix); \\\n\tfprintf (stderr, __VA_ARGS__); \\\n      } \\\n  } \\\n  while (false);\n\n/* Print a debugging message to stderr.  */\n\n#define HSA_DEBUG(...) HSA_LOG (\"HSA debug: \", __VA_ARGS__)\n\n/* Print a warning message to stderr.  */\n\n#define HSA_WARNING(...) HSA_LOG (\"HSA warning: \", __VA_ARGS__)\n\n/* Print HSA warning STR with an HSA STATUS code.  */\n\nstatic void\nhsa_warn (const char *str, hsa_status_t status)\n{\n  if (!debug)\n    return;\n\n  const char *hsa_error_msg;\n  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n\n  fprintf (stderr, \"HSA warning: %s\\nRuntime message: %s\", str, hsa_error_msg);\n}\n\n/* Report a fatal error STR together with the HSA error corresponding to STATUS\n   and terminate execution of the current process.  */\n\nstatic void\nhsa_fatal (const char *str, hsa_status_t status)\n{\n  const char *hsa_error_msg;\n  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n  GOMP_PLUGIN_fatal (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n\t\t     hsa_error_msg);\n}\n\n/* Like hsa_fatal, except only report error message, and return FALSE\n   for propagating error processing to outside of plugin.  */\n\nstatic bool\nhsa_error (const char *str, hsa_status_t status)\n{\n  const char *hsa_error_msg;\n  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n  GOMP_PLUGIN_error (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n\t\t     hsa_error_msg);\n  return false;\n}\n\nstruct hsa_kernel_description\n{\n  const char *name;\n  unsigned omp_data_size;\n  bool gridified_kernel_p;\n  unsigned kernel_dependencies_count;\n  const char **kernel_dependencies;\n};\n\nstruct global_var_info\n{\n  const char *name;\n  void *address;\n};\n\n/* Data passed by the static initializer of a compilation unit containing BRIG\n   to GOMP_offload_register.  */\n\nstruct brig_image_desc\n{\n  hsa_ext_module_t brig_module;\n  const unsigned kernel_count;\n  struct hsa_kernel_description *kernel_infos;\n  const unsigned global_variable_count;\n  struct global_var_info *global_variables;\n};\n\nstruct agent_info;\n\n/* Information required to identify, finalize and run any given kernel.  */\n\nstruct kernel_info\n{\n  /* Name of the kernel, required to locate it within the brig module.  */\n  const char *name;\n  /* Size of memory space for OMP data.  */\n  unsigned omp_data_size;\n  /* The specific agent the kernel has been or will be finalized for and run\n     on.  */\n  struct agent_info *agent;\n  /* The specific module where the kernel takes place.  */\n  struct module_info *module;\n  /* Mutex enforcing that at most once thread ever initializes a kernel for\n     use.  A thread should have locked agent->modules_rwlock for reading before\n     acquiring it.  */\n  pthread_mutex_t init_mutex;\n  /* Flag indicating whether the kernel has been initialized and all fields\n     below it contain valid data.  */\n  bool initialized;\n  /* Flag indicating that the kernel has a problem that blocks an execution.  */\n  bool initialization_failed;\n  /* The object to be put into the dispatch queue.  */\n  uint64_t object;\n  /* Required size of kernel arguments.  */\n  uint32_t kernarg_segment_size;\n  /* Required size of group segment.  */\n  uint32_t group_segment_size;\n  /* Required size of private segment.  */\n  uint32_t private_segment_size;\n  /* List of all kernel dependencies.  */\n  const char **dependencies;\n  /* Number of dependencies.  */\n  unsigned dependencies_count;\n  /* Maximum OMP data size necessary for kernel from kernel dispatches.  */\n  unsigned max_omp_data_size;\n  /* True if the kernel is gridified.  */\n  bool gridified_kernel_p;\n};\n\n/* Information about a particular brig module, its image and kernels.  */\n\nstruct module_info\n{\n  /* The next and previous module in the linked list of modules of an agent.  */\n  struct module_info *next, *prev;\n  /* The description with which the program has registered the image.  */\n  struct brig_image_desc *image_desc;\n\n  /* Number of kernels in this module.  */\n  int kernel_count;\n  /* An array of kernel_info structures describing each kernel in this\n     module.  */\n  struct kernel_info kernels[];\n};\n\n/* Information about shared brig library.  */\n\nstruct brig_library_info\n{\n  char *file_name;\n  hsa_ext_module_t image;\n};\n\n/* Description of an HSA GPU agent and the program associated with it.  */\n\nstruct agent_info\n{\n  /* The HSA ID of the agent.  Assigned when hsa_context is initialized.  */\n  hsa_agent_t id;\n  /* Whether the agent has been initialized.  The fields below are usable only\n     if it has been.  */\n  bool initialized;\n  /* The HSA ISA of this agent.  */\n  hsa_isa_t isa;\n  /* Command queue of the agent.  */\n  hsa_queue_t *command_q;\n  /* Kernel from kernel dispatch command queue.  */\n  hsa_queue_t *kernel_dispatch_command_q;\n  /* The HSA memory region from which to allocate kernel arguments.  */\n  hsa_region_t kernarg_region;\n\n  /* Read-write lock that protects kernels which are running or about to be run\n     from interference with loading and unloading of images.  Needs to be\n     locked for reading while a kernel is being run, and for writing if the\n     list of modules is manipulated (and thus the HSA program invalidated).  */\n  pthread_rwlock_t modules_rwlock;\n  /* The first module in a linked list of modules associated with this\n     kernel.  */\n  struct module_info *first_module;\n\n  /* Mutex enforcing that only one thread will finalize the HSA program.  A\n     thread should have locked agent->modules_rwlock for reading before\n     acquiring it.  */\n  pthread_mutex_t prog_mutex;\n  /* Flag whether the HSA program that consists of all the modules has been\n     finalized.  */\n  bool prog_finalized;\n  /* Flag whether the program was finalized but with a failure.  */\n  bool prog_finalized_error;\n  /* HSA executable - the finalized program that is used to locate kernels.  */\n  hsa_executable_t executable;\n  /* List of BRIG libraries.  */\n  struct brig_library_info **brig_libraries;\n  /* Number of loaded shared BRIG libraries.  */\n  unsigned brig_libraries_count;\n};\n\n/* Information about the whole HSA environment and all of its agents.  */\n\nstruct hsa_context_info\n{\n  /* Whether the structure has been initialized.  */\n  bool initialized;\n  /* Number of usable GPU HSA agents in the system.  */\n  int agent_count;\n  /* Array of agent_info structures describing the individual HSA agents.  */\n  struct agent_info *agents;\n};\n\n/* Information about the whole HSA environment and all of its agents.  */\n\nstatic struct hsa_context_info hsa_context;\n\n#define DLSYM_FN(function) \\\n  hsa_fns.function##_fn = dlsym (handle, #function); \\\n  if (hsa_fns.function##_fn == NULL) \\\n    return false;\n\nstatic bool\ninit_hsa_runtime_functions (void)\n{\n  void *handle = dlopen (hsa_runtime_lib, RTLD_LAZY);\n  if (handle == NULL)\n    return false;\n\n  DLSYM_FN (hsa_status_string)\n  DLSYM_FN (hsa_agent_get_info)\n  DLSYM_FN (hsa_init)\n  DLSYM_FN (hsa_iterate_agents)\n  DLSYM_FN (hsa_region_get_info)\n  DLSYM_FN (hsa_queue_create)\n  DLSYM_FN (hsa_agent_iterate_regions)\n  DLSYM_FN (hsa_executable_destroy)\n  DLSYM_FN (hsa_executable_create)\n  DLSYM_FN (hsa_executable_global_variable_define)\n  DLSYM_FN (hsa_executable_load_code_object)\n  DLSYM_FN (hsa_executable_freeze)\n  DLSYM_FN (hsa_signal_create)\n  DLSYM_FN (hsa_memory_allocate)\n  DLSYM_FN (hsa_memory_free)\n  DLSYM_FN (hsa_signal_destroy)\n  DLSYM_FN (hsa_executable_get_symbol)\n  DLSYM_FN (hsa_executable_symbol_get_info)\n  DLSYM_FN (hsa_queue_add_write_index_release)\n  DLSYM_FN (hsa_queue_load_read_index_acquire)\n  DLSYM_FN (hsa_signal_wait_acquire)\n  DLSYM_FN (hsa_signal_store_relaxed)\n  DLSYM_FN (hsa_signal_store_release)\n  DLSYM_FN (hsa_signal_load_acquire)\n  DLSYM_FN (hsa_queue_destroy)\n  DLSYM_FN (hsa_ext_program_add_module)\n  DLSYM_FN (hsa_ext_program_create)\n  DLSYM_FN (hsa_ext_program_destroy)\n  DLSYM_FN (hsa_ext_program_finalize)\n  return true;\n}\n\n/* Find kernel for an AGENT by name provided in KERNEL_NAME.  */\n\nstatic struct kernel_info *\nget_kernel_for_agent (struct agent_info *agent, const char *kernel_name)\n{\n  struct module_info *module = agent->first_module;\n\n  while (module)\n    {\n      for (unsigned i = 0; i < module->kernel_count; i++)\n\tif (strcmp (module->kernels[i].name, kernel_name) == 0)\n\t  return &module->kernels[i];\n\n      module = module->next;\n    }\n\n  return NULL;\n}\n\n/* Return true if the agent is a GPU and acceptable of concurrent submissions\n   from different threads.  */\n\nstatic bool\nsuitable_hsa_agent_p (hsa_agent_t agent)\n{\n  hsa_device_type_t device_type;\n  hsa_status_t status\n    = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,\n\t\t\t\t     &device_type);\n  if (status != HSA_STATUS_SUCCESS)\n    return false;\n\n  switch (device_type)\n    {\n    case HSA_DEVICE_TYPE_GPU:\n      break;\n    case HSA_DEVICE_TYPE_CPU:\n      if (!support_cpu_devices)\n\treturn false;\n      break;\n    default:\n      return false;\n    }\n\n  uint32_t features = 0;\n  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_FEATURE,\n\t\t\t\t\t  &features);\n  if (status != HSA_STATUS_SUCCESS\n      || !(features & HSA_AGENT_FEATURE_KERNEL_DISPATCH))\n    return false;\n  hsa_queue_type_t queue_type;\n  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_QUEUE_TYPE,\n\t\t\t\t\t  &queue_type);\n  if (status != HSA_STATUS_SUCCESS\n      || (queue_type != HSA_QUEUE_TYPE_MULTI))\n    return false;\n\n  return true;\n}\n\n/* Callback of hsa_iterate_agents, if AGENT is a GPU device, increment\n   agent_count in hsa_context.  */\n\nstatic hsa_status_t\ncount_gpu_agents (hsa_agent_t agent, void *data __attribute__ ((unused)))\n{\n  if (suitable_hsa_agent_p (agent))\n    hsa_context.agent_count++;\n  return HSA_STATUS_SUCCESS;\n}\n\n/* Callback of hsa_iterate_agents, if AGENT is a GPU device, assign the agent\n   id to the describing structure in the hsa context.  The index of the\n   structure is pointed to by DATA, increment it afterwards.  */\n\nstatic hsa_status_t\nassign_agent_ids (hsa_agent_t agent, void *data)\n{\n  if (suitable_hsa_agent_p (agent))\n    {\n      int *agent_index = (int *) data;\n      hsa_context.agents[*agent_index].id = agent;\n      ++*agent_index;\n    }\n  return HSA_STATUS_SUCCESS;\n}\n\n/* Initialize hsa_context if it has not already been done.\n   Return TRUE on success.  */\n\nstatic bool\ninit_hsa_context (void)\n{\n  hsa_status_t status;\n  int agent_index = 0;\n\n  if (hsa_context.initialized)\n    return true;\n  init_enviroment_variables ();\n  if (!init_hsa_runtime_functions ())\n    {\n      HSA_DEBUG (\"Run-time could not be dynamically opened\\n\");\n      return false;\n    }\n  status = hsa_fns.hsa_init_fn ();\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Run-time could not be initialized\", status);\n  HSA_DEBUG (\"HSA run-time initialized\\n\");\n  status = hsa_fns.hsa_iterate_agents_fn (count_gpu_agents, NULL);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"HSA GPU devices could not be enumerated\", status);\n  HSA_DEBUG (\"There are %i HSA GPU devices.\\n\", hsa_context.agent_count);\n\n  hsa_context.agents\n    = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count\n\t\t\t\t  * sizeof (struct agent_info));\n  status = hsa_fns.hsa_iterate_agents_fn (assign_agent_ids, &agent_index);\n  if (agent_index != hsa_context.agent_count)\n    {\n      GOMP_PLUGIN_error (\"Failed to assign IDs to all HSA agents\");\n      return false;\n    }\n  hsa_context.initialized = true;\n  return true;\n}\n\n/* Callback of dispatch queues to report errors.  */\n\nstatic void\nqueue_callback (hsa_status_t status,\n\t\thsa_queue_t *queue __attribute__ ((unused)),\n\t\tvoid *data __attribute__ ((unused)))\n{\n  hsa_fatal (\"Asynchronous queue error\", status);\n}\n\n/* Callback of hsa_agent_iterate_regions.  Determine if a memory REGION can be\n   used for kernarg allocations and if so write it to the memory pointed to by\n   DATA and break the query.  */\n\nstatic hsa_status_t\nget_kernarg_memory_region (hsa_region_t region, void *data)\n{\n  hsa_status_t status;\n  hsa_region_segment_t segment;\n\n  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT,\n\t\t\t\t\t   &segment);\n  if (status != HSA_STATUS_SUCCESS)\n    return status;\n  if (segment != HSA_REGION_SEGMENT_GLOBAL)\n    return HSA_STATUS_SUCCESS;\n\n  uint32_t flags;\n  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,\n\t\t\t\t\t   &flags);\n  if (status != HSA_STATUS_SUCCESS)\n    return status;\n  if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)\n    {\n      hsa_region_t *ret = (hsa_region_t *) data;\n      *ret = region;\n      return HSA_STATUS_INFO_BREAK;\n    }\n  return HSA_STATUS_SUCCESS;\n}\n\n/* Part of the libgomp plugin interface.  Return the number of HSA devices on\n   the system.  */\n\nint\nGOMP_OFFLOAD_get_num_devices (void)\n{\n  if (!init_hsa_context ())\n    return 0;\n  return hsa_context.agent_count;\n}\n\n/* Part of the libgomp plugin interface.  Initialize agent number N so that it\n   can be used for computation.  Return TRUE on success.  */\n\nbool\nGOMP_OFFLOAD_init_device (int n)\n{\n  if (!init_hsa_context ())\n    return false;\n  if (n >= hsa_context.agent_count)\n    {\n      GOMP_PLUGIN_error (\"Request to initialize non-existing HSA device %i\", n);\n      return false;\n    }\n  struct agent_info *agent = &hsa_context.agents[n];\n\n  if (agent->initialized)\n    return true;\n\n  if (pthread_rwlock_init (&agent->modules_rwlock, NULL))\n    {\n      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent rwlock\");\n      return false;\n    }\n  if (pthread_mutex_init (&agent->prog_mutex, NULL))\n    {\n      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent program mutex\");\n      return false;\n    }\n\n  uint32_t queue_size;\n  hsa_status_t status;\n  status = hsa_fns.hsa_agent_get_info_fn (agent->id,\n\t\t\t\t\t  HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n\t\t\t\t\t  &queue_size);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error requesting maximum queue size of the HSA agent\",\n    \t   \t      status);\n  status = hsa_fns.hsa_agent_get_info_fn (agent->id, HSA_AGENT_INFO_ISA,\n\t\t\t\t\t  &agent->isa);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error querying the ISA of the agent\", status);\n  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n\t\t\t\t\tUINT32_MAX,\n\t\t\t\t\t&agent->command_q);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error creating command queue\", status);\n\n  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n\t\t\t\t\tUINT32_MAX,\n\t\t\t\t\t&agent->kernel_dispatch_command_q);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error creating kernel dispatch command queue\", status);\n\n  agent->kernarg_region.handle = (uint64_t) -1;\n  status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,\n\t\t\t\t\t\t get_kernarg_memory_region,\n\t\t\t\t\t\t &agent->kernarg_region);\n  if (agent->kernarg_region.handle == (uint64_t) -1)\n    {\n      GOMP_PLUGIN_error (\"Could not find suitable memory region for kernel \"\n\t\t\t \"arguments\");\n      return false;\n    }\n  HSA_DEBUG (\"HSA agent initialized, queue has id %llu\\n\",\n\t     (long long unsigned) agent->command_q->id);\n  HSA_DEBUG (\"HSA agent initialized, kernel dispatch queue has id %llu\\n\",\n\t     (long long unsigned) agent->kernel_dispatch_command_q->id);\n  agent->initialized = true;\n  return true;\n}\n\n/* Verify that hsa_context has already been initialized and return the\n   agent_info structure describing device number N.  Return NULL on error.  */\n\nstatic struct agent_info *\nget_agent_info (int n)\n{\n  if (!hsa_context.initialized)\n    {\n      GOMP_PLUGIN_error (\"Attempt to use uninitialized HSA context.\");\n      return NULL;\n    }\n  if (n >= hsa_context.agent_count)\n    {\n      GOMP_PLUGIN_error (\"Request to operate on anon-existing HSA device %i\", n);\n      return NULL;\n    }\n  if (!hsa_context.agents[n].initialized)\n    {\n      GOMP_PLUGIN_error (\"Attempt to use an uninitialized HSA agent.\");\n      return NULL;\n    }\n  return &hsa_context.agents[n];\n}\n\n/* Insert MODULE to the linked list of modules of AGENT.  */\n\nstatic void\nadd_module_to_agent (struct agent_info *agent, struct module_info *module)\n{\n  if (agent->first_module)\n    agent->first_module->prev = module;\n  module->next = agent->first_module;\n  module->prev = NULL;\n  agent->first_module = module;\n}\n\n/* Remove MODULE from the linked list of modules of AGENT.  */\n\nstatic void\nremove_module_from_agent (struct agent_info *agent, struct module_info *module)\n{\n  if (agent->first_module == module)\n    agent->first_module = module->next;\n  if (module->prev)\n    module->prev->next = module->next;\n  if (module->next)\n    module->next->prev = module->prev;\n}\n\n/* Free the HSA program in agent and everything associated with it and set\n   agent->prog_finalized and the initialized flags of all kernels to false.\n   Return TRUE on success.  */\n\nstatic bool\ndestroy_hsa_program (struct agent_info *agent)\n{\n  if (!agent->prog_finalized || agent->prog_finalized_error)\n    return true;\n\n  hsa_status_t status;\n\n  HSA_DEBUG (\"Destroying the current HSA program.\\n\");\n\n  status = hsa_fns.hsa_executable_destroy_fn (agent->executable);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Could not destroy HSA executable\", status);\n\n  struct module_info *module;\n  for (module = agent->first_module; module; module = module->next)\n    {\n      int i;\n      for (i = 0; i < module->kernel_count; i++)\n\tmodule->kernels[i].initialized = false;\n    }\n  agent->prog_finalized = false;\n  return true;\n}\n\n/* Initialize KERNEL from D and other parameters.  Return true on success. */\n\nstatic bool\ninit_basic_kernel_info (struct kernel_info *kernel,\n\t\t\tstruct hsa_kernel_description *d,\n\t\t\tstruct agent_info *agent,\n\t\t\tstruct module_info *module)\n{\n  kernel->agent = agent;\n  kernel->module = module;\n  kernel->name = d->name;\n  kernel->omp_data_size = d->omp_data_size;\n  kernel->gridified_kernel_p = d->gridified_kernel_p;\n  kernel->dependencies_count = d->kernel_dependencies_count;\n  kernel->dependencies = d->kernel_dependencies;\n  if (pthread_mutex_init (&kernel->init_mutex, NULL))\n    {\n      GOMP_PLUGIN_error (\"Failed to initialize an HSA kernel mutex\");\n      return false;\n    }\n  return true;\n}\n\n/* Part of the libgomp plugin interface.  Load BRIG module described by struct\n   brig_image_desc in TARGET_DATA and return references to kernel descriptors\n   in TARGET_TABLE.  */\n\nint\nGOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n\t\t\t struct addr_pair **target_table)\n{\n  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n    {\n      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n\t\t\t \" (expected %u, received %u)\",\n\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n      return -1;\n    }\n\n  struct brig_image_desc *image_desc = (struct brig_image_desc *) target_data;\n  struct agent_info *agent;\n  struct addr_pair *pair;\n  struct module_info *module;\n  struct kernel_info *kernel;\n  int kernel_count = image_desc->kernel_count;\n\n  agent = get_agent_info (ord);\n  if (!agent)\n    return -1;\n\n  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n    {\n      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n      return -1;\n    }\n  if (agent->prog_finalized\n      && !destroy_hsa_program (agent))\n    return -1;\n\n  HSA_DEBUG (\"Encountered %d kernels in an image\\n\", kernel_count);\n  pair = GOMP_PLUGIN_malloc (kernel_count * sizeof (struct addr_pair));\n  *target_table = pair;\n  module = (struct module_info *)\n    GOMP_PLUGIN_malloc_cleared (sizeof (struct module_info)\n\t\t\t\t+ kernel_count * sizeof (struct kernel_info));\n  module->image_desc = image_desc;\n  module->kernel_count = kernel_count;\n\n  kernel = &module->kernels[0];\n\n  /* Allocate memory for kernel dependencies.  */\n  for (unsigned i = 0; i < kernel_count; i++)\n    {\n      pair->start = (uintptr_t) kernel;\n      pair->end = (uintptr_t) (kernel + 1);\n\n      struct hsa_kernel_description *d = &image_desc->kernel_infos[i];\n      if (!init_basic_kernel_info (kernel, d, agent, module))\n\treturn -1;\n      kernel++;\n      pair++;\n    }\n\n  add_module_to_agent (agent, module);\n  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n    {\n      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n      return -1;\n    }\n  return kernel_count;\n}\n\n/* Add a shared BRIG library from a FILE_NAME to an AGENT.  */\n\nstatic struct brig_library_info *\nadd_shared_library (const char *file_name, struct agent_info *agent)\n{\n  struct brig_library_info *library = NULL;\n\n  void *f = dlopen (file_name, RTLD_NOW);\n  void *start = dlsym (f, \"__brig_start\");\n  void *end = dlsym (f, \"__brig_end\");\n\n  if (start == NULL || end == NULL)\n    return NULL;\n\n  unsigned size = end - start;\n  char *buf = (char *) GOMP_PLUGIN_malloc (size);\n  memcpy (buf, start, size);\n\n  library = GOMP_PLUGIN_malloc (sizeof (struct agent_info));\n  library->file_name = (char *) GOMP_PLUGIN_malloc\n    ((strlen (file_name) + 1));\n  strcpy (library->file_name, file_name);\n  library->image = (hsa_ext_module_t) buf;\n\n  return library;\n}\n\n/* Release memory used for BRIG shared libraries that correspond\n   to an AGENT.  */\n\nstatic void\nrelease_agent_shared_libraries (struct agent_info *agent)\n{\n  for (unsigned i = 0; i < agent->brig_libraries_count; i++)\n    if (agent->brig_libraries[i])\n      {\n\tfree (agent->brig_libraries[i]->file_name);\n\tfree (agent->brig_libraries[i]->image);\n\tfree (agent->brig_libraries[i]);\n      }\n\n  free (agent->brig_libraries);\n}\n\n/* Create and finalize the program consisting of all loaded modules.  */\n\nstatic void\ncreate_and_finalize_hsa_program (struct agent_info *agent)\n{\n  hsa_status_t status;\n  hsa_ext_program_t prog_handle;\n  int mi = 0;\n\n  if (pthread_mutex_lock (&agent->prog_mutex))\n    GOMP_PLUGIN_fatal (\"Could not lock an HSA agent program mutex\");\n  if (agent->prog_finalized)\n    goto final;\n\n  status = hsa_fns.hsa_ext_program_create_fn\n    (HSA_MACHINE_MODEL_LARGE, HSA_PROFILE_FULL,\n     HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n     NULL, &prog_handle);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not create an HSA program\", status);\n\n  HSA_DEBUG (\"Created a finalized program\\n\");\n\n  struct module_info *module = agent->first_module;\n  while (module)\n    {\n      status = hsa_fns.hsa_ext_program_add_module_fn\n\t(prog_handle, module->image_desc->brig_module);\n      if (status != HSA_STATUS_SUCCESS)\n\thsa_fatal (\"Could not add a module to the HSA program\", status);\n      module = module->next;\n      mi++;\n    }\n\n  /* Load all shared libraries.  */\n  const char *libraries[] = { \"libhsamath.so\", \"libhsastd.so\" };\n  const unsigned libraries_count = sizeof (libraries) / sizeof (const char *);\n\n  agent->brig_libraries_count = libraries_count;\n  agent->brig_libraries = GOMP_PLUGIN_malloc_cleared\n    (sizeof (struct brig_library_info) * libraries_count);\n\n  for (unsigned i = 0; i < libraries_count; i++)\n    {\n      struct brig_library_info *library = add_shared_library (libraries[i],\n\t\t\t\t\t\t\t      agent);\n      if (library == NULL)\n\t{\n\t  HSA_WARNING (\"Could not open a shared BRIG library: %s\\n\",\n\t\t       libraries[i]);\n\t  continue;\n\t}\n\n      status = hsa_fns.hsa_ext_program_add_module_fn (prog_handle,\n\t\t\t\t\t\t      library->image);\n      if (status != HSA_STATUS_SUCCESS)\n\thsa_warn (\"Could not add a shared BRIG library the HSA program\",\n\t\t  status);\n      else\n\tHSA_DEBUG (\"a shared BRIG library has been added to a program: %s\\n\",\n\t\t   libraries[i]);\n    }\n\n  hsa_ext_control_directives_t control_directives;\n  memset (&control_directives, 0, sizeof (control_directives));\n  hsa_code_object_t code_object;\n  status = hsa_fns.hsa_ext_program_finalize_fn\n    (prog_handle, agent->isa,HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO,\n     control_directives, \"\", HSA_CODE_OBJECT_TYPE_PROGRAM, &code_object);\n  if (status != HSA_STATUS_SUCCESS)\n    {\n      hsa_warn (\"Finalization of the HSA program failed\", status);\n      goto failure;\n    }\n\n  HSA_DEBUG (\"Finalization done\\n\");\n  hsa_fns.hsa_ext_program_destroy_fn (prog_handle);\n\n  status\n    = hsa_fns.hsa_executable_create_fn (HSA_PROFILE_FULL,\n\t\t\t\t\tHSA_EXECUTABLE_STATE_UNFROZEN,\n\t\t\t\t\t\"\", &agent->executable);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not create HSA executable\", status);\n\n  module = agent->first_module;\n  while (module)\n    {\n      /* Initialize all global variables declared in the module.  */\n      for (unsigned i = 0; i < module->image_desc->global_variable_count; i++)\n\t{\n\t  struct global_var_info *var;\n\t  var = &module->image_desc->global_variables[i];\n\t  status = hsa_fns.hsa_executable_global_variable_define_fn\n\t    (agent->executable, var->name, var->address);\n\n\t  HSA_DEBUG (\"Defining global variable: %s, address: %p\\n\", var->name,\n\t\t     var->address);\n\n\t  if (status != HSA_STATUS_SUCCESS)\n\t    hsa_fatal (\"Could not define a global variable in the HSA program\",\n\t\t       status);\n\t}\n\n      module = module->next;\n    }\n\n  status = hsa_fns.hsa_executable_load_code_object_fn (agent->executable,\n\t\t\t\t\t\t       agent->id,\n\t\t\t\t\t\t       code_object, \"\");\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not add a code object to the HSA executable\", status);\n  status = hsa_fns.hsa_executable_freeze_fn (agent->executable, \"\");\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not freeze the HSA executable\", status);\n\n  HSA_DEBUG (\"Froze HSA executable with the finalized code object\\n\");\n\n  /* If all goes good, jump to final.  */\n  goto final;\n\nfailure:\n  agent->prog_finalized_error = true;\n\nfinal:\n  agent->prog_finalized = true;\n\n  if (pthread_mutex_unlock (&agent->prog_mutex))\n    GOMP_PLUGIN_fatal (\"Could not unlock an HSA agent program mutex\");\n}\n\n/* Create kernel dispatch data structure for given KERNEL.  */\n\nstatic struct GOMP_hsa_kernel_dispatch *\ncreate_single_kernel_dispatch (struct kernel_info *kernel,\n\t\t\t       unsigned omp_data_size)\n{\n  struct agent_info *agent = kernel->agent;\n  struct GOMP_hsa_kernel_dispatch *shadow\n    = GOMP_PLUGIN_malloc_cleared (sizeof (struct GOMP_hsa_kernel_dispatch));\n\n  shadow->queue = agent->command_q;\n  shadow->omp_data_memory\n    = omp_data_size > 0 ? GOMP_PLUGIN_malloc (omp_data_size) : NULL;\n  unsigned dispatch_count = kernel->dependencies_count;\n  shadow->kernel_dispatch_count = dispatch_count;\n\n  shadow->children_dispatches\n    = GOMP_PLUGIN_malloc (dispatch_count * sizeof (shadow));\n\n  shadow->object = kernel->object;\n\n  hsa_signal_t sync_signal;\n  hsa_status_t status = hsa_fns.hsa_signal_create_fn (1, 0, NULL, &sync_signal);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Error creating the HSA sync signal\", status);\n\n  shadow->signal = sync_signal.handle;\n  shadow->private_segment_size = kernel->private_segment_size;\n  shadow->group_segment_size = kernel->group_segment_size;\n\n  status\n    = hsa_fns.hsa_memory_allocate_fn (agent->kernarg_region,\n\t\t\t\t      kernel->kernarg_segment_size,\n\t\t\t\t      &shadow->kernarg_address);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not allocate memory for HSA kernel arguments\", status);\n\n  return shadow;\n}\n\n/* Release data structure created for a kernel dispatch in SHADOW argument.  */\n\nstatic void\nrelease_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)\n{\n  HSA_DEBUG (\"Released kernel dispatch: %p has value: %\" PRIu64 \" (%p)\\n\",\n\t     shadow, shadow->debug,\n\t     (void *) (uintptr_t) shadow->debug);\n\n  hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);\n\n  hsa_signal_t s;\n  s.handle = shadow->signal;\n  hsa_fns.hsa_signal_destroy_fn (s);\n\n  free (shadow->omp_data_memory);\n\n  for (unsigned i = 0; i < shadow->kernel_dispatch_count; i++)\n    release_kernel_dispatch (shadow->children_dispatches[i]);\n\n  free (shadow->children_dispatches);\n  free (shadow);\n}\n\n/* Initialize a KERNEL without its dependencies.  MAX_OMP_DATA_SIZE is used\n   to calculate maximum necessary memory for OMP data allocation.  */\n\nstatic void\ninit_single_kernel (struct kernel_info *kernel, unsigned *max_omp_data_size)\n{\n  hsa_status_t status;\n  struct agent_info *agent = kernel->agent;\n  hsa_executable_symbol_t kernel_symbol;\n  status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n\t\t\t\t\t\t kernel->name, agent->id,\n\t\t\t\t\t\t 0, &kernel_symbol);\n  if (status != HSA_STATUS_SUCCESS)\n    {\n      hsa_warn (\"Could not find symbol for kernel in the code object\", status);\n      goto failure;\n    }\n  HSA_DEBUG (\"Located kernel %s\\n\", kernel->name);\n  status = hsa_fns.hsa_executable_symbol_get_info_fn\n    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernel->object);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not extract a kernel object from its symbol\", status);\n  status = hsa_fns.hsa_executable_symbol_get_info_fn\n    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE,\n     &kernel->kernarg_segment_size);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not get info about kernel argument size\", status);\n  status = hsa_fns.hsa_executable_symbol_get_info_fn\n    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE,\n     &kernel->group_segment_size);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not get info about kernel group segment size\", status);\n  status = hsa_fns.hsa_executable_symbol_get_info_fn\n    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,\n     &kernel->private_segment_size);\n  if (status != HSA_STATUS_SUCCESS)\n    hsa_fatal (\"Could not get info about kernel private segment size\",\n\t       status);\n\n  HSA_DEBUG (\"Kernel structure for %s fully initialized with \"\n\t     \"following segment sizes: \\n\", kernel->name);\n  HSA_DEBUG (\"  group_segment_size: %u\\n\",\n\t     (unsigned) kernel->group_segment_size);\n  HSA_DEBUG (\"  private_segment_size: %u\\n\",\n\t     (unsigned) kernel->private_segment_size);\n  HSA_DEBUG (\"  kernarg_segment_size: %u\\n\",\n\t     (unsigned) kernel->kernarg_segment_size);\n  HSA_DEBUG (\"  omp_data_size: %u\\n\", kernel->omp_data_size);\n  HSA_DEBUG (\"  gridified_kernel_p: %u\\n\", kernel->gridified_kernel_p);\n\n  if (kernel->omp_data_size > *max_omp_data_size)\n    *max_omp_data_size = kernel->omp_data_size;\n\n  for (unsigned i = 0; i < kernel->dependencies_count; i++)\n    {\n      struct kernel_info *dependency\n\t= get_kernel_for_agent (agent, kernel->dependencies[i]);\n\n      if (dependency == NULL)\n\t{\n\t  HSA_DEBUG (\"Could not find a dependency for a kernel: %s, \"\n\t\t     \"dependency name: %s\\n\", kernel->name,\n\t\t     kernel->dependencies[i]);\n\t  goto failure;\n\t}\n\n      if (dependency->dependencies_count > 0)\n\t{\n\t  HSA_DEBUG (\"HSA does not allow kernel dispatching code with \"\n\t\t     \"a depth bigger than one\\n\")\n\t  goto failure;\n\t}\n\n      init_single_kernel (dependency, max_omp_data_size);\n    }\n\n  return;\n\nfailure:\n  kernel->initialization_failed = true;\n}\n\n/* Indent stream F by INDENT spaces.  */\n\nstatic void\nindent_stream (FILE *f, unsigned indent)\n{\n  fprintf (f, \"%*s\", indent, \"\");\n}\n\n/* Dump kernel DISPATCH data structure and indent it by INDENT spaces.  */\n\nstatic void\nprint_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *dispatch, unsigned indent)\n{\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"this: %p\\n\", dispatch);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"queue: %p\\n\", dispatch->queue);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"omp_data_memory: %p\\n\", dispatch->omp_data_memory);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"kernarg_address: %p\\n\", dispatch->kernarg_address);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"object: %\" PRIu64 \"\\n\", dispatch->object);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"signal: %\" PRIu64 \"\\n\", dispatch->signal);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"private_segment_size: %u\\n\",\n\t   dispatch->private_segment_size);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"group_segment_size: %u\\n\",\n\t   dispatch->group_segment_size);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"children dispatches: %\" PRIu64 \"\\n\",\n\t   dispatch->kernel_dispatch_count);\n  indent_stream (stderr, indent);\n  fprintf (stderr, \"omp_num_threads: %u\\n\",\n\t   dispatch->omp_num_threads);\n  fprintf (stderr, \"\\n\");\n\n  for (unsigned i = 0; i < dispatch->kernel_dispatch_count; i++)\n    print_kernel_dispatch (dispatch->children_dispatches[i], indent + 2);\n}\n\n/* Create kernel dispatch data structure for a KERNEL and all its\n   dependencies.  */\n\nstatic struct GOMP_hsa_kernel_dispatch *\ncreate_kernel_dispatch (struct kernel_info *kernel, unsigned omp_data_size)\n{\n  struct GOMP_hsa_kernel_dispatch *shadow\n    = create_single_kernel_dispatch (kernel, omp_data_size);\n  shadow->omp_num_threads = 64;\n  shadow->debug = 0;\n  shadow->omp_level = kernel->gridified_kernel_p ? 1 : 0;\n\n  /* Create kernel dispatch data structures.  We do not allow to have\n     a kernel dispatch with depth bigger than one.  */\n  for (unsigned i = 0; i < kernel->dependencies_count; i++)\n    {\n      struct kernel_info *dependency\n\t= get_kernel_for_agent (kernel->agent, kernel->dependencies[i]);\n      shadow->children_dispatches[i]\n\t= create_single_kernel_dispatch (dependency, omp_data_size);\n      shadow->children_dispatches[i]->queue\n\t= kernel->agent->kernel_dispatch_command_q;\n      shadow->children_dispatches[i]->omp_level = 1;\n    }\n\n  return shadow;\n}\n\n/* Do all the work that is necessary before running KERNEL for the first time.\n   The function assumes the program has been created, finalized and frozen by\n   create_and_finalize_hsa_program.  */\n\nstatic void\ninit_kernel (struct kernel_info *kernel)\n{\n  if (pthread_mutex_lock (&kernel->init_mutex))\n    GOMP_PLUGIN_fatal (\"Could not lock an HSA kernel initialization mutex\");\n  if (kernel->initialized)\n    {\n      if (pthread_mutex_unlock (&kernel->init_mutex))\n\tGOMP_PLUGIN_fatal (\"Could not unlock an HSA kernel initialization \"\n\t\t\t   \"mutex\");\n\n      return;\n    }\n\n  /* Precomputed maximum size of OMP data necessary for a kernel from kernel\n     dispatch operation.  */\n  init_single_kernel (kernel, &kernel->max_omp_data_size);\n\n  if (!kernel->initialization_failed)\n    HSA_DEBUG (\"\\n\");\n\n  kernel->initialized = true;\n  if (pthread_mutex_unlock (&kernel->init_mutex))\n    GOMP_PLUGIN_fatal (\"Could not unlock an HSA kernel initialization \"\n\t\t       \"mutex\");\n}\n\n/* Parse the target attributes INPUT provided by the compiler and return true\n   if we should run anything all.  If INPUT is NULL, fill DEF with default\n   values, then store INPUT or DEF into *RESULT.  */\n\nstatic bool\nparse_target_attributes (void **input,\n\t\t\t struct GOMP_kernel_launch_attributes *def,\n\t\t\t struct GOMP_kernel_launch_attributes **result)\n{\n  if (!input)\n    GOMP_PLUGIN_fatal (\"No target arguments provided\");\n\n  bool attrs_found = false;\n  while (*input)\n    {\n      uintptr_t id = (uintptr_t) *input;\n      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) == GOMP_DEVICE_HSA\n\t  && ((id & GOMP_TARGET_ARG_ID_MASK)\n\t      == GOMP_TARGET_ARG_HSA_KERNEL_ATTRIBUTES))\n\t{\n\t  input++;\n\t  attrs_found = true;\n\t  break;\n\t}\n\n      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n\tinput++;\n      input++;\n    }\n\n  if (!attrs_found)\n    {\n      def->ndim = 1;\n      def->gdims[0] = 1;\n      def->gdims[1] = 1;\n      def->gdims[2] = 1;\n      def->wdims[0] = 1;\n      def->wdims[1] = 1;\n      def->wdims[2] = 1;\n      *result = def;\n      HSA_DEBUG (\"GOMP_OFFLOAD_run called with no launch attributes\\n\");\n      return true;\n    }\n\n  struct GOMP_kernel_launch_attributes *kla;\n  kla = (struct GOMP_kernel_launch_attributes *) *input;\n  *result = kla;\n  if (kla->ndim == 0 || kla->ndim > 3)\n    GOMP_PLUGIN_fatal (\"Invalid number of dimensions (%u)\", kla->ndim);\n\n  HSA_DEBUG (\"GOMP_OFFLOAD_run called with %u dimensions:\\n\", kla->ndim);\n  unsigned i;\n  for (i = 0; i < kla->ndim; i++)\n    {\n      HSA_DEBUG (\"  Dimension %u: grid size %u and group size %u\\n\", i,\n\t\t kla->gdims[i], kla->wdims[i]);\n      if (kla->gdims[i] == 0)\n\treturn false;\n    }\n  return true;\n}\n\n/* Return the group size given the requested GROUP size, GRID size and number\n   of grid dimensions NDIM.  */\n\nstatic uint32_t\nget_group_size (uint32_t ndim, uint32_t grid, uint32_t group)\n{\n  if (group == 0)\n    {\n      /* TODO: Provide a default via environment or device characteristics.  */\n      if (ndim == 1)\n\tgroup = 64;\n      else if (ndim == 2)\n\tgroup = 8;\n      else\n\tgroup = 4;\n    }\n\n  if (group > grid)\n    group = grid;\n  return group;\n}\n\n/* Return true if the HSA runtime can run function FN_PTR.  */\n\nbool\nGOMP_OFFLOAD_can_run (void *fn_ptr)\n{\n  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n  struct agent_info *agent = kernel->agent;\n  create_and_finalize_hsa_program (agent);\n\n  if (agent->prog_finalized_error)\n    goto failure;\n\n  init_kernel (kernel);\n  if (kernel->initialization_failed)\n    goto failure;\n\n  return true;\n\nfailure:\n  if (suppress_host_fallback)\n    GOMP_PLUGIN_fatal (\"HSA host fallback has been suppressed\");\n  HSA_DEBUG (\"HSA target cannot be launched, doing a host fallback\\n\");\n  return false;\n}\n\n/* Atomically store pair of uint16_t values (HEADER and REST) to a PACKET.  */\n\nvoid\npacket_store_release (uint32_t* packet, uint16_t header, uint16_t rest)\n{\n  __atomic_store_n (packet, header | (rest << 16), __ATOMIC_RELEASE);\n}\n\n/* Run KERNEL on its agent, pass VARS to it as arguments and take\n   launchattributes from KLA.  */\n\nvoid\nrun_kernel (struct kernel_info *kernel, void *vars,\n\t    struct GOMP_kernel_launch_attributes *kla)\n{\n  struct agent_info *agent = kernel->agent;\n  if (pthread_rwlock_rdlock (&agent->modules_rwlock))\n    GOMP_PLUGIN_fatal (\"Unable to read-lock an HSA agent rwlock\");\n\n  if (!agent->initialized)\n    GOMP_PLUGIN_fatal (\"Agent must be initialized\");\n\n  if (!kernel->initialized)\n    GOMP_PLUGIN_fatal (\"Called kernel must be initialized\");\n\n  struct GOMP_hsa_kernel_dispatch *shadow\n    = create_kernel_dispatch (kernel, kernel->max_omp_data_size);\n\n  if (debug)\n    {\n      fprintf (stderr, \"\\nKernel has following dependencies:\\n\");\n      print_kernel_dispatch (shadow, 2);\n    }\n\n  uint64_t index\n    = hsa_fns.hsa_queue_add_write_index_release_fn (agent->command_q, 1);\n  HSA_DEBUG (\"Got AQL index %llu\\n\", (long long int) index);\n\n  /* Wait until the queue is not full before writing the packet.   */\n  while (index - hsa_fns.hsa_queue_load_read_index_acquire_fn (agent->command_q)\n\t >= agent->command_q->size)\n    ;\n\n  hsa_kernel_dispatch_packet_t *packet;\n  packet = ((hsa_kernel_dispatch_packet_t *) agent->command_q->base_address)\n\t   + index % agent->command_q->size;\n\n  memset (((uint8_t *) packet) + 4, 0, sizeof (*packet) - 4);\n  packet->grid_size_x = kla->gdims[0];\n  packet->workgroup_size_x = get_group_size (kla->ndim, kla->gdims[0],\n\t\t\t\t\t     kla->wdims[0]);\n\n  if (kla->ndim >= 2)\n    {\n      packet->grid_size_y = kla->gdims[1];\n      packet->workgroup_size_y = get_group_size (kla->ndim, kla->gdims[1],\n\t\t\t\t\t\t kla->wdims[1]);\n    }\n  else\n    {\n      packet->grid_size_y = 1;\n      packet->workgroup_size_y = 1;\n    }\n\n  if (kla->ndim == 3)\n    {\n      packet->grid_size_z = kla->gdims[2];\n      packet->workgroup_size_z = get_group_size (kla->ndim, kla->gdims[2],\n\t\t\t\t\t     kla->wdims[2]);\n    }\n  else\n    {\n      packet->grid_size_z = 1;\n      packet->workgroup_size_z = 1;\n    }\n\n  packet->private_segment_size = kernel->private_segment_size;\n  packet->group_segment_size = kernel->group_segment_size;\n  packet->kernel_object = kernel->object;\n  packet->kernarg_address = shadow->kernarg_address;\n  hsa_signal_t s;\n  s.handle = shadow->signal;\n  packet->completion_signal = s;\n  hsa_fns.hsa_signal_store_relaxed_fn (s, 1);\n  memcpy (shadow->kernarg_address, &vars, sizeof (vars));\n\n  /* PR hsa/70337.  */\n  size_t vars_size = sizeof (vars);\n  if (kernel->kernarg_segment_size > vars_size)\n    {\n      if (kernel->kernarg_segment_size != vars_size\n\t  + sizeof (struct hsa_kernel_runtime *))\n\tGOMP_PLUGIN_fatal (\"Kernel segment size has an unexpected value\");\n      memcpy (packet->kernarg_address + vars_size, &shadow,\n\t      sizeof (struct hsa_kernel_runtime *));\n    }\n\n  HSA_DEBUG (\"Copying kernel runtime pointer to kernarg_address\\n\");\n\n  uint16_t header;\n  header = HSA_PACKET_TYPE_KERNEL_DISPATCH << HSA_PACKET_HEADER_TYPE;\n  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE;\n  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE;\n\n  HSA_DEBUG (\"Going to dispatch kernel %s\\n\", kernel->name);\n\n  packet_store_release ((uint32_t *) packet, header,\n\t\t\t(uint16_t) kla->ndim << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS);\n\n  hsa_fns.hsa_signal_store_release_fn (agent->command_q->doorbell_signal,\n\t\t\t\t       index);\n\n  /* TODO: GPU agents in Carrizo APUs cannot properly update L2 cache for\n     signal wait and signal load operations on their own and we need to\n     periodically call the hsa_signal_load_acquire on completion signals of\n     children kernels in the CPU to make that happen.  As soon the\n     limitation will be resolved, this workaround can be removed.  */\n\n  HSA_DEBUG (\"Kernel dispatched, waiting for completion\\n\");\n\n  /* Root signal waits with 1ms timeout.  */\n  while (hsa_fns.hsa_signal_wait_acquire_fn (s, HSA_SIGNAL_CONDITION_LT, 1,\n\t\t\t\t\t     1000 * 1000,\n\t\t\t\t\t     HSA_WAIT_STATE_BLOCKED) != 0)\n    for (unsigned i = 0; i < shadow->kernel_dispatch_count; i++)\n      {\n\thsa_signal_t child_s;\n\tchild_s.handle = shadow->children_dispatches[i]->signal;\n\n\tHSA_DEBUG (\"Waiting for children completion signal: %\" PRIu64 \"\\n\",\n\t\t   shadow->children_dispatches[i]->signal);\n\thsa_fns.hsa_signal_load_acquire_fn (child_s);\n      }\n\n  release_kernel_dispatch (shadow);\n\n  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n    GOMP_PLUGIN_fatal (\"Unable to unlock an HSA agent rwlock\");\n}\n\n/* Part of the libgomp plugin interface.  Run a kernel on device N (the number\n   is actually ignored, we assume the FN_PTR has been mapped using the correct\n   device) and pass it an array of pointers in VARS as a parameter.  The kernel\n   is identified by FN_PTR which must point to a kernel_info structure.  */\n\nvoid\nGOMP_OFFLOAD_run (int n __attribute__((unused)),\n\t\t  void *fn_ptr, void *vars, void **args)\n{\n  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n  struct GOMP_kernel_launch_attributes def;\n  struct GOMP_kernel_launch_attributes *kla;\n  if (!parse_target_attributes (args, &def, &kla))\n    {\n      HSA_DEBUG (\"Will not run HSA kernel because the grid size is zero\\n\");\n      return;\n    }\n  run_kernel (kernel, vars, kla);\n}\n\n/* Information to be passed to a thread running a kernel asycnronously.  */\n\nstruct async_run_info\n{\n  int device;\n  void *tgt_fn;\n  void *tgt_vars;\n  void **args;\n  void *async_data;\n};\n\n/* Thread routine to run a kernel asynchronously.  */\n\nstatic void *\nrun_kernel_asynchronously (void *thread_arg)\n{\n  struct async_run_info *info = (struct async_run_info *) thread_arg;\n  int device = info->device;\n  void *tgt_fn = info->tgt_fn;\n  void *tgt_vars = info->tgt_vars;\n  void **args = info->args;\n  void *async_data = info->async_data;\n\n  free (info);\n  GOMP_OFFLOAD_run (device, tgt_fn, tgt_vars, args);\n  GOMP_PLUGIN_target_task_completion (async_data);\n  return NULL;\n}\n\n/* Part of the libgomp plugin interface.  Run a kernel like GOMP_OFFLOAD_run\n   does, but asynchronously and call GOMP_PLUGIN_target_task_completion when it\n   has finished.  */\n\nvoid\nGOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n\t\t\tvoid **args, void *async_data)\n{\n  pthread_t pt;\n  struct async_run_info *info;\n  HSA_DEBUG (\"GOMP_OFFLOAD_async_run invoked\\n\")\n  info = GOMP_PLUGIN_malloc (sizeof (struct async_run_info));\n\n  info->device = device;\n  info->tgt_fn = tgt_fn;\n  info->tgt_vars = tgt_vars;\n  info->args = args;\n  info->async_data = async_data;\n\n  int err = pthread_create (&pt, NULL, &run_kernel_asynchronously, info);\n  if (err != 0)\n    GOMP_PLUGIN_fatal (\"HSA asynchronous thread creation failed: %s\",\n\t\t       strerror (err));\n  err = pthread_detach (pt);\n  if (err != 0)\n    GOMP_PLUGIN_fatal (\"Failed to detach a thread to run HSA kernel \"\n\t\t       \"asynchronously: %s\", strerror (err));\n}\n\n/* Deinitialize all information associated with MODULE and kernels within\n   it.  Return TRUE on success.  */\n\nstatic bool\ndestroy_module (struct module_info *module)\n{\n  int i;\n  for (i = 0; i < module->kernel_count; i++)\n    if (pthread_mutex_destroy (&module->kernels[i].init_mutex))\n      {\n\tGOMP_PLUGIN_error (\"Failed to destroy an HSA kernel initialization \"\n\t\t\t   \"mutex\");\n\treturn false;\n      }\n  return true;\n}\n\n/* Part of the libgomp plugin interface.  Unload BRIG module described by\n   struct brig_image_desc in TARGET_DATA from agent number N.  Return\n   TRUE on success.  */\n\nbool\nGOMP_OFFLOAD_unload_image (int n, unsigned version, const void *target_data)\n{\n  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n    {\n      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n\t\t\t \" (expected %u, received %u)\",\n\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n      return false;\n    }\n\n  struct agent_info *agent;\n  agent = get_agent_info (n);\n  if (!agent)\n    return false;\n\n  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n    {\n      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n      return false;\n    }\n  struct module_info *module = agent->first_module;\n  while (module)\n    {\n      if (module->image_desc == target_data)\n\tbreak;\n      module = module->next;\n    }\n  if (!module)\n    {\n      GOMP_PLUGIN_error (\"Attempt to unload an image that has never been \"\n\t\t\t \"loaded before\");\n      return false;\n    }\n\n  remove_module_from_agent (agent, module);\n  if (!destroy_module (module))\n    return false;\n  free (module);\n  if (!destroy_hsa_program (agent))\n    return false;\n  if (pthread_rwlock_unlock (&agent->modules_rwlock))\n    {\n      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n      return false;\n    }\n  return true;\n}\n\n/* Part of the libgomp plugin interface.  Deinitialize all information and\n   status associated with agent number N.  We do not attempt any\n   synchronization, assuming the user and libgomp will not attempt\n   deinitialization of a device that is in any way being used at the same\n   time.  Return TRUE on success.  */\n\nbool\nGOMP_OFFLOAD_fini_device (int n)\n{\n  struct agent_info *agent = get_agent_info (n);\n  if (!agent)\n    return false;\n\n  if (!agent->initialized)\n    return true;\n\n  struct module_info *next_module = agent->first_module;\n  while (next_module)\n    {\n      struct module_info *module = next_module;\n      next_module = module->next;\n      if (!destroy_module (module))\n\treturn false;\n      free (module);\n    }\n  agent->first_module = NULL;\n  if (!destroy_hsa_program (agent))\n    return false;\n\n  release_agent_shared_libraries (agent);\n\n  hsa_status_t status = hsa_fns.hsa_queue_destroy_fn (agent->command_q);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error destroying command queue\", status);\n  status = hsa_fns.hsa_queue_destroy_fn (agent->kernel_dispatch_command_q);\n  if (status != HSA_STATUS_SUCCESS)\n    return hsa_error (\"Error destroying kernel dispatch command queue\", status);\n  if (pthread_mutex_destroy (&agent->prog_mutex))\n    {\n      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent program mutex\");\n      return false;\n    }\n  if (pthread_rwlock_destroy (&agent->modules_rwlock))\n    {\n      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent rwlock\");\n      return false;\n    }\n  agent->initialized = false;\n  return true;\n}\n\n/* Part of the libgomp plugin interface.  Not implemented as it is not required\n   for HSA.  */\n\nvoid *\nGOMP_OFFLOAD_alloc (int ord, size_t size)\n{\n  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_alloc is not implemented because \"\n\t\t     \"it should never be called\");\n  return NULL;\n}\n\n/* Part of the libgomp plugin interface.  Not implemented as it is not required\n   for HSA.  */\n\nbool\nGOMP_OFFLOAD_free (int ord, void *ptr)\n{\n  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_free is not implemented because \"\n\t\t     \"it should never be called\");\n  return false;\n}\n\n/* Part of the libgomp plugin interface.  Not implemented as it is not required\n   for HSA.  */\n\nbool\nGOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n{\n  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2host is not implemented because \"\n\t\t     \"it should never be called\");\n  return false;\n}\n\n/* Part of the libgomp plugin interface.  Not implemented as it is not required\n   for HSA.  */\n\nbool\nGOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n{\n  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_host2dev is not implemented because \"\n\t\t     \"it should never be called\");\n  return false;\n}\n\n/* Part of the libgomp plugin interface.  Not implemented as it is not required\n   for HSA.  */\n\nbool\nGOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n{\n  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2dev is not implemented because \"\n\t\t     \"it should never be called\");\n  return false;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgomp/plugin/configfrag.ac": "# Plugins for offload execution, configure.ac fragment.  -*- mode: autoconf -*-\n#\n# Copyright (C) 2014-2017 Free Software Foundation, Inc.\n#\n# Contributed by Mentor Embedded.\n#\n# This file is part of the GNU Offloading and Multi Processing Library\n# (libgomp).\n#\n# Libgomp is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3, or (at your option)\n# any later version.\n#\n# Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n#\n# Under Section 7 of GPL version 3, you are granted additional\n# permissions described in the GCC Runtime Library Exception, version\n# 3.1, as published by the Free Software Foundation.\n#\n# You should have received a copy of the GNU General Public License and\n# a copy of the GCC Runtime Library Exception along with this program;\n# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n# <http://www.gnu.org/licenses/>.\n\noffload_targets=\nAC_SUBST(offload_targets)\nplugin_support=yes\nAC_CHECK_LIB(dl, dlsym, , [plugin_support=no])\nif test x\"$plugin_support\" = xyes; then\n  AC_DEFINE(PLUGIN_SUPPORT, 1,\n    [Define if all infrastructure, needed for plugins, is supported.])\nelif test \"x${enable_offload_targets-no}\" != xno; then\n  AC_MSG_ERROR([Can't support offloading without support for plugins])\nfi\nAC_CHECK_HEADERS_ONCE(unistd.h)\nAC_CHECK_FUNCS_ONCE(secure_getenv __secure_getenv getuid geteuid getgid getegid)\n\n\n# Look for the CUDA driver package.\nCUDA_DRIVER_INCLUDE=\nCUDA_DRIVER_LIB=\nAC_SUBST(CUDA_DRIVER_INCLUDE)\nAC_SUBST(CUDA_DRIVER_LIB)\nCUDA_DRIVER_CPPFLAGS=\nCUDA_DRIVER_LDFLAGS=\nAC_ARG_WITH(cuda-driver,\n\t[AS_HELP_STRING([--with-cuda-driver=PATH],\n\t\t[specify prefix directory for installed CUDA driver package.\n\t\t Equivalent to --with-cuda-driver-include=PATH/include\n\t\t plus --with-cuda-driver-lib=PATH/lib])])\nAC_ARG_WITH(cuda-driver-include,\n\t[AS_HELP_STRING([--with-cuda-driver-include=PATH],\n\t\t[specify directory for installed CUDA driver include files])])\nAC_ARG_WITH(cuda-driver-lib,\n\t[AS_HELP_STRING([--with-cuda-driver-lib=PATH],\n\t\t[specify directory for the installed CUDA driver library])])\ncase \"x$with_cuda_driver\" in\n  x | xno) ;;\n  *) CUDA_DRIVER_INCLUDE=$with_cuda_driver/include\n     CUDA_DRIVER_LIB=$with_cuda_driver/lib\n     ;;\nesac\nif test \"x$with_cuda_driver_include\" != x; then\n  CUDA_DRIVER_INCLUDE=$with_cuda_driver_include\nfi\nif test \"x$with_cuda_driver_lib\" != x; then\n  CUDA_DRIVER_LIB=$with_cuda_driver_lib\nfi\nif test \"x$CUDA_DRIVER_INCLUDE\" != x; then\n  CUDA_DRIVER_CPPFLAGS=-I$CUDA_DRIVER_INCLUDE\nfi\nif test \"x$CUDA_DRIVER_LIB\" != x; then\n  CUDA_DRIVER_LDFLAGS=-L$CUDA_DRIVER_LIB\nfi\n\nPLUGIN_NVPTX=0\nPLUGIN_NVPTX_CPPFLAGS=\nPLUGIN_NVPTX_LDFLAGS=\nPLUGIN_NVPTX_LIBS=\nPLUGIN_NVPTX_DYNAMIC=0\nAC_SUBST(PLUGIN_NVPTX)\nAC_SUBST(PLUGIN_NVPTX_CPPFLAGS)\nAC_SUBST(PLUGIN_NVPTX_LDFLAGS)\nAC_SUBST(PLUGIN_NVPTX_LIBS)\n\n# Look for HSA run-time, its includes and libraries\n\nHSA_RUNTIME_INCLUDE=\nHSA_RUNTIME_LIB=\nAC_SUBST(HSA_RUNTIME_INCLUDE)\nAC_SUBST(HSA_RUNTIME_LIB)\nHSA_RUNTIME_CPPFLAGS=\nHSA_RUNTIME_LDFLAGS=\n\nAC_ARG_WITH(hsa-runtime,\n\t[AS_HELP_STRING([--with-hsa-runtime=PATH],\n\t\t[specify prefix directory for installed HSA run-time package.\n\t\t Equivalent to --with-hsa-runtime-include=PATH/include\n\t\t plus --with-hsa-runtime-lib=PATH/lib])])\nAC_ARG_WITH(hsa-runtime-include,\n\t[AS_HELP_STRING([--with-hsa-runtime-include=PATH],\n\t\t[specify directory for installed HSA run-time include files])])\nAC_ARG_WITH(hsa-runtime-lib,\n\t[AS_HELP_STRING([--with-hsa-runtime-lib=PATH],\n\t\t[specify directory for the installed HSA run-time library])])\nif test \"x$with_hsa_runtime\" != x; then\n  HSA_RUNTIME_INCLUDE=$with_hsa_runtime/include\n  HSA_RUNTIME_LIB=$with_hsa_runtime/lib\nfi\nif test \"x$with_hsa_runtime_include\" != x; then\n  HSA_RUNTIME_INCLUDE=$with_hsa_runtime_include\nfi\nif test \"x$with_hsa_runtime_lib\" != x; then\n  HSA_RUNTIME_LIB=$with_hsa_runtime_lib\nfi\nif test \"x$HSA_RUNTIME_INCLUDE\" != x; then\n  HSA_RUNTIME_CPPFLAGS=-I$HSA_RUNTIME_INCLUDE\nfi\nif test \"x$HSA_RUNTIME_LIB\" != x; then\n  HSA_RUNTIME_LDFLAGS=-L$HSA_RUNTIME_LIB\nfi\n\nPLUGIN_HSA=0\nPLUGIN_HSA_CPPFLAGS=\nPLUGIN_HSA_LDFLAGS=\nPLUGIN_HSA_LIBS=\nAC_SUBST(PLUGIN_HSA)\nAC_SUBST(PLUGIN_HSA_CPPFLAGS)\nAC_SUBST(PLUGIN_HSA_LDFLAGS)\nAC_SUBST(PLUGIN_HSA_LIBS)\n\n# Get offload targets and path to install tree of offloading compiler.\noffload_additional_options=\noffload_additional_lib_paths=\nAC_SUBST(offload_additional_options)\nAC_SUBST(offload_additional_lib_paths)\nif test x\"$enable_offload_targets\" != x; then\n  for tgt in `echo $enable_offload_targets | sed -e 's#,# #g'`; do\n    tgt_dir=`echo $tgt | grep '=' | sed 's/.*=//'`\n    tgt=`echo $tgt | sed 's/=.*//'`\n    tgt_name=\n    case $tgt in\n      *-intelmic-* | *-intelmicemul-*)\n\ttgt_name=intelmic\n\t;;\n      nvptx*)\n        tgt_name=nvptx\n\tPLUGIN_NVPTX=$tgt\n\tPLUGIN_NVPTX_CPPFLAGS=$CUDA_DRIVER_CPPFLAGS\n\tPLUGIN_NVPTX_LDFLAGS=$CUDA_DRIVER_LDFLAGS\n\tPLUGIN_NVPTX_LIBS='-lcuda'\n\n\tPLUGIN_NVPTX_save_CPPFLAGS=$CPPFLAGS\n\tCPPFLAGS=\"$PLUGIN_NVPTX_CPPFLAGS $CPPFLAGS\"\n\tPLUGIN_NVPTX_save_LDFLAGS=$LDFLAGS\n\tLDFLAGS=\"$PLUGIN_NVPTX_LDFLAGS $LDFLAGS\"\n\tPLUGIN_NVPTX_save_LIBS=$LIBS\n\tLIBS=\"$PLUGIN_NVPTX_LIBS $LIBS\"\n\tAC_LINK_IFELSE(\n\t  [AC_LANG_PROGRAM(\n\t    [#include \"cuda.h\"],\n\t      [CUresult r = cuCtxPushCurrent (NULL);])],\n\t  [PLUGIN_NVPTX=1])\n\tCPPFLAGS=$PLUGIN_NVPTX_save_CPPFLAGS\n\tLDFLAGS=$PLUGIN_NVPTX_save_LDFLAGS\n\tLIBS=$PLUGIN_NVPTX_save_LIBS\n\tcase $PLUGIN_NVPTX in\n\t  nvptx*)\n\t    if test \"x$CUDA_DRIVER_INCLUDE\" = x \\\n\t       && test \"x$CUDA_DRIVER_LIB\" = x; then\n\t      PLUGIN_NVPTX=1\n\t      PLUGIN_NVPTX_CPPFLAGS='-I$(srcdir)/plugin/cuda'\n\t      PLUGIN_NVPTX_LIBS='-ldl'\n\t      PLUGIN_NVPTX_DYNAMIC=1\n\t    else\n\t      PLUGIN_NVPTX=0\n\t      AC_MSG_ERROR([CUDA driver package required for nvptx support])\n\t    fi\n\t  ;;\n\tesac\n\t;;\n      hsa*)\n\tcase \"${target}\" in\n\t  x86_64-*-*)\n\t    case \" ${CC} ${CFLAGS} \" in\n\t      *\" -m32 \"*)\n\t        PLUGIN_HSA=0\n\t\t;;\n\t      *)\n\t        tgt_name=hsa\n\t        PLUGIN_HSA=$tgt\n\t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n\t        PLUGIN_HSA_LIBS=\"-ldl\"\n\n\t        PLUGIN_HSA_save_CPPFLAGS=$CPPFLAGS\n\t        CPPFLAGS=\"$PLUGIN_HSA_CPPFLAGS $CPPFLAGS\"\n\t        PLUGIN_HSA_save_LDFLAGS=$LDFLAGS\n\t        LDFLAGS=\"$PLUGIN_HSA_LDFLAGS $LDFLAGS\"\n\t        PLUGIN_HSA_save_LIBS=$LIBS\n\t        LIBS=\"$PLUGIN_HSA_LIBS $LIBS\"\n\n\t        PLUGIN_HSA=1\n\t        CPPFLAGS=$PLUGIN_HSA_save_CPPFLAGS\n\t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n\t        LIBS=$PLUGIN_HSA_save_LIBS\n\t        case $PLUGIN_HSA in\n\t          hsa*)\n\t            HSA_PLUGIN=0\n\t            AC_MSG_ERROR([HSA run-time package required for HSA support])\n\t            ;;\n\t        esac\n\t\t;;\n\t      esac\n    \t    ;;\n\t  *-*-*)\n\t    PLUGIN_HSA=0\n            ;;\n        esac\n        ;;\n      *)\n\tAC_MSG_ERROR([unknown offload target specified])\n\t;;\n    esac\n    if test x\"$tgt_name\" = x; then\n      # Don't configure libgomp for this offloading target if we don't build\n      # the corresponding plugin.\n      continue\n    elif test x\"$offload_targets\" = x; then\n      offload_targets=$tgt_name\n    else\n      offload_targets=$offload_targets,$tgt_name\n    fi\n    if test \"$tgt_name\" = hsa; then\n      # Offloading compilation is all handled by the target compiler.\n      :\n    elif test x\"$tgt_dir\" != x; then\n      offload_additional_options=\"$offload_additional_options -B$tgt_dir/libexec/gcc/\\$(target_alias)/\\$(gcc_version) -B$tgt_dir/bin\"\n      offload_additional_lib_paths=\"$offload_additional_lib_paths:$tgt_dir/lib64:$tgt_dir/lib:$tgt_dir/lib32\"\n    else\n      offload_additional_options=\"$offload_additional_options -B\\$(libexecdir)/gcc/\\$(target_alias)/\\$(gcc_version) -B\\$(bindir)\"\n      offload_additional_lib_paths=\"$offload_additional_lib_paths:$toolexeclibdir\"\n    fi\n  done\nfi\nAC_DEFINE_UNQUOTED(OFFLOAD_TARGETS, \"$offload_targets\",\n  [Define to offload targets, separated by commas.])\nAM_CONDITIONAL([PLUGIN_NVPTX], [test $PLUGIN_NVPTX = 1])\nAC_DEFINE_UNQUOTED([PLUGIN_NVPTX], [$PLUGIN_NVPTX],\n  [Define to 1 if the NVIDIA plugin is built, 0 if not.])\nAC_DEFINE_UNQUOTED([PLUGIN_NVPTX_DYNAMIC], [$PLUGIN_NVPTX_DYNAMIC],\n  [Define to 1 if the NVIDIA plugin should dlopen libcuda.so.1, 0 if it should be linked against it.])\nAM_CONDITIONAL([PLUGIN_HSA], [test $PLUGIN_HSA = 1])\nAC_DEFINE_UNQUOTED([PLUGIN_HSA], [$PLUGIN_HSA],\n  [Define to 1 if the HSA plugin is built, 0 if not.])\n\nif test \"$HSA_RUNTIME_LIB\" != \"\"; then\n  HSA_RUNTIME_LIB=\"$HSA_RUNTIME_LIB/\"\nfi\n\nAC_DEFINE_UNQUOTED([HSA_RUNTIME_LIB], [\"$HSA_RUNTIME_LIB\"],\n  [Define path to HSA runtime.])\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgomp/plugin/plugin-nvptx.c": "/* Plugin for NVPTX execution.\n\n   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n\n   Contributed by Mentor Embedded.\n\n   This file is part of the GNU Offloading and Multi Processing Library\n   (libgomp).\n\n   Libgomp is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n   more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* Nvidia PTX-specific parts of OpenACC support.  The cuda driver\n   library appears to hold some implicit state, but the documentation\n   is not clear as to what that state might be.  Or how one might\n   propagate it from one thread to another.  */\n\n#include \"openacc.h\"\n#include \"config.h\"\n#include \"libgomp-plugin.h\"\n#include \"oacc-plugin.h\"\n#include \"gomp-constants.h\"\n\n#include <pthread.h>\n#include <cuda.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <limits.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n#include <errno.h>\n\n#if PLUGIN_NVPTX_DYNAMIC\n# include <dlfcn.h>\n\n# define CUDA_CALLS \\\nCUDA_ONE_CALL (cuCtxCreate)\t\t\\\nCUDA_ONE_CALL (cuCtxDestroy)\t\t\\\nCUDA_ONE_CALL (cuCtxGetCurrent)\t\t\\\nCUDA_ONE_CALL (cuCtxGetDevice)\t\t\\\nCUDA_ONE_CALL (cuCtxPopCurrent)\t\t\\\nCUDA_ONE_CALL (cuCtxPushCurrent)\t\\\nCUDA_ONE_CALL (cuCtxSynchronize)\t\\\nCUDA_ONE_CALL (cuDeviceGet)\t\t\\\nCUDA_ONE_CALL (cuDeviceGetAttribute)\t\\\nCUDA_ONE_CALL (cuDeviceGetCount)\t\\\nCUDA_ONE_CALL (cuEventCreate)\t\t\\\nCUDA_ONE_CALL (cuEventDestroy)\t\t\\\nCUDA_ONE_CALL (cuEventElapsedTime)\t\\\nCUDA_ONE_CALL (cuEventQuery)\t\t\\\nCUDA_ONE_CALL (cuEventRecord)\t\t\\\nCUDA_ONE_CALL (cuEventSynchronize)\t\\\nCUDA_ONE_CALL (cuFuncGetAttribute)\t\\\nCUDA_ONE_CALL (cuGetErrorString)\t\\\nCUDA_ONE_CALL (cuInit)\t\t\t\\\nCUDA_ONE_CALL (cuLaunchKernel)\t\t\\\nCUDA_ONE_CALL (cuLinkAddData)\t\t\\\nCUDA_ONE_CALL (cuLinkComplete)\t\t\\\nCUDA_ONE_CALL (cuLinkCreate)\t\t\\\nCUDA_ONE_CALL (cuLinkDestroy)\t\t\\\nCUDA_ONE_CALL (cuMemAlloc)\t\t\\\nCUDA_ONE_CALL (cuMemAllocHost)\t\t\\\nCUDA_ONE_CALL (cuMemcpy)\t\t\\\nCUDA_ONE_CALL (cuMemcpyDtoDAsync)\t\\\nCUDA_ONE_CALL (cuMemcpyDtoH)\t\t\\\nCUDA_ONE_CALL (cuMemcpyDtoHAsync)\t\\\nCUDA_ONE_CALL (cuMemcpyHtoD)\t\t\\\nCUDA_ONE_CALL (cuMemcpyHtoDAsync)\t\\\nCUDA_ONE_CALL (cuMemFree)\t\t\\\nCUDA_ONE_CALL (cuMemFreeHost)\t\t\\\nCUDA_ONE_CALL (cuMemGetAddressRange)\t\\\nCUDA_ONE_CALL (cuMemHostGetDevicePointer)\\\nCUDA_ONE_CALL (cuModuleGetFunction)\t\\\nCUDA_ONE_CALL (cuModuleGetGlobal)\t\\\nCUDA_ONE_CALL (cuModuleLoad)\t\t\\\nCUDA_ONE_CALL (cuModuleLoadData)\t\\\nCUDA_ONE_CALL (cuModuleUnload)\t\t\\\nCUDA_ONE_CALL (cuStreamCreate)\t\t\\\nCUDA_ONE_CALL (cuStreamDestroy)\t\t\\\nCUDA_ONE_CALL (cuStreamQuery)\t\t\\\nCUDA_ONE_CALL (cuStreamSynchronize)\t\\\nCUDA_ONE_CALL (cuStreamWaitEvent)\n# define CUDA_ONE_CALL(call) \\\n  __typeof (call) *call;\nstruct cuda_lib_s {\n  CUDA_CALLS\n} cuda_lib;\n\n/* -1 if init_cuda_lib has not been called yet, false\n   if it has been and failed, true if it has been and succeeded.  */\nstatic signed char cuda_lib_inited = -1;\n\n/* Dynamically load the CUDA runtime library and initialize function\n   pointers, return false if unsuccessful, true if successful.  */\nstatic bool\ninit_cuda_lib (void)\n{\n  if (cuda_lib_inited != -1)\n    return cuda_lib_inited;\n  const char *cuda_runtime_lib = \"libcuda.so.1\";\n  void *h = dlopen (cuda_runtime_lib, RTLD_LAZY);\n  cuda_lib_inited = false;\n  if (h == NULL)\n    return false;\n# undef CUDA_ONE_CALL\n# define CUDA_ONE_CALL(call) CUDA_ONE_CALL_1 (call)\n# define CUDA_ONE_CALL_1(call) \\\n  cuda_lib.call = dlsym (h, #call);\t\\\n  if (cuda_lib.call == NULL)\t\t\\\n    return false;\n  CUDA_CALLS\n  cuda_lib_inited = true;\n  return true;\n}\n# undef CUDA_ONE_CALL\n# undef CUDA_ONE_CALL_1\n# define CUDA_CALL_PREFIX cuda_lib.\n#else\n# define CUDA_CALL_PREFIX\n# define init_cuda_lib() true\n#endif\n\n/* Convenience macros for the frequently used CUDA library call and\n   error handling sequence as well as CUDA library calls that\n   do the error checking themselves or don't do it at all.  */\n\n#define CUDA_CALL_ERET(ERET, FN, ...)\t\t\\\n  do {\t\t\t\t\t\t\\\n    unsigned __r\t\t\t\t\\\n      = CUDA_CALL_PREFIX FN (__VA_ARGS__);\t\\\n    if (__r != CUDA_SUCCESS)\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tGOMP_PLUGIN_error (#FN \" error: %s\",\t\\\n\t\t\t   cuda_error (__r));\t\\\n\treturn ERET;\t\t\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n#define CUDA_CALL(FN, ...)\t\t\t\\\n  CUDA_CALL_ERET (false, FN, __VA_ARGS__)\n\n#define CUDA_CALL_ASSERT(FN, ...)\t\t\\\n  do {\t\t\t\t\t\t\\\n    unsigned __r\t\t\t\t\\\n      = CUDA_CALL_PREFIX FN (__VA_ARGS__);\t\\\n    if (__r != CUDA_SUCCESS)\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tGOMP_PLUGIN_fatal (#FN \" error: %s\",\t\\\n\t\t\t   cuda_error (__r));\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n#define CUDA_CALL_NOCHECK(FN, ...)\t\t\\\n  CUDA_CALL_PREFIX FN (__VA_ARGS__)\n\nstatic const char *\ncuda_error (CUresult r)\n{\n#if CUDA_VERSION < 7000\n  /* Specified in documentation and present in library from at least\n     5.5.  Not declared in header file prior to 7.0.  */\n  extern CUresult cuGetErrorString (CUresult, const char **);\n#endif\n  const char *desc;\n\n  r = CUDA_CALL_NOCHECK (cuGetErrorString, r, &desc);\n  if (r != CUDA_SUCCESS)\n    desc = \"unknown cuda error\";\n\n  return desc;\n}\n\nstatic unsigned int instantiated_devices = 0;\nstatic pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstruct ptx_stream\n{\n  CUstream stream;\n  pthread_t host_thread;\n  bool multithreaded;\n\n  CUdeviceptr d;\n  void *h;\n  void *h_begin;\n  void *h_end;\n  void *h_next;\n  void *h_prev;\n  void *h_tail;\n\n  struct ptx_stream *next;\n};\n\n/* Thread-specific data for PTX.  */\n\nstruct nvptx_thread\n{\n  struct ptx_stream *current_stream;\n  struct ptx_device *ptx_dev;\n};\n\nstruct map\n{\n  int     async;\n  size_t  size;\n  char    mappings[0];\n};\n\nstatic bool\nmap_init (struct ptx_stream *s)\n{\n  int size = getpagesize ();\n\n  assert (s);\n  assert (!s->d);\n  assert (!s->h);\n\n  CUDA_CALL (cuMemAllocHost, &s->h, size);\n  CUDA_CALL (cuMemHostGetDevicePointer, &s->d, s->h, 0);\n\n  assert (s->h);\n\n  s->h_begin = s->h;\n  s->h_end = s->h_begin + size;\n  s->h_next = s->h_prev = s->h_tail = s->h_begin;\n\n  assert (s->h_next);\n  assert (s->h_end);\n  return true;\n}\n\nstatic bool\nmap_fini (struct ptx_stream *s)\n{\n  CUDA_CALL (cuMemFreeHost, s->h);\n  return true;\n}\n\nstatic void\nmap_pop (struct ptx_stream *s)\n{\n  struct map *m;\n\n  assert (s != NULL);\n  assert (s->h_next);\n  assert (s->h_prev);\n  assert (s->h_tail);\n\n  m = s->h_tail;\n\n  s->h_tail += m->size;\n\n  if (s->h_tail >= s->h_end)\n    s->h_tail = s->h_begin + (int) (s->h_tail - s->h_end);\n\n  if (s->h_next == s->h_tail)\n    s->h_prev = s->h_next;\n\n  assert (s->h_next >= s->h_begin);\n  assert (s->h_tail >= s->h_begin);\n  assert (s->h_prev >= s->h_begin);\n\n  assert (s->h_next <= s->h_end);\n  assert (s->h_tail <= s->h_end);\n  assert (s->h_prev <= s->h_end);\n}\n\nstatic void\nmap_push (struct ptx_stream *s, int async, size_t size, void **h, void **d)\n{\n  int left;\n  int offset;\n  struct map *m;\n\n  assert (s != NULL);\n\n  left = s->h_end - s->h_next;\n  size += sizeof (struct map);\n\n  assert (s->h_prev);\n  assert (s->h_next);\n\n  if (size >= left)\n    {\n      m = s->h_prev;\n      m->size += left;\n      s->h_next = s->h_begin;\n\n      if (s->h_next + size > s->h_end)\n\tGOMP_PLUGIN_fatal (\"unable to push map\");\n    }\n\n  assert (s->h_next);\n\n  m = s->h_next;\n  m->async = async;\n  m->size = size;\n\n  offset = (void *)&m->mappings[0] - s->h;\n\n  *d = (void *)(s->d + offset);\n  *h = (void *)(s->h + offset);\n\n  s->h_prev = s->h_next;\n  s->h_next += size;\n\n  assert (s->h_prev);\n  assert (s->h_next);\n\n  assert (s->h_next >= s->h_begin);\n  assert (s->h_tail >= s->h_begin);\n  assert (s->h_prev >= s->h_begin);\n  assert (s->h_next <= s->h_end);\n  assert (s->h_tail <= s->h_end);\n  assert (s->h_prev <= s->h_end);\n\n  return;\n}\n\n/* Target data function launch information.  */\n\nstruct targ_fn_launch\n{\n  const char *fn;\n  unsigned short dim[GOMP_DIM_MAX];\n};\n\n/* Target PTX object information.  */\n\nstruct targ_ptx_obj\n{\n  const char *code;\n  size_t size;\n};\n\n/* Target data image information.  */\n\ntypedef struct nvptx_tdata\n{\n  const struct targ_ptx_obj *ptx_objs;\n  unsigned ptx_num;\n\n  const char *const *var_names;\n  unsigned var_num;\n\n  const struct targ_fn_launch *fn_descs;\n  unsigned fn_num;\n} nvptx_tdata_t;\n\n/* Descriptor of a loaded function.  */\n\nstruct targ_fn_descriptor\n{\n  CUfunction fn;\n  const struct targ_fn_launch *launch;\n  int regs_per_thread;\n  int max_threads_per_block;\n};\n\n/* A loaded PTX image.  */\nstruct ptx_image_data\n{\n  const void *target_data;\n  CUmodule module;\n\n  struct targ_fn_descriptor *fns;  /* Array of functions.  */\n  \n  struct ptx_image_data *next;\n};\n\nstruct ptx_device\n{\n  CUcontext ctx;\n  bool ctx_shared;\n  CUdevice dev;\n  struct ptx_stream *null_stream;\n  /* All non-null streams associated with this device (actually context),\n     either created implicitly or passed in from the user (via\n     acc_set_cuda_stream).  */\n  struct ptx_stream *active_streams;\n  struct {\n    struct ptx_stream **arr;\n    int size;\n  } async_streams;\n  /* A lock for use when manipulating the above stream list and array.  */\n  pthread_mutex_t stream_lock;\n  int ord;\n  bool overlap;\n  bool map;\n  bool concur;\n  bool mkern;\n  int  mode;\n  int clock_khz;\n  int num_sms;\n  int regs_per_block;\n  int regs_per_sm;\n\n  struct ptx_image_data *images;  /* Images loaded on device.  */\n  pthread_mutex_t image_lock;     /* Lock for above list.  */\n  \n  struct ptx_device *next;\n};\n\nenum ptx_event_type\n{\n  PTX_EVT_MEM,\n  PTX_EVT_KNL,\n  PTX_EVT_SYNC,\n  PTX_EVT_ASYNC_CLEANUP\n};\n\nstruct ptx_event\n{\n  CUevent *evt;\n  int type;\n  void *addr;\n  int ord;\n  int val;\n\n  struct ptx_event *next;\n};\n\nstatic pthread_mutex_t ptx_event_lock;\nstatic struct ptx_event *ptx_events;\n\nstatic struct ptx_device **ptx_devices;\n\nstatic inline struct nvptx_thread *\nnvptx_thread (void)\n{\n  return (struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n}\n\nstatic bool\ninit_streams_for_device (struct ptx_device *ptx_dev, int concurrency)\n{\n  int i;\n  struct ptx_stream *null_stream\n    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));\n\n  null_stream->stream = NULL;\n  null_stream->host_thread = pthread_self ();\n  null_stream->multithreaded = true;\n  null_stream->d = (CUdeviceptr) NULL;\n  null_stream->h = NULL;\n  if (!map_init (null_stream))\n    return false;\n\n  ptx_dev->null_stream = null_stream;\n  ptx_dev->active_streams = NULL;\n  pthread_mutex_init (&ptx_dev->stream_lock, NULL);\n\n  if (concurrency < 1)\n    concurrency = 1;\n\n  /* This is just a guess -- make space for as many async streams as the\n     current device is capable of concurrently executing.  This can grow\n     later as necessary.  No streams are created yet.  */\n  ptx_dev->async_streams.arr\n    = GOMP_PLUGIN_malloc (concurrency * sizeof (struct ptx_stream *));\n  ptx_dev->async_streams.size = concurrency;\n\n  for (i = 0; i < concurrency; i++)\n    ptx_dev->async_streams.arr[i] = NULL;\n\n  return true;\n}\n\nstatic bool\nfini_streams_for_device (struct ptx_device *ptx_dev)\n{\n  free (ptx_dev->async_streams.arr);\n\n  bool ret = true;\n  while (ptx_dev->active_streams != NULL)\n    {\n      struct ptx_stream *s = ptx_dev->active_streams;\n      ptx_dev->active_streams = ptx_dev->active_streams->next;\n\n      ret &= map_fini (s);\n\n      CUresult r = CUDA_CALL_NOCHECK (cuStreamDestroy, s->stream);\n      if (r != CUDA_SUCCESS)\n\t{\n\t  GOMP_PLUGIN_error (\"cuStreamDestroy error: %s\", cuda_error (r));\n\t  ret = false;\n\t}\n      free (s);\n    }\n\n  ret &= map_fini (ptx_dev->null_stream);\n  free (ptx_dev->null_stream);\n  return ret;\n}\n\n/* Select a stream for (OpenACC-semantics) ASYNC argument for the current\n   thread THREAD (and also current device/context).  If CREATE is true, create\n   the stream if it does not exist (or use EXISTING if it is non-NULL), and\n   associate the stream with the same thread argument.  Returns stream to use\n   as result.  */\n\nstatic struct ptx_stream *\nselect_stream_for_async (int async, pthread_t thread, bool create,\n\t\t\t CUstream existing)\n{\n  struct nvptx_thread *nvthd = nvptx_thread ();\n  /* Local copy of TLS variable.  */\n  struct ptx_device *ptx_dev = nvthd->ptx_dev;\n  struct ptx_stream *stream = NULL;\n  int orig_async = async;\n\n  /* The special value acc_async_noval (-1) maps (for now) to an\n     implicitly-created stream, which is then handled the same as any other\n     numbered async stream.  Other options are available, e.g. using the null\n     stream for anonymous async operations, or choosing an idle stream from an\n     active set.  But, stick with this for now.  */\n  if (async > acc_async_sync)\n    async++;\n\n  if (create)\n    pthread_mutex_lock (&ptx_dev->stream_lock);\n\n  /* NOTE: AFAICT there's no particular need for acc_async_sync to map to the\n     null stream, and in fact better performance may be obtainable if it doesn't\n     (because the null stream enforces overly-strict synchronisation with\n     respect to other streams for legacy reasons, and that's probably not\n     needed with OpenACC).  Maybe investigate later.  */\n  if (async == acc_async_sync)\n    stream = ptx_dev->null_stream;\n  else if (async >= 0 && async < ptx_dev->async_streams.size\n\t   && ptx_dev->async_streams.arr[async] && !(create && existing))\n    stream = ptx_dev->async_streams.arr[async];\n  else if (async >= 0 && create)\n    {\n      if (async >= ptx_dev->async_streams.size)\n\t{\n\t  int i, newsize = ptx_dev->async_streams.size * 2;\n\n\t  if (async >= newsize)\n\t    newsize = async + 1;\n\n\t  ptx_dev->async_streams.arr\n\t    = GOMP_PLUGIN_realloc (ptx_dev->async_streams.arr,\n\t\t\t\t   newsize * sizeof (struct ptx_stream *));\n\n\t  for (i = ptx_dev->async_streams.size; i < newsize; i++)\n\t    ptx_dev->async_streams.arr[i] = NULL;\n\n\t  ptx_dev->async_streams.size = newsize;\n\t}\n\n      /* Create a new stream on-demand if there isn't one already, or if we're\n\t setting a particular async value to an existing (externally-provided)\n\t stream.  */\n      if (!ptx_dev->async_streams.arr[async] || existing)\n        {\n\t  CUresult r;\n\t  struct ptx_stream *s\n\t    = GOMP_PLUGIN_malloc (sizeof (struct ptx_stream));\n\n\t  if (existing)\n\t    s->stream = existing;\n\t  else\n\t    {\n\t      r = CUDA_CALL_NOCHECK (cuStreamCreate, &s->stream,\n\t\t\t\t     CU_STREAM_DEFAULT);\n\t      if (r != CUDA_SUCCESS)\n\t\t{\n\t\t  pthread_mutex_unlock (&ptx_dev->stream_lock);\n\t\t  GOMP_PLUGIN_fatal (\"cuStreamCreate error: %s\",\n\t\t\t\t     cuda_error (r));\n\t\t}\n\t    }\n\n\t  /* If CREATE is true, we're going to be queueing some work on this\n\t     stream.  Associate it with the current host thread.  */\n\t  s->host_thread = thread;\n\t  s->multithreaded = false;\n\n\t  s->d = (CUdeviceptr) NULL;\n\t  s->h = NULL;\n\t  if (!map_init (s))\n\t    {\n\t      pthread_mutex_unlock (&ptx_dev->stream_lock);\n\t      GOMP_PLUGIN_fatal (\"map_init fail\");\n\t    }\n\n\t  s->next = ptx_dev->active_streams;\n\t  ptx_dev->active_streams = s;\n\t  ptx_dev->async_streams.arr[async] = s;\n\t}\n\n      stream = ptx_dev->async_streams.arr[async];\n    }\n  else if (async < 0)\n    {\n      if (create)\n\tpthread_mutex_unlock (&ptx_dev->stream_lock);\n      GOMP_PLUGIN_fatal (\"bad async %d\", async);\n    }\n\n  if (create)\n    {\n      assert (stream != NULL);\n\n      /* If we're trying to use the same stream from different threads\n\t simultaneously, set stream->multithreaded to true.  This affects the\n\t behaviour of acc_async_test_all and acc_wait_all, which are supposed to\n\t only wait for asynchronous launches from the same host thread they are\n\t invoked on.  If multiple threads use the same async value, we make note\n\t of that here and fall back to testing/waiting for all threads in those\n\t functions.  */\n      if (thread != stream->host_thread)\n        stream->multithreaded = true;\n\n      pthread_mutex_unlock (&ptx_dev->stream_lock);\n    }\n  else if (stream && !stream->multithreaded\n\t   && !pthread_equal (stream->host_thread, thread))\n    GOMP_PLUGIN_fatal (\"async %d used on wrong thread\", orig_async);\n\n  return stream;\n}\n\n/* Initialize the device.  Return TRUE on success, else FALSE.  PTX_DEV_LOCK\n   should be locked on entry and remains locked on exit.  */\n\nstatic bool\nnvptx_init (void)\n{\n  int ndevs;\n\n  if (instantiated_devices != 0)\n    return true;\n\n  ptx_events = NULL;\n  pthread_mutex_init (&ptx_event_lock, NULL);\n\n  if (!init_cuda_lib ())\n    return false;\n\n  CUDA_CALL (cuInit, 0);\n\n  CUDA_CALL (cuDeviceGetCount, &ndevs);\n  ptx_devices = GOMP_PLUGIN_malloc_cleared (sizeof (struct ptx_device *)\n\t\t\t\t\t    * ndevs);\n  return true;\n}\n\n/* Select the N'th PTX device for the current host thread.  The device must\n   have been previously opened before calling this function.  */\n\nstatic bool\nnvptx_attach_host_thread_to_device (int n)\n{\n  CUdevice dev;\n  CUresult r;\n  struct ptx_device *ptx_dev;\n  CUcontext thd_ctx;\n\n  r = CUDA_CALL_NOCHECK (cuCtxGetDevice, &dev);\n  if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n    {\n      GOMP_PLUGIN_error (\"cuCtxGetDevice error: %s\", cuda_error (r));\n      return false;\n    }\n\n  if (r != CUDA_ERROR_INVALID_CONTEXT && dev == n)\n    return true;\n  else\n    {\n      CUcontext old_ctx;\n\n      ptx_dev = ptx_devices[n];\n      if (!ptx_dev)\n\t{\n\t  GOMP_PLUGIN_error (\"device %d not found\", n);\n\t  return false;\n\t}\n\n      CUDA_CALL (cuCtxGetCurrent, &thd_ctx);\n\n      /* We don't necessarily have a current context (e.g. if it has been\n         destroyed.  Pop it if we do though.  */\n      if (thd_ctx != NULL)\n\tCUDA_CALL (cuCtxPopCurrent, &old_ctx);\n\n      CUDA_CALL (cuCtxPushCurrent, ptx_dev->ctx);\n    }\n  return true;\n}\n\nstatic struct ptx_device *\nnvptx_open_device (int n)\n{\n  struct ptx_device *ptx_dev;\n  CUdevice dev, ctx_dev;\n  CUresult r;\n  int async_engines, pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGet, &dev, n);\n\n  ptx_dev = GOMP_PLUGIN_malloc (sizeof (struct ptx_device));\n\n  ptx_dev->ord = n;\n  ptx_dev->dev = dev;\n  ptx_dev->ctx_shared = false;\n\n  r = CUDA_CALL_NOCHECK (cuCtxGetDevice, &ctx_dev);\n  if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n    {\n      GOMP_PLUGIN_error (\"cuCtxGetDevice error: %s\", cuda_error (r));\n      return NULL;\n    }\n  \n  if (r != CUDA_ERROR_INVALID_CONTEXT && ctx_dev != dev)\n    {\n      /* The current host thread has an active context for a different device.\n         Detach it.  */\n      CUcontext old_ctx;\n      CUDA_CALL_ERET (NULL, cuCtxPopCurrent, &old_ctx);\n    }\n\n  CUDA_CALL_ERET (NULL, cuCtxGetCurrent, &ptx_dev->ctx);\n\n  if (!ptx_dev->ctx)\n    CUDA_CALL_ERET (NULL, cuCtxCreate, &ptx_dev->ctx, CU_CTX_SCHED_AUTO, dev);\n  else\n    ptx_dev->ctx_shared = true;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, dev);\n  ptx_dev->overlap = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, dev);\n  ptx_dev->map = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, dev);\n  ptx_dev->concur = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, dev);\n  ptx_dev->mode = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev);\n  ptx_dev->mkern = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_CLOCK_RATE, dev);\n  ptx_dev->clock_khz = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, dev);\n  ptx_dev->num_sms = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, dev);\n  ptx_dev->regs_per_block = pi;\n\n  /* CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82 is defined only\n     in CUDA 6.0 and newer.  */\n  r = CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &pi, 82, dev);\n  /* Fallback: use limit of registers per block, which is usually equal.  */\n  if (r == CUDA_ERROR_INVALID_VALUE)\n    pi = ptx_dev->regs_per_block;\n  else if (r != CUDA_SUCCESS)\n    {\n      GOMP_PLUGIN_error (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n      return NULL;\n    }\n  ptx_dev->regs_per_sm = pi;\n\n  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n\t\t  &pi, CU_DEVICE_ATTRIBUTE_WARP_SIZE, dev);\n  if (pi != 32)\n    {\n      GOMP_PLUGIN_error (\"Only warp size 32 is supported\");\n      return NULL;\n    }\n\n  r = CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &async_engines,\n\t\t\t CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, dev);\n  if (r != CUDA_SUCCESS)\n    async_engines = 1;\n\n  ptx_dev->images = NULL;\n  pthread_mutex_init (&ptx_dev->image_lock, NULL);\n\n  if (!init_streams_for_device (ptx_dev, async_engines))\n    return NULL;\n\n  return ptx_dev;\n}\n\nstatic bool\nnvptx_close_device (struct ptx_device *ptx_dev)\n{\n  if (!ptx_dev)\n    return true;\n\n  if (!fini_streams_for_device (ptx_dev))\n    return false;\n  \n  pthread_mutex_destroy (&ptx_dev->image_lock);\n\n  if (!ptx_dev->ctx_shared)\n    CUDA_CALL (cuCtxDestroy, ptx_dev->ctx);\n\n  free (ptx_dev);\n  return true;\n}\n\nstatic int\nnvptx_get_num_devices (void)\n{\n  int n;\n\n  /* PR libgomp/65099: Currently, we only support offloading in 64-bit\n     configurations.  */\n  if (sizeof (void *) != 8)\n    return 0;\n\n  /* This function will be called before the plugin has been initialized in\n     order to enumerate available devices, but CUDA API routines can't be used\n     until cuInit has been called.  Just call it now (but don't yet do any\n     further initialization).  */\n  if (instantiated_devices == 0)\n    {\n      if (!init_cuda_lib ())\n\treturn 0;\n      CUresult r = CUDA_CALL_NOCHECK (cuInit, 0);\n      /* This is not an error: e.g. we may have CUDA libraries installed but\n         no devices available.  */\n      if (r != CUDA_SUCCESS)\n        return 0;\n    }\n\n  CUDA_CALL_ERET (-1, cuDeviceGetCount, &n);\n  return n;\n}\n\n\nstatic bool\nlink_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n\t  unsigned num_objs)\n{\n  CUjit_option opts[6];\n  void *optvals[6];\n  float elapsed = 0.0;\n  char elog[1024];\n  char ilog[16384];\n  CUlinkState linkstate;\n  CUresult r;\n  void *linkout;\n  size_t linkoutsize __attribute__ ((unused));\n\n  opts[0] = CU_JIT_WALL_TIME;\n  optvals[0] = &elapsed;\n\n  opts[1] = CU_JIT_INFO_LOG_BUFFER;\n  optvals[1] = &ilog[0];\n\n  opts[2] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;\n  optvals[2] = (void *) sizeof ilog;\n\n  opts[3] = CU_JIT_ERROR_LOG_BUFFER;\n  optvals[3] = &elog[0];\n\n  opts[4] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;\n  optvals[4] = (void *) sizeof elog;\n\n  opts[5] = CU_JIT_LOG_VERBOSE;\n  optvals[5] = (void *) 1;\n\n  CUDA_CALL (cuLinkCreate, 6, opts, optvals, &linkstate);\n\n  for (; num_objs--; ptx_objs++)\n    {\n      /* cuLinkAddData's 'data' argument erroneously omits the const\n\t qualifier.  */\n      GOMP_PLUGIN_debug (0, \"Loading:\\n---\\n%s\\n---\\n\", ptx_objs->code);\n      r = CUDA_CALL_NOCHECK (cuLinkAddData, linkstate, CU_JIT_INPUT_PTX,\n\t\t\t     (char *) ptx_objs->code, ptx_objs->size,\n\t\t\t     0, 0, 0, 0);\n      if (r != CUDA_SUCCESS)\n\t{\n\t  GOMP_PLUGIN_error (\"Link error log %s\\n\", &elog[0]);\n\t  GOMP_PLUGIN_error (\"cuLinkAddData (ptx_code) error: %s\",\n\t\t\t     cuda_error (r));\n\t  return false;\n\t}\n    }\n\n  GOMP_PLUGIN_debug (0, \"Linking\\n\");\n  r = CUDA_CALL_NOCHECK (cuLinkComplete, linkstate, &linkout, &linkoutsize);\n\n  GOMP_PLUGIN_debug (0, \"Link complete: %fms\\n\", elapsed);\n  GOMP_PLUGIN_debug (0, \"Link log %s\\n\", &ilog[0]);\n\n  if (r != CUDA_SUCCESS)\n    {\n      GOMP_PLUGIN_error (\"cuLinkComplete error: %s\", cuda_error (r));\n      return false;\n    }\n\n  CUDA_CALL (cuModuleLoadData, module, linkout);\n  CUDA_CALL (cuLinkDestroy, linkstate);\n  return true;\n}\n\nstatic void\nevent_gc (bool memmap_lockable)\n{\n  struct ptx_event *ptx_event = ptx_events;\n  struct ptx_event *async_cleanups = NULL;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  pthread_mutex_lock (&ptx_event_lock);\n\n  while (ptx_event != NULL)\n    {\n      CUresult r;\n      struct ptx_event *e = ptx_event;\n\n      ptx_event = ptx_event->next;\n\n      if (e->ord != nvthd->ptx_dev->ord)\n\tcontinue;\n\n      r = CUDA_CALL_NOCHECK (cuEventQuery, *e->evt);\n      if (r == CUDA_SUCCESS)\n\t{\n\t  bool append_async = false;\n\t  CUevent *te;\n\n\t  te = e->evt;\n\n\t  switch (e->type)\n\t    {\n\t    case PTX_EVT_MEM:\n\t    case PTX_EVT_SYNC:\n\t      break;\n\n\t    case PTX_EVT_KNL:\n\t      map_pop (e->addr);\n\t      break;\n\n\t    case PTX_EVT_ASYNC_CLEANUP:\n\t      {\n\t\t/* The function gomp_plugin_async_unmap_vars needs to claim the\n\t\t   memory-map splay tree lock for the current device, so we\n\t\t   can't call it when one of our callers has already claimed\n\t\t   the lock.  In that case, just delay the GC for this event\n\t\t   until later.  */\n\t\tif (!memmap_lockable)\n\t\t  continue;\n\n\t\tappend_async = true;\n\t      }\n\t      break;\n\t    }\n\n\t  CUDA_CALL_NOCHECK (cuEventDestroy, *te);\n\t  free ((void *)te);\n\n\t  /* Unlink 'e' from ptx_events list.  */\n\t  if (ptx_events == e)\n\t    ptx_events = ptx_events->next;\n\t  else\n\t    {\n\t      struct ptx_event *e_ = ptx_events;\n\t      while (e_->next != e)\n\t\te_ = e_->next;\n\t      e_->next = e_->next->next;\n\t    }\n\n\t  if (append_async)\n\t    {\n\t      e->next = async_cleanups;\n\t      async_cleanups = e;\n\t    }\n\t  else\n\t    free (e);\n\t}\n    }\n\n  pthread_mutex_unlock (&ptx_event_lock);\n\n  /* We have to do these here, after ptx_event_lock is released.  */\n  while (async_cleanups)\n    {\n      struct ptx_event *e = async_cleanups;\n      async_cleanups = async_cleanups->next;\n\n      GOMP_PLUGIN_async_unmap_vars (e->addr, e->val);\n      free (e);\n    }\n}\n\nstatic void\nevent_add (enum ptx_event_type type, CUevent *e, void *h, int val)\n{\n  struct ptx_event *ptx_event;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  assert (type == PTX_EVT_MEM || type == PTX_EVT_KNL || type == PTX_EVT_SYNC\n\t  || type == PTX_EVT_ASYNC_CLEANUP);\n\n  ptx_event = GOMP_PLUGIN_malloc (sizeof (struct ptx_event));\n  ptx_event->type = type;\n  ptx_event->evt = e;\n  ptx_event->addr = h;\n  ptx_event->ord = nvthd->ptx_dev->ord;\n  ptx_event->val = val;\n\n  pthread_mutex_lock (&ptx_event_lock);\n\n  ptx_event->next = ptx_events;\n  ptx_events = ptx_event;\n\n  pthread_mutex_unlock (&ptx_event_lock);\n}\n\nstatic void\nnvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n\t    int async, unsigned *dims, void *targ_mem_desc)\n{\n  struct targ_fn_descriptor *targ_fn = (struct targ_fn_descriptor *) fn;\n  CUfunction function;\n  CUresult r;\n  int i;\n  struct ptx_stream *dev_str;\n  void *kargs[1];\n  void *hp, *dp;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n  const char *maybe_abort_msg = \"(perhaps abort was called)\";\n\n  function = targ_fn->fn;\n\n  dev_str = select_stream_for_async (async, pthread_self (), false, NULL);\n  assert (dev_str == nvthd->current_stream);\n\n  /* Initialize the launch dimensions.  Typically this is constant,\n     provided by the device compiler, but we must permit runtime\n     values.  */\n  int seen_zero = 0;\n  for (i = 0; i != GOMP_DIM_MAX; i++)\n    {\n      if (targ_fn->launch->dim[i])\n       dims[i] = targ_fn->launch->dim[i];\n      if (!dims[i])\n       seen_zero = 1;\n    }\n\n  if (seen_zero)\n    {\n      /* See if the user provided GOMP_OPENACC_DIM environment\n\t variable to specify runtime defaults. */\n      static int default_dims[GOMP_DIM_MAX];\n\n      pthread_mutex_lock (&ptx_dev_lock);\n      if (!default_dims[0])\n\t{\n\t  /* We only read the environment variable once.  You can't\n\t     change it in the middle of execution.  The syntax  is\n\t     the same as for the -fopenacc-dim compilation option.  */\n\t  const char *env_var = getenv (\"GOMP_OPENACC_DIM\");\n\t  if (env_var)\n\t    {\n\t      const char *pos = env_var;\n\n\t      for (i = 0; *pos && i != GOMP_DIM_MAX; i++)\n\t\t{\n\t\t  if (i && *pos++ != ':')\n\t\t    break;\n\t\t  if (*pos != ':')\n\t\t    {\n\t\t      const char *eptr;\n\n\t\t      errno = 0;\n\t\t      long val = strtol (pos, (char **)&eptr, 10);\n\t\t      if (errno || val < 0 || (unsigned)val != val)\n\t\t\tbreak;\n\t\t      default_dims[i] = (int)val;\n\t\t      pos = eptr;\n\t\t    }\n\t\t}\n\t    }\n\n\t  int warp_size, block_size, dev_size, cpu_size;\n\t  CUdevice dev = nvptx_thread()->ptx_dev->dev;\n\t  /* 32 is the default for known hardware.  */\n\t  int gang = 0, worker = 32, vector = 32;\n\t  CUdevice_attribute cu_tpb, cu_ws, cu_mpc, cu_tpm;\n\n\t  cu_tpb = CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK;\n\t  cu_ws = CU_DEVICE_ATTRIBUTE_WARP_SIZE;\n\t  cu_mpc = CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT;\n\t  cu_tpm  = CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR;\n\n\t  if (CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &block_size, cu_tpb,\n\t\t\t\t dev) == CUDA_SUCCESS\n\t      && CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &warp_size, cu_ws,\n\t\t\t\t    dev) == CUDA_SUCCESS\n\t      && CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &dev_size, cu_mpc,\n\t\t\t\t    dev) == CUDA_SUCCESS\n\t      && CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &cpu_size, cu_tpm,\n\t\t\t\t    dev) == CUDA_SUCCESS)\n\t    {\n\t      GOMP_PLUGIN_debug (0, \" warp_size=%d, block_size=%d,\"\n\t\t\t\t \" dev_size=%d, cpu_size=%d\\n\",\n\t\t\t\t warp_size, block_size, dev_size, cpu_size);\n\t      gang = (cpu_size / block_size) * dev_size;\n\t      worker = block_size / warp_size;\n\t      vector = warp_size;\n\t    }\n\n\t  /* There is no upper bound on the gang size.  The best size\n\t     matches the hardware configuration.  Logical gangs are\n\t     scheduled onto physical hardware.  To maximize usage, we\n\t     should guess a large number.  */\n\t  if (default_dims[GOMP_DIM_GANG] < 1)\n\t    default_dims[GOMP_DIM_GANG] = gang ? gang : 1024;\n\t  /* The worker size must not exceed the hardware.  */\n\t  if (default_dims[GOMP_DIM_WORKER] < 1\n\t      || (default_dims[GOMP_DIM_WORKER] > worker && gang))\n\t    default_dims[GOMP_DIM_WORKER] = worker;\n\t  /* The vector size must exactly match the hardware.  */\n\t  if (default_dims[GOMP_DIM_VECTOR] < 1\n\t      || (default_dims[GOMP_DIM_VECTOR] != vector && gang))\n\t    default_dims[GOMP_DIM_VECTOR] = vector;\n\n\t  GOMP_PLUGIN_debug (0, \" default dimensions [%d,%d,%d]\\n\",\n\t\t\t     default_dims[GOMP_DIM_GANG],\n\t\t\t     default_dims[GOMP_DIM_WORKER],\n\t\t\t     default_dims[GOMP_DIM_VECTOR]);\n\t}\n      pthread_mutex_unlock (&ptx_dev_lock);\n\n      for (i = 0; i != GOMP_DIM_MAX; i++)\n\tif (!dims[i])\n\t  dims[i] = default_dims[i];\n    }\n\n  /* This reserves a chunk of a pre-allocated page of memory mapped on both\n     the host and the device. HP is a host pointer to the new chunk, and DP is\n     the corresponding device pointer.  */\n  map_push (dev_str, async, mapnum * sizeof (void *), &hp, &dp);\n\n  GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n\n  /* Copy the array of arguments to the mapped page.  */\n  for (i = 0; i < mapnum; i++)\n    ((void **) hp)[i] = devaddrs[i];\n\n  /* Copy the (device) pointers to arguments to the device (dp and hp might in\n     fact have the same value on a unified-memory system).  */\n  CUDA_CALL_ASSERT (cuMemcpy, (CUdeviceptr) dp, (CUdeviceptr) hp,\n\t\t    mapnum * sizeof (void *));\n  GOMP_PLUGIN_debug (0, \"  %s: kernel %s: launch\"\n\t\t     \" gangs=%u, workers=%u, vectors=%u\\n\",\n\t\t     __FUNCTION__, targ_fn->launch->fn, dims[GOMP_DIM_GANG],\n\t\t     dims[GOMP_DIM_WORKER], dims[GOMP_DIM_VECTOR]);\n\n  // OpenACC\t\tCUDA\n  //\n  // num_gangs\t\tnctaid.x\n  // num_workers\tntid.y\n  // vector length\tntid.x\n\n  kargs[0] = &dp;\n  CUDA_CALL_ASSERT (cuLaunchKernel, function,\n\t\t    dims[GOMP_DIM_GANG], 1, 1,\n\t\t    dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,\n\t\t    0, dev_str->stream, kargs, 0);\n\n#ifndef DISABLE_ASYNC\n  if (async < acc_async_noval)\n    {\n      r = CUDA_CALL_NOCHECK (cuStreamSynchronize, dev_str->stream);\n      if (r == CUDA_ERROR_LAUNCH_FAILED)\n\tGOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s %s\\n\", cuda_error (r),\n\t\t\t   maybe_abort_msg);\n      else if (r != CUDA_SUCCESS)\n        GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n    }\n  else\n    {\n      CUevent *e;\n\n      e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n\n      r = CUDA_CALL_NOCHECK (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n      if (r == CUDA_ERROR_LAUNCH_FAILED)\n\tGOMP_PLUGIN_fatal (\"cuEventCreate error: %s %s\\n\", cuda_error (r),\n\t\t\t   maybe_abort_msg);\n      else if (r != CUDA_SUCCESS)\n        GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n\n      event_gc (true);\n\n      CUDA_CALL_ASSERT (cuEventRecord, *e, dev_str->stream);\n\n      event_add (PTX_EVT_KNL, e, (void *)dev_str, 0);\n    }\n#else\n  r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );\n  if (r == CUDA_ERROR_LAUNCH_FAILED)\n    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s %s\\n\", cuda_error (r),\n\t\t       maybe_abort_msg);\n  else if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s\", cuda_error (r));\n#endif\n\n  GOMP_PLUGIN_debug (0, \"  %s: kernel %s: finished\\n\", __FUNCTION__,\n\t\t     targ_fn->launch->fn);\n\n#ifndef DISABLE_ASYNC\n  if (async < acc_async_noval)\n#endif\n    map_pop (dev_str);\n}\n\nvoid * openacc_get_current_cuda_context (void);\n\nstatic void *\nnvptx_alloc (size_t s)\n{\n  CUdeviceptr d;\n\n  CUDA_CALL_ERET (NULL, cuMemAlloc, &d, s);\n  return (void *) d;\n}\n\nstatic bool\nnvptx_free (void *p)\n{\n  CUdeviceptr pb;\n  size_t ps;\n\n  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) p);\n  if ((CUdeviceptr) p != pb)\n    {\n      GOMP_PLUGIN_error (\"invalid device address\");\n      return false;\n    }\n\n  CUDA_CALL (cuMemFree, (CUdeviceptr) p);\n  return true;\n}\n\n\nstatic bool\nnvptx_host2dev (void *d, const void *h, size_t s)\n{\n  CUdeviceptr pb;\n  size_t ps;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (!s)\n    return true;\n  if (!d)\n    {\n      GOMP_PLUGIN_error (\"invalid device address\");\n      return false;\n    }\n\n  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n\n  if (!pb)\n    {\n      GOMP_PLUGIN_error (\"invalid device address\");\n      return false;\n    }\n  if (!h)\n    {\n      GOMP_PLUGIN_error (\"invalid host address\");\n      return false;\n    }\n  if (d == h)\n    {\n      GOMP_PLUGIN_error (\"invalid host or device address\");\n      return false;\n    }\n  if ((void *)(d + s) > (void *)(pb + ps))\n    {\n      GOMP_PLUGIN_error (\"invalid size\");\n      return false;\n    }\n\n#ifndef DISABLE_ASYNC\n  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n    {\n      CUevent *e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n      event_gc (false);\n      CUDA_CALL (cuMemcpyHtoDAsync,\n\t\t (CUdeviceptr) d, h, s, nvthd->current_stream->stream);\n      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n    }\n  else\n#endif\n    CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) d, h, s);\n\n  return true;\n}\n\nstatic bool\nnvptx_dev2host (void *h, const void *d, size_t s)\n{\n  CUdeviceptr pb;\n  size_t ps;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (!s)\n    return true;\n  if (!d)\n    {\n      GOMP_PLUGIN_error (\"invalid device address\");\n      return false;\n    }\n\n  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n\n  if (!pb)\n    {\n      GOMP_PLUGIN_error (\"invalid device address\");\n      return false;\n    }\n  if (!h)\n    {\n      GOMP_PLUGIN_error (\"invalid host address\");\n      return false;\n    }\n  if (d == h)\n    {\n      GOMP_PLUGIN_error (\"invalid host or device address\");\n      return false;\n    }\n  if ((void *)(d + s) > (void *)(pb + ps))\n    {\n      GOMP_PLUGIN_error (\"invalid size\");\n      return false;\n    }\n\n#ifndef DISABLE_ASYNC\n  if (nvthd && nvthd->current_stream != nvthd->ptx_dev->null_stream)\n    {\n      CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n      event_gc (false);\n      CUDA_CALL (cuMemcpyDtoHAsync,\n\t\t h, (CUdeviceptr) d, s, nvthd->current_stream->stream);\n      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n      event_add (PTX_EVT_MEM, e, (void *)h, 0);\n    }\n  else\n#endif\n    CUDA_CALL (cuMemcpyDtoH, h, (CUdeviceptr) d, s);\n\n  return true;\n}\n\nstatic void\nnvptx_set_async (int async)\n{\n  struct nvptx_thread *nvthd = nvptx_thread ();\n  nvthd->current_stream\n    = select_stream_for_async (async, pthread_self (), true, NULL);\n}\n\nstatic int\nnvptx_async_test (int async)\n{\n  CUresult r;\n  struct ptx_stream *s;\n\n  s = select_stream_for_async (async, pthread_self (), false, NULL);\n\n  if (!s)\n    GOMP_PLUGIN_fatal (\"unknown async %d\", async);\n\n  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);\n  if (r == CUDA_SUCCESS)\n    {\n      /* The oacc-parallel.c:goacc_wait function calls this hook to determine\n\t whether all work has completed on this stream, and if so omits the call\n\t to the wait hook.  If that happens, event_gc might not get called\n\t (which prevents variables from getting unmapped and their associated\n\t device storage freed), so call it here.  */\n      event_gc (true);\n      return 1;\n    }\n  else if (r == CUDA_ERROR_NOT_READY)\n    return 0;\n\n  GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n\n  return 0;\n}\n\nstatic int\nnvptx_async_test_all (void)\n{\n  struct ptx_stream *s;\n  pthread_t self = pthread_self ();\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n\n  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)\n    {\n      if ((s->multithreaded || pthread_equal (s->host_thread, self))\n\t  && CUDA_CALL_NOCHECK (cuStreamQuery,\n\t\t\t\ts->stream) == CUDA_ERROR_NOT_READY)\n\t{\n\t  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n\t  return 0;\n\t}\n    }\n\n  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n\n  event_gc (true);\n\n  return 1;\n}\n\nstatic void\nnvptx_wait (int async)\n{\n  struct ptx_stream *s;\n\n  s = select_stream_for_async (async, pthread_self (), false, NULL);\n  if (!s)\n    GOMP_PLUGIN_fatal (\"unknown async %d\", async);\n\n  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n\n  event_gc (true);\n}\n\nstatic void\nnvptx_wait_async (int async1, int async2)\n{\n  CUevent *e;\n  struct ptx_stream *s1, *s2;\n  pthread_t self = pthread_self ();\n\n  /* The stream that is waiting (rather than being waited for) doesn't\n     necessarily have to exist already.  */\n  s2 = select_stream_for_async (async2, self, true, NULL);\n\n  s1 = select_stream_for_async (async1, self, false, NULL);\n  if (!s1)\n    GOMP_PLUGIN_fatal (\"invalid async 1\\n\");\n\n  if (s1 == s2)\n    GOMP_PLUGIN_fatal (\"identical parameters\");\n\n  e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n\n  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n\n  event_gc (true);\n\n  CUDA_CALL_ASSERT (cuEventRecord, *e, s1->stream);\n\n  event_add (PTX_EVT_SYNC, e, NULL, 0);\n\n  CUDA_CALL_ASSERT (cuStreamWaitEvent, s2->stream, *e, 0);\n}\n\nstatic void\nnvptx_wait_all (void)\n{\n  CUresult r;\n  struct ptx_stream *s;\n  pthread_t self = pthread_self ();\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n\n  /* Wait for active streams initiated by this thread (or by multiple threads)\n     to complete.  */\n  for (s = nvthd->ptx_dev->active_streams; s != NULL; s = s->next)\n    {\n      if (s->multithreaded || pthread_equal (s->host_thread, self))\n\t{\n\t  r = CUDA_CALL_NOCHECK (cuStreamQuery, s->stream);\n\t  if (r == CUDA_SUCCESS)\n\t    continue;\n\t  else if (r != CUDA_ERROR_NOT_READY)\n\t    GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n\n\t  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n\t}\n    }\n\n  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n\n  event_gc (true);\n}\n\nstatic void\nnvptx_wait_all_async (int async)\n{\n  struct ptx_stream *waiting_stream, *other_stream;\n  CUevent *e;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n  pthread_t self = pthread_self ();\n\n  /* The stream doing the waiting.  This could be the first mention of the\n     stream, so create it if necessary.  */\n  waiting_stream\n    = select_stream_for_async (async, pthread_self (), true, NULL);\n\n  /* Launches on the null stream already block on other streams in the\n     context.  */\n  if (!waiting_stream || waiting_stream == nvthd->ptx_dev->null_stream)\n    return;\n\n  event_gc (true);\n\n  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n\n  for (other_stream = nvthd->ptx_dev->active_streams;\n       other_stream != NULL;\n       other_stream = other_stream->next)\n    {\n      if (!other_stream->multithreaded\n\t  && !pthread_equal (other_stream->host_thread, self))\n\tcontinue;\n\n      e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n\n      CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n\n      /* Record an event on the waited-for stream.  */\n      CUDA_CALL_ASSERT (cuEventRecord, *e, other_stream->stream);\n\n      event_add (PTX_EVT_SYNC, e, NULL, 0);\n\n      CUDA_CALL_ASSERT (cuStreamWaitEvent, waiting_stream->stream, *e, 0);\n   }\n\n  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n}\n\nstatic void *\nnvptx_get_current_cuda_device (void)\n{\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (!nvthd || !nvthd->ptx_dev)\n    return NULL;\n\n  return &nvthd->ptx_dev->dev;\n}\n\nstatic void *\nnvptx_get_current_cuda_context (void)\n{\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (!nvthd || !nvthd->ptx_dev)\n    return NULL;\n\n  return nvthd->ptx_dev->ctx;\n}\n\nstatic void *\nnvptx_get_cuda_stream (int async)\n{\n  struct ptx_stream *s;\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (!nvthd || !nvthd->ptx_dev)\n    return NULL;\n\n  s = select_stream_for_async (async, pthread_self (), false, NULL);\n\n  return s ? s->stream : NULL;\n}\n\nstatic int\nnvptx_set_cuda_stream (int async, void *stream)\n{\n  struct ptx_stream *oldstream;\n  pthread_t self = pthread_self ();\n  struct nvptx_thread *nvthd = nvptx_thread ();\n\n  if (async < 0)\n    GOMP_PLUGIN_fatal (\"bad async %d\", async);\n\n  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n\n  /* We have a list of active streams and an array mapping async values to\n     entries of that list.  We need to take \"ownership\" of the passed-in stream,\n     and add it to our list, removing the previous entry also (if there was one)\n     in order to prevent resource leaks.  Note the potential for surprise\n     here: maybe we should keep track of passed-in streams and leave it up to\n     the user to tidy those up, but that doesn't work for stream handles\n     returned from acc_get_cuda_stream above...  */\n\n  oldstream = select_stream_for_async (async, self, false, NULL);\n\n  if (oldstream)\n    {\n      if (nvthd->ptx_dev->active_streams == oldstream)\n\tnvthd->ptx_dev->active_streams = nvthd->ptx_dev->active_streams->next;\n      else\n\t{\n\t  struct ptx_stream *s = nvthd->ptx_dev->active_streams;\n\t  while (s->next != oldstream)\n\t    s = s->next;\n\t  s->next = s->next->next;\n\t}\n\n      CUDA_CALL_ASSERT (cuStreamDestroy, oldstream->stream);\n\n      if (!map_fini (oldstream))\n\tGOMP_PLUGIN_fatal (\"error when freeing host memory\");\n\n      free (oldstream);\n    }\n\n  pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n\n  (void) select_stream_for_async (async, self, true, (CUstream) stream);\n\n  return 1;\n}\n\n/* Plugin entry points.  */\n\nconst char *\nGOMP_OFFLOAD_get_name (void)\n{\n  return \"nvptx\";\n}\n\nunsigned int\nGOMP_OFFLOAD_get_caps (void)\n{\n  return GOMP_OFFLOAD_CAP_OPENACC_200 | GOMP_OFFLOAD_CAP_OPENMP_400;\n}\n\nint\nGOMP_OFFLOAD_get_type (void)\n{\n  return OFFLOAD_TARGET_TYPE_NVIDIA_PTX;\n}\n\nint\nGOMP_OFFLOAD_get_num_devices (void)\n{\n  return nvptx_get_num_devices ();\n}\n\nbool\nGOMP_OFFLOAD_init_device (int n)\n{\n  struct ptx_device *dev;\n\n  pthread_mutex_lock (&ptx_dev_lock);\n\n  if (!nvptx_init () || ptx_devices[n] != NULL)\n    {\n      pthread_mutex_unlock (&ptx_dev_lock);\n      return false;\n    }\n\n  dev = nvptx_open_device (n);\n  if (dev)\n    {\n      ptx_devices[n] = dev;\n      instantiated_devices++;\n    }\n\n  pthread_mutex_unlock (&ptx_dev_lock);\n\n  return dev != NULL;\n}\n\nbool\nGOMP_OFFLOAD_fini_device (int n)\n{\n  pthread_mutex_lock (&ptx_dev_lock);\n\n  if (ptx_devices[n] != NULL)\n    {\n      if (!nvptx_attach_host_thread_to_device (n)\n\t  || !nvptx_close_device (ptx_devices[n]))\n\t{\n\t  pthread_mutex_unlock (&ptx_dev_lock);\n\t  return false;\n\t}\n      ptx_devices[n] = NULL;\n      instantiated_devices--;\n    }\n\n  pthread_mutex_unlock (&ptx_dev_lock);\n  return true;\n}\n\n/* Return the libgomp version number we're compatible with.  There is\n   no requirement for cross-version compatibility.  */\n\nunsigned\nGOMP_OFFLOAD_version (void)\n{\n  return GOMP_VERSION;\n}\n\n/* Initialize __nvptx_clocktick, if present in MODULE.  */\n\nstatic void\nnvptx_set_clocktick (CUmodule module, struct ptx_device *dev)\n{\n  CUdeviceptr dptr;\n  CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &dptr, NULL,\n\t\t\t\t  module, \"__nvptx_clocktick\");\n  if (r == CUDA_ERROR_NOT_FOUND)\n    return;\n  if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n  double __nvptx_clocktick = 1e-3 / dev->clock_khz;\n  r = CUDA_CALL_NOCHECK (cuMemcpyHtoD, dptr, &__nvptx_clocktick,\n\t\t\t sizeof (__nvptx_clocktick));\n  if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n}\n\n/* Load the (partial) program described by TARGET_DATA to device\n   number ORD.  Allocate and return TARGET_TABLE.  */\n\nint\nGOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n\t\t\t struct addr_pair **target_table)\n{\n  CUmodule module;\n  const char *const *var_names;\n  const struct targ_fn_launch *fn_descs;\n  unsigned int fn_entries, var_entries, i, j;\n  struct targ_fn_descriptor *targ_fns;\n  struct addr_pair *targ_tbl;\n  const nvptx_tdata_t *img_header = (const nvptx_tdata_t *) target_data;\n  struct ptx_image_data *new_image;\n  struct ptx_device *dev;\n\n  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n    {\n      GOMP_PLUGIN_error (\"Offload data incompatible with PTX plugin\"\n\t\t\t \" (expected %u, received %u)\",\n\t\t\t GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n      return -1;\n    }\n\n  if (!nvptx_attach_host_thread_to_device (ord)\n      || !link_ptx (&module, img_header->ptx_objs, img_header->ptx_num))\n    return -1;\n\n  dev = ptx_devices[ord];\n\n  /* The mkoffload utility emits a struct of pointers/integers at the\n     start of each offload image.  The array of kernel names and the\n     functions addresses form a one-to-one correspondence.  */\n\n  var_entries = img_header->var_num;\n  var_names = img_header->var_names;\n  fn_entries = img_header->fn_num;\n  fn_descs = img_header->fn_descs;\n\n  targ_tbl = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n\t\t\t\t * (fn_entries + var_entries));\n  targ_fns = GOMP_PLUGIN_malloc (sizeof (struct targ_fn_descriptor)\n\t\t\t\t * fn_entries);\n\n  *target_table = targ_tbl;\n\n  new_image = GOMP_PLUGIN_malloc (sizeof (struct ptx_image_data));\n  new_image->target_data = target_data;\n  new_image->module = module;\n  new_image->fns = targ_fns;\n\n  pthread_mutex_lock (&dev->image_lock);\n  new_image->next = dev->images;\n  dev->images = new_image;\n  pthread_mutex_unlock (&dev->image_lock);\n\n  for (i = 0; i < fn_entries; i++, targ_fns++, targ_tbl++)\n    {\n      CUfunction function;\n      int nregs, mthrs;\n\n      CUDA_CALL_ERET (-1, cuModuleGetFunction, &function, module,\n\t\t      fn_descs[i].fn);\n      CUDA_CALL_ERET (-1, cuFuncGetAttribute, &nregs,\n\t\t      CU_FUNC_ATTRIBUTE_NUM_REGS, function);\n      CUDA_CALL_ERET (-1, cuFuncGetAttribute, &mthrs,\n\t\t      CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, function);\n\n      targ_fns->fn = function;\n      targ_fns->launch = &fn_descs[i];\n      targ_fns->regs_per_thread = nregs;\n      targ_fns->max_threads_per_block = mthrs;\n\n      targ_tbl->start = (uintptr_t) targ_fns;\n      targ_tbl->end = targ_tbl->start + 1;\n    }\n\n  for (j = 0; j < var_entries; j++, targ_tbl++)\n    {\n      CUdeviceptr var;\n      size_t bytes;\n\n      CUDA_CALL_ERET (-1, cuModuleGetGlobal,\n\t\t      &var, &bytes, module, var_names[j]);\n\n      targ_tbl->start = (uintptr_t) var;\n      targ_tbl->end = targ_tbl->start + bytes;\n    }\n\n  nvptx_set_clocktick (module, dev);\n\n  return fn_entries + var_entries;\n}\n\n/* Unload the program described by TARGET_DATA.  DEV_DATA is the\n   function descriptors allocated by G_O_load_image.  */\n\nbool\nGOMP_OFFLOAD_unload_image (int ord, unsigned version, const void *target_data)\n{\n  struct ptx_image_data *image, **prev_p;\n  struct ptx_device *dev = ptx_devices[ord];\n\n  if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n    {\n      GOMP_PLUGIN_error (\"Offload data incompatible with PTX plugin\"\n\t\t\t \" (expected %u, received %u)\",\n\t\t\t GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n      return false;\n    }\n\n  bool ret = true;\n  pthread_mutex_lock (&dev->image_lock);\n  for (prev_p = &dev->images; (image = *prev_p) != 0; prev_p = &image->next)\n    if (image->target_data == target_data)\n      {\n\t*prev_p = image->next;\n\tif (CUDA_CALL_NOCHECK (cuModuleUnload, image->module) != CUDA_SUCCESS)\n\t  ret = false;\n\tfree (image->fns);\n\tfree (image);\n\tbreak;\n      }\n  pthread_mutex_unlock (&dev->image_lock);\n  return ret;\n}\n\nvoid *\nGOMP_OFFLOAD_alloc (int ord, size_t size)\n{\n  if (!nvptx_attach_host_thread_to_device (ord))\n    return NULL;\n  return nvptx_alloc (size);\n}\n\nbool\nGOMP_OFFLOAD_free (int ord, void *ptr)\n{\n  return (nvptx_attach_host_thread_to_device (ord)\n\t  && nvptx_free (ptr));\n}\n\nbool\nGOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n{\n  return (nvptx_attach_host_thread_to_device (ord)\n\t  && nvptx_dev2host (dst, src, n));\n}\n\nbool\nGOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n{\n  return (nvptx_attach_host_thread_to_device (ord)\n\t  && nvptx_host2dev (dst, src, n));\n}\n\nbool\nGOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n{\n  struct ptx_device *ptx_dev = ptx_devices[ord];\n  CUDA_CALL (cuMemcpyDtoDAsync, (CUdeviceptr) dst, (CUdeviceptr) src, n,\n\t\t\t\tptx_dev->null_stream->stream);\n  return true;\n}\n\nvoid (*device_run) (int n, void *fn_ptr, void *vars) = NULL;\n\nvoid\nGOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n\t\t\t   void **hostaddrs, void **devaddrs,\n\t\t\t   int async, unsigned *dims, void *targ_mem_desc)\n{\n  nvptx_exec (fn, mapnum, hostaddrs, devaddrs, async, dims, targ_mem_desc);\n}\n\nvoid\nGOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc, int async)\n{\n  struct nvptx_thread *nvthd = nvptx_thread ();\n  CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n\n  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n  CUDA_CALL_ASSERT (cuEventRecord, *e, nvthd->current_stream->stream);\n  event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc, async);\n}\n\nint\nGOMP_OFFLOAD_openacc_async_test (int async)\n{\n  return nvptx_async_test (async);\n}\n\nint\nGOMP_OFFLOAD_openacc_async_test_all (void)\n{\n  return nvptx_async_test_all ();\n}\n\nvoid\nGOMP_OFFLOAD_openacc_async_wait (int async)\n{\n  nvptx_wait (async);\n}\n\nvoid\nGOMP_OFFLOAD_openacc_async_wait_async (int async1, int async2)\n{\n  nvptx_wait_async (async1, async2);\n}\n\nvoid\nGOMP_OFFLOAD_openacc_async_wait_all (void)\n{\n  nvptx_wait_all ();\n}\n\nvoid\nGOMP_OFFLOAD_openacc_async_wait_all_async (int async)\n{\n  nvptx_wait_all_async (async);\n}\n\nvoid\nGOMP_OFFLOAD_openacc_async_set_async (int async)\n{\n  nvptx_set_async (async);\n}\n\nvoid *\nGOMP_OFFLOAD_openacc_create_thread_data (int ord)\n{\n  struct ptx_device *ptx_dev;\n  struct nvptx_thread *nvthd\n    = GOMP_PLUGIN_malloc (sizeof (struct nvptx_thread));\n  CUcontext thd_ctx;\n\n  ptx_dev = ptx_devices[ord];\n\n  assert (ptx_dev);\n\n  CUDA_CALL_ASSERT (cuCtxGetCurrent, &thd_ctx);\n\n  assert (ptx_dev->ctx);\n\n  if (!thd_ctx)\n    CUDA_CALL_ASSERT (cuCtxPushCurrent, ptx_dev->ctx);\n\n  nvthd->current_stream = ptx_dev->null_stream;\n  nvthd->ptx_dev = ptx_dev;\n\n  return (void *) nvthd;\n}\n\nvoid\nGOMP_OFFLOAD_openacc_destroy_thread_data (void *data)\n{\n  free (data);\n}\n\nvoid *\nGOMP_OFFLOAD_openacc_cuda_get_current_device (void)\n{\n  return nvptx_get_current_cuda_device ();\n}\n\nvoid *\nGOMP_OFFLOAD_openacc_cuda_get_current_context (void)\n{\n  return nvptx_get_current_cuda_context ();\n}\n\n/* NOTE: This returns a CUstream, not a ptx_stream pointer.  */\n\nvoid *\nGOMP_OFFLOAD_openacc_cuda_get_stream (int async)\n{\n  return nvptx_get_cuda_stream (async);\n}\n\n/* NOTE: This takes a CUstream, not a ptx_stream pointer.  */\n\nint\nGOMP_OFFLOAD_openacc_cuda_set_stream (int async, void *stream)\n{\n  return nvptx_set_cuda_stream (async, stream);\n}\n\n/* Adjust launch dimensions: pick good values for number of blocks and warps\n   and ensure that number of warps does not exceed CUDA limits as well as GCC's\n   own limits.  */\n\nstatic void\nnvptx_adjust_launch_bounds (struct targ_fn_descriptor *fn,\n\t\t\t    struct ptx_device *ptx_dev,\n\t\t\t    int *teams_p, int *threads_p)\n{\n  int max_warps_block = fn->max_threads_per_block / 32;\n  /* Maximum 32 warps per block is an implementation limit in NVPTX backend\n     and libgcc, which matches documented limit of all GPUs as of 2015.  */\n  if (max_warps_block > 32)\n    max_warps_block = 32;\n  if (*threads_p <= 0)\n    *threads_p = 8;\n  if (*threads_p > max_warps_block)\n    *threads_p = max_warps_block;\n\n  int regs_per_block = fn->regs_per_thread * 32 * *threads_p;\n  /* This is an estimate of how many blocks the device can host simultaneously.\n     Actual limit, which may be lower, can be queried with \"occupancy control\"\n     driver interface (since CUDA 6.0).  */\n  int max_blocks = ptx_dev->regs_per_sm / regs_per_block * ptx_dev->num_sms;\n  if (*teams_p <= 0 || *teams_p > max_blocks)\n    *teams_p = max_blocks;\n}\n\n/* Return the size of per-warp stacks (see gcc -msoft-stack) to use for OpenMP\n   target regions.  */\n\nstatic size_t\nnvptx_stacks_size ()\n{\n  return 128 * 1024;\n}\n\n/* Return contiguous storage for NUM stacks, each SIZE bytes.  */\n\nstatic void *\nnvptx_stacks_alloc (size_t size, int num)\n{\n  CUdeviceptr stacks;\n  CUresult r = CUDA_CALL_NOCHECK (cuMemAlloc, &stacks, size * num);\n  if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuMemAlloc error: %s\", cuda_error (r));\n  return (void *) stacks;\n}\n\n/* Release storage previously allocated by nvptx_stacks_alloc.  */\n\nstatic void\nnvptx_stacks_free (void *p, int num)\n{\n  CUresult r = CUDA_CALL_NOCHECK (cuMemFree, (CUdeviceptr) p);\n  if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuMemFree error: %s\", cuda_error (r));\n}\n\nvoid\nGOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n{\n  CUfunction function = ((struct targ_fn_descriptor *) tgt_fn)->fn;\n  CUresult r;\n  struct ptx_device *ptx_dev = ptx_devices[ord];\n  const char *maybe_abort_msg = \"(perhaps abort was called)\";\n  int teams = 0, threads = 0;\n\n  if (!args)\n    GOMP_PLUGIN_fatal (\"No target arguments provided\");\n  while (*args)\n    {\n      intptr_t id = (intptr_t) *args++, val;\n      if (id & GOMP_TARGET_ARG_SUBSEQUENT_PARAM)\n\tval = (intptr_t) *args++;\n      else\n        val = id >> GOMP_TARGET_ARG_VALUE_SHIFT;\n      if ((id & GOMP_TARGET_ARG_DEVICE_MASK) != GOMP_TARGET_ARG_DEVICE_ALL)\n\tcontinue;\n      val = val > INT_MAX ? INT_MAX : val;\n      id &= GOMP_TARGET_ARG_ID_MASK;\n      if (id == GOMP_TARGET_ARG_NUM_TEAMS)\n\tteams = val;\n      else if (id == GOMP_TARGET_ARG_THREAD_LIMIT)\n\tthreads = val;\n    }\n  nvptx_adjust_launch_bounds (tgt_fn, ptx_dev, &teams, &threads);\n\n  size_t stack_size = nvptx_stacks_size ();\n  void *stacks = nvptx_stacks_alloc (stack_size, teams * threads);\n  void *fn_args[] = {tgt_vars, stacks, (void *) stack_size};\n  size_t fn_args_size = sizeof fn_args;\n  void *config[] = {\n    CU_LAUNCH_PARAM_BUFFER_POINTER, fn_args,\n    CU_LAUNCH_PARAM_BUFFER_SIZE, &fn_args_size,\n    CU_LAUNCH_PARAM_END\n  };\n  r = CUDA_CALL_NOCHECK (cuLaunchKernel, function, teams, 1, 1,\n\t\t\t 32, threads, 1, 0, ptx_dev->null_stream->stream,\n\t\t\t NULL, config);\n  if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuLaunchKernel error: %s\", cuda_error (r));\n\n  r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );\n  if (r == CUDA_ERROR_LAUNCH_FAILED)\n    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s %s\\n\", cuda_error (r),\n\t\t       maybe_abort_msg);\n  else if (r != CUDA_SUCCESS)\n    GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s\", cuda_error (r));\n  nvptx_stacks_free (stacks, teams * threads);\n}\n\nvoid\nGOMP_OFFLOAD_async_run (int ord, void *tgt_fn, void *tgt_vars, void **args,\n\t\t\tvoid *async_data)\n{\n  GOMP_PLUGIN_fatal (\"GOMP_OFFLOAD_async_run unimplemented\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgomp/testsuite/libgomp.c/affinity-1.c": "/* Affinity tests.\n   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n\n   GCC is free software; you can redistribute it and/or modify it under\n   the terms of the GNU General Public License as published by the Free\n   Software Foundation; either version 3, or (at your option) any later\n   version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n   for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING3.  If not see\n   <http://www.gnu.org/licenses/>.  */\n\n/* { dg-do run } */\n/* { dg-set-target-env-var OMP_PROC_BIND \"false\" } */\n/* { dg-additional-options \"-DINTERPOSE_GETAFFINITY -DDO_FORK -ldl\" { target *-*-linux* } } */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include \"config.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef DO_FORK\n#include <signal.h>\n#include <sys/wait.h>\n#endif\n#ifdef HAVE_PTHREAD_AFFINITY_NP\n#include <sched.h>\n#include <pthread.h>\n#ifdef INTERPOSE_GETAFFINITY\n#include <dlfcn.h>\n#endif\n#endif\n\nstruct place\n{\n  int start, len;\n};\nstruct places\n{\n  char name[40];\n  int count;\n  struct place places[8];\n} places_array[] = {\n  { \"\", 1, { { -1, -1 } } },\n  { \"{0}:8\", 8,\n    { { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 },\n      { 4, 1 }, { 5, 1 }, { 6, 1 }, { 7, 1 } } },\n  { \"{7,6}:2:-3\", 2, { { 6, 2 }, { 3, 2 } } },\n  { \"{6,7}:4:-2,!{2,3}\", 3, { { 6, 2 }, { 4, 2 }, { 0, 2 } } },\n  { \"{1}:7:1\", 7,\n    { { 1, 1 }, { 2, 1 }, { 3, 1 },\n      { 4, 1 }, { 5, 1 }, { 6, 1 }, { 7, 1 } } },\n  { \"{0,1},{3,2,4},{6,5,!6},{6},{7:2:-1,!6}\", 5,\n    { { 0, 2 }, { 2, 3 }, { 5, 1 }, { 6, 1 }, { 7, 1 } } }\n};\n\nunsigned long contig_cpucount;\nunsigned long min_cpusetsize;\n\n#if defined (HAVE_PTHREAD_AFFINITY_NP) && defined (_SC_NPROCESSORS_CONF) \\\n    && defined (CPU_ALLOC_SIZE)\n\n#if defined (RTLD_NEXT) && defined (INTERPOSE_GETAFFINITY)\nint (*orig_getaffinity_np) (pthread_t, size_t, cpu_set_t *);\n\nint\npthread_getaffinity_np (pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset)\n{\n  int ret;\n  unsigned long i, max;\n  if (orig_getaffinity_np == NULL)\n    {\n      orig_getaffinity_np = (int (*) (pthread_t, size_t, cpu_set_t *))\n\t\t\t    dlsym (RTLD_NEXT, \"pthread_getaffinity_np\");\n      if (orig_getaffinity_np == NULL)\n\texit (0);\n    }\n  ret = orig_getaffinity_np (thread, cpusetsize, cpuset);\n  if (ret != 0)\n    return ret;\n  if (contig_cpucount == 0)\n    {\n      max = 8 * cpusetsize;\n      for (i = 0; i < max; i++)\n\tif (!CPU_ISSET_S (i, cpusetsize, cpuset))\n\t  break;\n      contig_cpucount = i;\n      min_cpusetsize = cpusetsize;\n    }\n  return ret;\n}\n#endif\n\nvoid\nprint_affinity (struct place p)\n{\n  static unsigned long size;\n  if (size == 0)\n    {\n      if (min_cpusetsize)\n\tsize = min_cpusetsize;\n      else\n\t{\n\t  size = sysconf (_SC_NPROCESSORS_CONF);\n\t  size = CPU_ALLOC_SIZE (size);\n\t  if (size < sizeof (cpu_set_t))\n\t    size = sizeof (cpu_set_t);\n\t}\n    }\n  cpu_set_t *cpusetp = (cpu_set_t *) __builtin_alloca (size);\n  if (pthread_getaffinity_np (pthread_self (), size, cpusetp) == 0)\n    {\n      unsigned long i, len, max = 8 * size;\n      int notfirst = 0, unexpected = 1;\n\n      printf (\" bound to {\");\n      for (i = 0, len = 0; i < max; i++)\n\tif (CPU_ISSET_S (i, size, cpusetp))\n\t  {\n\t    if (len == 0)\n\t      {\n\t\tif (notfirst)\n\t\t  {\n\t\t    unexpected = 1;\n\t\t    printf (\",\");\n\t\t  }\n\t\telse if (i == (unsigned long) p.start)\n\t\t  unexpected = 0;\n\t\tnotfirst = 1;\n\t\tprintf (\"%lu\", i);\n\t      }\n\t    ++len;\n\t  }\n\telse\n\t  {\n\t    if (len && len != (unsigned long) p.len)\n\t      unexpected = 1;\n\t    if (len > 1)\n\t      printf (\":%lu\", len);\n\t    len = 0;\n\t  }\n      if (len && len != (unsigned long) p.len)\n\tunexpected = 1;\n      if (len > 1)\n\tprintf (\":%lu\", len);\n      printf (\"}\");\n      if (p.start != -1 && unexpected)\n\t{\n\t  printf (\", expected {%d\", p.start);\n\t  if (p.len != 1)\n\t    printf (\":%d\", p.len);\n\t  printf (\"} instead\");\n\t}\n      else if (p.start != -1)\n\tprintf (\", verified\");\n    }\n}\n#else\nvoid\nprint_affinity (struct place p)\n{\n  (void) p.start;\n  (void) p.len;\n}\n#endif\n\n\nint\nmain ()\n{\n  char *env_proc_bind = getenv (\"OMP_PROC_BIND\");\n  int test_false = env_proc_bind && strcmp (env_proc_bind, \"false\") == 0;\n  int test_true = env_proc_bind && strcmp (env_proc_bind, \"true\") == 0;\n  int test_spread_master_close\n    = env_proc_bind && strcmp (env_proc_bind, \"spread,master,close\") == 0;\n  char *env_places = getenv (\"OMP_PLACES\");\n  int test_places = 0;\n\n#ifdef DO_FORK\n  if (env_places == NULL && contig_cpucount >= 8 && test_false\n      && getenv (\"GOMP_AFFINITY\") == NULL)\n    {\n      int i, j, status;\n      pid_t pid;\n      for (j = 0; j < 2; j++)\n\t{\n\t  if (setenv (\"OMP_PROC_BIND\", j ? \"spread,master,close\" : \"true\", 1)\n\t      < 0)\n\t    break;\n\t  for (i = sizeof (places_array) / sizeof (places_array[0]) - 1;\n\t       i; --i)\n\t    {\n\t      if (setenv (\"OMP_PLACES\", places_array[i].name, 1) < 0)\n\t\tbreak;\n\t      pid = fork ();\n\t      if (pid == -1)\n\t\tbreak;\n\t      if (pid == 0)\n\t\t{\n\t\t  execl (\"/proc/self/exe\", \"affinity-1.exe\", NULL);\n\t\t  _exit (1);\n\t\t}\n\t      if (waitpid (pid, &status, 0) < 0)\n\t\tbreak;\n\t      if (WIFSIGNALED (status) && WTERMSIG (status) == SIGABRT)\n\t\tabort ();\n\t      else if (!WIFEXITED (status) || WEXITSTATUS (status) != 0)\n\t\tbreak;\n\t    }\n\t  if (i)\n\t    break;\n\t}\n    }\n#endif\n\n  int first = 1;\n  if (env_proc_bind)\n    {\n      printf (\"OMP_PROC_BIND='%s'\", env_proc_bind);\n      first = 0;\n    }\n  if (env_places)\n    printf (\"%sOMP_PLACES='%s'\", first ? \"\" : \" \", env_places);\n  printf (\"\\n\");\n\n  if (env_places && contig_cpucount >= 8\n      && (test_true || test_spread_master_close))\n    {\n      for (test_places = sizeof (places_array) / sizeof (places_array[0]) - 1;\n\t   test_places; --test_places)\n\tif (strcmp (env_places, places_array[test_places].name) == 0)\n\t  break;\n    }\n\n#define verify(if_true, if_s_m_c) \\\n  if (test_false && omp_get_proc_bind () != omp_proc_bind_false)\t\\\n    abort ();\t\t\t\t\t\t\t\t\\\n  if (test_true && omp_get_proc_bind () != if_true)\t\t\t\\\n    abort ();\t\t\t\t\t\t\t\t\\\n  if (test_spread_master_close && omp_get_proc_bind () != if_s_m_c)\t\\\n    abort ();\n\n  verify (omp_proc_bind_true, omp_proc_bind_spread);\n\n  printf (\"Initial thread\");\n  print_affinity (places_array[test_places].places[0]);\n  printf (\"\\n\");\n  omp_set_nested (1);\n  omp_set_dynamic (0);\n\n  #pragma omp parallel if (0)\n  {\n    verify (omp_proc_bind_true, omp_proc_bind_master);\n    #pragma omp parallel if (0)\n    {\n      verify (omp_proc_bind_true, omp_proc_bind_close);\n      #pragma omp parallel if (0)\n      {\n\tverify (omp_proc_bind_true, omp_proc_bind_close);\n      }\n      #pragma omp parallel if (0) proc_bind (spread)\n      {\n\tverify (omp_proc_bind_spread, omp_proc_bind_spread);\n      }\n    }\n    #pragma omp parallel if (0) proc_bind (master)\n    {\n      verify (omp_proc_bind_master, omp_proc_bind_close);\n      #pragma omp parallel if (0)\n      {\n\tverify (omp_proc_bind_master, omp_proc_bind_close);\n      }\n      #pragma omp parallel if (0) proc_bind (spread)\n      {\n\tverify (omp_proc_bind_spread, omp_proc_bind_spread);\n      }\n    }\n  }\n\n  /* True/spread */\n  #pragma omp parallel num_threads (4)\n  {\n    verify (omp_proc_bind_true, omp_proc_bind_master);\n    #pragma omp critical\n    {\n      struct place p = places_array[0].places[0];\n      int thr = omp_get_thread_num ();\n      printf (\"#1 thread %d\", thr);\n      if (omp_get_num_threads () == 4 && test_spread_master_close)\n\tswitch (places_array[test_places].count)\n\t  {\n\t  case 8:\n\t    /* T = 4, P = 8, each subpartition has 2 places.  */\n\t  case 7:\n\t    /* T = 4, P = 7, each subpartition has 2 places, but\n\t       last partition, which has just one place.  */\n\t    p = places_array[test_places].places[2 * thr];\n\t    break;\n\t  case 5:\n\t    /* T = 4, P = 5, first subpartition has 2 places, the\n\t       rest just one.  */\n\t    p = places_array[test_places].places[thr ? 1 + thr : 0];\n\t    break;\n\t  case 3:\n\t    /* T = 4, P = 3, unit sized subpartitions, first gets\n\t       thr0 and thr3, second thr1, third thr2.  */\n\t    p = places_array[test_places].places[thr == 3 ? 0 : thr];\n\t    break;\n\t  case 2:\n\t    /* T = 4, P = 2, unit sized subpartitions, each with\n\t       2 threads.  */\n\t    p = places_array[test_places].places[thr / 2];\n\t    break;\n\t  }\n      print_affinity (p);\n      printf (\"\\n\");\n    }\n    #pragma omp barrier\n    if (omp_get_thread_num () == 3)\n      {\n\t/* True/spread, true/master.  */\n\t#pragma omp parallel num_threads (3)\n\t{\n\t  verify (omp_proc_bind_true, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#1,#1 thread 3,%d\", thr);\n\t    if (omp_get_num_threads () == 3 && test_spread_master_close)\n\t      /* Outer is spread, inner master, so just bind to the\n\t\t place or the master thread, which is thr 3 above.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\tcase 7:\n\t\t  p = places_array[test_places].places[6];\n\t\t  break;\n\t\tcase 5:\n\t\t  p = places_array[test_places].places[4];\n\t\t  break;\n\t\tcase 3:\n\t\t  p = places_array[test_places].places[0];\n\t\t  break;\n\t\tcase 2:\n\t\t  p = places_array[test_places].places[1];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* True/spread, spread.  */\n\t#pragma omp parallel num_threads (5) proc_bind (spread)\n\t{\n\t  verify (omp_proc_bind_spread, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#1,#2 thread 3,%d\", thr);\n\t    if (omp_get_num_threads () == 5 && test_spread_master_close)\n\t      /* Outer is spread, inner spread.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 5, P = 2, unit sized subpartitions.  */\n\t\t  p = places_array[test_places].places[thr == 4 ? 6\n\t\t\t\t\t\t       : 6 + thr / 2];\n\t\t  break;\n\t\t/* The rest are T = 5, P = 1.  */\n\t\tcase 7:\n\t\t  p = places_array[test_places].places[6];\n\t\t  break;\n\t\tcase 5:\n\t\t  p = places_array[test_places].places[4];\n\t\t  break;\n\t\tcase 3:\n\t\t  p = places_array[test_places].places[0];\n\t\t  break;\n\t\tcase 2:\n\t\t  p = places_array[test_places].places[1];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 3)\n\t    {\n\t      /* True/spread, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#1,#2,#1 thread 3,3,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5 && test_spread_master_close)\n\t\t    /* Outer is spread, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      /* All are T = 5, P = 1.  */\n\t\t      case 8:\n\t\t\tp = places_array[test_places].places[7];\n\t\t\tbreak;\n\t\t      case 7:\n\t\t\tp = places_array[test_places].places[6];\n\t\t\tbreak;\n\t\t      case 5:\n\t\t\tp = places_array[test_places].places[4];\n\t\t\tbreak;\n\t\t      case 3:\n\t\t\tp = places_array[test_places].places[0];\n\t\t\tbreak;\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[1];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t}\n\t/* True/spread, master.  */\n\t#pragma omp parallel num_threads (4) proc_bind(master)\n\t{\n\t  verify (omp_proc_bind_master, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#1,#3 thread 3,%d\", thr);\n\t    if (omp_get_num_threads () == 4 && test_spread_master_close)\n\t      /* Outer is spread, inner master, so just bind to the\n\t\t place or the master thread, which is thr 3 above.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\tcase 7:\n\t\t  p = places_array[test_places].places[6];\n\t\t  break;\n\t\tcase 5:\n\t\t  p = places_array[test_places].places[4];\n\t\t  break;\n\t\tcase 3:\n\t\t  p = places_array[test_places].places[0];\n\t\t  break;\n\t\tcase 2:\n\t\t  p = places_array[test_places].places[1];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* True/spread, close.  */\n\t#pragma omp parallel num_threads (6) proc_bind (close)\n\t{\n\t  verify (omp_proc_bind_close, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#1,#4 thread 3,%d\", thr);\n\t    if (omp_get_num_threads () == 6 && test_spread_master_close)\n\t      /* Outer is spread, inner close.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 6, P = 2, unit sized subpartitions.  */\n\t\t  p = places_array[test_places].places[6 + thr / 3];\n\t\t  break;\n\t\t/* The rest are T = 6, P = 1.  */\n\t\tcase 7:\n\t\t  p = places_array[test_places].places[6];\n\t\t  break;\n\t\tcase 5:\n\t\t  p = places_array[test_places].places[4];\n\t\t  break;\n\t\tcase 3:\n\t\t  p = places_array[test_places].places[0];\n\t\t  break;\n\t\tcase 2:\n\t\t  p = places_array[test_places].places[1];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n      }\n  }\n\n  /* Spread.  */\n  #pragma omp parallel num_threads (5) proc_bind(spread)\n  {\n    verify (omp_proc_bind_spread, omp_proc_bind_master);\n    #pragma omp critical\n    {\n      struct place p = places_array[0].places[0];\n      int thr = omp_get_thread_num ();\n      printf (\"#2 thread %d\", thr);\n      if (omp_get_num_threads () == 5\n\t  && (test_spread_master_close || test_true))\n\tswitch (places_array[test_places].count)\n\t  {\n\t  case 8:\n\t    /* T = 5, P = 8, first 3 subpartitions have 2 places, last\n\t       2 one place.  */\n\t    p = places_array[test_places].places[thr < 3 ? 2 * thr : 3 + thr];\n\t    break;\n\t  case 7:\n\t    /* T = 5, P = 7, first 2 subpartitions have 2 places, last\n\t       3 one place.  */\n\t    p = places_array[test_places].places[thr < 2 ? 2 * thr : 2 + thr];\n\t    break;\n\t  case 5:\n\t    /* T = 5, P = 5, unit sized subpartitions, each one with one\n\t       thread.  */\n\t    p = places_array[test_places].places[thr];\n\t    break;\n\t  case 3:\n\t    /* T = 5, P = 3, unit sized subpartitions, first gets\n\t       thr0 and thr3, second thr1 and thr4, third thr2.  */\n\t    p = places_array[test_places].places[thr >= 3 ? thr - 3 : thr];\n\t    break;\n\t  case 2:\n\t    /* T = 5, P = 2, unit sized subpartitions, first with\n\t       thr{0,1,4} and second with thr{2,3}.  */\n\t    p = places_array[test_places].places[thr == 4 ? 0 : thr / 2];\n\t    break;\n\t  }\n      print_affinity (p);\n      printf (\"\\n\");\n    }\n    #pragma omp barrier\n    if (omp_get_thread_num () == 3)\n      {\n\tint pp = 0;\n\tswitch (places_array[test_places].count)\n\t  {\n\t  case 8: pp = 6; break;\n\t  case 7: pp = 5; break;\n\t  case 5: pp = 3; break;\n\t  case 2: pp = 1; break;\n\t  }\n\t/* Spread, spread/master.  */\n\t#pragma omp parallel num_threads (3) firstprivate (pp)\n\t{\n\t  verify (omp_proc_bind_spread, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#2,#1 thread 3,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is spread, inner spread resp. master, bit we have\n\t\t just unit sized partitions.  */\n\t      p = places_array[test_places].places[pp];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Spread, spread.  */\n\t#pragma omp parallel num_threads (5) proc_bind (spread) \\\n\t\t\t     firstprivate (pp)\n\t{\n\t  verify (omp_proc_bind_spread, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#2,#2 thread 3,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is spread, inner spread, bit we have\n\t\t just unit sized partitions.  */\n\t      p = places_array[test_places].places[pp];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Spread, master.  */\n\t#pragma omp parallel num_threads (4) proc_bind(master) \\\n\t\t\t     firstprivate(pp)\n\t{\n\t  verify (omp_proc_bind_master, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#2,#3 thread 3,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is spread, inner master, bit we have\n\t\t just unit sized partitions.  */\n\t      p = places_array[test_places].places[pp];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Spread, close.  */\n\t#pragma omp parallel num_threads (6) proc_bind (close) \\\n\t\t\t     firstprivate (pp)\n\t{\n\t  verify (omp_proc_bind_close, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#2,#4 thread 3,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is spread, inner close, bit we have\n\t\t just unit sized partitions.  */\n\t      p = places_array[test_places].places[pp];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n      }\n  }\n\n  /* Master.  */\n  #pragma omp parallel num_threads (3) proc_bind(master)\n  {\n    verify (omp_proc_bind_master, omp_proc_bind_master);\n    #pragma omp critical\n    {\n      struct place p = places_array[0].places[0];\n      int thr = omp_get_thread_num ();\n      printf (\"#3 thread %d\", thr);\n      if (test_spread_master_close || test_true)\n\tp = places_array[test_places].places[0];\n      print_affinity (p);\n      printf (\"\\n\");\n    }\n    #pragma omp barrier\n    if (omp_get_thread_num () == 2)\n      {\n\t/* Master, master.  */\n\t#pragma omp parallel num_threads (4)\n\t{\n\t  verify (omp_proc_bind_master, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#3,#1 thread 2,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is master, inner is master.  */\n\t      p = places_array[test_places].places[0];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Master, spread.  */\n\t#pragma omp parallel num_threads (4) proc_bind (spread)\n\t{\n\t  verify (omp_proc_bind_spread, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#3,#2 thread 2,%d\", thr);\n\t    if (omp_get_num_threads () == 4\n\t\t&& (test_spread_master_close || test_true))\n\t      /* Outer is master, inner is spread.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 4, P = 8, each subpartition has 2 places.  */\n\t\tcase 7:\n\t\t  /* T = 4, P = 7, each subpartition has 2 places, but\n\t\t     last partition, which has just one place.  */\n\t\t  p = places_array[test_places].places[2 * thr];\n\t\t  break;\n\t\tcase 5:\n\t\t  /* T = 4, P = 5, first subpartition has 2 places, the\n\t\t     rest just one.  */\n\t\t  p = places_array[test_places].places[thr ? 1 + thr : 0];\n\t\t  break;\n\t\tcase 3:\n\t\t  /* T = 4, P = 3, unit sized subpartitions, first gets\n\t\t     thr0 and thr3, second thr1, third thr2.  */\n\t\t  p = places_array[test_places].places[thr == 3 ? 0 : thr];\n\t\t  break;\n\t\tcase 2:\n\t\t  /* T = 4, P = 2, unit sized subpartitions, each with\n\t\t     2 threads.  */\n\t\t  p = places_array[test_places].places[thr / 2];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 0)\n\t    {\n\t      /* Master, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#3,#2,#1 thread 2,0,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5\n\t\t      && (test_spread_master_close || test_true))\n\t\t    /* Outer is master, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      /* First 3 are T = 5, P = 2.  */\n\t\t      case 8:\n\t\t      case 7:\n\t\t      case 5:\n\t\t\tp = places_array[test_places].places[(thr & 2) / 2];\n\t\t\tbreak;\n\t\t      /* All the rest are T = 5, P = 1.  */\n\t\t      case 3:\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[0];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 3)\n\t    {\n\t      /* Master, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#3,#2,#2 thread 2,3,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5\n\t\t      && (test_spread_master_close || test_true))\n\t\t    /* Outer is master, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      case 8:\n\t\t\t/* T = 5, P = 2.  */\n\t\t\tp = places_array[test_places].places[6\n\t\t\t\t\t\t\t     + (thr & 2) / 2];\n\t\t\tbreak;\n\t\t      /* All the rest are T = 5, P = 1.  */\n\t\t      case 7:\n\t\t\tp = places_array[test_places].places[6];\n\t\t\tbreak;\n\t\t      case 5:\n\t\t\tp = places_array[test_places].places[4];\n\t\t\tbreak;\n\t\t      case 3:\n\t\t\tp = places_array[test_places].places[0];\n\t\t\tbreak;\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[1];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t}\n\t/* Master, master.  */\n\t#pragma omp parallel num_threads (4) proc_bind(master)\n\t{\n\t  verify (omp_proc_bind_master, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#3,#3 thread 2,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is master, inner master.  */\n\t      p = places_array[test_places].places[0];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Master, close.  */\n\t#pragma omp parallel num_threads (6) proc_bind (close)\n\t{\n\t  verify (omp_proc_bind_close, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#3,#4 thread 2,%d\", thr);\n\t    if (omp_get_num_threads () == 6\n\t\t&& (test_spread_master_close || test_true))\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 6, P = 8.  */\n\t\tcase 7:\n\t\t  /* T = 6, P = 7.  */\n\t\t  p = places_array[test_places].places[thr];\n\t\t  break;\n\t\tcase 5:\n\t\t  /* T = 6, P = 5.  thr{0,5} go into the first place.  */\n\t\t  p = places_array[test_places].places[thr == 5 ? 0 : thr];\n\t\t  break;\n\t\tcase 3:\n\t\t  /* T = 6, P = 3, two threads into each place.  */\n\t\t  p = places_array[test_places].places[thr / 2];\n\t\t  break;\n\t\tcase 2:\n\t\t  /* T = 6, P = 2, 3 threads into each place.  */\n\t\t  p = places_array[test_places].places[thr / 3];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n      }\n  }\n\n  #pragma omp parallel num_threads (5) proc_bind(close)\n  {\n    verify (omp_proc_bind_close, omp_proc_bind_master);\n    #pragma omp critical\n    {\n      struct place p = places_array[0].places[0];\n      int thr = omp_get_thread_num ();\n      printf (\"#4 thread %d\", thr);\n      if (omp_get_num_threads () == 5\n\t  && (test_spread_master_close || test_true))\n\tswitch (places_array[test_places].count)\n\t  {\n\t  case 8:\n\t    /* T = 5, P = 8.  */\n\t  case 7:\n\t    /* T = 5, P = 7.  */\n\t  case 5:\n\t    /* T = 5, P = 5.  */\n\t    p = places_array[test_places].places[thr];\n\t    break;\n\t  case 3:\n\t    /* T = 5, P = 3, thr{0,3} in first place, thr{1,4} in second,\n\t       thr2 in third.  */\n\t    p = places_array[test_places].places[thr >= 3 ? thr - 3 : thr];\n\t    break;\n\t  case 2:\n\t    /* T = 5, P = 2, thr{0,1,4} in first place, thr{2,3} in second.  */\n\t    p = places_array[test_places].places[thr == 4 ? 0 : thr / 2];\n\t    break;\n\t  }\n      print_affinity (p);\n      printf (\"\\n\");\n    }\n    #pragma omp barrier\n    if (omp_get_thread_num () == 2)\n      {\n\tint pp = 0;\n\tswitch (places_array[test_places].count)\n\t  {\n\t  case 8:\n\t  case 7:\n\t  case 5:\n\t  case 3:\n\t    pp = 2;\n\t    break;\n\t  case 2:\n\t    pp = 1;\n\t    break;\n\t  }\n\t/* Close, close/master.  */\n\t#pragma omp parallel num_threads (4) firstprivate (pp)\n\t{\n\t  verify (omp_proc_bind_close, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#4,#1 thread 2,%d\", thr);\n\t    if (test_spread_master_close)\n\t      /* Outer is close, inner is master.  */\n\t      p = places_array[test_places].places[pp];\n\t    else if (omp_get_num_threads () == 4 && test_true)\n\t      /* Outer is close, inner is close.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 4, P = 8.  */\n\t\tcase 7:\n\t\t  /* T = 4, P = 7.  */\n\t\t  p = places_array[test_places].places[2 + thr];\n\t\t  break;\n\t\tcase 5:\n\t\t  /* T = 4, P = 5.  There is wrap-around for thr3.  */\n\t\t  p = places_array[test_places].places[thr == 3 ? 0 : 2 + thr];\n\t\t  break;\n\t\tcase 3:\n\t\t  /* T = 4, P = 3, thr{0,3} go into p2, thr1 into p0, thr2\n\t\t     into p1.  */\n\t\t  p = places_array[test_places].places[(2 + thr) % 3];\n\t\t  break;\n\t\tcase 2:\n\t\t  /* T = 4, P = 2, 2 threads into each place.  */\n\t\t  p = places_array[test_places].places[1 - thr / 2];\n\t\t  break;\n\t\t}\n\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Close, spread.  */\n\t#pragma omp parallel num_threads (4) proc_bind (spread)\n\t{\n\t  verify (omp_proc_bind_spread, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#4,#2 thread 2,%d\", thr);\n\t    if (omp_get_num_threads () == 4\n\t\t&& (test_spread_master_close || test_true))\n\t      /* Outer is close, inner is spread.  */\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 4, P = 8, each subpartition has 2 places.  */\n\t\tcase 7:\n\t\t  /* T = 4, P = 7, each subpartition has 2 places, but\n\t\t     last partition, which has just one place.  */\n\t\t  p = places_array[test_places].places[thr == 3 ? 0\n\t\t\t\t\t\t       : 2 + 2 * thr];\n\t\t  break;\n\t\tcase 5:\n\t\t  /* T = 4, P = 5, first subpartition has 2 places, the\n\t\t     rest just one.  */\n\t\t  p = places_array[test_places].places[thr == 3 ? 0\n\t\t\t\t\t\t       : 2 + thr];\n\t\t  break;\n\t\tcase 3:\n\t\t  /* T = 4, P = 3, unit sized subpartitions, third gets\n\t\t     thr0 and thr3, first thr1, second thr2.  */\n\t\t  p = places_array[test_places].places[thr == 0 ? 2 : thr - 1];\n\t\t  break;\n\t\tcase 2:\n\t\t  /* T = 4, P = 2, unit sized subpartitions, each with\n\t\t     2 threads.  */\n\t\t  p = places_array[test_places].places[1 - thr / 2];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 0)\n\t    {\n\t      /* Close, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#4,#2,#1 thread 2,0,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5\n\t\t      && (test_spread_master_close || test_true))\n\t\t    /* Outer is close, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      case 8:\n\t\t      case 7:\n\t\t\t/* T = 5, P = 2.  */\n\t\t\tp = places_array[test_places].places[2\n\t\t\t\t\t\t\t     + (thr & 2) / 2];\n\t\t\tbreak;\n\t\t      /* All the rest are T = 5, P = 1.  */\n\t\t      case 5:\n\t\t      case 3:\n\t\t\tp = places_array[test_places].places[2];\n\t\t\tbreak;\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[1];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 2)\n\t    {\n\t      /* Close, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#4,#2,#2 thread 2,2,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5\n\t\t      && (test_spread_master_close || test_true))\n\t\t    /* Outer is close, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      case 8:\n\t\t\t/* T = 5, P = 2.  */\n\t\t\tp = places_array[test_places].places[6\n\t\t\t\t\t\t\t     + (thr & 2) / 2];\n\t\t\tbreak;\n\t\t      /* All the rest are T = 5, P = 1.  */\n\t\t      case 7:\n\t\t\tp = places_array[test_places].places[6];\n\t\t\tbreak;\n\t\t      case 5:\n\t\t\tp = places_array[test_places].places[4];\n\t\t\tbreak;\n\t\t      case 3:\n\t\t\tp = places_array[test_places].places[1];\n\t\t\tbreak;\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[0];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t  #pragma omp barrier\n\t  if (omp_get_thread_num () == 3)\n\t    {\n\t      /* Close, spread, close.  */\n\t      #pragma omp parallel num_threads (5) proc_bind (close)\n\t      {\n\t\tverify (omp_proc_bind_close, omp_proc_bind_close);\n\t\t#pragma omp critical\n\t\t{\n\t\t  struct place p = places_array[0].places[0];\n\t\t  int thr = omp_get_thread_num ();\n\t\t  printf (\"#4,#2,#3 thread 2,3,%d\", thr);\n\t\t  if (omp_get_num_threads () == 5\n\t\t      && (test_spread_master_close || test_true))\n\t\t    /* Outer is close, inner spread, innermost close.  */\n\t\t    switch (places_array[test_places].count)\n\t\t      {\n\t\t      case 8:\n\t\t      case 7:\n\t\t      case 5:\n\t\t\t/* T = 5, P = 2.  */\n\t\t\tp = places_array[test_places].places[(thr & 2) / 2];\n\t\t\tbreak;\n\t\t      /* All the rest are T = 5, P = 1.  */\n\t\t      case 3:\n\t\t\tp = places_array[test_places].places[2];\n\t\t\tbreak;\n\t\t      case 2:\n\t\t\tp = places_array[test_places].places[0];\n\t\t\tbreak;\n\t\t      }\n\t\t  print_affinity (p);\n\t\t  printf (\"\\n\");\n\t\t}\n\t      }\n\t    }\n\t}\n\t/* Close, master.  */\n\t#pragma omp parallel num_threads (4) proc_bind(master) \\\n\t\t\t     firstprivate (pp)\n\t{\n\t  verify (omp_proc_bind_master, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#4,#3 thread 2,%d\", thr);\n\t    if (test_spread_master_close || test_true)\n\t      /* Outer is close, inner master.  */\n\t      p = places_array[test_places].places[pp];\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n\t/* Close, close.  */\n\t#pragma omp parallel num_threads (6) proc_bind (close)\n\t{\n\t  verify (omp_proc_bind_close, omp_proc_bind_close);\n\t  #pragma omp critical\n\t  {\n\t    struct place p = places_array[0].places[0];\n\t    int thr = omp_get_thread_num ();\n\t    printf (\"#4,#4 thread 2,%d\", thr);\n\t    if (omp_get_num_threads () == 6\n\t\t&& (test_spread_master_close || test_true))\n\t      switch (places_array[test_places].count)\n\t\t{\n\t\tcase 8:\n\t\t  /* T = 6, P = 8.  */\n\t\t  p = places_array[test_places].places[2 + thr];\n\t\t  break;\n\t\tcase 7:\n\t\t  /* T = 6, P = 7.  */\n\t\t  p = places_array[test_places].places[thr == 5 ? 0 : 2 + thr];\n\t\t  break;\n\t\tcase 5:\n\t\t  /* T = 6, P = 5.  thr{0,5} go into the third place.  */\n\t\t  p = places_array[test_places].places[thr >= 3 ? thr - 3\n\t\t\t\t\t\t       : 2 + thr];\n\t\t  break;\n\t\tcase 3:\n\t\t  /* T = 6, P = 3, two threads into each place.  */\n\t\t  p = places_array[test_places].places[thr < 2 ? 2\n\t\t\t\t\t\t       : thr / 2 - 1];\n\t\t  break;\n\t\tcase 2:\n\t\t  /* T = 6, P = 2, 3 threads into each place.  */\n\t\t  p = places_array[test_places].places[1 - thr / 3];\n\t\t  break;\n\t\t}\n\t    print_affinity (p);\n\t    printf (\"\\n\");\n\t  }\n\t}\n      }\n  }\n\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/intro/sum-of-squares.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/intro/factorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/_build/texinfo/sum-of-squares.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/_build/texinfo/sum-of-squares1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/_build/texinfo/factorial.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/jit/docs/_build/texinfo/factorial1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/sr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/fi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/hr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/uk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/id.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/be.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/nl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/vi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/ru.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/po/tr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/ada/doc/gnat_ugn/project-manager-figure.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/ada/doc/gnat_ugn/rtlibrary-structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/anint_1.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/bom_UTF-32.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/achar_3.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/altreturn_4.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/intrinsic_actual_4.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/extended_char_comparison_1.f",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/bom_UTF16-BE.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/data_implied_do_1.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/alloc_comp_default_init_2.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/bom_error.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/string_0xfe_0xff_1.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/achar_2.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/bom_UTF16-LE.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/altreturn_5.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/int_1.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/initialization_12.f90",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gfortran.dg/g77/19981216-0.f",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.old-deja/g++.mike/net48.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.old-deja/g++.oliva/thunk1.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.old-deja/g++.other/friend7.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.old-deja/g++.other/friend6.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.old-deja/g++.other/crash41.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gnat.dg/array13.adb",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gcc.c-torture/execute/20000227-1.c",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.dg/parse/condexpr1.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.dg/ext/offsetof1.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.dg/other/default4.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/g++.dg/lookup/using13.C",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/go.test/test/bench/shootout/mandelbrot.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gcc.dg/cpp/utf8-5byte-1.c",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gcc.dg/cpp/strify2.c",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_exception_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_modify_up.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_order_statistics.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_gp_hash_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_gp_hash_int_subscript_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_restoring_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_range_hashing_seq_diagram2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_gp_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_int_erase_mem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_embedded_lists_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_resize_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_join.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_cc_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_find_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_balls_and_bins.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_text_lor_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_embedded_lists_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_range_hashing_seq_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_mem_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_cc_hash_int_subscript_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_binary_priority_queue_int_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_container_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_trie_node_updator_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_different_underlying_dss.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_insert_resize_sequence_diagram3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_mem_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_embedded_lists_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_pop_mem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_find_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_invalidation_guarantee_erase.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_insert_resize_sequence_diagram1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_point_iterators_range_ops_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_binary_priority_queue_int_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_find_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_pat_trie.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_text_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_update_seq_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_node_invalidations.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_text_insert_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_text_insert_trie.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_pairing_priority_queue_text_modify_up_thin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_find_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_ranged_hash_range_hashing_fns.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_int_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_invalidation_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_node_updator_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_mem_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_point_iterators_range_ops_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_pairing_priority_queue_text_modify_down_thin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_point_iterator_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_pairing_priority_queue_text_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_text_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_insert_resize_sequence_diagram2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_rationale_null_node_updator.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_ccgp_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_int_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_different_underlying_dss_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_text_insert_vector.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/confdeps.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_cc_hash_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_hash_zlob_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_list_update.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_different_underlying_dss_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_pairing_priority_queue_text_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_simple_list.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_tree_split_join.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_priority_queue_text_modify_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/html/images/pbds_multimap_text_insert_mem_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/confdeps.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_exception_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_modify_up.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_order_statistics.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_subscript_insert.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_large_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_subscript_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_int_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_restoring_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_range_hashing_seq_diagram2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_push.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_int_erase_mem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_embedded_lists_3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_resize_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_small_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_int_push_pop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_join.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_large_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_small_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_large_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_balls_and_bins.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_lor_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_modify_down_thin.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_lor_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_embedded_lists_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_node_invariants.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_range_hashing_seq_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_small_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_vector.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_push_pop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_small_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_subscript_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_binary_priority_queue_int_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_container_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_trie_node_updator_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_small_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_different_underlying_dss.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_modify_up.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_insert_resize_sequence_diagram3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_push.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_embedded_lists_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_pop_mem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_exception_hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_invalidation_guarantee_erase.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_zlob_int_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_insert_resize_sequence_diagram1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_join.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_point_iterators_range_ops_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_large_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_ccgp_hash_int_subscript_insert.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_binary_priority_queue_int_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_container_tag_hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_large_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_int_erase_mem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_small_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pat_trie.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_text_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_binary_priority_queue_int_push.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_update_seq_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_small_s2p_tree.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_node_invalidations.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_node.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_invalidation_tag_hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_trie.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_modify_up_thin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_trie.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_subscript_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_ranged_hash_range_hashing_fns.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_int_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_modify_up_thin.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_invalidation_tag_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_find_small_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_gp_hash_int_subscript_insert.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_node.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_node_updator_policy_cd.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_tag_hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_point_iterators_range_ops_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_modify_down_thin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_point_iterator_hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_binary_priority_queue_int_push_pop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_insert_resize_sequence_diagram2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_pop_mem.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_large_s2p_hash.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_rationale_null_node_updator.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_ccgp_hash_int_subscript_insert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_int_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_large_s2p_hash.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_different_underlying_dss_1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_text_insert_vector.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/confdeps.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_zlob_int_find.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_list_update.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_different_underlying_dss_2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_order_statistics.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_push_pop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_modify_down.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_pairing_priority_queue_text_push_pop.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_simple_list.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_hash_text_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_int_push.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_split_join.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_tree_split_join.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_push.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_cc_hash_int_subscript_find.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_priority_queue_text_modify_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/doc/xml/images/pbds_multimap_text_insert_mem_large_s2p_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/27_io/basic_filebuf/cons/wchar_t/10132-1.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/time_put/put/char/9780-1.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/compare/char/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/compare/wchar_t/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/hash/char/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/hash/wchar_t/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/transform/char/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate/transform/wchar_t/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/ctype/cons/char/1.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/collate_byname/named_equivalence.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libstdc++-v3/testsuite/22_locale/messages/members/char/2.cc",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/liboffloadmic/include/coi/source/COIBuffer_source.h",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/sr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/fi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/el.po",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/uk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/pt_BR.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/id.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/be.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/nl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/eo.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/vi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/ca.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/ru.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcpp/po/tr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/blast/test.pk",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/puff/zeros.raw",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib.chm",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/Deflater.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/DotZLib.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/Inflater.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/GZipStream.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/dotzlib/DotZLib/CodecBase.cs",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/masmx86/inffas32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/masmx86/gvmat32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/masmx64/inffasx64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/zlib/contrib/masmx64/gvmat64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/pass-sawtooth.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/Mark.Twain-Tom.Sawyer.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/fail-issue5747.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/pass-random2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/e.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/random.data.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/pass-random2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/pass-random1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/bzip2/testdata/pass-random1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/gzip/testdata/issue6550.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-shifts.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text-shift.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-null-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-max.in",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-pi.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-zero.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-null-max.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/null-long-match.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-shifts.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-zero.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-pi.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-pi.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text-shift.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-null-max.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-shifts.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-null-max.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text-shift.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text-shift.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-null-max.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-shifts.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-zero.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/null-long-match.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.golden",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-1k.in",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-pi.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-shifts.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-pi.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-text-shift.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/compress/flate/testdata/huffman-rand-limit.in",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/regexp/testdata/re2-exhaustive.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/go/internal/gccgoimporter/testdata/unicode.gox",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/go/internal/gccgoimporter/testdata/time.gox",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/encoding/json/testdata/code.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.progressive.truncated.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.cmyk.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.separate.dc.progression.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.221212.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.cmyk.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.q50.2x2.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.440.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.411.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.422.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.q50.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.5bpp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.q50.2x2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.separate.dc.progression.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.410.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.rgb.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.410.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.444.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.progressive.truncated.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.221212.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.411.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.440.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.420.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.444.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.422.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-005.gray.q50.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.q50.420.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/testdata/video-001.interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchPaletted.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/invalid-zlib.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchRGB-interlace.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/gray-gradient.interlaced.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchNRGBA-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/invalid-crc32.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchNRGBA-opaque.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/invalid-trunc.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchGray.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/gray-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/benchRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/invalid-noend.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbbn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbbn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn4a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g04-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbbn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftp0n2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn4a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbgn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p02.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbwn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftp0n0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbbn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbwn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbyn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbgn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g02-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p08-trns.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p01.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn6a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftp0n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbrn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p04-31i.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g01-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn3p04.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftbbn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn6a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/basn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/image/png/testdata/pngsuite/ftp1n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/test-trailing-junk.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/symlink.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/crc32-not-streamed.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/go-with-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/readme.notzip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/zip64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/winxp.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/unix.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/go-no-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/dd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/zip64-2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/zip/testdata/readme.zip",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/writer-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/writer-big-long.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/issue10968.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/v7.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/issue12435.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/archive/tar/testdata/neg-size.tar",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/crypto/rsa/testdata/pss-vect.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/crypto/ecdsa/testdata/SigVer.rsp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc620-sparc64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc492-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc493-mips64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc492-mipsle.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/hello-world-core.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-clang-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/zdebug-test-gcc484-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc5-ppc.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc492-mips64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc531-s390x.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/compressed-32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc482-ppc64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc540-mips.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/compressed-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/elf/testdata/go-relocation-test-clang-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/line-clang.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/typedef.macho",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/ranges.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/typedef.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/typedef.elf4",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/line-gcc.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/split.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libgo/go/debug/dwarf/testdata/cycle.elf",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/intl/locale.alias",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libcilkrts/runtime/component.h",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/contrib/regression/GCC_Regression_Tester.wdgt/Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/contrib/regression/GCC_Regression_Tester.wdgt/Default.png",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/contrib/regression/GCC_Regression_Tester.wdgt/ja.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/contrib/regression/GCC_Regression_Tester.wdgt/en.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/contrib/regression/GCC_Regression_Tester.wdgt/de.lproj/InfoPlist.strings",
        "/tmp/vanessa/spack-stage/spack-stage-gcc-7.5.0-qh5blakmd32zstpse6bb3tue5oriwcob/spack-src/libiberty/strverscmp.c"
    ],
    "total_files": 75098
}