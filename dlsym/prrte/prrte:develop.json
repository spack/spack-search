{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-setd7qg7ghtcniplzpcy5uyt42zl4v4f/spack-src/src/mca/prtedl/prtedl.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * @file\n *\n * Dynamic library framework\n *\n * General Description:\n *\n * This framework provides portable access to prtedlopen- and prtedlsym-like\n * functionality, very similar to Libtool's libltprtedl.  Indeed, one of\n * the components in this framework will use libltprtedl, if it is\n * present/available.  However, on some common types systems where\n * libltprtedl headers and libraries are *not* available, we can support\n * plugins via this simple framework.\n *\n * This is a compile-time framework: a single component will be\n * selected by the priority that its configure.m4 provides.  All other\n * components will be ignored (i.e., not built/not part of the\n * installation).  Meaning: the static_components of the prtedl framework\n * will always contain 0 or 1 components.\n *\n * SIDENOTE: PRTE used to embed libltprtedl.  However, as of early\n * 2015, this became problematic, for a variety of complex and\n * uninteresting reasons (see the following if you care about the\n * details: https://github.com/open-mpi/ompi/issues/311,\n * http://debbugs.gnu.org/cgi/bugreport.cgi?bug=19370,\n * https://github.com/open-mpi/ompi/pull/366,\n * https://github.com/open-mpi/ompi/pull/390).  That being said, we,\n * as a developer community, still wanted to be able to natively use\n * DSOs by default.  A small/simple framework for DL functionality,\n * along with a simple component that supports prtedlopen/prtedlsym on POSIX\n * platforms and another component that natively uses libltprtedl seemed\n * like a good solution.\n */\n\n#ifndef PRTE_MCA_DL_DL_H\n#define PRTE_MCA_DL_DL_H\n\n#include \"prte_config.h\"\n\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n\nBEGIN_C_DECLS\n\n/**\n * Handle for an opened file\n */\nstruct prte_dl_handle_t;\ntypedef struct prte_dl_handle_t prte_dl_handle_t;\n\n/**\n * Dynamically open the file specified.\n *\n * Arguments:\n *   fname   = Base filename to open.  If NULL, open this process.\n *   use_ext = If true, try various filename suffixes that are\n *       relevant on this platform (e.g., .so, .prtedll, .dylib).  If\n *       false, just use exactly whatever was passed as fname.\n *   private = If true, open the file in a private namespace.\n *       Otherwise, open the file in a global namespace.\n *   handle = Upon successful open, a handle to the opened file will\n *       be returned.\n *   err_msg= if non-NULL and !=PRTE_SUCCESS is returned, will point to a\n *       string error message\n *\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n * Space for the handle must be allocated by the module (it can be\n * freed during the call to prte_prtedl_base_module_prtedlclose_fn_t).\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to prte_prtedl API calls.\n */\ntypedef int (*prte_prtedl_base_module_open_fn_t)\n    (const char *fname, bool use_ext, bool private_namespace,\n     prte_dl_handle_t **handle, char **err_msg);\n\n/**\n * Lookup a symbol in an opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file\n *   symbol = name of the symbol to lookup\n *   ptr    = if found, a pointer to the symbol.  Otherwise, NULL.\n *   err_msg= if non-NULL and !=PRTE_SUCCESS is returned, will point to a\n *            string error message\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to prte_prtedl API calls.\n */\ntypedef int (*prte_prtedl_base_module_lookup_fn_t)\n    (prte_dl_handle_t *handle, const char *symbol, void **ptr, char **err_msg);\n\n/**\n * Dynamically close a previously dynamically-opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file.\n * Returns:\n *   PRTE_SUCCESS on success, or PRTE_ERROR\n *\n * This function should close the file and free and resources\n * associated with it (e.g., whatever is cached on the handle).\n */\ntypedef int (*prte_prtedl_base_module_close_fn_t)\n    (prte_dl_handle_t *handle);\n\n/**\n * Search through a path of directories, invoking a callback on each\n * unique regular (non-Libtool) file basename found (e.g., will only\n * be invoked once for the files \"foo.la\" and \"foo.so\", with the\n * parameter \"foo\").\n *\n * Arguments:\n *   path   = PRTE_ENV_SEP-delimited list of directories\n *   cb_func= function to invoke on each filename found\n *   data   = context for callback function\n * Returns:\n *   PRTE_SUCESS on success, PRTE_ERR* otherwise\n */\ntypedef int (*prte_prtedl_base_module_foreachfile_fn_t)\n    (const char *search_path,\n     int (*cb_func)(const char *filename, void *context),\n     void *context);\n\n/**\n * Structure for DL components.\n */\nstruct prte_prtedl_base_component_1_0_0_t {\n    /** MCA base component */\n    prte_mca_base_component_t base_version;\n    /** MCA base data */\n    prte_mca_base_component_data_t base_data;\n\n    /** Default priority */\n    int priority;\n};\ntypedef struct prte_prtedl_base_component_1_0_0_t prte_prtedl_base_component_1_0_0_t;\ntypedef struct prte_prtedl_base_component_1_0_0_t prte_prtedl_base_component_t;\n\n/**\n * Structure for DL modules\n */\nstruct prte_prtedl_base_module_1_0_0_t {\n    prte_mca_base_module_2_0_0_t                 super;\n\n    /** Open / close */\n    prte_prtedl_base_module_open_fn_t           open;\n    prte_prtedl_base_module_close_fn_t          close;\n\n    /** Lookup a symbol */\n    prte_prtedl_base_module_lookup_fn_t         lookup;\n\n    /** Iterate looking for files */\n    prte_prtedl_base_module_foreachfile_fn_t    foreachfile;\n};\ntypedef struct prte_prtedl_base_module_1_0_0_t prte_prtedl_base_module_1_0_0_t;\ntypedef struct prte_prtedl_base_module_1_0_0_t prte_prtedl_base_module_t;\n\n/**\n * Macro for use in components that are of type DL\n */\n#define PRTE_DL_BASE_VERSION_1_0_0              \\\n    PRTE_MCA_BASE_VERSION_2_1_0(\"prtedl\", 1, 0, 0)\n\nEND_C_DECLS\n\n#endif /* PRTE_MCA_DL_DL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-setd7qg7ghtcniplzpcy5uyt42zl4v4f/spack-src/src/mca/prtedl/dlopen/prtedl_dlopen_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2018      Amazon.com, Inc. or its affiliates.  All Rights reserved.\n * Copyright (c) 2018-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"constants.h\"\n#include \"src/mca/prtedl/prtedl.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/printf.h\"\n\n#include \"prtedl_dlopen.h\"\n\n\n/*\n * Trivial helper function to avoid replicating code\n */\nstatic void do_dlopen(const char *fname, int flags,\n                      void **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = dlopen(fname, flags);\n\n    if (NULL != err_msg) {\n        if (NULL != *handle) {\n            *err_msg = NULL;\n        } else {\n            *err_msg = dlerror();\n        }\n    }\n}\n\n\nstatic int dlopen_open(const char *fname, bool use_ext, bool private_namespace,\n                       prte_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n\n    /* Setup the prtedlopen flags */\n    int flags = RTLD_LAZY;\n    if (private_namespace) {\n        flags |= RTLD_LOCAL;\n    } else {\n        flags |= RTLD_GLOBAL;\n    }\n\n    /* If the caller wants to use filename extensions, loop through\n       them */\n    void *local_handle = NULL;\n    if (use_ext && NULL != fname) {\n        int i, rc;\n        char *ext;\n\n        for (i = 0, ext = prte_prtedl_dlopen_component.filename_suffixes[i];\n             NULL != ext;\n             ext = prte_prtedl_dlopen_component.filename_suffixes[++i]) {\n            char *name;\n\n            prte_asprintf(&name, \"%s%s\", fname, ext);\n            if (NULL == name) {\n                return PRTE_ERR_IN_ERRNO;\n            }\n\n            /* Does the file exist? */\n            struct stat buf;\n            if (stat(name, &buf) < 0) {\n                if (NULL != err_msg) {\n                    rc = asprintf(err_msg, \"File %s not found\", name);\n                    if (0 > rc) {\n                        free(name);\n                        return PRTE_ERR_OUT_OF_RESOURCE;\n                    }\n                }\n                free(name);\n                continue;\n            }\n\n            /* Yes, the file exists -- try to prtedlopen it.  If we can't\n               prtedlopen it, bail. */\n            do_dlopen(name, flags, &local_handle, err_msg);\n            free(name);\n            break;\n        }\n    }\n\n    /* Otherwise, the caller does not want to use filename extensions,\n       so just use the single filename that the caller provided */\n    else {\n        do_dlopen(fname, flags, &local_handle, err_msg);\n    }\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(prte_dl_handle_t));\n        (*handle)->dlopen_handle = local_handle;\n\n#if PRTE_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n    }\n    return (NULL != local_handle) ? PRTE_SUCCESS : PRTE_ERROR;\n}\n\n\nstatic int dlopen_lookup(prte_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->dlopen_handle);\n    assert(symbol);\n    assert(ptr);\n\n    *ptr = dlsym(handle->dlopen_handle, symbol);\n    if (NULL != *ptr) {\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = dlerror();\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int dlopen_close(prte_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = dlclose(handle->dlopen_handle);\n\n#if PRTE_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\n/*\n * Scan all the files in a directory (or path) and invoke a callback\n * on each one.\n */\nstatic int dlopen_foreachfile(const char *search_path,\n                              int (*func)(const char *filename, void *data),\n                              void *data)\n{\n    int ret;\n    DIR *dp = NULL;\n    char **dirs = NULL;\n    char **good_files = NULL;\n\n    dirs = prte_argv_split(search_path, PRTE_ENV_SEP);\n    for (int i = 0; NULL != dirs && NULL != dirs[i]; ++i) {\n\n        dp = opendir(dirs[i]);\n        if (NULL == dp) {\n            ret = PRTE_ERR_IN_ERRNO;\n            goto error;\n        }\n\n        struct dirent *de;\n        while (NULL != (de = readdir(dp))) {\n\n            /* Make the absolute path name */\n            char *abs_name = NULL;\n            prte_asprintf(&abs_name, \"%s/%s\", dirs[i], de->d_name);\n            if (NULL == abs_name) {\n                ret = PRTE_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Stat the file */\n            struct stat buf;\n            if (stat(abs_name, &buf) < 0) {\n                free(abs_name);\n                ret = PRTE_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Skip if not a file */\n            if (!S_ISREG(buf.st_mode)) {\n                free(abs_name);\n                continue;\n            }\n\n            /* Find the suffix */\n            char *ptr = strrchr(abs_name, '.');\n            if (NULL != ptr) {\n\n                /* Skip libtool files */\n                if (strcmp(ptr, \".la\") == 0 ||\n                    strcmp(ptr, \".lo\") == 0) {\n                    free (abs_name);\n                    continue;\n                }\n\n                *ptr = '\\0';\n            }\n\n            /* Have we already found this file?  Or already found a\n               file with the same basename (but different suffix)? */\n            bool found = false;\n            for (int j = 0; NULL != good_files &&\n                     NULL != good_files[j]; ++j) {\n                if (strcmp(good_files[j], abs_name) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                prte_argv_append_nosize(&good_files, abs_name);\n            }\n            free(abs_name);\n        }\n        closedir(dp);\n    }\n    dp = NULL;\n\n    /* Invoke the callback on all the found files */\n    if (NULL != good_files) {\n        for (int i = 0; NULL != good_files[i]; ++i) {\n            ret = func(good_files[i], data);\n            if (PRTE_SUCCESS != ret) {\n                goto error;\n            }\n        }\n    }\n\n    ret = PRTE_SUCCESS;\n\n error:\n    if (NULL != dp) {\n        closedir(dp);\n    }\n    if (NULL != dirs) {\n        prte_argv_free(dirs);\n    }\n    if (NULL != good_files) {\n        prte_argv_free(good_files);\n    }\n\n    return ret;\n}\n\n\n/*\n * Module definition\n */\nprte_prtedl_base_module_t prte_prtedl_dlopen_module = {\n    .open = dlopen_open,\n    .lookup = dlopen_lookup,\n    .close = dlopen_close,\n    .foreachfile = dlopen_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-setd7qg7ghtcniplzpcy5uyt42zl4v4f/spack-src/src/mca/prtedl/libltdl/prtedl_libltdl_module.c": "/*\n * Copyright (c) 2015-2020 Cisco Systems, Inc.  All rights reserved\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2019-2020 Intel, Inc.  All rights reserved.\n * Copyright (c) 2019      Research Organization for Information Science\n *                         and Technology (RIST).  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"prte_config.h\"\n\n#include \"constants.h\"\n#include \"src/mca/prtedl/prtedl.h\"\n\n#include \"prtedl_libltdl.h\"\n\n\nstatic int libltdl_open(const char *fname, bool use_ext, bool private_namespace,\n                       prte_dl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    lt_prtedlhandle local_handle;\n\n#if PRTE_DL_LIBLTDL_HAVE_LT_DLADVISE\n    prte_prtedl_libltdl_component_t *c = &prte_prtedl_libltdl_component;\n\n    if (use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_ext);\n    } else if (use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_ext);\n    } else if (!use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_noext);\n    } else if (!use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_noext);\n    }\n#else\n    if (use_ext) {\n        local_handle = lt_dlopenext(fname);\n    } else {\n        local_handle = lt_dlopen(fname);\n    }\n#endif\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(prte_dl_handle_t));\n        (*handle)->ltdl_handle = local_handle;\n\n#if PRTE_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int libltdl_lookup(prte_dl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->ltdl_handle);\n    assert(symbol);\n    assert(ptr);\n\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    *ptr = lt_dlsym(handle->ltdl_handle, symbol);\n    if (NULL != *ptr) {\n        return PRTE_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = (char*) lt_dlerror();\n    }\n    return PRTE_ERROR;\n}\n\n\nstatic int libltdl_close(prte_dl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = lt_dlclose(handle->ltdl_handle);\n\n#if PRTE_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\nstatic int libltdl_foreachfile(const char *search_path,\n                               int (*func)(const char *filename, void *data),\n                               void *data)\n{\n    assert(search_path);\n    assert(func);\n\n    int ret = lt_dlforeachfile(search_path, func, data);\n    return (0 == ret) ? PRTE_SUCCESS : PRTE_ERROR;\n}\n\n\n/*\n * Module definition\n */\nprte_prtedl_base_module_t prte_prtedl_libltdl_module = {\n    .open = libltdl_open,\n    .lookup = libltdl_lookup,\n    .close = libltdl_close,\n    .foreachfile = libltdl_foreachfile\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-setd7qg7ghtcniplzpcy5uyt42zl4v4f/spack-src/.git/objects/pack/pack-14a8c0b88de6523a5f5767538926191a1cc489d9.idx",
        "/tmp/vanessa/spack-stage/spack-stage-prrte-develop-setd7qg7ghtcniplzpcy5uyt42zl4v4f/spack-src/.git/objects/pack/pack-14a8c0b88de6523a5f5767538926191a1cc489d9.pack"
    ],
    "total_files": 1090
}