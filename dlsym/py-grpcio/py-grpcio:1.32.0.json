{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-grpcio-1.32.0-4jixkyrniy2qd6w3kzfyixw23pdi5p5y/spack-src/third_party/abseil-cpp/absl/random/internal/randen_detect.cc": "// Copyright 2017 The Abseil Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the\"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an\"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// HERMETIC NOTE: The randen_hwaes target must not introduce duplicate\n// symbols from arbitrary system and other headers, since it may be built\n// with different flags from other targets, using different levels of\n// optimization, potentially introducing ODR violations.\n\n#include \"absl/random/internal/randen_detect.h\"\n\n#include <cstdint>\n#include <cstring>\n\n#include \"absl/random/internal/platform.h\"\n\n#if defined(ABSL_ARCH_X86_64)\n#define ABSL_INTERNAL_USE_X86_CPUID\n#elif defined(ABSL_ARCH_PPC) || defined(ABSL_ARCH_ARM) || \\\n    defined(ABSL_ARCH_AARCH64)\n#if defined(__ANDROID__)\n#define ABSL_INTERNAL_USE_ANDROID_GETAUXVAL\n#define ABSL_INTERNAL_USE_GETAUXVAL\n#elif defined(__linux__)\n#define ABSL_INTERNAL_USE_LINUX_GETAUXVAL\n#define ABSL_INTERNAL_USE_GETAUXVAL\n#endif\n#endif\n\n#if defined(ABSL_INTERNAL_USE_X86_CPUID)\n#if defined(_WIN32) || defined(_WIN64)\n#include <intrin.h>  // NOLINT(build/include_order)\n#pragma intrinsic(__cpuid)\n#else\n// MSVC-equivalent __cpuid intrinsic function.\nstatic void __cpuid(int cpu_info[4], int info_type) {\n  __asm__ volatile(\"cpuid \\n\\t\"\n                   : \"=a\"(cpu_info[0]), \"=b\"(cpu_info[1]), \"=c\"(cpu_info[2]),\n                     \"=d\"(cpu_info[3])\n                   : \"a\"(info_type), \"c\"(0));\n}\n#endif\n#endif  // ABSL_INTERNAL_USE_X86_CPUID\n\n// On linux, just use the c-library getauxval call.\n#if defined(ABSL_INTERNAL_USE_LINUX_GETAUXVAL)\n\nextern \"C\" unsigned long getauxval(unsigned long type);  // NOLINT(runtime/int)\n\nstatic uint32_t GetAuxval(uint32_t hwcap_type) {\n  return static_cast<uint32_t>(getauxval(hwcap_type));\n}\n\n#endif\n\n// On android, probe the system's C library for getauxval().\n// This is the same technique used by the android NDK cpu features library\n// as well as the google open-source cpu_features library.\n//\n// TODO(absl-team): Consider implementing a fallback of directly reading\n// /proc/self/auxval.\n#if defined(ABSL_INTERNAL_USE_ANDROID_GETAUXVAL)\n#include <dlfcn.h>\n\nstatic uint32_t GetAuxval(uint32_t hwcap_type) {\n  // NOLINTNEXTLINE(runtime/int)\n  typedef unsigned long (*getauxval_func_t)(unsigned long);\n\n  dlerror();  // Cleaning error state before calling dlopen.\n  void* libc_handle = dlopen(\"libc.so\", RTLD_NOW);\n  if (!libc_handle) {\n    return 0;\n  }\n  uint32_t result = 0;\n  void* sym = dlsym(libc_handle, \"getauxval\");\n  if (sym) {\n    getauxval_func_t func;\n    memcpy(&func, &sym, sizeof(func));\n    result = static_cast<uint32_t>((*func)(hwcap_type));\n  }\n  dlclose(libc_handle);\n  return result;\n}\n\n#endif\n\nnamespace absl {\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// The default return at the end of the function might be unreachable depending\n// on the configuration. Ignore that warning.\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code-return\"\n#endif\n\n// CPUSupportsRandenHwAes returns whether the CPU is a microarchitecture\n// which supports the crpyto/aes instructions or extensions necessary to use the\n// accelerated RandenHwAes implementation.\n//\n// 1. For x86 it is sufficient to use the CPUID instruction to detect whether\n//    the cpu supports AES instructions. Done.\n//\n// Fon non-x86 it is much more complicated.\n//\n// 2. When ABSL_INTERNAL_USE_GETAUXVAL is defined, use getauxval() (either\n//    the direct c-library version, or the android probing version which loads\n//    libc), and read the hardware capability bits.\n//    This is based on the technique used by boringssl uses to detect\n//    cpu capabilities, and should allow us to enable crypto in the android\n//    builds where it is supported.\n//\n// 3. Use the default for the compiler architecture.\n//\n\nbool CPUSupportsRandenHwAes() {\n#if defined(ABSL_INTERNAL_USE_X86_CPUID)\n  // 1. For x86: Use CPUID to detect the required AES instruction set.\n  int regs[4];\n  __cpuid(reinterpret_cast<int*>(regs), 1);\n  return regs[2] & (1 << 25);  // AES\n\n#elif defined(ABSL_INTERNAL_USE_GETAUXVAL)\n  // 2. Use getauxval() to read the hardware bits and determine\n  // cpu capabilities.\n\n#define AT_HWCAP 16\n#define AT_HWCAP2 26\n#if defined(ABSL_ARCH_PPC)\n  // For Power / PPC: Expect that the cpu supports VCRYPTO\n  // See https://members.openpowerfoundation.org/document/dl/576\n  // VCRYPTO should be present in POWER8 >= 2.07.\n  // Uses Linux kernel constants from arch/powerpc/include/uapi/asm/cputable.h\n  static const uint32_t kVCRYPTO = 0x02000000;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP2);\n  return (hwcap & kVCRYPTO) != 0;\n\n#elif defined(ABSL_ARCH_ARM)\n  // For ARM: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  // Uses Linux kernel constants from arch/arm64/include/asm/hwcap.h\n  static const uint32_t kNEON = 1 << 12;\n  uint32_t hwcap = GetAuxval(AT_HWCAP);\n  if ((hwcap & kNEON) == 0) {\n    return false;\n  }\n\n  // And use it again to detect AES.\n  static const uint32_t kAES = 1 << 0;\n  const uint32_t hwcap2 = GetAuxval(AT_HWCAP2);\n  return (hwcap2 & kAES) != 0;\n\n#elif defined(ABSL_ARCH_AARCH64)\n  // For AARCH64: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  static const uint32_t kNEON = 1 << 1;\n  static const uint32_t kAES = 1 << 3;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP);\n  return ((hwcap & kNEON) != 0) && ((hwcap & kAES) != 0);\n#endif\n\n#else  // ABSL_INTERNAL_USE_GETAUXVAL\n  // 3. By default, assume that the compiler default.\n  return ABSL_HAVE_ACCELERATED_AES ? true : false;\n\n#endif\n  // NOTE: There are some other techniques that may be worth trying:\n  //\n  // * Use an environment variable: ABSL_RANDOM_USE_HWAES\n  //\n  // * Rely on compiler-generated target-based dispatch.\n  // Using x86/gcc it might look something like this:\n  //\n  // int __attribute__((target(\"aes\"))) HasAes() { return 1; }\n  // int __attribute__((target(\"default\"))) HasAes() { return 0; }\n  //\n  // This does not work on all architecture/compiler combinations.\n  //\n  // * On Linux consider reading /proc/cpuinfo and/or /proc/self/auxv.\n  // These files have lines which are easy to parse; for ARM/AARCH64 it is quite\n  // easy to find the Features: line and extract aes / neon. Likewise for\n  // PPC.\n  //\n  // * Fork a process and test for SIGILL:\n  //\n  // * Many architectures have instructions to read the ISA. Unfortunately\n  //   most of those require that the code is running in ring 0 /\n  //   protected-mode.\n  //\n  //   There are several examples. e.g. Valgrind detects PPC ISA 2.07:\n  //   https://github.com/lu-zero/valgrind/blob/master/none/tests/ppc64/test_isa_2_07_part1.c\n  //\n  //   MRS <Xt>, ID_AA64ISAR0_EL1 ; Read ID_AA64ISAR0_EL1 into Xt\n  //\n  //   uint64_t val;\n  //   __asm __volatile(\"mrs %0, id_aa64isar0_el1\" :\"=&r\" (val));\n  //\n  // * Use a CPUID-style heuristic database.\n  //\n  // * On Apple (__APPLE__), AES is available on Arm v8.\n  //   https://stackoverflow.com/questions/45637888/how-to-determine-armv8-features-at-runtime-on-ios\n}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}  // namespace absl\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-grpcio-1.32.0-4jixkyrniy2qd6w3kzfyixw23pdi5p5y/spack-src/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_lookup.cc": "// Copyright 2016 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   https://www.apache.org/licenses/LICENSE-2.0\n//\n//   Unless required by applicable law or agreed to in writing, software\n//   distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//   See the License for the specific language governing permissions and\n//   limitations under the License.\n\n#include \"absl/base/config.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n\n#if defined(__ANDROID__)\n#include <sys/system_properties.h>\n#if defined(__ANDROID_API__) && __ANDROID_API__ >= 21\n#include <dlfcn.h>\n#endif\n#endif\n\n#if defined(__APPLE__)\n#include <CoreFoundation/CFTimeZone.h>\n\n#include <vector>\n#endif\n\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\n#include \"time_zone_fixed.h\"\n#include \"time_zone_impl.h\"\n\nnamespace absl {\nABSL_NAMESPACE_BEGIN\nnamespace time_internal {\nnamespace cctz {\n\n#if defined(__ANDROID__) && defined(__ANDROID_API__) && __ANDROID_API__ >= 21\nnamespace {\n// Android 'L' removes __system_property_get() from the NDK, however\n// it is still a hidden symbol in libc so we use dlsym() to access it.\n// See Chromium's base/sys_info_android.cc for a similar example.\n\nusing property_get_func = int (*)(const char*, char*);\n\nproperty_get_func LoadSystemPropertyGet() {\n  int flag = RTLD_LAZY | RTLD_GLOBAL;\n#if defined(RTLD_NOLOAD)\n  flag |= RTLD_NOLOAD;  // libc.so should already be resident\n#endif\n  if (void* handle = dlopen(\"libc.so\", flag)) {\n    void* sym = dlsym(handle, \"__system_property_get\");\n    dlclose(handle);\n    return reinterpret_cast<property_get_func>(sym);\n  }\n  return nullptr;\n}\n\nint __system_property_get(const char* name, char* value) {\n  static property_get_func system_property_get = LoadSystemPropertyGet();\n  return system_property_get ? system_property_get(name, value) : -1;\n}\n\n}  // namespace\n#endif\n\nstd::string time_zone::name() const { return effective_impl().Name(); }\n\ntime_zone::absolute_lookup time_zone::lookup(\n    const time_point<seconds>& tp) const {\n  return effective_impl().BreakTime(tp);\n}\n\ntime_zone::civil_lookup time_zone::lookup(const civil_second& cs) const {\n  return effective_impl().MakeTime(cs);\n}\n\nbool time_zone::next_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().NextTransition(tp, trans);\n}\n\nbool time_zone::prev_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().PrevTransition(tp, trans);\n}\n\nstd::string time_zone::version() const { return effective_impl().Version(); }\n\nstd::string time_zone::description() const {\n  return effective_impl().Description();\n}\n\nconst time_zone::Impl& time_zone::effective_impl() const {\n  if (impl_ == nullptr) {\n    // Dereferencing an implicit-UTC time_zone is expected to be\n    // rare, so we don't mind paying a small synchronization cost.\n    return *time_zone::Impl::UTC().impl_;\n  }\n  return *impl_;\n}\n\nbool load_time_zone(const std::string& name, time_zone* tz) {\n  return time_zone::Impl::LoadTimeZone(name, tz);\n}\n\ntime_zone utc_time_zone() {\n  return time_zone::Impl::UTC();  // avoid name lookup\n}\n\ntime_zone fixed_time_zone(const seconds& offset) {\n  time_zone tz;\n  load_time_zone(FixedOffsetToName(offset), &tz);\n  return tz;\n}\n\ntime_zone local_time_zone() {\n  const char* zone = \":localtime\";\n#if defined(__ANDROID__)\n  char sysprop[PROP_VALUE_MAX];\n  if (__system_property_get(\"persist.sys.timezone\", sysprop) > 0) {\n    zone = sysprop;\n  }\n#endif\n#if defined(__APPLE__)\n  std::vector<char> buffer;\n  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();\n  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {\n    CFStringEncoding encoding = kCFStringEncodingUTF8;\n    CFIndex length = CFStringGetLength(tz_name);\n    buffer.resize(CFStringGetMaximumSizeForEncoding(length, encoding) + 1);\n    if (CFStringGetCString(tz_name, &buffer[0], buffer.size(), encoding)) {\n      zone = &buffer[0];\n    }\n  }\n  CFRelease(tz_default);\n#endif\n\n  // Allow ${TZ} to override to default zone.\n  char* tz_env = nullptr;\n#if defined(_MSC_VER)\n  _dupenv_s(&tz_env, nullptr, \"TZ\");\n#else\n  tz_env = std::getenv(\"TZ\");\n#endif\n  if (tz_env) zone = tz_env;\n\n  // We only support the \"[:]<zone-name>\" form.\n  if (*zone == ':') ++zone;\n\n  // Map \"localtime\" to a system-specific name, but\n  // allow ${LOCALTIME} to override the default name.\n  char* localtime_env = nullptr;\n  if (strcmp(zone, \"localtime\") == 0) {\n#if defined(_MSC_VER)\n    // System-specific default is just \"localtime\".\n    _dupenv_s(&localtime_env, nullptr, \"LOCALTIME\");\n#else\n    zone = \"/etc/localtime\";  // System-specific default.\n    localtime_env = std::getenv(\"LOCALTIME\");\n#endif\n    if (localtime_env) zone = localtime_env;\n  }\n\n  const std::string name = zone;\n#if defined(_MSC_VER)\n  free(localtime_env);\n  free(tz_env);\n#endif\n\n  time_zone tz;\n  load_time_zone(name, &tz);  // Falls back to UTC.\n  // TODO: Follow the RFC3339 \"Unknown Local Offset Convention\" and\n  // arrange for %z to generate \"-0000\" when we don't know the local\n  // offset because the load_time_zone() failed and we're using UTC.\n  return tz;\n}\n\n}  // namespace cctz\n}  // namespace time_internal\nABSL_NAMESPACE_END\n}  // namespace absl\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-grpcio-1.32.0-4jixkyrniy2qd6w3kzfyixw23pdi5p5y/spack-src/src/core/lib/gpr/env_linux.cc": "/*\n *\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* for secure_getenv. */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <grpc/support/port_platform.h>\n\n#ifdef GPR_LINUX_ENV\n\n#include \"src/core/lib/gpr/env.h\"\n\n#include <dlfcn.h>\n#include <features.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <grpc/support/log.h>\n#include <grpc/support/string_util.h>\n\n#include \"src/core/lib/gpr/string.h\"\n#include \"src/core/lib/gpr/useful.h\"\n\nchar* gpr_getenv(const char* name) {\n  char* result = nullptr;\n#if defined(GPR_BACKWARDS_COMPATIBILITY_MODE)\n  typedef char* (*getenv_type)(const char*);\n  static getenv_type getenv_func = nullptr;\n  /* Check to see which getenv variant is supported (go from most\n   * to least secure) */\n  if (getenv_func == nullptr) {\n    const char* names[] = {\"secure_getenv\", \"__secure_getenv\", \"getenv\"};\n    for (size_t i = 0; i < GPR_ARRAY_SIZE(names); i++) {\n      getenv_func = (getenv_type)dlsym(RTLD_DEFAULT, names[i]);\n      if (getenv_func != nullptr) {\n        break;\n      }\n    }\n  }\n  result = getenv_func(name);\n#elif __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17)\n  result = secure_getenv(name);\n#else\n  result = getenv(name);\n#endif\n  return result == nullptr ? result : gpr_strdup(result);\n}\n\nvoid gpr_setenv(const char* name, const char* value) {\n  int res = setenv(name, value, 1);\n  GPR_ASSERT(res == 0);\n}\n\nvoid gpr_unsetenv(const char* name) {\n  int res = unsetenv(name);\n  GPR_ASSERT(res == 0);\n}\n\n#endif /* GPR_LINUX_ENV */\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-grpcio-1.32.0-4jixkyrniy2qd6w3kzfyixw23pdi5p5y/spack-src/include/grpc/impl/codegen/port_platform.h": "/*\n *\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#ifndef GRPC_IMPL_CODEGEN_PORT_PLATFORM_H\n#define GRPC_IMPL_CODEGEN_PORT_PLATFORM_H\n\n/*\n * Define GPR_BACKWARDS_COMPATIBILITY_MODE to try harder to be ABI\n * compatible with older platforms (currently only on Linux)\n * Causes:\n *  - some libc calls to be gotten via dlsym\n *  - some syscalls to be made directly\n */\n\n/*\n * Defines GPR_ABSEIL_SYNC to use synchronization features from Abseil\n */\n#ifndef GPR_ABSEIL_SYNC\n#if defined(__APPLE__)\n// This is disabled on Apple platforms because macos/grpc_basictests_c_cpp\n// fails with this. https://github.com/grpc/grpc/issues/23661\n#else\n#define GPR_ABSEIL_SYNC 1\n#endif\n#endif  // GPR_ABSEIL_SYNC\n\n/* Get windows.h included everywhere (we need it) */\n#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)\n#ifndef WIN32_LEAN_AND_MEAN\n#define GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED\n#define WIN32_LEAN_AND_MEAN\n#endif /* WIN32_LEAN_AND_MEAN */\n\n#ifndef NOMINMAX\n#define GRPC_NOMINMX_WAS_NOT_DEFINED\n#define NOMINMAX\n#endif /* NOMINMAX */\n\n#include <windows.h>\n\n#ifndef _WIN32_WINNT\n#error \\\n    \"Please compile grpc with _WIN32_WINNT of at least 0x600 (aka Windows Vista)\"\n#else /* !defined(_WIN32_WINNT) */\n#if (_WIN32_WINNT < 0x0600)\n#error \\\n    \"Please compile grpc with _WIN32_WINNT of at least 0x600 (aka Windows Vista)\"\n#endif /* _WIN32_WINNT < 0x0600 */\n#endif /* defined(_WIN32_WINNT) */\n\n#ifdef GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED\n#undef GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED\n#undef WIN32_LEAN_AND_MEAN\n#endif /* GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED */\n\n#ifdef GRPC_NOMINMAX_WAS_NOT_DEFINED\n#undef GRPC_NOMINMAX_WAS_NOT_DEFINED\n#undef NOMINMAX\n#endif /* GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED */\n#endif /* defined(_WIN64) || defined(WIN64) || defined(_WIN32) || \\\n          defined(WIN32) */\n\n/* Override this file with one for your platform if you need to redefine\n   things.  */\n\n#if !defined(GPR_NO_AUTODETECT_PLATFORM)\n#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)\n#if defined(_WIN64) || defined(WIN64)\n#define GPR_ARCH_64 1\n#else\n#define GPR_ARCH_32 1\n#endif\n#define GPR_PLATFORM_STRING \"windows\"\n#define GPR_WINDOWS 1\n#define GPR_WINDOWS_SUBPROCESS 1\n#define GPR_WINDOWS_ENV\n#ifdef __MSYS__\n#define GPR_GETPID_IN_UNISTD_H 1\n#define GPR_MSYS_TMPFILE\n#define GPR_POSIX_LOG\n#define GPR_POSIX_STRING\n#define GPR_POSIX_TIME\n#else\n#define GPR_GETPID_IN_PROCESS_H 1\n#define GPR_WINDOWS_TMPFILE\n#define GPR_WINDOWS_LOG\n#define GPR_WINDOWS_CRASH_HANDLER 1\n#define GPR_WINDOWS_STRING\n#define GPR_WINDOWS_TIME\n#endif\n#ifdef __GNUC__\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#else\n#define GPR_WINDOWS_ATOMIC 1\n#define GPR_MSVC_TLS 1\n#endif\n#elif defined(ANDROID) || defined(__ANDROID__)\n#define GPR_PLATFORM_STRING \"android\"\n#define GPR_ANDROID 1\n// TODO(apolcyn): re-evaluate support for c-ares\n// on android after upgrading our c-ares dependency.\n// See https://github.com/grpc/grpc/issues/18038.\n#define GRPC_ARES 0\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_SYNC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_ANDROID_LOG 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#define GPR_SUPPORT_CHANNELS_FROM_FD 1\n#elif defined(__linux__)\n#define GPR_PLATFORM_STRING \"linux\"\n#ifndef _BSD_SOURCE\n#define _BSD_SOURCE\n#endif\n#ifndef _DEFAULT_SOURCE\n#define _DEFAULT_SOURCE\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <features.h>\n#define GPR_CPU_LINUX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_LINUX 1\n#define GPR_LINUX_LOG\n#define GPR_SUPPORT_CHANNELS_FROM_FD 1\n#define GPR_LINUX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#ifdef __GLIBC__\n#define GPR_POSIX_CRASH_HANDLER 1\n#define GPR_LINUX_PTHREAD_NAME 1\n#include <linux/version.h>\n#else /* musl libc */\n#define GPR_MUSL_LIBC_COMPAT 1\n#endif\n#elif defined(__ASYLO__)\n#define GPR_ARCH_64 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_TLS 1\n#define GPR_PLATFORM_STRING \"asylo\"\n#define GPR_GCC_SYNC 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_TIME 1\n#define GPR_POSIX_ENV 1\n#define GPR_ASYLO 1\n#define GRPC_POSIX_SOCKET 1\n#define GRPC_POSIX_SOCKETADDR\n#define GRPC_POSIX_SOCKETUTILS 1\n#define GRPC_TIMER_USE_GENERIC 1\n#define GRPC_POSIX_NO_SPECIAL_WAKEUP_FD 1\n#define GRPC_POSIX_WAKEUP_FD 1\n#define GRPC_ARES 0\n#define GPR_NO_AUTODETECT_PLATFORM 1\n#elif defined(__APPLE__)\n#include <Availability.h>\n#include <TargetConditionals.h>\n#ifndef _BSD_SOURCE\n#define _BSD_SOURCE\n#endif\n#if TARGET_OS_IPHONE\n#define GPR_PLATFORM_STRING \"ios\"\n#define GPR_CPU_IPHONE 1\n#define GPR_PTHREAD_TLS 1\n#define GRPC_CFSTREAM 1\n/* the c-ares resolver isn't safe to enable on iOS */\n#define GRPC_ARES 0\n#else /* TARGET_OS_IPHONE */\n#define GPR_PLATFORM_STRING \"osx\"\n#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED\n#if __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_7\n#define GPR_CPU_IPHONE 1\n#define GPR_PTHREAD_TLS 1\n#else /* __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_7 */\n#define GPR_CPU_POSIX 1\n/* TODO(vjpai): there is a reported issue in bazel build for Mac where __thread\n   in a header is currently not working (bazelbuild/bazel#4341). Remove\n   the following conditional and use GPR_GCC_TLS when that is fixed */\n#ifndef GRPC_BAZEL_BUILD\n#define GPR_GCC_TLS 1\n#else /* GRPC_BAZEL_BUILD */\n#define GPR_PTHREAD_TLS 1\n#endif /* GRPC_BAZEL_BUILD */\n#define GPR_APPLE_PTHREAD_NAME 1\n#endif\n#else /* __MAC_OS_X_VERSION_MIN_REQUIRED */\n#define GPR_CPU_POSIX 1\n/* TODO(vjpai): Remove the following conditional and use only GPR_GCC_TLS\n   when bazelbuild/bazel#4341 is fixed */\n#ifndef GRPC_BAZEL_BUILD\n#define GPR_GCC_TLS 1\n#else /* GRPC_BAZEL_BUILD */\n#define GPR_PTHREAD_TLS 1\n#endif /* GRPC_BAZEL_BUILD */\n#endif\n#define GPR_POSIX_CRASH_HANDLER 1\n#endif\n#define GPR_APPLE 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#ifndef GRPC_CFSTREAM\n#define GPR_SUPPORT_CHANNELS_FROM_FD 1\n#endif\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(__FreeBSD__)\n#define GPR_PLATFORM_STRING \"freebsd\"\n#ifndef _BSD_SOURCE\n#define _BSD_SOURCE\n#endif\n#define GPR_FREEBSD 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#define GPR_SUPPORT_CHANNELS_FROM_FD 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(__OpenBSD__)\n#define GPR_PLATFORM_STRING \"openbsd\"\n#ifndef _BSD_SOURCE\n#define _BSD_SOURCE\n#endif\n#define GPR_OPENBSD 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#define GPR_SUPPORT_CHANNELS_FROM_FD 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(__sun) && defined(__SVR4)\n#define GPR_PLATFORM_STRING \"solaris\"\n#define GPR_SOLARIS 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(_AIX)\n#define GPR_PLATFORM_STRING \"aix\"\n#ifndef _ALL_SOURCE\n#define _ALL_SOURCE\n#endif\n#define GPR_AIX 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(__native_client__)\n#define GPR_PLATFORM_STRING \"nacl\"\n#ifndef _BSD_SOURCE\n#define _BSD_SOURCE\n#endif\n#ifndef _DEFAULT_SOURCE\n#define _DEFAULT_SOURCE\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define GPR_NACL 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_GCC_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#ifdef _LP64\n#define GPR_ARCH_64 1\n#else /* _LP64 */\n#define GPR_ARCH_32 1\n#endif /* _LP64 */\n#elif defined(__Fuchsia__)\n#define GPR_FUCHSIA 1\n#define GPR_ARCH_64 1\n#define GPR_PLATFORM_STRING \"fuchsia\"\n#include <features.h>\n// Specifying musl libc affects wrap_memcpy.c. It causes memmove() to be\n// invoked.\n#define GPR_MUSL_LIBC_COMPAT 1\n#define GPR_CPU_POSIX 1\n#define GPR_GCC_ATOMIC 1\n#define GPR_PTHREAD_TLS 1\n#define GPR_POSIX_LOG 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_ENV 1\n#define GPR_POSIX_TMPFILE 1\n#define GPR_POSIX_SUBPROCESS 1\n#define GPR_POSIX_SYNC 1\n#define GPR_POSIX_STRING 1\n#define GPR_POSIX_TIME 1\n#define GPR_HAS_PTHREAD_H 1\n#define GPR_GETPID_IN_UNISTD_H 1\n#else\n#error \"Could not auto-detect platform\"\n#endif\n#endif /* GPR_NO_AUTODETECT_PLATFORM */\n\n#if defined(GPR_BACKWARDS_COMPATIBILITY_MODE)\n/*\n * For backward compatibility mode, reset _FORTIFY_SOURCE to prevent\n * a library from having non-standard symbols such as __asprintf_chk.\n * This helps non-glibc systems such as alpine using musl to find symbols.\n */\n#if defined(_FORTIFY_SOURCE) && _FORTIFY_SOURCE > 0\n#undef _FORTIFY_SOURCE\n#define _FORTIFY_SOURCE 0\n#endif\n#endif\n\n/*\n *  There are platforms for which TLS should not be used even though the\n * compiler makes it seem like it's supported (Android NDK < r12b for example).\n * This is primarily because of linker problems and toolchain misconfiguration:\n * TLS isn't supported until NDK r12b per\n * https://developer.android.com/ndk/downloads/revision_history.html\n * TLS also does not work with Android NDK if GCC is being used as the compiler\n * instead of Clang.\n * Since NDK r16, `__NDK_MAJOR__` and `__NDK_MINOR__` are defined in\n * <android/ndk-version.h>. For NDK < r16, users should define these macros,\n * e.g. `-D__NDK_MAJOR__=11 -D__NKD_MINOR__=0` for NDK r11. */\n#if defined(__ANDROID__) && defined(GPR_GCC_TLS)\n#if __has_include(<android/ndk-version.h>)\n#include <android/ndk-version.h>\n#endif /* __has_include(<android/ndk-version.h>) */\n#if (defined(__clang__) && defined(__NDK_MAJOR__) && defined(__NDK_MINOR__) && \\\n     ((__NDK_MAJOR__ < 12) ||                                                  \\\n      ((__NDK_MAJOR__ == 12) && (__NDK_MINOR__ < 1)))) ||                      \\\n    (defined(__GNUC__) && !defined(__clang__))\n#undef GPR_GCC_TLS\n#define GPR_PTHREAD_TLS 1\n#endif\n#endif /*defined(__ANDROID__) && defined(GPR_GCC_TLS) */\n\n#if defined(__has_include)\n#if __has_include(<atomic>)\n#define GRPC_HAS_CXX11_ATOMIC\n#endif /* __has_include(<atomic>) */\n#endif /* defined(__has_include) */\n\n#ifndef GPR_PLATFORM_STRING\n#warning \"GPR_PLATFORM_STRING not auto-detected\"\n#define GPR_PLATFORM_STRING \"unknown\"\n#endif\n\n#ifdef GPR_GCOV\n#undef GPR_FORBID_UNREACHABLE_CODE\n#define GPR_FORBID_UNREACHABLE_CODE 1\n#endif\n\n#ifdef _MSC_VER\n#if _MSC_VER < 1700\ntypedef __int8 int8_t;\ntypedef __int16 int16_t;\ntypedef __int32 int32_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int8 uint8_t;\ntypedef unsigned __int16 uint16_t;\ntypedef unsigned __int32 uint32_t;\ntypedef unsigned __int64 uint64_t;\n#else\n#include <stdint.h>\n#endif /* _MSC_VER < 1700 */\n#else\n#include <stdint.h>\n#endif /* _MSC_VER */\n\n/* Type of cycle clock implementation */\n#ifdef GPR_LINUX\n/* Disable cycle clock by default.\n   TODO(soheil): enable when we support fallback for unstable cycle clocks.\n#if defined(__i386__)\n#define GPR_CYCLE_COUNTER_RDTSC_32 1\n#elif defined(__x86_64__) || defined(__amd64__)\n#define GPR_CYCLE_COUNTER_RDTSC_64 1\n#else\n#define GPR_CYCLE_COUNTER_FALLBACK 1\n#endif\n*/\n#define GPR_CYCLE_COUNTER_FALLBACK 1\n#else\n#define GPR_CYCLE_COUNTER_FALLBACK 1\n#endif /* GPR_LINUX */\n\n/* Cache line alignment */\n#ifndef GPR_CACHELINE_SIZE_LOG\n#if defined(__i386__) || defined(__x86_64__)\n#define GPR_CACHELINE_SIZE_LOG 6\n#endif\n#ifndef GPR_CACHELINE_SIZE_LOG\n/* A reasonable default guess. Note that overestimates tend to waste more\n   space, while underestimates tend to waste more time. */\n#define GPR_CACHELINE_SIZE_LOG 6\n#endif /* GPR_CACHELINE_SIZE_LOG */\n#endif /* GPR_CACHELINE_SIZE_LOG */\n\n#define GPR_CACHELINE_SIZE (1 << GPR_CACHELINE_SIZE_LOG)\n\n/* scrub GCC_ATOMIC if it's not available on this compiler */\n#if defined(GPR_GCC_ATOMIC) && !defined(__ATOMIC_RELAXED)\n#undef GPR_GCC_ATOMIC\n#define GPR_GCC_SYNC 1\n#endif\n\n/* Validate platform combinations */\n#if defined(GPR_GCC_ATOMIC) + defined(GPR_GCC_SYNC) + \\\n        defined(GPR_WINDOWS_ATOMIC) !=                \\\n    1\n#error Must define exactly one of GPR_GCC_ATOMIC, GPR_GCC_SYNC, GPR_WINDOWS_ATOMIC\n#endif\n\n#if defined(GPR_ARCH_32) + defined(GPR_ARCH_64) != 1\n#error Must define exactly one of GPR_ARCH_32, GPR_ARCH_64\n#endif\n\n#if defined(GPR_CPU_LINUX) + defined(GPR_CPU_POSIX) + defined(GPR_WINDOWS) + \\\n        defined(GPR_CPU_IPHONE) + defined(GPR_CPU_CUSTOM) !=                 \\\n    1\n#error Must define exactly one of GPR_CPU_LINUX, GPR_CPU_POSIX, GPR_WINDOWS, GPR_CPU_IPHONE, GPR_CPU_CUSTOM\n#endif\n\n#if defined(GPR_MSVC_TLS) + defined(GPR_GCC_TLS) + defined(GPR_PTHREAD_TLS) + \\\n        defined(GPR_CUSTOM_TLS) !=                                            \\\n    1\n#error Must define exactly one of GPR_MSVC_TLS, GPR_GCC_TLS, GPR_PTHREAD_TLS, GPR_CUSTOM_TLS\n#endif\n\n/* maximum alignment needed for any type on this platform, rounded up to a\n   power of two */\n#define GPR_MAX_ALIGNMENT 16\n\n#ifndef GRPC_ARES\n#define GRPC_ARES 1\n#endif\n\n#ifndef GRPC_IF_NAMETOINDEX\n#define GRPC_IF_NAMETOINDEX 1\n#endif\n\n#ifndef GRPC_MUST_USE_RESULT\n#if defined(__GNUC__) && !defined(__MINGW32__)\n#define GRPC_MUST_USE_RESULT __attribute__((warn_unused_result))\n#define GPR_ALIGN_STRUCT(n) __attribute__((aligned(n)))\n#else\n#define GRPC_MUST_USE_RESULT\n#define GPR_ALIGN_STRUCT(n)\n#endif\n#endif\n\n#ifndef GRPC_UNUSED\n#if defined(__GNUC__) && !defined(__MINGW32__)\n#define GRPC_UNUSED __attribute__((unused))\n#else\n#define GRPC_UNUSED\n#endif\n#endif\n\n#ifndef GPR_PRINT_FORMAT_CHECK\n#ifdef __GNUC__\n#define GPR_PRINT_FORMAT_CHECK(FORMAT_STR, ARGS) \\\n  __attribute__((format(printf, FORMAT_STR, ARGS)))\n#else\n#define GPR_PRINT_FORMAT_CHECK(FORMAT_STR, ARGS)\n#endif\n#endif /* GPR_PRINT_FORMAT_CHECK */\n\n#if GPR_FORBID_UNREACHABLE_CODE\n#define GPR_UNREACHABLE_CODE(STATEMENT)\n#else\n#define GPR_UNREACHABLE_CODE(STATEMENT)             \\\n  do {                                              \\\n    gpr_log(GPR_ERROR, \"Should never reach here.\"); \\\n    abort();                                        \\\n    STATEMENT;                                      \\\n  } while (0)\n#endif /* GPR_FORBID_UNREACHABLE_CODE */\n\n#ifndef GPRAPI\n#define GPRAPI\n#endif\n\n#ifndef GRPCAPI\n#define GRPCAPI GPRAPI\n#endif\n\n#ifndef CENSUSAPI\n#define CENSUSAPI GRPCAPI\n#endif\n\n#ifndef GPR_HAS_ATTRIBUTE\n#ifdef __has_attribute\n#define GPR_HAS_ATTRIBUTE(a) __has_attribute(a)\n#else\n#define GPR_HAS_ATTRIBUTE(a) 0\n#endif\n#endif /* GPR_HAS_ATTRIBUTE */\n\n#ifndef GPR_HAS_FEATURE\n#ifdef __has_feature\n#define GPR_HAS_FEATURE(a) __has_feature(a)\n#else\n#define GPR_HAS_FEATURE(a) 0\n#endif\n#endif /* GPR_HAS_FEATURE */\n\n#ifndef GPR_ATTRIBUTE_NOINLINE\n#if GPR_HAS_ATTRIBUTE(noinline) || (defined(__GNUC__) && !defined(__clang__))\n#define GPR_ATTRIBUTE_NOINLINE __attribute__((noinline))\n#define GPR_HAS_ATTRIBUTE_NOINLINE 1\n#else\n#define GPR_ATTRIBUTE_NOINLINE\n#endif\n#endif /* GPR_ATTRIBUTE_NOINLINE */\n\n#ifndef GPR_ATTRIBUTE_WEAK\n/* Attribute weak is broken on LLVM/windows:\n * https://bugs.llvm.org/show_bug.cgi?id=37598 */\n#if (GPR_HAS_ATTRIBUTE(weak) || (defined(__GNUC__) && !defined(__clang__))) && \\\n    !(defined(__llvm__) && defined(_WIN32))\n#define GPR_ATTRIBUTE_WEAK __attribute__((weak))\n#define GPR_HAS_ATTRIBUTE_WEAK 1\n#else\n#define GPR_ATTRIBUTE_WEAK\n#endif\n#endif /* GPR_ATTRIBUTE_WEAK */\n\n#ifndef GPR_ATTRIBUTE_NO_TSAN /* (1) */\n#if GPR_HAS_FEATURE(thread_sanitizer)\n#define GPR_ATTRIBUTE_NO_TSAN __attribute__((no_sanitize(\"thread\")))\n#endif                        /* GPR_HAS_FEATURE */\n#ifndef GPR_ATTRIBUTE_NO_TSAN /* (2) */\n#define GPR_ATTRIBUTE_NO_TSAN\n#endif /* GPR_ATTRIBUTE_NO_TSAN (2) */\n#endif /* GPR_ATTRIBUTE_NO_TSAN (1) */\n\n/* GRPC_TSAN_ENABLED will be defined, when compiled with thread sanitizer. */\n#ifndef GRPC_TSAN_SUPPRESSED\n#if defined(__SANITIZE_THREAD__)\n#define GRPC_TSAN_ENABLED\n#elif GPR_HAS_FEATURE(thread_sanitizer)\n#define GRPC_TSAN_ENABLED\n#endif\n#endif\n\n/* GRPC_ASAN_ENABLED will be defined, when compiled with address sanitizer. */\n#ifndef GRPC_ASAN_SUPPRESSED\n#if defined(__SANITIZE_ADDRESS__)\n#define GRPC_ASAN_ENABLED\n#elif GPR_HAS_FEATURE(address_sanitizer)\n#define GRPC_ASAN_ENABLED\n#endif\n#endif\n\n/* GRPC_ALLOW_EXCEPTIONS should be 0 or 1 if exceptions are allowed or not */\n#ifndef GRPC_ALLOW_EXCEPTIONS\n#ifdef GPR_WINDOWS\n#if defined(_MSC_VER) && defined(_CPPUNWIND)\n#define GRPC_ALLOW_EXCEPTIONS 1\n#elif defined(__EXCEPTIONS)\n#define GRPC_ALLOW_EXCEPTIONS 1\n#else\n#define GRPC_ALLOW_EXCEPTIONS 0\n#endif\n#else /* GPR_WINDOWS */\n#ifdef __EXCEPTIONS\n#define GRPC_ALLOW_EXCEPTIONS 1\n#else /* __EXCEPTIONS */\n#define GRPC_ALLOW_EXCEPTIONS 0\n#endif /* __EXCEPTIONS */\n#endif /* __GPR_WINDOWS */\n#endif /* GRPC_ALLOW_EXCEPTIONS */\n\n/* Use GPR_LIKELY only in cases where you are sure that a certain outcome is the\n * most likely. Ideally, also collect performance numbers to justify the claim.\n */\n#ifdef __GNUC__\n#define GPR_LIKELY(x) __builtin_expect((x), 1)\n#define GPR_UNLIKELY(x) __builtin_expect((x), 0)\n#else /* __GNUC__ */\n#define GPR_LIKELY(x) (x)\n#define GPR_UNLIKELY(x) (x)\n#endif /* __GNUC__ */\n\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n\n#endif /* GRPC_IMPL_CODEGEN_PORT_PLATFORM_H */\n"
    },
    "skipped": [],
    "total_files": 3221
}