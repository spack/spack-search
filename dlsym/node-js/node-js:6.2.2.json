{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/openssl/include/openssl/dso.h": "/* dso.h */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n# define HEADER_DSO_H\n\n# include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n# define DSO_CTRL_GET_FLAGS      1\n# define DSO_CTRL_SET_FLAGS      2\n# define DSO_CTRL_OR_FLAGS       3\n\n/*\n * By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the\n * DSO object (using DSO_set_name_converter()). This callback could even\n * utilise the DSO_METHOD's converter too if it only wants to override\n * behaviour for one or two possible DSO methods. However, the following flag\n * can be set in a DSO to prevent *any* native name-translation at all - eg.\n * if the caller has prompted the user for a path to a driver library so the\n * filename should be interpreted as-is.\n */\n# define DSO_FLAG_NO_NAME_TRANSLATION            0x01\n/*\n * An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and other\n * operating systems where the translation also may prefix the name with\n * something, like 'lib', and ignored everywhere else. This flag is also\n * ignored if DSO_FLAG_NO_NAME_TRANSLATION is used at the same time.\n */\n# define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY      0x02\n\n/*\n * The following flag controls the translation of symbol names to upper case.\n * This is currently only being implemented for OpenVMS.\n */\n# define DSO_FLAG_UPCASE_SYMBOL                  0x10\n\n/*\n * This flag loads the library with public symbols. Meaning: The exported\n * symbols of this library are public to all libraries loaded after this\n * library. At the moment only implemented in unix.\n */\n# define DSO_FLAG_GLOBAL_SYMBOLS                 0x20\n\ntypedef void (*DSO_FUNC_TYPE) (void);\n\ntypedef struct dso_st DSO;\n\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure\n * pointer (or NULL if they are to be used independantly of a DSO object) and\n * a filename to transform. They should either return NULL (if there is an\n * error condition) or a newly allocated string containing the transformed\n * form that the caller will need to free with OPENSSL_free() when done.\n */\ntypedef char *(*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a DSO\n * structure pointer (or NULL if they are to be used independantly of a DSO\n * object) and two file specifications to merge. They should either return\n * NULL (if there is an error condition) or a newly allocated string\n * containing the result of merging that the caller will need to free with\n * OPENSSL_free() when done. Here, merging means that bits and pieces are\n * taken from each of the file specifications and added together in whatever\n * fashion that is sensible for the DSO method in question.  The only rule\n * that really applies is that if the two specification contain pieces of the\n * same type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the second\n * being a bunch of defaults to add on if they're missing in the first.\n */\ntypedef char *(*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st {\n    const char *name;\n    /*\n     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n     * successful load populates the loaded_filename field, and likewise a\n     * successful unload OPENSSL_frees and NULLs it out.\n     */\n    int (*dso_load) (DSO *dso);\n    /* Unloads a shared library */\n    int (*dso_unload) (DSO *dso);\n    /* Binds a variable */\n    void *(*dso_bind_var) (DSO *dso, const char *symname);\n    /*\n     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n     * be cast to the real function prototype by the caller. Platforms that\n     * don't have compatible representations for different prototypes (this\n     * is possible within ANSI C) are highly unlikely to have shared\n     * libraries at all, let alone a DSO_METHOD implemented for them.\n     */\n    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n/* I don't think this would actually be used in any circumstances. */\n# if 0\n    /* Unbinds a variable */\n    int (*dso_unbind_var) (DSO *dso, char *symname, void *symptr);\n    /* Unbinds a function */\n    int (*dso_unbind_func) (DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n# endif\n    /*\n     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n     * (rather than zero) indicate errors.\n     */\n    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_MERGER_FUNC dso_merger;\n    /* [De]Initialisation handlers. */\n    int (*init) (DSO *dso);\n    int (*finish) (DSO *dso);\n    /* Return pathname of the module containing location */\n    int (*pathbyaddr) (void *addr, char *path, int sz);\n    /* Perform global symbol lookup, i.e. among *all* modules */\n    void *(*globallookup) (const char *symname);\n} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st {\n    DSO_METHOD *meth;\n    /*\n     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n     * anything but will need to cache the filename for use in the dso_bind\n     * handler. All in all, let each method control its own destiny.\n     * \"Handles\" and such go in a STACK.\n     */\n    STACK_OF(void) *meth_data;\n    int references;\n    int flags;\n    /*\n     * For use by applications etc ... use this for your bits'n'pieces, don't\n     * touch meth_data!\n     */\n    CRYPTO_EX_DATA ex_data;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n     * should normally set using DSO_set_name_converter().\n     */\n    DSO_NAME_CONVERTER_FUNC name_converter;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_merger. NB: This should\n     * normally set using DSO_set_merger().\n     */\n    DSO_MERGER_FUNC merger;\n    /*\n     * This is populated with (a copy of) the platform-independant filename\n     * used for this DSO.\n     */\n    char *filename;\n    /*\n     * This is populated with (a copy of) the translated filename by which\n     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n     * loaded. NB: This is here because the filename translation process may\n     * involve a callback being invoked more than once not only to convert to\n     * a platform-specific form, but also to try different filenames in the\n     * process of trying to perform a load. As such, this variable can be\n     * used to indicate (a) whether this DSO structure corresponds to a\n     * loaded library or not, and (b) the filename with which it was actually\n     * loaded.\n     */\n    char *loaded_filename;\n};\n\nDSO *DSO_new(void);\nDSO *DSO_new_method(DSO_METHOD *method);\nint DSO_free(DSO *dso);\nint DSO_flags(DSO *dso);\nint DSO_up_ref(DSO *dso);\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/*\n * This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success.\n */\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n                           DSO_NAME_CONVERTER_FUNC *oldcb);\n/*\n * These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded.\n */\nconst char *DSO_get_filename(DSO *dso);\nint DSO_set_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so\n * that caller-created DSO_METHODs can do the same thing. A non-NULL return\n * value will need to be OPENSSL_free()'d.\n */\nchar *DSO_convert_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d.\n */\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/*\n * If the DSO is currently loaded, this returns the filename that it was\n * loaded under, otherwise it returns NULL. So it is also useful as a test as\n * to whether the DSO is currently loaded. NB: This will not necessarily\n * return the same value as DSO_convert_filename(dso, dso->filename), because\n * the DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded.\n */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid DSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/*\n * The all-singing all-dancing load function, you normally pass NULL for the\n * first and third parameters. Use DSO_up and DSO_free for subsequent\n * reference count handling. Any flags passed in will be set in the\n * constructed DSO after its init() function but before the load operation.\n * If 'dso' is non-NULL, 'flags' is ignored.\n */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/*\n * This method is the default, but will beg, borrow, or steal whatever method\n * should be the default on any particular platform (including\n * DSO_METH_null() if necessary).\n */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/*\n * This method is defined for all platforms - if a platform has no DSO\n * support then this will be the only method!\n */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/*\n * If DSO_DLFCN is defined, the standard dlfcn.h-style functions (dlopen,\n * dlclose, dlsym, etc) will be used and incorporated into this method. If\n * not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/*\n * If DSO_DL is defined, the standard dl.h-style functions (shl_load,\n * shl_unload, shl_findsym, etc) will be used and incorporated into this\n * method. If not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/*\n * This function writes null-terminated pathname of DSO module containing\n * 'addr' into 'sz' large caller-provided 'path' and returns the number of\n * characters [including trailing zero] written to it. If 'sz' is 0 or\n * negative, 'path' is ignored and required amount of charachers [including\n * trailing zero] to accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero return value\n * denotes error.\n */\nint DSO_pathbyaddr(void *addr, char *path, int sz);\n\n/*\n * This function should be used with caution! It looks up symbols in *all*\n * loaded modules and if module gets unloaded by somebody else attempt to\n * dereference the pointer is doomed to have fatal consequences. Primary\n * usage for this function is to probe *core* system functionality, e.g.\n * check if getnameinfo(3) is available at run-time without bothering about\n * OS-specific details such as libc.so.versioning or where does it actually\n * reside: in libc itself or libsocket.\n */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/*\n * The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n# define DSO_F_BEOS_BIND_FUNC                             144\n# define DSO_F_BEOS_BIND_VAR                              145\n# define DSO_F_BEOS_LOAD                                  146\n# define DSO_F_BEOS_NAME_CONVERTER                        147\n# define DSO_F_BEOS_UNLOAD                                148\n# define DSO_F_DLFCN_BIND_FUNC                            100\n# define DSO_F_DLFCN_BIND_VAR                             101\n# define DSO_F_DLFCN_LOAD                                 102\n# define DSO_F_DLFCN_MERGER                               130\n# define DSO_F_DLFCN_NAME_CONVERTER                       123\n# define DSO_F_DLFCN_UNLOAD                               103\n# define DSO_F_DL_BIND_FUNC                               104\n# define DSO_F_DL_BIND_VAR                                105\n# define DSO_F_DL_LOAD                                    106\n# define DSO_F_DL_MERGER                                  131\n# define DSO_F_DL_NAME_CONVERTER                          124\n# define DSO_F_DL_UNLOAD                                  107\n# define DSO_F_DSO_BIND_FUNC                              108\n# define DSO_F_DSO_BIND_VAR                               109\n# define DSO_F_DSO_CONVERT_FILENAME                       126\n# define DSO_F_DSO_CTRL                                   110\n# define DSO_F_DSO_FREE                                   111\n# define DSO_F_DSO_GET_FILENAME                           127\n# define DSO_F_DSO_GET_LOADED_FILENAME                    128\n# define DSO_F_DSO_GLOBAL_LOOKUP                          139\n# define DSO_F_DSO_LOAD                                   112\n# define DSO_F_DSO_MERGE                                  132\n# define DSO_F_DSO_NEW_METHOD                             113\n# define DSO_F_DSO_PATHBYADDR                             140\n# define DSO_F_DSO_SET_FILENAME                           129\n# define DSO_F_DSO_SET_NAME_CONVERTER                     122\n# define DSO_F_DSO_UP_REF                                 114\n# define DSO_F_GLOBAL_LOOKUP_FUNC                         138\n# define DSO_F_PATHBYADDR                                 137\n# define DSO_F_VMS_BIND_SYM                               115\n# define DSO_F_VMS_LOAD                                   116\n# define DSO_F_VMS_MERGER                                 133\n# define DSO_F_VMS_UNLOAD                                 117\n# define DSO_F_WIN32_BIND_FUNC                            118\n# define DSO_F_WIN32_BIND_VAR                             119\n# define DSO_F_WIN32_GLOBALLOOKUP                         142\n# define DSO_F_WIN32_GLOBALLOOKUP_FUNC                    143\n# define DSO_F_WIN32_JOINER                               135\n# define DSO_F_WIN32_LOAD                                 120\n# define DSO_F_WIN32_MERGER                               134\n# define DSO_F_WIN32_NAME_CONVERTER                       125\n# define DSO_F_WIN32_PATHBYADDR                           141\n# define DSO_F_WIN32_SPLITTER                             136\n# define DSO_F_WIN32_UNLOAD                               121\n\n/* Reason codes. */\n# define DSO_R_CTRL_FAILED                                100\n# define DSO_R_DSO_ALREADY_LOADED                         110\n# define DSO_R_EMPTY_FILE_STRUCTURE                       113\n# define DSO_R_FAILURE                                    114\n# define DSO_R_FILENAME_TOO_BIG                           101\n# define DSO_R_FINISH_FAILED                              102\n# define DSO_R_INCORRECT_FILE_SYNTAX                      115\n# define DSO_R_LOAD_FAILED                                103\n# define DSO_R_NAME_TRANSLATION_FAILED                    109\n# define DSO_R_NO_FILENAME                                111\n# define DSO_R_NO_FILE_SPECIFICATION                      116\n# define DSO_R_NULL_HANDLE                                104\n# define DSO_R_SET_FILENAME_FAILED                        112\n# define DSO_R_STACK_ERROR                                105\n# define DSO_R_SYM_FAILURE                                106\n# define DSO_R_UNLOAD_FAILED                              107\n# define DSO_R_UNSUPPORTED                                108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/openssl/crypto/sparcv9cap.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <openssl/bn.h>\n\n#include \"sparc_arch.h\"\n\n#if defined(__GNUC__) && defined(__linux)\n__attribute__ ((visibility(\"hidden\")))\n#endif\nunsigned int OPENSSL_sparcv9cap_P[2] = { SPARCV9_TICK_PRIVILEGED, 0 };\n\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                const BN_ULONG *np, const BN_ULONG *n0, int num)\n{\n    int bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                         const BN_ULONG *np, const BN_ULONG *n0, int num);\n    int bn_mul_mont_fpu(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                        const BN_ULONG *np, const BN_ULONG *n0, int num);\n    int bn_mul_mont_int(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                        const BN_ULONG *np, const BN_ULONG *n0, int num);\n\n    if (!(num & 1) && num >= 6) {\n        if ((num & 15) == 0 && num <= 64 &&\n            (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n            (CFR_MONTMUL | CFR_MONTSQR)) {\n            typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                          const BN_ULONG *bp,\n                                          const BN_ULONG *np,\n                                          const BN_ULONG *n0);\n            int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const BN_ULONG *bp, const BN_ULONG *np,\n                                 const BN_ULONG *n0);\n            int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            static const bn_mul_mont_f funcs[4] = {\n                bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n                bn_mul_mont_t4_24, bn_mul_mont_t4_32\n            };\n            bn_mul_mont_f worker = funcs[num / 16 - 1];\n\n            if ((*worker) (rp, ap, bp, np, n0))\n                return 1;\n            /* retry once and fall back */\n            if ((*worker) (rp, ap, bp, np, n0))\n                return 1;\n            return bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\n        }\n        if ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3))\n            return bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\n        else if (num >= 8 &&\n                 (OPENSSL_sparcv9cap_P[0] &\n                  (SPARCV9_PREFER_FPU | SPARCV9_VIS1)) ==\n                 (SPARCV9_PREFER_FPU | SPARCV9_VIS1))\n            return bn_mul_mont_fpu(rp, ap, bp, np, n0, num);\n    }\n    return bn_mul_mont_int(rp, ap, bp, np, n0, num);\n}\n\nunsigned long _sparcv9_rdtick(void);\nvoid _sparcv9_vis1_probe(void);\nunsigned long _sparcv9_vis1_instrument(void);\nvoid _sparcv9_vis2_probe(void);\nvoid _sparcv9_fmadd_probe(void);\nunsigned long _sparcv9_rdcfr(void);\nvoid _sparcv9_vis3_probe(void);\nunsigned long _sparcv9_random(void);\nsize_t _sparcv9_vis1_instrument_bus(unsigned int *, size_t);\nsize_t _sparcv9_vis1_instrument_bus2(unsigned int *, size_t, size_t);\n\nunsigned long OPENSSL_rdtsc(void)\n{\n    if (OPENSSL_sparcv9cap_P[0] & SPARCV9_TICK_PRIVILEGED)\n#if defined(__sun) && defined(__SVR4)\n        return gethrtime();\n#else\n        return 0;\n#endif\n    else\n        return _sparcv9_rdtick();\n}\n\nsize_t OPENSSL_instrument_bus(unsigned int *out, size_t cnt)\n{\n    if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\n        SPARCV9_BLK)\n        return _sparcv9_vis1_instrument_bus(out, cnt);\n    else\n        return 0;\n}\n\nsize_t OPENSSL_instrument_bus2(unsigned int *out, size_t cnt, size_t max)\n{\n    if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\n        SPARCV9_BLK)\n        return _sparcv9_vis1_instrument_bus2(out, cnt, max);\n    else\n        return 0;\n}\n\n#if 0 && defined(__sun) && defined(__SVR4)\n/*\n * This code path is disabled, because of incompatibility of libdevinfo.so.1\n * and libmalloc.so.1 (see below for details)\n */\n# include <malloc.h>\n# include <dlfcn.h>\n# include <libdevinfo.h>\n# include <sys/systeminfo.h>\n\ntypedef di_node_t(*di_init_t) (const char *, uint_t);\ntypedef void (*di_fini_t) (di_node_t);\ntypedef char *(*di_node_name_t) (di_node_t);\ntypedef int (*di_walk_node_t) (di_node_t, uint_t, di_node_name_t,\n                               int (*)(di_node_t, di_node_name_t));\n\n# define DLLINK(h,name) (name=(name##_t)dlsym((h),#name))\n\nstatic int walk_nodename(di_node_t node, di_node_name_t di_node_name)\n{\n    char *name = (*di_node_name) (node);\n\n    /* This is expected to catch all UltraSPARC flavors prior T1 */\n    if (!strcmp(name, \"SUNW,UltraSPARC\") ||\n        /* covers II,III,IV */\n        !strncmp(name, \"SUNW,UltraSPARC-I\", 17)) {\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU | SPARCV9_VIS1;\n\n        /* %tick is privileged only on UltraSPARC-I/II, but not IIe */\n        if (name[14] != '\\0' && name[17] != '\\0' && name[18] != '\\0')\n            OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n        return DI_WALK_TERMINATE;\n    }\n    /* This is expected to catch remaining UltraSPARCs, such as T1 */\n    else if (!strncmp(name, \"SUNW,UltraSPARC\", 15)) {\n        OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n        return DI_WALK_TERMINATE;\n    }\n\n    return DI_WALK_CONTINUE;\n}\n\nvoid OPENSSL_cpuid_setup(void)\n{\n    void *h;\n    char *e, si[256];\n    static int trigger = 0;\n\n    if (trigger)\n        return;\n    trigger = 1;\n\n    if ((e = getenv(\"OPENSSL_sparcv9cap\"))) {\n        OPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0);\n        return;\n    }\n\n    if (sysinfo(SI_MACHINE, si, sizeof(si)) > 0) {\n        if (strcmp(si, \"sun4v\"))\n            /* FPU is preferred for all CPUs, but US-T1/2 */\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU;\n    }\n\n    if (sysinfo(SI_ISALIST, si, sizeof(si)) > 0) {\n        if (strstr(si, \"+vis\"))\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1 | SPARCV9_BLK;\n        if (strstr(si, \"+vis2\")) {\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n            OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n            return;\n        }\n    }\n# ifdef M_KEEP\n    /*\n     * Solaris libdevinfo.so.1 is effectively incomatible with\n     * libmalloc.so.1. Specifically, if application is linked with\n     * -lmalloc, it crashes upon startup with SIGSEGV in\n     * free(3LIBMALLOC) called by di_fini. Prior call to\n     * mallopt(M_KEEP,0) somehow helps... But not always...\n     */\n    if ((h = dlopen(NULL, RTLD_LAZY))) {\n        union {\n            void *p;\n            int (*f) (int, int);\n        } sym;\n        if ((sym.p = dlsym(h, \"mallopt\")))\n            (*sym.f) (M_KEEP, 0);\n        dlclose(h);\n    }\n# endif\n    if ((h = dlopen(\"libdevinfo.so.1\", RTLD_LAZY)))\n        do {\n            di_init_t di_init;\n            di_fini_t di_fini;\n            di_walk_node_t di_walk_node;\n            di_node_name_t di_node_name;\n            di_node_t root_node;\n\n            if (!DLLINK(h, di_init))\n                break;\n            if (!DLLINK(h, di_fini))\n                break;\n            if (!DLLINK(h, di_walk_node))\n                break;\n            if (!DLLINK(h, di_node_name))\n                break;\n\n            if ((root_node = (*di_init) (\"/\", DINFOSUBTREE)) != DI_NODE_NIL) {\n                (*di_walk_node) (root_node, DI_WALK_SIBFIRST,\n                                 di_node_name, walk_nodename);\n                (*di_fini) (root_node);\n            }\n        } while (0);\n\n    if (h)\n        dlclose(h);\n}\n\n#else\n\nstatic sigjmp_buf common_jmp;\nstatic void common_handler(int sig)\n{\n    siglongjmp(common_jmp, sig);\n}\n\n#if defined(__sun) && defined(__SVR4)\n# if defined(__GNUC__) && __GNUC__>=2\nextern unsigned int getisax(unsigned int vec[], unsigned int sz) __attribute__ ((weak));\n# elif defined(__SUNPRO_C)\n#pragma weak getisax\nextern unsigned int getisax(unsigned int vec[], unsigned int sz);\n# else\nstatic unsigned int (*getisax) (unsigned int vec[], unsigned int sz) = NULL;\n# endif\n#endif\n\nvoid OPENSSL_cpuid_setup(void)\n{\n    char *e;\n    struct sigaction common_act, ill_oact, bus_oact;\n    sigset_t all_masked, oset;\n    static int trigger = 0;\n\n    if (trigger)\n        return;\n    trigger = 1;\n\n    if ((e = getenv(\"OPENSSL_sparcv9cap\"))) {\n        OPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0);\n        if ((e = strchr(e, ':')))\n            OPENSSL_sparcv9cap_P[1] = strtoul(e + 1, NULL, 0);\n        return;\n    }\n\n#if defined(__sun) && defined(__SVR4)\n    if (getisax != NULL) {\n        unsigned int vec[1];\n\n        if (getisax (vec,1)) {\n            if (vec[0]&0x0020) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1;\n            if (vec[0]&0x0040) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n            if (vec[0]&0x0080) OPENSSL_sparcv9cap_P[0] |= SPARCV9_BLK;\n            if (vec[0]&0x0100) OPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;\n            if (vec[0]&0x0400) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;\n\n            /* reconstruct %cfr copy */\n            OPENSSL_sparcv9cap_P[1] = (vec[0]>>17)&0x3ff;\n            OPENSSL_sparcv9cap_P[1] |= (OPENSSL_sparcv9cap_P[1]&CFR_MONTMUL)<<1;\n            if (vec[0]&0x20000000) OPENSSL_sparcv9cap_P[1] |= CFR_CRC32C;\n\n            /* Some heuristics */\n            /* all known VIS2-capable CPUs have unprivileged tick counter */\n            if (OPENSSL_sparcv9cap_P[0]&SPARCV9_VIS2)\n                OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU;\n\n            /* detect UltraSPARC-Tx, see sparccpud.S for details... */\n            if ((OPENSSL_sparcv9cap_P[0]&SPARCV9_VIS1) &&\n                _sparcv9_vis1_instrument() >= 12)\n                OPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1 | SPARCV9_PREFER_FPU);\n        }\n\n        if (sizeof(size_t) == 8)\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n\n        return;\n    }\n#endif\n\n    /* Initial value, fits UltraSPARC-I&II... */\n    OPENSSL_sparcv9cap_P[0] = SPARCV9_PREFER_FPU | SPARCV9_TICK_PRIVILEGED;\n\n    sigfillset(&all_masked);\n    sigdelset(&all_masked, SIGILL);\n    sigdelset(&all_masked, SIGTRAP);\n# ifdef SIGEMT\n    sigdelset(&all_masked, SIGEMT);\n# endif\n    sigdelset(&all_masked, SIGFPE);\n    sigdelset(&all_masked, SIGBUS);\n    sigdelset(&all_masked, SIGSEGV);\n    sigprocmask(SIG_SETMASK, &all_masked, &oset);\n\n    memset(&common_act, 0, sizeof(common_act));\n    common_act.sa_handler = common_handler;\n    common_act.sa_mask = all_masked;\n\n    sigaction(SIGILL, &common_act, &ill_oact);\n    sigaction(SIGBUS, &common_act, &bus_oact); /* T1 fails 16-bit ldda [on\n                                                * Linux] */\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_rdtick();\n        OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n    }\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_vis1_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1 | SPARCV9_BLK;\n        /* detect UltraSPARC-Tx, see sparccpud.S for details... */\n        if (_sparcv9_vis1_instrument() >= 12)\n            OPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1 | SPARCV9_PREFER_FPU);\n        else {\n            _sparcv9_vis2_probe();\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n        }\n    }\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_fmadd_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;\n    }\n\n    /*\n     * VIS3 flag is tested independently from VIS1, unlike VIS2 that is,\n     * because VIS3 defines even integer instructions.\n     */\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_vis3_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;\n    }\n# if 0                          /* was planned at some point but never\n                                 * implemented in hardware */\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        (void)_sparcv9_random();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_RANDOM;\n    }\n# endif\n\n    /*\n     * In wait for better solution _sparcv9_rdcfr is masked by\n     * VIS3 flag, because it goes to uninterruptable endless\n     * loop on UltraSPARC II running Solaris. Things might be\n     * different on Linux...\n     */\n    if ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3) &&\n        sigsetjmp(common_jmp, 1) == 0) {\n        OPENSSL_sparcv9cap_P[1] = (unsigned int)_sparcv9_rdcfr();\n    }\n\n    sigaction(SIGBUS, &bus_oact, NULL);\n    sigaction(SIGILL, &ill_oact, NULL);\n\n    sigprocmask(SIG_SETMASK, &oset, NULL);\n\n    if (sizeof(size_t) == 8)\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n# ifdef __linux\n    else {\n        int ret = syscall(340);\n\n        if (ret >= 0 && ret & 1)\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n    }\n# endif\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/openssl/crypto/dso/dso_dlfcn.c": "/* dso_dlfcn.c */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#include <openssl/dso.h>\n\n#ifndef DSO_DLFCN\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n{\n    return NULL;\n}\n#else\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(_AIX) || defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\n# if 0\nstatic int dlfcn_unbind(DSO *dso, char *symname, void *symptr);\nstatic int dlfcn_init(DSO *dso);\nstatic int dlfcn_finish(DSO *dso);\nstatic long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);\n# endif\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_var,\n    dlfcn_bind_func,\n/* For now, \"unbind\" doesn't exist */\n# if 0\n    NULL,                       /* unbind_var */\n    NULL,                       /* unbind_func */\n# endif\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n{\n    return (&dso_meth_dlfcn);\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  ifdef OPENSSL_SYS_SUNOS\n#   define DLOPEN_FLAG 1\n#  else\n#   define DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */\n#  endif\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return (1);\n err:\n    /* Cleanup! */\n    if (filename != NULL)\n        OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return (0);\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return (0);\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return (1);\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return (0);\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return (1);\n}\n\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname)\n{\n    void *ptr, *sym;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    sym = dlsym(ptr, symname);\n    if (sym == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return (sym);\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_malloc(strlen(filespec1) + 1);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec1);\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_malloc(strlen(filespec2) + 1);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return (merged);\n}\n\n# ifdef OPENSSL_SYS_MACOSX\n#  define DSO_ext \".dylib\"\n#  define DSO_extlen 6\n# else\n#  define DSO_ext \".so\"\n#  define DSO_extlen 3\n# endif\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += DSO_extlen;    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return (NULL);\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_ext, filename);\n        else\n            sprintf(translated, \"%s\" DSO_ext, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return (translated);\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0)\n            return len + 1;\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/openssl/crypto/dso/dso.h": "/* dso.h */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n# define HEADER_DSO_H\n\n# include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n# define DSO_CTRL_GET_FLAGS      1\n# define DSO_CTRL_SET_FLAGS      2\n# define DSO_CTRL_OR_FLAGS       3\n\n/*\n * By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the\n * DSO object (using DSO_set_name_converter()). This callback could even\n * utilise the DSO_METHOD's converter too if it only wants to override\n * behaviour for one or two possible DSO methods. However, the following flag\n * can be set in a DSO to prevent *any* native name-translation at all - eg.\n * if the caller has prompted the user for a path to a driver library so the\n * filename should be interpreted as-is.\n */\n# define DSO_FLAG_NO_NAME_TRANSLATION            0x01\n/*\n * An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and other\n * operating systems where the translation also may prefix the name with\n * something, like 'lib', and ignored everywhere else. This flag is also\n * ignored if DSO_FLAG_NO_NAME_TRANSLATION is used at the same time.\n */\n# define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY      0x02\n\n/*\n * The following flag controls the translation of symbol names to upper case.\n * This is currently only being implemented for OpenVMS.\n */\n# define DSO_FLAG_UPCASE_SYMBOL                  0x10\n\n/*\n * This flag loads the library with public symbols. Meaning: The exported\n * symbols of this library are public to all libraries loaded after this\n * library. At the moment only implemented in unix.\n */\n# define DSO_FLAG_GLOBAL_SYMBOLS                 0x20\n\ntypedef void (*DSO_FUNC_TYPE) (void);\n\ntypedef struct dso_st DSO;\n\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure\n * pointer (or NULL if they are to be used independantly of a DSO object) and\n * a filename to transform. They should either return NULL (if there is an\n * error condition) or a newly allocated string containing the transformed\n * form that the caller will need to free with OPENSSL_free() when done.\n */\ntypedef char *(*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a DSO\n * structure pointer (or NULL if they are to be used independantly of a DSO\n * object) and two file specifications to merge. They should either return\n * NULL (if there is an error condition) or a newly allocated string\n * containing the result of merging that the caller will need to free with\n * OPENSSL_free() when done. Here, merging means that bits and pieces are\n * taken from each of the file specifications and added together in whatever\n * fashion that is sensible for the DSO method in question.  The only rule\n * that really applies is that if the two specification contain pieces of the\n * same type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the second\n * being a bunch of defaults to add on if they're missing in the first.\n */\ntypedef char *(*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st {\n    const char *name;\n    /*\n     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n     * successful load populates the loaded_filename field, and likewise a\n     * successful unload OPENSSL_frees and NULLs it out.\n     */\n    int (*dso_load) (DSO *dso);\n    /* Unloads a shared library */\n    int (*dso_unload) (DSO *dso);\n    /* Binds a variable */\n    void *(*dso_bind_var) (DSO *dso, const char *symname);\n    /*\n     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n     * be cast to the real function prototype by the caller. Platforms that\n     * don't have compatible representations for different prototypes (this\n     * is possible within ANSI C) are highly unlikely to have shared\n     * libraries at all, let alone a DSO_METHOD implemented for them.\n     */\n    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n/* I don't think this would actually be used in any circumstances. */\n# if 0\n    /* Unbinds a variable */\n    int (*dso_unbind_var) (DSO *dso, char *symname, void *symptr);\n    /* Unbinds a function */\n    int (*dso_unbind_func) (DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n# endif\n    /*\n     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n     * (rather than zero) indicate errors.\n     */\n    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_MERGER_FUNC dso_merger;\n    /* [De]Initialisation handlers. */\n    int (*init) (DSO *dso);\n    int (*finish) (DSO *dso);\n    /* Return pathname of the module containing location */\n    int (*pathbyaddr) (void *addr, char *path, int sz);\n    /* Perform global symbol lookup, i.e. among *all* modules */\n    void *(*globallookup) (const char *symname);\n} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st {\n    DSO_METHOD *meth;\n    /*\n     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n     * anything but will need to cache the filename for use in the dso_bind\n     * handler. All in all, let each method control its own destiny.\n     * \"Handles\" and such go in a STACK.\n     */\n    STACK_OF(void) *meth_data;\n    int references;\n    int flags;\n    /*\n     * For use by applications etc ... use this for your bits'n'pieces, don't\n     * touch meth_data!\n     */\n    CRYPTO_EX_DATA ex_data;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n     * should normally set using DSO_set_name_converter().\n     */\n    DSO_NAME_CONVERTER_FUNC name_converter;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_merger. NB: This should\n     * normally set using DSO_set_merger().\n     */\n    DSO_MERGER_FUNC merger;\n    /*\n     * This is populated with (a copy of) the platform-independant filename\n     * used for this DSO.\n     */\n    char *filename;\n    /*\n     * This is populated with (a copy of) the translated filename by which\n     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n     * loaded. NB: This is here because the filename translation process may\n     * involve a callback being invoked more than once not only to convert to\n     * a platform-specific form, but also to try different filenames in the\n     * process of trying to perform a load. As such, this variable can be\n     * used to indicate (a) whether this DSO structure corresponds to a\n     * loaded library or not, and (b) the filename with which it was actually\n     * loaded.\n     */\n    char *loaded_filename;\n};\n\nDSO *DSO_new(void);\nDSO *DSO_new_method(DSO_METHOD *method);\nint DSO_free(DSO *dso);\nint DSO_flags(DSO *dso);\nint DSO_up_ref(DSO *dso);\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/*\n * This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success.\n */\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n                           DSO_NAME_CONVERTER_FUNC *oldcb);\n/*\n * These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded.\n */\nconst char *DSO_get_filename(DSO *dso);\nint DSO_set_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so\n * that caller-created DSO_METHODs can do the same thing. A non-NULL return\n * value will need to be OPENSSL_free()'d.\n */\nchar *DSO_convert_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d.\n */\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/*\n * If the DSO is currently loaded, this returns the filename that it was\n * loaded under, otherwise it returns NULL. So it is also useful as a test as\n * to whether the DSO is currently loaded. NB: This will not necessarily\n * return the same value as DSO_convert_filename(dso, dso->filename), because\n * the DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded.\n */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid DSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/*\n * The all-singing all-dancing load function, you normally pass NULL for the\n * first and third parameters. Use DSO_up and DSO_free for subsequent\n * reference count handling. Any flags passed in will be set in the\n * constructed DSO after its init() function but before the load operation.\n * If 'dso' is non-NULL, 'flags' is ignored.\n */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/*\n * This method is the default, but will beg, borrow, or steal whatever method\n * should be the default on any particular platform (including\n * DSO_METH_null() if necessary).\n */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/*\n * This method is defined for all platforms - if a platform has no DSO\n * support then this will be the only method!\n */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/*\n * If DSO_DLFCN is defined, the standard dlfcn.h-style functions (dlopen,\n * dlclose, dlsym, etc) will be used and incorporated into this method. If\n * not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/*\n * If DSO_DL is defined, the standard dl.h-style functions (shl_load,\n * shl_unload, shl_findsym, etc) will be used and incorporated into this\n * method. If not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/*\n * This function writes null-terminated pathname of DSO module containing\n * 'addr' into 'sz' large caller-provided 'path' and returns the number of\n * characters [including trailing zero] written to it. If 'sz' is 0 or\n * negative, 'path' is ignored and required amount of charachers [including\n * trailing zero] to accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero return value\n * denotes error.\n */\nint DSO_pathbyaddr(void *addr, char *path, int sz);\n\n/*\n * This function should be used with caution! It looks up symbols in *all*\n * loaded modules and if module gets unloaded by somebody else attempt to\n * dereference the pointer is doomed to have fatal consequences. Primary\n * usage for this function is to probe *core* system functionality, e.g.\n * check if getnameinfo(3) is available at run-time without bothering about\n * OS-specific details such as libc.so.versioning or where does it actually\n * reside: in libc itself or libsocket.\n */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/*\n * The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n# define DSO_F_BEOS_BIND_FUNC                             144\n# define DSO_F_BEOS_BIND_VAR                              145\n# define DSO_F_BEOS_LOAD                                  146\n# define DSO_F_BEOS_NAME_CONVERTER                        147\n# define DSO_F_BEOS_UNLOAD                                148\n# define DSO_F_DLFCN_BIND_FUNC                            100\n# define DSO_F_DLFCN_BIND_VAR                             101\n# define DSO_F_DLFCN_LOAD                                 102\n# define DSO_F_DLFCN_MERGER                               130\n# define DSO_F_DLFCN_NAME_CONVERTER                       123\n# define DSO_F_DLFCN_UNLOAD                               103\n# define DSO_F_DL_BIND_FUNC                               104\n# define DSO_F_DL_BIND_VAR                                105\n# define DSO_F_DL_LOAD                                    106\n# define DSO_F_DL_MERGER                                  131\n# define DSO_F_DL_NAME_CONVERTER                          124\n# define DSO_F_DL_UNLOAD                                  107\n# define DSO_F_DSO_BIND_FUNC                              108\n# define DSO_F_DSO_BIND_VAR                               109\n# define DSO_F_DSO_CONVERT_FILENAME                       126\n# define DSO_F_DSO_CTRL                                   110\n# define DSO_F_DSO_FREE                                   111\n# define DSO_F_DSO_GET_FILENAME                           127\n# define DSO_F_DSO_GET_LOADED_FILENAME                    128\n# define DSO_F_DSO_GLOBAL_LOOKUP                          139\n# define DSO_F_DSO_LOAD                                   112\n# define DSO_F_DSO_MERGE                                  132\n# define DSO_F_DSO_NEW_METHOD                             113\n# define DSO_F_DSO_PATHBYADDR                             140\n# define DSO_F_DSO_SET_FILENAME                           129\n# define DSO_F_DSO_SET_NAME_CONVERTER                     122\n# define DSO_F_DSO_UP_REF                                 114\n# define DSO_F_GLOBAL_LOOKUP_FUNC                         138\n# define DSO_F_PATHBYADDR                                 137\n# define DSO_F_VMS_BIND_SYM                               115\n# define DSO_F_VMS_LOAD                                   116\n# define DSO_F_VMS_MERGER                                 133\n# define DSO_F_VMS_UNLOAD                                 117\n# define DSO_F_WIN32_BIND_FUNC                            118\n# define DSO_F_WIN32_BIND_VAR                             119\n# define DSO_F_WIN32_GLOBALLOOKUP                         142\n# define DSO_F_WIN32_GLOBALLOOKUP_FUNC                    143\n# define DSO_F_WIN32_JOINER                               135\n# define DSO_F_WIN32_LOAD                                 120\n# define DSO_F_WIN32_MERGER                               134\n# define DSO_F_WIN32_NAME_CONVERTER                       125\n# define DSO_F_WIN32_PATHBYADDR                           141\n# define DSO_F_WIN32_SPLITTER                             136\n# define DSO_F_WIN32_UNLOAD                               121\n\n/* Reason codes. */\n# define DSO_R_CTRL_FAILED                                100\n# define DSO_R_DSO_ALREADY_LOADED                         110\n# define DSO_R_EMPTY_FILE_STRUCTURE                       113\n# define DSO_R_FAILURE                                    114\n# define DSO_R_FILENAME_TOO_BIG                           101\n# define DSO_R_FINISH_FAILED                              102\n# define DSO_R_INCORRECT_FILE_SYNTAX                      115\n# define DSO_R_LOAD_FAILED                                103\n# define DSO_R_NAME_TRANSLATION_FAILED                    109\n# define DSO_R_NO_FILENAME                                111\n# define DSO_R_NO_FILE_SPECIFICATION                      116\n# define DSO_R_NULL_HANDLE                                104\n# define DSO_R_SET_FILENAME_FAILED                        112\n# define DSO_R_STACK_ERROR                                105\n# define DSO_R_SYM_FAILURE                                106\n# define DSO_R_UNLOAD_FAILED                              107\n# define DSO_R_UNSUPPORTED                                108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/v8/src/third_party/vtune/jitprofiling.cc": "/*\n  This file is provided under a dual BSD/GPLv2 license.  When using or\n  redistributing this file, you may do so under either license.\n\n  GPL LICENSE SUMMARY\n\n  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of version 2 of the GNU General Public License as\n  published by the Free Software Foundation.\n\n  This program is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.\n  The full GNU General Public License is included in this distribution\n  in the file called LICENSE.GPL.\n\n  Contact Information:\n  http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/\n\n  BSD LICENSE\n\n  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n    * Neither the name of Intel Corporation nor the names of its\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include \"ittnotify_config.h\"\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\n#pragma optimize(\"\", off)\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <pthread.h>\n#include <dlfcn.h>\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <malloc.h>\n#include <stdlib.h>\n\n#include \"jitprofiling.h\"\n\nstatic const char rcsid[] = \"\\n@(#) $Revision: 234474 $\\n\";\n\n#define DLL_ENVIRONMENT_VAR\t\t\"VS_PROFILER\"\n\n#ifndef NEW_DLL_ENVIRONMENT_VAR\n#if ITT_ARCH==ITT_ARCH_IA32\n#define NEW_DLL_ENVIRONMENT_VAR\t\t\"INTEL_JIT_PROFILER32\"\n#else\n#define NEW_DLL_ENVIRONMENT_VAR\t\t\"INTEL_JIT_PROFILER64\"\n#endif\n#endif /* NEW_DLL_ENVIRONMENT_VAR */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define DEFAULT_DLLNAME\t\t\t\"JitPI.dll\"\nHINSTANCE m_libHandle = NULL;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#define DEFAULT_DLLNAME\t\t\t\"libJitPI.so\"\nvoid* m_libHandle = NULL;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n/* default location of JIT profiling agent on Android */\n#define ANDROID_JIT_AGENT_PATH  \"/data/intel/libittnotify.so\"\n\n/* the function pointers */\ntypedef unsigned int(*TPInitialize)(void);\nstatic TPInitialize FUNC_Initialize=NULL;\n\ntypedef unsigned int(*TPNotify)(unsigned int, void*);\nstatic TPNotify FUNC_NotifyEvent=NULL;\n\nstatic iJIT_IsProfilingActiveFlags executionMode = iJIT_NOTHING_RUNNING;\n\n/* end collector dll part. */\n\n/* loadiJIT_Funcs() : this function is called just in the beginning and is responsible\n** to load the functions from BistroJavaCollector.dll\n** result:\n**\t\ton success: the functions loads,    iJIT_DLL_is_missing=0, return value = 1.\n**\t\ton failure: the functions are NULL, iJIT_DLL_is_missing=1, return value = 0.\n*/\nstatic int loadiJIT_Funcs(void);\n\n/* global representing whether the BistroJavaCollector can't be loaded */\nstatic int iJIT_DLL_is_missing = 0;\n\n/* Virtual stack - the struct is used as a virtual stack for each thread.\n** Every thread initializes with a stack of size INIT_TOP_STACK.\n** Every method entry decreases from the current stack point,\n** and when a thread stack reaches its top of stack (return from the global function),\n** the top of stack and the current stack increase. Notice that when returning from a function\n** the stack pointer is the address of the function return.\n*/\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\nstatic DWORD threadLocalStorageHandle = 0;\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\nstatic pthread_key_t threadLocalStorageHandle = (pthread_key_t)0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#define INIT_TOP_Stack 10000\n\ntypedef struct\n{\n    unsigned int TopStack;\n    unsigned int CurrentStack;\n} ThreadStack, *pThreadStack;\n\n/* end of virtual stack. */\n\n/*\n** The function for reporting virtual-machine related events to VTune.\n** Note: when reporting iJVM_EVENT_TYPE_ENTER_NIDS, there is no need to fill in the stack_id\n** field in the iJIT_Method_NIDS structure, as VTune fills it.\n**\n** The return value in iJVM_EVENT_TYPE_ENTER_NIDS && iJVM_EVENT_TYPE_LEAVE_NIDS events\n** will be 0 in case of failure.\n** in iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED event it will be -1 if EventSpecificData == 0\n** otherwise it will be 0.\n*/\n\nITT_EXTERN_C int JITAPI iJIT_NotifyEvent(iJIT_JVM_EVENT event_type, void *EventSpecificData)\n{\n    int ReturnValue;\n\n    /*******************************************************************************\n    ** This section is for debugging outside of VTune.\n    ** It creates the environment variables that indicates call graph mode.\n    ** If running outside of VTune remove the remark.\n    **\n\n      static int firstTime = 1;\n      char DoCallGraph[12] = \"DoCallGraph\";\n      if (firstTime)\n      {\n      firstTime = 0;\n      SetEnvironmentVariable( \"BISTRO_COLLECTORS_DO_CALLGRAPH\", DoCallGraph);\n      }\n\n    ** end of section.\n    *******************************************************************************/\n\n    /* initialization part - the functions have not been loaded yet. This part\n    **\t\twill load the functions, and check if we are in Call Graph mode.\n    **\t\t(for special treatment).\n    */\n    if (!FUNC_NotifyEvent)\n    {\n        if (iJIT_DLL_is_missing)\n            return 0;\n\n        // load the Function from the DLL\n        if (!loadiJIT_Funcs())\n            return 0;\n\n        /* Call Graph initialization. */\n    }\n\n    /* If the event is method entry/exit, check that in the current mode\n    ** VTune is allowed to receive it\n    */\n    if ((event_type == iJVM_EVENT_TYPE_ENTER_NIDS || event_type == iJVM_EVENT_TYPE_LEAVE_NIDS) &&\n        (executionMode != iJIT_CALLGRAPH_ON))\n    {\n        return 0;\n    }\n    /* This section is performed when method enter event occurs.\n    ** It updates the virtual stack, or creates it if this is the first\n    ** method entry in the thread. The stack pointer is decreased.\n    */\n    if (event_type == iJVM_EVENT_TYPE_ENTER_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        // check for use of reserved method IDs\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            // initialize the stack.\n            threadStack = (pThreadStack) calloc (sizeof(ThreadStack), 1);\n            threadStack->TopStack = INIT_TOP_Stack;\n            threadStack->CurrentStack = INIT_TOP_Stack;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue(threadLocalStorageHandle,(void*)threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle,(void*)threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n\n        // decrease the stack.\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = (threadStack->CurrentStack)--;\n    }\n\n    /* This section is performed when method leave event occurs\n    ** It updates the virtual stack.\n    **\t\tIncreases the stack pointer.\n    **\t\tIf the stack pointer reached the top (left the global function)\n    **\t\t\tincrease the pointer and the top pointer.\n    */\n    if (event_type == iJVM_EVENT_TYPE_LEAVE_NIDS)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n        // check for use of reserved method IDs\n        if ( ((piJIT_Method_NIDS) EventSpecificData)->method_id <= 999 )\n            return 0;\n\n        if (!threadStack)\n        {\n            /* Error: first report in this thread is method exit */\n            exit (1);\n        }\n\n        ((piJIT_Method_NIDS) EventSpecificData)->stack_id = ++(threadStack->CurrentStack) + 1;\n\n        if (((piJIT_Method_NIDS) EventSpecificData)->stack_id > threadStack->TopStack)\n            ((piJIT_Method_NIDS) EventSpecificData)->stack_id = (unsigned int)-1;\n    }\n\n    if (event_type == iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED)\n    {\n        // check for use of reserved method IDs\n        if ( ((piJIT_Method_Load) EventSpecificData)->method_id <= 999 )\n            return 0;\n    }\n\n    ReturnValue = (int)FUNC_NotifyEvent(event_type, EventSpecificData);\n\n    return ReturnValue;\n}\n\nITT_EXTERN_C void JITAPI iJIT_RegisterCallbackEx(void *userdata, iJIT_ModeChangedEx NewModeCallBackFuncEx) // The new mode call back routine\n{\n    // is it already missing... or the load of functions from the DLL failed\n    if (iJIT_DLL_is_missing || !loadiJIT_Funcs())\n    {\n        NewModeCallBackFuncEx(userdata, iJIT_NO_NOTIFICATIONS);  // then do not bother with notifications\n        /* Error: could not load JIT functions. */\n        return;\n    }\n    // nothing to do with the callback\n}\n\n/*\n** This function allows the user to query in which mode, if at all, VTune is running\n*/\nITT_EXTERN_C iJIT_IsProfilingActiveFlags JITAPI iJIT_IsProfilingActive()\n{\n    if (!iJIT_DLL_is_missing)\n    {\n        loadiJIT_Funcs();\n    }\n\n    return executionMode;\n}\n#include <stdio.h>\n/* this function loads the collector dll (BistroJavaCollector) and the relevant functions.\n** on success: all functions load,     iJIT_DLL_is_missing = 0, return value = 1.\n** on failure: all functions are NULL, iJIT_DLL_is_missing = 1, return value = 0.\n*/\nstatic int loadiJIT_Funcs()\n{\n    static int bDllWasLoaded = 0;\n    char *dllName = (char*)rcsid; // !!! Just to avoid unused code elimination !!!\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    DWORD dNameLength = 0;\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if(bDllWasLoaded)\n    {// dll was already loaded, no need to do it for the second time\n        return 1;\n    }\n\n    // Assumes that the DLL will not be found\n    iJIT_DLL_is_missing = 1;\n    FUNC_NotifyEvent = NULL;\n\n    if (m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    // try to get the dll name from the environment\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    dNameLength = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, NULL, 0);\n    if (dNameLength)\n    {\n        DWORD envret = 0;\n        dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n        envret = GetEnvironmentVariableA(NEW_DLL_ENVIRONMENT_VAR, dllName, dNameLength);\n        if (envret)\n        {\n            // Try to load the dll from the PATH...\n            m_libHandle = LoadLibraryExA(dllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n        }\n        free(dllName);\n    } else {\n        // Try to use old VS_PROFILER variable\n        dNameLength = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, NULL, 0);\n        if (dNameLength)\n        {\n            DWORD envret = 0;\n            dllName = (char*)malloc(sizeof(char) * (dNameLength + 1));\n            envret = GetEnvironmentVariableA(DLL_ENVIRONMENT_VAR, dllName, dNameLength);\n            if (envret)\n            {\n                // Try to load the dll from the PATH...\n                m_libHandle = LoadLibraryA(dllName);\n            }\n            free(dllName);\n        }\n    }\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    dllName = getenv(NEW_DLL_ENVIRONMENT_VAR);\n    if (!dllName) {\n        dllName = getenv(DLL_ENVIRONMENT_VAR);\n    }\n#ifdef ANDROID\n    if (!dllName)\n        dllName = ANDROID_JIT_AGENT_PATH;\n#endif\n    if (dllName)\n    {\n        // Try to load the dll from the PATH...\n        m_libHandle = dlopen(dllName, RTLD_LAZY);\n    }\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n    if (!m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        m_libHandle = LoadLibraryA(DEFAULT_DLLNAME);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = dlopen(DEFAULT_DLLNAME, RTLD_LAZY);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    // if the dll wasn't loaded - exit.\n    if (!m_libHandle)\n    {\n        iJIT_DLL_is_missing = 1; // don't try to initialize JIT agent the second time\n        return 0;\n    }\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_NotifyEvent = (TPNotify)GetProcAddress(m_libHandle, \"NotifyEvent\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_NotifyEvent = reinterpret_cast<TPNotify>(reinterpret_cast<intptr_t>(dlsym(m_libHandle, \"NotifyEvent\")));\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_NotifyEvent)\n    {\n        FUNC_Initialize = NULL;\n        return 0;\n    }\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n    FUNC_Initialize = (TPInitialize)GetProcAddress(m_libHandle, \"Initialize\");\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    FUNC_Initialize = reinterpret_cast<TPInitialize>(reinterpret_cast<intptr_t>(dlsym(m_libHandle, \"Initialize\")));\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    if (!FUNC_Initialize)\n    {\n        FUNC_NotifyEvent = NULL;\n        return 0;\n    }\n\n    executionMode = (iJIT_IsProfilingActiveFlags)FUNC_Initialize();\n    if (executionMode != iJIT_SAMPLING_ON)\n      executionMode = iJIT_SAMPLING_ON;\n\n    bDllWasLoaded = 1;\n    iJIT_DLL_is_missing = 0; // DLL is ok.\n\n    /*\n    ** Call Graph mode: init the thread local storage\n    ** (need to store the virtual stack there).\n    */\n    if ( executionMode == iJIT_CALLGRAPH_ON )\n    {\n        // Allocate a thread local storage slot for the thread \"stack\"\n        if (!threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            threadLocalStorageHandle = TlsAlloc();\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pthread_key_create(&threadLocalStorageHandle, NULL);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    }\n\n    return 1;\n}\n\n/*\n** This function should be called by the user whenever a thread ends, to free the thread\n** \"virtual stack\" storage\n*/\nITT_EXTERN_C void JITAPI FinalizeThread()\n{\n    if (threadLocalStorageHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        pThreadStack threadStack = (pThreadStack)TlsGetValue (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        pThreadStack threadStack = (pThreadStack)pthread_getspecific(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        if (threadStack)\n        {\n            free (threadStack);\n            threadStack = NULL;\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n            TlsSetValue (threadLocalStorageHandle, threadStack);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n            pthread_setspecific(threadLocalStorageHandle, threadStack);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        }\n    }\n}\n\n/*\n** This function should be called by the user when the process ends, to free the local\n** storage index\n*/\nITT_EXTERN_C void JITAPI FinalizeProcess()\n{\n    if (m_libHandle)\n    {\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        FreeLibrary(m_libHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        dlclose(m_libHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n        m_libHandle = NULL;\n    }\n\n    if (threadLocalStorageHandle)\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n        TlsFree (threadLocalStorageHandle);\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n    pthread_key_delete(threadLocalStorageHandle);\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n}\n\n/*\n** This function should be called by the user for any method once.\n** The function will return a unique method ID, the user should maintain the ID for each\n** method\n*/\nITT_EXTERN_C unsigned int JITAPI iJIT_GetNewMethodID()\n{\n    static unsigned int methodID = 0x100000;\n\n    if (methodID == 0)\n        return 0;\t// ERROR : this is not a valid value\n\n    return methodID++;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/v8/src/third_party/vtune/ittnotify_config.h": "/*\n  This file is provided under a dual BSD/GPLv2 license.  When using or\n  redistributing this file, you may do so under either license.\n\n  GPL LICENSE SUMMARY\n\n  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of version 2 of the GNU General Public License as\n  published by the Free Software Foundation.\n\n  This program is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.\n  The full GNU General Public License is included in this distribution\n  in the file called LICENSE.GPL.\n\n  Contact Information:\n  http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/\n\n  BSD LICENSE\n\n  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in\n      the documentation and/or other materials provided with the\n      distribution.\n    * Neither the name of Intel Corporation nor the names of its\n      contributors may be used to endorse or promote products derived\n      from this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif /* _WIN32 */\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define CDECL /* not actual on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define CDECL __attribute__ ((cdecl))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#      define STDCALL /* not supported on x86_64 platform */\n#    else  /* _M_X64 || _M_AMD64 || __x86_64__ */\n#      define STDCALL __attribute__ ((stdcall))\n#    endif /* _M_X64 || _M_AMD64 || __x86_64__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#endif /* __STRICT_ANSI__ */\n#define ITT_INLINE_ATTRIBUTE __attribute__ ((always_inline))\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_IA64\n#  define ITT_ARCH_IA64  3\n#endif /* ITT_ARCH_IA64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64\n#    define ITT_ARCH ITT_ARCH_IA64\n#  else\n#    define ITT_ARCH ITT_ARCH_IA32\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#else\n#  define ITT_EXTERN_C /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { static char __itt_build_check_##suffix[(expr) ? 1 : -1]; __itt_build_check_##suffix[0] = 0; } while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrlen(s)          lstrlenA(s)\n#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE int __itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE int __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   \\\n    {                                                                                        \\\n        pthread_mutexattr_t mutex_attr;                                                      \\\n        int error_code = pthread_mutexattr_init(&mutex_attr);                                \\\n        if (error_code)                                                                      \\\n            __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\", error_code);    \\\n        error_code = pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE);        \\\n        if (error_code)                                                                      \\\n            __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", error_code); \\\n        error_code = pthread_mutex_init(mutex, &mutex_attr);                                 \\\n        if (error_code)                                                                      \\\n            __itt_report_error(__itt_error_system, \"pthread_mutex_init\", error_code);        \\\n        error_code = pthread_mutexattr_destroy(&mutex_attr);                                 \\\n        if (error_code)                                                                      \\\n            __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", error_code); \\\n    }\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n#define __itt_fstrlen(s)          strlen(s)\n#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA64 */\n#endif /* __INTEL_COMPILER */\n#else /* ITT_ARCH!=ITT_ARCH_IA64 */\n/*ITT_INLINE int __TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE int __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    int result;\n    __asm__ __volatile__(\"lock\\nxaddl %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(long*)ptr)\n                          : \"0\"(addend), \"m\"(*(long*)ptr)\n                          : \"memory\");\n    return result;\n}\n*/\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\n/*ITT_INLINE int __itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE int __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1;\n}\n*/\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/v8/src/base/platform/platform-posix.cc": "// Copyright 2012 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Platform-specific code for POSIX goes here. This is not a platform on its\n// own, but contains the parts which are the same across the POSIX platforms\n// Linux, MacOS, FreeBSD, OpenBSD, NetBSD and QNX.\n\n#include <errno.h>\n#include <limits.h>\n#include <pthread.h>\n#if defined(__DragonFly__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <pthread_np.h>  // for pthread_set_name_np\n#endif\n#include <sched.h>  // for sched_yield\n#include <stdio.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#if defined(__APPLE__) || defined(__DragonFly__) || defined(__FreeBSD__) || \\\n    defined(__NetBSD__) || defined(__OpenBSD__)\n#include <sys/sysctl.h>  // NOLINT, for sysctl\n#endif\n\n#undef MAP_TYPE\n\n#if defined(ANDROID) && !defined(V8_ANDROID_LOG_STDOUT)\n#define LOG_TAG \"v8\"\n#include <android/log.h>  // NOLINT\n#endif\n\n#include <cmath>\n#include <cstdlib>\n\n#include \"src/base/lazy-instance.h\"\n#include \"src/base/macros.h\"\n#include \"src/base/platform/platform.h\"\n#include \"src/base/platform/time.h\"\n#include \"src/base/utils/random-number-generator.h\"\n\n#ifdef V8_FAST_TLS_SUPPORTED\n#include \"src/base/atomicops.h\"\n#endif\n\n#if V8_OS_MACOSX\n#include <dlfcn.h>\n#endif\n\n#if V8_OS_LINUX\n#include <sys/prctl.h>  // NOLINT, for prctl\n#endif\n\n#if !defined(V8_OS_NACL) && !defined(_AIX)\n#include <sys/syscall.h>\n#endif\n\nnamespace v8 {\nnamespace base {\n\nnamespace {\n\n// 0 is never a valid thread id.\nconst pthread_t kNoThread = (pthread_t) 0;\n\nbool g_hard_abort = false;\n\nconst char* g_gc_fake_mmap = NULL;\n\n}  // namespace\n\n\nint OS::ActivationFrameAlignment() {\n#if V8_TARGET_ARCH_ARM\n  // On EABI ARM targets this is required for fp correctness in the\n  // runtime system.\n  return 8;\n#elif V8_TARGET_ARCH_MIPS\n  return 8;\n#else\n  // Otherwise we just assume 16 byte alignment, i.e.:\n  // - With gcc 4.4 the tree vectorization optimizer can generate code\n  //   that requires 16 byte alignment such as movdqa on x86.\n  // - Mac OS X, PPC and Solaris (64-bit) activation frames must\n  //   be 16 byte-aligned;  see \"Mac OS X ABI Function Call Guide\"\n  return 16;\n#endif\n}\n\n\nintptr_t OS::CommitPageSize() {\n  static intptr_t page_size = getpagesize();\n  return page_size;\n}\n\n\nvoid OS::Free(void* address, const size_t size) {\n  // TODO(1240712): munmap has a return value which is ignored here.\n  int result = munmap(address, size);\n  USE(result);\n  DCHECK(result == 0);\n}\n\n\n// Get rid of writable permission on code allocations.\nvoid OS::ProtectCode(void* address, const size_t size) {\n#if V8_OS_CYGWIN\n  DWORD old_protect;\n  VirtualProtect(address, size, PAGE_EXECUTE_READ, &old_protect);\n#elif V8_OS_NACL\n  // The Native Client port of V8 uses an interpreter, so\n  // code pages don't need PROT_EXEC.\n  mprotect(address, size, PROT_READ);\n#else\n  mprotect(address, size, PROT_READ | PROT_EXEC);\n#endif\n}\n\n\n// Create guard pages.\nvoid OS::Guard(void* address, const size_t size) {\n#if V8_OS_CYGWIN\n  DWORD oldprotect;\n  VirtualProtect(address, size, PAGE_NOACCESS, &oldprotect);\n#else\n  mprotect(address, size, PROT_NONE);\n#endif\n}\n\n\nstatic LazyInstance<RandomNumberGenerator>::type\n    platform_random_number_generator = LAZY_INSTANCE_INITIALIZER;\n\n\nvoid OS::Initialize(int64_t random_seed, bool hard_abort,\n                    const char* const gc_fake_mmap) {\n  if (random_seed) {\n    platform_random_number_generator.Pointer()->SetSeed(random_seed);\n  }\n  g_hard_abort = hard_abort;\n  g_gc_fake_mmap = gc_fake_mmap;\n}\n\n\nconst char* OS::GetGCFakeMMapFile() {\n  return g_gc_fake_mmap;\n}\n\n\nvoid* OS::GetRandomMmapAddr() {\n#if V8_OS_NACL\n  // TODO(bradchen): restore randomization once Native Client gets\n  // smarter about using mmap address hints.\n  // See http://code.google.com/p/nativeclient/issues/3341\n  return NULL;\n#endif\n#if defined(ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \\\n    defined(THREAD_SANITIZER)\n  // Dynamic tools do not support custom mmap addresses.\n  return NULL;\n#endif\n  uintptr_t raw_addr;\n  platform_random_number_generator.Pointer()->NextBytes(&raw_addr,\n                                                        sizeof(raw_addr));\n#if V8_TARGET_ARCH_X64\n  // Currently available CPUs have 48 bits of virtual addressing.  Truncate\n  // the hint address to 46 bits to give the kernel a fighting chance of\n  // fulfilling our placement request.\n  raw_addr &= V8_UINT64_C(0x3ffffffff000);\n#elif V8_TARGET_ARCH_PPC64\n#if V8_OS_AIX\n  // AIX: 64 bits of virtual addressing, but we limit address range to:\n  //   a) minimize Segment Lookaside Buffer (SLB) misses and\n  raw_addr &= V8_UINT64_C(0x3ffff000);\n  // Use extra address space to isolate the mmap regions.\n  raw_addr += V8_UINT64_C(0x400000000000);\n#elif V8_TARGET_BIG_ENDIAN\n  // Big-endian Linux: 44 bits of virtual addressing.\n  raw_addr &= V8_UINT64_C(0x03fffffff000);\n#else\n  // Little-endian Linux: 48 bits of virtual addressing.\n  raw_addr &= V8_UINT64_C(0x3ffffffff000);\n#endif\n#else\n  raw_addr &= 0x3ffff000;\n\n# ifdef __sun\n  // For our Solaris/illumos mmap hint, we pick a random address in the bottom\n  // half of the top half of the address space (that is, the third quarter).\n  // Because we do not MAP_FIXED, this will be treated only as a hint -- the\n  // system will not fail to mmap() because something else happens to already\n  // be mapped at our random address. We deliberately set the hint high enough\n  // to get well above the system's break (that is, the heap); Solaris and\n  // illumos will try the hint and if that fails allocate as if there were\n  // no hint at all. The high hint prevents the break from getting hemmed in\n  // at low values, ceding half of the address space to the system heap.\n  raw_addr += 0x80000000;\n#elif V8_OS_AIX\n  // The range 0x30000000 - 0xD0000000 is available on AIX;\n  // choose the upper range.\n  raw_addr += 0x90000000;\n# else\n  // The range 0x20000000 - 0x60000000 is relatively unpopulated across a\n  // variety of ASLR modes (PAE kernel, NX compat mode, etc) and on macos\n  // 10.6 and 10.7.\n  raw_addr += 0x20000000;\n# endif\n#endif\n  return reinterpret_cast<void*>(raw_addr);\n}\n\n\nsize_t OS::AllocateAlignment() {\n  return static_cast<size_t>(sysconf(_SC_PAGESIZE));\n}\n\n\nvoid OS::Sleep(TimeDelta interval) {\n  usleep(static_cast<useconds_t>(interval.InMicroseconds()));\n}\n\n\nvoid OS::Abort() {\n  if (g_hard_abort) {\n    V8_IMMEDIATE_CRASH();\n  }\n  // Redirect to std abort to signal abnormal program termination.\n  abort();\n}\n\n\nvoid OS::DebugBreak() {\n#if V8_HOST_ARCH_ARM\n  asm(\"bkpt 0\");\n#elif V8_HOST_ARCH_ARM64\n  asm(\"brk 0\");\n#elif V8_HOST_ARCH_MIPS\n  asm(\"break\");\n#elif V8_HOST_ARCH_MIPS64\n  asm(\"break\");\n#elif V8_HOST_ARCH_PPC\n  asm(\"twge 2,2\");\n#elif V8_HOST_ARCH_IA32\n#if V8_OS_NACL\n  asm(\"hlt\");\n#else\n  asm(\"int $3\");\n#endif  // V8_OS_NACL\n#elif V8_HOST_ARCH_X64\n  asm(\"int $3\");\n#else\n#error Unsupported host architecture.\n#endif\n}\n\n\nclass PosixMemoryMappedFile final : public OS::MemoryMappedFile {\n public:\n  PosixMemoryMappedFile(FILE* file, void* memory, size_t size)\n      : file_(file), memory_(memory), size_(size) {}\n  ~PosixMemoryMappedFile() final;\n  void* memory() const final { return memory_; }\n  size_t size() const final { return size_; }\n\n private:\n  FILE* const file_;\n  void* const memory_;\n  size_t const size_;\n};\n\n\n// static\nOS::MemoryMappedFile* OS::MemoryMappedFile::open(const char* name) {\n  if (FILE* file = fopen(name, \"r+\")) {\n    if (fseek(file, 0, SEEK_END) == 0) {\n      long size = ftell(file);  // NOLINT(runtime/int)\n      if (size >= 0) {\n        void* const memory =\n            mmap(OS::GetRandomMmapAddr(), size, PROT_READ | PROT_WRITE,\n                 MAP_SHARED, fileno(file), 0);\n        if (memory != MAP_FAILED) {\n          return new PosixMemoryMappedFile(file, memory, size);\n        }\n      }\n    }\n    fclose(file);\n  }\n  return nullptr;\n}\n\n\n// static\nOS::MemoryMappedFile* OS::MemoryMappedFile::create(const char* name,\n                                                   size_t size, void* initial) {\n  if (FILE* file = fopen(name, \"w+\")) {\n    size_t result = fwrite(initial, 1, size, file);\n    if (result == size && !ferror(file)) {\n      void* memory = mmap(OS::GetRandomMmapAddr(), result,\n                          PROT_READ | PROT_WRITE, MAP_SHARED, fileno(file), 0);\n      if (memory != MAP_FAILED) {\n        return new PosixMemoryMappedFile(file, memory, result);\n      }\n    }\n    fclose(file);\n  }\n  return nullptr;\n}\n\n\nPosixMemoryMappedFile::~PosixMemoryMappedFile() {\n  if (memory_) OS::Free(memory_, size_);\n  fclose(file_);\n}\n\n\nint OS::GetCurrentProcessId() {\n  return static_cast<int>(getpid());\n}\n\n\nint OS::GetCurrentThreadId() {\n#if V8_OS_MACOSX || (V8_OS_ANDROID && defined(__APPLE__))\n  return static_cast<int>(pthread_mach_thread_np(pthread_self()));\n#elif V8_OS_LINUX\n  return static_cast<int>(syscall(__NR_gettid));\n#elif V8_OS_ANDROID\n  return static_cast<int>(gettid());\n#elif V8_OS_AIX\n  return static_cast<int>(thread_self());\n#elif V8_OS_SOLARIS\n  return static_cast<int>(pthread_self());\n#else\n  return static_cast<int>(reinterpret_cast<intptr_t>(pthread_self()));\n#endif\n}\n\n\n// ----------------------------------------------------------------------------\n// POSIX date/time support.\n//\n\nint OS::GetUserTime(uint32_t* secs, uint32_t* usecs) {\n#if V8_OS_NACL\n  // Optionally used in Logger::ResourceEvent.\n  return -1;\n#else\n  struct rusage usage;\n\n  if (getrusage(RUSAGE_SELF, &usage) < 0) return -1;\n  *secs = static_cast<uint32_t>(usage.ru_utime.tv_sec);\n  *usecs = static_cast<uint32_t>(usage.ru_utime.tv_usec);\n  return 0;\n#endif\n}\n\n\ndouble OS::TimeCurrentMillis() {\n  return Time::Now().ToJsTime();\n}\n\n\nclass TimezoneCache {};\n\n\nTimezoneCache* OS::CreateTimezoneCache() {\n  return NULL;\n}\n\n\nvoid OS::DisposeTimezoneCache(TimezoneCache* cache) {\n  DCHECK(cache == NULL);\n}\n\n\nvoid OS::ClearTimezoneCache(TimezoneCache* cache) {\n  DCHECK(cache == NULL);\n}\n\n\ndouble OS::DaylightSavingsOffset(double time, TimezoneCache*) {\n  if (std::isnan(time)) return std::numeric_limits<double>::quiet_NaN();\n  time_t tv = static_cast<time_t>(std::floor(time/msPerSecond));\n  struct tm* t = localtime(&tv);  // NOLINT(runtime/threadsafe_fn)\n  if (NULL == t) return std::numeric_limits<double>::quiet_NaN();\n  return t->tm_isdst > 0 ? 3600 * msPerSecond : 0;\n}\n\n\nint OS::GetLastError() {\n  return errno;\n}\n\n\n// ----------------------------------------------------------------------------\n// POSIX stdio support.\n//\n\nFILE* OS::FOpen(const char* path, const char* mode) {\n  FILE* file = fopen(path, mode);\n  if (file == NULL) return NULL;\n  struct stat file_stat;\n  if (fstat(fileno(file), &file_stat) != 0) return NULL;\n  bool is_regular_file = ((file_stat.st_mode & S_IFREG) != 0);\n  if (is_regular_file) return file;\n  fclose(file);\n  return NULL;\n}\n\n\nbool OS::Remove(const char* path) {\n  return (remove(path) == 0);\n}\n\n\nbool OS::isDirectorySeparator(const char ch) {\n  return ch == '/';\n}\n\n\nFILE* OS::OpenTemporaryFile() {\n  return tmpfile();\n}\n\n\nconst char* const OS::LogFileOpenMode = \"w\";\n\n\nvoid OS::Print(const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  VPrint(format, args);\n  va_end(args);\n}\n\n\nvoid OS::VPrint(const char* format, va_list args) {\n#if defined(ANDROID) && !defined(V8_ANDROID_LOG_STDOUT)\n  __android_log_vprint(ANDROID_LOG_INFO, LOG_TAG, format, args);\n#else\n  vprintf(format, args);\n#endif\n}\n\n\nvoid OS::FPrint(FILE* out, const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  VFPrint(out, format, args);\n  va_end(args);\n}\n\n\nvoid OS::VFPrint(FILE* out, const char* format, va_list args) {\n#if defined(ANDROID) && !defined(V8_ANDROID_LOG_STDOUT)\n  __android_log_vprint(ANDROID_LOG_INFO, LOG_TAG, format, args);\n#else\n  vfprintf(out, format, args);\n#endif\n}\n\n\nvoid OS::PrintError(const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  VPrintError(format, args);\n  va_end(args);\n}\n\n\nvoid OS::VPrintError(const char* format, va_list args) {\n#if defined(ANDROID) && !defined(V8_ANDROID_LOG_STDOUT)\n  __android_log_vprint(ANDROID_LOG_ERROR, LOG_TAG, format, args);\n#else\n  vfprintf(stderr, format, args);\n#endif\n}\n\n\nint OS::SNPrintF(char* str, int length, const char* format, ...) {\n  va_list args;\n  va_start(args, format);\n  int result = VSNPrintF(str, length, format, args);\n  va_end(args);\n  return result;\n}\n\n\nint OS::VSNPrintF(char* str,\n                  int length,\n                  const char* format,\n                  va_list args) {\n  int n = vsnprintf(str, length, format, args);\n  if (n < 0 || n >= length) {\n    // If the length is zero, the assignment fails.\n    if (length > 0)\n      str[length - 1] = '\\0';\n    return -1;\n  } else {\n    return n;\n  }\n}\n\n\n// ----------------------------------------------------------------------------\n// POSIX string support.\n//\n\nchar* OS::StrChr(char* str, int c) {\n  return strchr(str, c);\n}\n\n\nvoid OS::StrNCpy(char* dest, int length, const char* src, size_t n) {\n  strncpy(dest, src, n);\n}\n\n\n// ----------------------------------------------------------------------------\n// POSIX thread support.\n//\n\nclass Thread::PlatformData {\n public:\n  PlatformData() : thread_(kNoThread) {}\n  pthread_t thread_;  // Thread handle for pthread.\n  // Synchronizes thread creation\n  Mutex thread_creation_mutex_;\n};\n\nThread::Thread(const Options& options)\n    : data_(new PlatformData),\n      stack_size_(options.stack_size()),\n      start_semaphore_(NULL) {\n  if (stack_size_ > 0 && static_cast<size_t>(stack_size_) < PTHREAD_STACK_MIN) {\n    stack_size_ = PTHREAD_STACK_MIN;\n  }\n  set_name(options.name());\n}\n\n\nThread::~Thread() {\n  delete data_;\n}\n\n\nstatic void SetThreadName(const char* name) {\n#if V8_OS_DRAGONFLYBSD || V8_OS_FREEBSD || V8_OS_OPENBSD\n  pthread_set_name_np(pthread_self(), name);\n#elif V8_OS_NETBSD\n  STATIC_ASSERT(Thread::kMaxThreadNameLength <= PTHREAD_MAX_NAMELEN_NP);\n  pthread_setname_np(pthread_self(), \"%s\", name);\n#elif V8_OS_MACOSX\n  // pthread_setname_np is only available in 10.6 or later, so test\n  // for it at runtime.\n  int (*dynamic_pthread_setname_np)(const char*);\n  *reinterpret_cast<void**>(&dynamic_pthread_setname_np) =\n    dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n  if (dynamic_pthread_setname_np == NULL)\n    return;\n\n  // Mac OS X does not expose the length limit of the name, so hardcode it.\n  static const int kMaxNameLength = 63;\n  STATIC_ASSERT(Thread::kMaxThreadNameLength <= kMaxNameLength);\n  dynamic_pthread_setname_np(name);\n#elif defined(PR_SET_NAME)\n  prctl(PR_SET_NAME,\n        reinterpret_cast<unsigned long>(name),  // NOLINT\n        0, 0, 0);\n#endif\n}\n\n\nstatic void* ThreadEntry(void* arg) {\n  Thread* thread = reinterpret_cast<Thread*>(arg);\n  // We take the lock here to make sure that pthread_create finished first since\n  // we don't know which thread will run first (the original thread or the new\n  // one).\n  { LockGuard<Mutex> lock_guard(&thread->data()->thread_creation_mutex_); }\n  SetThreadName(thread->name());\n  DCHECK(thread->data()->thread_ != kNoThread);\n  thread->NotifyStartedAndRun();\n  return NULL;\n}\n\n\nvoid Thread::set_name(const char* name) {\n  strncpy(name_, name, sizeof(name_));\n  name_[sizeof(name_) - 1] = '\\0';\n}\n\n\nvoid Thread::Start() {\n  int result;\n  pthread_attr_t attr;\n  memset(&attr, 0, sizeof(attr));\n  result = pthread_attr_init(&attr);\n  DCHECK_EQ(0, result);\n  // Native client uses default stack size.\n#if !V8_OS_NACL\n  size_t stack_size = stack_size_;\n#if V8_OS_AIX\n  if (stack_size == 0) {\n    // Default on AIX is 96KB -- bump up to 2MB\n    stack_size = 2 * 1024 * 1024;\n  }\n#endif\n  if (stack_size > 0) {\n    result = pthread_attr_setstacksize(&attr, stack_size);\n    DCHECK_EQ(0, result);\n  }\n#endif\n  {\n    LockGuard<Mutex> lock_guard(&data_->thread_creation_mutex_);\n    result = pthread_create(&data_->thread_, &attr, ThreadEntry, this);\n  }\n  DCHECK_EQ(0, result);\n  result = pthread_attr_destroy(&attr);\n  DCHECK_EQ(0, result);\n  DCHECK(data_->thread_ != kNoThread);\n  USE(result);\n}\n\n\nvoid Thread::Join() {\n  pthread_join(data_->thread_, NULL);\n}\n\n\nstatic Thread::LocalStorageKey PthreadKeyToLocalKey(pthread_key_t pthread_key) {\n#if V8_OS_CYGWIN\n  // We need to cast pthread_key_t to Thread::LocalStorageKey in two steps\n  // because pthread_key_t is a pointer type on Cygwin. This will probably not\n  // work on 64-bit platforms, but Cygwin doesn't support 64-bit anyway.\n  STATIC_ASSERT(sizeof(Thread::LocalStorageKey) == sizeof(pthread_key_t));\n  intptr_t ptr_key = reinterpret_cast<intptr_t>(pthread_key);\n  return static_cast<Thread::LocalStorageKey>(ptr_key);\n#else\n  return static_cast<Thread::LocalStorageKey>(pthread_key);\n#endif\n}\n\n\nstatic pthread_key_t LocalKeyToPthreadKey(Thread::LocalStorageKey local_key) {\n#if V8_OS_CYGWIN\n  STATIC_ASSERT(sizeof(Thread::LocalStorageKey) == sizeof(pthread_key_t));\n  intptr_t ptr_key = static_cast<intptr_t>(local_key);\n  return reinterpret_cast<pthread_key_t>(ptr_key);\n#else\n  return static_cast<pthread_key_t>(local_key);\n#endif\n}\n\n\n#ifdef V8_FAST_TLS_SUPPORTED\n\nstatic Atomic32 tls_base_offset_initialized = 0;\nintptr_t kMacTlsBaseOffset = 0;\n\n// It's safe to do the initialization more that once, but it has to be\n// done at least once.\nstatic void InitializeTlsBaseOffset() {\n  const size_t kBufferSize = 128;\n  char buffer[kBufferSize];\n  size_t buffer_size = kBufferSize;\n  int ctl_name[] = { CTL_KERN , KERN_OSRELEASE };\n  if (sysctl(ctl_name, 2, buffer, &buffer_size, NULL, 0) != 0) {\n    V8_Fatal(__FILE__, __LINE__, \"V8 failed to get kernel version\");\n  }\n  // The buffer now contains a string of the form XX.YY.ZZ, where\n  // XX is the major kernel version component.\n  // Make sure the buffer is 0-terminated.\n  buffer[kBufferSize - 1] = '\\0';\n  char* period_pos = strchr(buffer, '.');\n  *period_pos = '\\0';\n  int kernel_version_major =\n      static_cast<int>(strtol(buffer, NULL, 10));  // NOLINT\n  // The constants below are taken from pthreads.s from the XNU kernel\n  // sources archive at www.opensource.apple.com.\n  if (kernel_version_major < 11) {\n    // 8.x.x (Tiger), 9.x.x (Leopard), 10.x.x (Snow Leopard) have the\n    // same offsets.\n#if V8_HOST_ARCH_IA32\n    kMacTlsBaseOffset = 0x48;\n#else\n    kMacTlsBaseOffset = 0x60;\n#endif\n  } else {\n    // 11.x.x (Lion) changed the offset.\n    kMacTlsBaseOffset = 0;\n  }\n\n  Release_Store(&tls_base_offset_initialized, 1);\n}\n\n\nstatic void CheckFastTls(Thread::LocalStorageKey key) {\n  void* expected = reinterpret_cast<void*>(0x1234CAFE);\n  Thread::SetThreadLocal(key, expected);\n  void* actual = Thread::GetExistingThreadLocal(key);\n  if (expected != actual) {\n    V8_Fatal(__FILE__, __LINE__,\n             \"V8 failed to initialize fast TLS on current kernel\");\n  }\n  Thread::SetThreadLocal(key, NULL);\n}\n\n#endif  // V8_FAST_TLS_SUPPORTED\n\n\nThread::LocalStorageKey Thread::CreateThreadLocalKey() {\n#ifdef V8_FAST_TLS_SUPPORTED\n  bool check_fast_tls = false;\n  if (tls_base_offset_initialized == 0) {\n    check_fast_tls = true;\n    InitializeTlsBaseOffset();\n  }\n#endif\n  pthread_key_t key;\n  int result = pthread_key_create(&key, NULL);\n  DCHECK_EQ(0, result);\n  USE(result);\n  LocalStorageKey local_key = PthreadKeyToLocalKey(key);\n#ifdef V8_FAST_TLS_SUPPORTED\n  // If we just initialized fast TLS support, make sure it works.\n  if (check_fast_tls) CheckFastTls(local_key);\n#endif\n  return local_key;\n}\n\n\nvoid Thread::DeleteThreadLocalKey(LocalStorageKey key) {\n  pthread_key_t pthread_key = LocalKeyToPthreadKey(key);\n  int result = pthread_key_delete(pthread_key);\n  DCHECK_EQ(0, result);\n  USE(result);\n}\n\n\nvoid* Thread::GetThreadLocal(LocalStorageKey key) {\n  pthread_key_t pthread_key = LocalKeyToPthreadKey(key);\n  return pthread_getspecific(pthread_key);\n}\n\n\nvoid Thread::SetThreadLocal(LocalStorageKey key, void* value) {\n  pthread_key_t pthread_key = LocalKeyToPthreadKey(key);\n  int result = pthread_setspecific(pthread_key, value);\n  DCHECK_EQ(0, result);\n  USE(result);\n}\n\n}  // namespace base\n}  // namespace v8\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!MultiByteToWideChar(CP_UTF8,\n                           0,\n                           filename,\n                           -1,\n                           filename_w,\n                           ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  *ptr = (void*) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic void uv__format_fallback_error(uv_lib_t* lib, int errorno){\n  DWORD_PTR args[1] = { (DWORD_PTR) errorno };\n  LPSTR fallback_error = \"error: %1!d!\";\n\n  FormatMessageA(FORMAT_MESSAGE_FROM_STRING |\n                 FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                 FORMAT_MESSAGE_ALLOCATE_BUFFER,\n                 fallback_error, 0, 0,\n                 (LPSTR) &lib->errmsg,\n                 0, (va_list*) args);\n}\n\n\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno) {\n  DWORD res;\n\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno) {\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                         MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                         (LPSTR) &lib->errmsg, 0, NULL);\n    if (!res && GetLastError() == ERROR_MUI_FILE_NOT_FOUND) {\n      res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                           FORMAT_MESSAGE_FROM_SYSTEM |\n                           FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                           0, (LPSTR) &lib->errmsg, 0, NULL);\n    }\n\n    if (!res) {\n      uv__format_fallback_error(lib, errorno);\n    }\n  }\n\n  return errorno ? -1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/src/unix/darwin-proctitle.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <TargetConditionals.h>\n\n#if !TARGET_OS_IPHONE\n# include <CoreFoundation/CoreFoundation.h>\n# include <ApplicationServices/ApplicationServices.h>\n#endif\n\n\nstatic int uv__pthread_setname_np(const char* name) {\n  int (*dynamic_pthread_setname_np)(const char* name);\n  char namebuf[64];  /* MAXTHREADNAMESIZE */\n  int err;\n\n  /* pthread_setname_np() first appeared in OS X 10.6 and iOS 3.2. */\n  *(void **)(&dynamic_pthread_setname_np) =\n      dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n\n  if (dynamic_pthread_setname_np == NULL)\n    return -ENOSYS;\n\n  strncpy(namebuf, name, sizeof(namebuf) - 1);\n  namebuf[sizeof(namebuf) - 1] = '\\0';\n\n  err = dynamic_pthread_setname_np(namebuf);\n  if (err)\n    return -err;\n\n  return 0;\n}\n\n\nint uv__set_process_title(const char* title) {\n#if TARGET_OS_IPHONE\n  return uv__pthread_setname_np(title);\n#else\n  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                            const char*,\n                                            CFStringEncoding);\n  CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);\n  void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);\n  void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);\n  CFTypeRef (*pLSGetCurrentApplicationASN)(void);\n  OSStatus (*pLSSetApplicationInformationItem)(int,\n                                               CFTypeRef,\n                                               CFStringRef,\n                                               CFStringRef,\n                                               CFDictionaryRef*);\n  void* application_services_handle;\n  void* core_foundation_handle;\n  CFBundleRef launch_services_bundle;\n  CFStringRef* display_name_key;\n  CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);\n  CFBundleRef (*pCFBundleGetMainBundle)(void);\n  CFBundleRef hi_services_bundle;\n  OSStatus (*pSetApplicationIsDaemon)(int);\n  CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);\n  void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,\n                                                                void*);\n  CFTypeRef asn;\n  int err;\n\n  err = -ENOENT;\n  application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                       \"ApplicationServices.framework/\"\n                                       \"Versions/A/ApplicationServices\",\n                                       RTLD_LAZY | RTLD_LOCAL);\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n\n  if (application_services_handle == NULL || core_foundation_handle == NULL)\n    goto out;\n\n  *(void **)(&pCFStringCreateWithCString) =\n      dlsym(core_foundation_handle, \"CFStringCreateWithCString\");\n  *(void **)(&pCFBundleGetBundleWithIdentifier) =\n      dlsym(core_foundation_handle, \"CFBundleGetBundleWithIdentifier\");\n  *(void **)(&pCFBundleGetDataPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetDataPointerForName\");\n  *(void **)(&pCFBundleGetFunctionPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetFunctionPointerForName\");\n\n  if (pCFStringCreateWithCString == NULL ||\n      pCFBundleGetBundleWithIdentifier == NULL ||\n      pCFBundleGetDataPointerForName == NULL ||\n      pCFBundleGetFunctionPointerForName == NULL) {\n    goto out;\n  }\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n  launch_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.LaunchServices\"));\n\n  if (launch_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pLSGetCurrentApplicationASN) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSGetCurrentApplicationASN\"));\n\n  if (pLSGetCurrentApplicationASN == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationInformationItem) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSSetApplicationInformationItem\"));\n\n  if (pLSSetApplicationInformationItem == NULL)\n    goto out;\n\n  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,\n                                                    S(\"_kLSDisplayNameKey\"));\n\n  if (display_name_key == NULL || *display_name_key == NULL)\n    goto out;\n\n  *(void **)(&pCFBundleGetInfoDictionary) = dlsym(core_foundation_handle,\n                                     \"CFBundleGetInfoDictionary\");\n  *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,\n                                 \"CFBundleGetMainBundle\");\n  if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)\n    goto out;\n\n  /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */\n  hi_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.HIServices\"));\n  err = -ENOENT;\n  if (hi_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pSetApplicationIsDaemon) = pCFBundleGetFunctionPointerForName(\n      hi_services_bundle,\n      S(\"SetApplicationIsDaemon\"));\n  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(\n      launch_services_bundle,\n      S(\"_LSApplicationCheckIn\"));\n  *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =\n      pCFBundleGetFunctionPointerForName(\n          launch_services_bundle,\n          S(\"_LSSetApplicationLaunchServicesServerConnectionStatus\"));\n  if (pSetApplicationIsDaemon == NULL ||\n      pLSApplicationCheckIn == NULL ||\n      pLSSetApplicationLaunchServicesServerConnectionStatus == NULL) {\n    goto out;\n  }\n\n  if (pSetApplicationIsDaemon(1) != noErr)\n    goto out;\n\n  pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);\n\n  /* Check into process manager?! */\n  pLSApplicationCheckIn(-2,\n                        pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));\n\n  asn = pLSGetCurrentApplicationASN();\n\n  err = -EINVAL;\n  if (pLSSetApplicationInformationItem(-2,  /* Magic value. */\n                                       asn,\n                                       *display_name_key,\n                                       S(title),\n                                       NULL) != noErr) {\n    goto out;\n  }\n\n  uv__pthread_setname_np(title);  /* Don't care if it fails. */\n  err = 0;\n\nout:\n  if (core_foundation_handle != NULL)\n    dlclose(core_foundation_handle);\n\n  if (application_services_handle != NULL)\n    dlclose(application_services_handle);\n\n  return err;\n#endif  /* !TARGET_OS_IPHONE */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/src/unix/fsevents.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#if TARGET_OS_IPHONE\n\n/* iOS (currently) doesn't provide the FSEvents-API (nor CoreServices) */\n\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n}\n\n#else /* TARGET_OS_IPHONE */\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include <CoreFoundation/CFRunLoop.h>\n#include <CoreServices/CoreServices.h>\n\n/* These are macros to avoid \"initializer element is not constant\" errors\n * with old versions of gcc.\n */\n#define kFSEventsModified (kFSEventStreamEventFlagItemFinderInfoMod |         \\\n                           kFSEventStreamEventFlagItemModified |              \\\n                           kFSEventStreamEventFlagItemInodeMetaMod |          \\\n                           kFSEventStreamEventFlagItemChangeOwner |           \\\n                           kFSEventStreamEventFlagItemXattrMod)\n\n#define kFSEventsRenamed  (kFSEventStreamEventFlagItemCreated |               \\\n                           kFSEventStreamEventFlagItemRemoved |               \\\n                           kFSEventStreamEventFlagItemRenamed)\n\n#define kFSEventsSystem   (kFSEventStreamEventFlagUserDropped |               \\\n                           kFSEventStreamEventFlagKernelDropped |             \\\n                           kFSEventStreamEventFlagEventIdsWrapped |           \\\n                           kFSEventStreamEventFlagHistoryDone |               \\\n                           kFSEventStreamEventFlagMount |                     \\\n                           kFSEventStreamEventFlagUnmount |                   \\\n                           kFSEventStreamEventFlagRootChanged)\n\ntypedef struct uv__fsevents_event_s uv__fsevents_event_t;\ntypedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;\ntypedef struct uv__cf_loop_state_s uv__cf_loop_state_t;\n\nenum uv__cf_loop_signal_type_e {\n  kUVCFLoopSignalRegular,\n  kUVCFLoopSignalClosing\n};\ntypedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;\n\nstruct uv__cf_loop_signal_s {\n  QUEUE member;\n  uv_fs_event_t* handle;\n  uv__cf_loop_signal_type_t type;\n};\n\nstruct uv__fsevents_event_s {\n  QUEUE member;\n  int events;\n  char path[1];\n};\n\nstruct uv__cf_loop_state_s {\n  CFRunLoopRef loop;\n  CFRunLoopSourceRef signal_source;\n  int fsevent_need_reschedule;\n  FSEventStreamRef fsevent_stream;\n  uv_sem_t fsevent_sem;\n  uv_mutex_t fsevent_mutex;\n  void* fsevent_handles[2];\n  unsigned int fsevent_handle_count;\n};\n\n/* Forward declarations */\nstatic void uv__cf_loop_cb(void* arg);\nstatic void* uv__cf_loop_runner(void* arg);\nstatic int uv__cf_loop_signal(uv_loop_t* loop,\n                              uv_fs_event_t* handle,\n                              uv__cf_loop_signal_type_t type);\n\n/* Lazy-loaded by uv__fsevents_global_init(). */\nstatic CFArrayRef (*pCFArrayCreate)(CFAllocatorRef,\n                                    const void**,\n                                    CFIndex,\n                                    const CFArrayCallBacks*);\nstatic void (*pCFRelease)(CFTypeRef);\nstatic void (*pCFRunLoopAddSource)(CFRunLoopRef,\n                                   CFRunLoopSourceRef,\n                                   CFStringRef);\nstatic CFRunLoopRef (*pCFRunLoopGetCurrent)(void);\nstatic void (*pCFRunLoopRemoveSource)(CFRunLoopRef,\n                                      CFRunLoopSourceRef,\n                                      CFStringRef);\nstatic void (*pCFRunLoopRun)(void);\nstatic CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef,\n                                                    CFIndex,\n                                                    CFRunLoopSourceContext*);\nstatic void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);\nstatic void (*pCFRunLoopStop)(CFRunLoopRef);\nstatic void (*pCFRunLoopWakeUp)(CFRunLoopRef);\nstatic CFStringRef (*pCFStringCreateWithFileSystemRepresentation)(\n    CFAllocatorRef,\n    const char*);\nstatic CFStringEncoding (*pCFStringGetSystemEncoding)(void);\nstatic CFStringRef (*pkCFRunLoopDefaultMode);\nstatic FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef,\n                                                FSEventStreamCallback,\n                                                FSEventStreamContext*,\n                                                CFArrayRef,\n                                                FSEventStreamEventId,\n                                                CFTimeInterval,\n                                                FSEventStreamCreateFlags);\nstatic void (*pFSEventStreamFlushSync)(FSEventStreamRef);\nstatic void (*pFSEventStreamInvalidate)(FSEventStreamRef);\nstatic void (*pFSEventStreamRelease)(FSEventStreamRef);\nstatic void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,\n                                                 CFRunLoopRef,\n                                                 CFStringRef);\nstatic Boolean (*pFSEventStreamStart)(FSEventStreamRef);\nstatic void (*pFSEventStreamStop)(FSEventStreamRef);\n\n#define UV__FSEVENTS_PROCESS(handle, block)                                   \\\n    do {                                                                      \\\n      QUEUE events;                                                           \\\n      QUEUE* q;                                                               \\\n      uv__fsevents_event_t* event;                                            \\\n      int err;                                                                \\\n      uv_mutex_lock(&(handle)->cf_mutex);                                     \\\n      /* Split-off all events and empty original queue */                     \\\n      QUEUE_MOVE(&(handle)->cf_events, &events);                              \\\n      /* Get error (if any) and zero original one */                          \\\n      err = (handle)->cf_error;                                               \\\n      (handle)->cf_error = 0;                                                 \\\n      uv_mutex_unlock(&(handle)->cf_mutex);                                   \\\n      /* Loop through events, deallocating each after processing */           \\\n      while (!QUEUE_EMPTY(&events)) {                                         \\\n        q = QUEUE_HEAD(&events);                                              \\\n        event = QUEUE_DATA(q, uv__fsevents_event_t, member);                  \\\n        QUEUE_REMOVE(q);                                                      \\\n        /* NOTE: Checking uv__is_active() is required here, because handle    \\\n         * callback may close handle and invoking it after it will lead to    \\\n         * incorrect behaviour */                                             \\\n        if (!uv__is_closing((handle)) && uv__is_active((handle)))             \\\n          block                                                               \\\n        /* Free allocated data */                                             \\\n        uv__free(event);                                                      \\\n      }                                                                       \\\n      if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))   \\\n        (handle)->cb((handle), NULL, 0, err);                                 \\\n    } while (0)\n\n\n/* Runs in UV loop's thread, when there're events to report to handle */\nstatic void uv__fsevents_cb(uv_async_t* cb) {\n  uv_fs_event_t* handle;\n\n  handle = cb->data;\n\n  UV__FSEVENTS_PROCESS(handle, {\n    handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);\n  });\n}\n\n\n/* Runs in CF thread, pushed event into handle's event list */\nstatic void uv__fsevents_push_event(uv_fs_event_t* handle,\n                                    QUEUE* events,\n                                    int err) {\n  assert(events != NULL || err != 0);\n  uv_mutex_lock(&handle->cf_mutex);\n\n  /* Concatenate two queues */\n  if (events != NULL)\n    QUEUE_ADD(&handle->cf_events, events);\n\n  /* Propagate error */\n  if (err != 0)\n    handle->cf_error = err;\n  uv_mutex_unlock(&handle->cf_mutex);\n\n  uv_async_send(handle->cf_cb);\n}\n\n\n/* Runs in CF thread, when there're events in FSEventStream */\nstatic void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n                                  void* info,\n                                  size_t numEvents,\n                                  void* eventPaths,\n                                  const FSEventStreamEventFlags eventFlags[],\n                                  const FSEventStreamEventId eventIds[]) {\n  size_t i;\n  int len;\n  char** paths;\n  char* path;\n  char* pos;\n  uv_fs_event_t* handle;\n  QUEUE* q;\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  uv__fsevents_event_t* event;\n  QUEUE head;\n\n  loop = info;\n  state = loop->cf_state;\n  assert(state != NULL);\n  paths = eventPaths;\n\n  /* For each handle */\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_FOREACH(q, &state->fsevent_handles) {\n    handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n    QUEUE_INIT(&head);\n\n    /* Process and filter out events */\n    for (i = 0; i < numEvents; i++) {\n      /* Ignore system events */\n      if (eventFlags[i] & kFSEventsSystem)\n        continue;\n\n      path = paths[i];\n      len = strlen(path);\n\n      /* Filter out paths that are outside handle's request */\n      if (strncmp(path, handle->realpath, handle->realpath_len) != 0)\n        continue;\n\n      if (handle->realpath_len > 1 || *handle->realpath != '/') {\n        path += handle->realpath_len;\n        len -= handle->realpath_len;\n\n        /* Skip forward slash */\n        if (*path != '\\0') {\n          path++;\n          len--;\n        }\n      }\n\n#ifdef MAC_OS_X_VERSION_10_7\n      /* Ignore events with path equal to directory itself */\n      if (len == 0)\n        continue;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      /* Do not emit events from subdirectories (without option set) */\n      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != 0) {\n        pos = strchr(path + 1, '/');\n        if (pos != NULL)\n          continue;\n      }\n\n#ifndef MAC_OS_X_VERSION_10_7\n      path = \"\";\n      len = 0;\n#endif /* MAC_OS_X_VERSION_10_7 */\n\n      event = uv__malloc(sizeof(*event) + len);\n      if (event == NULL)\n        break;\n\n      memset(event, 0, sizeof(*event));\n      memcpy(event->path, path, len + 1);\n\n      if ((eventFlags[i] & kFSEventsModified) != 0 &&\n          (eventFlags[i] & kFSEventsRenamed) == 0)\n        event->events = UV_CHANGE;\n      else\n        event->events = UV_RENAME;\n\n      QUEUE_INSERT_TAIL(&head, &event->member);\n    }\n\n    if (!QUEUE_EMPTY(&head))\n      uv__fsevents_push_event(handle, &head, 0);\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n}\n\n\n/* Runs in CF thread */\nstatic int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n  uv__cf_loop_state_t* state;\n  FSEventStreamContext ctx;\n  FSEventStreamRef ref;\n  CFAbsoluteTime latency;\n  FSEventStreamCreateFlags flags;\n\n  /* Initialize context */\n  ctx.version = 0;\n  ctx.info = loop;\n  ctx.retain = NULL;\n  ctx.release = NULL;\n  ctx.copyDescription = NULL;\n\n  latency = 0.05;\n\n  /* Explanation of selected flags:\n   * 1. NoDefer - without this flag, events that are happening continuously\n   *    (i.e. each event is happening after time interval less than `latency`,\n   *    counted from previous event), will be deferred and passed to callback\n   *    once they'll either fill whole OS buffer, or when this continuous stream\n   *    will stop (i.e. there'll be delay between events, bigger than\n   *    `latency`).\n   *    Specifying this flag will invoke callback after `latency` time passed\n   *    since event.\n   * 2. FileEvents - fire callback for file changes too (by default it is firing\n   *    it only for directory changes).\n   */\n  flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;\n\n  /*\n   * NOTE: It might sound like a good idea to remember last seen StreamEventId,\n   * but in reality one dir might have last StreamEventId less than, the other,\n   * that is being watched now. Which will cause FSEventStream API to report\n   * changes to files from the past.\n   */\n  ref = pFSEventStreamCreate(NULL,\n                             &uv__fsevents_event_cb,\n                             &ctx,\n                             paths,\n                             kFSEventStreamEventIdSinceNow,\n                             latency,\n                             flags);\n  assert(ref != NULL);\n\n  state = loop->cf_state;\n  pFSEventStreamScheduleWithRunLoop(ref,\n                                    state->loop,\n                                    *pkCFRunLoopDefaultMode);\n  if (!pFSEventStreamStart(ref)) {\n    pFSEventStreamInvalidate(ref);\n    pFSEventStreamRelease(ref);\n    return -EMFILE;\n  }\n\n  state->fsevent_stream = ref;\n  return 0;\n}\n\n\n/* Runs in CF thread */\nstatic void uv__fsevents_destroy_stream(uv_loop_t* loop) {\n  uv__cf_loop_state_t* state;\n\n  state = loop->cf_state;\n\n  if (state->fsevent_stream == NULL)\n    return;\n\n  /* Flush all accumulated events */\n  pFSEventStreamFlushSync(state->fsevent_stream);\n\n  /* Stop emitting events */\n  pFSEventStreamStop(state->fsevent_stream);\n\n  /* Release stream */\n  pFSEventStreamInvalidate(state->fsevent_stream);\n  pFSEventStreamRelease(state->fsevent_stream);\n  state->fsevent_stream = NULL;\n}\n\n\n/* Runs in CF thread, when there're new fsevent handles to add to stream */\nstatic void uv__fsevents_reschedule(uv_fs_event_t* handle,\n                                    uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n  uv_fs_event_t* curr;\n  CFArrayRef cf_paths;\n  CFStringRef* paths;\n  unsigned int i;\n  int err;\n  unsigned int path_count;\n\n  state = handle->loop->cf_state;\n  paths = NULL;\n  cf_paths = NULL;\n  err = 0;\n  /* NOTE: `i` is used in deallocation loop below */\n  i = 0;\n\n  /* Optimization to prevent O(n^2) time spent when starting to watch\n   * many files simultaneously\n   */\n  uv_mutex_lock(&state->fsevent_mutex);\n  if (state->fsevent_need_reschedule == 0) {\n    uv_mutex_unlock(&state->fsevent_mutex);\n    goto final;\n  }\n  state->fsevent_need_reschedule = 0;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Destroy previous FSEventStream */\n  uv__fsevents_destroy_stream(handle->loop);\n\n  /* Any failure below will be a memory failure */\n  err = -ENOMEM;\n\n  /* Create list of all watched paths */\n  uv_mutex_lock(&state->fsevent_mutex);\n  path_count = state->fsevent_handle_count;\n  if (path_count != 0) {\n    paths = uv__malloc(sizeof(*paths) * path_count);\n    if (paths == NULL) {\n      uv_mutex_unlock(&state->fsevent_mutex);\n      goto final;\n    }\n\n    q = &state->fsevent_handles;\n    for (; i < path_count; i++) {\n      q = QUEUE_NEXT(q);\n      assert(q != &state->fsevent_handles);\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n\n      assert(curr->realpath != NULL);\n      paths[i] =\n          pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath);\n      if (paths[i] == NULL) {\n        uv_mutex_unlock(&state->fsevent_mutex);\n        goto final;\n      }\n    }\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n  err = 0;\n\n  if (path_count != 0) {\n    /* Create new FSEventStream */\n    cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n    if (cf_paths == NULL) {\n      err = -ENOMEM;\n      goto final;\n    }\n    err = uv__fsevents_create_stream(handle->loop, cf_paths);\n  }\n\nfinal:\n  /* Deallocate all paths in case of failure */\n  if (err != 0) {\n    if (cf_paths == NULL) {\n      while (i != 0)\n        pCFRelease(paths[--i]);\n      uv__free(paths);\n    } else {\n      /* CFArray takes ownership of both strings and original C-array */\n      pCFRelease(cf_paths);\n    }\n\n    /* Broadcast error to all handles */\n    uv_mutex_lock(&state->fsevent_mutex);\n    QUEUE_FOREACH(q, &state->fsevent_handles) {\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n      uv__fsevents_push_event(curr, NULL, err);\n    }\n    uv_mutex_unlock(&state->fsevent_mutex);\n  }\n\n  /*\n   * Main thread will block until the removal of handle from the list,\n   * we must tell it when we're ready.\n   *\n   * NOTE: This is coupled with `uv_sem_wait()` in `uv__fsevents_close`\n   */\n  if (type == kUVCFLoopSignalClosing)\n    uv_sem_post(&state->fsevent_sem);\n}\n\n\nstatic int uv__fsevents_global_init(void) {\n  static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static void* core_foundation_handle;\n  static void* core_services_handle;\n  int err;\n\n  err = 0;\n  pthread_mutex_lock(&global_init_mutex);\n  if (core_foundation_handle != NULL)\n    goto out;\n\n  /* The libraries are never unloaded because we currently don't have a good\n   * mechanism for keeping a reference count. It's unlikely to be an issue\n   * but if it ever becomes one, we can turn the dynamic library handles into\n   * per-event loop properties and have the dynamic linker keep track for us.\n   */\n  err = -ENOSYS;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  if (core_foundation_handle == NULL)\n    goto out;\n\n  core_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                \"CoreServices.framework/\"\n                                \"Versions/A/CoreServices\",\n                                RTLD_LAZY | RTLD_LOCAL);\n  if (core_services_handle == NULL)\n    goto out;\n\n  err = -ENOENT;\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(core_foundation_handle, CFArrayCreate);\n  V(core_foundation_handle, CFRelease);\n  V(core_foundation_handle, CFRunLoopAddSource);\n  V(core_foundation_handle, CFRunLoopGetCurrent);\n  V(core_foundation_handle, CFRunLoopRemoveSource);\n  V(core_foundation_handle, CFRunLoopRun);\n  V(core_foundation_handle, CFRunLoopSourceCreate);\n  V(core_foundation_handle, CFRunLoopSourceSignal);\n  V(core_foundation_handle, CFRunLoopStop);\n  V(core_foundation_handle, CFRunLoopWakeUp);\n  V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, kCFRunLoopDefaultMode);\n  V(core_services_handle, FSEventStreamCreate);\n  V(core_services_handle, FSEventStreamFlushSync);\n  V(core_services_handle, FSEventStreamInvalidate);\n  V(core_services_handle, FSEventStreamRelease);\n  V(core_services_handle, FSEventStreamScheduleWithRunLoop);\n  V(core_services_handle, FSEventStreamStart);\n  V(core_services_handle, FSEventStreamStop);\n#undef V\n  err = 0;\n\nout:\n  if (err && core_services_handle != NULL) {\n    dlclose(core_services_handle);\n    core_services_handle = NULL;\n  }\n\n  if (err && core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  pthread_mutex_unlock(&global_init_mutex);\n  return err;\n}\n\n\n/* Runs in UV loop */\nstatic int uv__fsevents_loop_init(uv_loop_t* loop) {\n  CFRunLoopSourceContext ctx;\n  uv__cf_loop_state_t* state;\n  pthread_attr_t attr_storage;\n  pthread_attr_t* attr;\n  int err;\n\n  if (loop->cf_state != NULL)\n    return 0;\n\n  err = uv__fsevents_global_init();\n  if (err)\n    return err;\n\n  state = uv__calloc(1, sizeof(*state));\n  if (state == NULL)\n    return -ENOMEM;\n\n  err = uv_mutex_init(&loop->cf_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_sem_init(&loop->cf_sem, 0);\n  if (err)\n    goto fail_sem_init;\n\n  QUEUE_INIT(&loop->cf_signals);\n\n  err = uv_sem_init(&state->fsevent_sem, 0);\n  if (err)\n    goto fail_fsevent_sem_init;\n\n  err = uv_mutex_init(&state->fsevent_mutex);\n  if (err)\n    goto fail_fsevent_mutex_init;\n\n  QUEUE_INIT(&state->fsevent_handles);\n  state->fsevent_need_reschedule = 0;\n  state->fsevent_handle_count = 0;\n\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n  ctx.perform = uv__cf_loop_cb;\n  state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n  if (state->signal_source == NULL) {\n    err = -ENOMEM;\n    goto fail_signal_source_create;\n  }\n\n  /* In the unlikely event that pthread_attr_init() fails, create the thread\n   * with the default stack size. We'll use a little more address space but\n   * that in itself is not a fatal error.\n   */\n  attr = &attr_storage;\n  if (pthread_attr_init(attr))\n    attr = NULL;\n\n  if (attr != NULL)\n    if (pthread_attr_setstacksize(attr, 4 * PTHREAD_STACK_MIN))\n      abort();\n\n  loop->cf_state = state;\n\n  /* uv_thread_t is an alias for pthread_t. */\n  err = -pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop);\n\n  if (attr != NULL)\n    pthread_attr_destroy(attr);\n\n  if (err)\n    goto fail_thread_create;\n\n  /* Synchronize threads */\n  uv_sem_wait(&loop->cf_sem);\n  return 0;\n\nfail_thread_create:\n  loop->cf_state = NULL;\n\nfail_signal_source_create:\n  uv_mutex_destroy(&state->fsevent_mutex);\n\nfail_fsevent_mutex_init:\n  uv_sem_destroy(&state->fsevent_sem);\n\nfail_fsevent_sem_init:\n  uv_sem_destroy(&loop->cf_sem);\n\nfail_sem_init:\n  uv_mutex_destroy(&loop->cf_mutex);\n\nfail_mutex_init:\n  uv__free(state);\n  return err;\n}\n\n\n/* Runs in UV loop */\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n  uv__cf_loop_signal_t* s;\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n\n  if (loop->cf_state == NULL)\n    return;\n\n  if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0)\n    abort();\n\n  uv_thread_join(&loop->cf_thread);\n  uv_sem_destroy(&loop->cf_sem);\n  uv_mutex_destroy(&loop->cf_mutex);\n\n  /* Free any remaining data */\n  while (!QUEUE_EMPTY(&loop->cf_signals)) {\n    q = QUEUE_HEAD(&loop->cf_signals);\n    s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);\n    QUEUE_REMOVE(q);\n    uv__free(s);\n  }\n\n  /* Destroy state */\n  state = loop->cf_state;\n  uv_sem_destroy(&state->fsevent_sem);\n  uv_mutex_destroy(&state->fsevent_mutex);\n  pCFRelease(state->signal_source);\n  uv__free(state);\n  loop->cf_state = NULL;\n}\n\n\n/* Runs in CF thread. This is the CF loop's body */\nstatic void* uv__cf_loop_runner(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n\n  loop = arg;\n  state = loop->cf_state;\n  state->loop = pCFRunLoopGetCurrent();\n\n  pCFRunLoopAddSource(state->loop,\n                      state->signal_source,\n                      *pkCFRunLoopDefaultMode);\n\n  uv_sem_post(&loop->cf_sem);\n\n  pCFRunLoopRun();\n  pCFRunLoopRemoveSource(state->loop,\n                         state->signal_source,\n                         *pkCFRunLoopDefaultMode);\n\n  return NULL;\n}\n\n\n/* Runs in CF thread, executed after `uv__cf_loop_signal()` */\nstatic void uv__cf_loop_cb(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  QUEUE* item;\n  QUEUE split_head;\n  uv__cf_loop_signal_t* s;\n\n  loop = arg;\n  state = loop->cf_state;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_MOVE(&loop->cf_signals, &split_head);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  while (!QUEUE_EMPTY(&split_head)) {\n    item = QUEUE_HEAD(&split_head);\n    QUEUE_REMOVE(item);\n\n    s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);\n\n    /* This was a termination signal */\n    if (s->handle == NULL)\n      pCFRunLoopStop(state->loop);\n    else\n      uv__fsevents_reschedule(s->handle, s->type);\n\n    uv__free(s);\n  }\n}\n\n\n/* Runs in UV loop to notify CF thread */\nint uv__cf_loop_signal(uv_loop_t* loop,\n                       uv_fs_event_t* handle,\n                       uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_signal_t* item;\n  uv__cf_loop_state_t* state;\n\n  item = uv__malloc(sizeof(*item));\n  if (item == NULL)\n    return -ENOMEM;\n\n  item->handle = handle;\n  item->type = type;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  state = loop->cf_state;\n  assert(state != NULL);\n  pCFRunLoopSourceSignal(state->signal_source);\n  pCFRunLoopWakeUp(state->loop);\n\n  return 0;\n}\n\n\n/* Runs in UV loop to initialize handle */\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  err = uv__fsevents_loop_init(handle->loop);\n  if (err)\n    return err;\n\n  /* Get absolute path to file */\n  handle->realpath = realpath(handle->path, NULL);\n  if (handle->realpath == NULL)\n    return -errno;\n  handle->realpath_len = strlen(handle->realpath);\n\n  /* Initialize event queue */\n  QUEUE_INIT(&handle->cf_events);\n  handle->cf_error = 0;\n\n  /*\n   * Events will occur in other thread.\n   * Initialize callback for getting them back into event loop's thread\n   */\n  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n  if (handle->cf_cb == NULL) {\n    err = -ENOMEM;\n    goto fail_cf_cb_malloc;\n  }\n\n  handle->cf_cb->data = handle;\n  uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n  handle->cf_cb->flags |= UV__HANDLE_INTERNAL;\n  uv_unref((uv_handle_t*) handle->cf_cb);\n\n  err = uv_mutex_init(&handle->cf_mutex);\n  if (err)\n    goto fail_cf_mutex_init;\n\n  /* Insert handle into the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);\n  state->fsevent_handle_count++;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular);\n  if (err)\n    goto fail_loop_signal;\n\n  return 0;\n\nfail_loop_signal:\n  uv_mutex_destroy(&handle->cf_mutex);\n\nfail_cf_mutex_init:\n  uv__free(handle->cf_cb);\n  handle->cf_cb = NULL;\n\nfail_cf_cb_malloc:\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return err;\n}\n\n\n/* Runs in UV loop to de-initialize handle */\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  if (handle->cf_cb == NULL)\n    return -EINVAL;\n\n  /* Remove handle from  the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_REMOVE(&handle->cf_member);\n  state->fsevent_handle_count--;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n  if (err)\n    return -err;\n\n  /* Wait for deinitialization */\n  uv_sem_wait(&state->fsevent_sem);\n\n  uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free);\n  handle->cf_cb = NULL;\n\n  /* Free data in queue */\n  UV__FSEVENTS_PROCESS(handle, {\n    /* NOP */\n  });\n\n  uv_mutex_destroy(&handle->cf_mutex);\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return 0;\n}\n\n#endif /* TARGET_OS_IPHONE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/src/unix/core.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <stddef.h> /* NULL */\n#include <stdio.h> /* printf */\n#include <stdlib.h>\n#include <string.h> /* strerror */\n#include <errno.h>\n#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <limits.h> /* INT_MAX, PATH_MAX, IOV_MAX */\n#include <sys/uio.h> /* writev */\n#include <sys/resource.h> /* getrusage */\n#include <pwd.h>\n\n#ifdef __linux__\n# include <sys/ioctl.h>\n#endif\n\n#ifdef __sun\n# include <sys/types.h>\n# include <sys/wait.h>\n#endif\n\n#ifdef __APPLE__\n# include <mach-o/dyld.h> /* _NSGetExecutablePath */\n# include <sys/filio.h>\n# include <sys/ioctl.h>\n# if defined(O_CLOEXEC)\n#  define UV__O_CLOEXEC O_CLOEXEC\n# endif\n#endif\n\n#if defined(__FreeBSD__) || defined(__DragonFly__)\n# include <sys/sysctl.h>\n# include <sys/filio.h>\n# include <sys/ioctl.h>\n# include <sys/wait.h>\n# define UV__O_CLOEXEC O_CLOEXEC\n# if defined(__FreeBSD__) && __FreeBSD__ >= 10\n#  define uv__accept4 accept4\n#  define UV__SOCK_NONBLOCK SOCK_NONBLOCK\n#  define UV__SOCK_CLOEXEC  SOCK_CLOEXEC\n# endif\n# if !defined(F_DUP2FD_CLOEXEC) && defined(_F_DUP2FD_CLOEXEC)\n#  define F_DUP2FD_CLOEXEC  _F_DUP2FD_CLOEXEC\n# endif\n#endif\n\n#ifdef _AIX\n#include <sys/ioctl.h>\n#endif\n\n#if defined(__ANDROID_API__) && __ANDROID_API__ < 21\n# include <dlfcn.h>  /* for dlsym */\n#endif\n\nstatic int uv__run_pending(uv_loop_t* loop);\n\n/* Verify that uv_buf_t is ABI-compatible with struct iovec. */\nSTATIC_ASSERT(sizeof(uv_buf_t) == sizeof(struct iovec));\nSTATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->base) ==\n              sizeof(((struct iovec*) 0)->iov_base));\nSTATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->len) ==\n              sizeof(((struct iovec*) 0)->iov_len));\nSTATIC_ASSERT(offsetof(uv_buf_t, base) == offsetof(struct iovec, iov_base));\nSTATIC_ASSERT(offsetof(uv_buf_t, len) == offsetof(struct iovec, iov_len));\n\n\nuint64_t uv_hrtime(void) {\n  return uv__hrtime(UV_CLOCK_PRECISE);\n}\n\n\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!(handle->flags & (UV_CLOSING | UV_CLOSED)));\n\n  handle->flags |= UV_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n\n  case UV_UDP:\n    uv__udp_close((uv_udp_t*)handle);\n    break;\n\n  case UV_PREPARE:\n    uv__prepare_close((uv_prepare_t*)handle);\n    break;\n\n  case UV_CHECK:\n    uv__check_close((uv_check_t*)handle);\n    break;\n\n  case UV_IDLE:\n    uv__idle_close((uv_idle_t*)handle);\n    break;\n\n  case UV_ASYNC:\n    uv__async_close((uv_async_t*)handle);\n    break;\n\n  case UV_TIMER:\n    uv__timer_close((uv_timer_t*)handle);\n    break;\n\n  case UV_PROCESS:\n    uv__process_close((uv_process_t*)handle);\n    break;\n\n  case UV_FS_EVENT:\n    uv__fs_event_close((uv_fs_event_t*)handle);\n    break;\n\n  case UV_POLL:\n    uv__poll_close((uv_poll_t*)handle);\n    break;\n\n  case UV_FS_POLL:\n    uv__fs_poll_close((uv_fs_poll_t*)handle);\n    break;\n\n  case UV_SIGNAL:\n    uv__signal_close((uv_signal_t*) handle);\n    /* Signal handles may not be closed immediately. The signal code will */\n    /* itself close uv__make_close_pending whenever appropriate. */\n    return;\n\n  default:\n    assert(0);\n  }\n\n  uv__make_close_pending(handle);\n}\n\nint uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n  int r;\n  int fd;\n  socklen_t len;\n\n  if (handle == NULL || value == NULL)\n    return -EINVAL;\n\n  if (handle->type == UV_TCP || handle->type == UV_NAMED_PIPE)\n    fd = uv__stream_fd((uv_stream_t*) handle);\n  else if (handle->type == UV_UDP)\n    fd = ((uv_udp_t *) handle)->io_watcher.fd;\n  else\n    return -ENOTSUP;\n\n  len = sizeof(*value);\n\n  if (*value == 0)\n    r = getsockopt(fd, SOL_SOCKET, optname, value, &len);\n  else\n    r = setsockopt(fd, SOL_SOCKET, optname, (const void*) value, len);\n\n  if (r < 0)\n    return -errno;\n\n  return 0;\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_CLOSING);\n  assert(!(handle->flags & UV_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n\nint uv__getiovmax(void) {\n#if defined(IOV_MAX)\n  return IOV_MAX;\n#elif defined(_SC_IOV_MAX)\n  static int iovmax = -1;\n  if (iovmax == -1) {\n    iovmax = sysconf(_SC_IOV_MAX);\n    /* On some embedded devices (arm-linux-uclibc based ip camera),\n     * sysconf(_SC_IOV_MAX) can not get the correct value. The return\n     * value is -1 and the errno is EINPROGRESS. Degrade the value to 1.\n     */\n    if (iovmax == -1) iovmax = 1;\n  }\n  return iovmax;\n#else\n  return 1024;\n#endif\n}\n\n\nstatic void uv__finish_close(uv_handle_t* handle) {\n  /* Note: while the handle is in the UV_CLOSING state now, it's still possible\n   * for it to be active in the sense that uv__is_active() returns true.\n   * A good example is when the user calls uv_shutdown(), immediately followed\n   * by uv_close(). The handle is considered active at this point because the\n   * completion of the shutdown req is still pending.\n   */\n  assert(handle->flags & UV_CLOSING);\n  assert(!(handle->flags & UV_CLOSED));\n  handle->flags |= UV_CLOSED;\n\n  switch (handle->type) {\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_IDLE:\n    case UV_ASYNC:\n    case UV_TIMER:\n    case UV_PROCESS:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_POLL:\n    case UV_SIGNAL:\n      break;\n\n    case UV_NAMED_PIPE:\n    case UV_TCP:\n    case UV_TTY:\n      uv__stream_destroy((uv_stream_t*)handle);\n      break;\n\n    case UV_UDP:\n      uv__udp_finish_close((uv_udp_t*)handle);\n      break;\n\n    default:\n      assert(0);\n      break;\n  }\n\n  uv__handle_unref(handle);\n  QUEUE_REMOVE(&handle->handle_queue);\n\n  if (handle->close_cb) {\n    handle->close_cb(handle);\n  }\n}\n\n\nstatic void uv__run_closing_handles(uv_loop_t* loop) {\n  uv_handle_t* p;\n  uv_handle_t* q;\n\n  p = loop->closing_handles;\n  loop->closing_handles = NULL;\n\n  while (p) {\n    q = p->next_closing;\n    uv__finish_close(p);\n    p = q;\n  }\n}\n\n\nint uv_is_closing(const uv_handle_t* handle) {\n  return uv__is_closing(handle);\n}\n\n\nint uv_backend_fd(const uv_loop_t* loop) {\n  return loop->backend_fd;\n}\n\n\nint uv_backend_timeout(const uv_loop_t* loop) {\n  if (loop->stop_flag != 0)\n    return 0;\n\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\n\nstatic int uv__loop_alive(const uv_loop_t* loop) {\n  return uv__has_active_handles(loop) ||\n         uv__has_active_reqs(loop) ||\n         loop->closing_handles != NULL;\n}\n\n\nint uv_loop_alive(const uv_loop_t* loop) {\n    return uv__loop_alive(loop);\n}\n\n\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    uv__run_timers(loop);\n    ran_pending = uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n\n    timeout = 0;\n    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);\n    uv__run_check(loop);\n    uv__run_closing_handles(loop);\n\n    if (mode == UV_RUN_ONCE) {\n      /* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  /* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */\n  if (loop->stop_flag != 0)\n    loop->stop_flag = 0;\n\n  return r;\n}\n\n\nvoid uv_update_time(uv_loop_t* loop) {\n  uv__update_time(loop);\n}\n\n\nint uv_is_active(const uv_handle_t* handle) {\n  return uv__is_active(handle);\n}\n\n\n/* Open a socket in non-blocking close-on-exec mode, atomically if possible. */\nint uv__socket(int domain, int type, int protocol) {\n  int sockfd;\n  int err;\n\n#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)\n  sockfd = socket(domain, type | SOCK_NONBLOCK | SOCK_CLOEXEC, protocol);\n  if (sockfd != -1)\n    return sockfd;\n\n  if (errno != EINVAL)\n    return -errno;\n#endif\n\n  sockfd = socket(domain, type, protocol);\n  if (sockfd == -1)\n    return -errno;\n\n  err = uv__nonblock(sockfd, 1);\n  if (err == 0)\n    err = uv__cloexec(sockfd, 1);\n\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n#if defined(SO_NOSIGPIPE)\n  {\n    int on = 1;\n    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &on, sizeof(on));\n  }\n#endif\n\n  return sockfd;\n}\n\n/* get a file pointer to a file in read-only and close-on-exec mode */\nFILE* uv__open_file(const char* path) {\n  int fd;\n  FILE* fp;\n\n  fd = uv__open_cloexec(path, O_RDONLY);\n  if (fd < 0)\n    return NULL;\n\n   fp = fdopen(fd, \"r\");\n   if (fp == NULL)\n     uv__close(fd);\n\n   return fp;\n}\n\n\nint uv__accept(int sockfd) {\n  int peerfd;\n  int err;\n\n  assert(sockfd >= 0);\n\n  while (1) {\n#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD__ >= 10)\n    static int no_accept4;\n\n    if (no_accept4)\n      goto skip;\n\n    peerfd = uv__accept4(sockfd,\n                         NULL,\n                         NULL,\n                         UV__SOCK_NONBLOCK|UV__SOCK_CLOEXEC);\n    if (peerfd != -1)\n      return peerfd;\n\n    if (errno == EINTR)\n      continue;\n\n    if (errno != ENOSYS)\n      return -errno;\n\n    no_accept4 = 1;\nskip:\n#endif\n\n    peerfd = accept(sockfd, NULL, NULL);\n    if (peerfd == -1) {\n      if (errno == EINTR)\n        continue;\n      return -errno;\n    }\n\n    err = uv__cloexec(peerfd, 1);\n    if (err == 0)\n      err = uv__nonblock(peerfd, 1);\n\n    if (err) {\n      uv__close(peerfd);\n      return err;\n    }\n\n    return peerfd;\n  }\n}\n\n\nint uv__close_nocheckstdio(int fd) {\n  int saved_errno;\n  int rc;\n\n  assert(fd > -1);  /* Catch uninitialized io_watcher.fd bugs. */\n\n  saved_errno = errno;\n  rc = close(fd);\n  if (rc == -1) {\n    rc = -errno;\n    if (rc == -EINTR)\n      rc = -EINPROGRESS;  /* For platform/libc consistency. */\n    errno = saved_errno;\n  }\n\n  return rc;\n}\n\n\nint uv__close(int fd) {\n  assert(fd > STDERR_FILENO);  /* Catch stdio close bugs. */\n  return uv__close_nocheckstdio(fd);\n}\n\n\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || \\\n    defined(_AIX) || defined(__DragonFly__)\n\nint uv__nonblock(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, FIONBIO, &set);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}\n\n\nint uv__cloexec(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, set ? FIOCLEX : FIONCLEX);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}\n\n#else /* !(defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || \\\n\t   defined(_AIX) || defined(__DragonFly__)) */\n\nint uv__nonblock(int fd, int set) {\n  int flags;\n  int r;\n\n  do\n    r = fcntl(fd, F_GETFL);\n  while (r == -1 && errno == EINTR);\n\n  if (r == -1)\n    return -errno;\n\n  /* Bail out now if already set/clear. */\n  if (!!(r & O_NONBLOCK) == !!set)\n    return 0;\n\n  if (set)\n    flags = r | O_NONBLOCK;\n  else\n    flags = r & ~O_NONBLOCK;\n\n  do\n    r = fcntl(fd, F_SETFL, flags);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}\n\n\nint uv__cloexec(int fd, int set) {\n  int flags;\n  int r;\n\n  do\n    r = fcntl(fd, F_GETFD);\n  while (r == -1 && errno == EINTR);\n\n  if (r == -1)\n    return -errno;\n\n  /* Bail out now if already set/clear. */\n  if (!!(r & FD_CLOEXEC) == !!set)\n    return 0;\n\n  if (set)\n    flags = r | FD_CLOEXEC;\n  else\n    flags = r & ~FD_CLOEXEC;\n\n  do\n    r = fcntl(fd, F_SETFD, flags);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}\n\n#endif /* defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || \\\n\t  defined(_AIX) || defined(__DragonFly__) */\n\n\n/* This function is not execve-safe, there is a race window\n * between the call to dup() and fcntl(FD_CLOEXEC).\n */\nint uv__dup(int fd) {\n  int err;\n\n  fd = dup(fd);\n\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}\n\n\nssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n  struct cmsghdr* cmsg;\n  ssize_t rc;\n  int* pfd;\n  int* end;\n#if defined(__linux__)\n  static int no_msg_cmsg_cloexec;\n  if (no_msg_cmsg_cloexec == 0) {\n    rc = recvmsg(fd, msg, flags | 0x40000000);  /* MSG_CMSG_CLOEXEC */\n    if (rc != -1)\n      return rc;\n    if (errno != EINVAL)\n      return -errno;\n    rc = recvmsg(fd, msg, flags);\n    if (rc == -1)\n      return -errno;\n    no_msg_cmsg_cloexec = 1;\n  } else {\n    rc = recvmsg(fd, msg, flags);\n  }\n#else\n  rc = recvmsg(fd, msg, flags);\n#endif\n  if (rc == -1)\n    return -errno;\n  if (msg->msg_controllen == 0)\n    return rc;\n  for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg))\n    if (cmsg->cmsg_type == SCM_RIGHTS)\n      for (pfd = (int*) CMSG_DATA(cmsg),\n           end = (int*) ((char*) cmsg + cmsg->cmsg_len);\n           pfd < end;\n           pfd += 1)\n        uv__cloexec(*pfd, 1);\n  return rc;\n}\n\n\nint uv_cwd(char* buffer, size_t* size) {\n  if (buffer == NULL || size == NULL)\n    return -EINVAL;\n\n  if (getcwd(buffer, *size) == NULL)\n    return -errno;\n\n  *size = strlen(buffer);\n  if (*size > 1 && buffer[*size - 1] == '/') {\n    buffer[*size-1] = '\\0';\n    (*size)--;\n  }\n\n  return 0;\n}\n\n\nint uv_chdir(const char* dir) {\n  if (chdir(dir))\n    return -errno;\n\n  return 0;\n}\n\n\nvoid uv_disable_stdio_inheritance(void) {\n  int fd;\n\n  /* Set the CLOEXEC flag on all open descriptors. Unconditionally try the\n   * first 16 file descriptors. After that, bail out after the first error.\n   */\n  for (fd = 0; ; fd++)\n    if (uv__cloexec(fd, 1) && fd > 15)\n      break;\n}\n\n\nint uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {\n  int fd_out;\n\n  switch (handle->type) {\n  case UV_TCP:\n  case UV_NAMED_PIPE:\n  case UV_TTY:\n    fd_out = uv__stream_fd((uv_stream_t*) handle);\n    break;\n\n  case UV_UDP:\n    fd_out = ((uv_udp_t *) handle)->io_watcher.fd;\n    break;\n\n  case UV_POLL:\n    fd_out = ((uv_poll_t *) handle)->io_watcher.fd;\n    break;\n\n  default:\n    return -EINVAL;\n  }\n\n  if (uv__is_closing(handle) || fd_out == -1)\n    return -EBADF;\n\n  *fd = fd_out;\n  return 0;\n}\n\n\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n\n\nstatic unsigned int next_power_of_two(unsigned int val) {\n  val -= 1;\n  val |= val >> 1;\n  val |= val >> 2;\n  val |= val >> 4;\n  val |= val >> 8;\n  val |= val >> 16;\n  val += 1;\n  return val;\n}\n\nstatic void maybe_resize(uv_loop_t* loop, unsigned int len) {\n  uv__io_t** watchers;\n  void* fake_watcher_list;\n  void* fake_watcher_count;\n  unsigned int nwatchers;\n  unsigned int i;\n\n  if (len <= loop->nwatchers)\n    return;\n\n  /* Preserve fake watcher list and count at the end of the watchers */\n  if (loop->watchers != NULL) {\n    fake_watcher_list = loop->watchers[loop->nwatchers];\n    fake_watcher_count = loop->watchers[loop->nwatchers + 1];\n  } else {\n    fake_watcher_list = NULL;\n    fake_watcher_count = NULL;\n  }\n\n  nwatchers = next_power_of_two(len + 2) - 2;\n  watchers = uv__realloc(loop->watchers,\n                         (nwatchers + 2) * sizeof(loop->watchers[0]));\n\n  if (watchers == NULL)\n    abort();\n  for (i = loop->nwatchers; i < nwatchers; i++)\n    watchers[i] = NULL;\n  watchers[nwatchers] = fake_watcher_list;\n  watchers[nwatchers + 1] = fake_watcher_count;\n\n  loop->watchers = watchers;\n  loop->nwatchers = nwatchers;\n}\n\n\nvoid uv__io_init(uv__io_t* w, uv__io_cb cb, int fd) {\n  assert(cb != NULL);\n  assert(fd >= -1);\n  QUEUE_INIT(&w->pending_queue);\n  QUEUE_INIT(&w->watcher_queue);\n  w->cb = cb;\n  w->fd = fd;\n  w->events = 0;\n  w->pevents = 0;\n\n#if defined(UV_HAVE_KQUEUE)\n  w->rcount = 0;\n  w->wcount = 0;\n#endif /* defined(UV_HAVE_KQUEUE) */\n}\n\n\nvoid uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP)));\n  assert(0 != events);\n  assert(w->fd >= 0);\n  assert(w->fd < INT_MAX);\n\n  w->pevents |= events;\n  maybe_resize(loop, w->fd + 1);\n\n#if !defined(__sun)\n  /* The event ports backend needs to rearm all file descriptors on each and\n   * every tick of the event loop but the other backends allow us to\n   * short-circuit here if the event mask is unchanged.\n   */\n  if (w->events == w->pevents) {\n    if (w->events == 0 && !QUEUE_EMPTY(&w->watcher_queue)) {\n      QUEUE_REMOVE(&w->watcher_queue);\n      QUEUE_INIT(&w->watcher_queue);\n    }\n    return;\n  }\n#endif\n\n  if (QUEUE_EMPTY(&w->watcher_queue))\n    QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);\n\n  if (loop->watchers[w->fd] == NULL) {\n    loop->watchers[w->fd] = w;\n    loop->nfds++;\n  }\n}\n\n\nvoid uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP)));\n  assert(0 != events);\n\n  if (w->fd == -1)\n    return;\n\n  assert(w->fd >= 0);\n\n  /* Happens when uv__io_stop() is called on a handle that was never started. */\n  if ((unsigned) w->fd >= loop->nwatchers)\n    return;\n\n  w->pevents &= ~events;\n\n  if (w->pevents == 0) {\n    QUEUE_REMOVE(&w->watcher_queue);\n    QUEUE_INIT(&w->watcher_queue);\n\n    if (loop->watchers[w->fd] != NULL) {\n      assert(loop->watchers[w->fd] == w);\n      assert(loop->nfds > 0);\n      loop->watchers[w->fd] = NULL;\n      loop->nfds--;\n      w->events = 0;\n    }\n  }\n  else if (QUEUE_EMPTY(&w->watcher_queue))\n    QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);\n}\n\n\nvoid uv__io_close(uv_loop_t* loop, uv__io_t* w) {\n  uv__io_stop(loop, w, POLLIN | POLLOUT | UV__POLLRDHUP);\n  QUEUE_REMOVE(&w->pending_queue);\n\n  /* Remove stale events for this file descriptor */\n  uv__platform_invalidate_fd(loop, w->fd);\n}\n\n\nvoid uv__io_feed(uv_loop_t* loop, uv__io_t* w) {\n  if (QUEUE_EMPTY(&w->pending_queue))\n    QUEUE_INSERT_TAIL(&loop->pending_queue, &w->pending_queue);\n}\n\n\nint uv__io_active(const uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP)));\n  assert(0 != events);\n  return 0 != (w->pevents & events);\n}\n\n\nint uv_getrusage(uv_rusage_t* rusage) {\n  struct rusage usage;\n\n  if (getrusage(RUSAGE_SELF, &usage))\n    return -errno;\n\n  rusage->ru_utime.tv_sec = usage.ru_utime.tv_sec;\n  rusage->ru_utime.tv_usec = usage.ru_utime.tv_usec;\n\n  rusage->ru_stime.tv_sec = usage.ru_stime.tv_sec;\n  rusage->ru_stime.tv_usec = usage.ru_stime.tv_usec;\n\n  rusage->ru_maxrss = usage.ru_maxrss;\n  rusage->ru_ixrss = usage.ru_ixrss;\n  rusage->ru_idrss = usage.ru_idrss;\n  rusage->ru_isrss = usage.ru_isrss;\n  rusage->ru_minflt = usage.ru_minflt;\n  rusage->ru_majflt = usage.ru_majflt;\n  rusage->ru_nswap = usage.ru_nswap;\n  rusage->ru_inblock = usage.ru_inblock;\n  rusage->ru_oublock = usage.ru_oublock;\n  rusage->ru_msgsnd = usage.ru_msgsnd;\n  rusage->ru_msgrcv = usage.ru_msgrcv;\n  rusage->ru_nsignals = usage.ru_nsignals;\n  rusage->ru_nvcsw = usage.ru_nvcsw;\n  rusage->ru_nivcsw = usage.ru_nivcsw;\n\n  return 0;\n}\n\n\nint uv__open_cloexec(const char* path, int flags) {\n  int err;\n  int fd;\n\n#if defined(UV__O_CLOEXEC)\n  static int no_cloexec;\n\n  if (!no_cloexec) {\n    fd = open(path, flags | UV__O_CLOEXEC);\n    if (fd != -1)\n      return fd;\n\n    if (errno != EINVAL)\n      return -errno;\n\n    /* O_CLOEXEC not supported. */\n    no_cloexec = 1;\n  }\n#endif\n\n  fd = open(path, flags);\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}\n\n\nint uv__dup2_cloexec(int oldfd, int newfd) {\n  int r;\n#if defined(__FreeBSD__) && __FreeBSD__ >= 10\n  r = dup3(oldfd, newfd, O_CLOEXEC);\n  if (r == -1)\n    return -errno;\n  return r;\n#elif defined(__FreeBSD__) && defined(F_DUP2FD_CLOEXEC)\n  r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);\n  if (r != -1)\n    return r;\n  if (errno != EINVAL)\n    return -errno;\n  /* Fall through. */\n#elif defined(__linux__)\n  static int no_dup3;\n  if (!no_dup3) {\n    do\n      r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);\n    while (r == -1 && errno == EBUSY);\n    if (r != -1)\n      return r;\n    if (errno != ENOSYS)\n      return -errno;\n    /* Fall through. */\n    no_dup3 = 1;\n  }\n#endif\n  {\n    int err;\n    do\n      r = dup2(oldfd, newfd);\n#if defined(__linux__)\n    while (r == -1 && errno == EBUSY);\n#else\n    while (0);  /* Never retry. */\n#endif\n\n    if (r == -1)\n      return -errno;\n\n    err = uv__cloexec(newfd, 1);\n    if (err) {\n      uv__close(newfd);\n      return err;\n    }\n\n    return r;\n  }\n}\n\n\nint uv_os_homedir(char* buffer, size_t* size) {\n  uv_passwd_t pwd;\n  char* buf;\n  size_t len;\n  int r;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n  /* Check if the HOME environment variable is set first */\n  buf = getenv(\"HOME\");\n\n  if (buf != NULL) {\n    len = strlen(buf);\n\n    if (len >= *size) {\n      *size = len + 1;\n      return -ENOBUFS;\n    }\n\n    memcpy(buffer, buf, len + 1);\n    *size = len;\n\n    return 0;\n  }\n\n  /* HOME is not set, so call uv__getpwuid_r() */\n  r = uv__getpwuid_r(&pwd);\n\n  if (r != 0) {\n    return r;\n  }\n\n  len = strlen(pwd.homedir);\n\n  if (len >= *size) {\n    *size = len + 1;\n    uv_os_free_passwd(&pwd);\n    return -ENOBUFS;\n  }\n\n  memcpy(buffer, pwd.homedir, len + 1);\n  *size = len;\n  uv_os_free_passwd(&pwd);\n\n  return 0;\n}\n\n\nint uv_os_tmpdir(char* buffer, size_t* size) {\n  const char* buf;\n  size_t len;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n#define CHECK_ENV_VAR(name)                                                   \\\n  do {                                                                        \\\n    buf = getenv(name);                                                       \\\n    if (buf != NULL)                                                          \\\n      goto return_buffer;                                                     \\\n  }                                                                           \\\n  while (0)\n\n  /* Check the TMPDIR, TMP, TEMP, and TEMPDIR environment variables in order */\n  CHECK_ENV_VAR(\"TMPDIR\");\n  CHECK_ENV_VAR(\"TMP\");\n  CHECK_ENV_VAR(\"TEMP\");\n  CHECK_ENV_VAR(\"TEMPDIR\");\n\n#undef CHECK_ENV_VAR\n\n  /* No temp environment variables defined */\n  #if defined(__ANDROID__)\n    buf = \"/data/local/tmp\";\n  #else\n    buf = \"/tmp\";\n  #endif\n\nreturn_buffer:\n  len = strlen(buf);\n\n  if (len >= *size) {\n    *size = len + 1;\n    return -ENOBUFS;\n  }\n\n  /* The returned directory should not have a trailing slash. */\n  if (len > 1 && buf[len - 1] == '/') {\n    len--;\n  }\n\n  memcpy(buffer, buf, len + 1);\n  buffer[len] = '\\0';\n  *size = len;\n\n  return 0;\n}\n\n\nint uv__getpwuid_r(uv_passwd_t* pwd) {\n  struct passwd pw;\n  struct passwd* result;\n  char* buf;\n  uid_t uid;\n  size_t bufsize;\n  size_t name_size;\n  size_t homedir_size;\n  size_t shell_size;\n  long initsize;\n  int r;\n#if defined(__ANDROID_API__) && __ANDROID_API__ < 21\n  int (*getpwuid_r)(uid_t, struct passwd*, char*, size_t, struct passwd**);\n\n  getpwuid_r = dlsym(RTLD_DEFAULT, \"getpwuid_r\");\n  if (getpwuid_r == NULL)\n    return -ENOSYS;\n#endif\n\n  if (pwd == NULL)\n    return -EINVAL;\n\n  initsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n\n  if (initsize <= 0)\n    bufsize = 4096;\n  else\n    bufsize = (size_t) initsize;\n\n  uid = geteuid();\n  buf = NULL;\n\n  for (;;) {\n    uv__free(buf);\n    buf = uv__malloc(bufsize);\n\n    if (buf == NULL)\n      return -ENOMEM;\n\n    r = getpwuid_r(uid, &pw, buf, bufsize, &result);\n\n    if (r != ERANGE)\n      break;\n\n    bufsize *= 2;\n  }\n\n  if (r != 0) {\n    uv__free(buf);\n    return -r;\n  }\n\n  if (result == NULL) {\n    uv__free(buf);\n    return -ENOENT;\n  }\n\n  /* Allocate memory for the username, shell, and home directory */\n  name_size = strlen(pw.pw_name) + 1;\n  homedir_size = strlen(pw.pw_dir) + 1;\n  shell_size = strlen(pw.pw_shell) + 1;\n  pwd->username = uv__malloc(name_size + homedir_size + shell_size);\n\n  if (pwd->username == NULL) {\n    uv__free(buf);\n    return -ENOMEM;\n  }\n\n  /* Copy the username */\n  memcpy(pwd->username, pw.pw_name, name_size);\n\n  /* Copy the home directory */\n  pwd->homedir = pwd->username + name_size;\n  memcpy(pwd->homedir, pw.pw_dir, homedir_size);\n\n  /* Copy the shell */\n  pwd->shell = pwd->homedir + homedir_size;\n  memcpy(pwd->shell, pw.pw_shell, shell_size);\n\n  /* Copy the uid and gid */\n  pwd->uid = pw.pw_uid;\n  pwd->gid = pw.pw_gid;\n\n  uv__free(buf);\n\n  return 0;\n}\n\n\nvoid uv_os_free_passwd(uv_passwd_t* pwd) {\n  if (pwd == NULL)\n    return;\n\n  /*\n    The memory for name, shell, and homedir are allocated in a single\n    uv__malloc() call. The base of the pointer is stored in pwd->username, so\n    that is the field that needs to be freed.\n  */\n  uv__free(pwd->username);\n  pwd->username = NULL;\n  pwd->shell = NULL;\n  pwd->homedir = NULL;\n}\n\n\nint uv_os_get_passwd(uv_passwd_t* pwd) {\n  return uv__getpwuid_r(pwd);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  uv__free(lib->errmsg);\n  lib->errmsg = NULL;\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  const char* errmsg;\n\n  uv__free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = uv__strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv-errno.h\"\n#include \"uv-version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv-win.h\"\n#else\n# include \"uv-unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN const char* uv_err_name(int err);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* active_queue[2];                                                      \\\n  void* reserved[4];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN size_t uv_req_size(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle;\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\n\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s {\n    uint64_t user;\n    uint64_t nice;\n    uint64_t sys;\n    uint64_t idle;\n    uint64_t irq;\n  } cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  void* active_reqs[2];\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/icu-small/source/common/putilimp.h": "/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2015, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putilimp.h\n*\n*   Date        Name        Description\n*   10/17/04    grhoten     Move internal functions from putil.h to this file.\n******************************************************************************\n*/\n\n#ifndef PUTILIMP_H\n#define PUTILIMP_H\n\n#include \"unicode/utypes.h\"\n#include \"unicode/putil.h\"\n\n/**\n * \\def U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC\n * Nearly all CPUs and compilers implement a right-shift of a signed integer\n * as an Arithmetic Shift Right which copies the sign bit (the Most Significant Bit (MSB))\n * into the vacated bits (sign extension).\n * For example, (int32_t)0xfff5fff3>>4 becomes 0xffff5fff and -1>>1=-1.\n *\n * This can be useful for storing a signed value in the upper bits\n * and another bit field in the lower bits.\n * The signed value can be retrieved by simple right-shifting.\n *\n * This is consistent with the Java language.\n *\n * However, the C standard allows compilers to implement a right-shift of a signed integer\n * as a Logical Shift Right which copies a 0 into the vacated bits.\n * For example, (int32_t)0xfff5fff3>>4 becomes 0x0fff5fff and -1>>1=0x7fffffff.\n *\n * Code that depends on the natural behavior should be guarded with this macro,\n * with an alternate path for unusual platforms.\n * @internal\n */\n#ifdef U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC\n    /* Use the predefined value. */\n#else\n    /*\n     * Nearly all CPUs & compilers implement a right-shift of a signed integer\n     * as an Arithmetic Shift Right (with sign extension).\n     */\n#   define U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC 1\n#endif\n\n/** Define this to 1 if your platform supports IEEE 754 floating point,\n   to 0 if it does not. */\n#ifndef IEEE_754\n#   define IEEE_754 1\n#endif\n\n/**\n * uintptr_t is an optional part of the standard definitions in stdint.h.\n * The opengroup.org documentation for stdint.h says\n * \"On XSI-conformant systems, the intptr_t and uintptr_t types are required;\n * otherwise, they are optional.\"\n * We assume that when uintptr_t is defined, UINTPTR_MAX is defined as well.\n *\n * Do not use ptrdiff_t since it is signed. size_t is unsigned.\n */\n/* TODO: This check fails on some z environments. Filed a ticket #9357 for this. */\n#if !defined(__intptr_t_defined) && !defined(UINTPTR_MAX) && (U_PLATFORM != U_PF_OS390)\ntypedef size_t uintptr_t;\n#endif\n\n/**\n * \\def U_HAVE_MSVC_2003_OR_EARLIER\n * Flag for workaround of MSVC 2003 optimization bugs\n * @internal\n */\n#if !defined(U_HAVE_MSVC_2003_OR_EARLIER) && defined(_MSC_VER) && (_MSC_VER < 1400)\n#define U_HAVE_MSVC_2003_OR_EARLIER\n#endif\n\n/*===========================================================================*/\n/** @{ Information about POSIX support                                       */\n/*===========================================================================*/\n\n#ifdef U_HAVE_NL_LANGINFO_CODESET\n    /* Use the predefined value. */\n#elif U_PLATFORM_HAS_WIN32_API || U_PLATFORM == U_PF_ANDROID || U_PLATFORM == U_PF_QNX\n#   define U_HAVE_NL_LANGINFO_CODESET 0\n#else\n#   define U_HAVE_NL_LANGINFO_CODESET 1\n#endif\n\n#ifdef U_NL_LANGINFO_CODESET\n    /* Use the predefined value. */\n#elif !U_HAVE_NL_LANGINFO_CODESET\n#   define U_NL_LANGINFO_CODESET -1\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_NL_LANGINFO_CODESET CODESET\n#endif\n\n#ifdef U_TZSET\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_TZSET _tzset\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_TZSET tzset\n#endif\n\n#if defined(U_TIMEZONE) || defined(U_HAVE_TIMEZONE)\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_ANDROID\n#   define U_TIMEZONE timezone\n#elif U_PLATFORM_IS_LINUX_BASED\n#   if defined(__UCLIBC__)\n       /* uClibc does not have __timezone or _timezone. */\n#   elif defined(_NEWLIB_VERSION)\n#      define U_TIMEZONE      _timezone\n#   elif defined(__GLIBC__)\n       /* glibc */\n#      define U_TIMEZONE      __timezone\n#   endif\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_TIMEZONE _timezone\n#elif U_PLATFORM == U_PF_BSD && !defined(__NetBSD__)\n   /* not defined */\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#elif U_PLATFORM == U_PF_IPHONE\n   /* not defined */\n#else\n#   define U_TIMEZONE timezone\n#endif\n\n#ifdef U_TZNAME\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_TZNAME _tzname\n#elif U_PLATFORM == U_PF_OS400\n   /* not defined */\n#else\n#   define U_TZNAME tzname\n#endif\n\n#ifdef U_HAVE_MMAP\n    /* Use the predefined value. */\n#elif U_PLATFORM_HAS_WIN32_API\n#   define U_HAVE_MMAP 0\n#else\n#   define U_HAVE_MMAP 1\n#endif\n\n#ifdef U_HAVE_POPEN\n    /* Use the predefined value. */\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#   define U_HAVE_POPEN 0\n#elif U_PLATFORM == U_PF_OS400\n#   define U_HAVE_POPEN 0\n#else\n#   define U_HAVE_POPEN 1\n#endif\n\n/**\n * \\def U_HAVE_DIRENT_H\n * Defines whether dirent.h is available.\n * @internal\n */\n#ifdef U_HAVE_DIRENT_H\n    /* Use the predefined value. */\n#elif U_PLATFORM_HAS_WIN32_API\n#   define U_HAVE_DIRENT_H 0\n#else\n#   define U_HAVE_DIRENT_H 1\n#endif\n\n/** @} */\n\n/*===========================================================================*/\n/** @{ GCC built in functions for atomic memory operations                   */\n/*===========================================================================*/\n\n/**\n * \\def U_HAVE_GCC_ATOMICS\n * @internal\n */\n#ifdef U_HAVE_GCC_ATOMICS\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_MINGW\n    #define U_HAVE_GCC_ATOMICS 0\n#elif U_GCC_MAJOR_MINOR >= 404 || defined(__clang__)\n    /* TODO: Intel icc and IBM xlc on AIX also support gcc atomics.  (Intel originated them.)\n     *       Add them for these compilers.\n     * Note: Clang sets __GNUC__ defines for version 4.2, so misses the 4.4 test here.\n     */\n#   define U_HAVE_GCC_ATOMICS 1\n#else\n#   define U_HAVE_GCC_ATOMICS 0\n#endif\n\n/** @} */\n\n/**\n * \\def U_HAVE_STD_ATOMICS\n * Defines whether the standard C++11 <atomic> is available.\n * ICU will use this when avialable,\n * otherwise will fall back to compiler or platform specific alternatives.\n * @internal\n */\n#ifdef U_HAVE_STD_ATOMICS\n    /* Use the predefined value. */\n#elif U_CPLUSPLUS_VERSION < 11\n    /* Not C++11, disable use of atomics */\n#   define U_HAVE_STD_ATOMICS 0\n#elif __clang__ && __clang_major__==3 && __clang_minor__<=1\n    /* Clang 3.1, has atomic variable initializer bug. */\n#   define U_HAVE_STD_ATOMICS 0\n#else\n    /* U_HAVE_ATOMIC is typically set by an autoconf test of #include <atomic>  */\n    /*   Can be set manually, or left undefined, on platforms without autoconf. */\n#   if defined(U_HAVE_ATOMIC) &&  U_HAVE_ATOMIC\n#      define U_HAVE_STD_ATOMICS 1\n#   else\n#      define U_HAVE_STD_ATOMICS 0\n#   endif\n#endif\n\n\n/**\n *  \\def U_HAVE_CLANG_ATOMICS\n *  Defines whether Clang c11 style built-in atomics are avaialable.\n *  These are used in preference to gcc atomics when both are available.\n */\n#ifdef U_HAVE_CLANG_ATOMICS\n    /* Use the predefined value. */\n#elif __has_builtin(__c11_atomic_load) && \\\n    __has_builtin(__c11_atomic_store) && \\\n    __has_builtin(__c11_atomic_fetch_add) && \\\n    __has_builtin(__c11_atomic_fetch_sub)\n#    define U_HAVE_CLANG_ATOMICS 1\n#else\n#    define U_HAVE_CLANG_ATOMICS 0\n#endif\n\n/*===========================================================================*/\n/** @{ Programs used by ICU code                                             */\n/*===========================================================================*/\n\n/**\n * \\def U_MAKE_IS_NMAKE\n * Defines whether the \"make\" program is Windows nmake.\n */\n#ifdef U_MAKE_IS_NMAKE\n    /* Use the predefined value. */\n#elif U_PLATFORM == U_PF_WINDOWS\n#   define U_MAKE_IS_NMAKE 1\n#else\n#   define U_MAKE_IS_NMAKE 0\n#endif\n\n/** @} */\n\n/*==========================================================================*/\n/* Platform utilities                                                       */\n/*==========================================================================*/\n\n/**\n * Platform utilities isolates the platform dependencies of the\n * libarary.  For each platform which this code is ported to, these\n * functions may have to be re-implemented.\n */\n\n/**\n * Floating point utility to determine if a double is Not a Number (NaN).\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isNaN(double d);\n/**\n * Floating point utility to determine if a double has an infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isInfinite(double d);\n/**\n * Floating point utility to determine if a double has a positive infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isPositiveInfinity(double d);\n/**\n * Floating point utility to determine if a double has a negative infinite value.\n * @internal\n */\nU_INTERNAL UBool   U_EXPORT2 uprv_isNegativeInfinity(double d);\n/**\n * Floating point utility that returns a Not a Number (NaN) value.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_getNaN(void);\n/**\n * Floating point utility that returns an infinite value.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_getInfinity(void);\n\n/**\n * Floating point utility to truncate a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_trunc(double d);\n/**\n * Floating point utility to calculate the floor of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_floor(double d);\n/**\n * Floating point utility to calculate the ceiling of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_ceil(double d);\n/**\n * Floating point utility to calculate the absolute value of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fabs(double d);\n/**\n * Floating point utility to calculate the fractional and integer parts of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_modf(double d, double* pinteger);\n/**\n * Floating point utility to calculate the remainder of a double divided by another double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmod(double d, double y);\n/**\n * Floating point utility to calculate d to the power of exponent (d^exponent).\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_pow(double d, double exponent);\n/**\n * Floating point utility to calculate 10 to the power of exponent (10^exponent).\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_pow10(int32_t exponent);\n/**\n * Floating point utility to calculate the maximum value of two doubles.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmax(double d, double y);\n/**\n * Floating point utility to calculate the minimum value of two doubles.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_fmin(double d, double y);\n/**\n * Private utility to calculate the maximum value of two integers.\n * @internal\n */\nU_INTERNAL int32_t U_EXPORT2 uprv_max(int32_t d, int32_t y);\n/**\n * Private utility to calculate the minimum value of two integers.\n * @internal\n */\nU_INTERNAL int32_t U_EXPORT2 uprv_min(int32_t d, int32_t y);\n\n#if U_IS_BIG_ENDIAN\n#   define uprv_isNegative(number) (*((signed char *)&(number))<0)\n#else\n#   define uprv_isNegative(number) (*((signed char *)&(number)+sizeof(number)-1)<0)\n#endif\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_maxMantissa(void);\n\n/**\n * Floating point utility to calculate the logarithm of a double.\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_log(double d);\n\n/**\n * Does common notion of rounding e.g. uprv_floor(x + 0.5);\n * @param x the double number\n * @return the rounded double\n * @internal\n */\nU_INTERNAL double  U_EXPORT2 uprv_round(double x);\n\n#if 0\n/**\n * Returns the number of digits after the decimal point in a double number x.\n *\n * @param x the double number\n * @return the number of digits after the decimal point in a double number x.\n * @internal\n */\n/*U_INTERNAL int32_t  U_EXPORT2 uprv_digitsAfterDecimal(double x);*/\n#endif\n\n#if !U_CHARSET_IS_UTF8\n/**\n * Please use ucnv_getDefaultName() instead.\n * Return the default codepage for this platform and locale.\n * This function can call setlocale() on Unix platforms. Please read the\n * platform documentation on setlocale() before calling this function.\n * @return the default codepage for this platform\n * @internal\n */\nU_INTERNAL const char*  U_EXPORT2 uprv_getDefaultCodepage(void);\n#endif\n\n/**\n * Please use uloc_getDefault() instead.\n * Return the default locale ID string by querying ths system, or\n *     zero if one cannot be found.\n * This function can call setlocale() on Unix platforms. Please read the\n * platform documentation on setlocale() before calling this function.\n * @return the default locale ID string\n * @internal\n */\nU_INTERNAL const char*  U_EXPORT2 uprv_getDefaultLocaleID(void);\n\n/**\n * Time zone utilities\n *\n * Wrappers for C runtime library functions relating to timezones.\n * The t_tzset() function (similar to tzset) uses the current setting\n * of the environment variable TZ to assign values to three global\n * variables: daylight, timezone, and tzname. These variables have the\n * following meanings, and are declared in &lt;time.h&gt;.\n *\n *   daylight   Nonzero if daylight-saving-time zone (DST) is specified\n *              in TZ; otherwise, 0. Default value is 1.\n *   timezone   Difference in seconds between coordinated universal\n *              time and local time. E.g., -28,800 for PST (GMT-8hrs)\n *   tzname(0)  Three-letter time-zone name derived from TZ environment\n *              variable. E.g., \"PST\".\n *   tzname(1)  Three-letter DST zone name derived from TZ environment\n *              variable.  E.g., \"PDT\". If DST zone is omitted from TZ,\n *              tzname(1) is an empty string.\n *\n * Notes: For example, to set the TZ environment variable to correspond\n * to the current time zone in Germany, you can use one of the\n * following statements:\n *\n *   set TZ=GST1GDT\n *   set TZ=GST+1GDT\n *\n * If the TZ value is not set, t_tzset() attempts to use the time zone\n * information specified by the operating system. Under Windows NT\n * and Windows 95, this information is specified in the Control Panel's\n * Date/Time application.\n * @internal\n */\nU_INTERNAL void     U_EXPORT2 uprv_tzset(void);\n\n/**\n * Difference in seconds between coordinated universal\n * time and local time. E.g., -28,800 for PST (GMT-8hrs)\n * @return the difference in seconds between coordinated universal time and local time.\n * @internal\n */\nU_INTERNAL int32_t  U_EXPORT2 uprv_timezone(void);\n\n/**\n *   tzname(0)  Three-letter time-zone name derived from TZ environment\n *              variable. E.g., \"PST\".\n *   tzname(1)  Three-letter DST zone name derived from TZ environment\n *              variable.  E.g., \"PDT\". If DST zone is omitted from TZ,\n *              tzname(1) is an empty string.\n * @internal\n */\nU_INTERNAL const char* U_EXPORT2 uprv_tzname(int n);\n\n/**\n * Get UTC (GMT) time measured in milliseconds since 0:00 on 1/1/1970.\n * This function is affected by 'faketime' and should be the bottleneck for all user-visible ICU time functions.\n * @return the UTC time measured in milliseconds\n * @internal\n */\nU_INTERNAL UDate U_EXPORT2 uprv_getUTCtime(void);\n\n/**\n * Get UTC (GMT) time measured in milliseconds since 0:00 on 1/1/1970.\n * This function is not affected by 'faketime', so it should only be used by low level test functions- not by anything that\n * exposes time to the end user.\n * @return the UTC time measured in milliseconds\n * @internal\n */\nU_INTERNAL UDate U_EXPORT2 uprv_getRawUTCtime(void);\n\n/**\n * Determine whether a pathname is absolute or not, as defined by the platform.\n * @param path Pathname to test\n * @return TRUE if the path is absolute\n * @internal (ICU 3.0)\n */\nU_INTERNAL UBool U_EXPORT2 uprv_pathIsAbsolute(const char *path);\n\n/**\n * Use U_MAX_PTR instead of this function.\n * @param void pointer to test\n * @return the largest possible pointer greater than the base\n * @internal (ICU 3.8)\n */\nU_INTERNAL void * U_EXPORT2 uprv_maximumPtr(void *base);\n\n/**\n * Maximum value of a (void*) - use to indicate the limit of an 'infinite' buffer.\n * In fact, buffer sizes must not exceed 2GB so that the difference between\n * the buffer limit and the buffer start can be expressed in an int32_t.\n *\n * The definition of U_MAX_PTR must fulfill the following conditions:\n * - return the largest possible pointer greater than base\n * - return a valid pointer according to the machine architecture (AS/400, 64-bit, etc.)\n * - avoid wrapping around at high addresses\n * - make sure that the returned pointer is not farther from base than 0x7fffffff bytes\n *\n * @param base The beginning of a buffer to find the maximum offset from\n * @internal\n */\n#ifndef U_MAX_PTR\n#  if U_PLATFORM == U_PF_OS390 && !defined(_LP64)\n    /* We have 31-bit pointers. */\n#    define U_MAX_PTR(base) ((void *)0x7fffffff)\n#  elif U_PLATFORM == U_PF_OS400\n#    define U_MAX_PTR(base) uprv_maximumPtr((void *)base)\n#  elif 0\n    /*\n     * For platforms where pointers are scalar values (which is normal, but unlike i5/OS)\n     * but that do not define uintptr_t.\n     *\n     * However, this does not work on modern compilers:\n     * The C++ standard does not define pointer overflow, and allows compilers to\n     * assume that p+u>p for any pointer p and any integer u>0.\n     * Thus, modern compilers optimize away the \">\" comparison.\n     * (See ICU tickets #7187 and #8096.)\n     */\n#    define U_MAX_PTR(base) \\\n    ((void *)(((char *)(base)+0x7fffffffu) > (char *)(base) \\\n        ? ((char *)(base)+0x7fffffffu) \\\n        : (char *)-1))\n#  else\n    /* Default version. C++ standard compliant for scalar pointers. */\n#    define U_MAX_PTR(base) \\\n    ((void *)(((uintptr_t)(base)+0x7fffffffu) > (uintptr_t)(base) \\\n        ? ((uintptr_t)(base)+0x7fffffffu) \\\n        : (uintptr_t)-1))\n#  endif\n#endif\n\n/*  Dynamic Library Functions */\n\ntypedef void (UVoidFunction)(void);\n\n#if U_ENABLE_DYLOAD\n/**\n * Load a library\n * @internal (ICU 4.4)\n */\nU_INTERNAL void * U_EXPORT2 uprv_dl_open(const char *libName, UErrorCode *status);\n\n/**\n * Close a library\n * @internal (ICU 4.4)\n */\nU_INTERNAL void U_EXPORT2 uprv_dl_close( void *lib, UErrorCode *status);\n\n/**\n * Extract a symbol from a library (function)\n * @internal (ICU 4.8)\n */\nU_INTERNAL UVoidFunction* U_EXPORT2 uprv_dlsym_func( void *lib, const char *symbolName, UErrorCode *status);\n\n/**\n * Extract a symbol from a library (function)\n * Not implemented, no clients.\n * @internal\n */\n/* U_INTERNAL void * U_EXPORT2 uprv_dlsym_data( void *lib, const char *symbolName, UErrorCode *status); */\n\n#endif\n\n/**\n * Define malloc and related functions\n * @internal\n */\n#if U_PLATFORM == U_PF_OS400\n# define uprv_default_malloc(x) _C_TS_malloc(x)\n# define uprv_default_realloc(x,y) _C_TS_realloc(x,y)\n# define uprv_default_free(x) _C_TS_free(x)\n/* also _C_TS_calloc(x) */\n#else\n/* C defaults */\n# define uprv_default_malloc(x) malloc(x)\n# define uprv_default_realloc(x,y) realloc(x,y)\n# define uprv_default_free(x) free(x)\n#endif\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/icu-small/source/common/putil.cpp": "/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2015, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)\n*\n*   Date        Name        Description\n*   04/14/97    aliu        Creation.\n*   04/24/97    aliu        Added getDefaultDataDirectory() and\n*                            getDefaultLocaleID().\n*   04/28/97    aliu        Rewritten to assume Unix and apply general methods\n*                            for assumed case.  Non-UNIX platforms must be\n*                            special-cased.  Rewrote numeric methods dealing\n*                            with NaN and Infinity to be platform independent\n*                             over all IEEE 754 platforms.\n*   05/13/97    aliu        Restored sign of timezone\n*                            (semantics are hours West of GMT)\n*   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,\n*                             nextDouble..\n*   07/22/98    stephen     Added remainder, max, min, trunc\n*   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity\n*   08/24/98    stephen     Added longBitsFromDouble\n*   09/08/98    stephen     Minor changes for Mac Port\n*   03/02/99    stephen     Removed openFile().  Added AS400 support.\n*                            Fixed EBCDIC tables\n*   04/15/99    stephen     Converted to C.\n*   06/28/99    stephen     Removed mutex locking in u_isBigEndian().\n*   08/04/99    jeffrey R.  Added OS/2 changes\n*   11/15/99    helena      Integrated S/390 IEEE support.\n*   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID\n*   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage\n*   01/03/08    Steven L.   Fake Time Support\n******************************************************************************\n*/\n\n// Defines _XOPEN_SOURCE for access to POSIX functions.\n// Must be before any other #includes.\n#include \"uposixdefs.h\"\n\n/* include ICU headers */\n#include \"unicode/utypes.h\"\n#include \"unicode/putil.h\"\n#include \"unicode/ustring.h\"\n#include \"putilimp.h\"\n#include \"uassert.h\"\n#include \"umutex.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"locmap.h\"\n#include \"ucln_cmn.h\"\n#include \"charstr.h\"\n\n/* Include standard headers. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <locale.h>\n#include <float.h>\n\n#ifndef U_COMMON_IMPLEMENTATION\n#error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu\n#endif\n\n\n/* include system headers */\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /*\n     * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.\n     * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)\n     * to use native APIs as much as possible?\n     */\n#   define WIN32_LEAN_AND_MEAN\n#   define VC_EXTRALEAN\n#   define NOUSER\n#   define NOSERVICE\n#   define NOIME\n#   define NOMCX\n#   include <windows.h>\n#   include \"wintz.h\"\n#elif U_PLATFORM == U_PF_OS400\n#   include <float.h>\n#   include <qusec.h>       /* error code structure */\n#   include <qusrjobi.h>\n#   include <qliept.h>      /* EPT_CALL macro  - this include must be after all other \"QSYSINCs\" */\n#   include <mih/testptr.h> /* For uprv_maximumPtr */\n#elif U_PLATFORM == U_PF_OS390\n#   include \"unicode/ucnv.h\"   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */\n#elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS\n#   include <limits.h>\n#   include <unistd.h>\n#   if U_PLATFORM == U_PF_SOLARIS\n#       ifndef _XPG4_2\n#           define _XPG4_2\n#       endif\n#   endif\n#elif U_PLATFORM == U_PF_QNX\n#   include <sys/neutrino.h>\n#endif\n\n#if (U_PF_MINGW <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN) && defined(__STRICT_ANSI__)\n/* tzset isn't defined in strict ANSI on Cygwin and MinGW. */\n#undef __STRICT_ANSI__\n#endif\n\n/*\n * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.\n */\n#include <time.h>\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#include <sys/time.h>\n#endif\n\n/*\n * Only include langinfo.h if we have a way to get the codeset. If we later\n * depend on more feature, we can test on U_HAVE_NL_LANGINFO.\n *\n */\n\n#if U_HAVE_NL_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n/**\n * Simple things (presence of functions, etc) should just go in configure.in and be added to\n * icucfg.h via autoheader.\n */\n#if U_PLATFORM_IMPLEMENTS_POSIX\n#   if U_PLATFORM == U_PF_OS400\n#    define HAVE_DLFCN_H 0\n#    define HAVE_DLOPEN 0\n#   else\n#   ifndef HAVE_DLFCN_H\n#    define HAVE_DLFCN_H 1\n#   endif\n#   ifndef HAVE_DLOPEN\n#    define HAVE_DLOPEN 1\n#   endif\n#   endif\n#   ifndef HAVE_GETTIMEOFDAY\n#    define HAVE_GETTIMEOFDAY 1\n#   endif\n#else\n#   define HAVE_DLFCN_H 0\n#   define HAVE_DLOPEN 0\n#   define HAVE_GETTIMEOFDAY 0\n#endif\n\nU_NAMESPACE_USE\n\n/* Define the extension for data files, again... */\n#define DATA_TYPE \"dat\"\n\n/* Leave this copyright notice here! */\nstatic const char copyright[] = U_COPYRIGHT_STRING;\n\n/* floating point implementations ------------------------------------------- */\n\n/* We return QNAN rather than SNAN*/\n#define SIGN 0x80000000U\n\n/* Make it easy to define certain types of constants */\ntypedef union {\n    int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */\n    double d64;\n} BitPatternConversion;\nstatic const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };\nstatic const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };\n\n/*---------------------------------------------------------------------------\n  Platform utilities\n  Our general strategy is to assume we're on a POSIX platform.  Platforms which\n  are non-POSIX must declare themselves so.  The default POSIX implementation\n  will sometimes work for non-POSIX platforms as well (e.g., the NaN-related\n  functions).\n  ---------------------------------------------------------------------------*/\n\n#if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400\n#   undef U_POSIX_LOCALE\n#else\n#   define U_POSIX_LOCALE    1\n#endif\n\n/*\n    WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble\n    can't be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).\n*/\n#if !IEEE_754\nstatic char*\nu_topNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)d;\n#else\n    return (char*)(d + 1) - n;\n#endif\n}\n\nstatic char*\nu_bottomNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)(d + 1) - n;\n#else\n    return (char*)d;\n#endif\n}\n#endif   /* !IEEE_754 */\n\n#if IEEE_754\nstatic UBool\nu_signBit(double d) {\n    uint8_t hiByte;\n#if U_IS_BIG_ENDIAN\n    hiByte = *(uint8_t *)&d;\n#else\n    hiByte = *(((uint8_t *)&d) + sizeof(double) - 1);\n#endif\n    return (hiByte & 0x80) != 0;\n}\n#endif\n\n\n\n#if defined (U_DEBUG_FAKETIME)\n/* Override the clock to test things without having to move the system clock.\n * Assumes POSIX gettimeofday() will function\n */\nUDate fakeClock_t0 = 0; /** Time to start the clock from **/\nUDate fakeClock_dt = 0; /** Offset (fake time - real time) **/\nUBool fakeClock_set = FALSE; /** True if fake clock has spun up **/\nstatic UMutex fakeClockMutex = U_MUTEX_INTIALIZER;\n\nstatic UDate getUTCtime_real() {\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n}\n\nstatic UDate getUTCtime_fake() {\n    umtx_lock(&fakeClockMutex);\n    if(!fakeClock_set) {\n        UDate real = getUTCtime_real();\n        const char *fake_start = getenv(\"U_FAKETIME_START\");\n        if((fake_start!=NULL) && (fake_start[0]!=0)) {\n            sscanf(fake_start,\"%lf\",&fakeClock_t0);\n            fakeClock_dt = fakeClock_t0 - real;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\\n\"\n                    \"env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\\n\",\n                    fakeClock_t0, fake_start, fakeClock_dt, real);\n        } else {\n          fakeClock_dt = 0;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\\n\"\n                    \"Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\\n\");\n        }\n        fakeClock_set = TRUE;\n    }\n    umtx_unlock(&fakeClockMutex);\n\n    return getUTCtime_real() + fakeClock_dt;\n}\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\ntypedef union {\n    int64_t int64;\n    FILETIME fileTime;\n} FileTimeConversion;   /* This is like a ULARGE_INTEGER */\n\n/* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */\n#define EPOCH_BIAS  INT64_C(116444736000000000)\n#define HECTONANOSECOND_PER_MILLISECOND   10000\n\n#endif\n\n/*---------------------------------------------------------------------------\n  Universal Implementations\n  These are designed to work on all platforms.  Try these, and if they\n  don't work on your platform, then special case your platform with new\n  implementations.\n---------------------------------------------------------------------------*/\n\nU_CAPI UDate U_EXPORT2\nuprv_getUTCtime()\n{\n#if defined(U_DEBUG_FAKETIME)\n    return getUTCtime_fake(); /* Hook for overriding the clock */\n#else\n    return uprv_getRawUTCtime();\n#endif\n}\n\n/* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/\nU_CAPI UDate U_EXPORT2\nuprv_getRawUTCtime()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n\n    FileTimeConversion winTime;\n    GetSystemTimeAsFileTime(&winTime.fileTime);\n    return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);\n#else\n\n#if HAVE_GETTIMEOFDAY\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n#else\n    time_t epochtime;\n    time(&epochtime);\n    return (UDate)epochtime * U_MILLIS_PER_SECOND;\n#endif\n\n#endif\n}\n\n/*-----------------------------------------------------------------------------\n  IEEE 754\n  These methods detect and return NaN and infinity values for doubles\n  conforming to IEEE 754.  Platforms which support this standard include X86,\n  Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.\n  If this doesn't work on your platform, you have non-IEEE floating-point, and\n  will need to code your own versions.  A naive implementation is to return 0.0\n  for getNaN and getInfinity, and false for isNaN and isInfinite.\n  ---------------------------------------------------------------------------*/\n\nU_CAPI UBool U_EXPORT2\nuprv_isNaN(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) > gInf.i64);\n\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits & 0x7F080000L) == 0x7F080000L) &&\n      (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return number != number;\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isInfinite(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is exactly 0x7FF0000000000000U. */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) == gInf.i64);\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits  & ~SIGN) == 0x70FF0000L) && (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return number == (2.0 * number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isPositiveInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number > 0 && uprv_isInfinite(number));\n#else\n    return uprv_isInfinite(number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isNegativeInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number < 0 && uprv_isInfinite(number));\n\n#else\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    return((highBits & SIGN) && uprv_isInfinite(number));\n\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getNaN()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gNan.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getInfinity()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gInf.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_floor(double x)\n{\n    return floor(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_ceil(double x)\n{\n    return ceil(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_round(double x)\n{\n    return uprv_floor(x + 0.5);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fabs(double x)\n{\n    return fabs(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_modf(double x, double* y)\n{\n    return modf(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmod(double x, double y)\n{\n    return fmod(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow(double x, double y)\n{\n    /* This is declared as \"double pow(double x, double y)\" */\n    return pow(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow10(int32_t x)\n{\n    return pow(10.0, (double)x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmax(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(x))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? x : y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmin(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(y))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? y : x);\n}\n\n/**\n * Truncates the given double.\n * trunc(3.3) = 3.0, trunc (-3.3) = -3.0\n * This is different than calling floor() or ceil():\n * floor(3.3) = 3, floor(-3.3) = -4\n * ceil(3.3) = 4, ceil(-3.3) = -3\n */\nU_CAPI double U_EXPORT2\nuprv_trunc(double d)\n{\n#if IEEE_754\n    /* handle error cases*/\n    if(uprv_isNaN(d))\n        return uprv_getNaN();\n    if(uprv_isInfinite(d))\n        return uprv_getInfinity();\n\n    if(u_signBit(d))    /* Signbit() picks up -0.0;  d<0 does not. */\n        return ceil(d);\n    else\n        return floor(d);\n\n#else\n    return d >= 0 ? floor(d) : ceil(d);\n\n#endif\n}\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n */\nU_CAPI double U_EXPORT2\nuprv_maxMantissa(void)\n{\n    return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;\n}\n\nU_CAPI double U_EXPORT2\nuprv_log(double d)\n{\n    return log(d);\n}\n\nU_CAPI void * U_EXPORT2\nuprv_maximumPtr(void * base)\n{\n#if U_PLATFORM == U_PF_OS400\n    /*\n     * With the provided function we should never be out of range of a given segment\n     * (a traditional/typical segment that is).  Our segments have 5 bytes for the\n     * id and 3 bytes for the offset.  The key is that the casting takes care of\n     * only retrieving the offset portion minus x1000.  Hence, the smallest offset\n     * seen in a program is x001000 and when casted to an int would be 0.\n     * That's why we can only add 0xffefff.  Otherwise, we would exceed the segment.\n     *\n     * Currently, 16MB is the current addressing limitation on i5/OS if the activation is\n     * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).\n     * This function determines the activation based on the pointer that is passed in and\n     * calculates the appropriate maximum available size for\n     * each pointer type (TERASPACE and non-TERASPACE)\n     *\n     * Unlike other operating systems, the pointer model isn't determined at\n     * compile time on i5/OS.\n     */\n    if ((base != NULL) && (_TESTPTR(base, _C_TERASPACE_CHECK))) {\n        /* if it is a TERASPACE pointer the max is 2GB - 4k */\n        return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));\n    }\n    /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */\n    return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));\n\n#else\n    return U_MAX_PTR(base);\n#endif\n}\n\n/*---------------------------------------------------------------------------\n  Platform-specific Implementations\n  Try these, and if they don't work on your platform, then special case your\n  platform with new implementations.\n  ---------------------------------------------------------------------------*/\n\n/* Generic time zone layer -------------------------------------------------- */\n\n/* Time zone utilities */\nU_CAPI void U_EXPORT2\nuprv_tzset()\n{\n#if defined(U_TZSET)\n    U_TZSET();\n#else\n    /* no initialization*/\n#endif\n}\n\nU_CAPI int32_t U_EXPORT2\nuprv_timezone()\n{\n#ifdef U_TIMEZONE\n    return U_TIMEZONE;\n#else\n    time_t t, t1, t2;\n    struct tm tmrec;\n    int32_t tdiff = 0;\n\n    time(&t);\n    uprv_memcpy( &tmrec, localtime(&t), sizeof(tmrec) );\n#if U_PLATFORM != U_PF_IPHONE\n    UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/\n#endif\n    t1 = mktime(&tmrec);                 /* local time in seconds*/\n    uprv_memcpy( &tmrec, gmtime(&t), sizeof(tmrec) );\n    t2 = mktime(&tmrec);                 /* GMT (or UTC) in seconds*/\n    tdiff = t2 - t1;\n\n#if U_PLATFORM != U_PF_IPHONE\n    /* imitate NT behaviour, which returns same timezone offset to GMT for\n       winter and summer.\n       This does not work on all platforms. For instance, on glibc on Linux\n       and on Mac OS 10.5, tdiff calculated above remains the same\n       regardless of whether DST is in effect or not. iOS is another\n       platform where this does not work. Linux + glibc and Mac OS 10.5\n       have U_TIMEZONE defined so that this code is not reached.\n    */\n    if (dst_checked)\n        tdiff += 3600;\n#endif\n    return tdiff;\n#endif\n}\n\n/* Note that U_TZNAME does *not* have to be tzname, but if it is,\n   some platforms need to have it declared here. */\n\n#if defined(U_TZNAME) && (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED || (U_PLATFORM == U_PF_CYGWIN && !U_PLATFORM_USES_ONLY_WIN32_API))\n/* RS6000 and others reject char **tzname.  */\nextern U_IMPORT char *U_TZNAME[];\n#endif\n\n#if !UCONFIG_NO_FILE_IO && ((U_PLATFORM_IS_DARWIN_BASED && (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)\n/* These platforms are likely to use Olson timezone IDs. */\n#define CHECK_LOCALTIME_LINK 1\n#if U_PLATFORM_IS_DARWIN_BASED\n#include <tzfile.h>\n#define TZZONEINFO      (TZDIR \"/\")\n#elif U_PLATFORM == U_PF_SOLARIS\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/lib/zoneinfo/\"\n#define TZZONEINFO2     \"../usr/share/lib/zoneinfo/\"\n#define TZ_ENV_CHECK    \"localtime\"\n#else\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/zoneinfo/\"\n#endif\n#if U_HAVE_DIRENT_H\n#define TZFILE_SKIP     \"posixrules\" /* tz file to skip when searching. */\n/* Some Linux distributions have 'localtime' in /usr/share/zoneinfo\n   symlinked to /etc/localtime, which makes searchForTZFile return\n   'localtime' when it's the first match. */\n#define TZFILE_SKIP2    \"localtime\"\n#define SEARCH_TZFILE\n#include <dirent.h>  /* Needed to search through system timezone files */\n#endif\nstatic char gTimeZoneBuffer[PATH_MAX];\nstatic char *gTimeZoneBufferPtr = NULL;\n#endif\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#define isNonDigit(ch) (ch < '0' || '9' < ch)\nstatic UBool isValidOlsonID(const char *id) {\n    int32_t idx = 0;\n\n    /* Determine if this is something like Iceland (Olson ID)\n    or AST4ADT (non-Olson ID) */\n    while (id[idx] && isNonDigit(id[idx]) && id[idx] != ',') {\n        idx++;\n    }\n\n    /* If we went through the whole string, then it might be okay.\n    The timezone is sometimes set to \"CST-7CDT\", \"CST6CDT5,J129,J131/19:30\",\n    \"GRNLNDST3GRNLNDDT\" or similar, so we cannot use it.\n    The rest of the time it could be an Olson ID. George */\n    return (UBool)(id[idx] == 0\n        || uprv_strcmp(id, \"PST8PDT\") == 0\n        || uprv_strcmp(id, \"MST7MDT\") == 0\n        || uprv_strcmp(id, \"CST6CDT\") == 0\n        || uprv_strcmp(id, \"EST5EDT\") == 0);\n}\n\n/* On some Unix-like OS, 'posix' subdirectory in\n   /usr/share/zoneinfo replicates the top-level contents. 'right'\n   subdirectory has the same set of files, but individual files\n   are different from those in the top-level directory or 'posix'\n   because 'right' has files for TAI (Int'l Atomic Time) while 'posix'\n   has files for UTC.\n   When the first match for /etc/localtime is in either of them\n   (usually in posix because 'right' has different file contents),\n   or TZ environment variable points to one of them, createTimeZone\n   fails because, say, 'posix/America/New_York' is not an Olson\n   timezone id ('America/New_York' is). So, we have to skip\n   'posix/' and 'right/' at the beginning. */\nstatic void skipZoneIDPrefix(const char** id) {\n    if (uprv_strncmp(*id, \"posix/\", 6) == 0\n        || uprv_strncmp(*id, \"right/\", 6) == 0)\n    {\n        *id += 6;\n    }\n}\n#endif\n\n#if defined(U_TZNAME) && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)\ntypedef struct OffsetZoneMapping {\n    int32_t offsetSeconds;\n    int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/\n    const char *stdID;\n    const char *dstID;\n    const char *olsonID;\n} OffsetZoneMapping;\n\nenum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };\n\n/*\nThis list tries to disambiguate a set of abbreviated timezone IDs and offsets\nand maps it to an Olson ID.\nBefore adding anything to this list, take a look at\nicu/source/tools/tzcode/tz.alias\nSometimes no daylight savings (0) is important to define due to aliases.\nThis list can be tested with icu/source/test/compat/tzone.pl\nMore values could be added to daylightType to increase precision.\n*/\nstatic const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {\n    {-45900, 2, \"CHAST\", \"CHADT\", \"Pacific/Chatham\"},\n    {-43200, 1, \"PETT\", \"PETST\", \"Asia/Kamchatka\"},\n    {-43200, 2, \"NZST\", \"NZDT\", \"Pacific/Auckland\"},\n    {-43200, 1, \"ANAT\", \"ANAST\", \"Asia/Anadyr\"},\n    {-39600, 1, \"MAGT\", \"MAGST\", \"Asia/Magadan\"},\n    {-37800, 2, \"LHST\", \"LHST\", \"Australia/Lord_Howe\"},\n    {-36000, 2, \"EST\", \"EST\", \"Australia/Sydney\"},\n    {-36000, 1, \"SAKT\", \"SAKST\", \"Asia/Sakhalin\"},\n    {-36000, 1, \"VLAT\", \"VLAST\", \"Asia/Vladivostok\"},\n    {-34200, 2, \"CST\", \"CST\", \"Australia/South\"},\n    {-32400, 1, \"YAKT\", \"YAKST\", \"Asia/Yakutsk\"},\n    {-32400, 1, \"CHOT\", \"CHOST\", \"Asia/Choibalsan\"},\n    {-31500, 2, \"CWST\", \"CWST\", \"Australia/Eucla\"},\n    {-28800, 1, \"IRKT\", \"IRKST\", \"Asia/Irkutsk\"},\n    {-28800, 1, \"ULAT\", \"ULAST\", \"Asia/Ulaanbaatar\"},\n    {-28800, 2, \"WST\", \"WST\", \"Australia/West\"},\n    {-25200, 1, \"HOVT\", \"HOVST\", \"Asia/Hovd\"},\n    {-25200, 1, \"KRAT\", \"KRAST\", \"Asia/Krasnoyarsk\"},\n    {-21600, 1, \"NOVT\", \"NOVST\", \"Asia/Novosibirsk\"},\n    {-21600, 1, \"OMST\", \"OMSST\", \"Asia/Omsk\"},\n    {-18000, 1, \"YEKT\", \"YEKST\", \"Asia/Yekaterinburg\"},\n    {-14400, 1, \"SAMT\", \"SAMST\", \"Europe/Samara\"},\n    {-14400, 1, \"AMT\", \"AMST\", \"Asia/Yerevan\"},\n    {-14400, 1, \"AZT\", \"AZST\", \"Asia/Baku\"},\n    {-10800, 1, \"AST\", \"ADT\", \"Asia/Baghdad\"},\n    {-10800, 1, \"MSK\", \"MSD\", \"Europe/Moscow\"},\n    {-10800, 1, \"VOLT\", \"VOLST\", \"Europe/Volgograd\"},\n    {-7200, 0, \"EET\", \"CEST\", \"Africa/Tripoli\"},\n    {-7200, 1, \"EET\", \"EEST\", \"Europe/Athens\"}, /* Conflicts with Africa/Cairo */\n    {-7200, 1, \"IST\", \"IDT\", \"Asia/Jerusalem\"},\n    {-3600, 0, \"CET\", \"WEST\", \"Africa/Algiers\"},\n    {-3600, 2, \"WAT\", \"WAST\", \"Africa/Windhoek\"},\n    {0, 1, \"GMT\", \"IST\", \"Europe/Dublin\"},\n    {0, 1, \"GMT\", \"BST\", \"Europe/London\"},\n    {0, 0, \"WET\", \"WEST\", \"Africa/Casablanca\"},\n    {0, 0, \"WET\", \"WET\", \"Africa/El_Aaiun\"},\n    {3600, 1, \"AZOT\", \"AZOST\", \"Atlantic/Azores\"},\n    {3600, 1, \"EGT\", \"EGST\", \"America/Scoresbysund\"},\n    {10800, 1, \"PMST\", \"PMDT\", \"America/Miquelon\"},\n    {10800, 2, \"UYT\", \"UYST\", \"America/Montevideo\"},\n    {10800, 1, \"WGT\", \"WGST\", \"America/Godthab\"},\n    {10800, 2, \"BRT\", \"BRST\", \"Brazil/East\"},\n    {12600, 1, \"NST\", \"NDT\", \"America/St_Johns\"},\n    {14400, 1, \"AST\", \"ADT\", \"Canada/Atlantic\"},\n    {14400, 2, \"AMT\", \"AMST\", \"America/Cuiaba\"},\n    {14400, 2, \"CLT\", \"CLST\", \"Chile/Continental\"},\n    {14400, 2, \"FKT\", \"FKST\", \"Atlantic/Stanley\"},\n    {14400, 2, \"PYT\", \"PYST\", \"America/Asuncion\"},\n    {18000, 1, \"CST\", \"CDT\", \"America/Havana\"},\n    {18000, 1, \"EST\", \"EDT\", \"US/Eastern\"}, /* Conflicts with America/Grand_Turk */\n    {21600, 2, \"EAST\", \"EASST\", \"Chile/EasterIsland\"},\n    {21600, 0, \"CST\", \"MDT\", \"Canada/Saskatchewan\"},\n    {21600, 0, \"CST\", \"CDT\", \"America/Guatemala\"},\n    {21600, 1, \"CST\", \"CDT\", \"US/Central\"}, /* Conflicts with Mexico/General */\n    {25200, 1, \"MST\", \"MDT\", \"US/Mountain\"}, /* Conflicts with Mexico/BajaSur */\n    {28800, 0, \"PST\", \"PST\", \"Pacific/Pitcairn\"},\n    {28800, 1, \"PST\", \"PDT\", \"US/Pacific\"}, /* Conflicts with Mexico/BajaNorte */\n    {32400, 1, \"AKST\", \"AKDT\", \"US/Alaska\"},\n    {36000, 1, \"HAST\", \"HADT\", \"US/Aleutian\"}\n};\n\n/*#define DEBUG_TZNAME*/\n\nstatic const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)\n{\n    int32_t idx;\n#ifdef DEBUG_TZNAME\n    fprintf(stderr, \"TZ=%s std=%s dst=%s daylight=%d offset=%d\\n\", getenv(\"TZ\"), stdID, dstID, daylightType, offset);\n#endif\n    for (idx = 0; idx < UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)\n    {\n        if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds\n            && daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)\n        {\n            return OFFSET_ZONE_MAPPINGS[idx].olsonID;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#ifdef SEARCH_TZFILE\n#define MAX_PATH_SIZE PATH_MAX /* Set the limit for the size of the path. */\n#define MAX_READ_SIZE 512\n\ntypedef struct DefaultTZInfo {\n    char* defaultTZBuffer;\n    int64_t defaultTZFileSize;\n    FILE* defaultTZFilePtr;\n    UBool defaultTZstatus;\n    int32_t defaultTZPosition;\n} DefaultTZInfo;\n\n/*\n * This method compares the two files given to see if they are a match.\n * It is currently use to compare two TZ files.\n */\nstatic UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {\n    FILE* file;\n    int64_t sizeFile;\n    int64_t sizeFileLeft;\n    int32_t sizeFileRead;\n    int32_t sizeFileToRead;\n    char bufferFile[MAX_READ_SIZE];\n    UBool result = TRUE;\n\n    if (tzInfo->defaultTZFilePtr == NULL) {\n        tzInfo->defaultTZFilePtr = fopen(defaultTZFileName, \"r\");\n    }\n    file = fopen(TZFileName, \"r\");\n\n    tzInfo->defaultTZPosition = 0; /* reset position to begin search */\n\n    if (file != NULL && tzInfo->defaultTZFilePtr != NULL) {\n        /* First check that the file size are equal. */\n        if (tzInfo->defaultTZFileSize == 0) {\n            fseek(tzInfo->defaultTZFilePtr, 0, SEEK_END);\n            tzInfo->defaultTZFileSize = ftell(tzInfo->defaultTZFilePtr);\n        }\n        fseek(file, 0, SEEK_END);\n        sizeFile = ftell(file);\n        sizeFileLeft = sizeFile;\n\n        if (sizeFile != tzInfo->defaultTZFileSize) {\n            result = FALSE;\n        } else {\n            /* Store the data from the files in seperate buffers and\n             * compare each byte to determine equality.\n             */\n            if (tzInfo->defaultTZBuffer == NULL) {\n                rewind(tzInfo->defaultTZFilePtr);\n                tzInfo->defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo->defaultTZFileSize);\n                sizeFileRead = fread(tzInfo->defaultTZBuffer, 1, tzInfo->defaultTZFileSize, tzInfo->defaultTZFilePtr);\n            }\n            rewind(file);\n            while(sizeFileLeft > 0) {\n                uprv_memset(bufferFile, 0, MAX_READ_SIZE);\n                sizeFileToRead = sizeFileLeft < MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;\n\n                sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);\n                if (memcmp(tzInfo->defaultTZBuffer + tzInfo->defaultTZPosition, bufferFile, sizeFileRead) != 0) {\n                    result = FALSE;\n                    break;\n                }\n                sizeFileLeft -= sizeFileRead;\n                tzInfo->defaultTZPosition += sizeFileRead;\n            }\n        }\n    } else {\n        result = FALSE;\n    }\n\n    if (file != NULL) {\n        fclose(file);\n    }\n\n    return result;\n}\n/*\n * This method recursively traverses the directory given for a matching TZ file and returns the first match.\n */\n/* dirent also lists two entries: \".\" and \"..\" that we can safely ignore. */\n#define SKIP1 \".\"\n#define SKIP2 \"..\"\nstatic char SEARCH_TZFILE_RESULT[MAX_PATH_SIZE] = \"\";\nstatic char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {\n    char curpath[MAX_PATH_SIZE];\n    DIR* dirp = opendir(path);\n    DIR* subDirp = NULL;\n    struct dirent* dirEntry = NULL;\n\n    char* result = NULL;\n    if (dirp == NULL) {\n        return result;\n    }\n\n    /* Save the current path */\n    uprv_memset(curpath, 0, MAX_PATH_SIZE);\n    uprv_strcpy(curpath, path);\n\n    /* Check each entry in the directory. */\n    while((dirEntry = readdir(dirp)) != NULL) {\n        const char* dirName = dirEntry->d_name;\n        if (uprv_strcmp(dirName, SKIP1) != 0 && uprv_strcmp(dirName, SKIP2) != 0) {\n            /* Create a newpath with the new entry to test each entry in the directory. */\n            char newpath[MAX_PATH_SIZE];\n            uprv_strcpy(newpath, curpath);\n            uprv_strcat(newpath, dirName);\n\n            if ((subDirp = opendir(newpath)) != NULL) {\n                /* If this new path is a directory, make a recursive call with the newpath. */\n                closedir(subDirp);\n                uprv_strcat(newpath, \"/\");\n                result = searchForTZFile(newpath, tzInfo);\n                /*\n                 Have to get out here. Otherwise, we'd keep looking\n                 and return the first match in the top-level directory\n                 if there's a match in the top-level. If not, this function\n                 would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().\n                 It worked without this in most cases because we have a fallback of calling\n                 localtime_r to figure out the default timezone.\n                */\n                if (result != NULL)\n                    break;\n            } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 && uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {\n                if(compareBinaryFiles(TZDEFAULT, newpath, tzInfo)) {\n                    const char* zoneid = newpath + (sizeof(TZZONEINFO)) - 1;\n                    skipZoneIDPrefix(&zoneid);\n                    uprv_strcpy(SEARCH_TZFILE_RESULT, zoneid);\n                    result = SEARCH_TZFILE_RESULT;\n                    /* Get out after the first one found. */\n                    break;\n                }\n            }\n        }\n    }\n    closedir(dirp);\n    return result;\n}\n#endif\nU_CAPI const char* U_EXPORT2\nuprv_tzname(int n)\n{\n    const char *tzid = NULL;\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    tzid = uprv_detectWindowsTimeZone();\n\n    if (tzid != NULL) {\n        return tzid;\n    }\n#else\n\n/*#if U_PLATFORM_IS_DARWIN_BASED\n    int ret;\n\n    tzid = getenv(\"TZFILE\");\n    if (tzid != NULL) {\n        return tzid;\n    }\n#endif*/\n\n/* This code can be temporarily disabled to test tzname resolution later on. */\n#ifndef DEBUG_TZNAME\n    tzid = getenv(\"TZ\");\n    if (tzid != NULL && isValidOlsonID(tzid)\n#if U_PLATFORM == U_PF_SOLARIS\n    /* When TZ equals localtime on Solaris, check the /etc/localtime file. */\n        && uprv_strcmp(tzid, TZ_ENV_CHECK) != 0\n#endif\n    ) {\n        /* The colon forces tzset() to treat the remainder as zoneinfo path */\n        if (tzid[0] == ':') {\n            tzid++;\n        }\n        /* This might be a good Olson ID. */\n        skipZoneIDPrefix(&tzid);\n        return tzid;\n    }\n    /* else U_TZNAME will give a better result. */\n#endif\n\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    /* Caller must handle threading issues */\n    if (gTimeZoneBufferPtr == NULL) {\n        /*\n        This is a trick to look at the name of the link to get the Olson ID\n        because the tzfile contents is underspecified.\n        This isn't guaranteed to work because it may not be a symlink.\n        */\n        int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer));\n        if (0 < ret) {\n            int32_t tzZoneInfoLen = uprv_strlen(TZZONEINFO);\n            gTimeZoneBuffer[ret] = 0;\n            if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO, tzZoneInfoLen) == 0\n                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n            {\n                return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n            }\n#if U_PLATFORM == U_PF_SOLARIS\n            else\n            {\n                tzZoneInfoLen = uprv_strlen(TZZONEINFO2);\n                if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO2, tzZoneInfoLen) == 0\n                                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n                {\n                    return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n                }\n            }\n#endif\n        } else {\n#if defined(SEARCH_TZFILE)\n            DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));\n            if (tzInfo != NULL) {\n                tzInfo->defaultTZBuffer = NULL;\n                tzInfo->defaultTZFileSize = 0;\n                tzInfo->defaultTZFilePtr = NULL;\n                tzInfo->defaultTZstatus = FALSE;\n                tzInfo->defaultTZPosition = 0;\n\n                gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);\n\n                /* Free previously allocated memory */\n                if (tzInfo->defaultTZBuffer != NULL) {\n                    uprv_free(tzInfo->defaultTZBuffer);\n                }\n                if (tzInfo->defaultTZFilePtr != NULL) {\n                    fclose(tzInfo->defaultTZFilePtr);\n                }\n                uprv_free(tzInfo);\n            }\n\n            if (gTimeZoneBufferPtr != NULL && isValidOlsonID(gTimeZoneBufferPtr)) {\n                return gTimeZoneBufferPtr;\n            }\n#endif\n        }\n    }\n    else {\n        return gTimeZoneBufferPtr;\n    }\n#endif\n#endif\n\n#ifdef U_TZNAME\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /* The return value is free'd in timezone.cpp on Windows because\n     * the other code path returns a pointer to a heap location. */\n    return uprv_strdup(U_TZNAME[n]);\n#else\n    /*\n    U_TZNAME is usually a non-unique abbreviation, which isn't normally usable.\n    So we remap the abbreviation to an olson ID.\n\n    Since Windows exposes a little more timezone information,\n    we normally don't use this code on Windows because\n    uprv_detectWindowsTimeZone should have already given the correct answer.\n    */\n    {\n        struct tm juneSol, decemberSol;\n        int daylightType;\n        static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/\n        static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/\n\n        /* This probing will tell us when daylight savings occurs.  */\n        localtime_r(&juneSolstice, &juneSol);\n        localtime_r(&decemberSolstice, &decemberSol);\n        if(decemberSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_DECEMBER;\n        } else if(juneSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_JUNE;\n        } else {\n          daylightType = U_DAYLIGHT_NONE;\n        }\n        tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());\n        if (tzid != NULL) {\n            return tzid;\n        }\n    }\n    return U_TZNAME[n];\n#endif\n#else\n    return \"\";\n#endif\n}\n\n/* Get and set the ICU data directory --------------------------------------- */\n\nstatic icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;\nstatic char *gDataDirectory = NULL;\n\nUInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;\nstatic CharString *gTimeZoneFilesDirectory = NULL;\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n static char *gCorrectedPOSIXLocale = NULL; /* Heap allocated */\n#endif\n\nstatic UBool U_CALLCONV putil_cleanup(void)\n{\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = NULL;\n    gDataDirInitOnce.reset();\n\n    delete gTimeZoneFilesDirectory;\n    gTimeZoneFilesDirectory = NULL;\n    gTimeZoneFilesInitOnce.reset();\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n    if (gCorrectedPOSIXLocale) {\n        uprv_free(gCorrectedPOSIXLocale);\n        gCorrectedPOSIXLocale = NULL;\n    }\n#endif\n    return TRUE;\n}\n\n/*\n * Set the data directory.\n *    Make a copy of the passed string, and set the global data dir to point to it.\n */\nU_CAPI void U_EXPORT2\nu_setDataDirectory(const char *directory) {\n    char *newDataDir;\n    int32_t length;\n\n    if(directory==NULL || *directory==0) {\n        /* A small optimization to prevent the malloc and copy when the\n        shared library is used, and this is a way to make sure that NULL\n        is never returned.\n        */\n        newDataDir = (char *)\"\";\n    }\n    else {\n        length=(int32_t)uprv_strlen(directory);\n        newDataDir = (char *)uprv_malloc(length + 2);\n        /* Exit out if newDataDir could not be created. */\n        if (newDataDir == NULL) {\n            return;\n        }\n        uprv_strcpy(newDataDir, directory);\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n        {\n            char *p;\n            while(p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) {\n                *p = U_FILE_SEP_CHAR;\n            }\n        }\n#endif\n    }\n\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = newDataDir;\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_pathIsAbsolute(const char *path)\n{\n  if(!path || !*path) {\n    return FALSE;\n  }\n\n  if(*path == U_FILE_SEP_CHAR) {\n    return TRUE;\n  }\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n  if(*path == U_FILE_ALT_SEP_CHAR) {\n    return TRUE;\n  }\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\n  if( (((path[0] >= 'A') && (path[0] <= 'Z')) ||\n       ((path[0] >= 'a') && (path[0] <= 'z'))) &&\n      path[1] == ':' ) {\n    return TRUE;\n  }\n#endif\n\n  return FALSE;\n}\n\n/* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR\n   until some client wrapper makefiles are updated */\n#if U_PLATFORM_IS_DARWIN_BASED && TARGET_IPHONE_SIMULATOR\n# if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n#  define ICU_DATA_DIR_PREFIX_ENV_VAR \"IPHONE_SIMULATOR_ROOT\"\n# endif\n#endif\n\nstatic void U_CALLCONV dataDirectoryInitFn() {\n    /* If we already have the directory, then return immediately. Will happen if user called\n     * u_setDataDirectory().\n     */\n    if (gDataDirectory) {\n        return;\n    }\n\n    const char *path = NULL;\n#if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n    char datadir_path_buffer[PATH_MAX];\n#endif\n\n    /*\n    When ICU_NO_USER_DATA_OVERRIDE is defined, users aren't allowed to\n    override ICU's data with the ICU_DATA environment variable. This prevents\n    problems where multiple custom copies of ICU's specific version of data\n    are installed on a system. Either the application must define the data\n    directory with u_setDataDirectory, define ICU_DATA_DIR when compiling\n    ICU, set the data with udata_setCommonData or trust that all of the\n    required data is contained in ICU's data library that contains\n    the entry point defined by U_ICUDATA_ENTRY_POINT.\n\n    There may also be some platforms where environment variables\n    are not allowed.\n    */\n#   if !defined(ICU_NO_USER_DATA_OVERRIDE) && !UCONFIG_NO_FILE_IO\n    /* First try to get the environment variable */\n    path=getenv(\"ICU_DATA\");\n#   endif\n\n    /* ICU_DATA_DIR may be set as a compile option.\n     * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time\n     * and is used only when data is built in archive mode eliminating the need\n     * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation\n     * directory of the data dat file. Users should use ICU_DATA_DIR if they want to\n     * set their own path.\n     */\n#if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)\n    if(path==NULL || *path==0) {\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);\n# endif\n# ifdef ICU_DATA_DIR\n        path=ICU_DATA_DIR;\n# else\n        path=U_ICU_DATA_DEFAULT_DIR;\n# endif\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        if (prefix != NULL) {\n            snprintf(datadir_path_buffer, PATH_MAX, \"%s%s\", prefix, path);\n            path=datadir_path_buffer;\n        }\n# endif\n    }\n#endif\n\n    if(path==NULL) {\n        /* It looks really bad, set it to something. */\n        path = \"\";\n    }\n\n    u_setDataDirectory(path);\n    return;\n}\n\nU_CAPI const char * U_EXPORT2\nu_getDataDirectory(void) {\n    umtx_initOnce(gDataDirInitOnce, &dataDirectoryInitFn);\n    return gDataDirectory;\n}\n\nstatic void setTimeZoneFilesDir(const char *path, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    gTimeZoneFilesDirectory->clear();\n    gTimeZoneFilesDirectory->append(path, status);\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n    char *p = gTimeZoneFilesDirectory->data();\n    while (p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) {\n        *p = U_FILE_SEP_CHAR;\n    }\n#endif\n}\n\n#define TO_STRING(x) TO_STRING_2(x)\n#define TO_STRING_2(x) #x\n\nstatic void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &status) {\n    U_ASSERT(gTimeZoneFilesDirectory == NULL);\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    gTimeZoneFilesDirectory = new CharString();\n    if (gTimeZoneFilesDirectory == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return;\n    }\n    const char *dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n#if defined(U_TIMEZONE_FILES_DIR)\n    if (dir == NULL) {\n        dir = TO_STRING(U_TIMEZONE_FILES_DIR);\n    }\n#endif\n    if (dir == NULL) {\n        dir = \"\";\n    }\n    setTimeZoneFilesDir(dir, status);\n}\n\n\nU_CAPI const char * U_EXPORT2\nu_getTimeZoneFilesDirectory(UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    return U_SUCCESS(*status) ? gTimeZoneFilesDirectory->data() : \"\";\n}\n\nU_CAPI void U_EXPORT2\nu_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    setTimeZoneFilesDir(path, *status);\n\n    // Note: this function does some extra churn, first setting based on the\n    //       environment, then immediately replacing with the value passed in.\n    //       The logic is simpler that way, and performance shouldn't be an issue.\n}\n\n\n#if U_POSIX_LOCALE\n/* A helper function used by uprv_getPOSIXIDForDefaultLocale and\n * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for\n * LC_CTYPE and LC_MESSAGES. It doesn't support other locale categories.\n */\nstatic const char *uprv_getPOSIXIDForCategory(int category)\n{\n    const char* posixID = NULL;\n    if (category == LC_MESSAGES || category == LC_CTYPE) {\n        /*\n        * On Solaris two different calls to setlocale can result in\n        * different values. Only get this value once.\n        *\n        * We must check this first because an application can set this.\n        *\n        * LC_ALL can't be used because it's platform dependent. The LANG\n        * environment variable seems to affect LC_CTYPE variable by default.\n        * Here is what setlocale(LC_ALL, NULL) can return.\n        * HPUX can return 'C C C C C C C'\n        * Solaris can return /en_US/C/C/C/C/C on the second try.\n        * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...\n        *\n        * The default codepage detection also needs to use LC_CTYPE.\n        *\n        * Do not call setlocale(LC_*, \"\")! Using an empty string instead\n        * of NULL, will modify the libc behavior.\n        */\n        posixID = setlocale(category, NULL);\n        if ((posixID == 0)\n            || (uprv_strcmp(\"C\", posixID) == 0)\n            || (uprv_strcmp(\"POSIX\", posixID) == 0))\n        {\n            /* Maybe we got some garbage.  Try something more reasonable */\n            posixID = getenv(\"LC_ALL\");\n            /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008\n             * This is needed to properly handle empty env. variables\n             */\n#if U_PLATFORM == U_PF_SOLARIS\n            if ((posixID == 0) || (posixID[0] == '\\0')) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if ((posixID == 0) || (posixID[0] == '\\0')) {\n#else\n            if (posixID == 0) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if (posixID == 0) {\n#endif\n                    posixID = getenv(\"LANG\");\n                }\n            }\n        }\n    }\n    if ((posixID==0)\n        || (uprv_strcmp(\"C\", posixID) == 0)\n        || (uprv_strcmp(\"POSIX\", posixID) == 0))\n    {\n        /* Nothing worked.  Give it a nice POSIX default value. */\n        posixID = \"en_US_POSIX\";\n    }\n    return posixID;\n}\n\n/* Return just the POSIX id for the default locale, whatever happens to be in\n * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultLocale(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);\n    }\n    return posixID;\n}\n\n#if !U_CHARSET_IS_UTF8\n/* Return just the POSIX id for the default codepage, whatever happens to be in\n * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultCodepage(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);\n    }\n    return posixID;\n}\n#endif\n#endif\n\n/* NOTE: The caller should handle thread safety */\nU_CAPI const char* U_EXPORT2\nuprv_getDefaultLocaleID()\n{\n#if U_POSIX_LOCALE\n/*\n  Note that:  (a '!' means the ID is improper somehow)\n     LC_ALL  ---->     default_loc          codepage\n--------------------------------------------------------\n     ab.CD             ab                   CD\n     ab@CD             ab__CD               -\n     ab@CD.EF          ab__CD               EF\n\n     ab_CD.EF@GH       ab_CD_GH             EF\n\nSome 'improper' ways to do the same as above:\n  !  ab_CD@GH.EF       ab_CD_GH             EF\n  !  ab_CD.EF@GH.IJ    ab_CD_GH             EF\n  !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF\n\n     _CD@GH            _CD_GH               -\n     _CD.EF@GH         _CD_GH               EF\n\nThe variant cannot have dots in it.\nThe 'rightmost' variant (@xxx) wins.\nThe leftmost codepage (.xxx) wins.\n*/\n    char *correctedPOSIXLocale = 0;\n    const char* posixID = uprv_getPOSIXIDForDefaultLocale();\n    const char *p;\n    const char *q;\n    int32_t len;\n\n    /* Format: (no spaces)\n    ll [ _CC ] [ . MM ] [ @ VV]\n\n      l = lang, C = ctry, M = charmap, V = variant\n    */\n\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    if ((p = uprv_strchr(posixID, '.')) != NULL) {\n        /* assume new locale can't be larger than old one? */\n        correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n        correctedPOSIXLocale[p-posixID] = 0;\n\n        /* do not copy after the @ */\n        if ((p = uprv_strchr(correctedPOSIXLocale, '@')) != NULL) {\n            correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;\n        }\n    }\n\n    /* Note that we scan the *uncorrected* ID. */\n    if ((p = uprv_strrchr(posixID, '@')) != NULL) {\n        if (correctedPOSIXLocale == NULL) {\n            correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n            /* Exit on memory allocation error. */\n            if (correctedPOSIXLocale == NULL) {\n                return NULL;\n            }\n            uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n            correctedPOSIXLocale[p-posixID] = 0;\n        }\n        p++;\n\n        /* Take care of any special cases here.. */\n        if (!uprv_strcmp(p, \"nynorsk\")) {\n            p = \"NY\";\n            /* Don't worry about no__NY. In practice, it won't appear. */\n        }\n\n        if (uprv_strchr(correctedPOSIXLocale,'_') == NULL) {\n            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b */\n        }\n        else {\n            uprv_strcat(correctedPOSIXLocale, \"_\"); /* aa_CC@b -> aa_CC_b */\n        }\n\n        if ((q = uprv_strchr(p, '.')) != NULL) {\n            /* How big will the resulting string be? */\n            len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));\n            uprv_strncat(correctedPOSIXLocale, p, q-p);\n            correctedPOSIXLocale[len] = 0;\n        }\n        else {\n            /* Anything following the @ sign */\n            uprv_strcat(correctedPOSIXLocale, p);\n        }\n\n        /* Should there be a map from 'no@nynorsk' -> no_NO_NY here?\n         * How about 'russian' -> 'ru'?\n         * Many of the other locales using ISO codes will be handled by the\n         * canonicalization functions in uloc_getDefault.\n         */\n    }\n\n    /* Was a correction made? */\n    if (correctedPOSIXLocale != NULL) {\n        posixID = correctedPOSIXLocale;\n    }\n    else {\n        /* copy it, just in case the original pointer goes away.  See j2395 */\n        correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        posixID = uprv_strcpy(correctedPOSIXLocale, posixID);\n    }\n\n    if (gCorrectedPOSIXLocale == NULL) {\n        gCorrectedPOSIXLocale = correctedPOSIXLocale;\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n        correctedPOSIXLocale = NULL;\n    }\n\n    if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */\n        uprv_free(correctedPOSIXLocale);\n    }\n\n    return posixID;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#define POSIX_LOCALE_CAPACITY 64\n    UErrorCode status = U_ZERO_ERROR;\n    char *correctedPOSIXLocale = 0;\n\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    LCID id = GetThreadLocale();\n    correctedPOSIXLocale = static_cast<char *>(uprv_malloc(POSIX_LOCALE_CAPACITY + 1));\n    if (correctedPOSIXLocale) {\n        int32_t posixLen = uprv_convertToPosix(id, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &status);\n        if (U_SUCCESS(status)) {\n            *(correctedPOSIXLocale + posixLen) = 0;\n            gCorrectedPOSIXLocale = correctedPOSIXLocale;\n            ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n        } else {\n            uprv_free(correctedPOSIXLocale);\n        }\n    }\n\n    if (gCorrectedPOSIXLocale == NULL) {\n        return \"en_US\";\n    }\n    return gCorrectedPOSIXLocale;\n\n#elif U_PLATFORM == U_PF_OS400\n    /* locales are process scoped and are by definition thread safe */\n    static char correctedLocale[64];\n    const  char *localeID = getenv(\"LC_ALL\");\n           char *p;\n\n    if (localeID == NULL)\n        localeID = getenv(\"LANG\");\n    if (localeID == NULL)\n        localeID = setlocale(LC_ALL, NULL);\n    /* Make sure we have something... */\n    if (localeID == NULL)\n        return \"en_US_POSIX\";\n\n    /* Extract the locale name from the path. */\n    if((p = uprv_strrchr(localeID, '/')) != NULL)\n    {\n        /* Increment p to start of locale name. */\n        p++;\n        localeID = p;\n    }\n\n    /* Copy to work location. */\n    uprv_strcpy(correctedLocale, localeID);\n\n    /* Strip off the '.locale' extension. */\n    if((p = uprv_strchr(correctedLocale, '.')) != NULL) {\n        *p = 0;\n    }\n\n    /* Upper case the locale name. */\n    T_CString_toUpperCase(correctedLocale);\n\n    /* See if we are using the POSIX locale.  Any of the\n    * following are equivalent and use the same QLGPGCMA\n    * (POSIX) locale.\n    * QLGPGCMA2 means UCS2\n    * QLGPGCMA_4 means UTF-32\n    * QLGPGCMA_8 means UTF-8\n    */\n    if ((uprv_strcmp(\"C\", correctedLocale) == 0) ||\n        (uprv_strcmp(\"POSIX\", correctedLocale) == 0) ||\n        (uprv_strncmp(\"QLGPGCMA\", correctedLocale, 8) == 0))\n    {\n        uprv_strcpy(correctedLocale, \"en_US_POSIX\");\n    }\n    else\n    {\n        int16_t LocaleLen;\n\n        /* Lower case the lang portion. */\n        for(p = correctedLocale; *p != 0 && *p != '_'; p++)\n        {\n            *p = uprv_tolower(*p);\n        }\n\n        /* Adjust for Euro.  After '_E' add 'URO'. */\n        LocaleLen = uprv_strlen(correctedLocale);\n        if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'E')\n        {\n            uprv_strcat(correctedLocale, \"URO\");\n        }\n\n        /* If using Lotus-based locale then convert to\n         * equivalent non Lotus.\n         */\n        else if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'L')\n        {\n            correctedLocale[LocaleLen - 2] = 0;\n        }\n\n        /* There are separate simplified and traditional\n         * locales called zh_HK_S and zh_HK_T.\n         */\n        else if (uprv_strncmp(correctedLocale, \"zh_HK\", 5) == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_HK\");\n        }\n\n        /* A special zh_CN_GBK locale...\n        */\n        else if (uprv_strcmp(correctedLocale, \"zh_CN_GBK\") == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_CN\");\n        }\n\n    }\n\n    return correctedLocale;\n#endif\n\n}\n\n#if !U_CHARSET_IS_UTF8\n#if U_POSIX_LOCALE\n/*\nDue to various platform differences, one platform may specify a charset,\nwhen they really mean a different charset. Remap the names so that they are\ncompatible with ICU. Only conflicting/ambiguous aliases should be resolved\nhere. Before adding anything to this function, please consider adding unique\nnames to the ICU alias table in the data directory.\n*/\nstatic const char*\nremapPlatformDependentCodepage(const char *locale, const char *name) {\n    if (locale != NULL && *locale == 0) {\n        /* Make sure that an empty locale is handled the same way. */\n        locale = NULL;\n    }\n    if (name == NULL) {\n        return NULL;\n    }\n#if U_PLATFORM == U_PF_AIX\n    if (uprv_strcmp(name, \"IBM-943\") == 0) {\n        /* Use the ASCII compatible ibm-943 */\n        name = \"Shift-JIS\";\n    }\n    else if (uprv_strcmp(name, \"IBM-1252\") == 0) {\n        /* Use the windows-1252 that contains the Euro */\n        name = \"IBM-5348\";\n    }\n#elif U_PLATFORM == U_PF_SOLARIS\n    if (locale != NULL && uprv_strcmp(name, \"EUC\") == 0) {\n        /* Solaris underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"zh_CN\") == 0) {\n            name = \"EUC-CN\";\n        }\n        else if (uprv_strcmp(locale, \"zh_TW\") == 0) {\n            name = \"EUC-TW\";\n        }\n        else if (uprv_strcmp(locale, \"ko_KR\") == 0) {\n            name = \"EUC-KR\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-954 is the best match.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (uprv_strcmp(name, \"646\") == 0) {\n        /*\n         * The default codepage given by Solaris is 646 but the C library routines treat it as if it was\n         * ISO-8859-1 instead of US-ASCII(646).\n         */\n        name = \"ISO-8859-1\";\n    }\n#elif U_PLATFORM_IS_DARWIN_BASED\n    if (locale == NULL && *name == 0) {\n        /*\n        No locale was specified, and an empty name was passed in.\n        This usually indicates that nl_langinfo didn't return valid information.\n        Mac OS X uses UTF-8 by default (especially the locale data and console).\n        */\n        name = \"UTF-8\";\n    }\n    else if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 && uprv_strcmp(name, \"US-ASCII\") == 0) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n#elif U_PLATFORM == U_PF_BSD\n    if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n#elif U_PLATFORM == U_PF_HPUX\n    if (locale != NULL && uprv_strcmp(locale, \"zh_HK\") == 0 && uprv_strcmp(name, \"big5\") == 0) {\n        /* HP decided to extend big5 as hkbig5 even though it's not compatible :-( */\n        /* zh_TW.big5 is not the same charset as zh_HK.big5! */\n        name = \"hkbig5\";\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n#elif U_PLATFORM == U_PF_LINUX\n    if (locale != NULL && uprv_strcmp(name, \"euc\") == 0) {\n        /* Linux underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"korean\") == 0) {\n            name = \"EUC-KR\";\n        }\n        else if (uprv_strcmp(locale, \"japanese\") == 0) {\n            /* See comment below about eucJP */\n            name = \"eucjis\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucjp\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 &&\n            (uprv_strcmp(name, \"ANSI_X3.4-1968\") == 0 || uprv_strcmp(name, \"US-ASCII\") == 0)) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n    /*\n     * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of\n     * it by falling back to 'US-ASCII' when NULL is returned from this\n     * function. So, we don't have to worry about it here.\n     */\n#endif\n    /* return NULL when \"\" is passed in */\n    if (*name == 0) {\n        name = NULL;\n    }\n    return name;\n}\n\nstatic const char*\ngetCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)\n{\n    char localeBuf[100];\n    const char *name = NULL;\n    char *variant = NULL;\n\n    if (localeName != NULL && (name = (uprv_strchr(localeName, '.'))) != NULL) {\n        size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);\n        uprv_strncpy(localeBuf, localeName, localeCapacity);\n        localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */\n        name = uprv_strncpy(buffer, name+1, buffCapacity);\n        buffer[buffCapacity-1] = 0; /* ensure NULL termination */\n        if ((variant = const_cast<char *>(uprv_strchr(name, '@'))) != NULL) {\n            *variant = 0;\n        }\n        name = remapPlatformDependentCodepage(localeBuf, name);\n    }\n    return name;\n}\n#endif\n\nstatic const char*\nint_getDefaultCodepage()\n{\n#if U_PLATFORM == U_PF_OS400\n    uint32_t ccsid = 37; /* Default to ibm-37 */\n    static char codepage[64];\n    Qwc_JOBI0400_t jobinfo;\n    Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */\n\n    EPT_CALL(QUSRJOBI)(&jobinfo, sizeof(jobinfo), \"JOBI0400\",\n        \"*                         \", \"                \", &error);\n\n    if (error.Bytes_Available == 0) {\n        if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;\n        }\n        else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;\n        }\n        /* else use the default */\n    }\n    sprintf(codepage,\"ibm-%d\", ccsid);\n    return codepage;\n\n#elif U_PLATFORM == U_PF_OS390\n    static char codepage[64];\n\n    strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));\n    strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);\n    codepage[63] = 0; /* NULL terminate */\n\n    return codepage;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    static char codepage[64];\n    sprintf(codepage, \"windows-%d\", GetACP());\n    return codepage;\n\n#elif U_POSIX_LOCALE\n    static char codesetName[100];\n    const char *localeName = NULL;\n    const char *name = NULL;\n\n    localeName = uprv_getPOSIXIDForDefaultCodepage();\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    /* On Solaris nl_langinfo returns C locale values unless setlocale\n     * was called earlier.\n     */\n#if (U_HAVE_NL_LANGINFO_CODESET && U_PLATFORM != U_PF_SOLARIS)\n    /* When available, check nl_langinfo first because it usually gives more\n       useful names. It depends on LC_CTYPE.\n       nl_langinfo may use the same buffer as setlocale. */\n    {\n        const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);\n#if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED\n        /*\n         * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8\n         * instead of ASCII.\n         */\n        if (uprv_strcmp(localeName, \"en_US_POSIX\") != 0) {\n            codeset = remapPlatformDependentCodepage(localeName, codeset);\n        } else\n#endif\n        {\n            codeset = remapPlatformDependentCodepage(NULL, codeset);\n        }\n\n        if (codeset != NULL) {\n            uprv_strncpy(codesetName, codeset, sizeof(codesetName));\n            codesetName[sizeof(codesetName)-1] = 0;\n            return codesetName;\n        }\n    }\n#endif\n\n    /* Use setlocale in a nice way, and then check some environment variables.\n       Maybe the application used setlocale already.\n    */\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));\n    if (name) {\n        /* if we can find the codeset name from setlocale, return that. */\n        return name;\n    }\n\n    if (*codesetName == 0)\n    {\n        /* Everything failed. Return US ASCII (ISO 646). */\n        (void)uprv_strcpy(codesetName, \"US-ASCII\");\n    }\n    return codesetName;\n#else\n    return \"US-ASCII\";\n#endif\n}\n\n\nU_CAPI const char*  U_EXPORT2\nuprv_getDefaultCodepage()\n{\n    static char const  *name = NULL;\n    umtx_lock(NULL);\n    if (name == NULL) {\n        name = int_getDefaultCodepage();\n    }\n    umtx_unlock(NULL);\n    return name;\n}\n#endif  /* !U_CHARSET_IS_UTF8 */\n\n\n/* end of platform-specific implementation -------------- */\n\n/* version handling --------------------------------------------------------- */\n\nU_CAPI void U_EXPORT2\nu_versionFromString(UVersionInfo versionArray, const char *versionString) {\n    char *end;\n    uint16_t part=0;\n\n    if(versionArray==NULL) {\n        return;\n    }\n\n    if(versionString!=NULL) {\n        for(;;) {\n            versionArray[part]=(uint8_t)uprv_strtoul(versionString, &end, 10);\n            if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {\n                break;\n            }\n            versionString=end+1;\n        }\n    }\n\n    while(part<U_MAX_VERSION_LENGTH) {\n        versionArray[part++]=0;\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {\n    if(versionArray!=NULL && versionString!=NULL) {\n        char versionChars[U_MAX_VERSION_STRING_LENGTH+1];\n        int32_t len = u_strlen(versionString);\n        if(len>U_MAX_VERSION_STRING_LENGTH) {\n            len = U_MAX_VERSION_STRING_LENGTH;\n        }\n        u_UCharsToChars(versionString, versionChars, len);\n        versionChars[len]=0;\n        u_versionFromString(versionArray, versionChars);\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionToString(const UVersionInfo versionArray, char *versionString) {\n    uint16_t count, part;\n    uint8_t field;\n\n    if(versionString==NULL) {\n        return;\n    }\n\n    if(versionArray==NULL) {\n        versionString[0]=0;\n        return;\n    }\n\n    /* count how many fields need to be written */\n    for(count=4; count>0 && versionArray[count-1]==0; --count) {\n    }\n\n    if(count <= 1) {\n        count = 2;\n    }\n\n    /* write the first part */\n    /* write the decimal field value */\n    field=versionArray[0];\n    if(field>=100) {\n        *versionString++=(char)('0'+field/100);\n        field%=100;\n    }\n    if(field>=10) {\n        *versionString++=(char)('0'+field/10);\n        field%=10;\n    }\n    *versionString++=(char)('0'+field);\n\n    /* write the following parts */\n    for(part=1; part<count; ++part) {\n        /* write a dot first */\n        *versionString++=U_VERSION_DELIMITER;\n\n        /* write the decimal field value */\n        field=versionArray[part];\n        if(field>=100) {\n            *versionString++=(char)('0'+field/100);\n            field%=100;\n        }\n        if(field>=10) {\n            *versionString++=(char)('0'+field/10);\n            field%=10;\n        }\n        *versionString++=(char)('0'+field);\n    }\n\n    /* NUL-terminate */\n    *versionString=0;\n}\n\nU_CAPI void U_EXPORT2\nu_getVersion(UVersionInfo versionArray) {\n    (void)copyright;   // Suppress unused variable warning from clang.\n    u_versionFromString(versionArray, U_ICU_VERSION);\n}\n\n/**\n * icucfg.h dependent code\n */\n\n#if U_ENABLE_DYLOAD\n\n#if HAVE_DLOPEN && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#if HAVE_DLFCN_H\n\n#ifdef __MVS__\n#ifndef __SUSV3\n#define __SUSV3 1\n#endif\n#endif\n#include <dlfcn.h>\n#endif\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  void *ret = NULL;\n  if(U_FAILURE(*status)) return ret;\n  ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);\n  if(ret==NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlopen(%s): %s\\n\", libName, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  dlclose(lib);\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  union {\n      UVoidFunction *fp;\n      void *vp;\n  } uret;\n  uret.fp = NULL;\n  if(U_FAILURE(*status)) return uret.fp;\n  uret.vp = dlsym(lib, sym);\n  if(uret.vp == NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlsym(%p,%s): %s\\n\", lib,sym, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return uret.fp;\n}\n\n#else\n\n/* null (nonexistent) implementation. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  if(U_FAILURE(*status)) return NULL;\n  *status = U_UNSUPPORTED_ERROR;\n  return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  *status = U_UNSUPPORTED_ERROR;\n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n\n\n#endif\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  HMODULE lib = NULL;\n\n  if(U_FAILURE(*status)) return NULL;\n\n  lib = LoadLibraryA(libName);\n\n  if(lib==NULL) {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n\n  return (void*)lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  if(U_FAILURE(*status)) return;\n\n  FreeLibrary(handle);\n\n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  UVoidFunction* addr = NULL;\n\n  if(U_FAILURE(*status) || lib==NULL) return NULL;\n\n  addr = (UVoidFunction*)GetProcAddress(handle, sym);\n\n  if(addr==NULL) {\n    DWORD lastError = GetLastError();\n    if(lastError == ERROR_PROC_NOT_FOUND) {\n      *status = U_MISSING_RESOURCE_ERROR;\n    } else {\n      *status = U_UNSUPPORTED_ERROR; /* other unknown error. */\n    }\n  }\n\n  return addr;\n}\n\n\n#else\n\n/* No dynamic loading set. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n    (void)libName;\n    if(U_FAILURE(*status)) return NULL;\n    *status = U_UNSUPPORTED_ERROR;\n    return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n    (void)lib;\n    if(U_FAILURE(*status)) return;\n    *status = U_UNSUPPORTED_ERROR;\n    return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  (void)lib;\n  (void)sym;\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n#endif /* U_ENABLE_DYLOAD */\n\n/*\n * Hey, Emacs, please set the following:\n *\n * Local Variables:\n * indent-tabs-mode: nil\n * End:\n *\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/icu-small/source/common/icuplug.cpp": "/*\n******************************************************************************\n*\n*   Copyright (C) 2009-2015, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : icuplug.c\n*\n*   Date         Name        Description\n*   10/29/2009   sl          New.\n******************************************************************************\n*/\n\n#include \"unicode/icuplug.h\"\n\n\n#if UCONFIG_ENABLE_PLUGINS\n\n\n#include \"icuplugimp.h\"\n#include \"cstring.h\"\n#include \"cmemory.h\"\n#include \"putilimp.h\"\n#include \"ucln.h\"\n#include <stdio.h>\n#ifdef __MVS__  /* defined by z/OS compiler */\n#define _POSIX_SOURCE\n#include <cics.h> /* 12 Nov 2011 JAM iscics() function */\n#endif\n#include \"charstr.h\"\n\nusing namespace icu;\n\n#ifndef UPLUG_TRACE\n#define UPLUG_TRACE 0\n#endif\n\n#if UPLUG_TRACE\n#include <stdio.h>\n#define DBG(x) fprintf(stderr, \"%s:%d: \",__FILE__,__LINE__); fprintf x\n#endif\n\n/**\n * Internal structure of an ICU plugin.\n */\n\nstruct UPlugData {\n  UPlugEntrypoint  *entrypoint; /**< plugin entrypoint */\n  uint32_t structSize;    /**< initialized to the size of this structure */\n  uint32_t token;         /**< must be U_PLUG_TOKEN */\n  void *lib;              /**< plugin library, or NULL */\n  char libName[UPLUG_NAME_MAX];   /**< library name */\n  char sym[UPLUG_NAME_MAX];        /**< plugin symbol, or NULL */\n  char config[UPLUG_NAME_MAX];     /**< configuration data */\n  void *context;          /**< user context data */\n  char name[UPLUG_NAME_MAX];   /**< name of plugin */\n  UPlugLevel  level; /**< level of plugin */\n  UBool   awaitingLoad; /**< TRUE if the plugin is awaiting a load call */\n  UBool   dontUnload; /**< TRUE if plugin must stay resident (leak plugin and lib) */\n  UErrorCode pluginStatus; /**< status code of plugin */\n};\n\n\n\n#define UPLUG_LIBRARY_INITIAL_COUNT 8\n#define UPLUG_PLUGIN_INITIAL_COUNT 12\n\n/**\n * Remove an item\n * @param list the full list\n * @param listSize the number of entries in the list\n * @param memberSize the size of one member\n * @param itemToRemove the item number of the member\n * @return the new listsize\n */\nstatic int32_t uplug_removeEntryAt(void *list, int32_t listSize, int32_t memberSize, int32_t itemToRemove) {\n  uint8_t *bytePtr = (uint8_t *)list;\n\n  /* get rid of some bad cases first */\n  if(listSize<1) {\n    return listSize;\n  }\n\n  /* is there anything to move? */\n  if(listSize > itemToRemove+1) {\n    memmove(bytePtr+(itemToRemove*memberSize), bytePtr+((itemToRemove+1)*memberSize), memberSize);\n  }\n\n  return listSize-1;\n}\n\n\n\n\n#if U_ENABLE_DYLOAD\n/**\n * Library management. Internal.\n * @internal\n */\nstruct UPlugLibrary;\n\n/**\n * Library management. Internal.\n * @internal\n */\ntypedef struct UPlugLibrary {\n  void *lib;                           /**< library ptr */\n  char name[UPLUG_NAME_MAX]; /**< library name */\n  uint32_t ref;                        /**< reference count */\n} UPlugLibrary;\n\nstatic UPlugLibrary   staticLibraryList[UPLUG_LIBRARY_INITIAL_COUNT];\nstatic UPlugLibrary * libraryList = staticLibraryList;\nstatic int32_t libraryCount = 0;\nstatic int32_t libraryMax = UPLUG_LIBRARY_INITIAL_COUNT;\n\n/**\n * Search for a library. Doesn't lock\n * @param libName libname to search for\n * @return the library's struct\n */\nstatic int32_t searchForLibraryName(const char *libName) {\n  int32_t i;\n\n  for(i=0;i<libraryCount;i++) {\n    if(!uprv_strcmp(libName, libraryList[i].name)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nstatic int32_t searchForLibrary(void *lib) {\n  int32_t i;\n\n  for(i=0;i<libraryCount;i++) {\n    if(lib==libraryList[i].lib) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nU_INTERNAL char * U_EXPORT2\nuplug_findLibrary(void *lib, UErrorCode *status) {\n  int32_t libEnt;\n  char *ret = NULL;\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n  libEnt = searchForLibrary(lib);\n  if(libEnt!=-1) {\n    ret = libraryList[libEnt].name;\n  } else {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void * U_EXPORT2\nuplug_openLibrary(const char *libName, UErrorCode *status) {\n  int32_t libEntry = -1;\n  void *lib = NULL;\n\n  if(U_FAILURE(*status)) return NULL;\n\n  libEntry = searchForLibraryName(libName);\n  if(libEntry == -1) {\n    libEntry = libraryCount++;\n    if(libraryCount >= libraryMax) {\n      /* Ran out of library slots. Statically allocated because we can't depend on allocating memory.. */\n      *status = U_MEMORY_ALLOCATION_ERROR;\n#if UPLUG_TRACE\n      DBG((stderr, \"uplug_openLibrary() - out of library slots (max %d)\\n\", libraryMax));\n#endif\n      return NULL;\n    }\n    /* Some operating systems don't want\n       DL operations from multiple threads. */\n    libraryList[libEntry].lib = uprv_dl_open(libName, status);\n#if UPLUG_TRACE\n    DBG((stderr, \"uplug_openLibrary(%s,%s) libEntry %d, lib %p\\n\", libName, u_errorName(*status), libEntry, lib));\n#endif\n\n    if(libraryList[libEntry].lib == NULL || U_FAILURE(*status)) {\n      /* cleanup. */\n      libraryList[libEntry].lib = NULL; /* failure with open */\n      libraryList[libEntry].name[0] = 0;\n#if UPLUG_TRACE\n      DBG((stderr, \"uplug_openLibrary(%s,%s) libEntry %d, lib %p\\n\", libName, u_errorName(*status), libEntry, lib));\n#endif\n      /* no need to free - just won't increase the count. */\n      libraryCount--;\n    } else { /* is it still there? */\n      /* link it in */\n      uprv_strncpy(libraryList[libEntry].name,libName,UPLUG_NAME_MAX);\n      libraryList[libEntry].ref=1;\n      lib = libraryList[libEntry].lib;\n    }\n\n  } else {\n    lib = libraryList[libEntry].lib;\n    libraryList[libEntry].ref++;\n  }\n  return lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuplug_closeLibrary(void *lib, UErrorCode *status) {\n  int32_t i;\n\n#if UPLUG_TRACE\n  DBG((stderr, \"uplug_closeLibrary(%p,%s) list %p\\n\", lib, u_errorName(*status), (void*)libraryList));\n#endif\n  if(U_FAILURE(*status)) return;\n\n  for(i=0;i<libraryCount;i++) {\n    if(lib==libraryList[i].lib) {\n      if(--(libraryList[i].ref) == 0) {\n        uprv_dl_close(libraryList[i].lib, status);\n        libraryCount = uplug_removeEntryAt(libraryList, libraryCount, sizeof(*libraryList), i);\n      }\n      return;\n    }\n  }\n  *status = U_INTERNAL_PROGRAM_ERROR; /* could not find the entry! */\n}\n\n#endif\n\nstatic UPlugData pluginList[UPLUG_PLUGIN_INITIAL_COUNT];\nstatic int32_t pluginCount = 0;\n\n\n\n\nstatic int32_t uplug_pluginNumber(UPlugData* d) {\n  UPlugData *pastPlug = &pluginList[pluginCount];\n  if(d<=pluginList) {\n    return 0;\n  } else if(d>=pastPlug) {\n    return pluginCount;\n  } else {\n    return (d-pluginList)/sizeof(pluginList[0]);\n  }\n}\n\n\nU_CAPI UPlugData * U_EXPORT2\nuplug_nextPlug(UPlugData *prior) {\n  if(prior==NULL) {\n    return pluginList;\n  } else {\n    UPlugData *nextPlug = &prior[1];\n    UPlugData *pastPlug = &pluginList[pluginCount];\n\n    if(nextPlug>=pastPlug) {\n      return NULL;\n    } else {\n      return nextPlug;\n    }\n  }\n}\n\n\n\n/**\n * Call the plugin with some params\n */\nstatic void uplug_callPlug(UPlugData *plug, UPlugReason reason, UErrorCode *status) {\n  UPlugTokenReturn token;\n  if(plug==NULL||U_FAILURE(*status)) {\n    return;\n  }\n  token = (*(plug->entrypoint))(plug, reason, status);\n  if(token!=UPLUG_TOKEN) {\n    *status = U_INTERNAL_PROGRAM_ERROR;\n  }\n}\n\n\nstatic void uplug_unloadPlug(UPlugData *plug, UErrorCode *status) {\n  if(plug->awaitingLoad) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return;\n  }\n  if(U_SUCCESS(plug->pluginStatus)) {\n    /* Don't unload a plug which has a failing load status - means it didn't actually load. */\n    uplug_callPlug(plug, UPLUG_REASON_UNLOAD, status);\n  }\n}\n\nstatic void uplug_queryPlug(UPlugData *plug, UErrorCode *status) {\n  if(!plug->awaitingLoad || !(plug->level == UPLUG_LEVEL_UNKNOWN) ) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return;\n  }\n  plug->level = UPLUG_LEVEL_INVALID;\n  uplug_callPlug(plug, UPLUG_REASON_QUERY, status);\n  if(U_SUCCESS(*status)) {\n    if(plug->level == UPLUG_LEVEL_INVALID) {\n      plug->pluginStatus = U_PLUGIN_DIDNT_SET_LEVEL;\n      plug->awaitingLoad = FALSE;\n    }\n  } else {\n    plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n    plug->awaitingLoad = FALSE;\n  }\n}\n\n\nstatic void uplug_loadPlug(UPlugData *plug, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return;\n  }\n  if(!plug->awaitingLoad || (plug->level < UPLUG_LEVEL_LOW) ) {  /* shouldn't happen. Plugin hasn'tbeen loaded yet.*/\n    *status = U_INTERNAL_PROGRAM_ERROR;\n    return;\n  }\n  uplug_callPlug(plug, UPLUG_REASON_LOAD, status);\n  plug->awaitingLoad = FALSE;\n  if(!U_SUCCESS(*status)) {\n    plug->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n  }\n}\n\nstatic UPlugData *uplug_allocateEmptyPlug(UErrorCode *status)\n{\n  UPlugData *plug = NULL;\n\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n\n  if(pluginCount == UPLUG_PLUGIN_INITIAL_COUNT) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n    return NULL;\n  }\n\n  plug = &pluginList[pluginCount++];\n\n  plug->token = UPLUG_TOKEN;\n  plug->structSize = sizeof(UPlugData);\n  plug->name[0]=0;\n  plug->level = UPLUG_LEVEL_UNKNOWN; /* initialize to null state */\n  plug->awaitingLoad = TRUE;\n  plug->dontUnload = FALSE;\n  plug->pluginStatus = U_ZERO_ERROR;\n  plug->libName[0] = 0;\n  plug->config[0]=0;\n  plug->sym[0]=0;\n  plug->lib=NULL;\n  plug->entrypoint=NULL;\n\n\n  return plug;\n}\n\nstatic UPlugData *uplug_allocatePlug(UPlugEntrypoint *entrypoint, const char *config, void *lib, const char *symName,\n                                     UErrorCode *status) {\n  UPlugData *plug = uplug_allocateEmptyPlug(status);\n  if(U_FAILURE(*status)) {\n    return NULL;\n  }\n\n  if(config!=NULL) {\n    uprv_strncpy(plug->config, config, UPLUG_NAME_MAX);\n  } else {\n    plug->config[0] = 0;\n  }\n\n  if(symName!=NULL) {\n    uprv_strncpy(plug->sym, symName, UPLUG_NAME_MAX);\n  } else {\n    plug->sym[0] = 0;\n  }\n\n  plug->entrypoint = entrypoint;\n  plug->lib = lib;\n  uplug_queryPlug(plug, status);\n\n  return plug;\n}\n\nstatic void uplug_deallocatePlug(UPlugData *plug, UErrorCode *status) {\n  UErrorCode subStatus = U_ZERO_ERROR;\n  if(!plug->dontUnload) {\n#if U_ENABLE_DYLOAD\n    uplug_closeLibrary(plug->lib, &subStatus);\n#endif\n  }\n  plug->lib = NULL;\n  if(U_SUCCESS(*status) && U_FAILURE(subStatus)) {\n    *status = subStatus;\n  }\n  /* shift plugins up and decrement count. */\n  if(U_SUCCESS(*status)) {\n    /* all ok- remove. */\n    pluginCount = uplug_removeEntryAt(pluginList, pluginCount, sizeof(plug[0]), uplug_pluginNumber(plug));\n  } else {\n    /* not ok- leave as a message. */\n    plug->awaitingLoad=FALSE;\n    plug->entrypoint=0;\n    plug->dontUnload=TRUE;\n  }\n}\n\nstatic void uplug_doUnloadPlug(UPlugData *plugToRemove, UErrorCode *status) {\n  if(plugToRemove != NULL) {\n    uplug_unloadPlug(plugToRemove, status);\n    uplug_deallocatePlug(plugToRemove, status);\n  }\n}\n\nU_CAPI void U_EXPORT2\nuplug_removePlug(UPlugData *plug, UErrorCode *status)  {\n  UPlugData *cursor = NULL;\n  UPlugData *plugToRemove = NULL;\n  if(U_FAILURE(*status)) return;\n\n  for(cursor=pluginList;cursor!=NULL;) {\n    if(cursor==plug) {\n      plugToRemove = plug;\n      cursor=NULL;\n    } else {\n      cursor = uplug_nextPlug(cursor);\n    }\n  }\n\n  uplug_doUnloadPlug(plugToRemove, status);\n}\n\n\n\n\nU_CAPI void U_EXPORT2\nuplug_setPlugNoUnload(UPlugData *data, UBool dontUnload)\n{\n  data->dontUnload = dontUnload;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setPlugLevel(UPlugData *data, UPlugLevel level) {\n  data->level = level;\n}\n\n\nU_CAPI UPlugLevel U_EXPORT2\nuplug_getPlugLevel(UPlugData *data) {\n  return data->level;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setPlugName(UPlugData *data, const char *name) {\n  uprv_strncpy(data->name, name, UPLUG_NAME_MAX);\n}\n\n\nU_CAPI const char * U_EXPORT2\nuplug_getPlugName(UPlugData *data) {\n  return data->name;\n}\n\n\nU_CAPI const char * U_EXPORT2\nuplug_getSymbolName(UPlugData *data) {\n  return data->sym;\n}\n\nU_CAPI const char * U_EXPORT2\nuplug_getLibraryName(UPlugData *data, UErrorCode *status) {\n  if(data->libName[0]) {\n    return data->libName;\n  } else {\n#if U_ENABLE_DYLOAD\n    return uplug_findLibrary(data->lib, status);\n#else\n    return NULL;\n#endif\n  }\n}\n\nU_CAPI void * U_EXPORT2\nuplug_getLibrary(UPlugData *data) {\n  return data->lib;\n}\n\nU_CAPI void * U_EXPORT2\nuplug_getContext(UPlugData *data) {\n  return data->context;\n}\n\n\nU_CAPI void U_EXPORT2\nuplug_setContext(UPlugData *data, void *context) {\n  data->context = context;\n}\n\nU_CAPI const char* U_EXPORT2\nuplug_getConfiguration(UPlugData *data) {\n  return data->config;\n}\n\nU_INTERNAL UPlugData* U_EXPORT2\nuplug_getPlugInternal(int32_t n) {\n  if(n <0 || n >= pluginCount) {\n    return NULL;\n  } else {\n    return &(pluginList[n]);\n  }\n}\n\n\nU_CAPI UErrorCode U_EXPORT2\nuplug_getPlugLoadStatus(UPlugData *plug) {\n  return plug->pluginStatus;\n}\n\n\n\n\n/**\n * Initialize a plugin fron an entrypoint and library - but don't load it.\n */\nstatic UPlugData* uplug_initPlugFromEntrypointAndLibrary(UPlugEntrypoint *entrypoint, const char *config, void *lib, const char *sym,\n                                                         UErrorCode *status) {\n  UPlugData *plug = NULL;\n\n  plug = uplug_allocatePlug(entrypoint, config, lib, sym, status);\n\n  if(U_SUCCESS(*status)) {\n    return plug;\n  } else {\n    uplug_deallocatePlug(plug, status);\n    return NULL;\n  }\n}\n\nU_CAPI UPlugData* U_EXPORT2\nuplug_loadPlugFromEntrypoint(UPlugEntrypoint *entrypoint, const char *config, UErrorCode *status) {\n  UPlugData* plug = uplug_initPlugFromEntrypointAndLibrary(entrypoint, config, NULL, NULL, status);\n  uplug_loadPlug(plug, status);\n  return plug;\n}\n\n#if U_ENABLE_DYLOAD\n\nstatic UPlugData*\nuplug_initErrorPlug(const char *libName, const char *sym, const char *config, const char *nameOrError, UErrorCode loadStatus, UErrorCode *status)\n{\n  UPlugData *plug = uplug_allocateEmptyPlug(status);\n  if(U_FAILURE(*status)) return NULL;\n\n  plug->pluginStatus = loadStatus;\n  plug->awaitingLoad = FALSE; /* Won't load. */\n  plug->dontUnload = TRUE; /* cannot unload. */\n\n  if(sym!=NULL) {\n    uprv_strncpy(plug->sym, sym, UPLUG_NAME_MAX);\n  }\n\n  if(libName!=NULL) {\n    uprv_strncpy(plug->libName, libName, UPLUG_NAME_MAX);\n  }\n\n  if(nameOrError!=NULL) {\n    uprv_strncpy(plug->name, nameOrError, UPLUG_NAME_MAX);\n  }\n\n  if(config!=NULL) {\n    uprv_strncpy(plug->config, config, UPLUG_NAME_MAX);\n  }\n\n  return plug;\n}\n\n/**\n * Fetch a plugin from DLL, and then initialize it from a library- but don't load it.\n */\nstatic UPlugData*\nuplug_initPlugFromLibrary(const char *libName, const char *sym, const char *config, UErrorCode *status) {\n  void *lib = NULL;\n  UPlugData *plug = NULL;\n  if(U_FAILURE(*status)) { return NULL; }\n  lib = uplug_openLibrary(libName, status);\n  if(lib!=NULL && U_SUCCESS(*status)) {\n    UPlugEntrypoint *entrypoint = NULL;\n    entrypoint = (UPlugEntrypoint*)uprv_dlsym_func(lib, sym, status);\n\n    if(entrypoint!=NULL&&U_SUCCESS(*status)) {\n      plug = uplug_initPlugFromEntrypointAndLibrary(entrypoint, config, lib, sym, status);\n      if(plug!=NULL&&U_SUCCESS(*status)) {\n        plug->lib = lib; /* plug takes ownership of library */\n        lib = NULL; /* library is now owned by plugin. */\n      }\n    } else {\n      UErrorCode subStatus = U_ZERO_ERROR;\n      plug = uplug_initErrorPlug(libName,sym,config,\"ERROR: Could not load entrypoint\",(lib==NULL)?U_MISSING_RESOURCE_ERROR:*status,&subStatus);\n    }\n    if(lib!=NULL) { /* still need to close the lib */\n      UErrorCode subStatus = U_ZERO_ERROR;\n      uplug_closeLibrary(lib, &subStatus); /* don't care here */\n    }\n  } else {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    plug = uplug_initErrorPlug(libName,sym,config,\"ERROR: could not load library\",(lib==NULL)?U_MISSING_RESOURCE_ERROR:*status,&subStatus);\n  }\n  return plug;\n}\n\nU_CAPI UPlugData* U_EXPORT2\nuplug_loadPlugFromLibrary(const char *libName, const char *sym, const char *config, UErrorCode *status) {\n  UPlugData *plug = NULL;\n  if(U_FAILURE(*status)) { return NULL; }\n  plug = uplug_initPlugFromLibrary(libName, sym, config, status);\n  uplug_loadPlug(plug, status);\n\n  return plug;\n}\n\n#endif\n\nstatic UPlugLevel gCurrentLevel = UPLUG_LEVEL_LOW;\n\nU_CAPI UPlugLevel U_EXPORT2 uplug_getCurrentLevel() {\n  return gCurrentLevel;\n}\n\nstatic UBool U_CALLCONV uplug_cleanup(void)\n{\n  int32_t i;\n\n  UPlugData *pluginToRemove;\n  /* cleanup plugs */\n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    pluginToRemove = &pluginList[i];\n    /* unload and deallocate */\n    uplug_doUnloadPlug(pluginToRemove, &subStatus);\n  }\n  /* close other held libs? */\n  gCurrentLevel = UPLUG_LEVEL_LOW;\n  return TRUE;\n}\n\n#if U_ENABLE_DYLOAD\n\nstatic void uplug_loadWaitingPlugs(UErrorCode *status) {\n  int32_t i;\n  UPlugLevel currentLevel = uplug_getCurrentLevel();\n\n  if(U_FAILURE(*status)) {\n    return;\n  }\n#if UPLUG_TRACE\n  DBG((stderr,  \"uplug_loadWaitingPlugs() Level: %d\\n\", currentLevel));\n#endif\n  /* pass #1: low level plugs */\n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    UPlugData *pluginToLoad = &pluginList[i];\n    if(pluginToLoad->awaitingLoad) {\n      if(pluginToLoad->level == UPLUG_LEVEL_LOW) {\n        if(currentLevel > UPLUG_LEVEL_LOW) {\n          pluginToLoad->pluginStatus = U_PLUGIN_TOO_HIGH;\n        } else {\n          UPlugLevel newLevel;\n          uplug_loadPlug(pluginToLoad, &subStatus);\n          newLevel = uplug_getCurrentLevel();\n          if(newLevel > currentLevel) {\n            pluginToLoad->pluginStatus = U_PLUGIN_CHANGED_LEVEL_WARNING;\n            currentLevel = newLevel;\n          }\n        }\n        pluginToLoad->awaitingLoad = FALSE;\n      }\n    }\n  }\n  for(i=0;i<pluginCount;i++) {\n    UErrorCode subStatus = U_ZERO_ERROR;\n    UPlugData *pluginToLoad = &pluginList[i];\n\n    if(pluginToLoad->awaitingLoad) {\n      if(pluginToLoad->level == UPLUG_LEVEL_INVALID) {\n        pluginToLoad->pluginStatus = U_PLUGIN_DIDNT_SET_LEVEL;\n      } else if(pluginToLoad->level == UPLUG_LEVEL_UNKNOWN) {\n        pluginToLoad->pluginStatus = U_INTERNAL_PROGRAM_ERROR;\n      } else {\n        uplug_loadPlug(pluginToLoad, &subStatus);\n      }\n      pluginToLoad->awaitingLoad = FALSE;\n    }\n  }\n\n#if UPLUG_TRACE\n  DBG((stderr,  \" Done Loading Plugs. Level: %d\\n\", (int32_t)uplug_getCurrentLevel()));\n#endif\n}\n\n/* Name of the plugin config file */\nstatic char plugin_file[2048] = \"\";\n#endif\n\nU_INTERNAL const char* U_EXPORT2\nuplug_getPluginFile() {\n#if U_ENABLE_DYLOAD && !UCONFIG_NO_FILE_IO\n  return plugin_file;\n#else\n  return NULL;\n#endif\n}\n\n\n//  uplug_init()  is called first thing from u_init().\n\nU_CAPI void U_EXPORT2\nuplug_init(UErrorCode *status) {\n#if !U_ENABLE_DYLOAD\n  (void)status; /* unused */\n#elif !UCONFIG_NO_FILE_IO\n  CharString plugin_dir;\n  const char *env = getenv(\"ICU_PLUGINS\");\n\n  if(U_FAILURE(*status)) return;\n  if(env != NULL) {\n    plugin_dir.append(env, -1, *status);\n  }\n  if(U_FAILURE(*status)) return;\n\n#if defined(DEFAULT_ICU_PLUGINS)\n  if(plugin_dir.isEmpty()) {\n    plugin_dir.append(DEFAULT_ICU_PLUGINS, -1, *status);\n  }\n#endif\n\n#if UPLUG_TRACE\n  DBG((stderr, \"ICU_PLUGINS=%s\\n\", plugin_dir.data()));\n#endif\n\n  if(!plugin_dir.isEmpty()) {\n    FILE *f;\n\n    CharString pluginFile;\n#ifdef OS390BATCH\n/* There are potentially a lot of ways to implement a plugin directory on OS390/zOS  */\n/* Keeping in mind that unauthorized file access is logged, monitored, and enforced  */\n/* I've chosen to open a DDNAME if BATCH and leave it alone for (presumably) UNIX    */\n/* System Services.  Alternative techniques might be allocating a member in          */\n/* SYS1.PARMLIB or setting an environment variable \"ICU_PLUGIN_PATH\" (?).  The       */\n/* DDNAME can be connected to a file in the HFS if need be.                          */\n\n    pluginFile.append(\"//DD:ICUPLUG\", -1, *status);        /* JAM 20 Oct 2011 */\n#else\n    pluginFile.append(plugin_dir, *status);\n    pluginFile.append(U_FILE_SEP_STRING, -1, *status);\n    pluginFile.append(\"icuplugins\", -1, *status);\n    pluginFile.append(U_ICU_VERSION_SHORT, -1, *status);\n    pluginFile.append(\".txt\", -1, *status);\n#endif\n\n#if UPLUG_TRACE\n    DBG((stderr, \"status=%s\\n\", u_errorName(*status)));\n#endif\n\n    if(U_FAILURE(*status)) {\n      return;\n    }\n    if((size_t)pluginFile.length() > (sizeof(plugin_file)-1)) {\n      *status = U_BUFFER_OVERFLOW_ERROR;\n#if UPLUG_TRACE\n      DBG((stderr, \"status=%s\\n\", u_errorName(*status)));\n#endif\n      return;\n    }\n\n    /* plugin_file is not used for processing - it is only used\n       so that uplug_getPluginFile() works (i.e. icuinfo)\n    */\n    uprv_strncpy(plugin_file, pluginFile.data(), sizeof(plugin_file));\n\n#if UPLUG_TRACE\n    DBG((stderr, \"pluginfile= %s len %d/%d\\n\", plugin_file, (int)strlen(plugin_file), (int)sizeof(plugin_file)));\n#endif\n\n#ifdef __MVS__\n    if (iscics()) /* 12 Nov 2011 JAM */\n    {\n        f = NULL;\n    }\n    else\n#endif\n    {\n        f = fopen(pluginFile.data(), \"r\");\n    }\n\n    if(f != NULL) {\n      char linebuf[1024];\n      char *p, *libName=NULL, *symName=NULL, *config=NULL;\n      int32_t line = 0;\n\n\n      while(fgets(linebuf,1023,f)) {\n        line++;\n\n        if(!*linebuf || *linebuf=='#') {\n          continue;\n        } else {\n          p = linebuf;\n          while(*p&&isspace((int)*p))\n            p++;\n          if(!*p || *p=='#') continue;\n          libName = p;\n          while(*p&&!isspace((int)*p)) {\n            p++;\n          }\n          if(!*p || *p=='#') continue; /* no tab after libname */\n          *p=0; /* end of libname */\n          p++;\n          while(*p&&isspace((int)*p)) {\n            p++;\n          }\n          if(!*p||*p=='#') continue; /* no symname after libname +tab */\n          symName = p;\n          while(*p&&!isspace((int)*p)) {\n            p++;\n          }\n\n          if(*p) { /* has config */\n            *p=0;\n            ++p;\n            while(*p&&isspace((int)*p)) {\n              p++;\n            }\n            if(*p) {\n              config = p;\n            }\n          }\n\n          /* chop whitespace at the end of the config */\n          if(config!=NULL&&*config!=0) {\n            p = config+strlen(config);\n            while(p>config&&isspace((int)*(--p))) {\n              *p=0;\n            }\n          }\n\n          /* OK, we're good. */\n          {\n            UErrorCode subStatus = U_ZERO_ERROR;\n            UPlugData *plug = uplug_initPlugFromLibrary(libName, symName, config, &subStatus);\n            if(U_FAILURE(subStatus) && U_SUCCESS(*status)) {\n              *status = subStatus;\n            }\n#if UPLUG_TRACE\n            DBG((stderr, \"PLUGIN libName=[%s], sym=[%s], config=[%s]\\n\", libName, symName, config));\n            DBG((stderr, \" -> %p, %s\\n\", (void*)plug, u_errorName(subStatus)));\n#else\n            (void)plug; /* unused */\n#endif\n          }\n        }\n      }\n      fclose(f);\n    } else {\n#if UPLUG_TRACE\n      DBG((stderr, \"Can't open plugin file %s\\n\", plugin_file));\n#endif\n    }\n  }\n  uplug_loadWaitingPlugs(status);\n#endif /* U_ENABLE_DYLOAD */\n  gCurrentLevel = UPLUG_LEVEL_HIGH;\n  ucln_registerCleanup(UCLN_UPLUG, uplug_cleanup);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/icu-small/source/common/unicode/urename.h": "/*\n*******************************************************************************\n*   Copyright (C) 2002-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*******************************************************************************\n*\n*   file name:  urename.h\n*   encoding:   US-ASCII\n*   tab size:   8 (not used)\n*   indentation:4\n*\n*   Created by: Perl script tools/genren.pl written by Vladimir Weinstein\n*\n*  Contains data for renaming ICU exports.\n*  Gets included by umachine.h\n*\n*  THIS FILE IS MACHINE-GENERATED, DON'T PLAY WITH IT IF YOU DON'T KNOW WHAT\n*  YOU ARE DOING, OTHERWISE VERY BAD THINGS WILL HAPPEN!\n*/\n\n#ifndef URENAME_H\n#define URENAME_H\n\n/* U_DISABLE_RENAMING can be defined in the following ways:\n *   - when running configure, e.g.\n *        runConfigureICU Linux --disable-renaming\n *   - by changing the default setting of U_DISABLE_RENAMING in uconfig.h\n */\n\n#include \"unicode/uconfig.h\"\n\n#if !U_DISABLE_RENAMING\n\n/* We need the U_ICU_ENTRY_POINT_RENAME definition. There's a default one in unicode/uvernum.h we can use, but we will give\n   the platform a chance to define it first.\n   Normally (if utypes.h or umachine.h was included first) this will not be necessary as it will already be defined.\n */\n\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#include \"unicode/umachine.h\"\n#endif\n\n/* If we still don't have U_ICU_ENTRY_POINT_RENAME use the default. */\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#include \"unicode/uvernum.h\"\n#endif\n\n/* Error out before the following defines cause very strange and unexpected code breakage */\n#ifndef U_ICU_ENTRY_POINT_RENAME\n#error U_ICU_ENTRY_POINT_RENAME is not defined - cannot continue. Consider defining U_DISABLE_RENAMING if renaming should not be used.\n#endif\n\n\n/* C exports renaming data */\n\n#define T_CString_int64ToString U_ICU_ENTRY_POINT_RENAME(T_CString_int64ToString)\n#define T_CString_integerToString U_ICU_ENTRY_POINT_RENAME(T_CString_integerToString)\n#define T_CString_stringToInteger U_ICU_ENTRY_POINT_RENAME(T_CString_stringToInteger)\n#define T_CString_toLowerCase U_ICU_ENTRY_POINT_RENAME(T_CString_toLowerCase)\n#define T_CString_toUpperCase U_ICU_ENTRY_POINT_RENAME(T_CString_toUpperCase)\n#define UCNV_FROM_U_CALLBACK_ESCAPE U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_ESCAPE)\n#define UCNV_FROM_U_CALLBACK_SKIP U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_SKIP)\n#define UCNV_FROM_U_CALLBACK_STOP U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_STOP)\n#define UCNV_FROM_U_CALLBACK_SUBSTITUTE U_ICU_ENTRY_POINT_RENAME(UCNV_FROM_U_CALLBACK_SUBSTITUTE)\n#define UCNV_TO_U_CALLBACK_ESCAPE U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_ESCAPE)\n#define UCNV_TO_U_CALLBACK_SKIP U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_SKIP)\n#define UCNV_TO_U_CALLBACK_STOP U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_STOP)\n#define UCNV_TO_U_CALLBACK_SUBSTITUTE U_ICU_ENTRY_POINT_RENAME(UCNV_TO_U_CALLBACK_SUBSTITUTE)\n#define UDataMemory_createNewInstance U_ICU_ENTRY_POINT_RENAME(UDataMemory_createNewInstance)\n#define UDataMemory_init U_ICU_ENTRY_POINT_RENAME(UDataMemory_init)\n#define UDataMemory_isLoaded U_ICU_ENTRY_POINT_RENAME(UDataMemory_isLoaded)\n#define UDataMemory_normalizeDataPointer U_ICU_ENTRY_POINT_RENAME(UDataMemory_normalizeDataPointer)\n#define UDataMemory_setData U_ICU_ENTRY_POINT_RENAME(UDataMemory_setData)\n#define UDatamemory_assign U_ICU_ENTRY_POINT_RENAME(UDatamemory_assign)\n#define _ASCIIData U_ICU_ENTRY_POINT_RENAME(_ASCIIData)\n#define _Bocu1Data U_ICU_ENTRY_POINT_RENAME(_Bocu1Data)\n#define _CESU8Data U_ICU_ENTRY_POINT_RENAME(_CESU8Data)\n#define _CompoundTextData U_ICU_ENTRY_POINT_RENAME(_CompoundTextData)\n#define _HZData U_ICU_ENTRY_POINT_RENAME(_HZData)\n#define _IMAPData U_ICU_ENTRY_POINT_RENAME(_IMAPData)\n#define _ISCIIData U_ICU_ENTRY_POINT_RENAME(_ISCIIData)\n#define _ISO2022Data U_ICU_ENTRY_POINT_RENAME(_ISO2022Data)\n#define _LMBCSData1 U_ICU_ENTRY_POINT_RENAME(_LMBCSData1)\n#define _LMBCSData11 U_ICU_ENTRY_POINT_RENAME(_LMBCSData11)\n#define _LMBCSData16 U_ICU_ENTRY_POINT_RENAME(_LMBCSData16)\n#define _LMBCSData17 U_ICU_ENTRY_POINT_RENAME(_LMBCSData17)\n#define _LMBCSData18 U_ICU_ENTRY_POINT_RENAME(_LMBCSData18)\n#define _LMBCSData19 U_ICU_ENTRY_POINT_RENAME(_LMBCSData19)\n#define _LMBCSData2 U_ICU_ENTRY_POINT_RENAME(_LMBCSData2)\n#define _LMBCSData3 U_ICU_ENTRY_POINT_RENAME(_LMBCSData3)\n#define _LMBCSData4 U_ICU_ENTRY_POINT_RENAME(_LMBCSData4)\n#define _LMBCSData5 U_ICU_ENTRY_POINT_RENAME(_LMBCSData5)\n#define _LMBCSData6 U_ICU_ENTRY_POINT_RENAME(_LMBCSData6)\n#define _LMBCSData8 U_ICU_ENTRY_POINT_RENAME(_LMBCSData8)\n#define _Latin1Data U_ICU_ENTRY_POINT_RENAME(_Latin1Data)\n#define _MBCSData U_ICU_ENTRY_POINT_RENAME(_MBCSData)\n#define _SCSUData U_ICU_ENTRY_POINT_RENAME(_SCSUData)\n#define _UTF16BEData U_ICU_ENTRY_POINT_RENAME(_UTF16BEData)\n#define _UTF16Data U_ICU_ENTRY_POINT_RENAME(_UTF16Data)\n#define _UTF16LEData U_ICU_ENTRY_POINT_RENAME(_UTF16LEData)\n#define _UTF32BEData U_ICU_ENTRY_POINT_RENAME(_UTF32BEData)\n#define _UTF32Data U_ICU_ENTRY_POINT_RENAME(_UTF32Data)\n#define _UTF32LEData U_ICU_ENTRY_POINT_RENAME(_UTF32LEData)\n#define _UTF7Data U_ICU_ENTRY_POINT_RENAME(_UTF7Data)\n#define _UTF8Data U_ICU_ENTRY_POINT_RENAME(_UTF8Data)\n#define cmemory_cleanup U_ICU_ENTRY_POINT_RENAME(cmemory_cleanup)\n#define gTimeZoneFilesInitOnce U_ICU_ENTRY_POINT_RENAME(gTimeZoneFilesInitOnce)\n#define izrule_clone U_ICU_ENTRY_POINT_RENAME(izrule_clone)\n#define izrule_close U_ICU_ENTRY_POINT_RENAME(izrule_close)\n#define izrule_equals U_ICU_ENTRY_POINT_RENAME(izrule_equals)\n#define izrule_getDSTSavings U_ICU_ENTRY_POINT_RENAME(izrule_getDSTSavings)\n#define izrule_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(izrule_getDynamicClassID)\n#define izrule_getFinalStart U_ICU_ENTRY_POINT_RENAME(izrule_getFinalStart)\n#define izrule_getFirstStart U_ICU_ENTRY_POINT_RENAME(izrule_getFirstStart)\n#define izrule_getName U_ICU_ENTRY_POINT_RENAME(izrule_getName)\n#define izrule_getNextStart U_ICU_ENTRY_POINT_RENAME(izrule_getNextStart)\n#define izrule_getPreviousStart U_ICU_ENTRY_POINT_RENAME(izrule_getPreviousStart)\n#define izrule_getRawOffset U_ICU_ENTRY_POINT_RENAME(izrule_getRawOffset)\n#define izrule_getStaticClassID U_ICU_ENTRY_POINT_RENAME(izrule_getStaticClassID)\n#define izrule_isEquivalentTo U_ICU_ENTRY_POINT_RENAME(izrule_isEquivalentTo)\n#define izrule_open U_ICU_ENTRY_POINT_RENAME(izrule_open)\n#define le_close U_ICU_ENTRY_POINT_RENAME(le_close)\n#define le_create U_ICU_ENTRY_POINT_RENAME(le_create)\n#define le_getCharIndices U_ICU_ENTRY_POINT_RENAME(le_getCharIndices)\n#define le_getCharIndicesWithBase U_ICU_ENTRY_POINT_RENAME(le_getCharIndicesWithBase)\n#define le_getGlyphCount U_ICU_ENTRY_POINT_RENAME(le_getGlyphCount)\n#define le_getGlyphPosition U_ICU_ENTRY_POINT_RENAME(le_getGlyphPosition)\n#define le_getGlyphPositions U_ICU_ENTRY_POINT_RENAME(le_getGlyphPositions)\n#define le_getGlyphs U_ICU_ENTRY_POINT_RENAME(le_getGlyphs)\n#define le_layoutChars U_ICU_ENTRY_POINT_RENAME(le_layoutChars)\n#define le_reset U_ICU_ENTRY_POINT_RENAME(le_reset)\n#define locale_getKeywords U_ICU_ENTRY_POINT_RENAME(locale_getKeywords)\n#define locale_getKeywordsStart U_ICU_ENTRY_POINT_RENAME(locale_getKeywordsStart)\n#define locale_get_default U_ICU_ENTRY_POINT_RENAME(locale_get_default)\n#define locale_set_default U_ICU_ENTRY_POINT_RENAME(locale_set_default)\n#define pl_addFontRun U_ICU_ENTRY_POINT_RENAME(pl_addFontRun)\n#define pl_addLocaleRun U_ICU_ENTRY_POINT_RENAME(pl_addLocaleRun)\n#define pl_addValueRun U_ICU_ENTRY_POINT_RENAME(pl_addValueRun)\n#define pl_close U_ICU_ENTRY_POINT_RENAME(pl_close)\n#define pl_closeFontRuns U_ICU_ENTRY_POINT_RENAME(pl_closeFontRuns)\n#define pl_closeLine U_ICU_ENTRY_POINT_RENAME(pl_closeLine)\n#define pl_closeLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_closeLocaleRuns)\n#define pl_closeValueRuns U_ICU_ENTRY_POINT_RENAME(pl_closeValueRuns)\n#define pl_countLineRuns U_ICU_ENTRY_POINT_RENAME(pl_countLineRuns)\n#define pl_create U_ICU_ENTRY_POINT_RENAME(pl_create)\n#define pl_getAscent U_ICU_ENTRY_POINT_RENAME(pl_getAscent)\n#define pl_getDescent U_ICU_ENTRY_POINT_RENAME(pl_getDescent)\n#define pl_getFontRunCount U_ICU_ENTRY_POINT_RENAME(pl_getFontRunCount)\n#define pl_getFontRunFont U_ICU_ENTRY_POINT_RENAME(pl_getFontRunFont)\n#define pl_getFontRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getFontRunLastLimit)\n#define pl_getFontRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getFontRunLimit)\n#define pl_getLeading U_ICU_ENTRY_POINT_RENAME(pl_getLeading)\n#define pl_getLineAscent U_ICU_ENTRY_POINT_RENAME(pl_getLineAscent)\n#define pl_getLineDescent U_ICU_ENTRY_POINT_RENAME(pl_getLineDescent)\n#define pl_getLineLeading U_ICU_ENTRY_POINT_RENAME(pl_getLineLeading)\n#define pl_getLineVisualRun U_ICU_ENTRY_POINT_RENAME(pl_getLineVisualRun)\n#define pl_getLineWidth U_ICU_ENTRY_POINT_RENAME(pl_getLineWidth)\n#define pl_getLocaleRunCount U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunCount)\n#define pl_getLocaleRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLastLimit)\n#define pl_getLocaleRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLimit)\n#define pl_getLocaleRunLocale U_ICU_ENTRY_POINT_RENAME(pl_getLocaleRunLocale)\n#define pl_getParagraphLevel U_ICU_ENTRY_POINT_RENAME(pl_getParagraphLevel)\n#define pl_getTextDirection U_ICU_ENTRY_POINT_RENAME(pl_getTextDirection)\n#define pl_getValueRunCount U_ICU_ENTRY_POINT_RENAME(pl_getValueRunCount)\n#define pl_getValueRunLastLimit U_ICU_ENTRY_POINT_RENAME(pl_getValueRunLastLimit)\n#define pl_getValueRunLimit U_ICU_ENTRY_POINT_RENAME(pl_getValueRunLimit)\n#define pl_getValueRunValue U_ICU_ENTRY_POINT_RENAME(pl_getValueRunValue)\n#define pl_getVisualRunAscent U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunAscent)\n#define pl_getVisualRunDescent U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunDescent)\n#define pl_getVisualRunDirection U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunDirection)\n#define pl_getVisualRunFont U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunFont)\n#define pl_getVisualRunGlyphCount U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphCount)\n#define pl_getVisualRunGlyphToCharMap U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphToCharMap)\n#define pl_getVisualRunGlyphs U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunGlyphs)\n#define pl_getVisualRunLeading U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunLeading)\n#define pl_getVisualRunPositions U_ICU_ENTRY_POINT_RENAME(pl_getVisualRunPositions)\n#define pl_isComplex U_ICU_ENTRY_POINT_RENAME(pl_isComplex)\n#define pl_nextLine U_ICU_ENTRY_POINT_RENAME(pl_nextLine)\n#define pl_openEmptyFontRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyFontRuns)\n#define pl_openEmptyLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyLocaleRuns)\n#define pl_openEmptyValueRuns U_ICU_ENTRY_POINT_RENAME(pl_openEmptyValueRuns)\n#define pl_openFontRuns U_ICU_ENTRY_POINT_RENAME(pl_openFontRuns)\n#define pl_openLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_openLocaleRuns)\n#define pl_openValueRuns U_ICU_ENTRY_POINT_RENAME(pl_openValueRuns)\n#define pl_reflow U_ICU_ENTRY_POINT_RENAME(pl_reflow)\n#define pl_resetFontRuns U_ICU_ENTRY_POINT_RENAME(pl_resetFontRuns)\n#define pl_resetLocaleRuns U_ICU_ENTRY_POINT_RENAME(pl_resetLocaleRuns)\n#define pl_resetValueRuns U_ICU_ENTRY_POINT_RENAME(pl_resetValueRuns)\n#define res_countArrayItems U_ICU_ENTRY_POINT_RENAME(res_countArrayItems)\n#define res_findResource U_ICU_ENTRY_POINT_RENAME(res_findResource)\n#define res_getAlias U_ICU_ENTRY_POINT_RENAME(res_getAlias)\n#define res_getArrayItem U_ICU_ENTRY_POINT_RENAME(res_getArrayItem)\n#define res_getBinary U_ICU_ENTRY_POINT_RENAME(res_getBinary)\n#define res_getIntVector U_ICU_ENTRY_POINT_RENAME(res_getIntVector)\n#define res_getPublicType U_ICU_ENTRY_POINT_RENAME(res_getPublicType)\n#define res_getResource U_ICU_ENTRY_POINT_RENAME(res_getResource)\n#define res_getString U_ICU_ENTRY_POINT_RENAME(res_getString)\n#define res_getTableItemByIndex U_ICU_ENTRY_POINT_RENAME(res_getTableItemByIndex)\n#define res_getTableItemByKey U_ICU_ENTRY_POINT_RENAME(res_getTableItemByKey)\n#define res_load U_ICU_ENTRY_POINT_RENAME(res_load)\n#define res_read U_ICU_ENTRY_POINT_RENAME(res_read)\n#define res_unload U_ICU_ENTRY_POINT_RENAME(res_unload)\n#define u_UCharsToChars U_ICU_ENTRY_POINT_RENAME(u_UCharsToChars)\n#define u_austrcpy U_ICU_ENTRY_POINT_RENAME(u_austrcpy)\n#define u_austrncpy U_ICU_ENTRY_POINT_RENAME(u_austrncpy)\n#define u_caseInsensitivePrefixMatch U_ICU_ENTRY_POINT_RENAME(u_caseInsensitivePrefixMatch)\n#define u_catclose U_ICU_ENTRY_POINT_RENAME(u_catclose)\n#define u_catgets U_ICU_ENTRY_POINT_RENAME(u_catgets)\n#define u_catopen U_ICU_ENTRY_POINT_RENAME(u_catopen)\n#define u_charAge U_ICU_ENTRY_POINT_RENAME(u_charAge)\n#define u_charDigitValue U_ICU_ENTRY_POINT_RENAME(u_charDigitValue)\n#define u_charDirection U_ICU_ENTRY_POINT_RENAME(u_charDirection)\n#define u_charFromName U_ICU_ENTRY_POINT_RENAME(u_charFromName)\n#define u_charMirror U_ICU_ENTRY_POINT_RENAME(u_charMirror)\n#define u_charName U_ICU_ENTRY_POINT_RENAME(u_charName)\n#define u_charType U_ICU_ENTRY_POINT_RENAME(u_charType)\n#define u_charsToUChars U_ICU_ENTRY_POINT_RENAME(u_charsToUChars)\n#define u_cleanup U_ICU_ENTRY_POINT_RENAME(u_cleanup)\n#define u_countChar32 U_ICU_ENTRY_POINT_RENAME(u_countChar32)\n#define u_digit U_ICU_ENTRY_POINT_RENAME(u_digit)\n#define u_enumCharNames U_ICU_ENTRY_POINT_RENAME(u_enumCharNames)\n#define u_enumCharTypes U_ICU_ENTRY_POINT_RENAME(u_enumCharTypes)\n#define u_errorName U_ICU_ENTRY_POINT_RENAME(u_errorName)\n#define u_fadopt U_ICU_ENTRY_POINT_RENAME(u_fadopt)\n#define u_fclose U_ICU_ENTRY_POINT_RENAME(u_fclose)\n#define u_feof U_ICU_ENTRY_POINT_RENAME(u_feof)\n#define u_fflush U_ICU_ENTRY_POINT_RENAME(u_fflush)\n#define u_fgetConverter U_ICU_ENTRY_POINT_RENAME(u_fgetConverter)\n#define u_fgetNumberFormat U_ICU_ENTRY_POINT_RENAME(u_fgetNumberFormat)\n#define u_fgetc U_ICU_ENTRY_POINT_RENAME(u_fgetc)\n#define u_fgetcodepage U_ICU_ENTRY_POINT_RENAME(u_fgetcodepage)\n#define u_fgetcx U_ICU_ENTRY_POINT_RENAME(u_fgetcx)\n#define u_fgetfile U_ICU_ENTRY_POINT_RENAME(u_fgetfile)\n#define u_fgetlocale U_ICU_ENTRY_POINT_RENAME(u_fgetlocale)\n#define u_fgets U_ICU_ENTRY_POINT_RENAME(u_fgets)\n#define u_file_read U_ICU_ENTRY_POINT_RENAME(u_file_read)\n#define u_file_write U_ICU_ENTRY_POINT_RENAME(u_file_write)\n#define u_file_write_flush U_ICU_ENTRY_POINT_RENAME(u_file_write_flush)\n#define u_finit U_ICU_ENTRY_POINT_RENAME(u_finit)\n#define u_flushDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_flushDefaultConverter)\n#define u_foldCase U_ICU_ENTRY_POINT_RENAME(u_foldCase)\n#define u_fopen U_ICU_ENTRY_POINT_RENAME(u_fopen)\n#define u_fopen_u U_ICU_ENTRY_POINT_RENAME(u_fopen_u)\n#define u_forDigit U_ICU_ENTRY_POINT_RENAME(u_forDigit)\n#define u_formatMessage U_ICU_ENTRY_POINT_RENAME(u_formatMessage)\n#define u_formatMessageWithError U_ICU_ENTRY_POINT_RENAME(u_formatMessageWithError)\n#define u_fprintf U_ICU_ENTRY_POINT_RENAME(u_fprintf)\n#define u_fprintf_u U_ICU_ENTRY_POINT_RENAME(u_fprintf_u)\n#define u_fputc U_ICU_ENTRY_POINT_RENAME(u_fputc)\n#define u_fputs U_ICU_ENTRY_POINT_RENAME(u_fputs)\n#define u_frewind U_ICU_ENTRY_POINT_RENAME(u_frewind)\n#define u_fscanf U_ICU_ENTRY_POINT_RENAME(u_fscanf)\n#define u_fscanf_u U_ICU_ENTRY_POINT_RENAME(u_fscanf_u)\n#define u_fsetcodepage U_ICU_ENTRY_POINT_RENAME(u_fsetcodepage)\n#define u_fsetlocale U_ICU_ENTRY_POINT_RENAME(u_fsetlocale)\n#define u_fsettransliterator U_ICU_ENTRY_POINT_RENAME(u_fsettransliterator)\n#define u_fstropen U_ICU_ENTRY_POINT_RENAME(u_fstropen)\n#define u_fungetc U_ICU_ENTRY_POINT_RENAME(u_fungetc)\n#define u_getBidiPairedBracket U_ICU_ENTRY_POINT_RENAME(u_getBidiPairedBracket)\n#define u_getCombiningClass U_ICU_ENTRY_POINT_RENAME(u_getCombiningClass)\n#define u_getDataDirectory U_ICU_ENTRY_POINT_RENAME(u_getDataDirectory)\n#define u_getDataVersion U_ICU_ENTRY_POINT_RENAME(u_getDataVersion)\n#define u_getDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_getDefaultConverter)\n#define u_getFC_NFKC_Closure U_ICU_ENTRY_POINT_RENAME(u_getFC_NFKC_Closure)\n#define u_getISOComment U_ICU_ENTRY_POINT_RENAME(u_getISOComment)\n#define u_getIntPropertyMaxValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMaxValue)\n#define u_getIntPropertyMinValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMinValue)\n#define u_getIntPropertyValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyValue)\n#define u_getMainProperties U_ICU_ENTRY_POINT_RENAME(u_getMainProperties)\n#define u_getNumericValue U_ICU_ENTRY_POINT_RENAME(u_getNumericValue)\n#define u_getPropertyEnum U_ICU_ENTRY_POINT_RENAME(u_getPropertyEnum)\n#define u_getPropertyName U_ICU_ENTRY_POINT_RENAME(u_getPropertyName)\n#define u_getPropertyValueEnum U_ICU_ENTRY_POINT_RENAME(u_getPropertyValueEnum)\n#define u_getPropertyValueName U_ICU_ENTRY_POINT_RENAME(u_getPropertyValueName)\n#define u_getTimeZoneFilesDirectory U_ICU_ENTRY_POINT_RENAME(u_getTimeZoneFilesDirectory)\n#define u_getUnicodeProperties U_ICU_ENTRY_POINT_RENAME(u_getUnicodeProperties)\n#define u_getUnicodeVersion U_ICU_ENTRY_POINT_RENAME(u_getUnicodeVersion)\n#define u_getVersion U_ICU_ENTRY_POINT_RENAME(u_getVersion)\n#define u_get_stdout U_ICU_ENTRY_POINT_RENAME(u_get_stdout)\n#define u_hasBinaryProperty U_ICU_ENTRY_POINT_RENAME(u_hasBinaryProperty)\n#define u_init U_ICU_ENTRY_POINT_RENAME(u_init)\n#define u_isIDIgnorable U_ICU_ENTRY_POINT_RENAME(u_isIDIgnorable)\n#define u_isIDPart U_ICU_ENTRY_POINT_RENAME(u_isIDPart)\n#define u_isIDStart U_ICU_ENTRY_POINT_RENAME(u_isIDStart)\n#define u_isISOControl U_ICU_ENTRY_POINT_RENAME(u_isISOControl)\n#define u_isJavaIDPart U_ICU_ENTRY_POINT_RENAME(u_isJavaIDPart)\n#define u_isJavaIDStart U_ICU_ENTRY_POINT_RENAME(u_isJavaIDStart)\n#define u_isJavaSpaceChar U_ICU_ENTRY_POINT_RENAME(u_isJavaSpaceChar)\n#define u_isMirrored U_ICU_ENTRY_POINT_RENAME(u_isMirrored)\n#define u_isUAlphabetic U_ICU_ENTRY_POINT_RENAME(u_isUAlphabetic)\n#define u_isULowercase U_ICU_ENTRY_POINT_RENAME(u_isULowercase)\n#define u_isUUppercase U_ICU_ENTRY_POINT_RENAME(u_isUUppercase)\n#define u_isUWhiteSpace U_ICU_ENTRY_POINT_RENAME(u_isUWhiteSpace)\n#define u_isWhitespace U_ICU_ENTRY_POINT_RENAME(u_isWhitespace)\n#define u_isalnum U_ICU_ENTRY_POINT_RENAME(u_isalnum)\n#define u_isalnumPOSIX U_ICU_ENTRY_POINT_RENAME(u_isalnumPOSIX)\n#define u_isalpha U_ICU_ENTRY_POINT_RENAME(u_isalpha)\n#define u_isbase U_ICU_ENTRY_POINT_RENAME(u_isbase)\n#define u_isblank U_ICU_ENTRY_POINT_RENAME(u_isblank)\n#define u_iscntrl U_ICU_ENTRY_POINT_RENAME(u_iscntrl)\n#define u_isdefined U_ICU_ENTRY_POINT_RENAME(u_isdefined)\n#define u_isdigit U_ICU_ENTRY_POINT_RENAME(u_isdigit)\n#define u_isgraph U_ICU_ENTRY_POINT_RENAME(u_isgraph)\n#define u_isgraphPOSIX U_ICU_ENTRY_POINT_RENAME(u_isgraphPOSIX)\n#define u_islower U_ICU_ENTRY_POINT_RENAME(u_islower)\n#define u_isprint U_ICU_ENTRY_POINT_RENAME(u_isprint)\n#define u_isprintPOSIX U_ICU_ENTRY_POINT_RENAME(u_isprintPOSIX)\n#define u_ispunct U_ICU_ENTRY_POINT_RENAME(u_ispunct)\n#define u_isspace U_ICU_ENTRY_POINT_RENAME(u_isspace)\n#define u_istitle U_ICU_ENTRY_POINT_RENAME(u_istitle)\n#define u_isupper U_ICU_ENTRY_POINT_RENAME(u_isupper)\n#define u_isxdigit U_ICU_ENTRY_POINT_RENAME(u_isxdigit)\n#define u_locbund_close U_ICU_ENTRY_POINT_RENAME(u_locbund_close)\n#define u_locbund_getNumberFormat U_ICU_ENTRY_POINT_RENAME(u_locbund_getNumberFormat)\n#define u_locbund_init U_ICU_ENTRY_POINT_RENAME(u_locbund_init)\n#define u_memcasecmp U_ICU_ENTRY_POINT_RENAME(u_memcasecmp)\n#define u_memchr U_ICU_ENTRY_POINT_RENAME(u_memchr)\n#define u_memchr32 U_ICU_ENTRY_POINT_RENAME(u_memchr32)\n#define u_memcmp U_ICU_ENTRY_POINT_RENAME(u_memcmp)\n#define u_memcmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_memcmpCodePointOrder)\n#define u_memcpy U_ICU_ENTRY_POINT_RENAME(u_memcpy)\n#define u_memmove U_ICU_ENTRY_POINT_RENAME(u_memmove)\n#define u_memrchr U_ICU_ENTRY_POINT_RENAME(u_memrchr)\n#define u_memrchr32 U_ICU_ENTRY_POINT_RENAME(u_memrchr32)\n#define u_memset U_ICU_ENTRY_POINT_RENAME(u_memset)\n#define u_parseMessage U_ICU_ENTRY_POINT_RENAME(u_parseMessage)\n#define u_parseMessageWithError U_ICU_ENTRY_POINT_RENAME(u_parseMessageWithError)\n#define u_printf U_ICU_ENTRY_POINT_RENAME(u_printf)\n#define u_printf_parse U_ICU_ENTRY_POINT_RENAME(u_printf_parse)\n#define u_printf_u U_ICU_ENTRY_POINT_RENAME(u_printf_u)\n#define u_releaseDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_releaseDefaultConverter)\n#define u_scanf_parse U_ICU_ENTRY_POINT_RENAME(u_scanf_parse)\n#define u_setAtomicIncDecFunctions U_ICU_ENTRY_POINT_RENAME(u_setAtomicIncDecFunctions)\n#define u_setDataDirectory U_ICU_ENTRY_POINT_RENAME(u_setDataDirectory)\n#define u_setMemoryFunctions U_ICU_ENTRY_POINT_RENAME(u_setMemoryFunctions)\n#define u_setMutexFunctions U_ICU_ENTRY_POINT_RENAME(u_setMutexFunctions)\n#define u_setTimeZoneFilesDirectory U_ICU_ENTRY_POINT_RENAME(u_setTimeZoneFilesDirectory)\n#define u_shapeArabic U_ICU_ENTRY_POINT_RENAME(u_shapeArabic)\n#define u_snprintf U_ICU_ENTRY_POINT_RENAME(u_snprintf)\n#define u_snprintf_u U_ICU_ENTRY_POINT_RENAME(u_snprintf_u)\n#define u_sprintf U_ICU_ENTRY_POINT_RENAME(u_sprintf)\n#define u_sprintf_u U_ICU_ENTRY_POINT_RENAME(u_sprintf_u)\n#define u_sscanf U_ICU_ENTRY_POINT_RENAME(u_sscanf)\n#define u_sscanf_u U_ICU_ENTRY_POINT_RENAME(u_sscanf_u)\n#define u_strCaseCompare U_ICU_ENTRY_POINT_RENAME(u_strCaseCompare)\n#define u_strCompare U_ICU_ENTRY_POINT_RENAME(u_strCompare)\n#define u_strCompareIter U_ICU_ENTRY_POINT_RENAME(u_strCompareIter)\n#define u_strFindFirst U_ICU_ENTRY_POINT_RENAME(u_strFindFirst)\n#define u_strFindLast U_ICU_ENTRY_POINT_RENAME(u_strFindLast)\n#define u_strFoldCase U_ICU_ENTRY_POINT_RENAME(u_strFoldCase)\n#define u_strFromJavaModifiedUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromJavaModifiedUTF8WithSub)\n#define u_strFromPunycode U_ICU_ENTRY_POINT_RENAME(u_strFromPunycode)\n#define u_strFromUTF32 U_ICU_ENTRY_POINT_RENAME(u_strFromUTF32)\n#define u_strFromUTF32WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromUTF32WithSub)\n#define u_strFromUTF8 U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8)\n#define u_strFromUTF8Lenient U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8Lenient)\n#define u_strFromUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strFromUTF8WithSub)\n#define u_strFromWCS U_ICU_ENTRY_POINT_RENAME(u_strFromWCS)\n#define u_strHasMoreChar32Than U_ICU_ENTRY_POINT_RENAME(u_strHasMoreChar32Than)\n#define u_strToJavaModifiedUTF8 U_ICU_ENTRY_POINT_RENAME(u_strToJavaModifiedUTF8)\n#define u_strToLower U_ICU_ENTRY_POINT_RENAME(u_strToLower)\n#define u_strToPunycode U_ICU_ENTRY_POINT_RENAME(u_strToPunycode)\n#define u_strToTitle U_ICU_ENTRY_POINT_RENAME(u_strToTitle)\n#define u_strToUTF32 U_ICU_ENTRY_POINT_RENAME(u_strToUTF32)\n#define u_strToUTF32WithSub U_ICU_ENTRY_POINT_RENAME(u_strToUTF32WithSub)\n#define u_strToUTF8 U_ICU_ENTRY_POINT_RENAME(u_strToUTF8)\n#define u_strToUTF8WithSub U_ICU_ENTRY_POINT_RENAME(u_strToUTF8WithSub)\n#define u_strToUpper U_ICU_ENTRY_POINT_RENAME(u_strToUpper)\n#define u_strToWCS U_ICU_ENTRY_POINT_RENAME(u_strToWCS)\n#define u_strcasecmp U_ICU_ENTRY_POINT_RENAME(u_strcasecmp)\n#define u_strcat U_ICU_ENTRY_POINT_RENAME(u_strcat)\n#define u_strchr U_ICU_ENTRY_POINT_RENAME(u_strchr)\n#define u_strchr32 U_ICU_ENTRY_POINT_RENAME(u_strchr32)\n#define u_strcmp U_ICU_ENTRY_POINT_RENAME(u_strcmp)\n#define u_strcmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_strcmpCodePointOrder)\n#define u_strcmpFold U_ICU_ENTRY_POINT_RENAME(u_strcmpFold)\n#define u_strcpy U_ICU_ENTRY_POINT_RENAME(u_strcpy)\n#define u_strcspn U_ICU_ENTRY_POINT_RENAME(u_strcspn)\n#define u_strlen U_ICU_ENTRY_POINT_RENAME(u_strlen)\n#define u_strncasecmp U_ICU_ENTRY_POINT_RENAME(u_strncasecmp)\n#define u_strncat U_ICU_ENTRY_POINT_RENAME(u_strncat)\n#define u_strncmp U_ICU_ENTRY_POINT_RENAME(u_strncmp)\n#define u_strncmpCodePointOrder U_ICU_ENTRY_POINT_RENAME(u_strncmpCodePointOrder)\n#define u_strncpy U_ICU_ENTRY_POINT_RENAME(u_strncpy)\n#define u_strpbrk U_ICU_ENTRY_POINT_RENAME(u_strpbrk)\n#define u_strrchr U_ICU_ENTRY_POINT_RENAME(u_strrchr)\n#define u_strrchr32 U_ICU_ENTRY_POINT_RENAME(u_strrchr32)\n#define u_strrstr U_ICU_ENTRY_POINT_RENAME(u_strrstr)\n#define u_strspn U_ICU_ENTRY_POINT_RENAME(u_strspn)\n#define u_strstr U_ICU_ENTRY_POINT_RENAME(u_strstr)\n#define u_strtok_r U_ICU_ENTRY_POINT_RENAME(u_strtok_r)\n#define u_terminateChars U_ICU_ENTRY_POINT_RENAME(u_terminateChars)\n#define u_terminateUChar32s U_ICU_ENTRY_POINT_RENAME(u_terminateUChar32s)\n#define u_terminateUChars U_ICU_ENTRY_POINT_RENAME(u_terminateUChars)\n#define u_terminateWChars U_ICU_ENTRY_POINT_RENAME(u_terminateWChars)\n#define u_tolower U_ICU_ENTRY_POINT_RENAME(u_tolower)\n#define u_totitle U_ICU_ENTRY_POINT_RENAME(u_totitle)\n#define u_toupper U_ICU_ENTRY_POINT_RENAME(u_toupper)\n#define u_uastrcpy U_ICU_ENTRY_POINT_RENAME(u_uastrcpy)\n#define u_uastrncpy U_ICU_ENTRY_POINT_RENAME(u_uastrncpy)\n#define u_unescape U_ICU_ENTRY_POINT_RENAME(u_unescape)\n#define u_unescapeAt U_ICU_ENTRY_POINT_RENAME(u_unescapeAt)\n#define u_versionFromString U_ICU_ENTRY_POINT_RENAME(u_versionFromString)\n#define u_versionFromUString U_ICU_ENTRY_POINT_RENAME(u_versionFromUString)\n#define u_versionToString U_ICU_ENTRY_POINT_RENAME(u_versionToString)\n#define u_vformatMessage U_ICU_ENTRY_POINT_RENAME(u_vformatMessage)\n#define u_vformatMessageWithError U_ICU_ENTRY_POINT_RENAME(u_vformatMessageWithError)\n#define u_vfprintf U_ICU_ENTRY_POINT_RENAME(u_vfprintf)\n#define u_vfprintf_u U_ICU_ENTRY_POINT_RENAME(u_vfprintf_u)\n#define u_vfscanf U_ICU_ENTRY_POINT_RENAME(u_vfscanf)\n#define u_vfscanf_u U_ICU_ENTRY_POINT_RENAME(u_vfscanf_u)\n#define u_vparseMessage U_ICU_ENTRY_POINT_RENAME(u_vparseMessage)\n#define u_vparseMessageWithError U_ICU_ENTRY_POINT_RENAME(u_vparseMessageWithError)\n#define u_vsnprintf U_ICU_ENTRY_POINT_RENAME(u_vsnprintf)\n#define u_vsnprintf_u U_ICU_ENTRY_POINT_RENAME(u_vsnprintf_u)\n#define u_vsprintf U_ICU_ENTRY_POINT_RENAME(u_vsprintf)\n#define u_vsprintf_u U_ICU_ENTRY_POINT_RENAME(u_vsprintf_u)\n#define u_vsscanf U_ICU_ENTRY_POINT_RENAME(u_vsscanf)\n#define u_vsscanf_u U_ICU_ENTRY_POINT_RENAME(u_vsscanf_u)\n#define u_writeIdenticalLevelRun U_ICU_ENTRY_POINT_RENAME(u_writeIdenticalLevelRun)\n#define ubidi_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(ubidi_addPropertyStarts)\n#define ubidi_close U_ICU_ENTRY_POINT_RENAME(ubidi_close)\n#define ubidi_countParagraphs U_ICU_ENTRY_POINT_RENAME(ubidi_countParagraphs)\n#define ubidi_countRuns U_ICU_ENTRY_POINT_RENAME(ubidi_countRuns)\n#define ubidi_getBaseDirection U_ICU_ENTRY_POINT_RENAME(ubidi_getBaseDirection)\n#define ubidi_getClass U_ICU_ENTRY_POINT_RENAME(ubidi_getClass)\n#define ubidi_getClassCallback U_ICU_ENTRY_POINT_RENAME(ubidi_getClassCallback)\n#define ubidi_getCustomizedClass U_ICU_ENTRY_POINT_RENAME(ubidi_getCustomizedClass)\n#define ubidi_getDirection U_ICU_ENTRY_POINT_RENAME(ubidi_getDirection)\n#define ubidi_getJoiningGroup U_ICU_ENTRY_POINT_RENAME(ubidi_getJoiningGroup)\n#define ubidi_getJoiningType U_ICU_ENTRY_POINT_RENAME(ubidi_getJoiningType)\n#define ubidi_getLength U_ICU_ENTRY_POINT_RENAME(ubidi_getLength)\n#define ubidi_getLevelAt U_ICU_ENTRY_POINT_RENAME(ubidi_getLevelAt)\n#define ubidi_getLevels U_ICU_ENTRY_POINT_RENAME(ubidi_getLevels)\n#define ubidi_getLogicalIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalIndex)\n#define ubidi_getLogicalMap U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalMap)\n#define ubidi_getLogicalRun U_ICU_ENTRY_POINT_RENAME(ubidi_getLogicalRun)\n#define ubidi_getMaxValue U_ICU_ENTRY_POINT_RENAME(ubidi_getMaxValue)\n#define ubidi_getMemory U_ICU_ENTRY_POINT_RENAME(ubidi_getMemory)\n#define ubidi_getMirror U_ICU_ENTRY_POINT_RENAME(ubidi_getMirror)\n#define ubidi_getPairedBracket U_ICU_ENTRY_POINT_RENAME(ubidi_getPairedBracket)\n#define ubidi_getPairedBracketType U_ICU_ENTRY_POINT_RENAME(ubidi_getPairedBracketType)\n#define ubidi_getParaLevel U_ICU_ENTRY_POINT_RENAME(ubidi_getParaLevel)\n#define ubidi_getParaLevelAtIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getParaLevelAtIndex)\n#define ubidi_getParagraph U_ICU_ENTRY_POINT_RENAME(ubidi_getParagraph)\n#define ubidi_getParagraphByIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getParagraphByIndex)\n#define ubidi_getProcessedLength U_ICU_ENTRY_POINT_RENAME(ubidi_getProcessedLength)\n#define ubidi_getReorderingMode U_ICU_ENTRY_POINT_RENAME(ubidi_getReorderingMode)\n#define ubidi_getReorderingOptions U_ICU_ENTRY_POINT_RENAME(ubidi_getReorderingOptions)\n#define ubidi_getResultLength U_ICU_ENTRY_POINT_RENAME(ubidi_getResultLength)\n#define ubidi_getRuns U_ICU_ENTRY_POINT_RENAME(ubidi_getRuns)\n#define ubidi_getSingleton U_ICU_ENTRY_POINT_RENAME(ubidi_getSingleton)\n#define ubidi_getText U_ICU_ENTRY_POINT_RENAME(ubidi_getText)\n#define ubidi_getVisualIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualIndex)\n#define ubidi_getVisualMap U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualMap)\n#define ubidi_getVisualRun U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualRun)\n#define ubidi_invertMap U_ICU_ENTRY_POINT_RENAME(ubidi_invertMap)\n#define ubidi_isBidiControl U_ICU_ENTRY_POINT_RENAME(ubidi_isBidiControl)\n#define ubidi_isInverse U_ICU_ENTRY_POINT_RENAME(ubidi_isInverse)\n#define ubidi_isJoinControl U_ICU_ENTRY_POINT_RENAME(ubidi_isJoinControl)\n#define ubidi_isMirrored U_ICU_ENTRY_POINT_RENAME(ubidi_isMirrored)\n#define ubidi_isOrderParagraphsLTR U_ICU_ENTRY_POINT_RENAME(ubidi_isOrderParagraphsLTR)\n#define ubidi_open U_ICU_ENTRY_POINT_RENAME(ubidi_open)\n#define ubidi_openSized U_ICU_ENTRY_POINT_RENAME(ubidi_openSized)\n#define ubidi_orderParagraphsLTR U_ICU_ENTRY_POINT_RENAME(ubidi_orderParagraphsLTR)\n#define ubidi_reorderLogical U_ICU_ENTRY_POINT_RENAME(ubidi_reorderLogical)\n#define ubidi_reorderVisual U_ICU_ENTRY_POINT_RENAME(ubidi_reorderVisual)\n#define ubidi_setClassCallback U_ICU_ENTRY_POINT_RENAME(ubidi_setClassCallback)\n#define ubidi_setContext U_ICU_ENTRY_POINT_RENAME(ubidi_setContext)\n#define ubidi_setInverse U_ICU_ENTRY_POINT_RENAME(ubidi_setInverse)\n#define ubidi_setLine U_ICU_ENTRY_POINT_RENAME(ubidi_setLine)\n#define ubidi_setPara U_ICU_ENTRY_POINT_RENAME(ubidi_setPara)\n#define ubidi_setReorderingMode U_ICU_ENTRY_POINT_RENAME(ubidi_setReorderingMode)\n#define ubidi_setReorderingOptions U_ICU_ENTRY_POINT_RENAME(ubidi_setReorderingOptions)\n#define ubidi_writeReordered U_ICU_ENTRY_POINT_RENAME(ubidi_writeReordered)\n#define ubidi_writeReverse U_ICU_ENTRY_POINT_RENAME(ubidi_writeReverse)\n#define ublock_getCode U_ICU_ENTRY_POINT_RENAME(ublock_getCode)\n#define ubrk_close U_ICU_ENTRY_POINT_RENAME(ubrk_close)\n#define ubrk_countAvailable U_ICU_ENTRY_POINT_RENAME(ubrk_countAvailable)\n#define ubrk_current U_ICU_ENTRY_POINT_RENAME(ubrk_current)\n#define ubrk_first U_ICU_ENTRY_POINT_RENAME(ubrk_first)\n#define ubrk_following U_ICU_ENTRY_POINT_RENAME(ubrk_following)\n#define ubrk_getAvailable U_ICU_ENTRY_POINT_RENAME(ubrk_getAvailable)\n#define ubrk_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ubrk_getLocaleByType)\n#define ubrk_getRuleStatus U_ICU_ENTRY_POINT_RENAME(ubrk_getRuleStatus)\n#define ubrk_getRuleStatusVec U_ICU_ENTRY_POINT_RENAME(ubrk_getRuleStatusVec)\n#define ubrk_isBoundary U_ICU_ENTRY_POINT_RENAME(ubrk_isBoundary)\n#define ubrk_last U_ICU_ENTRY_POINT_RENAME(ubrk_last)\n#define ubrk_next U_ICU_ENTRY_POINT_RENAME(ubrk_next)\n#define ubrk_open U_ICU_ENTRY_POINT_RENAME(ubrk_open)\n#define ubrk_openRules U_ICU_ENTRY_POINT_RENAME(ubrk_openRules)\n#define ubrk_preceding U_ICU_ENTRY_POINT_RENAME(ubrk_preceding)\n#define ubrk_previous U_ICU_ENTRY_POINT_RENAME(ubrk_previous)\n#define ubrk_refreshUText U_ICU_ENTRY_POINT_RENAME(ubrk_refreshUText)\n#define ubrk_safeClone U_ICU_ENTRY_POINT_RENAME(ubrk_safeClone)\n#define ubrk_setText U_ICU_ENTRY_POINT_RENAME(ubrk_setText)\n#define ubrk_setUText U_ICU_ENTRY_POINT_RENAME(ubrk_setUText)\n#define ubrk_swap U_ICU_ENTRY_POINT_RENAME(ubrk_swap)\n#define ucache_compareKeys U_ICU_ENTRY_POINT_RENAME(ucache_compareKeys)\n#define ucache_deleteKey U_ICU_ENTRY_POINT_RENAME(ucache_deleteKey)\n#define ucache_hashKeys U_ICU_ENTRY_POINT_RENAME(ucache_hashKeys)\n#define ucal_add U_ICU_ENTRY_POINT_RENAME(ucal_add)\n#define ucal_clear U_ICU_ENTRY_POINT_RENAME(ucal_clear)\n#define ucal_clearField U_ICU_ENTRY_POINT_RENAME(ucal_clearField)\n#define ucal_clone U_ICU_ENTRY_POINT_RENAME(ucal_clone)\n#define ucal_close U_ICU_ENTRY_POINT_RENAME(ucal_close)\n#define ucal_countAvailable U_ICU_ENTRY_POINT_RENAME(ucal_countAvailable)\n#define ucal_equivalentTo U_ICU_ENTRY_POINT_RENAME(ucal_equivalentTo)\n#define ucal_get U_ICU_ENTRY_POINT_RENAME(ucal_get)\n#define ucal_getAttribute U_ICU_ENTRY_POINT_RENAME(ucal_getAttribute)\n#define ucal_getAvailable U_ICU_ENTRY_POINT_RENAME(ucal_getAvailable)\n#define ucal_getCanonicalTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getCanonicalTimeZoneID)\n#define ucal_getDSTSavings U_ICU_ENTRY_POINT_RENAME(ucal_getDSTSavings)\n#define ucal_getDayOfWeekType U_ICU_ENTRY_POINT_RENAME(ucal_getDayOfWeekType)\n#define ucal_getDefaultTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_getDefaultTimeZone)\n#define ucal_getFieldDifference U_ICU_ENTRY_POINT_RENAME(ucal_getFieldDifference)\n#define ucal_getGregorianChange U_ICU_ENTRY_POINT_RENAME(ucal_getGregorianChange)\n#define ucal_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucal_getKeywordValuesForLocale)\n#define ucal_getLimit U_ICU_ENTRY_POINT_RENAME(ucal_getLimit)\n#define ucal_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ucal_getLocaleByType)\n#define ucal_getMillis U_ICU_ENTRY_POINT_RENAME(ucal_getMillis)\n#define ucal_getNow U_ICU_ENTRY_POINT_RENAME(ucal_getNow)\n#define ucal_getTZDataVersion U_ICU_ENTRY_POINT_RENAME(ucal_getTZDataVersion)\n#define ucal_getTimeZoneDisplayName U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneDisplayName)\n#define ucal_getTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneID)\n#define ucal_getTimeZoneIDForWindowsID U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneIDForWindowsID)\n#define ucal_getTimeZoneTransitionDate U_ICU_ENTRY_POINT_RENAME(ucal_getTimeZoneTransitionDate)\n#define ucal_getType U_ICU_ENTRY_POINT_RENAME(ucal_getType)\n#define ucal_getWeekendTransition U_ICU_ENTRY_POINT_RENAME(ucal_getWeekendTransition)\n#define ucal_getWindowsTimeZoneID U_ICU_ENTRY_POINT_RENAME(ucal_getWindowsTimeZoneID)\n#define ucal_inDaylightTime U_ICU_ENTRY_POINT_RENAME(ucal_inDaylightTime)\n#define ucal_isSet U_ICU_ENTRY_POINT_RENAME(ucal_isSet)\n#define ucal_isWeekend U_ICU_ENTRY_POINT_RENAME(ucal_isWeekend)\n#define ucal_open U_ICU_ENTRY_POINT_RENAME(ucal_open)\n#define ucal_openCountryTimeZones U_ICU_ENTRY_POINT_RENAME(ucal_openCountryTimeZones)\n#define ucal_openTimeZoneIDEnumeration U_ICU_ENTRY_POINT_RENAME(ucal_openTimeZoneIDEnumeration)\n#define ucal_openTimeZones U_ICU_ENTRY_POINT_RENAME(ucal_openTimeZones)\n#define ucal_roll U_ICU_ENTRY_POINT_RENAME(ucal_roll)\n#define ucal_set U_ICU_ENTRY_POINT_RENAME(ucal_set)\n#define ucal_setAttribute U_ICU_ENTRY_POINT_RENAME(ucal_setAttribute)\n#define ucal_setDate U_ICU_ENTRY_POINT_RENAME(ucal_setDate)\n#define ucal_setDateTime U_ICU_ENTRY_POINT_RENAME(ucal_setDateTime)\n#define ucal_setDefaultTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_setDefaultTimeZone)\n#define ucal_setGregorianChange U_ICU_ENTRY_POINT_RENAME(ucal_setGregorianChange)\n#define ucal_setMillis U_ICU_ENTRY_POINT_RENAME(ucal_setMillis)\n#define ucal_setTimeZone U_ICU_ENTRY_POINT_RENAME(ucal_setTimeZone)\n#define ucase_addCaseClosure U_ICU_ENTRY_POINT_RENAME(ucase_addCaseClosure)\n#define ucase_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(ucase_addPropertyStarts)\n#define ucase_addStringCaseClosure U_ICU_ENTRY_POINT_RENAME(ucase_addStringCaseClosure)\n#define ucase_fold U_ICU_ENTRY_POINT_RENAME(ucase_fold)\n#define ucase_getCaseLocale U_ICU_ENTRY_POINT_RENAME(ucase_getCaseLocale)\n#define ucase_getSingleton U_ICU_ENTRY_POINT_RENAME(ucase_getSingleton)\n#define ucase_getType U_ICU_ENTRY_POINT_RENAME(ucase_getType)\n#define ucase_getTypeOrIgnorable U_ICU_ENTRY_POINT_RENAME(ucase_getTypeOrIgnorable)\n#define ucase_hasBinaryProperty U_ICU_ENTRY_POINT_RENAME(ucase_hasBinaryProperty)\n#define ucase_isCaseSensitive U_ICU_ENTRY_POINT_RENAME(ucase_isCaseSensitive)\n#define ucase_isSoftDotted U_ICU_ENTRY_POINT_RENAME(ucase_isSoftDotted)\n#define ucase_toFullFolding U_ICU_ENTRY_POINT_RENAME(ucase_toFullFolding)\n#define ucase_toFullLower U_ICU_ENTRY_POINT_RENAME(ucase_toFullLower)\n#define ucase_toFullTitle U_ICU_ENTRY_POINT_RENAME(ucase_toFullTitle)\n#define ucase_toFullUpper U_ICU_ENTRY_POINT_RENAME(ucase_toFullUpper)\n#define ucase_tolower U_ICU_ENTRY_POINT_RENAME(ucase_tolower)\n#define ucase_totitle U_ICU_ENTRY_POINT_RENAME(ucase_totitle)\n#define ucase_toupper U_ICU_ENTRY_POINT_RENAME(ucase_toupper)\n#define ucasemap_close U_ICU_ENTRY_POINT_RENAME(ucasemap_close)\n#define ucasemap_getBreakIterator U_ICU_ENTRY_POINT_RENAME(ucasemap_getBreakIterator)\n#define ucasemap_getLocale U_ICU_ENTRY_POINT_RENAME(ucasemap_getLocale)\n#define ucasemap_getOptions U_ICU_ENTRY_POINT_RENAME(ucasemap_getOptions)\n#define ucasemap_internalUTF8ToTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_internalUTF8ToTitle)\n#define ucasemap_mapUTF8 U_ICU_ENTRY_POINT_RENAME(ucasemap_mapUTF8)\n#define ucasemap_open U_ICU_ENTRY_POINT_RENAME(ucasemap_open)\n#define ucasemap_setBreakIterator U_ICU_ENTRY_POINT_RENAME(ucasemap_setBreakIterator)\n#define ucasemap_setLocale U_ICU_ENTRY_POINT_RENAME(ucasemap_setLocale)\n#define ucasemap_setOptions U_ICU_ENTRY_POINT_RENAME(ucasemap_setOptions)\n#define ucasemap_toTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_toTitle)\n#define ucasemap_utf8FoldCase U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8FoldCase)\n#define ucasemap_utf8ToLower U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToLower)\n#define ucasemap_utf8ToTitle U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToTitle)\n#define ucasemap_utf8ToUpper U_ICU_ENTRY_POINT_RENAME(ucasemap_utf8ToUpper)\n#define uchar_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(uchar_addPropertyStarts)\n#define uchar_swapNames U_ICU_ENTRY_POINT_RENAME(uchar_swapNames)\n#define ucln_cleanupOne U_ICU_ENTRY_POINT_RENAME(ucln_cleanupOne)\n#define ucln_common_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_common_registerCleanup)\n#define ucln_i18n_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_i18n_registerCleanup)\n#define ucln_io_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_io_registerCleanup)\n#define ucln_lib_cleanup U_ICU_ENTRY_POINT_RENAME(ucln_lib_cleanup)\n#define ucln_registerCleanup U_ICU_ENTRY_POINT_RENAME(ucln_registerCleanup)\n#define ucnv_MBCSFromUChar32 U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSFromUChar32)\n#define ucnv_MBCSFromUnicodeWithOffsets U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSFromUnicodeWithOffsets)\n#define ucnv_MBCSGetFilteredUnicodeSetForUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetFilteredUnicodeSetForUnicode)\n#define ucnv_MBCSGetType U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetType)\n#define ucnv_MBCSGetUnicodeSetForUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSGetUnicodeSetForUnicode)\n#define ucnv_MBCSIsLeadByte U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSIsLeadByte)\n#define ucnv_MBCSSimpleGetNextUChar U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSSimpleGetNextUChar)\n#define ucnv_MBCSToUnicodeWithOffsets U_ICU_ENTRY_POINT_RENAME(ucnv_MBCSToUnicodeWithOffsets)\n#define ucnv_bld_countAvailableConverters U_ICU_ENTRY_POINT_RENAME(ucnv_bld_countAvailableConverters)\n#define ucnv_bld_getAvailableConverter U_ICU_ENTRY_POINT_RENAME(ucnv_bld_getAvailableConverter)\n#define ucnv_canCreateConverter U_ICU_ENTRY_POINT_RENAME(ucnv_canCreateConverter)\n#define ucnv_cbFromUWriteBytes U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteBytes)\n#define ucnv_cbFromUWriteSub U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteSub)\n#define ucnv_cbFromUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_cbFromUWriteUChars)\n#define ucnv_cbToUWriteSub U_ICU_ENTRY_POINT_RENAME(ucnv_cbToUWriteSub)\n#define ucnv_cbToUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_cbToUWriteUChars)\n#define ucnv_close U_ICU_ENTRY_POINT_RENAME(ucnv_close)\n#define ucnv_compareNames U_ICU_ENTRY_POINT_RENAME(ucnv_compareNames)\n#define ucnv_convert U_ICU_ENTRY_POINT_RENAME(ucnv_convert)\n#define ucnv_convertEx U_ICU_ENTRY_POINT_RENAME(ucnv_convertEx)\n#define ucnv_countAliases U_ICU_ENTRY_POINT_RENAME(ucnv_countAliases)\n#define ucnv_countAvailable U_ICU_ENTRY_POINT_RENAME(ucnv_countAvailable)\n#define ucnv_countStandards U_ICU_ENTRY_POINT_RENAME(ucnv_countStandards)\n#define ucnv_createAlgorithmicConverter U_ICU_ENTRY_POINT_RENAME(ucnv_createAlgorithmicConverter)\n#define ucnv_createConverter U_ICU_ENTRY_POINT_RENAME(ucnv_createConverter)\n#define ucnv_createConverterFromPackage U_ICU_ENTRY_POINT_RENAME(ucnv_createConverterFromPackage)\n#define ucnv_createConverterFromSharedData U_ICU_ENTRY_POINT_RENAME(ucnv_createConverterFromSharedData)\n#define ucnv_detectUnicodeSignature U_ICU_ENTRY_POINT_RENAME(ucnv_detectUnicodeSignature)\n#define ucnv_extContinueMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extContinueMatchFromU)\n#define ucnv_extContinueMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extContinueMatchToU)\n#define ucnv_extGetUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_extGetUnicodeSet)\n#define ucnv_extInitialMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extInitialMatchFromU)\n#define ucnv_extInitialMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extInitialMatchToU)\n#define ucnv_extSimpleMatchFromU U_ICU_ENTRY_POINT_RENAME(ucnv_extSimpleMatchFromU)\n#define ucnv_extSimpleMatchToU U_ICU_ENTRY_POINT_RENAME(ucnv_extSimpleMatchToU)\n#define ucnv_fixFileSeparator U_ICU_ENTRY_POINT_RENAME(ucnv_fixFileSeparator)\n#define ucnv_flushCache U_ICU_ENTRY_POINT_RENAME(ucnv_flushCache)\n#define ucnv_fromAlgorithmic U_ICU_ENTRY_POINT_RENAME(ucnv_fromAlgorithmic)\n#define ucnv_fromUChars U_ICU_ENTRY_POINT_RENAME(ucnv_fromUChars)\n#define ucnv_fromUCountPending U_ICU_ENTRY_POINT_RENAME(ucnv_fromUCountPending)\n#define ucnv_fromUWriteBytes U_ICU_ENTRY_POINT_RENAME(ucnv_fromUWriteBytes)\n#define ucnv_fromUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode)\n#define ucnv_fromUnicode_UTF8 U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode_UTF8)\n#define ucnv_fromUnicode_UTF8_OFFSETS_LOGIC U_ICU_ENTRY_POINT_RENAME(ucnv_fromUnicode_UTF8_OFFSETS_LOGIC)\n#define ucnv_getAlias U_ICU_ENTRY_POINT_RENAME(ucnv_getAlias)\n#define ucnv_getAliases U_ICU_ENTRY_POINT_RENAME(ucnv_getAliases)\n#define ucnv_getAvailableName U_ICU_ENTRY_POINT_RENAME(ucnv_getAvailableName)\n#define ucnv_getCCSID U_ICU_ENTRY_POINT_RENAME(ucnv_getCCSID)\n#define ucnv_getCanonicalName U_ICU_ENTRY_POINT_RENAME(ucnv_getCanonicalName)\n#define ucnv_getCompleteUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getCompleteUnicodeSet)\n#define ucnv_getDefaultName U_ICU_ENTRY_POINT_RENAME(ucnv_getDefaultName)\n#define ucnv_getDisplayName U_ICU_ENTRY_POINT_RENAME(ucnv_getDisplayName)\n#define ucnv_getFromUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_getFromUCallBack)\n#define ucnv_getInvalidChars U_ICU_ENTRY_POINT_RENAME(ucnv_getInvalidChars)\n#define ucnv_getInvalidUChars U_ICU_ENTRY_POINT_RENAME(ucnv_getInvalidUChars)\n#define ucnv_getMaxCharSize U_ICU_ENTRY_POINT_RENAME(ucnv_getMaxCharSize)\n#define ucnv_getMinCharSize U_ICU_ENTRY_POINT_RENAME(ucnv_getMinCharSize)\n#define ucnv_getName U_ICU_ENTRY_POINT_RENAME(ucnv_getName)\n#define ucnv_getNextUChar U_ICU_ENTRY_POINT_RENAME(ucnv_getNextUChar)\n#define ucnv_getNonSurrogateUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getNonSurrogateUnicodeSet)\n#define ucnv_getPlatform U_ICU_ENTRY_POINT_RENAME(ucnv_getPlatform)\n#define ucnv_getStandard U_ICU_ENTRY_POINT_RENAME(ucnv_getStandard)\n#define ucnv_getStandardName U_ICU_ENTRY_POINT_RENAME(ucnv_getStandardName)\n#define ucnv_getStarters U_ICU_ENTRY_POINT_RENAME(ucnv_getStarters)\n#define ucnv_getSubstChars U_ICU_ENTRY_POINT_RENAME(ucnv_getSubstChars)\n#define ucnv_getToUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_getToUCallBack)\n#define ucnv_getType U_ICU_ENTRY_POINT_RENAME(ucnv_getType)\n#define ucnv_getUnicodeSet U_ICU_ENTRY_POINT_RENAME(ucnv_getUnicodeSet)\n#define ucnv_incrementRefCount U_ICU_ENTRY_POINT_RENAME(ucnv_incrementRefCount)\n#define ucnv_io_countKnownConverters U_ICU_ENTRY_POINT_RENAME(ucnv_io_countKnownConverters)\n#define ucnv_io_getConverterName U_ICU_ENTRY_POINT_RENAME(ucnv_io_getConverterName)\n#define ucnv_io_stripASCIIForCompare U_ICU_ENTRY_POINT_RENAME(ucnv_io_stripASCIIForCompare)\n#define ucnv_io_stripEBCDICForCompare U_ICU_ENTRY_POINT_RENAME(ucnv_io_stripEBCDICForCompare)\n#define ucnv_isAmbiguous U_ICU_ENTRY_POINT_RENAME(ucnv_isAmbiguous)\n#define ucnv_isFixedWidth U_ICU_ENTRY_POINT_RENAME(ucnv_isFixedWidth)\n#define ucnv_load U_ICU_ENTRY_POINT_RENAME(ucnv_load)\n#define ucnv_loadSharedData U_ICU_ENTRY_POINT_RENAME(ucnv_loadSharedData)\n#define ucnv_open U_ICU_ENTRY_POINT_RENAME(ucnv_open)\n#define ucnv_openAllNames U_ICU_ENTRY_POINT_RENAME(ucnv_openAllNames)\n#define ucnv_openCCSID U_ICU_ENTRY_POINT_RENAME(ucnv_openCCSID)\n#define ucnv_openPackage U_ICU_ENTRY_POINT_RENAME(ucnv_openPackage)\n#define ucnv_openStandardNames U_ICU_ENTRY_POINT_RENAME(ucnv_openStandardNames)\n#define ucnv_openU U_ICU_ENTRY_POINT_RENAME(ucnv_openU)\n#define ucnv_reset U_ICU_ENTRY_POINT_RENAME(ucnv_reset)\n#define ucnv_resetFromUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_resetFromUnicode)\n#define ucnv_resetToUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_resetToUnicode)\n#define ucnv_safeClone U_ICU_ENTRY_POINT_RENAME(ucnv_safeClone)\n#define ucnv_setDefaultName U_ICU_ENTRY_POINT_RENAME(ucnv_setDefaultName)\n#define ucnv_setFallback U_ICU_ENTRY_POINT_RENAME(ucnv_setFallback)\n#define ucnv_setFromUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_setFromUCallBack)\n#define ucnv_setSubstChars U_ICU_ENTRY_POINT_RENAME(ucnv_setSubstChars)\n#define ucnv_setSubstString U_ICU_ENTRY_POINT_RENAME(ucnv_setSubstString)\n#define ucnv_setToUCallBack U_ICU_ENTRY_POINT_RENAME(ucnv_setToUCallBack)\n#define ucnv_swap U_ICU_ENTRY_POINT_RENAME(ucnv_swap)\n#define ucnv_swapAliases U_ICU_ENTRY_POINT_RENAME(ucnv_swapAliases)\n#define ucnv_toAlgorithmic U_ICU_ENTRY_POINT_RENAME(ucnv_toAlgorithmic)\n#define ucnv_toUChars U_ICU_ENTRY_POINT_RENAME(ucnv_toUChars)\n#define ucnv_toUCountPending U_ICU_ENTRY_POINT_RENAME(ucnv_toUCountPending)\n#define ucnv_toUWriteCodePoint U_ICU_ENTRY_POINT_RENAME(ucnv_toUWriteCodePoint)\n#define ucnv_toUWriteUChars U_ICU_ENTRY_POINT_RENAME(ucnv_toUWriteUChars)\n#define ucnv_toUnicode U_ICU_ENTRY_POINT_RENAME(ucnv_toUnicode)\n#define ucnv_unload U_ICU_ENTRY_POINT_RENAME(ucnv_unload)\n#define ucnv_unloadSharedDataIfReady U_ICU_ENTRY_POINT_RENAME(ucnv_unloadSharedDataIfReady)\n#define ucnv_usesFallback U_ICU_ENTRY_POINT_RENAME(ucnv_usesFallback)\n#define ucnvsel_close U_ICU_ENTRY_POINT_RENAME(ucnvsel_close)\n#define ucnvsel_open U_ICU_ENTRY_POINT_RENAME(ucnvsel_open)\n#define ucnvsel_openFromSerialized U_ICU_ENTRY_POINT_RENAME(ucnvsel_openFromSerialized)\n#define ucnvsel_selectForString U_ICU_ENTRY_POINT_RENAME(ucnvsel_selectForString)\n#define ucnvsel_selectForUTF8 U_ICU_ENTRY_POINT_RENAME(ucnvsel_selectForUTF8)\n#define ucnvsel_serialize U_ICU_ENTRY_POINT_RENAME(ucnvsel_serialize)\n#define ucol_cloneBinary U_ICU_ENTRY_POINT_RENAME(ucol_cloneBinary)\n#define ucol_close U_ICU_ENTRY_POINT_RENAME(ucol_close)\n#define ucol_closeElements U_ICU_ENTRY_POINT_RENAME(ucol_closeElements)\n#define ucol_countAvailable U_ICU_ENTRY_POINT_RENAME(ucol_countAvailable)\n#define ucol_equal U_ICU_ENTRY_POINT_RENAME(ucol_equal)\n#define ucol_equals U_ICU_ENTRY_POINT_RENAME(ucol_equals)\n#define ucol_getAttribute U_ICU_ENTRY_POINT_RENAME(ucol_getAttribute)\n#define ucol_getAvailable U_ICU_ENTRY_POINT_RENAME(ucol_getAvailable)\n#define ucol_getBound U_ICU_ENTRY_POINT_RENAME(ucol_getBound)\n#define ucol_getContractions U_ICU_ENTRY_POINT_RENAME(ucol_getContractions)\n#define ucol_getContractionsAndExpansions U_ICU_ENTRY_POINT_RENAME(ucol_getContractionsAndExpansions)\n#define ucol_getDisplayName U_ICU_ENTRY_POINT_RENAME(ucol_getDisplayName)\n#define ucol_getEquivalentReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_getEquivalentReorderCodes)\n#define ucol_getFunctionalEquivalent U_ICU_ENTRY_POINT_RENAME(ucol_getFunctionalEquivalent)\n#define ucol_getKeywordValues U_ICU_ENTRY_POINT_RENAME(ucol_getKeywordValues)\n#define ucol_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucol_getKeywordValuesForLocale)\n#define ucol_getKeywords U_ICU_ENTRY_POINT_RENAME(ucol_getKeywords)\n#define ucol_getLocale U_ICU_ENTRY_POINT_RENAME(ucol_getLocale)\n#define ucol_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ucol_getLocaleByType)\n#define ucol_getMaxExpansion U_ICU_ENTRY_POINT_RENAME(ucol_getMaxExpansion)\n#define ucol_getMaxVariable U_ICU_ENTRY_POINT_RENAME(ucol_getMaxVariable)\n#define ucol_getOffset U_ICU_ENTRY_POINT_RENAME(ucol_getOffset)\n#define ucol_getReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_getReorderCodes)\n#define ucol_getRules U_ICU_ENTRY_POINT_RENAME(ucol_getRules)\n#define ucol_getRulesEx U_ICU_ENTRY_POINT_RENAME(ucol_getRulesEx)\n#define ucol_getShortDefinitionString U_ICU_ENTRY_POINT_RENAME(ucol_getShortDefinitionString)\n#define ucol_getSortKey U_ICU_ENTRY_POINT_RENAME(ucol_getSortKey)\n#define ucol_getStrength U_ICU_ENTRY_POINT_RENAME(ucol_getStrength)\n#define ucol_getTailoredSet U_ICU_ENTRY_POINT_RENAME(ucol_getTailoredSet)\n#define ucol_getUCAVersion U_ICU_ENTRY_POINT_RENAME(ucol_getUCAVersion)\n#define ucol_getUnsafeSet U_ICU_ENTRY_POINT_RENAME(ucol_getUnsafeSet)\n#define ucol_getVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_getVariableTop)\n#define ucol_getVersion U_ICU_ENTRY_POINT_RENAME(ucol_getVersion)\n#define ucol_greater U_ICU_ENTRY_POINT_RENAME(ucol_greater)\n#define ucol_greaterOrEqual U_ICU_ENTRY_POINT_RENAME(ucol_greaterOrEqual)\n#define ucol_keyHashCode U_ICU_ENTRY_POINT_RENAME(ucol_keyHashCode)\n#define ucol_looksLikeCollationBinary U_ICU_ENTRY_POINT_RENAME(ucol_looksLikeCollationBinary)\n#define ucol_mergeSortkeys U_ICU_ENTRY_POINT_RENAME(ucol_mergeSortkeys)\n#define ucol_next U_ICU_ENTRY_POINT_RENAME(ucol_next)\n#define ucol_nextSortKeyPart U_ICU_ENTRY_POINT_RENAME(ucol_nextSortKeyPart)\n#define ucol_normalizeShortDefinitionString U_ICU_ENTRY_POINT_RENAME(ucol_normalizeShortDefinitionString)\n#define ucol_open U_ICU_ENTRY_POINT_RENAME(ucol_open)\n#define ucol_openAvailableLocales U_ICU_ENTRY_POINT_RENAME(ucol_openAvailableLocales)\n#define ucol_openBinary U_ICU_ENTRY_POINT_RENAME(ucol_openBinary)\n#define ucol_openElements U_ICU_ENTRY_POINT_RENAME(ucol_openElements)\n#define ucol_openFromShortString U_ICU_ENTRY_POINT_RENAME(ucol_openFromShortString)\n#define ucol_openRules U_ICU_ENTRY_POINT_RENAME(ucol_openRules)\n#define ucol_prepareShortStringOpen U_ICU_ENTRY_POINT_RENAME(ucol_prepareShortStringOpen)\n#define ucol_previous U_ICU_ENTRY_POINT_RENAME(ucol_previous)\n#define ucol_primaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_primaryOrder)\n#define ucol_reset U_ICU_ENTRY_POINT_RENAME(ucol_reset)\n#define ucol_restoreVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_restoreVariableTop)\n#define ucol_safeClone U_ICU_ENTRY_POINT_RENAME(ucol_safeClone)\n#define ucol_secondaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_secondaryOrder)\n#define ucol_setAttribute U_ICU_ENTRY_POINT_RENAME(ucol_setAttribute)\n#define ucol_setMaxVariable U_ICU_ENTRY_POINT_RENAME(ucol_setMaxVariable)\n#define ucol_setOffset U_ICU_ENTRY_POINT_RENAME(ucol_setOffset)\n#define ucol_setReorderCodes U_ICU_ENTRY_POINT_RENAME(ucol_setReorderCodes)\n#define ucol_setStrength U_ICU_ENTRY_POINT_RENAME(ucol_setStrength)\n#define ucol_setText U_ICU_ENTRY_POINT_RENAME(ucol_setText)\n#define ucol_setVariableTop U_ICU_ENTRY_POINT_RENAME(ucol_setVariableTop)\n#define ucol_strcoll U_ICU_ENTRY_POINT_RENAME(ucol_strcoll)\n#define ucol_strcollIter U_ICU_ENTRY_POINT_RENAME(ucol_strcollIter)\n#define ucol_strcollUTF8 U_ICU_ENTRY_POINT_RENAME(ucol_strcollUTF8)\n#define ucol_swap U_ICU_ENTRY_POINT_RENAME(ucol_swap)\n#define ucol_swapInverseUCA U_ICU_ENTRY_POINT_RENAME(ucol_swapInverseUCA)\n#define ucol_tertiaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_tertiaryOrder)\n#define ucsdet_close U_ICU_ENTRY_POINT_RENAME(ucsdet_close)\n#define ucsdet_detect U_ICU_ENTRY_POINT_RENAME(ucsdet_detect)\n#define ucsdet_detectAll U_ICU_ENTRY_POINT_RENAME(ucsdet_detectAll)\n#define ucsdet_enableInputFilter U_ICU_ENTRY_POINT_RENAME(ucsdet_enableInputFilter)\n#define ucsdet_getAllDetectableCharsets U_ICU_ENTRY_POINT_RENAME(ucsdet_getAllDetectableCharsets)\n#define ucsdet_getConfidence U_ICU_ENTRY_POINT_RENAME(ucsdet_getConfidence)\n#define ucsdet_getDetectableCharsets U_ICU_ENTRY_POINT_RENAME(ucsdet_getDetectableCharsets)\n#define ucsdet_getLanguage U_ICU_ENTRY_POINT_RENAME(ucsdet_getLanguage)\n#define ucsdet_getName U_ICU_ENTRY_POINT_RENAME(ucsdet_getName)\n#define ucsdet_getUChars U_ICU_ENTRY_POINT_RENAME(ucsdet_getUChars)\n#define ucsdet_isInputFilterEnabled U_ICU_ENTRY_POINT_RENAME(ucsdet_isInputFilterEnabled)\n#define ucsdet_open U_ICU_ENTRY_POINT_RENAME(ucsdet_open)\n#define ucsdet_setDeclaredEncoding U_ICU_ENTRY_POINT_RENAME(ucsdet_setDeclaredEncoding)\n#define ucsdet_setDetectableCharset U_ICU_ENTRY_POINT_RENAME(ucsdet_setDetectableCharset)\n#define ucsdet_setText U_ICU_ENTRY_POINT_RENAME(ucsdet_setText)\n#define ucurr_countCurrencies U_ICU_ENTRY_POINT_RENAME(ucurr_countCurrencies)\n#define ucurr_forLocale U_ICU_ENTRY_POINT_RENAME(ucurr_forLocale)\n#define ucurr_forLocaleAndDate U_ICU_ENTRY_POINT_RENAME(ucurr_forLocaleAndDate)\n#define ucurr_getDefaultFractionDigits U_ICU_ENTRY_POINT_RENAME(ucurr_getDefaultFractionDigits)\n#define ucurr_getDefaultFractionDigitsForUsage U_ICU_ENTRY_POINT_RENAME(ucurr_getDefaultFractionDigitsForUsage)\n#define ucurr_getKeywordValuesForLocale U_ICU_ENTRY_POINT_RENAME(ucurr_getKeywordValuesForLocale)\n#define ucurr_getName U_ICU_ENTRY_POINT_RENAME(ucurr_getName)\n#define ucurr_getNumericCode U_ICU_ENTRY_POINT_RENAME(ucurr_getNumericCode)\n#define ucurr_getPluralName U_ICU_ENTRY_POINT_RENAME(ucurr_getPluralName)\n#define ucurr_getRoundingIncrement U_ICU_ENTRY_POINT_RENAME(ucurr_getRoundingIncrement)\n#define ucurr_getRoundingIncrementForUsage U_ICU_ENTRY_POINT_RENAME(ucurr_getRoundingIncrementForUsage)\n#define ucurr_isAvailable U_ICU_ENTRY_POINT_RENAME(ucurr_isAvailable)\n#define ucurr_openISOCurrencies U_ICU_ENTRY_POINT_RENAME(ucurr_openISOCurrencies)\n#define ucurr_register U_ICU_ENTRY_POINT_RENAME(ucurr_register)\n#define ucurr_unregister U_ICU_ENTRY_POINT_RENAME(ucurr_unregister)\n#define udat_adoptNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_adoptNumberFormat)\n#define udat_adoptNumberFormatForFields U_ICU_ENTRY_POINT_RENAME(udat_adoptNumberFormatForFields)\n#define udat_applyPattern U_ICU_ENTRY_POINT_RENAME(udat_applyPattern)\n#define udat_applyPatternRelative U_ICU_ENTRY_POINT_RENAME(udat_applyPatternRelative)\n#define udat_clone U_ICU_ENTRY_POINT_RENAME(udat_clone)\n#define udat_close U_ICU_ENTRY_POINT_RENAME(udat_close)\n#define udat_countAvailable U_ICU_ENTRY_POINT_RENAME(udat_countAvailable)\n#define udat_countSymbols U_ICU_ENTRY_POINT_RENAME(udat_countSymbols)\n#define udat_format U_ICU_ENTRY_POINT_RENAME(udat_format)\n#define udat_formatCalendar U_ICU_ENTRY_POINT_RENAME(udat_formatCalendar)\n#define udat_formatCalendarForFields U_ICU_ENTRY_POINT_RENAME(udat_formatCalendarForFields)\n#define udat_formatForFields U_ICU_ENTRY_POINT_RENAME(udat_formatForFields)\n#define udat_get2DigitYearStart U_ICU_ENTRY_POINT_RENAME(udat_get2DigitYearStart)\n#define udat_getAvailable U_ICU_ENTRY_POINT_RENAME(udat_getAvailable)\n#define udat_getBooleanAttribute U_ICU_ENTRY_POINT_RENAME(udat_getBooleanAttribute)\n#define udat_getCalendar U_ICU_ENTRY_POINT_RENAME(udat_getCalendar)\n#define udat_getContext U_ICU_ENTRY_POINT_RENAME(udat_getContext)\n#define udat_getLocaleByType U_ICU_ENTRY_POINT_RENAME(udat_getLocaleByType)\n#define udat_getNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_getNumberFormat)\n#define udat_getNumberFormatForField U_ICU_ENTRY_POINT_RENAME(udat_getNumberFormatForField)\n#define udat_getSymbols U_ICU_ENTRY_POINT_RENAME(udat_getSymbols)\n#define udat_isLenient U_ICU_ENTRY_POINT_RENAME(udat_isLenient)\n#define udat_open U_ICU_ENTRY_POINT_RENAME(udat_open)\n#define udat_parse U_ICU_ENTRY_POINT_RENAME(udat_parse)\n#define udat_parseCalendar U_ICU_ENTRY_POINT_RENAME(udat_parseCalendar)\n#define udat_registerOpener U_ICU_ENTRY_POINT_RENAME(udat_registerOpener)\n#define udat_set2DigitYearStart U_ICU_ENTRY_POINT_RENAME(udat_set2DigitYearStart)\n#define udat_setBooleanAttribute U_ICU_ENTRY_POINT_RENAME(udat_setBooleanAttribute)\n#define udat_setCalendar U_ICU_ENTRY_POINT_RENAME(udat_setCalendar)\n#define udat_setContext U_ICU_ENTRY_POINT_RENAME(udat_setContext)\n#define udat_setLenient U_ICU_ENTRY_POINT_RENAME(udat_setLenient)\n#define udat_setNumberFormat U_ICU_ENTRY_POINT_RENAME(udat_setNumberFormat)\n#define udat_setSymbols U_ICU_ENTRY_POINT_RENAME(udat_setSymbols)\n#define udat_toCalendarDateField U_ICU_ENTRY_POINT_RENAME(udat_toCalendarDateField)\n#define udat_toPattern U_ICU_ENTRY_POINT_RENAME(udat_toPattern)\n#define udat_toPatternRelativeDate U_ICU_ENTRY_POINT_RENAME(udat_toPatternRelativeDate)\n#define udat_toPatternRelativeTime U_ICU_ENTRY_POINT_RENAME(udat_toPatternRelativeTime)\n#define udat_unregisterOpener U_ICU_ENTRY_POINT_RENAME(udat_unregisterOpener)\n#define udata_checkCommonData U_ICU_ENTRY_POINT_RENAME(udata_checkCommonData)\n#define udata_close U_ICU_ENTRY_POINT_RENAME(udata_close)\n#define udata_closeSwapper U_ICU_ENTRY_POINT_RENAME(udata_closeSwapper)\n#define udata_getHeaderSize U_ICU_ENTRY_POINT_RENAME(udata_getHeaderSize)\n#define udata_getInfo U_ICU_ENTRY_POINT_RENAME(udata_getInfo)\n#define udata_getInfoSize U_ICU_ENTRY_POINT_RENAME(udata_getInfoSize)\n#define udata_getLength U_ICU_ENTRY_POINT_RENAME(udata_getLength)\n#define udata_getMemory U_ICU_ENTRY_POINT_RENAME(udata_getMemory)\n#define udata_getRawMemory U_ICU_ENTRY_POINT_RENAME(udata_getRawMemory)\n#define udata_open U_ICU_ENTRY_POINT_RENAME(udata_open)\n#define udata_openChoice U_ICU_ENTRY_POINT_RENAME(udata_openChoice)\n#define udata_openSwapper U_ICU_ENTRY_POINT_RENAME(udata_openSwapper)\n#define udata_openSwapperForInputData U_ICU_ENTRY_POINT_RENAME(udata_openSwapperForInputData)\n#define udata_printError U_ICU_ENTRY_POINT_RENAME(udata_printError)\n#define udata_readInt16 U_ICU_ENTRY_POINT_RENAME(udata_readInt16)\n#define udata_readInt32 U_ICU_ENTRY_POINT_RENAME(udata_readInt32)\n#define udata_setAppData U_ICU_ENTRY_POINT_RENAME(udata_setAppData)\n#define udata_setCommonData U_ICU_ENTRY_POINT_RENAME(udata_setCommonData)\n#define udata_setFileAccess U_ICU_ENTRY_POINT_RENAME(udata_setFileAccess)\n#define udata_swapDataHeader U_ICU_ENTRY_POINT_RENAME(udata_swapDataHeader)\n#define udata_swapInvStringBlock U_ICU_ENTRY_POINT_RENAME(udata_swapInvStringBlock)\n#define udatpg_addPattern U_ICU_ENTRY_POINT_RENAME(udatpg_addPattern)\n#define udatpg_clone U_ICU_ENTRY_POINT_RENAME(udatpg_clone)\n#define udatpg_close U_ICU_ENTRY_POINT_RENAME(udatpg_close)\n#define udatpg_getAppendItemFormat U_ICU_ENTRY_POINT_RENAME(udatpg_getAppendItemFormat)\n#define udatpg_getAppendItemName U_ICU_ENTRY_POINT_RENAME(udatpg_getAppendItemName)\n#define udatpg_getBaseSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getBaseSkeleton)\n#define udatpg_getBestPattern U_ICU_ENTRY_POINT_RENAME(udatpg_getBestPattern)\n#define udatpg_getBestPatternWithOptions U_ICU_ENTRY_POINT_RENAME(udatpg_getBestPatternWithOptions)\n#define udatpg_getDateTimeFormat U_ICU_ENTRY_POINT_RENAME(udatpg_getDateTimeFormat)\n#define udatpg_getDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_getDecimal)\n#define udatpg_getPatternForSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getPatternForSkeleton)\n#define udatpg_getSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getSkeleton)\n#define udatpg_open U_ICU_ENTRY_POINT_RENAME(udatpg_open)\n#define udatpg_openBaseSkeletons U_ICU_ENTRY_POINT_RENAME(udatpg_openBaseSkeletons)\n#define udatpg_openEmpty U_ICU_ENTRY_POINT_RENAME(udatpg_openEmpty)\n#define udatpg_openSkeletons U_ICU_ENTRY_POINT_RENAME(udatpg_openSkeletons)\n#define udatpg_replaceFieldTypes U_ICU_ENTRY_POINT_RENAME(udatpg_replaceFieldTypes)\n#define udatpg_replaceFieldTypesWithOptions U_ICU_ENTRY_POINT_RENAME(udatpg_replaceFieldTypesWithOptions)\n#define udatpg_setAppendItemFormat U_ICU_ENTRY_POINT_RENAME(udatpg_setAppendItemFormat)\n#define udatpg_setAppendItemName U_ICU_ENTRY_POINT_RENAME(udatpg_setAppendItemName)\n#define udatpg_setDateTimeFormat U_ICU_ENTRY_POINT_RENAME(udatpg_setDateTimeFormat)\n#define udatpg_setDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_setDecimal)\n#define udict_swap U_ICU_ENTRY_POINT_RENAME(udict_swap)\n#define udtitvfmt_close U_ICU_ENTRY_POINT_RENAME(udtitvfmt_close)\n#define udtitvfmt_format U_ICU_ENTRY_POINT_RENAME(udtitvfmt_format)\n#define udtitvfmt_open U_ICU_ENTRY_POINT_RENAME(udtitvfmt_open)\n#define uenum_close U_ICU_ENTRY_POINT_RENAME(uenum_close)\n#define uenum_count U_ICU_ENTRY_POINT_RENAME(uenum_count)\n#define uenum_next U_ICU_ENTRY_POINT_RENAME(uenum_next)\n#define uenum_nextDefault U_ICU_ENTRY_POINT_RENAME(uenum_nextDefault)\n#define uenum_openCharStringsEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openCharStringsEnumeration)\n#define uenum_openFromStringEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openFromStringEnumeration)\n#define uenum_openUCharStringsEnumeration U_ICU_ENTRY_POINT_RENAME(uenum_openUCharStringsEnumeration)\n#define uenum_reset U_ICU_ENTRY_POINT_RENAME(uenum_reset)\n#define uenum_unext U_ICU_ENTRY_POINT_RENAME(uenum_unext)\n#define uenum_unextDefault U_ICU_ENTRY_POINT_RENAME(uenum_unextDefault)\n#define ufieldpositer_close U_ICU_ENTRY_POINT_RENAME(ufieldpositer_close)\n#define ufieldpositer_next U_ICU_ENTRY_POINT_RENAME(ufieldpositer_next)\n#define ufieldpositer_open U_ICU_ENTRY_POINT_RENAME(ufieldpositer_open)\n#define ufile_close_translit U_ICU_ENTRY_POINT_RENAME(ufile_close_translit)\n#define ufile_fill_uchar_buffer U_ICU_ENTRY_POINT_RENAME(ufile_fill_uchar_buffer)\n#define ufile_flush_io U_ICU_ENTRY_POINT_RENAME(ufile_flush_io)\n#define ufile_flush_translit U_ICU_ENTRY_POINT_RENAME(ufile_flush_translit)\n#define ufile_getch U_ICU_ENTRY_POINT_RENAME(ufile_getch)\n#define ufile_getch32 U_ICU_ENTRY_POINT_RENAME(ufile_getch32)\n#define ufmt_64tou U_ICU_ENTRY_POINT_RENAME(ufmt_64tou)\n#define ufmt_close U_ICU_ENTRY_POINT_RENAME(ufmt_close)\n#define ufmt_defaultCPToUnicode U_ICU_ENTRY_POINT_RENAME(ufmt_defaultCPToUnicode)\n#define ufmt_digitvalue U_ICU_ENTRY_POINT_RENAME(ufmt_digitvalue)\n#define ufmt_getArrayItemByIndex U_ICU_ENTRY_POINT_RENAME(ufmt_getArrayItemByIndex)\n#define ufmt_getArrayLength U_ICU_ENTRY_POINT_RENAME(ufmt_getArrayLength)\n#define ufmt_getDate U_ICU_ENTRY_POINT_RENAME(ufmt_getDate)\n#define ufmt_getDecNumChars U_ICU_ENTRY_POINT_RENAME(ufmt_getDecNumChars)\n#define ufmt_getDouble U_ICU_ENTRY_POINT_RENAME(ufmt_getDouble)\n#define ufmt_getInt64 U_ICU_ENTRY_POINT_RENAME(ufmt_getInt64)\n#define ufmt_getLong U_ICU_ENTRY_POINT_RENAME(ufmt_getLong)\n#define ufmt_getObject U_ICU_ENTRY_POINT_RENAME(ufmt_getObject)\n#define ufmt_getType U_ICU_ENTRY_POINT_RENAME(ufmt_getType)\n#define ufmt_getUChars U_ICU_ENTRY_POINT_RENAME(ufmt_getUChars)\n#define ufmt_isNumeric U_ICU_ENTRY_POINT_RENAME(ufmt_isNumeric)\n#define ufmt_isdigit U_ICU_ENTRY_POINT_RENAME(ufmt_isdigit)\n#define ufmt_open U_ICU_ENTRY_POINT_RENAME(ufmt_open)\n#define ufmt_ptou U_ICU_ENTRY_POINT_RENAME(ufmt_ptou)\n#define ufmt_uto64 U_ICU_ENTRY_POINT_RENAME(ufmt_uto64)\n#define ufmt_utop U_ICU_ENTRY_POINT_RENAME(ufmt_utop)\n#define ugender_getInstance U_ICU_ENTRY_POINT_RENAME(ugender_getInstance)\n#define ugender_getListGender U_ICU_ENTRY_POINT_RENAME(ugender_getListGender)\n#define uhash_close U_ICU_ENTRY_POINT_RENAME(uhash_close)\n#define uhash_compareCaselessUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_compareCaselessUnicodeString)\n#define uhash_compareChars U_ICU_ENTRY_POINT_RENAME(uhash_compareChars)\n#define uhash_compareIChars U_ICU_ENTRY_POINT_RENAME(uhash_compareIChars)\n#define uhash_compareLong U_ICU_ENTRY_POINT_RENAME(uhash_compareLong)\n#define uhash_compareScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_compareScriptSet)\n#define uhash_compareUChars U_ICU_ENTRY_POINT_RENAME(uhash_compareUChars)\n#define uhash_compareUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_compareUnicodeString)\n#define uhash_count U_ICU_ENTRY_POINT_RENAME(uhash_count)\n#define uhash_deleteHashtable U_ICU_ENTRY_POINT_RENAME(uhash_deleteHashtable)\n#define uhash_deleteScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_deleteScriptSet)\n#define uhash_equals U_ICU_ENTRY_POINT_RENAME(uhash_equals)\n#define uhash_equalsScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_equalsScriptSet)\n#define uhash_find U_ICU_ENTRY_POINT_RENAME(uhash_find)\n#define uhash_get U_ICU_ENTRY_POINT_RENAME(uhash_get)\n#define uhash_geti U_ICU_ENTRY_POINT_RENAME(uhash_geti)\n#define uhash_hashCaselessUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_hashCaselessUnicodeString)\n#define uhash_hashChars U_ICU_ENTRY_POINT_RENAME(uhash_hashChars)\n#define uhash_hashIChars U_ICU_ENTRY_POINT_RENAME(uhash_hashIChars)\n#define uhash_hashLong U_ICU_ENTRY_POINT_RENAME(uhash_hashLong)\n#define uhash_hashScriptSet U_ICU_ENTRY_POINT_RENAME(uhash_hashScriptSet)\n#define uhash_hashUChars U_ICU_ENTRY_POINT_RENAME(uhash_hashUChars)\n#define uhash_hashUnicodeString U_ICU_ENTRY_POINT_RENAME(uhash_hashUnicodeString)\n#define uhash_iget U_ICU_ENTRY_POINT_RENAME(uhash_iget)\n#define uhash_igeti U_ICU_ENTRY_POINT_RENAME(uhash_igeti)\n#define uhash_init U_ICU_ENTRY_POINT_RENAME(uhash_init)\n#define uhash_iput U_ICU_ENTRY_POINT_RENAME(uhash_iput)\n#define uhash_iputi U_ICU_ENTRY_POINT_RENAME(uhash_iputi)\n#define uhash_iremove U_ICU_ENTRY_POINT_RENAME(uhash_iremove)\n#define uhash_iremovei U_ICU_ENTRY_POINT_RENAME(uhash_iremovei)\n#define uhash_nextElement U_ICU_ENTRY_POINT_RENAME(uhash_nextElement)\n#define uhash_open U_ICU_ENTRY_POINT_RENAME(uhash_open)\n#define uhash_openSize U_ICU_ENTRY_POINT_RENAME(uhash_openSize)\n#define uhash_put U_ICU_ENTRY_POINT_RENAME(uhash_put)\n#define uhash_puti U_ICU_ENTRY_POINT_RENAME(uhash_puti)\n#define uhash_remove U_ICU_ENTRY_POINT_RENAME(uhash_remove)\n#define uhash_removeAll U_ICU_ENTRY_POINT_RENAME(uhash_removeAll)\n#define uhash_removeElement U_ICU_ENTRY_POINT_RENAME(uhash_removeElement)\n#define uhash_removei U_ICU_ENTRY_POINT_RENAME(uhash_removei)\n#define uhash_setKeyComparator U_ICU_ENTRY_POINT_RENAME(uhash_setKeyComparator)\n#define uhash_setKeyDeleter U_ICU_ENTRY_POINT_RENAME(uhash_setKeyDeleter)\n#define uhash_setKeyHasher U_ICU_ENTRY_POINT_RENAME(uhash_setKeyHasher)\n#define uhash_setResizePolicy U_ICU_ENTRY_POINT_RENAME(uhash_setResizePolicy)\n#define uhash_setValueComparator U_ICU_ENTRY_POINT_RENAME(uhash_setValueComparator)\n#define uhash_setValueDeleter U_ICU_ENTRY_POINT_RENAME(uhash_setValueDeleter)\n#define uidna_IDNToASCII U_ICU_ENTRY_POINT_RENAME(uidna_IDNToASCII)\n#define uidna_IDNToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_IDNToUnicode)\n#define uidna_close U_ICU_ENTRY_POINT_RENAME(uidna_close)\n#define uidna_compare U_ICU_ENTRY_POINT_RENAME(uidna_compare)\n#define uidna_labelToASCII U_ICU_ENTRY_POINT_RENAME(uidna_labelToASCII)\n#define uidna_labelToASCII_UTF8 U_ICU_ENTRY_POINT_RENAME(uidna_labelToASCII_UTF8)\n#define uidna_labelToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_labelToUnicode)\n#define uidna_labelToUnicodeUTF8 U_ICU_ENTRY_POINT_RENAME(uidna_labelToUnicodeUTF8)\n#define uidna_nameToASCII U_ICU_ENTRY_POINT_RENAME(uidna_nameToASCII)\n#define uidna_nameToASCII_UTF8 U_ICU_ENTRY_POINT_RENAME(uidna_nameToASCII_UTF8)\n#define uidna_nameToUnicode U_ICU_ENTRY_POINT_RENAME(uidna_nameToUnicode)\n#define uidna_nameToUnicodeUTF8 U_ICU_ENTRY_POINT_RENAME(uidna_nameToUnicodeUTF8)\n#define uidna_openUTS46 U_ICU_ENTRY_POINT_RENAME(uidna_openUTS46)\n#define uidna_toASCII U_ICU_ENTRY_POINT_RENAME(uidna_toASCII)\n#define uidna_toUnicode U_ICU_ENTRY_POINT_RENAME(uidna_toUnicode)\n#define uiter_current32 U_ICU_ENTRY_POINT_RENAME(uiter_current32)\n#define uiter_getState U_ICU_ENTRY_POINT_RENAME(uiter_getState)\n#define uiter_next32 U_ICU_ENTRY_POINT_RENAME(uiter_next32)\n#define uiter_previous32 U_ICU_ENTRY_POINT_RENAME(uiter_previous32)\n#define uiter_setCharacterIterator U_ICU_ENTRY_POINT_RENAME(uiter_setCharacterIterator)\n#define uiter_setReplaceable U_ICU_ENTRY_POINT_RENAME(uiter_setReplaceable)\n#define uiter_setState U_ICU_ENTRY_POINT_RENAME(uiter_setState)\n#define uiter_setString U_ICU_ENTRY_POINT_RENAME(uiter_setString)\n#define uiter_setUTF16BE U_ICU_ENTRY_POINT_RENAME(uiter_setUTF16BE)\n#define uiter_setUTF8 U_ICU_ENTRY_POINT_RENAME(uiter_setUTF8)\n#define uldn_close U_ICU_ENTRY_POINT_RENAME(uldn_close)\n#define uldn_getContext U_ICU_ENTRY_POINT_RENAME(uldn_getContext)\n#define uldn_getDialectHandling U_ICU_ENTRY_POINT_RENAME(uldn_getDialectHandling)\n#define uldn_getLocale U_ICU_ENTRY_POINT_RENAME(uldn_getLocale)\n#define uldn_keyDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_keyDisplayName)\n#define uldn_keyValueDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_keyValueDisplayName)\n#define uldn_languageDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_languageDisplayName)\n#define uldn_localeDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_localeDisplayName)\n#define uldn_open U_ICU_ENTRY_POINT_RENAME(uldn_open)\n#define uldn_openForContext U_ICU_ENTRY_POINT_RENAME(uldn_openForContext)\n#define uldn_regionDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_regionDisplayName)\n#define uldn_scriptCodeDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_scriptCodeDisplayName)\n#define uldn_scriptDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_scriptDisplayName)\n#define uldn_variantDisplayName U_ICU_ENTRY_POINT_RENAME(uldn_variantDisplayName)\n#define ulist_addItemBeginList U_ICU_ENTRY_POINT_RENAME(ulist_addItemBeginList)\n#define ulist_addItemEndList U_ICU_ENTRY_POINT_RENAME(ulist_addItemEndList)\n#define ulist_close_keyword_values_iterator U_ICU_ENTRY_POINT_RENAME(ulist_close_keyword_values_iterator)\n#define ulist_containsString U_ICU_ENTRY_POINT_RENAME(ulist_containsString)\n#define ulist_count_keyword_values U_ICU_ENTRY_POINT_RENAME(ulist_count_keyword_values)\n#define ulist_createEmptyList U_ICU_ENTRY_POINT_RENAME(ulist_createEmptyList)\n#define ulist_deleteList U_ICU_ENTRY_POINT_RENAME(ulist_deleteList)\n#define ulist_getListFromEnum U_ICU_ENTRY_POINT_RENAME(ulist_getListFromEnum)\n#define ulist_getListSize U_ICU_ENTRY_POINT_RENAME(ulist_getListSize)\n#define ulist_getNext U_ICU_ENTRY_POINT_RENAME(ulist_getNext)\n#define ulist_next_keyword_value U_ICU_ENTRY_POINT_RENAME(ulist_next_keyword_value)\n#define ulist_resetList U_ICU_ENTRY_POINT_RENAME(ulist_resetList)\n#define ulist_reset_keyword_values_iterator U_ICU_ENTRY_POINT_RENAME(ulist_reset_keyword_values_iterator)\n#define ulistfmt_close U_ICU_ENTRY_POINT_RENAME(ulistfmt_close)\n#define ulistfmt_format U_ICU_ENTRY_POINT_RENAME(ulistfmt_format)\n#define ulistfmt_open U_ICU_ENTRY_POINT_RENAME(ulistfmt_open)\n#define uloc_acceptLanguage U_ICU_ENTRY_POINT_RENAME(uloc_acceptLanguage)\n#define uloc_acceptLanguageFromHTTP U_ICU_ENTRY_POINT_RENAME(uloc_acceptLanguageFromHTTP)\n#define uloc_addLikelySubtags U_ICU_ENTRY_POINT_RENAME(uloc_addLikelySubtags)\n#define uloc_canonicalize U_ICU_ENTRY_POINT_RENAME(uloc_canonicalize)\n#define uloc_countAvailable U_ICU_ENTRY_POINT_RENAME(uloc_countAvailable)\n#define uloc_forLanguageTag U_ICU_ENTRY_POINT_RENAME(uloc_forLanguageTag)\n#define uloc_getAvailable U_ICU_ENTRY_POINT_RENAME(uloc_getAvailable)\n#define uloc_getBaseName U_ICU_ENTRY_POINT_RENAME(uloc_getBaseName)\n#define uloc_getCharacterOrientation U_ICU_ENTRY_POINT_RENAME(uloc_getCharacterOrientation)\n#define uloc_getCountry U_ICU_ENTRY_POINT_RENAME(uloc_getCountry)\n#define uloc_getCurrentCountryID U_ICU_ENTRY_POINT_RENAME(uloc_getCurrentCountryID)\n#define uloc_getCurrentLanguageID U_ICU_ENTRY_POINT_RENAME(uloc_getCurrentLanguageID)\n#define uloc_getDefault U_ICU_ENTRY_POINT_RENAME(uloc_getDefault)\n#define uloc_getDisplayCountry U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayCountry)\n#define uloc_getDisplayKeyword U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayKeyword)\n#define uloc_getDisplayKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayKeywordValue)\n#define uloc_getDisplayLanguage U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayLanguage)\n#define uloc_getDisplayName U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayName)\n#define uloc_getDisplayScript U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayScript)\n#define uloc_getDisplayScriptInContext U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayScriptInContext)\n#define uloc_getDisplayVariant U_ICU_ENTRY_POINT_RENAME(uloc_getDisplayVariant)\n#define uloc_getISO3Country U_ICU_ENTRY_POINT_RENAME(uloc_getISO3Country)\n#define uloc_getISO3Language U_ICU_ENTRY_POINT_RENAME(uloc_getISO3Language)\n#define uloc_getISOCountries U_ICU_ENTRY_POINT_RENAME(uloc_getISOCountries)\n#define uloc_getISOLanguages U_ICU_ENTRY_POINT_RENAME(uloc_getISOLanguages)\n#define uloc_getKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_getKeywordValue)\n#define uloc_getLCID U_ICU_ENTRY_POINT_RENAME(uloc_getLCID)\n#define uloc_getLanguage U_ICU_ENTRY_POINT_RENAME(uloc_getLanguage)\n#define uloc_getLineOrientation U_ICU_ENTRY_POINT_RENAME(uloc_getLineOrientation)\n#define uloc_getLocaleForLCID U_ICU_ENTRY_POINT_RENAME(uloc_getLocaleForLCID)\n#define uloc_getName U_ICU_ENTRY_POINT_RENAME(uloc_getName)\n#define uloc_getParent U_ICU_ENTRY_POINT_RENAME(uloc_getParent)\n#define uloc_getScript U_ICU_ENTRY_POINT_RENAME(uloc_getScript)\n#define uloc_getTableStringWithFallback U_ICU_ENTRY_POINT_RENAME(uloc_getTableStringWithFallback)\n#define uloc_getVariant U_ICU_ENTRY_POINT_RENAME(uloc_getVariant)\n#define uloc_isRightToLeft U_ICU_ENTRY_POINT_RENAME(uloc_isRightToLeft)\n#define uloc_minimizeSubtags U_ICU_ENTRY_POINT_RENAME(uloc_minimizeSubtags)\n#define uloc_openKeywordList U_ICU_ENTRY_POINT_RENAME(uloc_openKeywordList)\n#define uloc_openKeywords U_ICU_ENTRY_POINT_RENAME(uloc_openKeywords)\n#define uloc_setDefault U_ICU_ENTRY_POINT_RENAME(uloc_setDefault)\n#define uloc_setKeywordValue U_ICU_ENTRY_POINT_RENAME(uloc_setKeywordValue)\n#define uloc_toLanguageTag U_ICU_ENTRY_POINT_RENAME(uloc_toLanguageTag)\n#define uloc_toLegacyKey U_ICU_ENTRY_POINT_RENAME(uloc_toLegacyKey)\n#define uloc_toLegacyType U_ICU_ENTRY_POINT_RENAME(uloc_toLegacyType)\n#define uloc_toUnicodeLocaleKey U_ICU_ENTRY_POINT_RENAME(uloc_toUnicodeLocaleKey)\n#define uloc_toUnicodeLocaleType U_ICU_ENTRY_POINT_RENAME(uloc_toUnicodeLocaleType)\n#define ulocdata_close U_ICU_ENTRY_POINT_RENAME(ulocdata_close)\n#define ulocdata_getCLDRVersion U_ICU_ENTRY_POINT_RENAME(ulocdata_getCLDRVersion)\n#define ulocdata_getDelimiter U_ICU_ENTRY_POINT_RENAME(ulocdata_getDelimiter)\n#define ulocdata_getExemplarSet U_ICU_ENTRY_POINT_RENAME(ulocdata_getExemplarSet)\n#define ulocdata_getLocaleDisplayPattern U_ICU_ENTRY_POINT_RENAME(ulocdata_getLocaleDisplayPattern)\n#define ulocdata_getLocaleSeparator U_ICU_ENTRY_POINT_RENAME(ulocdata_getLocaleSeparator)\n#define ulocdata_getMeasurementSystem U_ICU_ENTRY_POINT_RENAME(ulocdata_getMeasurementSystem)\n#define ulocdata_getNoSubstitute U_ICU_ENTRY_POINT_RENAME(ulocdata_getNoSubstitute)\n#define ulocdata_getPaperSize U_ICU_ENTRY_POINT_RENAME(ulocdata_getPaperSize)\n#define ulocdata_open U_ICU_ENTRY_POINT_RENAME(ulocdata_open)\n#define ulocdata_setNoSubstitute U_ICU_ENTRY_POINT_RENAME(ulocdata_setNoSubstitute)\n#define ulocimp_getCountry U_ICU_ENTRY_POINT_RENAME(ulocimp_getCountry)\n#define ulocimp_getLanguage U_ICU_ENTRY_POINT_RENAME(ulocimp_getLanguage)\n#define ulocimp_getRegionForSupplementalData U_ICU_ENTRY_POINT_RENAME(ulocimp_getRegionForSupplementalData)\n#define ulocimp_getScript U_ICU_ENTRY_POINT_RENAME(ulocimp_getScript)\n#define ulocimp_toBcpKey U_ICU_ENTRY_POINT_RENAME(ulocimp_toBcpKey)\n#define ulocimp_toBcpType U_ICU_ENTRY_POINT_RENAME(ulocimp_toBcpType)\n#define ulocimp_toLegacyKey U_ICU_ENTRY_POINT_RENAME(ulocimp_toLegacyKey)\n#define ulocimp_toLegacyType U_ICU_ENTRY_POINT_RENAME(ulocimp_toLegacyType)\n#define ultag_isUnicodeLocaleKey U_ICU_ENTRY_POINT_RENAME(ultag_isUnicodeLocaleKey)\n#define ultag_isUnicodeLocaleType U_ICU_ENTRY_POINT_RENAME(ultag_isUnicodeLocaleType)\n#define umsg_applyPattern U_ICU_ENTRY_POINT_RENAME(umsg_applyPattern)\n#define umsg_autoQuoteApostrophe U_ICU_ENTRY_POINT_RENAME(umsg_autoQuoteApostrophe)\n#define umsg_clone U_ICU_ENTRY_POINT_RENAME(umsg_clone)\n#define umsg_close U_ICU_ENTRY_POINT_RENAME(umsg_close)\n#define umsg_format U_ICU_ENTRY_POINT_RENAME(umsg_format)\n#define umsg_getLocale U_ICU_ENTRY_POINT_RENAME(umsg_getLocale)\n#define umsg_open U_ICU_ENTRY_POINT_RENAME(umsg_open)\n#define umsg_parse U_ICU_ENTRY_POINT_RENAME(umsg_parse)\n#define umsg_setLocale U_ICU_ENTRY_POINT_RENAME(umsg_setLocale)\n#define umsg_toPattern U_ICU_ENTRY_POINT_RENAME(umsg_toPattern)\n#define umsg_vformat U_ICU_ENTRY_POINT_RENAME(umsg_vformat)\n#define umsg_vparse U_ICU_ENTRY_POINT_RENAME(umsg_vparse)\n#define umtx_condBroadcast U_ICU_ENTRY_POINT_RENAME(umtx_condBroadcast)\n#define umtx_condSignal U_ICU_ENTRY_POINT_RENAME(umtx_condSignal)\n#define umtx_condWait U_ICU_ENTRY_POINT_RENAME(umtx_condWait)\n#define umtx_lock U_ICU_ENTRY_POINT_RENAME(umtx_lock)\n#define umtx_unlock U_ICU_ENTRY_POINT_RENAME(umtx_unlock)\n#define uniset_getUnicode32Instance U_ICU_ENTRY_POINT_RENAME(uniset_getUnicode32Instance)\n#define unorm2_append U_ICU_ENTRY_POINT_RENAME(unorm2_append)\n#define unorm2_close U_ICU_ENTRY_POINT_RENAME(unorm2_close)\n#define unorm2_composePair U_ICU_ENTRY_POINT_RENAME(unorm2_composePair)\n#define unorm2_getCombiningClass U_ICU_ENTRY_POINT_RENAME(unorm2_getCombiningClass)\n#define unorm2_getDecomposition U_ICU_ENTRY_POINT_RENAME(unorm2_getDecomposition)\n#define unorm2_getInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getInstance)\n#define unorm2_getNFCInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFCInstance)\n#define unorm2_getNFDInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFDInstance)\n#define unorm2_getNFKCCasefoldInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKCCasefoldInstance)\n#define unorm2_getNFKCInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKCInstance)\n#define unorm2_getNFKDInstance U_ICU_ENTRY_POINT_RENAME(unorm2_getNFKDInstance)\n#define unorm2_getRawDecomposition U_ICU_ENTRY_POINT_RENAME(unorm2_getRawDecomposition)\n#define unorm2_hasBoundaryAfter U_ICU_ENTRY_POINT_RENAME(unorm2_hasBoundaryAfter)\n#define unorm2_hasBoundaryBefore U_ICU_ENTRY_POINT_RENAME(unorm2_hasBoundaryBefore)\n#define unorm2_isInert U_ICU_ENTRY_POINT_RENAME(unorm2_isInert)\n#define unorm2_isNormalized U_ICU_ENTRY_POINT_RENAME(unorm2_isNormalized)\n#define unorm2_normalize U_ICU_ENTRY_POINT_RENAME(unorm2_normalize)\n#define unorm2_normalizeSecondAndAppend U_ICU_ENTRY_POINT_RENAME(unorm2_normalizeSecondAndAppend)\n#define unorm2_openFiltered U_ICU_ENTRY_POINT_RENAME(unorm2_openFiltered)\n#define unorm2_quickCheck U_ICU_ENTRY_POINT_RENAME(unorm2_quickCheck)\n#define unorm2_spanQuickCheckYes U_ICU_ENTRY_POINT_RENAME(unorm2_spanQuickCheckYes)\n#define unorm2_swap U_ICU_ENTRY_POINT_RENAME(unorm2_swap)\n#define unorm_compare U_ICU_ENTRY_POINT_RENAME(unorm_compare)\n#define unorm_concatenate U_ICU_ENTRY_POINT_RENAME(unorm_concatenate)\n#define unorm_getFCD16 U_ICU_ENTRY_POINT_RENAME(unorm_getFCD16)\n#define unorm_getQuickCheck U_ICU_ENTRY_POINT_RENAME(unorm_getQuickCheck)\n#define unorm_isNormalized U_ICU_ENTRY_POINT_RENAME(unorm_isNormalized)\n#define unorm_isNormalizedWithOptions U_ICU_ENTRY_POINT_RENAME(unorm_isNormalizedWithOptions)\n#define unorm_next U_ICU_ENTRY_POINT_RENAME(unorm_next)\n#define unorm_normalize U_ICU_ENTRY_POINT_RENAME(unorm_normalize)\n#define unorm_previous U_ICU_ENTRY_POINT_RENAME(unorm_previous)\n#define unorm_quickCheck U_ICU_ENTRY_POINT_RENAME(unorm_quickCheck)\n#define unorm_quickCheckWithOptions U_ICU_ENTRY_POINT_RENAME(unorm_quickCheckWithOptions)\n#define unum_applyPattern U_ICU_ENTRY_POINT_RENAME(unum_applyPattern)\n#define unum_clone U_ICU_ENTRY_POINT_RENAME(unum_clone)\n#define unum_close U_ICU_ENTRY_POINT_RENAME(unum_close)\n#define unum_countAvailable U_ICU_ENTRY_POINT_RENAME(unum_countAvailable)\n#define unum_format U_ICU_ENTRY_POINT_RENAME(unum_format)\n#define unum_formatDecimal U_ICU_ENTRY_POINT_RENAME(unum_formatDecimal)\n#define unum_formatDouble U_ICU_ENTRY_POINT_RENAME(unum_formatDouble)\n#define unum_formatDoubleCurrency U_ICU_ENTRY_POINT_RENAME(unum_formatDoubleCurrency)\n#define unum_formatInt64 U_ICU_ENTRY_POINT_RENAME(unum_formatInt64)\n#define unum_formatUFormattable U_ICU_ENTRY_POINT_RENAME(unum_formatUFormattable)\n#define unum_getAttribute U_ICU_ENTRY_POINT_RENAME(unum_getAttribute)\n#define unum_getAvailable U_ICU_ENTRY_POINT_RENAME(unum_getAvailable)\n#define unum_getContext U_ICU_ENTRY_POINT_RENAME(unum_getContext)\n#define unum_getDoubleAttribute U_ICU_ENTRY_POINT_RENAME(unum_getDoubleAttribute)\n#define unum_getLocaleByType U_ICU_ENTRY_POINT_RENAME(unum_getLocaleByType)\n#define unum_getSymbol U_ICU_ENTRY_POINT_RENAME(unum_getSymbol)\n#define unum_getTextAttribute U_ICU_ENTRY_POINT_RENAME(unum_getTextAttribute)\n#define unum_open U_ICU_ENTRY_POINT_RENAME(unum_open)\n#define unum_parse U_ICU_ENTRY_POINT_RENAME(unum_parse)\n#define unum_parseDecimal U_ICU_ENTRY_POINT_RENAME(unum_parseDecimal)\n#define unum_parseDouble U_ICU_ENTRY_POINT_RENAME(unum_parseDouble)\n#define unum_parseDoubleCurrency U_ICU_ENTRY_POINT_RENAME(unum_parseDoubleCurrency)\n#define unum_parseInt64 U_ICU_ENTRY_POINT_RENAME(unum_parseInt64)\n#define unum_parseToUFormattable U_ICU_ENTRY_POINT_RENAME(unum_parseToUFormattable)\n#define unum_setAttribute U_ICU_ENTRY_POINT_RENAME(unum_setAttribute)\n#define unum_setContext U_ICU_ENTRY_POINT_RENAME(unum_setContext)\n#define unum_setDoubleAttribute U_ICU_ENTRY_POINT_RENAME(unum_setDoubleAttribute)\n#define unum_setSymbol U_ICU_ENTRY_POINT_RENAME(unum_setSymbol)\n#define unum_setTextAttribute U_ICU_ENTRY_POINT_RENAME(unum_setTextAttribute)\n#define unum_toPattern U_ICU_ENTRY_POINT_RENAME(unum_toPattern)\n#define unumsys_close U_ICU_ENTRY_POINT_RENAME(unumsys_close)\n#define unumsys_getDescription U_ICU_ENTRY_POINT_RENAME(unumsys_getDescription)\n#define unumsys_getName U_ICU_ENTRY_POINT_RENAME(unumsys_getName)\n#define unumsys_getRadix U_ICU_ENTRY_POINT_RENAME(unumsys_getRadix)\n#define unumsys_isAlgorithmic U_ICU_ENTRY_POINT_RENAME(unumsys_isAlgorithmic)\n#define unumsys_open U_ICU_ENTRY_POINT_RENAME(unumsys_open)\n#define unumsys_openAvailableNames U_ICU_ENTRY_POINT_RENAME(unumsys_openAvailableNames)\n#define unumsys_openByName U_ICU_ENTRY_POINT_RENAME(unumsys_openByName)\n#define uplrules_close U_ICU_ENTRY_POINT_RENAME(uplrules_close)\n#define uplrules_open U_ICU_ENTRY_POINT_RENAME(uplrules_open)\n#define uplrules_openForType U_ICU_ENTRY_POINT_RENAME(uplrules_openForType)\n#define uplrules_select U_ICU_ENTRY_POINT_RENAME(uplrules_select)\n#define uplug_closeLibrary U_ICU_ENTRY_POINT_RENAME(uplug_closeLibrary)\n#define uplug_findLibrary U_ICU_ENTRY_POINT_RENAME(uplug_findLibrary)\n#define uplug_getConfiguration U_ICU_ENTRY_POINT_RENAME(uplug_getConfiguration)\n#define uplug_getContext U_ICU_ENTRY_POINT_RENAME(uplug_getContext)\n#define uplug_getCurrentLevel U_ICU_ENTRY_POINT_RENAME(uplug_getCurrentLevel)\n#define uplug_getLibrary U_ICU_ENTRY_POINT_RENAME(uplug_getLibrary)\n#define uplug_getLibraryName U_ICU_ENTRY_POINT_RENAME(uplug_getLibraryName)\n#define uplug_getPlugInternal U_ICU_ENTRY_POINT_RENAME(uplug_getPlugInternal)\n#define uplug_getPlugLevel U_ICU_ENTRY_POINT_RENAME(uplug_getPlugLevel)\n#define uplug_getPlugLoadStatus U_ICU_ENTRY_POINT_RENAME(uplug_getPlugLoadStatus)\n#define uplug_getPlugName U_ICU_ENTRY_POINT_RENAME(uplug_getPlugName)\n#define uplug_getPluginFile U_ICU_ENTRY_POINT_RENAME(uplug_getPluginFile)\n#define uplug_getSymbolName U_ICU_ENTRY_POINT_RENAME(uplug_getSymbolName)\n#define uplug_init U_ICU_ENTRY_POINT_RENAME(uplug_init)\n#define uplug_loadPlugFromEntrypoint U_ICU_ENTRY_POINT_RENAME(uplug_loadPlugFromEntrypoint)\n#define uplug_loadPlugFromLibrary U_ICU_ENTRY_POINT_RENAME(uplug_loadPlugFromLibrary)\n#define uplug_nextPlug U_ICU_ENTRY_POINT_RENAME(uplug_nextPlug)\n#define uplug_openLibrary U_ICU_ENTRY_POINT_RENAME(uplug_openLibrary)\n#define uplug_removePlug U_ICU_ENTRY_POINT_RENAME(uplug_removePlug)\n#define uplug_setContext U_ICU_ENTRY_POINT_RENAME(uplug_setContext)\n#define uplug_setPlugLevel U_ICU_ENTRY_POINT_RENAME(uplug_setPlugLevel)\n#define uplug_setPlugName U_ICU_ENTRY_POINT_RENAME(uplug_setPlugName)\n#define uplug_setPlugNoUnload U_ICU_ENTRY_POINT_RENAME(uplug_setPlugNoUnload)\n#define uprops_getSource U_ICU_ENTRY_POINT_RENAME(uprops_getSource)\n#define upropsvec_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(upropsvec_addPropertyStarts)\n#define uprv_aestrncpy U_ICU_ENTRY_POINT_RENAME(uprv_aestrncpy)\n#define uprv_asciiFromEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_asciiFromEbcdic)\n#define uprv_asciitolower U_ICU_ENTRY_POINT_RENAME(uprv_asciitolower)\n#define uprv_calloc U_ICU_ENTRY_POINT_RENAME(uprv_calloc)\n#define uprv_ceil U_ICU_ENTRY_POINT_RENAME(uprv_ceil)\n#define uprv_compareASCIIPropertyNames U_ICU_ENTRY_POINT_RENAME(uprv_compareASCIIPropertyNames)\n#define uprv_compareEBCDICPropertyNames U_ICU_ENTRY_POINT_RENAME(uprv_compareEBCDICPropertyNames)\n#define uprv_compareInvAscii U_ICU_ENTRY_POINT_RENAME(uprv_compareInvAscii)\n#define uprv_compareInvEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_compareInvEbcdic)\n#define uprv_compareInvEbcdicAsAscii U_ICU_ENTRY_POINT_RENAME(uprv_compareInvEbcdicAsAscii)\n#define uprv_convertToLCID U_ICU_ENTRY_POINT_RENAME(uprv_convertToLCID)\n#define uprv_convertToPosix U_ICU_ENTRY_POINT_RENAME(uprv_convertToPosix)\n#define uprv_copyAscii U_ICU_ENTRY_POINT_RENAME(uprv_copyAscii)\n#define uprv_copyEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_copyEbcdic)\n#define uprv_decContextClearStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextClearStatus)\n#define uprv_decContextDefault U_ICU_ENTRY_POINT_RENAME(uprv_decContextDefault)\n#define uprv_decContextGetRounding U_ICU_ENTRY_POINT_RENAME(uprv_decContextGetRounding)\n#define uprv_decContextGetStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextGetStatus)\n#define uprv_decContextRestoreStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextRestoreStatus)\n#define uprv_decContextSaveStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextSaveStatus)\n#define uprv_decContextSetRounding U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetRounding)\n#define uprv_decContextSetStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatus)\n#define uprv_decContextSetStatusFromString U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusFromString)\n#define uprv_decContextSetStatusFromStringQuiet U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusFromStringQuiet)\n#define uprv_decContextSetStatusQuiet U_ICU_ENTRY_POINT_RENAME(uprv_decContextSetStatusQuiet)\n#define uprv_decContextStatusToString U_ICU_ENTRY_POINT_RENAME(uprv_decContextStatusToString)\n#define uprv_decContextTestSavedStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextTestSavedStatus)\n#define uprv_decContextTestStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextTestStatus)\n#define uprv_decContextZeroStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextZeroStatus)\n#define uprv_decNumberAbs U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAbs)\n#define uprv_decNumberAdd U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAdd)\n#define uprv_decNumberAnd U_ICU_ENTRY_POINT_RENAME(uprv_decNumberAnd)\n#define uprv_decNumberClass U_ICU_ENTRY_POINT_RENAME(uprv_decNumberClass)\n#define uprv_decNumberClassToString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberClassToString)\n#define uprv_decNumberCompare U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompare)\n#define uprv_decNumberCompareSignal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareSignal)\n#define uprv_decNumberCompareTotal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareTotal)\n#define uprv_decNumberCompareTotalMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCompareTotalMag)\n#define uprv_decNumberCopy U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopy)\n#define uprv_decNumberCopyAbs U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopyAbs)\n#define uprv_decNumberCopyNegate U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopyNegate)\n#define uprv_decNumberCopySign U_ICU_ENTRY_POINT_RENAME(uprv_decNumberCopySign)\n#define uprv_decNumberDivide U_ICU_ENTRY_POINT_RENAME(uprv_decNumberDivide)\n#define uprv_decNumberDivideInteger U_ICU_ENTRY_POINT_RENAME(uprv_decNumberDivideInteger)\n#define uprv_decNumberExp U_ICU_ENTRY_POINT_RENAME(uprv_decNumberExp)\n#define uprv_decNumberFMA U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFMA)\n#define uprv_decNumberFromInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromInt32)\n#define uprv_decNumberFromString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromString)\n#define uprv_decNumberFromUInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberFromUInt32)\n#define uprv_decNumberGetBCD U_ICU_ENTRY_POINT_RENAME(uprv_decNumberGetBCD)\n#define uprv_decNumberInvert U_ICU_ENTRY_POINT_RENAME(uprv_decNumberInvert)\n#define uprv_decNumberIsNormal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberIsNormal)\n#define uprv_decNumberIsSubnormal U_ICU_ENTRY_POINT_RENAME(uprv_decNumberIsSubnormal)\n#define uprv_decNumberLn U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLn)\n#define uprv_decNumberLog10 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLog10)\n#define uprv_decNumberLogB U_ICU_ENTRY_POINT_RENAME(uprv_decNumberLogB)\n#define uprv_decNumberMax U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMax)\n#define uprv_decNumberMaxMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMaxMag)\n#define uprv_decNumberMin U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMin)\n#define uprv_decNumberMinMag U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMinMag)\n#define uprv_decNumberMinus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMinus)\n#define uprv_decNumberMultiply U_ICU_ENTRY_POINT_RENAME(uprv_decNumberMultiply)\n#define uprv_decNumberNextMinus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextMinus)\n#define uprv_decNumberNextPlus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextPlus)\n#define uprv_decNumberNextToward U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNextToward)\n#define uprv_decNumberNormalize U_ICU_ENTRY_POINT_RENAME(uprv_decNumberNormalize)\n#define uprv_decNumberOr U_ICU_ENTRY_POINT_RENAME(uprv_decNumberOr)\n#define uprv_decNumberPlus U_ICU_ENTRY_POINT_RENAME(uprv_decNumberPlus)\n#define uprv_decNumberPower U_ICU_ENTRY_POINT_RENAME(uprv_decNumberPower)\n#define uprv_decNumberQuantize U_ICU_ENTRY_POINT_RENAME(uprv_decNumberQuantize)\n#define uprv_decNumberReduce U_ICU_ENTRY_POINT_RENAME(uprv_decNumberReduce)\n#define uprv_decNumberRemainder U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRemainder)\n#define uprv_decNumberRemainderNear U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRemainderNear)\n#define uprv_decNumberRescale U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRescale)\n#define uprv_decNumberRotate U_ICU_ENTRY_POINT_RENAME(uprv_decNumberRotate)\n#define uprv_decNumberSameQuantum U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSameQuantum)\n#define uprv_decNumberScaleB U_ICU_ENTRY_POINT_RENAME(uprv_decNumberScaleB)\n#define uprv_decNumberSetBCD U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSetBCD)\n#define uprv_decNumberShift U_ICU_ENTRY_POINT_RENAME(uprv_decNumberShift)\n#define uprv_decNumberSquareRoot U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSquareRoot)\n#define uprv_decNumberSubtract U_ICU_ENTRY_POINT_RENAME(uprv_decNumberSubtract)\n#define uprv_decNumberToEngString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToEngString)\n#define uprv_decNumberToInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToInt32)\n#define uprv_decNumberToIntegralExact U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToIntegralExact)\n#define uprv_decNumberToIntegralValue U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToIntegralValue)\n#define uprv_decNumberToString U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToString)\n#define uprv_decNumberToUInt32 U_ICU_ENTRY_POINT_RENAME(uprv_decNumberToUInt32)\n#define uprv_decNumberTrim U_ICU_ENTRY_POINT_RENAME(uprv_decNumberTrim)\n#define uprv_decNumberVersion U_ICU_ENTRY_POINT_RENAME(uprv_decNumberVersion)\n#define uprv_decNumberXor U_ICU_ENTRY_POINT_RENAME(uprv_decNumberXor)\n#define uprv_decNumberZero U_ICU_ENTRY_POINT_RENAME(uprv_decNumberZero)\n#define uprv_deleteConditionalCE32 U_ICU_ENTRY_POINT_RENAME(uprv_deleteConditionalCE32)\n#define uprv_deleteUObject U_ICU_ENTRY_POINT_RENAME(uprv_deleteUObject)\n#define uprv_dl_close U_ICU_ENTRY_POINT_RENAME(uprv_dl_close)\n#define uprv_dl_open U_ICU_ENTRY_POINT_RENAME(uprv_dl_open)\n#define uprv_dlsym_func U_ICU_ENTRY_POINT_RENAME(uprv_dlsym_func)\n#define uprv_eastrncpy U_ICU_ENTRY_POINT_RENAME(uprv_eastrncpy)\n#define uprv_ebcdicFromAscii U_ICU_ENTRY_POINT_RENAME(uprv_ebcdicFromAscii)\n#define uprv_ebcdicToLowercaseAscii U_ICU_ENTRY_POINT_RENAME(uprv_ebcdicToLowercaseAscii)\n#define uprv_ebcdictolower U_ICU_ENTRY_POINT_RENAME(uprv_ebcdictolower)\n#define uprv_fabs U_ICU_ENTRY_POINT_RENAME(uprv_fabs)\n#define uprv_floor U_ICU_ENTRY_POINT_RENAME(uprv_floor)\n#define uprv_fmax U_ICU_ENTRY_POINT_RENAME(uprv_fmax)\n#define uprv_fmin U_ICU_ENTRY_POINT_RENAME(uprv_fmin)\n#define uprv_fmod U_ICU_ENTRY_POINT_RENAME(uprv_fmod)\n#define uprv_free U_ICU_ENTRY_POINT_RENAME(uprv_free)\n#define uprv_getCharNameCharacters U_ICU_ENTRY_POINT_RENAME(uprv_getCharNameCharacters)\n#define uprv_getDefaultCodepage U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultCodepage)\n#define uprv_getDefaultLocaleID U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultLocaleID)\n#define uprv_getInfinity U_ICU_ENTRY_POINT_RENAME(uprv_getInfinity)\n#define uprv_getMaxCharNameLength U_ICU_ENTRY_POINT_RENAME(uprv_getMaxCharNameLength)\n#define uprv_getMaxValues U_ICU_ENTRY_POINT_RENAME(uprv_getMaxValues)\n#define uprv_getNaN U_ICU_ENTRY_POINT_RENAME(uprv_getNaN)\n#define uprv_getRawUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getRawUTCtime)\n#define uprv_getStaticCurrencyName U_ICU_ENTRY_POINT_RENAME(uprv_getStaticCurrencyName)\n#define uprv_getUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getUTCtime)\n#define uprv_haveProperties U_ICU_ENTRY_POINT_RENAME(uprv_haveProperties)\n#define uprv_int32Comparator U_ICU_ENTRY_POINT_RENAME(uprv_int32Comparator)\n#define uprv_isASCIILetter U_ICU_ENTRY_POINT_RENAME(uprv_isASCIILetter)\n#define uprv_isInfinite U_ICU_ENTRY_POINT_RENAME(uprv_isInfinite)\n#define uprv_isInvariantString U_ICU_ENTRY_POINT_RENAME(uprv_isInvariantString)\n#define uprv_isInvariantUString U_ICU_ENTRY_POINT_RENAME(uprv_isInvariantUString)\n#define uprv_isNaN U_ICU_ENTRY_POINT_RENAME(uprv_isNaN)\n#define uprv_isNegativeInfinity U_ICU_ENTRY_POINT_RENAME(uprv_isNegativeInfinity)\n#define uprv_isPositiveInfinity U_ICU_ENTRY_POINT_RENAME(uprv_isPositiveInfinity)\n#define uprv_itou U_ICU_ENTRY_POINT_RENAME(uprv_itou)\n#define uprv_log U_ICU_ENTRY_POINT_RENAME(uprv_log)\n#define uprv_malloc U_ICU_ENTRY_POINT_RENAME(uprv_malloc)\n#define uprv_mapFile U_ICU_ENTRY_POINT_RENAME(uprv_mapFile)\n#define uprv_max U_ICU_ENTRY_POINT_RENAME(uprv_max)\n#define uprv_maxMantissa U_ICU_ENTRY_POINT_RENAME(uprv_maxMantissa)\n#define uprv_maximumPtr U_ICU_ENTRY_POINT_RENAME(uprv_maximumPtr)\n#define uprv_min U_ICU_ENTRY_POINT_RENAME(uprv_min)\n#define uprv_modf U_ICU_ENTRY_POINT_RENAME(uprv_modf)\n#define uprv_parseCurrency U_ICU_ENTRY_POINT_RENAME(uprv_parseCurrency)\n#define uprv_pathIsAbsolute U_ICU_ENTRY_POINT_RENAME(uprv_pathIsAbsolute)\n#define uprv_pow U_ICU_ENTRY_POINT_RENAME(uprv_pow)\n#define uprv_pow10 U_ICU_ENTRY_POINT_RENAME(uprv_pow10)\n#define uprv_realloc U_ICU_ENTRY_POINT_RENAME(uprv_realloc)\n#define uprv_round U_ICU_ENTRY_POINT_RENAME(uprv_round)\n#define uprv_sortArray U_ICU_ENTRY_POINT_RENAME(uprv_sortArray)\n#define uprv_stableBinarySearch U_ICU_ENTRY_POINT_RENAME(uprv_stableBinarySearch)\n#define uprv_strCompare U_ICU_ENTRY_POINT_RENAME(uprv_strCompare)\n#define uprv_strdup U_ICU_ENTRY_POINT_RENAME(uprv_strdup)\n#define uprv_stricmp U_ICU_ENTRY_POINT_RENAME(uprv_stricmp)\n#define uprv_strndup U_ICU_ENTRY_POINT_RENAME(uprv_strndup)\n#define uprv_strnicmp U_ICU_ENTRY_POINT_RENAME(uprv_strnicmp)\n#define uprv_syntaxError U_ICU_ENTRY_POINT_RENAME(uprv_syntaxError)\n#define uprv_timezone U_ICU_ENTRY_POINT_RENAME(uprv_timezone)\n#define uprv_toupper U_ICU_ENTRY_POINT_RENAME(uprv_toupper)\n#define uprv_trunc U_ICU_ENTRY_POINT_RENAME(uprv_trunc)\n#define uprv_tzname U_ICU_ENTRY_POINT_RENAME(uprv_tzname)\n#define uprv_tzset U_ICU_ENTRY_POINT_RENAME(uprv_tzset)\n#define uprv_uint16Comparator U_ICU_ENTRY_POINT_RENAME(uprv_uint16Comparator)\n#define uprv_uint32Comparator U_ICU_ENTRY_POINT_RENAME(uprv_uint32Comparator)\n#define uprv_unmapFile U_ICU_ENTRY_POINT_RENAME(uprv_unmapFile)\n#define upvec_cloneArray U_ICU_ENTRY_POINT_RENAME(upvec_cloneArray)\n#define upvec_close U_ICU_ENTRY_POINT_RENAME(upvec_close)\n#define upvec_compact U_ICU_ENTRY_POINT_RENAME(upvec_compact)\n#define upvec_compactToUTrie2Handler U_ICU_ENTRY_POINT_RENAME(upvec_compactToUTrie2Handler)\n#define upvec_compactToUTrie2WithRowIndexes U_ICU_ENTRY_POINT_RENAME(upvec_compactToUTrie2WithRowIndexes)\n#define upvec_getArray U_ICU_ENTRY_POINT_RENAME(upvec_getArray)\n#define upvec_getRow U_ICU_ENTRY_POINT_RENAME(upvec_getRow)\n#define upvec_getValue U_ICU_ENTRY_POINT_RENAME(upvec_getValue)\n#define upvec_open U_ICU_ENTRY_POINT_RENAME(upvec_open)\n#define upvec_setValue U_ICU_ENTRY_POINT_RENAME(upvec_setValue)\n#define uregex_appendReplacement U_ICU_ENTRY_POINT_RENAME(uregex_appendReplacement)\n#define uregex_appendReplacementUText U_ICU_ENTRY_POINT_RENAME(uregex_appendReplacementUText)\n#define uregex_appendTail U_ICU_ENTRY_POINT_RENAME(uregex_appendTail)\n#define uregex_appendTailUText U_ICU_ENTRY_POINT_RENAME(uregex_appendTailUText)\n#define uregex_clone U_ICU_ENTRY_POINT_RENAME(uregex_clone)\n#define uregex_close U_ICU_ENTRY_POINT_RENAME(uregex_close)\n#define uregex_end U_ICU_ENTRY_POINT_RENAME(uregex_end)\n#define uregex_end64 U_ICU_ENTRY_POINT_RENAME(uregex_end64)\n#define uregex_find U_ICU_ENTRY_POINT_RENAME(uregex_find)\n#define uregex_find64 U_ICU_ENTRY_POINT_RENAME(uregex_find64)\n#define uregex_findNext U_ICU_ENTRY_POINT_RENAME(uregex_findNext)\n#define uregex_flags U_ICU_ENTRY_POINT_RENAME(uregex_flags)\n#define uregex_getFindProgressCallback U_ICU_ENTRY_POINT_RENAME(uregex_getFindProgressCallback)\n#define uregex_getMatchCallback U_ICU_ENTRY_POINT_RENAME(uregex_getMatchCallback)\n#define uregex_getStackLimit U_ICU_ENTRY_POINT_RENAME(uregex_getStackLimit)\n#define uregex_getText U_ICU_ENTRY_POINT_RENAME(uregex_getText)\n#define uregex_getTimeLimit U_ICU_ENTRY_POINT_RENAME(uregex_getTimeLimit)\n#define uregex_getUText U_ICU_ENTRY_POINT_RENAME(uregex_getUText)\n#define uregex_group U_ICU_ENTRY_POINT_RENAME(uregex_group)\n#define uregex_groupCount U_ICU_ENTRY_POINT_RENAME(uregex_groupCount)\n#define uregex_groupNumberFromCName U_ICU_ENTRY_POINT_RENAME(uregex_groupNumberFromCName)\n#define uregex_groupNumberFromName U_ICU_ENTRY_POINT_RENAME(uregex_groupNumberFromName)\n#define uregex_groupUText U_ICU_ENTRY_POINT_RENAME(uregex_groupUText)\n#define uregex_hasAnchoringBounds U_ICU_ENTRY_POINT_RENAME(uregex_hasAnchoringBounds)\n#define uregex_hasTransparentBounds U_ICU_ENTRY_POINT_RENAME(uregex_hasTransparentBounds)\n#define uregex_hitEnd U_ICU_ENTRY_POINT_RENAME(uregex_hitEnd)\n#define uregex_lookingAt U_ICU_ENTRY_POINT_RENAME(uregex_lookingAt)\n#define uregex_lookingAt64 U_ICU_ENTRY_POINT_RENAME(uregex_lookingAt64)\n#define uregex_matches U_ICU_ENTRY_POINT_RENAME(uregex_matches)\n#define uregex_matches64 U_ICU_ENTRY_POINT_RENAME(uregex_matches64)\n#define uregex_open U_ICU_ENTRY_POINT_RENAME(uregex_open)\n#define uregex_openC U_ICU_ENTRY_POINT_RENAME(uregex_openC)\n#define uregex_openUText U_ICU_ENTRY_POINT_RENAME(uregex_openUText)\n#define uregex_pattern U_ICU_ENTRY_POINT_RENAME(uregex_pattern)\n#define uregex_patternUText U_ICU_ENTRY_POINT_RENAME(uregex_patternUText)\n#define uregex_refreshUText U_ICU_ENTRY_POINT_RENAME(uregex_refreshUText)\n#define uregex_regionEnd U_ICU_ENTRY_POINT_RENAME(uregex_regionEnd)\n#define uregex_regionEnd64 U_ICU_ENTRY_POINT_RENAME(uregex_regionEnd64)\n#define uregex_regionStart U_ICU_ENTRY_POINT_RENAME(uregex_regionStart)\n#define uregex_regionStart64 U_ICU_ENTRY_POINT_RENAME(uregex_regionStart64)\n#define uregex_replaceAll U_ICU_ENTRY_POINT_RENAME(uregex_replaceAll)\n#define uregex_replaceAllUText U_ICU_ENTRY_POINT_RENAME(uregex_replaceAllUText)\n#define uregex_replaceFirst U_ICU_ENTRY_POINT_RENAME(uregex_replaceFirst)\n#define uregex_replaceFirstUText U_ICU_ENTRY_POINT_RENAME(uregex_replaceFirstUText)\n#define uregex_requireEnd U_ICU_ENTRY_POINT_RENAME(uregex_requireEnd)\n#define uregex_reset U_ICU_ENTRY_POINT_RENAME(uregex_reset)\n#define uregex_reset64 U_ICU_ENTRY_POINT_RENAME(uregex_reset64)\n#define uregex_setFindProgressCallback U_ICU_ENTRY_POINT_RENAME(uregex_setFindProgressCallback)\n#define uregex_setMatchCallback U_ICU_ENTRY_POINT_RENAME(uregex_setMatchCallback)\n#define uregex_setRegion U_ICU_ENTRY_POINT_RENAME(uregex_setRegion)\n#define uregex_setRegion64 U_ICU_ENTRY_POINT_RENAME(uregex_setRegion64)\n#define uregex_setRegionAndStart U_ICU_ENTRY_POINT_RENAME(uregex_setRegionAndStart)\n#define uregex_setStackLimit U_ICU_ENTRY_POINT_RENAME(uregex_setStackLimit)\n#define uregex_setText U_ICU_ENTRY_POINT_RENAME(uregex_setText)\n#define uregex_setTimeLimit U_ICU_ENTRY_POINT_RENAME(uregex_setTimeLimit)\n#define uregex_setUText U_ICU_ENTRY_POINT_RENAME(uregex_setUText)\n#define uregex_split U_ICU_ENTRY_POINT_RENAME(uregex_split)\n#define uregex_splitUText U_ICU_ENTRY_POINT_RENAME(uregex_splitUText)\n#define uregex_start U_ICU_ENTRY_POINT_RENAME(uregex_start)\n#define uregex_start64 U_ICU_ENTRY_POINT_RENAME(uregex_start64)\n#define uregex_ucstr_unescape_charAt U_ICU_ENTRY_POINT_RENAME(uregex_ucstr_unescape_charAt)\n#define uregex_useAnchoringBounds U_ICU_ENTRY_POINT_RENAME(uregex_useAnchoringBounds)\n#define uregex_useTransparentBounds U_ICU_ENTRY_POINT_RENAME(uregex_useTransparentBounds)\n#define uregex_utext_unescape_charAt U_ICU_ENTRY_POINT_RENAME(uregex_utext_unescape_charAt)\n#define uregion_areEqual U_ICU_ENTRY_POINT_RENAME(uregion_areEqual)\n#define uregion_contains U_ICU_ENTRY_POINT_RENAME(uregion_contains)\n#define uregion_getAvailable U_ICU_ENTRY_POINT_RENAME(uregion_getAvailable)\n#define uregion_getContainedRegions U_ICU_ENTRY_POINT_RENAME(uregion_getContainedRegions)\n#define uregion_getContainedRegionsOfType U_ICU_ENTRY_POINT_RENAME(uregion_getContainedRegionsOfType)\n#define uregion_getContainingRegion U_ICU_ENTRY_POINT_RENAME(uregion_getContainingRegion)\n#define uregion_getContainingRegionOfType U_ICU_ENTRY_POINT_RENAME(uregion_getContainingRegionOfType)\n#define uregion_getNumericCode U_ICU_ENTRY_POINT_RENAME(uregion_getNumericCode)\n#define uregion_getPreferredValues U_ICU_ENTRY_POINT_RENAME(uregion_getPreferredValues)\n#define uregion_getRegionCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionCode)\n#define uregion_getRegionFromCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionFromCode)\n#define uregion_getRegionFromNumericCode U_ICU_ENTRY_POINT_RENAME(uregion_getRegionFromNumericCode)\n#define uregion_getType U_ICU_ENTRY_POINT_RENAME(uregion_getType)\n#define ureldatefmt_close U_ICU_ENTRY_POINT_RENAME(ureldatefmt_close)\n#define ureldatefmt_combineDateAndTime U_ICU_ENTRY_POINT_RENAME(ureldatefmt_combineDateAndTime)\n#define ureldatefmt_format U_ICU_ENTRY_POINT_RENAME(ureldatefmt_format)\n#define ureldatefmt_formatNumeric U_ICU_ENTRY_POINT_RENAME(ureldatefmt_formatNumeric)\n#define ureldatefmt_open U_ICU_ENTRY_POINT_RENAME(ureldatefmt_open)\n#define ures_close U_ICU_ENTRY_POINT_RENAME(ures_close)\n#define ures_copyResb U_ICU_ENTRY_POINT_RENAME(ures_copyResb)\n#define ures_countArrayItems U_ICU_ENTRY_POINT_RENAME(ures_countArrayItems)\n#define ures_findResource U_ICU_ENTRY_POINT_RENAME(ures_findResource)\n#define ures_findSubResource U_ICU_ENTRY_POINT_RENAME(ures_findSubResource)\n#define ures_getAllArrayItems U_ICU_ENTRY_POINT_RENAME(ures_getAllArrayItems)\n#define ures_getAllArrayItemsWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getAllArrayItemsWithFallback)\n#define ures_getAllTableItems U_ICU_ENTRY_POINT_RENAME(ures_getAllTableItems)\n#define ures_getAllTableItemsWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getAllTableItemsWithFallback)\n#define ures_getBinary U_ICU_ENTRY_POINT_RENAME(ures_getBinary)\n#define ures_getByIndex U_ICU_ENTRY_POINT_RENAME(ures_getByIndex)\n#define ures_getByKey U_ICU_ENTRY_POINT_RENAME(ures_getByKey)\n#define ures_getByKeyWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getByKeyWithFallback)\n#define ures_getFunctionalEquivalent U_ICU_ENTRY_POINT_RENAME(ures_getFunctionalEquivalent)\n#define ures_getInt U_ICU_ENTRY_POINT_RENAME(ures_getInt)\n#define ures_getIntVector U_ICU_ENTRY_POINT_RENAME(ures_getIntVector)\n#define ures_getKey U_ICU_ENTRY_POINT_RENAME(ures_getKey)\n#define ures_getKeywordValues U_ICU_ENTRY_POINT_RENAME(ures_getKeywordValues)\n#define ures_getLocale U_ICU_ENTRY_POINT_RENAME(ures_getLocale)\n#define ures_getLocaleByType U_ICU_ENTRY_POINT_RENAME(ures_getLocaleByType)\n#define ures_getLocaleInternal U_ICU_ENTRY_POINT_RENAME(ures_getLocaleInternal)\n#define ures_getName U_ICU_ENTRY_POINT_RENAME(ures_getName)\n#define ures_getNextResource U_ICU_ENTRY_POINT_RENAME(ures_getNextResource)\n#define ures_getNextString U_ICU_ENTRY_POINT_RENAME(ures_getNextString)\n#define ures_getSize U_ICU_ENTRY_POINT_RENAME(ures_getSize)\n#define ures_getString U_ICU_ENTRY_POINT_RENAME(ures_getString)\n#define ures_getStringByIndex U_ICU_ENTRY_POINT_RENAME(ures_getStringByIndex)\n#define ures_getStringByKey U_ICU_ENTRY_POINT_RENAME(ures_getStringByKey)\n#define ures_getStringByKeyWithFallback U_ICU_ENTRY_POINT_RENAME(ures_getStringByKeyWithFallback)\n#define ures_getType U_ICU_ENTRY_POINT_RENAME(ures_getType)\n#define ures_getUInt U_ICU_ENTRY_POINT_RENAME(ures_getUInt)\n#define ures_getUTF8String U_ICU_ENTRY_POINT_RENAME(ures_getUTF8String)\n#define ures_getUTF8StringByIndex U_ICU_ENTRY_POINT_RENAME(ures_getUTF8StringByIndex)\n#define ures_getUTF8StringByKey U_ICU_ENTRY_POINT_RENAME(ures_getUTF8StringByKey)\n#define ures_getVersion U_ICU_ENTRY_POINT_RENAME(ures_getVersion)\n#define ures_getVersionByKey U_ICU_ENTRY_POINT_RENAME(ures_getVersionByKey)\n#define ures_getVersionNumber U_ICU_ENTRY_POINT_RENAME(ures_getVersionNumber)\n#define ures_getVersionNumberInternal U_ICU_ENTRY_POINT_RENAME(ures_getVersionNumberInternal)\n#define ures_hasNext U_ICU_ENTRY_POINT_RENAME(ures_hasNext)\n#define ures_initStackObject U_ICU_ENTRY_POINT_RENAME(ures_initStackObject)\n#define ures_open U_ICU_ENTRY_POINT_RENAME(ures_open)\n#define ures_openAvailableLocales U_ICU_ENTRY_POINT_RENAME(ures_openAvailableLocales)\n#define ures_openDirect U_ICU_ENTRY_POINT_RENAME(ures_openDirect)\n#define ures_openFillIn U_ICU_ENTRY_POINT_RENAME(ures_openFillIn)\n#define ures_openNoDefault U_ICU_ENTRY_POINT_RENAME(ures_openNoDefault)\n#define ures_openU U_ICU_ENTRY_POINT_RENAME(ures_openU)\n#define ures_resetIterator U_ICU_ENTRY_POINT_RENAME(ures_resetIterator)\n#define ures_swap U_ICU_ENTRY_POINT_RENAME(ures_swap)\n#define uscript_breaksBetweenLetters U_ICU_ENTRY_POINT_RENAME(uscript_breaksBetweenLetters)\n#define uscript_closeRun U_ICU_ENTRY_POINT_RENAME(uscript_closeRun)\n#define uscript_getCode U_ICU_ENTRY_POINT_RENAME(uscript_getCode)\n#define uscript_getName U_ICU_ENTRY_POINT_RENAME(uscript_getName)\n#define uscript_getSampleString U_ICU_ENTRY_POINT_RENAME(uscript_getSampleString)\n#define uscript_getSampleUnicodeString U_ICU_ENTRY_POINT_RENAME(uscript_getSampleUnicodeString)\n#define uscript_getScript U_ICU_ENTRY_POINT_RENAME(uscript_getScript)\n#define uscript_getScriptExtensions U_ICU_ENTRY_POINT_RENAME(uscript_getScriptExtensions)\n#define uscript_getShortName U_ICU_ENTRY_POINT_RENAME(uscript_getShortName)\n#define uscript_getUsage U_ICU_ENTRY_POINT_RENAME(uscript_getUsage)\n#define uscript_hasScript U_ICU_ENTRY_POINT_RENAME(uscript_hasScript)\n#define uscript_isCased U_ICU_ENTRY_POINT_RENAME(uscript_isCased)\n#define uscript_isRightToLeft U_ICU_ENTRY_POINT_RENAME(uscript_isRightToLeft)\n#define uscript_nextRun U_ICU_ENTRY_POINT_RENAME(uscript_nextRun)\n#define uscript_openRun U_ICU_ENTRY_POINT_RENAME(uscript_openRun)\n#define uscript_resetRun U_ICU_ENTRY_POINT_RENAME(uscript_resetRun)\n#define uscript_setRunText U_ICU_ENTRY_POINT_RENAME(uscript_setRunText)\n#define usearch_close U_ICU_ENTRY_POINT_RENAME(usearch_close)\n#define usearch_first U_ICU_ENTRY_POINT_RENAME(usearch_first)\n#define usearch_following U_ICU_ENTRY_POINT_RENAME(usearch_following)\n#define usearch_getAttribute U_ICU_ENTRY_POINT_RENAME(usearch_getAttribute)\n#define usearch_getBreakIterator U_ICU_ENTRY_POINT_RENAME(usearch_getBreakIterator)\n#define usearch_getCollator U_ICU_ENTRY_POINT_RENAME(usearch_getCollator)\n#define usearch_getMatchedLength U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedLength)\n#define usearch_getMatchedStart U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedStart)\n#define usearch_getMatchedText U_ICU_ENTRY_POINT_RENAME(usearch_getMatchedText)\n#define usearch_getOffset U_ICU_ENTRY_POINT_RENAME(usearch_getOffset)\n#define usearch_getPattern U_ICU_ENTRY_POINT_RENAME(usearch_getPattern)\n#define usearch_getText U_ICU_ENTRY_POINT_RENAME(usearch_getText)\n#define usearch_handleNextCanonical U_ICU_ENTRY_POINT_RENAME(usearch_handleNextCanonical)\n#define usearch_handleNextExact U_ICU_ENTRY_POINT_RENAME(usearch_handleNextExact)\n#define usearch_handlePreviousCanonical U_ICU_ENTRY_POINT_RENAME(usearch_handlePreviousCanonical)\n#define usearch_handlePreviousExact U_ICU_ENTRY_POINT_RENAME(usearch_handlePreviousExact)\n#define usearch_last U_ICU_ENTRY_POINT_RENAME(usearch_last)\n#define usearch_next U_ICU_ENTRY_POINT_RENAME(usearch_next)\n#define usearch_open U_ICU_ENTRY_POINT_RENAME(usearch_open)\n#define usearch_openFromCollator U_ICU_ENTRY_POINT_RENAME(usearch_openFromCollator)\n#define usearch_preceding U_ICU_ENTRY_POINT_RENAME(usearch_preceding)\n#define usearch_previous U_ICU_ENTRY_POINT_RENAME(usearch_previous)\n#define usearch_reset U_ICU_ENTRY_POINT_RENAME(usearch_reset)\n#define usearch_search U_ICU_ENTRY_POINT_RENAME(usearch_search)\n#define usearch_searchBackwards U_ICU_ENTRY_POINT_RENAME(usearch_searchBackwards)\n#define usearch_setAttribute U_ICU_ENTRY_POINT_RENAME(usearch_setAttribute)\n#define usearch_setBreakIterator U_ICU_ENTRY_POINT_RENAME(usearch_setBreakIterator)\n#define usearch_setCollator U_ICU_ENTRY_POINT_RENAME(usearch_setCollator)\n#define usearch_setOffset U_ICU_ENTRY_POINT_RENAME(usearch_setOffset)\n#define usearch_setPattern U_ICU_ENTRY_POINT_RENAME(usearch_setPattern)\n#define usearch_setText U_ICU_ENTRY_POINT_RENAME(usearch_setText)\n#define uset_add U_ICU_ENTRY_POINT_RENAME(uset_add)\n#define uset_addAll U_ICU_ENTRY_POINT_RENAME(uset_addAll)\n#define uset_addAllCodePoints U_ICU_ENTRY_POINT_RENAME(uset_addAllCodePoints)\n#define uset_addRange U_ICU_ENTRY_POINT_RENAME(uset_addRange)\n#define uset_addString U_ICU_ENTRY_POINT_RENAME(uset_addString)\n#define uset_applyIntPropertyValue U_ICU_ENTRY_POINT_RENAME(uset_applyIntPropertyValue)\n#define uset_applyPattern U_ICU_ENTRY_POINT_RENAME(uset_applyPattern)\n#define uset_applyPropertyAlias U_ICU_ENTRY_POINT_RENAME(uset_applyPropertyAlias)\n#define uset_charAt U_ICU_ENTRY_POINT_RENAME(uset_charAt)\n#define uset_clear U_ICU_ENTRY_POINT_RENAME(uset_clear)\n#define uset_clone U_ICU_ENTRY_POINT_RENAME(uset_clone)\n#define uset_cloneAsThawed U_ICU_ENTRY_POINT_RENAME(uset_cloneAsThawed)\n#define uset_close U_ICU_ENTRY_POINT_RENAME(uset_close)\n#define uset_closeOver U_ICU_ENTRY_POINT_RENAME(uset_closeOver)\n#define uset_compact U_ICU_ENTRY_POINT_RENAME(uset_compact)\n#define uset_complement U_ICU_ENTRY_POINT_RENAME(uset_complement)\n#define uset_complementAll U_ICU_ENTRY_POINT_RENAME(uset_complementAll)\n#define uset_contains U_ICU_ENTRY_POINT_RENAME(uset_contains)\n#define uset_containsAll U_ICU_ENTRY_POINT_RENAME(uset_containsAll)\n#define uset_containsAllCodePoints U_ICU_ENTRY_POINT_RENAME(uset_containsAllCodePoints)\n#define uset_containsNone U_ICU_ENTRY_POINT_RENAME(uset_containsNone)\n#define uset_containsRange U_ICU_ENTRY_POINT_RENAME(uset_containsRange)\n#define uset_containsSome U_ICU_ENTRY_POINT_RENAME(uset_containsSome)\n#define uset_containsString U_ICU_ENTRY_POINT_RENAME(uset_containsString)\n#define uset_equals U_ICU_ENTRY_POINT_RENAME(uset_equals)\n#define uset_freeze U_ICU_ENTRY_POINT_RENAME(uset_freeze)\n#define uset_getItem U_ICU_ENTRY_POINT_RENAME(uset_getItem)\n#define uset_getItemCount U_ICU_ENTRY_POINT_RENAME(uset_getItemCount)\n#define uset_getSerializedRange U_ICU_ENTRY_POINT_RENAME(uset_getSerializedRange)\n#define uset_getSerializedRangeCount U_ICU_ENTRY_POINT_RENAME(uset_getSerializedRangeCount)\n#define uset_getSerializedSet U_ICU_ENTRY_POINT_RENAME(uset_getSerializedSet)\n#define uset_indexOf U_ICU_ENTRY_POINT_RENAME(uset_indexOf)\n#define uset_isEmpty U_ICU_ENTRY_POINT_RENAME(uset_isEmpty)\n#define uset_isFrozen U_ICU_ENTRY_POINT_RENAME(uset_isFrozen)\n#define uset_open U_ICU_ENTRY_POINT_RENAME(uset_open)\n#define uset_openEmpty U_ICU_ENTRY_POINT_RENAME(uset_openEmpty)\n#define uset_openPattern U_ICU_ENTRY_POINT_RENAME(uset_openPattern)\n#define uset_openPatternOptions U_ICU_ENTRY_POINT_RENAME(uset_openPatternOptions)\n#define uset_remove U_ICU_ENTRY_POINT_RENAME(uset_remove)\n#define uset_removeAll U_ICU_ENTRY_POINT_RENAME(uset_removeAll)\n#define uset_removeAllStrings U_ICU_ENTRY_POINT_RENAME(uset_removeAllStrings)\n#define uset_removeRange U_ICU_ENTRY_POINT_RENAME(uset_removeRange)\n#define uset_removeString U_ICU_ENTRY_POINT_RENAME(uset_removeString)\n#define uset_resemblesPattern U_ICU_ENTRY_POINT_RENAME(uset_resemblesPattern)\n#define uset_retain U_ICU_ENTRY_POINT_RENAME(uset_retain)\n#define uset_retainAll U_ICU_ENTRY_POINT_RENAME(uset_retainAll)\n#define uset_serialize U_ICU_ENTRY_POINT_RENAME(uset_serialize)\n#define uset_serializedContains U_ICU_ENTRY_POINT_RENAME(uset_serializedContains)\n#define uset_set U_ICU_ENTRY_POINT_RENAME(uset_set)\n#define uset_setSerializedToOne U_ICU_ENTRY_POINT_RENAME(uset_setSerializedToOne)\n#define uset_size U_ICU_ENTRY_POINT_RENAME(uset_size)\n#define uset_span U_ICU_ENTRY_POINT_RENAME(uset_span)\n#define uset_spanBack U_ICU_ENTRY_POINT_RENAME(uset_spanBack)\n#define uset_spanBackUTF8 U_ICU_ENTRY_POINT_RENAME(uset_spanBackUTF8)\n#define uset_spanUTF8 U_ICU_ENTRY_POINT_RENAME(uset_spanUTF8)\n#define uset_toPattern U_ICU_ENTRY_POINT_RENAME(uset_toPattern)\n#define uspoof_areConfusable U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusable)\n#define uspoof_areConfusableUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusableUTF8)\n#define uspoof_areConfusableUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_areConfusableUnicodeString)\n#define uspoof_check U_ICU_ENTRY_POINT_RENAME(uspoof_check)\n#define uspoof_checkUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_checkUTF8)\n#define uspoof_checkUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_checkUnicodeString)\n#define uspoof_clone U_ICU_ENTRY_POINT_RENAME(uspoof_clone)\n#define uspoof_close U_ICU_ENTRY_POINT_RENAME(uspoof_close)\n#define uspoof_getAllowedChars U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedChars)\n#define uspoof_getAllowedLocales U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedLocales)\n#define uspoof_getAllowedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getAllowedUnicodeSet)\n#define uspoof_getChecks U_ICU_ENTRY_POINT_RENAME(uspoof_getChecks)\n#define uspoof_getInclusionSet U_ICU_ENTRY_POINT_RENAME(uspoof_getInclusionSet)\n#define uspoof_getInclusionUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getInclusionUnicodeSet)\n#define uspoof_getRecommendedSet U_ICU_ENTRY_POINT_RENAME(uspoof_getRecommendedSet)\n#define uspoof_getRecommendedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_getRecommendedUnicodeSet)\n#define uspoof_getRestrictionLevel U_ICU_ENTRY_POINT_RENAME(uspoof_getRestrictionLevel)\n#define uspoof_getSkeleton U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeleton)\n#define uspoof_getSkeletonUTF8 U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeletonUTF8)\n#define uspoof_getSkeletonUnicodeString U_ICU_ENTRY_POINT_RENAME(uspoof_getSkeletonUnicodeString)\n#define uspoof_internalInitStatics U_ICU_ENTRY_POINT_RENAME(uspoof_internalInitStatics)\n#define uspoof_open U_ICU_ENTRY_POINT_RENAME(uspoof_open)\n#define uspoof_openFromSerialized U_ICU_ENTRY_POINT_RENAME(uspoof_openFromSerialized)\n#define uspoof_openFromSource U_ICU_ENTRY_POINT_RENAME(uspoof_openFromSource)\n#define uspoof_serialize U_ICU_ENTRY_POINT_RENAME(uspoof_serialize)\n#define uspoof_setAllowedChars U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedChars)\n#define uspoof_setAllowedLocales U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedLocales)\n#define uspoof_setAllowedUnicodeSet U_ICU_ENTRY_POINT_RENAME(uspoof_setAllowedUnicodeSet)\n#define uspoof_setChecks U_ICU_ENTRY_POINT_RENAME(uspoof_setChecks)\n#define uspoof_setRestrictionLevel U_ICU_ENTRY_POINT_RENAME(uspoof_setRestrictionLevel)\n#define uspoof_swap U_ICU_ENTRY_POINT_RENAME(uspoof_swap)\n#define usprep_close U_ICU_ENTRY_POINT_RENAME(usprep_close)\n#define usprep_open U_ICU_ENTRY_POINT_RENAME(usprep_open)\n#define usprep_openByType U_ICU_ENTRY_POINT_RENAME(usprep_openByType)\n#define usprep_prepare U_ICU_ENTRY_POINT_RENAME(usprep_prepare)\n#define usprep_swap U_ICU_ENTRY_POINT_RENAME(usprep_swap)\n#define ustr_hashCharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashCharsN)\n#define ustr_hashICharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashICharsN)\n#define ustr_hashUCharsN U_ICU_ENTRY_POINT_RENAME(ustr_hashUCharsN)\n#define ustrcase_internalFold U_ICU_ENTRY_POINT_RENAME(ustrcase_internalFold)\n#define ustrcase_internalToLower U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToLower)\n#define ustrcase_internalToTitle U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToTitle)\n#define ustrcase_internalToUpper U_ICU_ENTRY_POINT_RENAME(ustrcase_internalToUpper)\n#define ustrcase_map U_ICU_ENTRY_POINT_RENAME(ustrcase_map)\n#define ustrcase_setTempCaseMapLocale U_ICU_ENTRY_POINT_RENAME(ustrcase_setTempCaseMapLocale)\n#define utext_char32At U_ICU_ENTRY_POINT_RENAME(utext_char32At)\n#define utext_clone U_ICU_ENTRY_POINT_RENAME(utext_clone)\n#define utext_close U_ICU_ENTRY_POINT_RENAME(utext_close)\n#define utext_copy U_ICU_ENTRY_POINT_RENAME(utext_copy)\n#define utext_current32 U_ICU_ENTRY_POINT_RENAME(utext_current32)\n#define utext_equals U_ICU_ENTRY_POINT_RENAME(utext_equals)\n#define utext_extract U_ICU_ENTRY_POINT_RENAME(utext_extract)\n#define utext_freeze U_ICU_ENTRY_POINT_RENAME(utext_freeze)\n#define utext_getNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_getNativeIndex)\n#define utext_getPreviousNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_getPreviousNativeIndex)\n#define utext_hasMetaData U_ICU_ENTRY_POINT_RENAME(utext_hasMetaData)\n#define utext_isLengthExpensive U_ICU_ENTRY_POINT_RENAME(utext_isLengthExpensive)\n#define utext_isWritable U_ICU_ENTRY_POINT_RENAME(utext_isWritable)\n#define utext_moveIndex32 U_ICU_ENTRY_POINT_RENAME(utext_moveIndex32)\n#define utext_nativeLength U_ICU_ENTRY_POINT_RENAME(utext_nativeLength)\n#define utext_next32 U_ICU_ENTRY_POINT_RENAME(utext_next32)\n#define utext_next32From U_ICU_ENTRY_POINT_RENAME(utext_next32From)\n#define utext_openCharacterIterator U_ICU_ENTRY_POINT_RENAME(utext_openCharacterIterator)\n#define utext_openConstUnicodeString U_ICU_ENTRY_POINT_RENAME(utext_openConstUnicodeString)\n#define utext_openReplaceable U_ICU_ENTRY_POINT_RENAME(utext_openReplaceable)\n#define utext_openUChars U_ICU_ENTRY_POINT_RENAME(utext_openUChars)\n#define utext_openUTF8 U_ICU_ENTRY_POINT_RENAME(utext_openUTF8)\n#define utext_openUnicodeString U_ICU_ENTRY_POINT_RENAME(utext_openUnicodeString)\n#define utext_previous32 U_ICU_ENTRY_POINT_RENAME(utext_previous32)\n#define utext_previous32From U_ICU_ENTRY_POINT_RENAME(utext_previous32From)\n#define utext_replace U_ICU_ENTRY_POINT_RENAME(utext_replace)\n#define utext_setNativeIndex U_ICU_ENTRY_POINT_RENAME(utext_setNativeIndex)\n#define utext_setup U_ICU_ENTRY_POINT_RENAME(utext_setup)\n#define utf8_appendCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_appendCharSafeBody)\n#define utf8_back1SafeBody U_ICU_ENTRY_POINT_RENAME(utf8_back1SafeBody)\n#define utf8_countTrailBytes U_ICU_ENTRY_POINT_RENAME(utf8_countTrailBytes)\n#define utf8_nextCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_nextCharSafeBody)\n#define utf8_prevCharSafeBody U_ICU_ENTRY_POINT_RENAME(utf8_prevCharSafeBody)\n#define utmscale_fromInt64 U_ICU_ENTRY_POINT_RENAME(utmscale_fromInt64)\n#define utmscale_getTimeScaleValue U_ICU_ENTRY_POINT_RENAME(utmscale_getTimeScaleValue)\n#define utmscale_toInt64 U_ICU_ENTRY_POINT_RENAME(utmscale_toInt64)\n#define utrace_cleanup U_ICU_ENTRY_POINT_RENAME(utrace_cleanup)\n#define utrace_data U_ICU_ENTRY_POINT_RENAME(utrace_data)\n#define utrace_entry U_ICU_ENTRY_POINT_RENAME(utrace_entry)\n#define utrace_exit U_ICU_ENTRY_POINT_RENAME(utrace_exit)\n#define utrace_format U_ICU_ENTRY_POINT_RENAME(utrace_format)\n#define utrace_functionName U_ICU_ENTRY_POINT_RENAME(utrace_functionName)\n#define utrace_getFunctions U_ICU_ENTRY_POINT_RENAME(utrace_getFunctions)\n#define utrace_getLevel U_ICU_ENTRY_POINT_RENAME(utrace_getLevel)\n#define utrace_level U_ICU_ENTRY_POINT_RENAME(utrace_level)\n#define utrace_setFunctions U_ICU_ENTRY_POINT_RENAME(utrace_setFunctions)\n#define utrace_setLevel U_ICU_ENTRY_POINT_RENAME(utrace_setLevel)\n#define utrace_vformat U_ICU_ENTRY_POINT_RENAME(utrace_vformat)\n#define utrans_clone U_ICU_ENTRY_POINT_RENAME(utrans_clone)\n#define utrans_close U_ICU_ENTRY_POINT_RENAME(utrans_close)\n#define utrans_countAvailableIDs U_ICU_ENTRY_POINT_RENAME(utrans_countAvailableIDs)\n#define utrans_getAvailableID U_ICU_ENTRY_POINT_RENAME(utrans_getAvailableID)\n#define utrans_getID U_ICU_ENTRY_POINT_RENAME(utrans_getID)\n#define utrans_getSourceSet U_ICU_ENTRY_POINT_RENAME(utrans_getSourceSet)\n#define utrans_getUnicodeID U_ICU_ENTRY_POINT_RENAME(utrans_getUnicodeID)\n#define utrans_open U_ICU_ENTRY_POINT_RENAME(utrans_open)\n#define utrans_openIDs U_ICU_ENTRY_POINT_RENAME(utrans_openIDs)\n#define utrans_openInverse U_ICU_ENTRY_POINT_RENAME(utrans_openInverse)\n#define utrans_openU U_ICU_ENTRY_POINT_RENAME(utrans_openU)\n#define utrans_register U_ICU_ENTRY_POINT_RENAME(utrans_register)\n#define utrans_rep_caseContextIterator U_ICU_ENTRY_POINT_RENAME(utrans_rep_caseContextIterator)\n#define utrans_setFilter U_ICU_ENTRY_POINT_RENAME(utrans_setFilter)\n#define utrans_stripRules U_ICU_ENTRY_POINT_RENAME(utrans_stripRules)\n#define utrans_toRules U_ICU_ENTRY_POINT_RENAME(utrans_toRules)\n#define utrans_trans U_ICU_ENTRY_POINT_RENAME(utrans_trans)\n#define utrans_transIncremental U_ICU_ENTRY_POINT_RENAME(utrans_transIncremental)\n#define utrans_transIncrementalUChars U_ICU_ENTRY_POINT_RENAME(utrans_transIncrementalUChars)\n#define utrans_transUChars U_ICU_ENTRY_POINT_RENAME(utrans_transUChars)\n#define utrans_transliterator_cleanup U_ICU_ENTRY_POINT_RENAME(utrans_transliterator_cleanup)\n#define utrans_unregister U_ICU_ENTRY_POINT_RENAME(utrans_unregister)\n#define utrans_unregisterID U_ICU_ENTRY_POINT_RENAME(utrans_unregisterID)\n#define utrie2_clone U_ICU_ENTRY_POINT_RENAME(utrie2_clone)\n#define utrie2_cloneAsThawed U_ICU_ENTRY_POINT_RENAME(utrie2_cloneAsThawed)\n#define utrie2_close U_ICU_ENTRY_POINT_RENAME(utrie2_close)\n#define utrie2_enum U_ICU_ENTRY_POINT_RENAME(utrie2_enum)\n#define utrie2_enumForLeadSurrogate U_ICU_ENTRY_POINT_RENAME(utrie2_enumForLeadSurrogate)\n#define utrie2_freeze U_ICU_ENTRY_POINT_RENAME(utrie2_freeze)\n#define utrie2_fromUTrie U_ICU_ENTRY_POINT_RENAME(utrie2_fromUTrie)\n#define utrie2_get32 U_ICU_ENTRY_POINT_RENAME(utrie2_get32)\n#define utrie2_get32FromLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_get32FromLeadSurrogateCodeUnit)\n#define utrie2_getVersion U_ICU_ENTRY_POINT_RENAME(utrie2_getVersion)\n#define utrie2_internalU8NextIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8NextIndex)\n#define utrie2_internalU8PrevIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8PrevIndex)\n#define utrie2_isFrozen U_ICU_ENTRY_POINT_RENAME(utrie2_isFrozen)\n#define utrie2_open U_ICU_ENTRY_POINT_RENAME(utrie2_open)\n#define utrie2_openDummy U_ICU_ENTRY_POINT_RENAME(utrie2_openDummy)\n#define utrie2_openFromSerialized U_ICU_ENTRY_POINT_RENAME(utrie2_openFromSerialized)\n#define utrie2_serialize U_ICU_ENTRY_POINT_RENAME(utrie2_serialize)\n#define utrie2_set32 U_ICU_ENTRY_POINT_RENAME(utrie2_set32)\n#define utrie2_set32ForLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_set32ForLeadSurrogateCodeUnit)\n#define utrie2_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie2_setRange32)\n#define utrie2_swap U_ICU_ENTRY_POINT_RENAME(utrie2_swap)\n#define utrie2_swapAnyVersion U_ICU_ENTRY_POINT_RENAME(utrie2_swapAnyVersion)\n#define utrie_clone U_ICU_ENTRY_POINT_RENAME(utrie_clone)\n#define utrie_close U_ICU_ENTRY_POINT_RENAME(utrie_close)\n#define utrie_defaultGetFoldingOffset U_ICU_ENTRY_POINT_RENAME(utrie_defaultGetFoldingOffset)\n#define utrie_enum U_ICU_ENTRY_POINT_RENAME(utrie_enum)\n#define utrie_get32 U_ICU_ENTRY_POINT_RENAME(utrie_get32)\n#define utrie_getData U_ICU_ENTRY_POINT_RENAME(utrie_getData)\n#define utrie_open U_ICU_ENTRY_POINT_RENAME(utrie_open)\n#define utrie_serialize U_ICU_ENTRY_POINT_RENAME(utrie_serialize)\n#define utrie_set32 U_ICU_ENTRY_POINT_RENAME(utrie_set32)\n#define utrie_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie_setRange32)\n#define utrie_swap U_ICU_ENTRY_POINT_RENAME(utrie_swap)\n#define utrie_unserialize U_ICU_ENTRY_POINT_RENAME(utrie_unserialize)\n#define utrie_unserializeDummy U_ICU_ENTRY_POINT_RENAME(utrie_unserializeDummy)\n#define vzone_clone U_ICU_ENTRY_POINT_RENAME(vzone_clone)\n#define vzone_close U_ICU_ENTRY_POINT_RENAME(vzone_close)\n#define vzone_countTransitionRules U_ICU_ENTRY_POINT_RENAME(vzone_countTransitionRules)\n#define vzone_equals U_ICU_ENTRY_POINT_RENAME(vzone_equals)\n#define vzone_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(vzone_getDynamicClassID)\n#define vzone_getLastModified U_ICU_ENTRY_POINT_RENAME(vzone_getLastModified)\n#define vzone_getNextTransition U_ICU_ENTRY_POINT_RENAME(vzone_getNextTransition)\n#define vzone_getOffset U_ICU_ENTRY_POINT_RENAME(vzone_getOffset)\n#define vzone_getOffset2 U_ICU_ENTRY_POINT_RENAME(vzone_getOffset2)\n#define vzone_getOffset3 U_ICU_ENTRY_POINT_RENAME(vzone_getOffset3)\n#define vzone_getPreviousTransition U_ICU_ENTRY_POINT_RENAME(vzone_getPreviousTransition)\n#define vzone_getRawOffset U_ICU_ENTRY_POINT_RENAME(vzone_getRawOffset)\n#define vzone_getStaticClassID U_ICU_ENTRY_POINT_RENAME(vzone_getStaticClassID)\n#define vzone_getTZURL U_ICU_ENTRY_POINT_RENAME(vzone_getTZURL)\n#define vzone_hasSameRules U_ICU_ENTRY_POINT_RENAME(vzone_hasSameRules)\n#define vzone_inDaylightTime U_ICU_ENTRY_POINT_RENAME(vzone_inDaylightTime)\n#define vzone_openData U_ICU_ENTRY_POINT_RENAME(vzone_openData)\n#define vzone_openID U_ICU_ENTRY_POINT_RENAME(vzone_openID)\n#define vzone_setLastModified U_ICU_ENTRY_POINT_RENAME(vzone_setLastModified)\n#define vzone_setRawOffset U_ICU_ENTRY_POINT_RENAME(vzone_setRawOffset)\n#define vzone_setTZURL U_ICU_ENTRY_POINT_RENAME(vzone_setTZURL)\n#define vzone_useDaylightTime U_ICU_ENTRY_POINT_RENAME(vzone_useDaylightTime)\n#define vzone_write U_ICU_ENTRY_POINT_RENAME(vzone_write)\n#define vzone_writeFromStart U_ICU_ENTRY_POINT_RENAME(vzone_writeFromStart)\n#define vzone_writeSimple U_ICU_ENTRY_POINT_RENAME(vzone_writeSimple)\n#define zrule_close U_ICU_ENTRY_POINT_RENAME(zrule_close)\n#define zrule_equals U_ICU_ENTRY_POINT_RENAME(zrule_equals)\n#define zrule_getDSTSavings U_ICU_ENTRY_POINT_RENAME(zrule_getDSTSavings)\n#define zrule_getName U_ICU_ENTRY_POINT_RENAME(zrule_getName)\n#define zrule_getRawOffset U_ICU_ENTRY_POINT_RENAME(zrule_getRawOffset)\n#define zrule_isEquivalentTo U_ICU_ENTRY_POINT_RENAME(zrule_isEquivalentTo)\n#define ztrans_adoptFrom U_ICU_ENTRY_POINT_RENAME(ztrans_adoptFrom)\n#define ztrans_adoptTo U_ICU_ENTRY_POINT_RENAME(ztrans_adoptTo)\n#define ztrans_clone U_ICU_ENTRY_POINT_RENAME(ztrans_clone)\n#define ztrans_close U_ICU_ENTRY_POINT_RENAME(ztrans_close)\n#define ztrans_equals U_ICU_ENTRY_POINT_RENAME(ztrans_equals)\n#define ztrans_getDynamicClassID U_ICU_ENTRY_POINT_RENAME(ztrans_getDynamicClassID)\n#define ztrans_getFrom U_ICU_ENTRY_POINT_RENAME(ztrans_getFrom)\n#define ztrans_getStaticClassID U_ICU_ENTRY_POINT_RENAME(ztrans_getStaticClassID)\n#define ztrans_getTime U_ICU_ENTRY_POINT_RENAME(ztrans_getTime)\n#define ztrans_getTo U_ICU_ENTRY_POINT_RENAME(ztrans_getTo)\n#define ztrans_open U_ICU_ENTRY_POINT_RENAME(ztrans_open)\n#define ztrans_openEmpty U_ICU_ENTRY_POINT_RENAME(ztrans_openEmpty)\n#define ztrans_setFrom U_ICU_ENTRY_POINT_RENAME(ztrans_setFrom)\n#define ztrans_setTime U_ICU_ENTRY_POINT_RENAME(ztrans_setTime)\n#define ztrans_setTo U_ICU_ENTRY_POINT_RENAME(ztrans_setTo)\n\n#endif\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/src/res/node.ico",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/sample.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/pseudo-multimember-gzip.z",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/google_ssl_hello.bin",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/pseudo-multimember-gzip.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/person.jpg.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/person.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/test_cert.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/test/fixtures/keys/agent1-pfx.pem",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/openssl/ms/.rnd",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/openssl/doc/openssl_define_list.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/v8/benchmarks/v8-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/uv/img/banner.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/icu-small/source/data/in/icudt57l.dat",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/html/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/github-com-BryanDonovan-dummy-npm-foo.git.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/github-com-BryanDonovan-dummy-npm-bar.git.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/github-com-BryanDonovan-dummy-npm-buzz.git.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/forked-underscore-1.5.1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/scoped-underscore-1.3.1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/npmignore.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/gitignore-and-npmignore.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/gitignore.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/test/fixtures/github-com-BryanDonovan-npm-git-test.git.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/npmlog/node_modules/gauge/example.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/readable-stream/coverage/lcov-report/sort-arrow-sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/request/node_modules/hawk/images/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/request/node_modules/hawk/images/hawk.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/request/node_modules/hawk/node_modules/boom/images/boom.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/request/node_modules/hawk/node_modules/hoek/images/hoek.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/npm-registry-client/node_modules/retry/equation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/tar/test/cb-never-called-1.0.1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/deps/npm/node_modules/tar/test/fixtures.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/doc/osx_installer_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/doc/thin-white-stripe.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-node-js-6.2.2-rhniyk4m3ptym6r5ndfyhyxa4v2tupqu/spack-src/doc/full-white-stripe.jpg"
    ],
    "total_files": 10164
}