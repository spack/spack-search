{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/ioengines.c": "/*\n * The io parts of the fio tool, includes workers for sync and mmap'ed\n * io, as well as both posix and linux libaio support.\n *\n * sync io is implemented on top of aio.\n *\n * This is not really specific to fio, if the get_io_u/put_io_u and\n * structures was pulled into this as well it would be a perfectly\n * generic io engine that could be used for other projects.\n *\n */\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#include \"fio.h\"\n#include \"diskutil.h\"\n#include \"zbd.h\"\n\nstatic FLIST_HEAD(engine_list);\n\nstatic bool check_engine_ops(struct ioengine_ops *ops)\n{\n\tif (ops->version != FIO_IOOPS_VERSION) {\n\t\tlog_err(\"bad ioops version %d (want %d)\\n\", ops->version,\n\t\t\t\t\t\t\tFIO_IOOPS_VERSION);\n\t\treturn true;\n\t}\n\n\tif (!ops->queue) {\n\t\tlog_err(\"%s: no queue handler\\n\", ops->name);\n\t\treturn true;\n\t}\n\n\t/*\n\t * sync engines only need a ->queue()\n\t */\n\tif (ops->flags & FIO_SYNCIO)\n\t\treturn false;\n\n\tif (!ops->event || !ops->getevents) {\n\t\tlog_err(\"%s: no event/getevents handler\\n\", ops->name);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid unregister_ioengine(struct ioengine_ops *ops)\n{\n\tdprint(FD_IO, \"ioengine %s unregistered\\n\", ops->name);\n\tflist_del_init(&ops->list);\n}\n\nvoid register_ioengine(struct ioengine_ops *ops)\n{\n\tdprint(FD_IO, \"ioengine %s registered\\n\", ops->name);\n\tflist_add_tail(&ops->list, &engine_list);\n}\n\nstatic struct ioengine_ops *find_ioengine(const char *name)\n{\n\tstruct ioengine_ops *ops;\n\tstruct flist_head *entry;\n\n\tflist_for_each(entry, &engine_list) {\n\t\tops = flist_entry(entry, struct ioengine_ops, list);\n\t\tif (!strcmp(name, ops->name))\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ioengine_ops *dlopen_ioengine(struct thread_data *td,\n\t\t\t\t\t    const char *engine_lib)\n{\n\tstruct ioengine_ops *ops;\n\tvoid *dlhandle;\n\n\tdprint(FD_IO, \"dload engine %s\\n\", engine_lib);\n\n\tdlerror();\n\tdlhandle = dlopen(engine_lib, RTLD_LAZY);\n\tif (!dlhandle) {\n\t\ttd_vmsg(td, -1, dlerror(), \"dlopen\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Unlike the included modules, external engines should have a\n\t * non-static ioengine structure that we can reference.\n\t */\n\tops = dlsym(dlhandle, engine_lib);\n\tif (!ops)\n\t\tops = dlsym(dlhandle, \"ioengine\");\n\n\t/*\n\t * For some external engines (like C++ ones) it is not that trivial\n\t * to provide a non-static ionengine structure that we can reference.\n\t * Instead we call a method which allocates the required ioengine\n\t * structure.\n\t */\n\tif (!ops) {\n\t\tget_ioengine_t get_ioengine = dlsym(dlhandle, \"get_ioengine\");\n\n\t\tif (get_ioengine)\n\t\t\tget_ioengine(&ops);\n\t}\n\n\tif (!ops) {\n\t\ttd_vmsg(td, -1, dlerror(), \"dlsym\");\n\t\tdlclose(dlhandle);\n\t\treturn NULL;\n\t}\n\n\ttd->io_ops_dlhandle = dlhandle;\n\treturn ops;\n}\n\nstatic struct ioengine_ops *__load_ioengine(const char *engine)\n{\n\t/*\n\t * linux libaio has alias names, so convert to what we want\n\t */\n\tif (!strncmp(engine, \"linuxaio\", 8)) {\n\t\tdprint(FD_IO, \"converting ioengine name: %s -> libaio\\n\",\n\t\t       engine);\n\t\tengine = \"libaio\";\n\t}\n\n\tdprint(FD_IO, \"load ioengine %s\\n\", engine);\n\treturn find_ioengine(engine);\n}\n\nstruct ioengine_ops *load_ioengine(struct thread_data *td)\n{\n\tstruct ioengine_ops *ops = NULL;\n\tconst char *name;\n\n\t/*\n\t * Use ->ioengine_so_path if an external ioengine path is specified.\n\t * In this case, ->ioengine is \"external\" which also means the prefix\n\t * for external ioengines \"external:\" is properly used.\n\t */\n\tname = td->o.ioengine_so_path ?: td->o.ioengine;\n\n\t/*\n\t * Try to load ->ioengine first, and if failed try to dlopen(3) either\n\t * ->ioengine or ->ioengine_so_path.  This is redundant for an external\n\t * ioengine with prefix, and also leaves the possibility of unexpected\n\t * behavior (e.g. if the \"external\" ioengine exists), but we do this\n\t * so as not to break job files not using the prefix.\n\t */\n\tops = __load_ioengine(td->o.ioengine);\n\tif (!ops)\n\t\tops = dlopen_ioengine(td, name);\n\n\t/*\n\t * If ops is NULL, we failed to load ->ioengine, and also failed to\n\t * dlopen(3) either ->ioengine or ->ioengine_so_path as a path.\n\t */\n\tif (!ops) {\n\t\tlog_err(\"fio: engine %s not loadable\\n\", name);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Check that the required methods are there.\n\t */\n\tif (check_engine_ops(ops))\n\t\treturn NULL;\n\n\treturn ops;\n}\n\n/*\n * For cleaning up an ioengine which never made it to init().\n */\nvoid free_ioengine(struct thread_data *td)\n{\n\tdprint(FD_IO, \"free ioengine %s\\n\", td->io_ops->name);\n\n\tif (td->eo && td->io_ops->options) {\n\t\toptions_free(td->io_ops->options, td->eo);\n\t\tfree(td->eo);\n\t\ttd->eo = NULL;\n\t}\n\n\tif (td->io_ops_dlhandle) {\n\t\tdlclose(td->io_ops_dlhandle);\n\t\ttd->io_ops_dlhandle = NULL;\n\t}\n\n\ttd->io_ops = NULL;\n}\n\nvoid close_ioengine(struct thread_data *td)\n{\n\tdprint(FD_IO, \"close ioengine %s\\n\", td->io_ops->name);\n\n\tif (td->io_ops->cleanup) {\n\t\ttd->io_ops->cleanup(td);\n\t\ttd->io_ops_data = NULL;\n\t}\n\n\tfree_ioengine(td);\n}\n\nint td_io_prep(struct thread_data *td, struct io_u *io_u)\n{\n\tdprint_io_u(io_u, \"prep\");\n\tfio_ro_check(td, io_u);\n\n\tlock_file(td, io_u->file, io_u->ddir);\n\n\tif (td->io_ops->prep) {\n\t\tint ret = td->io_ops->prep(td, io_u);\n\n\t\tdprint(FD_IO, \"prep: io_u %p: ret=%d\\n\", io_u, ret);\n\n\t\tif (ret)\n\t\t\tunlock_file(td, io_u->file);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint td_io_getevents(struct thread_data *td, unsigned int min, unsigned int max,\n\t\t    const struct timespec *t)\n{\n\tint r = 0;\n\n\t/*\n\t * For ioengine=rdma one side operation RDMA_WRITE or RDMA_READ,\n\t * server side gets a message from the client\n\t * side that the task is finished, and\n\t * td->done is set to 1 after td_io_commit(). In this case,\n\t * there is no need to reap complete event in server side.\n\t */\n\tif (td->done)\n\t\treturn 0;\n\n\tif (min > 0 && td->io_ops->commit) {\n\t\tr = td->io_ops->commit(td);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tif (max > td->cur_depth)\n\t\tmax = td->cur_depth;\n\tif (min > max)\n\t\tmax = min;\n\n\tr = 0;\n\tif (max && td->io_ops->getevents)\n\t\tr = td->io_ops->getevents(td, min, max, t);\nout:\n\tif (r >= 0) {\n\t\t/*\n\t\t * Reflect that our submitted requests were retrieved with\n\t\t * whatever OS async calls are in the underlying engine.\n\t\t */\n\t\ttd->io_u_in_flight -= r;\n\t\tio_u_mark_complete(td, r);\n\t} else\n\t\ttd_verror(td, r, \"get_events\");\n\n\tdprint(FD_IO, \"getevents: %d\\n\", r);\n\treturn r;\n}\n\nenum fio_q_status td_io_queue(struct thread_data *td, struct io_u *io_u)\n{\n\tconst enum fio_ddir ddir = acct_ddir(io_u);\n\tunsigned long long buflen = io_u->xfer_buflen;\n\tenum fio_q_status ret;\n\n\tdprint_io_u(io_u, \"queue\");\n\tfio_ro_check(td, io_u);\n\n\tassert((io_u->flags & IO_U_F_FLIGHT) == 0);\n\tio_u_set(td, io_u, IO_U_F_FLIGHT);\n\n\t/*\n\t * If overlap checking was enabled in offload mode we\n\t * can release this lock that was acquired when we\n\t * started the overlap check because the IO_U_F_FLIGHT\n\t * flag is now set\n\t */\n\tif (td_offload_overlap(td))\n\t\tpthread_mutex_unlock(&overlap_check);\n\n\tassert(fio_file_open(io_u->file));\n\n\t/*\n\t * If using a write iolog, store this entry.\n\t */\n\tlog_io_u(td, io_u);\n\n\tio_u->error = 0;\n\tio_u->resid = 0;\n\n\tif (td_ioengine_flagged(td, FIO_SYNCIO) ||\n\t\t(td_ioengine_flagged(td, FIO_ASYNCIO_SYNC_TRIM) && \n\t\tio_u->ddir == DDIR_TRIM)) {\n\t\tif (fio_fill_issue_time(td))\n\t\t\tfio_gettime(&io_u->issue_time, NULL);\n\n\t\t/*\n\t\t * only used for iolog\n\t\t */\n\t\tif (td->o.read_iolog_file)\n\t\t\tmemcpy(&td->last_issue, &io_u->issue_time,\n\t\t\t\t\tsizeof(io_u->issue_time));\n\t}\n\n\n\tif (ddir_rw(ddir)) {\n\t\tif (!(io_u->flags & IO_U_F_VER_LIST)) {\n\t\t\ttd->io_issues[ddir]++;\n\t\t\ttd->io_issue_bytes[ddir] += buflen;\n\t\t}\n\t\ttd->rate_io_issue_bytes[ddir] += buflen;\n\t}\n\n\tret = td->io_ops->queue(td, io_u);\n\tzbd_queue_io_u(io_u, ret);\n\n\tunlock_file(td, io_u->file);\n\n\tif (ret == FIO_Q_BUSY && ddir_rw(ddir)) {\n\t\ttd->io_issues[ddir]--;\n\t\ttd->io_issue_bytes[ddir] -= buflen;\n\t\ttd->rate_io_issue_bytes[ddir] -= buflen;\n\t\tio_u_clear(td, io_u, IO_U_F_FLIGHT);\n\t}\n\n\t/*\n\t * If an error was seen and the io engine didn't propagate it\n\t * back to 'td', do so.\n\t */\n\tif (io_u->error && !td->error)\n\t\ttd_verror(td, io_u->error, \"td_io_queue\");\n\n\t/*\n\t * Add warning for O_DIRECT so that users have an easier time\n\t * spotting potentially bad alignment. If this triggers for the first\n\t * IO, then it's likely an alignment problem or because the host fs\n\t * does not support O_DIRECT\n\t */\n\tif (io_u->error == EINVAL && td->io_issues[io_u->ddir & 1] == 1 &&\n\t    td->o.odirect) {\n\n\t\tlog_info(\"fio: first direct IO errored. File system may not \"\n\t\t\t \"support direct IO, or iomem_align= is bad, or \"\n\t\t\t \"invalid block size. Try setting direct=0.\\n\");\n\t}\n\n\tif (zbd_unaligned_write(io_u->error) &&\n\t    td->io_issues[io_u->ddir & 1] == 1 &&\n\t    td->o.zone_mode != ZONE_MODE_ZBD) {\n\t\tlog_info(\"fio: first I/O failed. If %s is a zoned block device, consider --zonemode=zbd\\n\",\n\t\t\t io_u->file->file_name);\n\t}\n\n\tif (!td->io_ops->commit) {\n\t\tio_u_mark_submit(td, 1);\n\t\tio_u_mark_complete(td, 1);\n\t\tzbd_put_io_u(io_u);\n\t}\n\n\tif (ret == FIO_Q_COMPLETED) {\n\t\tif (ddir_rw(io_u->ddir) ||\n\t\t    (ddir_sync(io_u->ddir) && td->runstate != TD_FSYNCING)) {\n\t\t\tio_u_mark_depth(td, 1);\n\t\t\ttd->ts.total_io_u[io_u->ddir]++;\n\t\t}\n\t} else if (ret == FIO_Q_QUEUED) {\n\t\ttd->io_u_queued++;\n\n\t\tif (ddir_rw(io_u->ddir) ||\n\t\t    (ddir_sync(io_u->ddir) && td->runstate != TD_FSYNCING))\n\t\t\ttd->ts.total_io_u[io_u->ddir]++;\n\n\t\tif (td->io_u_queued >= td->o.iodepth_batch)\n\t\t\ttd_io_commit(td);\n\t}\n\n\tif (!td_ioengine_flagged(td, FIO_SYNCIO) &&\n\t\t(!td_ioengine_flagged(td, FIO_ASYNCIO_SYNC_TRIM) ||\n\t\t io_u->ddir != DDIR_TRIM)) {\n\t\tif (fio_fill_issue_time(td))\n\t\t\tfio_gettime(&io_u->issue_time, NULL);\n\n\t\t/*\n\t\t * only used for iolog\n\t\t */\n\t\tif (td->o.read_iolog_file)\n\t\t\tmemcpy(&td->last_issue, &io_u->issue_time,\n\t\t\t\t\tsizeof(io_u->issue_time));\n\t}\n\n\treturn ret;\n}\n\nint td_io_init(struct thread_data *td)\n{\n\tint ret = 0;\n\n\tif (td->io_ops->init) {\n\t\tret = td->io_ops->init(td);\n\t\tif (ret)\n\t\t\tlog_err(\"fio: io engine %s init failed.%s\\n\",\n\t\t\t\ttd->io_ops->name,\n\t\t\t\ttd->o.iodepth > 1 ?\n\t\t\t\t\" Perhaps try reducing io depth?\" : \"\");\n\t\telse\n\t\t\ttd->io_ops_init = 1;\n\t\tif (!td->error)\n\t\t\ttd->error = ret;\n\t}\n\n\treturn ret;\n}\n\nvoid td_io_commit(struct thread_data *td)\n{\n\tint ret;\n\n\tdprint(FD_IO, \"calling ->commit(), depth %d\\n\", td->cur_depth);\n\n\tif (!td->cur_depth || !td->io_u_queued)\n\t\treturn;\n\n\tio_u_mark_depth(td, td->io_u_queued);\n\n\tif (td->io_ops->commit) {\n\t\tret = td->io_ops->commit(td);\n\t\tif (ret)\n\t\t\ttd_verror(td, -ret, \"io commit\");\n\t}\n\n\t/*\n\t * Reflect that events were submitted as async IO requests.\n\t */\n\ttd->io_u_in_flight += td->io_u_queued;\n\ttd->io_u_queued = 0;\n}\n\nint td_io_open_file(struct thread_data *td, struct fio_file *f)\n{\n\tif (fio_file_closing(f)) {\n\t\t/*\n\t\t * Open translates to undo closing.\n\t\t */\n\t\tfio_file_clear_closing(f);\n\t\tget_file(f);\n\t\treturn 0;\n\t}\n\tassert(!fio_file_open(f));\n\tassert(f->fd == -1);\n\tassert(td->io_ops->open_file);\n\n\tif (td->io_ops->open_file(td, f)) {\n\t\tif (td->error == EINVAL && td->o.odirect)\n\t\t\tlog_err(\"fio: destination does not support O_DIRECT\\n\");\n\t\tif (td->error == EMFILE) {\n\t\t\tlog_err(\"fio: try reducing/setting openfiles (failed\"\n\t\t\t\t\" at %u of %u)\\n\", td->nr_open_files,\n\t\t\t\t\t\t\ttd->o.nr_files);\n\t\t}\n\n\t\tassert(f->fd == -1);\n\t\tassert(!fio_file_open(f));\n\t\treturn 1;\n\t}\n\n\tfio_file_reset(td, f);\n\tfio_file_set_open(f);\n\tfio_file_clear_closing(f);\n\tdisk_util_inc(f->du);\n\n\ttd->nr_open_files++;\n\tget_file(f);\n\n\tif (f->filetype == FIO_TYPE_PIPE) {\n\t\tif (td_random(td)) {\n\t\t\tlog_err(\"fio: can't seek on pipes (no random io)\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (td_ioengine_flagged(td, FIO_DISKLESSIO))\n\t\tgoto done;\n\n\tif (td->o.invalidate_cache && file_invalidate_cache(td, f))\n\t\tgoto err;\n\n\tif (td->o.fadvise_hint != F_ADV_NONE &&\n\t    (f->filetype == FIO_TYPE_BLOCK || f->filetype == FIO_TYPE_FILE)) {\n\t\tint flags;\n\n\t\tif (td->o.fadvise_hint == F_ADV_TYPE) {\n\t\t\tif (td_random(td))\n\t\t\t\tflags = POSIX_FADV_RANDOM;\n\t\t\telse\n\t\t\t\tflags = POSIX_FADV_SEQUENTIAL;\n\t\t} else if (td->o.fadvise_hint == F_ADV_RANDOM)\n\t\t\tflags = POSIX_FADV_RANDOM;\n\t\telse if (td->o.fadvise_hint == F_ADV_SEQUENTIAL)\n\t\t\tflags = POSIX_FADV_SEQUENTIAL;\n\t\telse {\n\t\t\tlog_err(\"fio: unknown fadvise type %d\\n\",\n\t\t\t\t\t\t\ttd->o.fadvise_hint);\n\t\t\tflags = POSIX_FADV_NORMAL;\n\t\t}\n\n\t\tif (posix_fadvise(f->fd, f->file_offset, f->io_size, flags) < 0) {\n\t\t\tif (!fio_did_warn(FIO_WARN_FADVISE))\n\t\t\t\tlog_err(\"fio: fadvise hint failed\\n\");\n\t\t}\n\t}\n#ifdef FIO_HAVE_WRITE_HINT\n\tif (fio_option_is_set(&td->o, write_hint) &&\n\t    (f->filetype == FIO_TYPE_BLOCK || f->filetype == FIO_TYPE_FILE)) {\n\t\tuint64_t hint = td->o.write_hint;\n\t\tint cmd;\n\n\t\t/*\n\t\t * For direct IO, we just need/want to set the hint on\n\t\t * the file descriptor. For buffered IO, we need to set\n\t\t * it on the inode.\n\t\t */\n\t\tif (td->o.odirect)\n\t\t\tcmd = F_SET_FILE_RW_HINT;\n\t\telse\n\t\t\tcmd = F_SET_RW_HINT;\n\n\t\tif (fcntl(f->fd, cmd, &hint) < 0) {\n\t\t\ttd_verror(td, errno, \"fcntl write hint\");\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\n\tif (td->o.odirect && !OS_O_DIRECT && fio_set_directio(td, f))\n\t\tgoto err;\n\ndone:\n\tlog_file(td, f, FIO_LOG_OPEN_FILE);\n\treturn 0;\nerr:\n\tdisk_util_dec(f->du);\n\tif (td->io_ops->close_file)\n\t\ttd->io_ops->close_file(td, f);\n\treturn 1;\n}\n\nint td_io_close_file(struct thread_data *td, struct fio_file *f)\n{\n\tif (!fio_file_closing(f))\n\t\tlog_file(td, f, FIO_LOG_CLOSE_FILE);\n\n\t/*\n\t * mark as closing, do real close when last io on it has completed\n\t */\n\tfio_file_set_closing(f);\n\n\treturn put_file(td, f);\n}\n\nint td_io_unlink_file(struct thread_data *td, struct fio_file *f)\n{\n\tif (td->io_ops->unlink_file)\n\t\treturn td->io_ops->unlink_file(td, f);\n\telse {\n\t\tint ret;\n\n\t\tret = unlink(f->file_name);\n\t\tif (ret < 0)\n\t\t\treturn errno;\n\n\t\treturn 0;\n\t}\n}\n\nint td_io_get_file_size(struct thread_data *td, struct fio_file *f)\n{\n\tif (!td->io_ops->get_file_size)\n\t\treturn 0;\n\n\treturn td->io_ops->get_file_size(td, f);\n}\n\nint fio_show_ioengine_help(const char *engine)\n{\n\tstruct flist_head *entry;\n\tstruct thread_data td;\n\tstruct ioengine_ops *io_ops;\n\tchar *sep;\n\tint ret = 1;\n\n\tif (!engine || !*engine) {\n\t\tlog_info(\"Available IO engines:\\n\");\n\t\tflist_for_each(entry, &engine_list) {\n\t\t\tio_ops = flist_entry(entry, struct ioengine_ops, list);\n\t\t\tlog_info(\"\\t%s\\n\", io_ops->name);\n\t\t}\n\t\treturn 0;\n\t}\n\tsep = strchr(engine, ',');\n\tif (sep) {\n\t\t*sep = 0;\n\t\tsep++;\n\t}\n\n\tmemset(&td, 0, sizeof(struct thread_data));\n\ttd.o.ioengine = (char *)engine;\n\tio_ops = load_ioengine(&td);\n\n\tif (!io_ops) {\n\t\tlog_info(\"IO engine %s not found\\n\", engine);\n\t\treturn 1;\n\t}\n\n\tif (io_ops->options)\n\t\tret = show_cmd_help(io_ops->options, sep);\n\telse\n\t\tlog_info(\"IO engine %s has no options\\n\", io_ops->name);\n\n\tfree_ioengine(&td);\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/os/windows/posix.c": "/* This file contains functions which implement those POSIX and Linux functions\n * that MinGW and Microsoft don't provide. The implementations contain just enough\n * functionality to support fio.\n */\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <windows.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <pthread.h>\n#include <time.h>\n#include <semaphore.h>\n#include <sys/shm.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <poll.h>\n#include <sys/wait.h>\n#include <setjmp.h>\n\n#include \"../os-windows.h\"\n#include \"../../lib/hweight.h\"\n\nextern unsigned long mtime_since_now(struct timespec *);\nextern void fio_gettime(struct timespec *, void *);\n\nint win_to_posix_error(DWORD winerr)\n{\n\tswitch (winerr) {\n\tcase ERROR_SUCCESS:\n\t\treturn 0;\n\tcase ERROR_FILE_NOT_FOUND:\n\t\treturn ENOENT;\n\tcase ERROR_PATH_NOT_FOUND:\n\t\treturn ENOENT;\n\tcase ERROR_ACCESS_DENIED:\n\t\treturn EACCES;\n\tcase ERROR_INVALID_HANDLE:\n\t\treturn EBADF;\n\tcase ERROR_NOT_ENOUGH_MEMORY:\n\t\treturn ENOMEM;\n\tcase ERROR_INVALID_DATA:\n\t\treturn EINVAL;\n\tcase ERROR_OUTOFMEMORY:\n\t\treturn ENOMEM;\n\tcase ERROR_INVALID_DRIVE:\n\t\treturn ENODEV;\n\tcase ERROR_NOT_SAME_DEVICE:\n\t\treturn EXDEV;\n\tcase ERROR_WRITE_PROTECT:\n\t\treturn EROFS;\n\tcase ERROR_BAD_UNIT:\n\t\treturn ENODEV;\n\tcase ERROR_NOT_READY:\n\t\treturn EAGAIN;\n\tcase ERROR_SHARING_VIOLATION:\n\t\treturn EACCES;\n\tcase ERROR_LOCK_VIOLATION:\n\t\treturn EACCES;\n\tcase ERROR_SHARING_BUFFER_EXCEEDED:\n\t\treturn ENOLCK;\n\tcase ERROR_HANDLE_DISK_FULL:\n\t\treturn ENOSPC;\n\tcase ERROR_NOT_SUPPORTED:\n\t\treturn ENOSYS;\n\tcase ERROR_FILE_EXISTS:\n\t\treturn EEXIST;\n\tcase ERROR_CANNOT_MAKE:\n\t\treturn EPERM;\n\tcase ERROR_INVALID_PARAMETER:\n\t\treturn EINVAL;\n\tcase ERROR_NO_PROC_SLOTS:\n\t\treturn EAGAIN;\n\tcase ERROR_BROKEN_PIPE:\n\t\treturn EPIPE;\n\tcase ERROR_OPEN_FAILED:\n\t\treturn EIO;\n\tcase ERROR_NO_MORE_SEARCH_HANDLES:\n\t\treturn ENFILE;\n\tcase ERROR_CALL_NOT_IMPLEMENTED:\n\t\treturn ENOSYS;\n\tcase ERROR_INVALID_NAME:\n\t\treturn ENOENT;\n\tcase ERROR_WAIT_NO_CHILDREN:\n\t\treturn ECHILD;\n\tcase ERROR_CHILD_NOT_COMPLETE:\n\t\treturn EBUSY;\n\tcase ERROR_DIR_NOT_EMPTY:\n\t\treturn ENOTEMPTY;\n\tcase ERROR_SIGNAL_REFUSED:\n\t\treturn EIO;\n\tcase ERROR_BAD_PATHNAME:\n\t\treturn ENOENT;\n\tcase ERROR_SIGNAL_PENDING:\n\t\treturn EBUSY;\n\tcase ERROR_MAX_THRDS_REACHED:\n\t\treturn EAGAIN;\n\tcase ERROR_BUSY:\n\t\treturn EBUSY;\n\tcase ERROR_ALREADY_EXISTS:\n\t\treturn EEXIST;\n\tcase ERROR_NO_SIGNAL_SENT:\n\t\treturn EIO;\n\tcase ERROR_FILENAME_EXCED_RANGE:\n\t\treturn EINVAL;\n\tcase ERROR_META_EXPANSION_TOO_LONG:\n\t\treturn EINVAL;\n\tcase ERROR_INVALID_SIGNAL_NUMBER:\n\t\treturn EINVAL;\n\tcase ERROR_THREAD_1_INACTIVE:\n\t\treturn EINVAL;\n\tcase ERROR_BAD_PIPE:\n\t\treturn EINVAL;\n\tcase ERROR_PIPE_BUSY:\n\t\treturn EBUSY;\n\tcase ERROR_NO_DATA:\n\t\treturn EPIPE;\n\tcase ERROR_MORE_DATA:\n\t\treturn EAGAIN;\n\tcase ERROR_DIRECTORY:\n\t\treturn ENOTDIR;\n\tcase ERROR_PIPE_CONNECTED:\n\t\treturn EBUSY;\n\tcase ERROR_NO_TOKEN:\n\t\treturn EINVAL;\n\tcase ERROR_PROCESS_ABORTED:\n\t\treturn EFAULT;\n\tcase ERROR_BAD_DEVICE:\n\t\treturn ENODEV;\n\tcase ERROR_BAD_USERNAME:\n\t\treturn EINVAL;\n\tcase ERROR_OPEN_FILES:\n\t\treturn EAGAIN;\n\tcase ERROR_ACTIVE_CONNECTIONS:\n\t\treturn EAGAIN;\n\tcase ERROR_DEVICE_IN_USE:\n\t\treturn EBUSY;\n\tcase ERROR_INVALID_AT_INTERRUPT_TIME:\n\t\treturn EINTR;\n\tcase ERROR_IO_DEVICE:\n\t\treturn EIO;\n\tcase ERROR_NOT_OWNER:\n\t\treturn EPERM;\n\tcase ERROR_END_OF_MEDIA:\n\t\treturn ENOSPC;\n\tcase ERROR_EOM_OVERFLOW:\n\t\treturn ENOSPC;\n\tcase ERROR_BEGINNING_OF_MEDIA:\n\t\treturn ESPIPE;\n\tcase ERROR_SETMARK_DETECTED:\n\t\treturn ESPIPE;\n\tcase ERROR_NO_DATA_DETECTED:\n\t\treturn ENOSPC;\n\tcase ERROR_POSSIBLE_DEADLOCK:\n\t\treturn EDEADLOCK;\n\tcase ERROR_CRC:\n\t\treturn EIO;\n\tcase ERROR_NEGATIVE_SEEK:\n\t\treturn EINVAL;\n\tcase ERROR_DISK_FULL:\n\t\treturn ENOSPC;\n\tcase ERROR_NOACCESS:\n\t\treturn EFAULT;\n\tcase ERROR_FILE_INVALID:\n\t\treturn ENXIO;\n\tdefault:\n\t\tlog_err(\"fio: windows error %d not handled\\n\", winerr);\n\t\treturn EIO;\n\t}\n\n\treturn winerr;\n}\n\nint GetNumLogicalProcessors(void)\n{\n\tSYSTEM_LOGICAL_PROCESSOR_INFORMATION *processor_info = NULL;\n\tDWORD len = 0;\n\tDWORD num_processors = 0;\n\tDWORD error = 0;\n\tDWORD i;\n\n\twhile (!GetLogicalProcessorInformation(processor_info, &len)) {\n\t\terror = GetLastError();\n\t\tif (error == ERROR_INSUFFICIENT_BUFFER)\n\t\t\tprocessor_info = malloc(len);\n\t\telse {\n\t\t\tlog_err(\"Error: GetLogicalProcessorInformation failed: %d\\n\", error);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (processor_info == NULL) {\n\t\t\tlog_err(\"Error: failed to allocate memory for GetLogicalProcessorInformation\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < len / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++) {\n\t\tif (processor_info[i].Relationship == RelationProcessorCore)\n\t\t\tnum_processors += hweight64(processor_info[i].ProcessorMask);\n\t}\n\n\tfree(processor_info);\n\treturn num_processors;\n}\n\nlong sysconf(int name)\n{\n\tlong val = -1;\n\tlong val2 = -1;\n\tSYSTEM_INFO sysInfo;\n\tMEMORYSTATUSEX status;\n\n\tswitch (name) {\n\tcase _SC_NPROCESSORS_ONLN:\n\t\tval = GetNumLogicalProcessors();\n\t\tif (val == -1)\n\t\t\tlog_err(\"sysconf(_SC_NPROCESSORS_ONLN) failed\\n\");\n\n\t\tbreak;\n\n\tcase _SC_PAGESIZE:\n\t\tGetSystemInfo(&sysInfo);\n\t\tval = sysInfo.dwPageSize;\n\t\tbreak;\n\n\tcase _SC_PHYS_PAGES:\n\t\tstatus.dwLength = sizeof(status);\n\t\tval2 = sysconf(_SC_PAGESIZE);\n\t\tif (GlobalMemoryStatusEx(&status) && val2 != -1)\n\t\t\tval = status.ullTotalPhys / val2;\n\t\telse\n\t\t\tlog_err(\"sysconf(_SC_PHYS_PAGES) failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"sysconf(%d) is not implemented\\n\", name);\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nchar *dl_error = NULL;\n\nint dlclose(void *handle)\n{\n\treturn !FreeLibrary((HMODULE)handle);\n}\n\nvoid *dlopen(const char *file, int mode)\n{\n\tHMODULE hMod;\n\n\thMod = LoadLibrary(file);\n\tif (hMod == INVALID_HANDLE_VALUE)\n\t\tdl_error = (char*)\"LoadLibrary failed\";\n\telse\n\t\tdl_error = NULL;\n\n\treturn hMod;\n}\n\nvoid *dlsym(void *handle, const char *name)\n{\n\tFARPROC fnPtr;\n\n\tfnPtr = GetProcAddress((HMODULE)handle, name);\n\tif (fnPtr == NULL)\n\t\tdl_error = (char*)\"GetProcAddress failed\";\n\telse\n\t\tdl_error = NULL;\n\n\treturn fnPtr;\n}\n\nchar *dlerror(void)\n{\n\treturn dl_error;\n}\n\n/* Copied from http://blogs.msdn.com/b/joshpoley/archive/2007/12/19/date-time-formats-and-conversions.aspx */\nvoid Time_tToSystemTime(time_t dosTime, SYSTEMTIME *systemTime)\n{\n\tFILETIME utcFT;\n\tLONGLONG jan1970;\n\tSYSTEMTIME tempSystemTime;\n\n\tjan1970 = Int32x32To64(dosTime, 10000000) + 116444736000000000;\n\tutcFT.dwLowDateTime = (DWORD)jan1970;\n\tutcFT.dwHighDateTime = jan1970 >> 32;\n\n\tFileTimeToSystemTime((FILETIME*)&utcFT, &tempSystemTime);\n\tSystemTimeToTzSpecificLocalTime(NULL, &tempSystemTime, systemTime);\n}\n\nchar *ctime_r(const time_t *t, char *buf)\n{\n\tSYSTEMTIME systime;\n\tconst char * const dayOfWeek[] = { \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };\n\tconst char * const monthOfYear[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\n\tTime_tToSystemTime(*t, &systime);\n\n\t/*\n\t * We don't know how long `buf` is, but assume it's rounded up from\n\t * the minimum of 25 to 32\n\t */\n\tsnprintf(buf, 32, \"%s %s %d %02d:%02d:%02d %04d\\n\",\n\t\t dayOfWeek[systime.wDayOfWeek % 7],\n\t\t monthOfYear[(systime.wMonth - 1) % 12],\n\t\t systime.wDay, systime.wHour, systime.wMinute,\n\t\t systime.wSecond, systime.wYear);\n\treturn buf;\n}\n\nint gettimeofday(struct timeval *restrict tp, void *restrict tzp)\n{\n\tFILETIME fileTime;\n\tuint64_t unix_time, windows_time;\n\tconst uint64_t MILLISECONDS_BETWEEN_1601_AND_1970 = 11644473600000;\n\n\t/* Ignore the timezone parameter */\n\t(void)tzp;\n\n\t/*\n\t * Windows time is stored as the number 100 ns intervals since January 1 1601.\n\t * Conversion details from http://www.informit.com/articles/article.aspx?p=102236&seqNum=3\n\t * Its precision is 100 ns but accuracy is only one clock tick, or normally around 15 ms.\n\t */\n\tGetSystemTimeAsFileTime(&fileTime);\n\twindows_time = ((uint64_t)fileTime.dwHighDateTime << 32) + fileTime.dwLowDateTime;\n\t/* Divide by 10,000 to convert to ms and subtract the time between 1601 and 1970 */\n\tunix_time = (((windows_time)/10000) - MILLISECONDS_BETWEEN_1601_AND_1970);\n\t/* unix_time is now the number of milliseconds since 1970 (the Unix epoch) */\n\ttp->tv_sec = unix_time / 1000;\n\ttp->tv_usec = (unix_time % 1000) * 1000;\n\treturn 0;\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact)\n{\n\tint rc = 0;\n\tvoid (*prev_handler)(int);\n\n\tprev_handler = signal(sig, act->sa_handler);\n\tif (oact != NULL)\n\t\toact->sa_handler = prev_handler;\n\n\tif (prev_handler == SIG_ERR)\n\t\trc = -1;\n\n\treturn rc;\n}\n\nint lstat(const char *path, struct stat *buf)\n{\n\treturn stat(path, buf);\n}\n\nvoid *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off)\n{\n\tDWORD vaProt = 0;\n\tDWORD mapAccess = 0;\n\tDWORD lenlow;\n\tDWORD lenhigh;\n\tHANDLE hMap;\n\tvoid* allocAddr = NULL;\n\n\tif (prot & PROT_NONE)\n\t\tvaProt |= PAGE_NOACCESS;\n\n\tif ((prot & PROT_READ) && !(prot & PROT_WRITE)) {\n\t\tvaProt |= PAGE_READONLY;\n\t\tmapAccess = FILE_MAP_READ;\n\t}\n\n\tif (prot & PROT_WRITE) {\n\t\tvaProt |= PAGE_READWRITE;\n\t\tmapAccess |= FILE_MAP_WRITE;\n\t}\n\n\tlenlow = len & 0xFFFF;\n\tlenhigh = len >> 16;\n\t/* If the low DWORD is zero and the high DWORD is non-zero, `CreateFileMapping`\n\t   will return ERROR_INVALID_PARAMETER. To avoid this, set both to zero. */\n\tif (lenlow == 0)\n\t\tlenhigh = 0;\n\n\tif (flags & MAP_ANON || flags & MAP_ANONYMOUS) {\n\t\tallocAddr = VirtualAlloc(addr, len, MEM_COMMIT, vaProt);\n\t\tif (allocAddr == NULL)\n\t\t\terrno = win_to_posix_error(GetLastError());\n\t} else {\n\t\thMap = CreateFileMapping((HANDLE)_get_osfhandle(fildes), NULL,\n\t\t\t\t\t\tvaProt, lenhigh, lenlow, NULL);\n\n\t\tif (hMap != NULL)\n\t\t\tallocAddr = MapViewOfFile(hMap, mapAccess, off >> 16,\n\t\t\t\t\t\t\toff & 0xFFFF, len);\n\t\tif (hMap == NULL || allocAddr == NULL)\n\t\t\terrno = win_to_posix_error(GetLastError());\n\n\t}\n\n\treturn allocAddr;\n}\n\nint munmap(void *addr, size_t len)\n{\n\tBOOL success;\n\n\t/* We may have allocated the memory with either MapViewOfFile or\n\t\t VirtualAlloc. Therefore, try calling UnmapViewOfFile first, and if that\n\t\t fails, call VirtualFree. */\n\tsuccess = UnmapViewOfFile(addr);\n\n\tif (!success)\n\t\tsuccess = VirtualFree(addr, 0, MEM_RELEASE);\n\n\treturn !success;\n}\n\nint msync(void *addr, size_t len, int flags)\n{\n\treturn !FlushViewOfFile(addr, len);\n}\n\nint fork(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\npid_t setsid(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nstatic HANDLE log_file = INVALID_HANDLE_VALUE;\n\nvoid openlog(const char *ident, int logopt, int facility)\n{\n\tif (log_file != INVALID_HANDLE_VALUE)\n\t\treturn;\n\n\tlog_file = CreateFileA(\"syslog.txt\", GENERIC_WRITE,\n\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n\t\t\t\tOPEN_ALWAYS, 0, NULL);\n}\n\nvoid closelog(void)\n{\n\tCloseHandle(log_file);\n\tlog_file = INVALID_HANDLE_VALUE;\n}\n\nvoid syslog(int priority, const char *message, ... /* argument */)\n{\n\tva_list v;\n\tint len;\n\tchar *output;\n\tDWORD bytes_written;\n\n\tif (log_file == INVALID_HANDLE_VALUE) {\n\t\tlog_file = CreateFileA(\"syslog.txt\", GENERIC_WRITE,\n\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\t\t\t\tNULL, OPEN_ALWAYS, 0, NULL);\n\t}\n\n\tif (log_file == INVALID_HANDLE_VALUE) {\n\t\tlog_err(\"syslog: failed to open log file\\n\");\n\t\treturn;\n\t}\n\n\tva_start(v, message);\n\tlen = _vscprintf(message, v);\n\toutput = malloc(len + sizeof(char));\n\tvsprintf(output, message, v);\n\tWriteFile(log_file, output, len, &bytes_written, NULL);\n\tva_end(v);\n\tfree(output);\n}\n\nint kill(pid_t pid, int sig)\n{\n\terrno = ESRCH;\n\treturn -1;\n}\n\n/*\n * This is assumed to be used only by the network code,\n * and so doesn't try and handle any of the other cases\n */\nint fcntl(int fildes, int cmd, ...)\n{\n\t/*\n\t * non-blocking mode doesn't work the same as in BSD sockets,\n\t * so ignore it.\n\t */\n#if 0\n\tva_list ap;\n\tint val, opt, status;\n\n\tif (cmd == F_GETFL)\n\t\treturn 0;\n\telse if (cmd != F_SETFL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tva_start(ap, 1);\n\n\topt = va_arg(ap, int);\n\tif (opt & O_NONBLOCK)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\tstatus = ioctlsocket((SOCKET)fildes, opt, &val);\n\n\tif (status == SOCKET_ERROR) {\n\t\terrno = EINVAL;\n\t\tval = -1;\n\t}\n\n\tva_end(ap);\n\n\treturn val;\n#endif\nreturn 0;\n}\n\n/*\n * Get the value of a local clock source.\n * This implementation supports 2 clocks: CLOCK_MONOTONIC provides high-accuracy\n * relative time, while CLOCK_REALTIME provides a low-accuracy wall time.\n */\nint clock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n\tint rc = 0;\n\n\tif (clock_id == CLOCK_MONOTONIC) {\n\t\tstatic LARGE_INTEGER freq = {{0,0}};\n\t\tLARGE_INTEGER counts;\n\t\tuint64_t t;\n\n\t\tQueryPerformanceCounter(&counts);\n\t\tif (freq.QuadPart == 0)\n\t\t\tQueryPerformanceFrequency(&freq);\n\n\t\ttp->tv_sec = counts.QuadPart / freq.QuadPart;\n\t\t/* Get the difference between the number of ns stored\n\t\t * in 'tv_sec' and that stored in 'counts' */\n\t\tt = tp->tv_sec * freq.QuadPart;\n\t\tt = counts.QuadPart - t;\n\t\t/* 't' now contains the number of cycles since the last second.\n\t\t * We want the number of nanoseconds, so multiply out by 1,000,000,000\n\t\t * and then divide by the frequency. */\n\t\tt *= 1000000000;\n\t\ttp->tv_nsec = t / freq.QuadPart;\n\t} else if (clock_id == CLOCK_REALTIME) {\n\t\t/* clock_gettime(CLOCK_REALTIME,...) is just an alias for gettimeofday with a\n\t\t * higher-precision field. */\n\t\tstruct timeval tv;\n\t\tgettimeofday(&tv, NULL);\n\t\ttp->tv_sec = tv.tv_sec;\n\t\ttp->tv_nsec = tv.tv_usec * 1000;\n\t} else {\n\t\terrno = EINVAL;\n\t\trc = -1;\n\t}\n\n\treturn rc;\n}\n\nint mlock(const void * addr, size_t len)\n{\n\tSIZE_T min, max;\n\tBOOL success;\n\tHANDLE process = GetCurrentProcess();\n\n\tsuccess = GetProcessWorkingSetSize(process, &min, &max);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\tmin += len;\n\tmax += len;\n\tsuccess = SetProcessWorkingSetSize(process, min, max);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\tsuccess = VirtualLock((LPVOID)addr, len);\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint munlock(const void * addr, size_t len)\n{\n\tBOOL success = VirtualUnlock((LPVOID)addr, len);\n\n\tif (!success) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\npid_t waitpid(pid_t pid, int *stat_loc, int options)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint usleep(useconds_t useconds)\n{\n\tSleep(useconds / 1000);\n\treturn 0;\n}\n\nchar *basename(char *path)\n{\n\tstatic char name[MAX_PATH];\n\tint i;\n\n\tif (path == NULL || strlen(path) == 0)\n\t\treturn (char*)\".\";\n\n\ti = strlen(path) - 1;\n\n\twhile (path[i] != '\\\\' && path[i] != '/' && i >= 0)\n\t\ti--;\n\n\tname[MAX_PATH - 1] = '\\0';\n\tstrncpy(name, path + i + 1, MAX_PATH - 1);\n\n\treturn name;\n}\n\nint fsync(int fildes)\n{\n\tHANDLE hFile = (HANDLE)_get_osfhandle(fildes);\n\tif (!FlushFileBuffers(hFile)) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint nFileMappings = 0;\nHANDLE fileMappings[1024];\n\nint shmget(key_t key, size_t size, int shmflg)\n{\n\tint mapid = -1;\n\tuint32_t size_low = size & 0xFFFFFFFF;\n\tuint32_t size_high = ((uint64_t)size) >> 32;\n\tHANDLE hMapping;\n\n\thMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n\t\t\t\t\tPAGE_EXECUTE_READWRITE | SEC_RESERVE,\n\t\t\t\t\tsize_high, size_low, NULL);\n\tif (hMapping != NULL) {\n\t\tfileMappings[nFileMappings] = hMapping;\n\t\tmapid = nFileMappings;\n\t\tnFileMappings++;\n\t} else\n\t\terrno = ENOSYS;\n\n\treturn mapid;\n}\n\nvoid *shmat(int shmid, const void *shmaddr, int shmflg)\n{\n\tvoid *mapAddr;\n\tMEMORY_BASIC_INFORMATION memInfo;\n\n\tmapAddr = MapViewOfFile(fileMappings[shmid], FILE_MAP_ALL_ACCESS, 0, 0, 0);\n\tif (mapAddr == NULL) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\tif (VirtualQuery(mapAddr, &memInfo, sizeof(memInfo)) == 0) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\tmapAddr = VirtualAlloc(mapAddr, memInfo.RegionSize, MEM_COMMIT, PAGE_READWRITE);\n\tif (mapAddr == NULL) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn (void*)-1;\n\t}\n\n\treturn mapAddr;\n}\n\nint shmdt(const void *shmaddr)\n{\n\tif (!UnmapViewOfFile(shmaddr)) {\n\t\terrno = win_to_posix_error(GetLastError());\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint shmctl(int shmid, int cmd, struct shmid_ds *buf)\n{\n\tif (cmd == IPC_RMID) {\n\t\tfileMappings[shmid] = INVALID_HANDLE_VALUE;\n\t\treturn 0;\n\t}\n\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint setuid(uid_t uid)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint setgid(gid_t gid)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nint nice(int incr)\n{\n\tDWORD prioclass = NORMAL_PRIORITY_CLASS;\n\t\n\tif (incr < -15)\n\t\tprioclass = HIGH_PRIORITY_CLASS;\n\telse if (incr < 0)\n\t\tprioclass = ABOVE_NORMAL_PRIORITY_CLASS;\n\telse if (incr > 15)\n\t\tprioclass = IDLE_PRIORITY_CLASS;\n\telse if (incr > 0)\n\t\tprioclass = BELOW_NORMAL_PRIORITY_CLASS;\n\t\n\tif (!SetPriorityClass(GetCurrentProcess(), prioclass))\n\t\tlog_err(\"fio: SetPriorityClass failed\\n\");\n\n\treturn 0;\n}\n\nint getrusage(int who, struct rusage *r_usage)\n{\n\tconst uint64_t SECONDS_BETWEEN_1601_AND_1970 = 11644473600;\n\tFILETIME cTime, eTime, kTime, uTime;\n\ttime_t time;\n\tHANDLE h;\n\n\tmemset(r_usage, 0, sizeof(*r_usage));\n\n\tif (who == RUSAGE_SELF) {\n\t\th = GetCurrentProcess();\n\t\tGetProcessTimes(h, &cTime, &eTime, &kTime, &uTime);\n\t} else if (who == RUSAGE_THREAD) {\n\t\th = GetCurrentThread();\n\t\tGetThreadTimes(h, &cTime, &eTime, &kTime, &uTime);\n\t} else {\n\t\tlog_err(\"fio: getrusage %d is not implemented\\n\", who);\n\t\treturn -1;\n\t}\n\n\ttime = ((uint64_t)uTime.dwHighDateTime << 32) + uTime.dwLowDateTime;\n\t/* Divide by 10,000,000 to get the number of seconds and move the epoch from\n\t * 1601 to 1970 */\n\ttime = (time_t)(((time)/10000000) - SECONDS_BETWEEN_1601_AND_1970);\n\tr_usage->ru_utime.tv_sec = time;\n\t/* getrusage() doesn't care about anything other than seconds, so set tv_usec to 0 */\n\tr_usage->ru_utime.tv_usec = 0;\n\ttime = ((uint64_t)kTime.dwHighDateTime << 32) + kTime.dwLowDateTime;\n\t/* Divide by 10,000,000 to get the number of seconds and move the epoch from\n\t * 1601 to 1970 */\n\ttime = (time_t)(((time)/10000000) - SECONDS_BETWEEN_1601_AND_1970);\n\tr_usage->ru_stime.tv_sec = time;\n\tr_usage->ru_stime.tv_usec = 0;\n\treturn 0;\n}\n\nint posix_madvise(void *addr, size_t len, int advice)\n{\n\treturn ENOSYS;\n}\n\nint fdatasync(int fildes)\n{\n\treturn fsync(fildes);\n}\n\nssize_t pwrite(int fildes, const void *buf, size_t nbyte,\n\t\toff_t offset)\n{\n\tint64_t pos = _telli64(fildes);\n\tssize_t len = _write(fildes, buf, nbyte);\n\n\t_lseeki64(fildes, pos, SEEK_SET);\n\treturn len;\n}\n\nssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset)\n{\n\tint64_t pos = _telli64(fildes);\n\tssize_t len = read(fildes, buf, nbyte);\n\n\t_lseeki64(fildes, pos, SEEK_SET);\n\treturn len;\n}\n\nssize_t readv(int fildes, const struct iovec *iov, int iovcnt)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nssize_t writev(int fildes, const struct iovec *iov, int iovcnt)\n{\n\tint i;\n\tDWORD bytes_written = 0;\n\n\tfor (i = 0; i < iovcnt; i++) {\n\t\tint len;\n\n\t\tlen = send((SOCKET)fildes, iov[i].iov_base, iov[i].iov_len, 0);\n\t\tif (len == SOCKET_ERROR) {\n\t\t\tDWORD err = GetLastError();\n\t\t\terrno = win_to_posix_error(err);\n\t\t\tbytes_written = -1;\n\t\t\tbreak;\n\t\t}\n\t\tbytes_written += len;\n\t}\n\n\treturn bytes_written;\n}\n\nlong long strtoll(const char *restrict str, char **restrict endptr, int base)\n{\n\treturn _strtoi64(str, endptr, base);\n}\n\nint poll(struct pollfd fds[], nfds_t nfds, int timeout)\n{\n\tstruct timeval tv;\n\tstruct timeval *to = NULL;\n\tfd_set readfds, writefds, exceptfds;\n\tint i;\n\tint rc;\n\n\tif (timeout != -1) {\n\t\tto = &tv;\n\t\tto->tv_sec = timeout / 1000;\n\t\tto->tv_usec = (timeout % 1000) * 1000;\n\t}\n\n\tFD_ZERO(&readfds);\n\tFD_ZERO(&writefds);\n\tFD_ZERO(&exceptfds);\n\n\tfor (i = 0; i < nfds; i++) {\n\t\tif (fds[i].fd < 0) {\n\t\t\tfds[i].revents = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fds[i].events & POLLIN)\n\t\t\tFD_SET(fds[i].fd, &readfds);\n\n\t\tif (fds[i].events & POLLOUT)\n\t\t\tFD_SET(fds[i].fd, &writefds);\n\n\t\tFD_SET(fds[i].fd, &exceptfds);\n\t}\n\trc = select(nfds, &readfds, &writefds, &exceptfds, to);\n\n\tif (rc != SOCKET_ERROR) {\n\t\tfor (i = 0; i < nfds; i++) {\n\t\t\tif (fds[i].fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((fds[i].events & POLLIN) && FD_ISSET(fds[i].fd, &readfds))\n\t\t\t\tfds[i].revents |= POLLIN;\n\n\t\t\tif ((fds[i].events & POLLOUT) && FD_ISSET(fds[i].fd, &writefds))\n\t\t\t\tfds[i].revents |= POLLOUT;\n\n\t\t\tif (FD_ISSET(fds[i].fd, &exceptfds))\n\t\t\t\tfds[i].revents |= POLLHUP;\n\t\t}\n\t}\n\treturn rc;\n}\n\nint nanosleep(const struct timespec *rqtp, struct timespec *rmtp)\n{\n\tstruct timespec tv;\n\tDWORD ms_remaining;\n\tDWORD ms_total = (rqtp->tv_sec * 1000) + (rqtp->tv_nsec / 1000000.0);\n\n\tif (ms_total == 0)\n\t\tms_total = 1;\n\n\tms_remaining = ms_total;\n\n\t/* Since Sleep() can sleep for less than the requested time, add a loop to\n\t   ensure we only return after the requested length of time has elapsed */\n\tdo {\n\t\tfio_gettime(&tv, NULL);\n\t\tSleep(ms_remaining);\n\t\tms_remaining = ms_total - mtime_since_now(&tv);\n\t} while (ms_remaining > 0 && ms_remaining < ms_total);\n\n\t/* this implementation will never sleep for less than the requested time */\n\tif (rmtp != NULL) {\n\t\trmtp->tv_sec = 0;\n\t\trmtp->tv_nsec = 0;\n\t}\n\n\treturn 0;\n}\n\nDIR *opendir(const char *dirname)\n{\n\tstruct dirent_ctx *dc = NULL;\n\tHANDLE file;\n\n\t/* See if we can open it. If not, we'll return an error here */\n\tfile = CreateFileA(dirname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n\t\t\t\tOPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\tif (file != INVALID_HANDLE_VALUE) {\n\t\tCloseHandle(file);\n\t\tdc = malloc(sizeof(struct dirent_ctx));\n\t\tsnprintf(dc->dirname, sizeof(dc->dirname), \"%s\", dirname);\n\t\tdc->find_handle = INVALID_HANDLE_VALUE;\n\t} else {\n\t\tDWORD error = GetLastError();\n\t\tif (error == ERROR_FILE_NOT_FOUND)\n\t\t\terrno = ENOENT;\n\n\t\telse if (error == ERROR_PATH_NOT_FOUND)\n\t\t\terrno = ENOTDIR;\n\t\telse if (error == ERROR_TOO_MANY_OPEN_FILES)\n\t\t\terrno = ENFILE;\n\t\telse if (error == ERROR_ACCESS_DENIED)\n\t\t\terrno = EACCES;\n\t\telse\n\t\t\terrno = error;\n\t}\n\n\treturn dc;\n}\n\nint closedir(DIR *dirp)\n{\n\tif (dirp != NULL && dirp->find_handle != INVALID_HANDLE_VALUE)\n\t\tFindClose(dirp->find_handle);\n\n\tfree(dirp);\n\treturn 0;\n}\n\nstruct dirent *readdir(DIR *dirp)\n{\n\tstatic struct dirent de;\n\tWIN32_FIND_DATA find_data;\n\n\tif (dirp == NULL)\n\t\treturn NULL;\n\n\tif (dirp->find_handle == INVALID_HANDLE_VALUE) {\n\t\tchar search_pattern[MAX_PATH];\n\n\t\tsnprintf(search_pattern, sizeof(search_pattern), \"%s\\\\*\",\n\t\t\t dirp->dirname);\n\t\tdirp->find_handle = FindFirstFileA(search_pattern, &find_data);\n\t\tif (dirp->find_handle == INVALID_HANDLE_VALUE)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (!FindNextFile(dirp->find_handle, &find_data))\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(de.d_name, sizeof(de.d_name), find_data.cFileName);\n\tde.d_ino = 0;\n\n\treturn &de;\n}\n\nuid_t geteuid(void)\n{\n\tlog_err(\"%s is not implemented\\n\", __func__);\n\terrno = ENOSYS;\n\treturn -1;\n}\n\nin_addr_t inet_network(const char *cp)\n{\n\tin_addr_t hbo;\n\tin_addr_t nbo = inet_addr(cp);\n\thbo = ((nbo & 0xFF) << 24) + ((nbo & 0xFF00) << 8) + ((nbo & 0xFF0000) >> 8) + ((nbo & 0xFF000000) >> 24);\n\treturn hbo;\n}\n\n#ifdef CONFIG_WINDOWS_XP\nconst char *inet_ntop(int af, const void *restrict src, char *restrict dst,\n\t\t      socklen_t size)\n{\n\tINT status = SOCKET_ERROR;\n\tWSADATA wsd;\n\tchar *ret = NULL;\n\n\tif (af != AF_INET && af != AF_INET6) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\n\tWSAStartup(MAKEWORD(2,2), &wsd);\n\n\tif (af == AF_INET) {\n\t\tstruct sockaddr_in si;\n\t\tDWORD len = size;\n\n\t\tmemset(&si, 0, sizeof(si));\n\t\tsi.sin_family = af;\n\t\tmemcpy(&si.sin_addr, src, sizeof(si.sin_addr));\n\t\tstatus = WSAAddressToString((struct sockaddr*)&si, sizeof(si), NULL, dst, &len);\n\t} else if (af == AF_INET6) {\n\t\tstruct sockaddr_in6 si6;\n\t\tDWORD len = size;\n\n\t\tmemset(&si6, 0, sizeof(si6));\n\t\tsi6.sin6_family = af;\n\t\tmemcpy(&si6.sin6_addr, src, sizeof(si6.sin6_addr));\n\t\tstatus = WSAAddressToString((struct sockaddr*)&si6, sizeof(si6), NULL, dst, &len);\n\t}\n\n\tif (status != SOCKET_ERROR)\n\t\tret = dst;\n\telse\n\t\terrno = ENOSPC;\n\n\tWSACleanup();\n\n\treturn ret;\n}\n\nint inet_pton(int af, const char *restrict src, void *restrict dst)\n{\n\tINT status = SOCKET_ERROR;\n\tWSADATA wsd;\n\tint ret = 1;\n\n\tif (af != AF_INET && af != AF_INET6) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tWSAStartup(MAKEWORD(2,2), &wsd);\n\n\tif (af == AF_INET) {\n\t\tstruct sockaddr_in si;\n\t\tINT len = sizeof(si);\n\n\t\tmemset(&si, 0, sizeof(si));\n\t\tsi.sin_family = af;\n\t\tstatus = WSAStringToAddressA((char*)src, af, NULL, (struct sockaddr*)&si, &len);\n\t\tif (status != SOCKET_ERROR)\n\t\t\tmemcpy(dst, &si.sin_addr, sizeof(si.sin_addr));\n\t} else if (af == AF_INET6) {\n\t\tstruct sockaddr_in6 si6;\n\t\tINT len = sizeof(si6);\n\n\t\tmemset(&si6, 0, sizeof(si6));\n\t\tsi6.sin6_family = af;\n\t\tstatus = WSAStringToAddressA((char*)src, af, NULL, (struct sockaddr*)&si6, &len);\n\t\tif (status != SOCKET_ERROR)\n\t\t\tmemcpy(dst, &si6.sin6_addr, sizeof(si6.sin6_addr));\n\t}\n\n\tif (status == SOCKET_ERROR) {\n\t\terrno = ENOSPC;\n\t\tret = 0;\n\t}\n\n\tWSACleanup();\n\n\treturn ret;\n}\n#endif /* CONFIG_WINDOWS_XP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/os/windows/posix/include/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\n\n#define RTLD_LAZY 1\n\nvoid *dlopen(const char *file, int mode);\nint dlclose(void *handle);\nvoid *dlsym(void *restrict handle, const char *restrict name);\nchar *dlerror(void);\n\n#endif /* DLFCN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/engines/skeleton_external.c": "/*\n * Skeleton for a sample external io engine\n *\n * Should be compiled with:\n *\n * gcc -Wall -O2 -g -D_GNU_SOURCE -include ../config-host.h -shared -rdynamic -fPIC -o skeleton_external.o skeleton_external.c\n * (also requires -D_GNU_SOURCE -DCONFIG_STRSEP on Linux)\n *\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n\n#include \"../fio.h\"\n#include \"../optgroup.h\"\n\n/*\n * The core of the module is identical to the ones included with fio,\n * read those. You cannot use register_ioengine() and unregister_ioengine()\n * for external modules, they should be gotten through dlsym()\n */\n\n/*\n * The io engine can define its own options within the io engine source.\n * The option member must not be at offset 0, due to the way fio parses\n * the given option. Just add a padding pointer unless the io engine has\n * something usable.\n */\nstruct fio_skeleton_options {\n\tvoid *pad; /* avoid ->off1 of fio_option becomes 0 */\n\tunsigned int dummy;\n};\n\nstatic struct fio_option options[] = {\n\t{\n\t\t.name\t= \"dummy\",\n\t\t.lname\t= \"ldummy\",\n\t\t.type\t= FIO_OPT_STR_SET,\n\t\t.off1\t= offsetof(struct fio_skeleton_options, dummy),\n\t\t.help\t= \"Set dummy\",\n\t\t.category = FIO_OPT_C_ENGINE, /* always use this */\n\t\t.group\t= FIO_OPT_G_INVALID, /* this can be different */\n\t},\n\t{\n\t\t.name\t= NULL,\n\t},\n};\n\n/*\n * The ->event() hook is called to match an event number with an io_u.\n * After the core has called ->getevents() and it has returned eg 3,\n * the ->event() hook must return the 3 events that have completed for\n * subsequent calls to ->event() with [0-2]. Required.\n */\nstatic struct io_u *fio_skeleton_event(struct thread_data *td, int event)\n{\n\treturn NULL;\n}\n\n/*\n * The ->getevents() hook is used to reap completion events from an async\n * io engine. It returns the number of completed events since the last call,\n * which may then be retrieved by calling the ->event() hook with the event\n * numbers. Required.\n */\nstatic int fio_skeleton_getevents(struct thread_data *td, unsigned int min,\n\t\t\t\t  unsigned int max, const struct timespec *t)\n{\n\treturn 0;\n}\n\n/*\n * The ->cancel() hook attempts to cancel the io_u. Only relevant for\n * async io engines, and need not be supported.\n */\nstatic int fio_skeleton_cancel(struct thread_data *td, struct io_u *io_u)\n{\n\treturn 0;\n}\n\n/*\n * The ->queue() hook is responsible for initiating io on the io_u\n * being passed in. If the io engine is a synchronous one, io may complete\n * before ->queue() returns. Required.\n *\n * The io engine must transfer in the direction noted by io_u->ddir\n * to the buffer pointed to by io_u->xfer_buf for as many bytes as\n * io_u->xfer_buflen. Residual data count may be set in io_u->resid\n * for a short read/write.\n */\nstatic enum fio_q_status fio_skeleton_queue(struct thread_data *td,\n\t\t\t\t\t    struct io_u *io_u)\n{\n\t/*\n\t * Double sanity check to catch errant write on a readonly setup\n\t */\n\tfio_ro_check(td, io_u);\n\n\t/*\n\t * Could return FIO_Q_QUEUED for a queued request,\n\t * FIO_Q_COMPLETED for a completed request, and FIO_Q_BUSY\n\t * if we could queue no more at this point (you'd have to\n\t * define ->commit() to handle that.\n\t */\n\treturn FIO_Q_COMPLETED;\n}\n\n/*\n * The ->prep() function is called for each io_u prior to being submitted\n * with ->queue(). This hook allows the io engine to perform any\n * preparatory actions on the io_u, before being submitted. Not required.\n */\nstatic int fio_skeleton_prep(struct thread_data *td, struct io_u *io_u)\n{\n\treturn 0;\n}\n\n/*\n * The init function is called once per thread/process, and should set up\n * any structures that this io engine requires to keep track of io. Not\n * required.\n */\nstatic int fio_skeleton_init(struct thread_data *td)\n{\n\treturn 0;\n}\n\n/*\n * This is paired with the ->init() function and is called when a thread is\n * done doing io. Should tear down anything setup by the ->init() function.\n * Not required.\n */\nstatic void fio_skeleton_cleanup(struct thread_data *td)\n{\n}\n\n/*\n * Hook for opening the given file. Unless the engine has special\n * needs, it usually just provides generic_open_file() as the handler.\n */\nstatic int fio_skeleton_open(struct thread_data *td, struct fio_file *f)\n{\n\treturn generic_open_file(td, f);\n}\n\n/*\n * Hook for closing a file. See fio_skeleton_open().\n */\nstatic int fio_skeleton_close(struct thread_data *td, struct fio_file *f)\n{\n\treturn generic_close_file(td, f);\n}\n\n/*\n * Note that the structure is exported, so that fio can get it via\n * dlsym(..., \"ioengine\"); for (and only for) external engines.\n */\nstruct ioengine_ops ioengine = {\n\t.name\t\t= \"engine_name\",\n\t.version\t= FIO_IOOPS_VERSION,\n\t.init\t\t= fio_skeleton_init,\n\t.prep\t\t= fio_skeleton_prep,\n\t.queue\t\t= fio_skeleton_queue,\n\t.cancel\t\t= fio_skeleton_cancel,\n\t.getevents\t= fio_skeleton_getevents,\n\t.event\t\t= fio_skeleton_event,\n\t.cleanup\t= fio_skeleton_cleanup,\n\t.open_file\t= fio_skeleton_open,\n\t.close_file\t= fio_skeleton_close,\n\t.options\t= options,\n\t.option_struct_size\t= sizeof(struct fio_skeleton_options),\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/tools/plot/samples/fio-logs.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-fio-3.19-r3gw3nkowx3ahlghzdzb7uhfla5w5vhe/spack-src/doc/fio-histo-log-pctiles.pdf"
    ],
    "total_files": 446
}