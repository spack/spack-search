{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/Ft/Lib/DistExt/BuildExt.py": "import os\nimport re\nimport sys\nfrom distutils import util, sysconfig\nfrom distutils.command import build_ext\nfrom distutils.dep_util import newer_group, newer\nfrom distutils.version import StrictVersion\n\nfrom Ft.Lib import ImportUtil\nfrom Ft.Lib.DistExt import Util\n\n# Constants for symbol stripping\nSTRIP_NONE = 0\nSTRIP_VERSIONING = 1\nSTRIP_EXPORTS_FILE = 2\nSTRIP_EXPORTS_ARGLIST = 3\nSTRIP_EXPORTS_POST_LINK = 4\n\nBISONGEN_MINIMUM_VERSION = StrictVersion('0.8.0')\n\ntry:\n    enumerate\nexcept NameError:\n    enumerate = lambda sequence: zip(range(len(sequence)), sequence)\n\nclass BuildExt(build_ext.build_ext):\n\n    command_name = 'build_ext'\n\n    def initialize_options(self):\n        build_ext.build_ext.initialize_options(self)\n\n        # How to format C symbol name to exported symbol name\n        self.export_symbol_format = '%s'\n\n        self.symbol_stripping = STRIP_NONE\n        self.strip_command = None\n        return\n\n    def finalize_options(self):\n        build_ext.build_ext.finalize_options(self)\n\n        # Verify that extensions are built with the proper flags.\n        # For Windows, Py_DEBUG is enabled whenever debugging information\n        # is included. For other platforms, it must be explicited defined.\n        if sys.platform == 'win32':\n            py_debug = self.debug\n        else:\n            # 'getobjects()' is only available in debug builds.\n            py_debug = hasattr(sys, 'getobjects')\n        if py_debug and not Util.GetConfigVars('Py_DEBUG')[0]:\n            macros = [('Py_DEBUG', None)]\n            if not self.define:\n                self.define = macros\n            else:\n                self.define.extend(macros)\n\n        # If built as shared, remove the library dir if the shared library\n        # is not installed there (which Python does not do by default).\n        # This fixes the errors building on openSUSE 10.2 w/Python 2.5.\n        if (sys.platform.startswith('linux') and\n            sysconfig.get_config_var('Py_ENABLE_SHARED')):\n            libpl, ldlibrary = sysconfig.get_config_vars('LIBPL', 'LDLIBRARY')\n            if libpl in self.library_dirs:\n                if not os.path.exists(os.path.join(libpl, ldlibrary)):\n                    self.library_dirs.remove(libpl)\n\n        # OpenBSD and NetBSD dlsyms have a leading underscore if the object\n        # format is not ELF.  (from src/Python/dynload_shlib.c).\n        if (sys.platform.startswith('openbsd')\n            or sys.platform.startswith('netbsd')):\n            # Capture predefined preprocessor macros (from src/configure)\n            cc = sysconfig.get_config_var('CC')\n            defines = os.popen(cc + ' -dM -E - </dev/null').read()\n            # Check for ELF object format\n            if defines.find('__ELF__') == -1:\n                self.export_symbol_format = '_%s'\n\n        # By limiting exported symbols, we don't need to worry about symbol\n        # conflicts between the shared modules or Python itself.\n        if os.name == 'nt' or sys.platform.startswith('cygwin'):\n            # The compiler default is to limit exported symbols\n            self.symbol_stripping = STRIP_NONE\n\n        elif (sys.platform.startswith('linux')\n              or sys.platform.startswith('freebsd')\n              or sys.platform.startswith('openbsd')\n              or sys.platform.startswith('netbsd')):\n            # This assumes the the GNU linker is being used.\n            # As of Dec 2005, the SourceForge Compile Farm servers use GNU ld\n            # for OpenBSD and NetBSD.\n            self.symbol_stripping = STRIP_VERSIONING\n            self.strip_command = '-Wl,--version-script,%s'\n\n        elif sys.platform.startswith('sunos'):\n            self.symbol_stripping = STRIP_VERSIONING\n            self.strip_command = '-Wl,-M,%s'\n\n        elif sys.platform.startswith('darwin'):\n            # Mac OS X/Darwin\n            ld = sysconfig.get_config_var('LDSHARED')\n            output = os.popen(ld + ' -Wl,-exported_symbols_list').read()\n            if re.search('unknown flag: -exported_symbols_list', output):\n                # Older OSX (10.1 or 10.2 with DevTools prior to Dec 2002)\n                # Use external program (nmedit) to limit exported symbols\n                self.symbol_stripping = STRIP_EXPORTS_POST_LINK\n                self.strip_command = 'nmedit -s %(exports)s -p %(extension)s'\n            else:\n                self.symbol_stripping = STRIP_EXPORTS_FILE\n                self.strip_command = '-Wl,-exported_symbols_list,%s'\n                self.export_symbol_format = '_%s'\n\n        elif sys.platform.startswith('hp-ux'):\n            # HP-UX linker lists exported symbols one at a time in the\n            # argument list.\n            self.symbol_stripping = STRIP_EXPORTS_ARGLIST\n            self.strip_command = '-Wl,+e,%s'\n\n        elif os.name == 'posix':\n            # From online manual pages, most UNIX support limiting exported\n            # symbols with the same option.\n            self.symbol_stripping = STRIP_EXPORTS_FILE\n            self.strip_command = '-Wl,-exports_file,%s'\n        return\n\n    def check_extensions_list(self, extensions):\n        build_ext.build_ext.check_extensions_list(self, extensions)\n\n        # Add the included files for each source file\n        for ext in extensions:\n            if not isinstance(ext.sources, (tuple, list)):\n                raise DistutilsSetupError(\n                    \"in 'ext_modules' option (extension '%s'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\" % ext.name)\n            if not hasattr(ext, 'depends'):\n                ext.depends = []\n            if not hasattr(ext, 'includes'):\n                ext.includes = {}\n                for source in ext.sources:\n                    includes = Util.FindIncludes(util.convert_path(source),\n                                                 ext.include_dirs)\n                    ext.includes[source] = includes\n        return\n\n    def get_source_files(self):\n        self.check_extensions_list(self.extensions)\n\n        filenames = []\n        for extension in self.extensions:\n            for source in self.prepare_sources(extension):\n                filenames.append(source)\n                filenames.extend(extension.includes[source])\n        return filenames\n\n    def build_extension(self, ext):\n        # First, scan the sources for SWIG definition files (.i), run\n        # SWIG on 'em to create .c files, and modify the sources list\n        # accordingly.\n        sources = self.prepare_sources(ext)\n\n        fullname = self.get_ext_fullname(ext.name)\n        ext_filename = os.path.join(self.build_lib,\n                                    self.get_ext_filename(fullname))\n\n        # Changes to the command indicate that compilation options may have\n        # changed so rebuild/link everything\n        command_mtime = ImportUtil.GetLastModified(__name__)\n        try:\n            force = command_mtime > os.stat(ext_filename).st_mtime\n        except OSError:\n            force = True\n        force = self.force or force\n\n        depends = sources + ext.depends\n        for includes in ext.includes.values():\n            depends.extend(includes)\n        if not (force or newer_group(depends, ext_filename, 'newer')):\n            self.announce(\"skipping '%s' extension (up-to-date)\" % ext.name)\n            return\n\n        self.announce(\"building '%s' extension\" % ext.name, 2)\n\n        # Next, compile the source code to object files.\n        extra_args = ext.extra_compile_args or []\n\n        macros = ext.define_macros[:]\n        for undef in ext.undef_macros:\n            macros.append((undef,))\n\n        # Get the resulting object filenames as we are compiling the sources\n        # one at a time to reduce compile time for large source lists.\n        objects = self.compiler.object_filenames(sources,\n                                                 sysconfig.python_build,\n                                                 self.build_temp)\n\n        self.compiler.force = force\n        if sys.version >= '2.3':\n            # Python 2.3 added dependency checking to the compiler, use that\n            for object, source in zip(objects, sources):\n                depends = ext.depends + ext.includes[source]\n                self.compiler.compile([source],\n                                      output_dir=self.build_temp,\n                                      macros=macros,\n                                      include_dirs=ext.include_dirs,\n                                      debug=self.debug,\n                                      extra_postargs=extra_args,\n                                      depends=depends)\n        else:\n            if not force:\n                # Determine those sources that require rebuilding\n                new_sources = []\n                for object, source in zip(objects, sources):\n                    depends = [source]\n                    depends.extend(ext.includes[source])\n                    if (newer_group(depends, object, 'newer')\n                        or command_mtime > os.stat(object).st_mtime):\n                        new_sources.append(source)\n                sources = new_sources\n\n            # Forcably build those sources listed in 'sources'\n            self.compiler.force = True\n            for source in sources:\n                output_dir = os.path.join(self.build_temp,\n                                          os.path.dirname(source))\n                self.compiler.compile([source],\n                                      output_dir=output_dir,\n                                      macros=macros,\n                                      include_dirs=ext.include_dirs,\n                                      debug=self.debug,\n                                      extra_postargs=extra_args)\n\n        # Now link the object files together into a \"shared object\" --\n        # of course, first we have to figure out all the other things\n        # that go into the mix.\n        if ext.extra_objects:\n            objects.extend(ext.extra_objects)\n\n        # Setup \"symbol stripping\"\n        if self.symbol_stripping == STRIP_VERSIONING:\n            # Strip symbols via a versioning script\n            f, mapfile = self._mkstemp(ext, '.map')\n            f.write('{ global: ')\n            for sym in self.get_export_symbols(ext):\n                f.write(sym + '; ')\n            f.write('local: *; };')\n            f.close()\n            link_preargs = [self.strip_command % mapfile]\n\n        elif self.symbol_stripping == STRIP_EXPORTS_FILE:\n            # Strip symbols via an exports file\n            f, expfile = self._mkstemp(ext, '.exp')\n            for sym in self.get_export_symbols(ext):\n                f.write(sym + '\\n')\n            f.close()\n            link_preargs = [self.strip_command % expfile]\n\n        elif self.symbol_stripping == STRIP_EXPORTS_ARGLIST:\n            # Strip symbols via multiple arguments\n            symbols = self.get_export_symbols(ext)\n            link_preargs = [ self.strip_command % sym for sym in symbols ]\n\n        else:\n            # No linker support for limiting exported symbols\n            link_preargs = []\n\n        # Detect target language, if not provided\n        kwords = {}\n        if sys.version >= '2.3':\n            lang = ext.language or self.compiler.detect_language(ext.sources)\n            kwords['target_lang'] = lang\n\n        self.compiler.link_shared_object(\n            objects, ext_filename,\n            libraries=self.get_libraries(ext),\n            library_dirs=ext.library_dirs,\n            runtime_library_dirs=ext.runtime_library_dirs,\n            extra_preargs=link_preargs,\n            extra_postargs=ext.extra_link_args,\n            export_symbols=self.get_export_symbols(ext),\n            debug=self.debug,\n            build_temp=self.build_temp,\n            **kwords)\n\n        if self.symbol_stripping == STRIP_EXPORTS_POST_LINK:\n            # Create the exports file\n            f, expfile = self._mkstemp(ext, '.exp')\n            for sym in self.get_export_symbols(ext):\n                f.write(sym + '\\n')\n            f.close()\n\n            subst = {'exports' : expfile, 'extension' : filename}\n            self.spawn([ x % subst for x in self.strip_command.split(' ') ])\n\n        # Reset the force flag on the compilier\n        self.compiler.force = self.force\n        return\n\n    def prepare_sources(self, extension):\n        \"\"\"Walk the list of source files in 'sources', looking for SWIG\n        interface (.i) files.  Run SWIG on all that are found, and\n        return a modified 'sources' list with SWIG source files replaced\n        by the generated C (or C++) files.\n        \"\"\"\n        sources = []\n        bgen_sources = []\n        bgen_outputs = []\n        for source in extension.sources:\n            if source.endswith('.bgen'):\n                name, includes = self._parse_bgen(source)\n                if name is None:\n                    name = extension.name.split('.')[-1][:-1]\n                extension.includes[source] = includes\n                # replace the BisonGen file with the generated C file\n                bgen_output = os.path.dirname(source)\n                bgen_output = os.path.join(bgen_output, name + '.c')\n                # see if the C file needs to be regenerated\n                if newer_group([source] + includes, bgen_output):\n                    bgen_sources.append(source)\n                bgen_outputs.append(bgen_output)\n                sources.append(bgen_output)\n            else:\n                sources.append(source)\n        if bgen_sources:\n            try:\n                from BisonGen import __version__, Processor, OptionParser\n            except ImportError:\n                # use the pre-generated sources\n                for source in bgen_sources:\n                    self.warn(\"not compiling %s (BisonGen not found)\" % source)\n            else:\n                if StrictVersion(__version__) < BISONGEN_MINIMUM_VERSION:\n                    raise DistutilsExecError(\"requires BisonGen %s, found %s\"\n                                             % (BISONGEN_MINIMUM_VERSION,\n                                                __version__))\n                # Convert verbosity to logging threshold\n                threshold = 3 - self.verbose\n                processor = Processor.Processor(threshold)\n                options = OptionParser.Values()\n                options.language = 'c'\n                for source in bgen_sources:\n                    options.outputDirectory = os.path.dirname(source)\n                    processor.run(source, options)\n\n        # Update the extension's include mapping for the generated file.\n        for output in bgen_outputs:\n            includes = extension.includes.get(output, [])\n            includes = FindIncludes(output, extension.include_dirs, includes)\n            extension.includes[output] = includes\n\n        if sys.version < '2.4':\n            return self.swig_sources(sources)\n        return self.swig_sources(sources, extension)\n\n    def _parse_bgen(self, filename):\n        name = None\n        includes = []\n        basedir = os.path.dirname(filename)\n        for event, node in Util.IterXml(filename):\n            if name is None and event == 'START_ELEMENT':\n                if node.tagName == 'options':\n                    name = node.getAttribute('name')\n            elif event == 'PROCESSING_INSTRUCTION':\n                if node.target == 'include':\n                    match = re.match(r'([\"]?)(.+)(\\1)', node.nodeValue)\n                    if match:\n                        include = util.convert_path(match.group(2))\n                        include = os.path.join(basedir, include)\n                        include = os.path.normpath(include)\n                        includes.append(include)\n                        includes.extend(self._parse_bgen(include)[1])\n        return (name, includes)\n\n    def _mkstemp(self, extension, suffix):\n        path_parts = extension.name.split('.')\n        basename = os.path.join(self.build_temp, *path_parts)\n        # extensions in debug_mode are named 'module_d.pyd' under windows\n        if os.name == 'nt' and self.debug:\n            basename += '_d'\n        filename = basename + suffix\n        self.mkpath(os.path.dirname(filename))\n        return (open(filename, 'w'), filename)\n\n    def get_export_symbols(self, extension):\n        symbols = build_ext.build_ext.get_export_symbols(self, extension)\n        return [ self.export_symbol_format % symbol for symbol in symbols ]\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/XPath/Borrowed/od_20000608.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Xslt/Borrowed/da_20000714.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Xslt/Borrowed/mg_20010530.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Xslt/Borrowed/ep_20020718.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Xslt/Borrowed/ce_20000527.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Xslt/Borrowed/fc_20001125.py",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/goodXml_16LE_LEBOM_noDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/goodXml_16LE_LEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/badXml_16LE_BEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/goodXml_16BE_BEBOM_noDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/badXml_16LE_LEBOM_16LEDecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/test/Xml/Core/goodXml_16BE_BEBOM_16Decl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/Ft/Lib/DistExt/stubmain.exe",
        "/tmp/vanessa/spack-stage/spack-stage-py-4suite-xml-1.0.2-eirhsaczokfdhxtp3xnafneqev7oy53x/spack-src/Ft/Data/draft.gif"
    ],
    "total_files": 979
}