{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/source/timemory/utility/signals.hpp": "// MIT License\n//\n// Copyright (c) 2019, The Regents of the University of California,\n// through Lawrence Berkeley National Laboratory (subject to receipt of any\n// required approvals from the U.S. Dept. of Energy).  All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n/** \\file timemory/utility/signals.hpp\n * \\headerfile utility/signals.hpp \"timemory/utility/signals.hpp\"\n * Handles signals emitted by application\n *\n */\n\n//======================================================================================//\n/// This global method should be used on LINUX or MacOSX platforms with gcc,\n/// clang, or intel compilers for activating signal detection and forcing\n/// exception being thrown that can be handled when detected.\n//======================================================================================//\n\n#pragma once\n\n#include \"timemory/backends/dmp.hpp\"\n#include \"timemory/backends/signals.hpp\"\n#include \"timemory/settings.hpp\"\n#include \"timemory/utility/macros.hpp\"\n#include \"timemory/utility/utility.hpp\"\n\n#include <cfenv>\n#include <csignal>\n\n#if defined(SIGNAL_AVAILABLE)\n#    include <dlfcn.h>\n#endif\n\n//======================================================================================//\n\nnamespace tim\n{\n// No    Name         Default Action       Description\n// 1     SIGHUP       terminate process    terminal line hangup\n// 2     SIGINT       terminate process    interrupt program\n// 3     SIGQUIT      create core image    quit program\n// 4     SIGILL       create core image    illegal instruction\n// 5     SIGTRAP      create core image    trace trap\n// 6     SIGABRT      create core image    abort program (formerly SIGIOT)\n// 7     SIGEMT       create core image    emulate instruction executed\n// 8     SIGFPE       create core image    floating-point exception\n// 9     SIGKILL      terminate process    kill program\n// 10    SIGBUS       create core image    bus error\n// 11    SIGSEGV      create core image    segmentation violation\n// 12    SIGSYS       create core image    non-existent system call invoked\n// 13    SIGPIPE      terminate process    write on a pipe with no reader\n// 14    SIGALRM      terminate process    real-time timer expired\n// 15    SIGTERM      terminate process    software termination signal\n// 16    SIGURG       discard signal       urgent condition present on socket\n// 18    SIGTSTP      stop process         stop signal generated from keyboard\n// 24    SIGXCPU      terminate process    cpu time limit exceeded (see\n// setrlimit(2)) 25    SIGXFSZ      terminate process    file size limit\n// exceeded (see setrlimit(2)) 26    SIGVTALRM    terminate process    virtual\n// time alarm (see setitimer(2)) 27    SIGPROF      terminate process profiling\n// timer alarm (see setitimer(2))\n\n//--------------------------------------------------------------------------------------//\n\nenum class sys_signal : int\n{\n    Hangup       = SIGHUP,   // 1\n    Interrupt    = SIGINT,   // 2\n    Quit         = SIGQUIT,  // 3\n    Illegal      = SIGILL,\n    Trap         = SIGTRAP,\n    Abort        = SIGABRT,\n    Emulate      = SIGEMT,\n    FPE          = SIGFPE,\n    Kill         = SIGKILL,\n    Bus          = SIGBUS,\n    SegFault     = SIGSEGV,\n    System       = SIGSYS,\n    Pipe         = SIGPIPE,\n    Alarm        = SIGALRM,\n    Terminate    = SIGTERM,\n    Urgent       = SIGURG,\n    Stop         = SIGTSTP,\n    CPUtime      = SIGXCPU,\n    FileSize     = SIGXFSZ,\n    VirtualAlarm = SIGVTALRM,\n    ProfileAlarm = SIGPROF,\n    User1        = SIGUSR1,\n    User2        = SIGUSR2\n};\n\n//--------------------------------------------------------------------------------------//\n\nclass signal_settings\n{\npublic:\n    using signal_set_t      = std::set<sys_signal>;\n    using signal_function_t = std::function<void(int)>;\n\npublic:\n    static bool        is_active();\n    static void        set_active(bool val);\n    static void        enable(const sys_signal&);\n    static void        disable(const sys_signal&);\n    static std::string str(const sys_signal&);\n    static std::string str();\n    static void        check_environment();\n    static void        set_exit_action(signal_function_t _f);\n    static void        exit_action(int errcode);\n\n    static const signal_set_t& enabled();\n    static const signal_set_t& disabled();\n    static const signal_set_t& get_enabled();\n    static const signal_set_t& get_disabled();\n    static const signal_set_t& get_default();\n\nprotected:\n    struct signals_data_t\n    {\n        signals_data_t();\n        bool              signals_active;\n        signal_set_t      signals_default;\n        signal_set_t      signals_enabled;\n        signal_set_t      signals_disabled;\n        signal_function_t signals_exit_func;\n    };\n\n    static signals_data_t& f_signals()\n    {\n        static signal_settings::signals_data_t instance;\n        return instance;\n    }\n};\n\n//--------------------------------------------------------------------------------------//\n\n// declarations\ninline bool enable_signal_detection(\n    signal_settings::signal_set_t = signal_settings::get_default());\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection();\n\n//--------------------------------------------------------------------------------------//\n\ninline void\nupdate_signal_detection(const signal_settings::signal_set_t& _signals)\n{\n    if(settings::allow_signal_handler())\n    {\n        disable_signal_detection();\n        enable_signal_detection(_signals);\n    }\n}\n\n//--------------------------------------------------------------------------------------//\n#if defined(SIGNAL_AVAILABLE)\nstatic void\ntermination_signal_message(int sig, siginfo_t* sinfo, std::ostream& message);\n#endif\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#if defined(SIGNAL_AVAILABLE)\n\ninline std::string\ntimemory_stack_demangle(const std::string& name)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    size_t found_end = name.find_first_of(\"+)\", 0, 2);\n    if(found_end == std::string::npos)\n    {\n        found_end = name.size();\n    }\n    size_t found_parenthesis = name.find_first_of(\"(\");\n    size_t start             = found_parenthesis + 1;\n    if(found_parenthesis == std::string::npos)\n        start = 0;\n\n    // PRINT_HERE(\"%s\", \"substr\");\n    std::string s = name.substr(start, found_end - start);\n\n    if(s.length() != 0)\n    {\n        int    status        = 0;\n        char*  output_buffer = nullptr;\n        size_t length        = s.length();\n        char*  d = abi::__cxa_demangle(s.c_str(), output_buffer, &length, &status);\n        if(status == 0 && d != nullptr)\n        {\n            s = d;\n            free(d);\n        }\n    }\n    // PRINT_HERE(\"%s\", \"special-case\");\n    // Special cases for \"main\" and \"start\" on Mac\n    if(s.length() == 0)\n    {\n        if(name == \"main\" || name == \"start\")\n        {\n            s = name;\n        }\n    }\n    // PRINT_HERE(\"%s\", \"returning\");\n    return s;\n}\n//--------------------------------------------------------------------------------------//\n\ninline void\ntimemory_stack_backtrace(std::ostream& os)\n{\n    using size_type = std::string::size_type;\n    // PRINT_HERE(\"%s\", \"\");\n\n    //   from http://linux.die.net/man/3/backtrace_symbols_fd\n#    define BSIZE 100\n    void* buffer[BSIZE];\n    for(size_type j = 0; j < BSIZE; ++j)\n        buffer[j] = nullptr;\n    size_type nptrs   = backtrace(buffer, BSIZE);\n    char**    strings = backtrace_symbols(buffer, nptrs);\n    if(strings == NULL)\n    {\n        perror(\"backtrace_symbols\");\n        return;\n    }\n\n    std::vector<std::vector<std::string>> dmang_buf;\n    std::vector<size_type>                dmang_len;\n\n    // lambda for demangling a string when delimiting\n    auto _transform = [](std::string s) {\n        int    status        = 0;\n        char*  output_buffer = nullptr;\n        size_t length        = s.length();\n        char*  d = abi::__cxa_demangle(s.c_str(), output_buffer, &length, &status);\n        if(status == 0 && d != nullptr)\n        {\n            s = d;\n            free(d);\n        }\n        return s;\n    };\n\n    dmang_buf.resize(nptrs, std::vector<std::string>(0, \"\"));\n\n    for(size_type j = 0; j < nptrs; ++j)\n    {\n        std::string _str = const_cast<const char*>(strings[j]);\n\n        auto _delim = tim::delimit(_str, \" ;\\t\\n\\r()[]\");\n\n        if(_delim.size() > 0)\n            _delim[0] = _transform(_delim[0]);\n\n        /*\n        if(_delim.size() > 1)\n        {\n            int _line = 0;\n            std::stringstream ss;\n            ss << std::hex << _delim[1];\n            ss >> _line;\n            _delim[1] = std::to_string(_line);\n        }\n\n        if(_delim.size() > 2)\n        {\n            std::string _file = \"\";\n            std::stringstream ss;\n            ss << std::hex << _delim[2];\n            ss >> _file;\n            _delim[2] = _file;\n        }\n        */\n\n        for(auto& itr : _delim)\n            itr = _transform(itr);\n\n        /*\n        std::vector<std::string> _dladdr;\n        for(const auto& itr : _delim)\n        {\n            auto idx = itr.find(\"(+\");\n            if(idx == std::string::npos)\n            {\n                _dladdr.push_back(itr);\n            }\n            else\n            {\n                auto edx = itr.find_last_of(')');\n                if(edx == std::string::npos)\n                {\n                    _dladdr.push_back(itr);\n                }\n                else\n                {\n                    auto _funcn = itr.substr(0, idx);\n                    auto _remain = itr.substr(idx+2, edx);\n                    while(_remain.find(')') != std::string::npos)\n                        _remain.erase(_remain.find(')'), 1);\n\n                    _dladdr.push_back(_funcn);\n                    _dladdr.push_back(_remain);\n\n                    // PRINT_HERE(\"%s\", \"dlopen\");\n                    auto _dlopen = dlopen(NULL, RTLD_NOW);\n                    if(_dlopen)\n                    {\n                        // PRINT_HERE(\"%s\", \"dlsym\");\n                        auto _dlsym = dlsym(_dlopen, _remain.c_str());\n                        // PRINT_HERE(\"%s\", \"dladdr\");\n                        Dl_info _info;\n                        auto _ret = dladdr(_dlsym, &_info);\n                        // PRINT_HERE(\"ret: %i\", (int) _ret);\n                        if(_ret != 0 && _info.dli_fname != NULL)\n                        {\n                            // PRINT_HERE(\"%s\", _info.dli_fname);\n                            _dladdr.push_back(std::string(_info.dli_fname));\n                        }\n                    }\n                }\n            }\n        }*/\n\n        // PRINT_HERE(\"iteration %i - accumulate\", (int) j);\n        dmang_len.resize(std::max(dmang_len.size(), _delim.size()), 0);\n\n        // accumulate the max lengths of the strings\n        for(size_type i = 0; i < _delim.size(); ++i)\n            dmang_len[i] = std::max(dmang_len[i], _delim[i].length());\n\n        // add\n        dmang_buf[j] = _delim;\n    }\n\n    // PRINT_HERE(\"%s\", \"\");\n    free(strings);\n\n    std::stringstream _oss;\n\n    _oss << std::endl << \"Call Stack:\" << std::endl;\n    int nwidth = std::max(2, static_cast<int32_t>(std::log10(nptrs)) + 1);\n    for(size_type j = 0; j < nptrs; ++j)\n    {\n        // print the back-trace numver\n        _oss << \"[\" << std::setw(nwidth) << nptrs - j - 1 << \"/\" << std::setw(nwidth)\n             << nptrs << \"] : \";\n\n        // loop over fields\n        for(size_type i = 0; i < dmang_len.size(); ++i)\n        {\n            std::stringstream _ss;\n            // if last param, don't set width\n            int mwidth = (i + 1 < dmang_len.size()) ? dmang_len.at(i) : 0;\n            _ss << std::setw(mwidth) << std::left\n                << ((i < dmang_buf.at(j).size()) ? dmang_buf.at(j).at(i)\n                                                 : std::string(\" \"));\n            _oss << _ss.str() << \"  \";\n            // std::cout << _ss.str() << \"  \";\n        }\n        _oss << std::endl;\n        // std::cout << std::endl;\n    }\n\n    _oss << std::flush;\n    os << _oss.str() << std::flush;\n    // c++filt can demangle:\n    // http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic void\ntimemory_termination_signal_handler(int sig, siginfo_t* sinfo, void* /* context */)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    tim::sys_signal _sig = (tim::sys_signal)(sig);\n\n    if(tim::signal_settings::get_enabled().find(_sig) ==\n       tim::signal_settings::get_enabled().end())\n    {\n        std::stringstream ss;\n        ss << \"signal \" << sig << \" not caught\";\n        throw std::runtime_error(ss.str());\n    }\n    {\n        std::stringstream message;\n        tim::termination_signal_message(sig, sinfo, message);\n        std::cerr << message.str() << std::flush;\n    }\n\n    tim::disable_signal_detection();\n\n    std::stringstream message;\n    message << \"\\n\\n\";\n\n#    if defined(PSIGINFO_AVAILABLE)\n    if(sinfo)\n    {\n        psiginfo(sinfo, message.str().c_str());\n    }\n    else\n    {\n        std::cerr << message.str() << std::endl;\n    }\n#    else\n    std::cerr << message.str() << std::endl;\n#    endif\n    // std::raise(sig);\n    exit(sig);\n}\n\n//======================================================================================//\n\nnamespace tim\n{\n//--------------------------------------------------------------------------------------//\n\nstatic struct sigaction&\ntim_signal_termaction()\n{\n    static struct sigaction timemory_sigaction_instance_new;\n    return timemory_sigaction_instance_new;\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic struct sigaction&\ntim_signal_oldaction()\n{\n    static struct sigaction timemory_sigaction_instance_old;\n    return timemory_sigaction_instance_old;\n}\n\n//--------------------------------------------------------------------------------------//\n\nstatic void\ntermination_signal_message(int sig, siginfo_t* sinfo, std::ostream& os)\n{\n    // PRINT_HERE(\"%s\", \"\");\n    std::stringstream message;\n    sys_signal        _sig = (sys_signal)(sig);\n\n    message << \"\\n### ERROR ### \";\n    if(dmp::is_initialized())\n        message << \" [ rank : \" << dmp::rank() << \" ] \";\n    message << \"Error code : \" << sig;\n    if(sinfo)\n        message << \" @ \" << sinfo->si_addr;\n    message << \" : \" << signal_settings::str(_sig);\n\n    if(sig == SIGSEGV)\n    {\n        if(sinfo)\n        {\n            switch(sinfo->si_code)\n            {\n                case SEGV_MAPERR: message << \"Address not mapped to object.\"; break;\n                case SEGV_ACCERR:\n                    message << \"Invalid permissions for mapped object.\";\n                    break;\n                default:\n                    message << \"Unknown segmentation fault error: \" << sinfo->si_code\n                            << \".\";\n                    break;\n            }\n        }\n        else\n        {\n            message << \"Segmentation fault (unknown).\";\n        }\n    }\n    else if(sig == SIGFPE)\n    {\n        if(sinfo)\n        {\n            switch(sinfo->si_code)\n            {\n                case FE_DIVBYZERO: message << \"Floating point divide by zero.\"; break;\n                case FE_OVERFLOW: message << \"Floating point overflow.\"; break;\n                case FE_UNDERFLOW: message << \"Floating point underflow.\"; break;\n                case FE_INEXACT: message << \"Floating point inexact result.\"; break;\n                case FE_INVALID: message << \"Floating point invalid operation.\"; break;\n                default:\n                    message << \"Unknown floating point exception error: \"\n                            << sinfo->si_code << \".\";\n                    break;\n            }\n        }\n        else\n        {\n            message << \"Unknown error.\";\n        }\n    }\n\n    message << std::endl;\n    try\n    {\n        signal_settings::disable(_sig);\n        signal_settings::exit_action(sig);\n    } catch(std::exception& e)\n    {\n        std::cerr << \"signal_settings::exit_action(\" << sig << \") threw an exception\"\n                  << std::endl;\n        std::cerr << e.what() << std::endl;\n    }\n\n    timemory_stack_backtrace(message);\n    os << message.str() << std::flush;\n}\n\n//--------------------------------------------------------------------------------------//\n\ninline bool\nenable_signal_detection(signal_settings::signal_set_t operations)\n{\n    if(!settings::allow_signal_handler())\n    {\n        if(signal_settings::is_active())\n            disable_signal_detection();\n        return false;\n    }\n\n    // don't re-enable\n    if(signal_settings::is_active())\n        return false;\n\n    if(operations.empty())\n        operations = signal_settings::enabled();\n    else\n    {\n        for(auto& itr : signal_settings::get_enabled())\n            signal_settings::disable(itr);\n        signal_settings::check_environment();\n        for(auto& itr : operations)\n            signal_settings::enable(itr);\n    }\n\n    std::set<int> _signals;\n    for(auto itr = operations.cbegin(); itr != operations.cend(); ++itr)\n        _signals.insert(static_cast<int>(*itr));\n\n    sigfillset(&tim_signal_termaction().sa_mask);\n    for(auto& itr : _signals)\n        sigdelset(&tim_signal_termaction().sa_mask, itr);\n    tim_signal_termaction().sa_sigaction = timemory_termination_signal_handler;\n    tim_signal_termaction().sa_flags     = SA_SIGINFO;\n    for(auto& itr : _signals)\n    {\n        sigaction(itr, &tim_signal_termaction(), &tim_signal_oldaction());\n    }\n    signal_settings::set_active(true);\n\n    if(settings::verbose() > 0 || settings::debug())\n        std::cout << signal_settings::str() << std::endl;\n\n    return true;\n}\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection()\n{\n    // don't re-disable\n    if(!signal_settings::is_active())\n        return;\n\n    sigemptyset(&tim_signal_termaction().sa_mask);\n    tim_signal_termaction().sa_handler = SIG_DFL;\n\n    auto _disable = [](signal_settings::signal_set_t _set) {\n        for(auto itr = _set.cbegin(); itr != _set.cend(); ++itr)\n        {\n            int _itr = static_cast<int>(*itr);\n            sigaction(_itr, &tim_signal_termaction(), 0);\n        }\n    };\n\n    _disable(signal_settings::get_enabled());\n    _disable(signal_settings::get_disabled());\n\n    signal_settings::set_active(false);\n}\n\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#else /* Not a supported architecture */\n\n//======================================================================================//\n\nnamespace tim\n{\n//--------------------------------------------------------------------------------------//\n\ninline bool enable_signal_detection(signal_settings::signal_set_t) { return false; }\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ndisable_signal_detection()\n{}\n\n//--------------------------------------------------------------------------------------//\n\ninline void\ntimemory_stack_backtrace(std::ostream& os)\n{\n    os << \"timemory_stack_backtrace() not available.\" << std::endl;\n}\n\n//--------------------------------------------------------------------------------------//\n\n}  // namespace tim\n\n//======================================================================================//\n\n#endif\n\n#include \"timemory/utility/bits/signals.hpp\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/test/dlopen/test_dlopen.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"gotcha/gotcha.h\"\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n#ifndef LIB_NAME_RAW\n#define LIB_NAME_RAW libnum.so\n#endif\n\n#define LIB_NAME QUOTE(LIB_NAME_RAW)\nint correct_return_four()\n{\n   return 4;\n}\n\nint return_five() \n{\n   /* Intentional bug, gotcha will correct this to return 5*/\n   return 3;\n}\n\nint correct_return_five()\n{\n   return 5;\n}\n\n\nstatic gotcha_wrappee_handle_t buggy_return_four;\nstatic gotcha_wrappee_handle_t buggy_return_five;\nstruct gotcha_binding_t funcs[] = {\n   { \"return_four\", correct_return_four, &buggy_return_four },\n   { \"return_five\", correct_return_five, &buggy_return_five }\n};\n\nint main()\n{\n   void *libnum;\n   int (*retfour)(void);\n   int (*test_retfive)(void);\n   int had_error = 0;\n   int result;\n\n   result = gotcha_wrap(funcs, 2, \"dlopen_test\");\n   if(result != GOTCHA_FUNCTION_NOT_FOUND){\n     fprintf(stderr, \"GOTCHA should have failed to find a function, but found it\\n\");\n     return -1;\n   }\n\n   libnum = dlopen(LIB_NAME, RTLD_NOW);\n   if (!libnum) {\n      fprintf(stderr, \"ERROR: Test failed to dlopen libnum.so\\n\");\n      return -1;\n   }\n\n   /* Test 1: Check if a dlsym generated indirect call gets re-routed by gotcha */\n   retfour = (int (*)(void)) dlsym(libnum, \"return_four\");\n   if (retfour() != 4) {\n      fprintf(stderr, \"ERROR: dlsym returned original function, not wrapped\\n\");\n      had_error = -1;\n   }\n\n   /* Test 2: Does a call in a dlopen'd library get rerouted by gotcha */\n   test_retfive = (int (*)(void)) dlsym(libnum, \"test_return_five\");\n   if (test_retfive() != 5) {\n      fprintf(stderr, \"ERROR: call to return_five in libnum.so was not wrapped by correct_return_five\\n\");\n      had_error = -1;\n   }\n\n   return had_error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/test/multi_agent_dlopen/dlsym.c": "/*\n *  dlsym.c  -->  libsym.so\n *\n *  Override dlsym() and replace with __libc_dlsym().\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MYNAME  \"libsym.so\"\n\ntypedef void * dlsym_fcn_t(void *, const char *);\ntypedef void * dlopen_mode_fcn_t(const char *, int);\n\ndlsym_fcn_t __libc_dlsym;\ndlopen_mode_fcn_t __libc_dlopen_mode;\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n    fprintf(stderr, \"%s:  enter dlsym:  sym = %s\\n\", MYNAME, symbol);\n\n    void * dl_handle = __libc_dlopen_mode(\"libdl.so\", RTLD_LAZY);\n\n    if (dl_handle == NULL) {\n\terr(1, \"__libc_dlopen_mode failed\");\n    }\n\n    dlsym_fcn_t * the_dlsym = __libc_dlsym(dl_handle, \"dlsym\");\n\n    if (the_dlsym == NULL) {\n\terr(1, \"__libc_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  mid   dlsym:  dlsym = %p\\n\", MYNAME, the_dlsym);\n\n#if 0\n    if (handle == RTLD_NEXT) { handle = RTLD_DEFAULT; }\n#endif\n\n    void *ans = the_dlsym(handle, symbol);\n\n    if (ans == NULL) {\n\terr(1, \"the_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  exit  dlsym:  ans = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/test/multi_agent_dlopen/monitor.c": "/*\n *  monitor.c  -->  libmon.so\n *\n *  Override dlopen() use dlsym(RTLD_NEXT).\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n#include <gotcha/gotcha.h>\n\n#define MYNAME  \"libmon.so\"\n\ntypedef void *dlopen_fcn_t(const char *, int);\n\ngotcha_wrappee_handle_t reel_dlopen_handle;\n\nvoid *\nwrap_dlopen(const char *file, int flag)\n{\n    typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n    fprintf(stderr, \"ENTER WRAP: %p\\n\", reel_dlopen);\n    fprintf(stderr, \"%s:  enter dlopen:  file = %s\\n\", MYNAME, file);\n\n    void *ans = reel_dlopen ? (reel_dlopen)(file, flag) : NULL;\n    if(!ans){\n      fprintf(stderr, \"Real dlopen not found\\n\");\n    }\n    fprintf(stderr, \"%s:  exit  dlopen:  handle = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\nvoid* opaque;\nstruct gotcha_binding_t binds[] = {\n  { \"dlopen\", wrap_dlopen, &reel_dlopen_handle}\n};\nvoid fix_things(){\n  reel_dlopen_handle = NULL;\n  gotcha_wrap(binds, 1, \"silly\");\n  typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n  fprintf(stderr, \"IMMEDIATE WRITE: %p\\n\", reel_dlopen);\n}\n__attribute__((constructor)) void startup_fix_things(){\n  fix_things(); \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/test/multi_agent_dlopen/main.c": "/*\n *  Try dlopen(libm.so, ...) and call sin().\n */\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <math.h>\n#include <stdio.h>\n\n#define MYNAME  \"main\"\n\ntypedef double sin_fcn_t(double);\n\nint\nmain(int argc, char **argv)\n{\n    sin_fcn_t *sin_fcn = NULL;\n    double val = 4.0;\n    double ans = 0.0;\n\n    fprintf(stderr, \"%s:  val = %.6f\\n\", MYNAME, val);\n\n    void *handle = dlopen(\"libm.so\", RTLD_NOW);\n    if (handle == NULL) {\n\terr(1, \"dlopen failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    sin_fcn = dlsym(handle, \"sin\");\n    if (sin_fcn == NULL) {\n\terr(1, \"dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    ans = (*sin_fcn)(val);\n\n    fprintf(stderr, \"%s:  ans = %.6f\\n\", MYNAME, ans);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/gotcha/test/multi_agent_dlopen/CMakeLists.txt": "set(CMAKE_C_FLAGS \"-g -O -fPIC\")\nadd_library(multi_agent_sym SHARED dlsym.c)\nadd_library(multi_agent_mon SHARED monitor.c)\nadd_executable(multi_agent_main main.c)\ntarget_link_libraries(multi_agent_main dl)\ntarget_link_libraries(multi_agent_mon dl gotcha)\ngotcha_add_test(multi_agent_dlopen multi_agent_main)\nenvironment_add(multi_agent_dlopen TEST \"LD_PRELOAD=${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_sym.so:${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_mon.so GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/objects/pack/pack-3f3989b4d8e8958c1e507dc4864ecd0f1d89e700.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/objects/pack/pack-3f3989b4d8e8958c1e507dc4864ecd0f1d89e700.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/google-test/objects/pack/pack-d8d7265a7d7eb7f9985925206325110f400ff382.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/google-test/objects/pack/pack-d8d7265a7d7eb7f9985925206325110f400ff382.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/python/pybind11/objects/pack/pack-075ad05d3dd551f84af905ed4628f28821559509.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/python/pybind11/objects/pack/pack-075ad05d3dd551f84af905ed4628f28821559509.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/cereal/objects/pack/pack-a012d54d8315c289deb64456c643e69a05287354.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/source/cereal/objects/pack/pack-a012d54d8315c289deb64456c643e69a05287354.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/pybind11/docs/pybind11_vs_boost_python1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/pybind11/docs/pybind11-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/pybind11/docs/pybind11_vs_boost_python2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/src/mpi-rt/services/mpit/mpitdesign/design.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/src/mpi-rt/services/mpit/mpitdesign/caliper.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/doc/sphinx/caliper-services-workflow.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/external/caliper/doc/sphinx/caliper-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/docs/components/mpi_macro_dp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/docs/components/work_macro_sp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-3.0.0-jw2hytpwzzpi6gwqkbaasgnksn2htayw/spack-src/docs/getting_started/roofline.jpg"
    ],
    "total_files": 1742
}