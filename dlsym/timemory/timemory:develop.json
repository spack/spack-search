{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/source/weak.cpp": "// MIT License\n//\n// Copyright (c) 2020, The Regents of the University of California,\n// through Lawrence Berkeley National Laboratory (subject to receipt of any\n// required approvals from the U.S. Dept. of Energy).  All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include \"timemory/backends/process.hpp\"\n#include \"timemory/compat/library.h\"\n#include \"timemory/components/ompt/types.hpp\"\n#include \"timemory/environment.hpp\"\n#include \"timemory/library.h\"\n#include \"timemory/settings.hpp\"\n\n#include <cstdint>\n#include <limits>\n#include <numeric>\n\n#if !defined(_WINDOWS)\n#    include <dlfcn.h>\n#endif\n\n// Macro for obtaining jump pointer function association\n#if defined(_WINDOWS)\n#    define DLSYM_FUNCTION(VARNAME, HANDLE, FUNCNAME)\n#else\n#    define DLSYM_FUNCTION(VARNAME, HANDLE, FUNCNAME)                                    \\\n        if(HANDLE)                                                                       \\\n        {                                                                                \\\n            *(void**) (&VARNAME) = dlsym(HANDLE, FUNCNAME.c_str());                      \\\n            if(VARNAME == nullptr)                                                       \\\n            {                                                                            \\\n                fprintf(stderr, \"[%s][pid=%i]> %s\\n\", FUNCNAME.c_str(),                  \\\n                        tim::process::get_id(), dlerror());                              \\\n            }                                                                            \\\n        }                                                                                \\\n        else                                                                             \\\n        {                                                                                \\\n            VARNAME = nullptr;                                                           \\\n        }\n#endif\n\n#if !defined(OS_DYNAMIC_LIBRARY_EXT)\n#    if defined(_MACOS)\n#        define OS_DYNAMIC_LIBRARY_EXT \"dylib\"\n#    elif defined(_WINDOWS)\n#        define OS_DYNAMIC_LIBRARY_EXT \"dll\"\n#    else\n#        define OS_DYNAMIC_LIBRARY_EXT \"so\"\n#    endif\n#endif\n\nstruct tools_stubs_dlsym\n{\n    using ctor_function_t       = void (*)();\n    using register_function_t   = void (*)();\n    using deregister_function_t = void (*)();\n    using start_function_t      = uint64_t (*)();\n    using stop_function_t       = uint64_t (*)(uint64_t);\n\n    TIMEMORY_DEFAULT_OBJECT(tools_stubs_dlsym)\n\n    tools_stubs_dlsym(const std::string& id, std::string libname = \"\")\n    {\n        load(id, libname);\n    }\n\n    void load(const std::string& id, std::string libname = \"\")\n    {\n#if defined(_WINDOWS)\n        tim::consume_parameters(id, libname);\n#else\n        if(libname.empty())\n            libname = TIMEMORY_JOIN(\"\", \"libtimemory-\", id, '.', OS_DYNAMIC_LIBRARY_EXT);\n\n        auto libhandle = dlopen(libname.c_str(), RTLD_LAZY);\n\n        if(!libhandle)\n        {\n            if(tim::settings::debug())\n                fprintf(stderr, \"%s\\n\", dlerror());\n        }\n\n        dlerror(); /* Clear any existing error */\n\n        auto ctor_name       = TIMEMORY_JOIN(\"\", \"timemory_\", id, \"_library_ctor\");\n        auto register_name   = TIMEMORY_JOIN(\"\", \"timemory_register_\", id);\n        auto deregister_name = TIMEMORY_JOIN(\"\", \"timemory_deregister_\", id);\n        auto start_name      = TIMEMORY_JOIN(\"\", \"timemory_start_\", id);\n        auto stop_name       = TIMEMORY_JOIN(\"\", \"timemory_stop_\", id);\n\n        // Initialize all pointers\n        DLSYM_FUNCTION(m_ctor, libhandle, ctor_name);\n        DLSYM_FUNCTION(m_register, libhandle, register_name);\n        DLSYM_FUNCTION(m_deregister, libhandle, deregister_name);\n        DLSYM_FUNCTION(m_start, libhandle, start_name);\n        DLSYM_FUNCTION(m_stop, libhandle, stop_name);\n#endif\n    }\n\n    void invoke_ctor()\n    {\n        if(m_ctor)\n            (*m_ctor)();\n    }\n\n    void invoke_register()\n    {\n        if(m_register)\n            (*m_register)();\n    }\n\n    void invoke_deregister()\n    {\n        if(m_deregister)\n            (*m_deregister)();\n    }\n\n    uint64_t invoke_start()\n    {\n        if(m_start)\n            return (*m_start)();\n        return std::numeric_limits<uint64_t>::max();\n    }\n\n    uint64_t invoke_stop(uint64_t val)\n    {\n        if(m_stop)\n            return (*m_stop)(val);\n        return 0;\n    }\n\nprivate:\n    ctor_function_t       m_ctor       = nullptr;\n    register_function_t   m_register   = nullptr;\n    deregister_function_t m_deregister = nullptr;\n    start_function_t      m_start      = nullptr;\n    stop_function_t       m_stop       = nullptr;\n};\n\nenum TOOL_STUB_IDS\n{\n    mpip_idx = 0,\n    ompt_idx,\n    ncclp_idx,\n    mallocp_idx,\n};\n\ntemplate <int Idx>\ntools_stubs_dlsym*\nget_tool_stubs();\n\n#define TOOL_DLSYM_SPECIALIZAITON(INDEX, ID, ENV_VAR)                                    \\\n    template <>                                                                          \\\n    tools_stubs_dlsym* get_tool_stubs<INDEX>()                                           \\\n    {                                                                                    \\\n        static auto _instance = std::unique_ptr<tools_stubs_dlsym>{};                    \\\n        if(!_instance)                                                                   \\\n        {                                                                                \\\n            auto _env = tim::get_env<std::string>(ENV_VAR, \"\");                          \\\n            _instance = std::make_unique<tools_stubs_dlsym>(ID, _env);                   \\\n        }                                                                                \\\n        return _instance.get();                                                          \\\n    }\n\nTOOL_DLSYM_SPECIALIZAITON(mpip_idx, \"mpip\", \"TIMEMORY_MPIP_LIBRARY\")\nTOOL_DLSYM_SPECIALIZAITON(ompt_idx, \"ompt\", \"TIMEMORY_OMPT_LIBRARY\")\nTOOL_DLSYM_SPECIALIZAITON(ncclp_idx, \"ncclp\", \"TIMEMORY_NCCLP_LIBRARY\")\nTOOL_DLSYM_SPECIALIZAITON(mallocp_idx, \"mallocp\", \"TIMEMORY_MALLOCP_LIBRARY\")\n\n#define TOOL_INDEX(NAME) NAME##_idx\n#define TOOL_DLSYM(NAME) get_tool_stubs<TOOL_INDEX(NAME)>()\n#define TOOL_PREFIX TIMEMORY_WEAK_PREFIX\n#define TOOL_SUFFIX TIMEMORY_WEAK_POSTFIX TIMEMORY_VISIBILITY(\"default\")\n#define TOOL_STUBS(NAME)                                                                 \\\n    TOOL_PREFIX                                                                          \\\n    void timemory_##NAME##_library_ctor() TOOL_SUFFIX;                                   \\\n    TOOL_PREFIX                                                                          \\\n    void timemory_register_##NAME() TOOL_SUFFIX;                                         \\\n    TOOL_PREFIX                                                                          \\\n    void timemory_deregister_##NAME() TOOL_SUFFIX;                                       \\\n    TOOL_PREFIX                                                                          \\\n    uint64_t timemory_start_##NAME() TOOL_SUFFIX;                                        \\\n    TOOL_PREFIX                                                                          \\\n    uint64_t timemory_stop_##NAME(uint64_t) TOOL_SUFFIX;                                 \\\n                                                                                         \\\n    void     timemory_##NAME##_library_ctor() { TOOL_DLSYM(NAME)->invoke_ctor(); }       \\\n    void     timemory_register_##NAME() { TOOL_DLSYM(NAME)->invoke_register(); }         \\\n    void     timemory_deregister_##NAME() { TOOL_DLSYM(NAME)->invoke_deregister(); }     \\\n    uint64_t timemory_start_##NAME() { return TOOL_DLSYM(NAME)->invoke_start(); }        \\\n    uint64_t timemory_stop_##NAME(uint64_t v) { return TOOL_DLSYM(NAME)->invoke_stop(v); }\n\nextern \"C\"\n{\n    //\n    //----------------------------------------------------------------------------------//\n    //\n    TOOL_STUBS(mpip)\n    TOOL_STUBS(ompt)\n    TOOL_STUBS(ncclp)\n    TOOL_STUBS(mallocp)\n    //\n    //----------------------------------------------------------------------------------//\n    //\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/source/tools/timemory-jump/README.md": "# timemory-jump library\n\nThe timemory jump library implements the **jump** instrumentation mode for `timemory-run` tool. Additionally, this library can\nbe linked to in lieu of the traditional timemory library and provide instrumentation via setting the environment variable\n`TIMEMORY_JUMP_LIBRARY` on libraries which provide `dlsym` and `dlopen`.\n\n## Description\n\nThe **jump** mode is used to insert dynamic instrumentation code in an application binary using **function pointers**. The inserted function pointers dereference to the instrumentation code at runtime alleviating the risk of self instrumentation loop in case a library that is being used by instrumentation code is instrumented. For example, dynamic instrumentation of `libm` may lead to a self instrumentation loop. The **jump** instrumentation mode can be used by using the `--jump` option with `timemory-run` tool.\n\n## About timemory-run tool\n\nPlease refer to [timemory-run documentation](../timemory-run/README.md) for infomation about this tool.\n\n## Usage\n\n**NOTE:** Make sure the libtimemory-jump.so is in the `LD_LIBRARY_PATH` environment variable before running `timemory-run`.\n\n```bash\n$ timemory-run --jump [OPTIONS] -o <INSTRUMENTED_BINARY> -- <BINARY>\n```\n\n## Examples\n\n```bash\n$ timemory-run --jump -o lscpu.inst -- /usr/bin/lscpu\n\n [command]: /usr/bin/lscpu\n\ninstrumentation target: /usr/bin/lscpu\nloading library: 'libtimemory-jump.so'...\ntimemory-run: Unable to find function exit\ntimemory-run: Unable to find function MPI_Init\ntimemory-run: Unable to find function MPI_Finalize\nInstrumenting with 'timemory_push_trace' and 'timemory_pop_trace'...\nParsing module: lscpu\nDumping 'available_module_functions.txt'...\nDumping 'instrumented_module_functions.txt'...\n\nThe instrumented executable image is stored in '/home/mhaseeb/lscpu.inst'\n[timemory-run]> Getting linked libraries for /usr/bin/lscpu...\n[timemory-run]> Consider instrumenting the relevant libraries...\n\n        /lib/x86_64-linux-gnu/libsmartcols.so.1\n        /lib/x86_64-linux-gnu/libc.so.6\n        /lib64/ld-linux-x86-64.so.2\n```\n\n### Testing the instrumented binary\n```bash\n$ ./lscpu.inst\n#------------------------- tim::manager initialized [id=0][pid=12885] -------------------------#\n\n[pid=12885][tid=0][timemory_trace_init@'../source/trace.cpp':636]> rank = 0, pid = 12885, thread = 0, args = wall_clock...\nArchitecture:        x86_64\nCPU op-mode(s):      32-bit, 64-bit\nByte Order:          Little Endian\nCPU(s):              12\nOn-line CPU(s) list: 0-11\nThread(s) per core:  2\nCore(s) per socket:  6\nSocket(s):           1\nNUMA node(s):        1\nVendor ID:           GenuineIntel\nCPU family:          6\nModel:               79\nModel name:          Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz\nStepping:            1\nCPU MHz:             1204.187\nCPU max MHz:         4000.0000\nCPU min MHz:         1200.0000\nBogoMIPS:            6799.28\nVirtualization:      VT-x\nL1d cache:           32K\nL1i cache:           32K\nL2 cache:            256K\nL3 cache:            15360K\nNUMA node0 CPU(s):   0-11\nFlags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cdp_l3 invpcid_single pti intel_ppin ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdt_a rdseed adx smap intel_pt xsaveopt cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts md_clear flush_l1d\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.flamegraph.json'...\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.json'...\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.txt'...\n/home/mhaseeb/repos/spack/opt/spack/linux-ubuntu18.04-broadwell/gcc-8.4.0/python-3.7.7-2dybrjceqs3qc4k7ci56t56bvzb4csxc/bin/python: Error while finding module specification for 'timemory.plotting' (ModuleNotFoundError: No module named 'timemory')\n[timemory]> Command: '/home/mhaseeb/repos/spack/opt/spack/linux-ubuntu18.04-broadwell/gcc-8.4.0/python-3.7.7-2dybrjceqs3qc4k7ci56t56bvzb4csxc/bin/python -m timemory.plotting -f timemory-lscpu.inst-output/wall.json -t \"wall \" -o timemory-lscpu.inst-output' returned a non-zero exit code: 256... plot/definition.hpp:77 plot generation failed\n\n|------------------------------------------------------------------------------------------------------------------------|\n|                                            REAL-CLOCK TIMER (I.E. WALL-CLOCK TIMER)                                    |\n| ---------------------------------------------------------------------------------------------------------------------- |\n|   LABEL  | COUNT    | DEPTH    | METRIC   | UNITS    | SUM      | MEAN     | MIN      | MAX      | STDDEV   | % SELF   |\n| ---------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|\n| >>> main | 1        | 0        | wall     | sec      | 0.026    | 0.026    | 0.026    | 0.026    | 0.000    | 100.0    |\n|------------------------------------------------------------------------------------------------------------------------|\n\n[metadata::manager::finalize]> Outputting 'timemory-lscpu.inst-output/metadata.json'...\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/source/tools/timemory-jump/library.cpp": "// MIT License\n//\n// Copyright (c) 2020, The Regents of the University of California,\n// through Lawrence Berkeley National Laboratory (subject to receipt of any\n// required approvals from the U.S. Dept. of Energy).  All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include \"timemory/backends/process.hpp\"\n#include \"timemory/environment.hpp\"\n\n#include <dlfcn.h>\n\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <limits>\n#include <memory>\n#include <string>\n\n// Macro for obtaining jump pointer function association\n#define DLSYM_JUMP_FUNCTION(VARNAME, HANDLE, FUNCNAME)                                   \\\n    if(HANDLE)                                                                           \\\n    {                                                                                    \\\n        *(void**) (&VARNAME) = dlsym(HANDLE, FUNCNAME);                                  \\\n        if(VARNAME == nullptr)                                                           \\\n        {                                                                                \\\n            fprintf(stderr, \"[timemory-jump@%s][pid=%i]> %s\\n\", FUNCNAME,                \\\n                    tim::process::get_id(), dlerror());                                  \\\n        }                                                                                \\\n    }                                                                                    \\\n    else                                                                                 \\\n    {                                                                                    \\\n        VARNAME = nullptr;                                                               \\\n    }\n\n//--------------------------------------------------------------------------------------//\n\n// This class contains jump pointers for timemory's dyninst functions\nclass jump\n{\npublic:\n    void (*timemory_push_components_jump)(const char*);  // NOLINT\n    void (*timemory_pop_components_jump)(void);          // NOLINT\n\n    void (*timemory_push_region_jump)(const char*);  // NOLINT\n    void (*timemory_pop_region_jump)(const char*);   // NOLINT\n\n    void (*timemory_add_hash_id_jump)(uint64_t, const char*);          // NOLINT\n    void (*timemory_push_trace_jump)(const char*);                     // NOLINT\n    void (*timemory_pop_trace_jump)(const char*);                      // NOLINT\n    void (*timemory_push_trace_hash_jump)(uint64_t);                   // NOLINT\n    void (*timemory_pop_trace_hash_jump)(uint64_t);                    // NOLINT\n    void (*timemory_trace_init_jump)(const char*, bool, const char*);  // NOLINT\n    void (*timemory_trace_finalize_jump)(void);                        // NOLINT\n    void (*timemory_trace_set_env_jump)(const char*, const char*);     // NOLINT\n    void (*timemory_trace_set_mpi_jump)(bool, bool);                   // NOLINT\n\n    explicit jump(std::string&& libpath)\n    {\n        auto libhandle = dlopen(libpath.c_str(), RTLD_LAZY);\n\n        if(!libhandle)\n            fprintf(stderr, \"%s\\n\", dlerror());\n\n        dlerror(); /* Clear any existing error */\n\n        /* Initialize all pointers */\n        DLSYM_JUMP_FUNCTION(timemory_push_components_jump, libhandle,\n                            \"timemory_push_components\");\n\n        DLSYM_JUMP_FUNCTION(timemory_pop_components_jump, libhandle,\n                            \"timemory_pop_components\");\n\n        DLSYM_JUMP_FUNCTION(timemory_push_region_jump, libhandle, \"timemory_push_region\");\n\n        DLSYM_JUMP_FUNCTION(timemory_pop_region_jump, libhandle, \"timemory_pop_region\");\n\n        DLSYM_JUMP_FUNCTION(timemory_add_hash_id_jump, libhandle, \"timemory_add_hash_id\");\n\n        DLSYM_JUMP_FUNCTION(timemory_push_trace_jump, libhandle, \"timemory_push_trace\");\n\n        DLSYM_JUMP_FUNCTION(timemory_pop_trace_jump, libhandle, \"timemory_pop_trace\");\n\n        DLSYM_JUMP_FUNCTION(timemory_push_trace_hash_jump, libhandle,\n                            \"timemory_push_trace_hash\");\n\n        DLSYM_JUMP_FUNCTION(timemory_pop_trace_hash_jump, libhandle,\n                            \"timemory_pop_trace_hash\");\n\n        DLSYM_JUMP_FUNCTION(timemory_trace_init_jump, libhandle, \"timemory_trace_init\");\n\n        DLSYM_JUMP_FUNCTION(timemory_trace_finalize_jump, libhandle,\n                            \"timemory_trace_finalize\");\n\n        DLSYM_JUMP_FUNCTION(timemory_trace_set_env_jump, libhandle,\n                            \"timemory_trace_set_env\");\n\n        DLSYM_JUMP_FUNCTION(timemory_trace_set_mpi_jump, libhandle,\n                            \"timemory_trace_set_mpi\");\n\n        dlclose(libhandle);\n    }\n};\n\n//--------------------------------------------------------------------------------------//\n\nstd::unique_ptr<jump>&\nget_jump()\n{\n#if defined(_MACOS)\n    static std::unique_ptr<jump> obj = std::make_unique<jump>(\n        tim::get_env<std::string>(\"TIMEMORY_JUMP_LIBRARY\", \"libtimemory.so\"));\n#else\n    static std::unique_ptr<jump> obj = std::make_unique<jump>(\n        tim::get_env<std::string>(\"TIMEMORY_JUMP_LIBRARY\", \"libtimemory.dylib\"));\n#endif\n    return obj;\n}\n\n//--------------------------------------------------------------------------------------//\n//\n//      timemory symbols\n//\n//--------------------------------------------------------------------------------------//\nextern \"C\"\n{\n    void timemory_push_components(const char* name)\n    {\n        (*get_jump()->timemory_push_components_jump)(name);\n    }\n\n    void timemory_pop_components(void) { (*get_jump()->timemory_pop_components_jump)(); }\n\n    void timemory_push_region(const char* name)\n    {\n        (*get_jump()->timemory_push_region_jump)(name);\n    }\n\n    void timemory_pop_region(const char* name)\n    {\n        (*get_jump()->timemory_pop_region_jump)(name);\n    }\n\n    void timemory_add_hash_id(uint64_t hash, const char* name)\n    {\n        (*get_jump()->timemory_add_hash_id_jump)(hash, name);\n    }\n\n    void timemory_push_trace(const char* name)\n    {\n        (*get_jump()->timemory_push_trace_jump)(name);\n    }\n\n    void timemory_pop_trace(const char* name)\n    {\n        (*get_jump()->timemory_pop_trace_jump)(name);\n    }\n\n    void timemory_push_trace_hash(uint64_t hash)\n    {\n        (*get_jump()->timemory_push_trace_hash_jump)(hash);\n    }\n\n    void timemory_pop_trace_hash(uint64_t hash)\n    {\n        (*get_jump()->timemory_pop_trace_hash_jump)(hash);\n    }\n\n    void timemory_trace_init(const char* a, bool b, const char* c)\n    {\n        (*get_jump()->timemory_trace_init_jump)(a, b, c);\n    }\n\n    void timemory_trace_finalize(void) { (*get_jump()->timemory_trace_finalize_jump)(); }\n\n    void timemory_trace_set_env(const char* a, const char* b)\n    {\n        (*get_jump()->timemory_trace_set_env_jump)(a, b);\n    }\n\n    void timemory_trace_set_mpi(bool a, bool b)\n    {\n        (*get_jump()->timemory_trace_set_mpi_jump)(a, b);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/runtime/src/z_Linux_util.cpp": "/*\n * z_Linux_util.cpp -- platform specific routines.\n */\n\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.txt for details.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"kmp.h\"\n#include \"kmp_affinity.h\"\n#include \"kmp_i18n.h\"\n#include \"kmp_io.h\"\n#include \"kmp_itt.h\"\n#include \"kmp_lock.h\"\n#include \"kmp_stats.h\"\n#include \"kmp_str.h\"\n#include \"kmp_wait_release.h\"\n#include \"kmp_wrapper_getpid.h\"\n\n#if !KMP_OS_FREEBSD && !KMP_OS_NETBSD\n#include <alloca.h>\n#endif\n#include <math.h> // HUGE_VAL.\n#include <sys/resource.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/times.h>\n#include <unistd.h>\n\n#if KMP_OS_LINUX && !KMP_OS_CNK\n#include <sys/sysinfo.h>\n#if KMP_USE_FUTEX\n// We should really include <futex.h>, but that causes compatibility problems on\n// different Linux* OS distributions that either require that you include (or\n// break when you try to include) <pci/types.h>. Since all we need is the two\n// macros below (which are part of the kernel ABI, so can't change) we just\n// define the constants here and don't include <futex.h>\n#ifndef FUTEX_WAIT\n#define FUTEX_WAIT 0\n#endif\n#ifndef FUTEX_WAKE\n#define FUTEX_WAKE 1\n#endif\n#endif\n#elif KMP_OS_DARWIN\n#include <mach/mach.h>\n#include <sys/sysctl.h>\n#elif KMP_OS_FREEBSD\n#include <pthread_np.h>\n#endif\n\n#include <ctype.h>\n#include <dirent.h>\n#include <fcntl.h>\n\n#include \"tsan_annotations.h\"\n\nstruct kmp_sys_timer {\n  struct timespec start;\n};\n\n// Convert timespec to nanoseconds.\n#define TS2NS(timespec) (((timespec).tv_sec * 1e9) + (timespec).tv_nsec)\n\nstatic struct kmp_sys_timer __kmp_sys_timer_data;\n\n#if KMP_HANDLE_SIGNALS\ntypedef void (*sig_func_t)(int);\nSTATIC_EFI2_WORKAROUND struct sigaction __kmp_sighldrs[NSIG];\nstatic sigset_t __kmp_sigset;\n#endif\n\nstatic int __kmp_init_runtime = FALSE;\n\nstatic int __kmp_fork_count = 0;\n\nstatic pthread_condattr_t __kmp_suspend_cond_attr;\nstatic pthread_mutexattr_t __kmp_suspend_mutex_attr;\n\nstatic kmp_cond_align_t __kmp_wait_cv;\nstatic kmp_mutex_align_t __kmp_wait_mx;\n\nkmp_uint64 __kmp_ticks_per_msec = 1000000;\n\n#ifdef DEBUG_SUSPEND\nstatic void __kmp_print_cond(char *buffer, kmp_cond_align_t *cond) {\n  KMP_SNPRINTF(buffer, 128, \"(cond (lock (%ld, %d)), (descr (%p)))\",\n               cond->c_cond.__c_lock.__status, cond->c_cond.__c_lock.__spinlock,\n               cond->c_cond.__c_waiting);\n}\n#endif\n\n#if (KMP_OS_LINUX && KMP_AFFINITY_SUPPORTED)\n\n/* Affinity support */\n\nvoid __kmp_affinity_bind_thread(int which) {\n  KMP_ASSERT2(KMP_AFFINITY_CAPABLE(),\n              \"Illegal set affinity operation when not capable\");\n\n  kmp_affin_mask_t *mask;\n  KMP_CPU_ALLOC_ON_STACK(mask);\n  KMP_CPU_ZERO(mask);\n  KMP_CPU_SET(which, mask);\n  __kmp_set_system_affinity(mask, TRUE);\n  KMP_CPU_FREE_FROM_STACK(mask);\n}\n\n/* Determine if we can access affinity functionality on this version of\n * Linux* OS by checking __NR_sched_{get,set}affinity system calls, and set\n * __kmp_affin_mask_size to the appropriate value (0 means not capable). */\nvoid __kmp_affinity_determine_capable(const char *env_var) {\n// Check and see if the OS supports thread affinity.\n\n#define KMP_CPU_SET_SIZE_LIMIT (1024 * 1024)\n\n  int gCode;\n  int sCode;\n  unsigned char *buf;\n  buf = (unsigned char *)KMP_INTERNAL_MALLOC(KMP_CPU_SET_SIZE_LIMIT);\n\n  // If Linux* OS:\n  // If the syscall fails or returns a suggestion for the size,\n  // then we don't have to search for an appropriate size.\n  gCode = syscall(__NR_sched_getaffinity, 0, KMP_CPU_SET_SIZE_LIMIT, buf);\n  KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                \"initial getaffinity call returned %d errno = %d\\n\",\n                gCode, errno));\n\n  // if ((gCode < 0) && (errno == ENOSYS))\n  if (gCode < 0) {\n    // System call not supported\n    if (__kmp_affinity_verbose ||\n        (__kmp_affinity_warnings && (__kmp_affinity_type != affinity_none) &&\n         (__kmp_affinity_type != affinity_default) &&\n         (__kmp_affinity_type != affinity_disabled))) {\n      int error = errno;\n      kmp_msg_t err_code = KMP_ERR(error);\n      __kmp_msg(kmp_ms_warning, KMP_MSG(GetAffSysCallNotSupported, env_var),\n                err_code, __kmp_msg_null);\n      if (__kmp_generate_warnings == kmp_warnings_off) {\n        __kmp_str_free(&err_code.str);\n      }\n    }\n    KMP_AFFINITY_DISABLE();\n    KMP_INTERNAL_FREE(buf);\n    return;\n  }\n  if (gCode > 0) { // Linux* OS only\n    // The optimal situation: the OS returns the size of the buffer it expects.\n    //\n    // A verification of correct behavior is that Isetaffinity on a NULL\n    // buffer with the same size fails with errno set to EFAULT.\n    sCode = syscall(__NR_sched_setaffinity, 0, gCode, NULL);\n    KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                  \"setaffinity for mask size %d returned %d errno = %d\\n\",\n                  gCode, sCode, errno));\n    if (sCode < 0) {\n      if (errno == ENOSYS) {\n        if (__kmp_affinity_verbose ||\n            (__kmp_affinity_warnings &&\n             (__kmp_affinity_type != affinity_none) &&\n             (__kmp_affinity_type != affinity_default) &&\n             (__kmp_affinity_type != affinity_disabled))) {\n          int error = errno;\n          kmp_msg_t err_code = KMP_ERR(error);\n          __kmp_msg(kmp_ms_warning, KMP_MSG(SetAffSysCallNotSupported, env_var),\n                    err_code, __kmp_msg_null);\n          if (__kmp_generate_warnings == kmp_warnings_off) {\n            __kmp_str_free(&err_code.str);\n          }\n        }\n        KMP_AFFINITY_DISABLE();\n        KMP_INTERNAL_FREE(buf);\n      }\n      if (errno == EFAULT) {\n        KMP_AFFINITY_ENABLE(gCode);\n        KA_TRACE(10, (\"__kmp_affinity_determine_capable: \"\n                      \"affinity supported (mask size %d)\\n\",\n                      (int)__kmp_affin_mask_size));\n        KMP_INTERNAL_FREE(buf);\n        return;\n      }\n    }\n  }\n\n  // Call the getaffinity system call repeatedly with increasing set sizes\n  // until we succeed, or reach an upper bound on the search.\n  KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                \"searching for proper set size\\n\"));\n  int size;\n  for (size = 1; size <= KMP_CPU_SET_SIZE_LIMIT; size *= 2) {\n    gCode = syscall(__NR_sched_getaffinity, 0, size, buf);\n    KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                  \"getaffinity for mask size %d returned %d errno = %d\\n\",\n                  size, gCode, errno));\n\n    if (gCode < 0) {\n      if (errno == ENOSYS) {\n        // We shouldn't get here\n        KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                      \"inconsistent OS call behavior: errno == ENOSYS for mask \"\n                      \"size %d\\n\",\n                      size));\n        if (__kmp_affinity_verbose ||\n            (__kmp_affinity_warnings &&\n             (__kmp_affinity_type != affinity_none) &&\n             (__kmp_affinity_type != affinity_default) &&\n             (__kmp_affinity_type != affinity_disabled))) {\n          int error = errno;\n          kmp_msg_t err_code = KMP_ERR(error);\n          __kmp_msg(kmp_ms_warning, KMP_MSG(GetAffSysCallNotSupported, env_var),\n                    err_code, __kmp_msg_null);\n          if (__kmp_generate_warnings == kmp_warnings_off) {\n            __kmp_str_free(&err_code.str);\n          }\n        }\n        KMP_AFFINITY_DISABLE();\n        KMP_INTERNAL_FREE(buf);\n        return;\n      }\n      continue;\n    }\n\n    sCode = syscall(__NR_sched_setaffinity, 0, gCode, NULL);\n    KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                  \"setaffinity for mask size %d returned %d errno = %d\\n\",\n                  gCode, sCode, errno));\n    if (sCode < 0) {\n      if (errno == ENOSYS) { // Linux* OS only\n        // We shouldn't get here\n        KA_TRACE(30, (\"__kmp_affinity_determine_capable: \"\n                      \"inconsistent OS call behavior: errno == ENOSYS for mask \"\n                      \"size %d\\n\",\n                      size));\n        if (__kmp_affinity_verbose ||\n            (__kmp_affinity_warnings &&\n             (__kmp_affinity_type != affinity_none) &&\n             (__kmp_affinity_type != affinity_default) &&\n             (__kmp_affinity_type != affinity_disabled))) {\n          int error = errno;\n          kmp_msg_t err_code = KMP_ERR(error);\n          __kmp_msg(kmp_ms_warning, KMP_MSG(SetAffSysCallNotSupported, env_var),\n                    err_code, __kmp_msg_null);\n          if (__kmp_generate_warnings == kmp_warnings_off) {\n            __kmp_str_free(&err_code.str);\n          }\n        }\n        KMP_AFFINITY_DISABLE();\n        KMP_INTERNAL_FREE(buf);\n        return;\n      }\n      if (errno == EFAULT) {\n        KMP_AFFINITY_ENABLE(gCode);\n        KA_TRACE(10, (\"__kmp_affinity_determine_capable: \"\n                      \"affinity supported (mask size %d)\\n\",\n                      (int)__kmp_affin_mask_size));\n        KMP_INTERNAL_FREE(buf);\n        return;\n      }\n    }\n  }\n  // save uncaught error code\n  // int error = errno;\n  KMP_INTERNAL_FREE(buf);\n  // restore uncaught error code, will be printed at the next KMP_WARNING below\n  // errno = error;\n\n  // Affinity is not supported\n  KMP_AFFINITY_DISABLE();\n  KA_TRACE(10, (\"__kmp_affinity_determine_capable: \"\n                \"cannot determine mask size - affinity not supported\\n\"));\n  if (__kmp_affinity_verbose ||\n      (__kmp_affinity_warnings && (__kmp_affinity_type != affinity_none) &&\n       (__kmp_affinity_type != affinity_default) &&\n       (__kmp_affinity_type != affinity_disabled))) {\n    KMP_WARNING(AffCantGetMaskSize, env_var);\n  }\n}\n\n#endif // KMP_OS_LINUX && KMP_AFFINITY_SUPPORTED\n\n#if KMP_USE_FUTEX\n\nint __kmp_futex_determine_capable() {\n  int loc = 0;\n  int rc = syscall(__NR_futex, &loc, FUTEX_WAKE, 1, NULL, NULL, 0);\n  int retval = (rc == 0) || (errno != ENOSYS);\n\n  KA_TRACE(10,\n           (\"__kmp_futex_determine_capable: rc = %d errno = %d\\n\", rc, errno));\n  KA_TRACE(10, (\"__kmp_futex_determine_capable: futex syscall%s supported\\n\",\n                retval ? \"\" : \" not\"));\n\n  return retval;\n}\n\n#endif // KMP_USE_FUTEX\n\n#if (KMP_ARCH_X86 || KMP_ARCH_X86_64) && (!KMP_ASM_INTRINS)\n/* Only 32-bit \"add-exchange\" instruction on IA-32 architecture causes us to\n   use compare_and_store for these routines */\n\nkmp_int8 __kmp_test_then_or8(volatile kmp_int8 *p, kmp_int8 d) {\n  kmp_int8 old_value, new_value;\n\n  old_value = TCR_1(*p);\n  new_value = old_value | d;\n\n  while (!KMP_COMPARE_AND_STORE_REL8(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_1(*p);\n    new_value = old_value | d;\n  }\n  return old_value;\n}\n\nkmp_int8 __kmp_test_then_and8(volatile kmp_int8 *p, kmp_int8 d) {\n  kmp_int8 old_value, new_value;\n\n  old_value = TCR_1(*p);\n  new_value = old_value & d;\n\n  while (!KMP_COMPARE_AND_STORE_REL8(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_1(*p);\n    new_value = old_value & d;\n  }\n  return old_value;\n}\n\nkmp_uint32 __kmp_test_then_or32(volatile kmp_uint32 *p, kmp_uint32 d) {\n  kmp_uint32 old_value, new_value;\n\n  old_value = TCR_4(*p);\n  new_value = old_value | d;\n\n  while (!KMP_COMPARE_AND_STORE_REL32(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_4(*p);\n    new_value = old_value | d;\n  }\n  return old_value;\n}\n\nkmp_uint32 __kmp_test_then_and32(volatile kmp_uint32 *p, kmp_uint32 d) {\n  kmp_uint32 old_value, new_value;\n\n  old_value = TCR_4(*p);\n  new_value = old_value & d;\n\n  while (!KMP_COMPARE_AND_STORE_REL32(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_4(*p);\n    new_value = old_value & d;\n  }\n  return old_value;\n}\n\n#if KMP_ARCH_X86\nkmp_int8 __kmp_test_then_add8(volatile kmp_int8 *p, kmp_int8 d) {\n  kmp_int8 old_value, new_value;\n\n  old_value = TCR_1(*p);\n  new_value = old_value + d;\n\n  while (!KMP_COMPARE_AND_STORE_REL8(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_1(*p);\n    new_value = old_value + d;\n  }\n  return old_value;\n}\n\nkmp_int64 __kmp_test_then_add64(volatile kmp_int64 *p, kmp_int64 d) {\n  kmp_int64 old_value, new_value;\n\n  old_value = TCR_8(*p);\n  new_value = old_value + d;\n\n  while (!KMP_COMPARE_AND_STORE_REL64(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_8(*p);\n    new_value = old_value + d;\n  }\n  return old_value;\n}\n#endif /* KMP_ARCH_X86 */\n\nkmp_uint64 __kmp_test_then_or64(volatile kmp_uint64 *p, kmp_uint64 d) {\n  kmp_uint64 old_value, new_value;\n\n  old_value = TCR_8(*p);\n  new_value = old_value | d;\n  while (!KMP_COMPARE_AND_STORE_REL64(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_8(*p);\n    new_value = old_value | d;\n  }\n  return old_value;\n}\n\nkmp_uint64 __kmp_test_then_and64(volatile kmp_uint64 *p, kmp_uint64 d) {\n  kmp_uint64 old_value, new_value;\n\n  old_value = TCR_8(*p);\n  new_value = old_value & d;\n  while (!KMP_COMPARE_AND_STORE_REL64(p, old_value, new_value)) {\n    KMP_CPU_PAUSE();\n    old_value = TCR_8(*p);\n    new_value = old_value & d;\n  }\n  return old_value;\n}\n\n#endif /* (KMP_ARCH_X86 || KMP_ARCH_X86_64) && (! KMP_ASM_INTRINS) */\n\nvoid __kmp_terminate_thread(int gtid) {\n  int status;\n  kmp_info_t *th = __kmp_threads[gtid];\n\n  if (!th)\n    return;\n\n#ifdef KMP_CANCEL_THREADS\n  KA_TRACE(10, (\"__kmp_terminate_thread: kill (%d)\\n\", gtid));\n  status = pthread_cancel(th->th.th_info.ds.ds_thread);\n  if (status != 0 && status != ESRCH) {\n    __kmp_fatal(KMP_MSG(CantTerminateWorkerThread), KMP_ERR(status),\n                __kmp_msg_null);\n  }\n#endif\n  __kmp_yield(TRUE);\n} //\n\n/* Set thread stack info according to values returned by pthread_getattr_np().\n   If values are unreasonable, assume call failed and use incremental stack\n   refinement method instead. Returns TRUE if the stack parameters could be\n   determined exactly, FALSE if incremental refinement is necessary. */\nstatic kmp_int32 __kmp_set_stack_info(int gtid, kmp_info_t *th) {\n  int stack_data;\n#if KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_NETBSD\n  /* Linux* OS only -- no pthread_getattr_np support on OS X* */\n  pthread_attr_t attr;\n  int status;\n  size_t size = 0;\n  void *addr = 0;\n\n  /* Always do incremental stack refinement for ubermaster threads since the\n     initial thread stack range can be reduced by sibling thread creation so\n     pthread_attr_getstack may cause thread gtid aliasing */\n  if (!KMP_UBER_GTID(gtid)) {\n\n    /* Fetch the real thread attributes */\n    status = pthread_attr_init(&attr);\n    KMP_CHECK_SYSFAIL(\"pthread_attr_init\", status);\n#if KMP_OS_FREEBSD || KMP_OS_NETBSD\n    status = pthread_attr_get_np(pthread_self(), &attr);\n    KMP_CHECK_SYSFAIL(\"pthread_attr_get_np\", status);\n#else\n    status = pthread_getattr_np(pthread_self(), &attr);\n    KMP_CHECK_SYSFAIL(\"pthread_getattr_np\", status);\n#endif\n    status = pthread_attr_getstack(&attr, &addr, &size);\n    KMP_CHECK_SYSFAIL(\"pthread_attr_getstack\", status);\n    KA_TRACE(60,\n             (\"__kmp_set_stack_info: T#%d pthread_attr_getstack returned size:\"\n              \" %lu, low addr: %p\\n\",\n              gtid, size, addr));\n    status = pthread_attr_destroy(&attr);\n    KMP_CHECK_SYSFAIL(\"pthread_attr_destroy\", status);\n  }\n\n  if (size != 0 && addr != 0) { // was stack parameter determination successful?\n    /* Store the correct base and size */\n    TCW_PTR(th->th.th_info.ds.ds_stackbase, (((char *)addr) + size));\n    TCW_PTR(th->th.th_info.ds.ds_stacksize, size);\n    TCW_4(th->th.th_info.ds.ds_stackgrow, FALSE);\n    return TRUE;\n  }\n#endif /* KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_NETBSD */\n  /* Use incremental refinement starting from initial conservative estimate */\n  TCW_PTR(th->th.th_info.ds.ds_stacksize, 0);\n  TCW_PTR(th->th.th_info.ds.ds_stackbase, &stack_data);\n  TCW_4(th->th.th_info.ds.ds_stackgrow, TRUE);\n  return FALSE;\n}\n\nstatic void *__kmp_launch_worker(void *thr) {\n  int status, old_type, old_state;\n#ifdef KMP_BLOCK_SIGNALS\n  sigset_t new_set, old_set;\n#endif /* KMP_BLOCK_SIGNALS */\n  void *exit_val;\n#if KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_NETBSD\n  void *volatile padding = 0;\n#endif\n  int gtid;\n\n  gtid = ((kmp_info_t *)thr)->th.th_info.ds.ds_gtid;\n  __kmp_gtid_set_specific(gtid);\n#ifdef KMP_TDATA_GTID\n  __kmp_gtid = gtid;\n#endif\n#if KMP_STATS_ENABLED\n  // set thread local index to point to thread-specific stats\n  __kmp_stats_thread_ptr = ((kmp_info_t *)thr)->th.th_stats;\n  KMP_START_EXPLICIT_TIMER(OMP_worker_thread_life);\n  KMP_SET_THREAD_STATE(IDLE);\n  KMP_INIT_PARTITIONED_TIMERS(OMP_idle);\n#endif\n\n#if USE_ITT_BUILD\n  __kmp_itt_thread_name(gtid);\n#endif /* USE_ITT_BUILD */\n\n#if KMP_AFFINITY_SUPPORTED\n  __kmp_affinity_set_init_mask(gtid, FALSE);\n#endif\n\n#ifdef KMP_CANCEL_THREADS\n  status = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &old_type);\n  KMP_CHECK_SYSFAIL(\"pthread_setcanceltype\", status);\n  // josh todo: isn't PTHREAD_CANCEL_ENABLE default for newly-created threads?\n  status = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &old_state);\n  KMP_CHECK_SYSFAIL(\"pthread_setcancelstate\", status);\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  // Set FP control regs to be a copy of the parallel initialization thread's.\n  __kmp_clear_x87_fpu_status_word();\n  __kmp_load_x87_fpu_control_word(&__kmp_init_x87_fpu_control_word);\n  __kmp_load_mxcsr(&__kmp_init_mxcsr);\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n#ifdef KMP_BLOCK_SIGNALS\n  status = sigfillset(&new_set);\n  KMP_CHECK_SYSFAIL_ERRNO(\"sigfillset\", status);\n  status = pthread_sigmask(SIG_BLOCK, &new_set, &old_set);\n  KMP_CHECK_SYSFAIL(\"pthread_sigmask\", status);\n#endif /* KMP_BLOCK_SIGNALS */\n\n#if KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_NETBSD\n  if (__kmp_stkoffset > 0 && gtid > 0) {\n    padding = KMP_ALLOCA(gtid * __kmp_stkoffset);\n  }\n#endif\n\n  KMP_MB();\n  __kmp_set_stack_info(gtid, (kmp_info_t *)thr);\n\n  __kmp_check_stack_overlap((kmp_info_t *)thr);\n\n  exit_val = __kmp_launch_thread((kmp_info_t *)thr);\n\n#ifdef KMP_BLOCK_SIGNALS\n  status = pthread_sigmask(SIG_SETMASK, &old_set, NULL);\n  KMP_CHECK_SYSFAIL(\"pthread_sigmask\", status);\n#endif /* KMP_BLOCK_SIGNALS */\n\n  return exit_val;\n}\n\n#if KMP_USE_MONITOR\n/* The monitor thread controls all of the threads in the complex */\n\nstatic void *__kmp_launch_monitor(void *thr) {\n  int status, old_type, old_state;\n#ifdef KMP_BLOCK_SIGNALS\n  sigset_t new_set;\n#endif /* KMP_BLOCK_SIGNALS */\n  struct timespec interval;\n  int yield_count;\n  int yield_cycles = 0;\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  KA_TRACE(10, (\"__kmp_launch_monitor: #1 launched\\n\"));\n\n  /* register us as the monitor thread */\n  __kmp_gtid_set_specific(KMP_GTID_MONITOR);\n#ifdef KMP_TDATA_GTID\n  __kmp_gtid = KMP_GTID_MONITOR;\n#endif\n\n  KMP_MB();\n\n#if USE_ITT_BUILD\n  // Instruct Intel(R) Threading Tools to ignore monitor thread.\n  __kmp_itt_thread_ignore();\n#endif /* USE_ITT_BUILD */\n\n  __kmp_set_stack_info(((kmp_info_t *)thr)->th.th_info.ds.ds_gtid,\n                       (kmp_info_t *)thr);\n\n  __kmp_check_stack_overlap((kmp_info_t *)thr);\n\n#ifdef KMP_CANCEL_THREADS\n  status = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &old_type);\n  KMP_CHECK_SYSFAIL(\"pthread_setcanceltype\", status);\n  // josh todo: isn't PTHREAD_CANCEL_ENABLE default for newly-created threads?\n  status = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &old_state);\n  KMP_CHECK_SYSFAIL(\"pthread_setcancelstate\", status);\n#endif\n\n#if KMP_REAL_TIME_FIX\n  // This is a potential fix which allows application with real-time scheduling\n  // policy work. However, decision about the fix is not made yet, so it is\n  // disabled by default.\n  { // Are program started with real-time scheduling policy?\n    int sched = sched_getscheduler(0);\n    if (sched == SCHED_FIFO || sched == SCHED_RR) {\n      // Yes, we are a part of real-time application. Try to increase the\n      // priority of the monitor.\n      struct sched_param param;\n      int max_priority = sched_get_priority_max(sched);\n      int rc;\n      KMP_WARNING(RealTimeSchedNotSupported);\n      sched_getparam(0, &param);\n      if (param.sched_priority < max_priority) {\n        param.sched_priority += 1;\n        rc = sched_setscheduler(0, sched, &param);\n        if (rc != 0) {\n          int error = errno;\n          kmp_msg_t err_code = KMP_ERR(error);\n          __kmp_msg(kmp_ms_warning, KMP_MSG(CantChangeMonitorPriority),\n                    err_code, KMP_MSG(MonitorWillStarve), __kmp_msg_null);\n          if (__kmp_generate_warnings == kmp_warnings_off) {\n            __kmp_str_free(&err_code.str);\n          }\n        }\n      } else {\n        // We cannot abort here, because number of CPUs may be enough for all\n        // the threads, including the monitor thread, so application could\n        // potentially work...\n        __kmp_msg(kmp_ms_warning, KMP_MSG(RunningAtMaxPriority),\n                  KMP_MSG(MonitorWillStarve), KMP_HNT(RunningAtMaxPriority),\n                  __kmp_msg_null);\n      }\n    }\n    // AC: free thread that waits for monitor started\n    TCW_4(__kmp_global.g.g_time.dt.t_value, 0);\n  }\n#endif // KMP_REAL_TIME_FIX\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  if (__kmp_monitor_wakeups == 1) {\n    interval.tv_sec = 1;\n    interval.tv_nsec = 0;\n  } else {\n    interval.tv_sec = 0;\n    interval.tv_nsec = (KMP_NSEC_PER_SEC / __kmp_monitor_wakeups);\n  }\n\n  KA_TRACE(10, (\"__kmp_launch_monitor: #2 monitor\\n\"));\n\n  if (__kmp_yield_cycle) {\n    __kmp_yielding_on = 0; /* Start out with yielding shut off */\n    yield_count = __kmp_yield_off_count;\n  } else {\n    __kmp_yielding_on = 1; /* Yielding is on permanently */\n  }\n\n  while (!TCR_4(__kmp_global.g.g_done)) {\n    struct timespec now;\n    struct timeval tval;\n\n    /*  This thread monitors the state of the system */\n\n    KA_TRACE(15, (\"__kmp_launch_monitor: update\\n\"));\n\n    status = gettimeofday(&tval, NULL);\n    KMP_CHECK_SYSFAIL_ERRNO(\"gettimeofday\", status);\n    TIMEVAL_TO_TIMESPEC(&tval, &now);\n\n    now.tv_sec += interval.tv_sec;\n    now.tv_nsec += interval.tv_nsec;\n\n    if (now.tv_nsec >= KMP_NSEC_PER_SEC) {\n      now.tv_sec += 1;\n      now.tv_nsec -= KMP_NSEC_PER_SEC;\n    }\n\n    status = pthread_mutex_lock(&__kmp_wait_mx.m_mutex);\n    KMP_CHECK_SYSFAIL(\"pthread_mutex_lock\", status);\n    // AC: the monitor should not fall asleep if g_done has been set\n    if (!TCR_4(__kmp_global.g.g_done)) { // check once more under mutex\n      status = pthread_cond_timedwait(&__kmp_wait_cv.c_cond,\n                                      &__kmp_wait_mx.m_mutex, &now);\n      if (status != 0) {\n        if (status != ETIMEDOUT && status != EINTR) {\n          KMP_SYSFAIL(\"pthread_cond_timedwait\", status);\n        }\n      }\n    }\n    status = pthread_mutex_unlock(&__kmp_wait_mx.m_mutex);\n    KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n\n    if (__kmp_yield_cycle) {\n      yield_cycles++;\n      if ((yield_cycles % yield_count) == 0) {\n        if (__kmp_yielding_on) {\n          __kmp_yielding_on = 0; /* Turn it off now */\n          yield_count = __kmp_yield_off_count;\n        } else {\n          __kmp_yielding_on = 1; /* Turn it on now */\n          yield_count = __kmp_yield_on_count;\n        }\n        yield_cycles = 0;\n      }\n    } else {\n      __kmp_yielding_on = 1;\n    }\n\n    TCW_4(__kmp_global.g.g_time.dt.t_value,\n          TCR_4(__kmp_global.g.g_time.dt.t_value) + 1);\n\n    KMP_MB(); /* Flush all pending memory write invalidates.  */\n  }\n\n  KA_TRACE(10, (\"__kmp_launch_monitor: #3 cleanup\\n\"));\n\n#ifdef KMP_BLOCK_SIGNALS\n  status = sigfillset(&new_set);\n  KMP_CHECK_SYSFAIL_ERRNO(\"sigfillset\", status);\n  status = pthread_sigmask(SIG_UNBLOCK, &new_set, NULL);\n  KMP_CHECK_SYSFAIL(\"pthread_sigmask\", status);\n#endif /* KMP_BLOCK_SIGNALS */\n\n  KA_TRACE(10, (\"__kmp_launch_monitor: #4 finished\\n\"));\n\n  if (__kmp_global.g.g_abort != 0) {\n    /* now we need to terminate the worker threads  */\n    /* the value of t_abort is the signal we caught */\n\n    int gtid;\n\n    KA_TRACE(10, (\"__kmp_launch_monitor: #5 terminate sig=%d\\n\",\n                  __kmp_global.g.g_abort));\n\n    /* terminate the OpenMP worker threads */\n    /* TODO this is not valid for sibling threads!!\n     * the uber master might not be 0 anymore.. */\n    for (gtid = 1; gtid < __kmp_threads_capacity; ++gtid)\n      __kmp_terminate_thread(gtid);\n\n    __kmp_cleanup();\n\n    KA_TRACE(10, (\"__kmp_launch_monitor: #6 raise sig=%d\\n\",\n                  __kmp_global.g.g_abort));\n\n    if (__kmp_global.g.g_abort > 0)\n      raise(__kmp_global.g.g_abort);\n  }\n\n  KA_TRACE(10, (\"__kmp_launch_monitor: #7 exit\\n\"));\n\n  return thr;\n}\n#endif // KMP_USE_MONITOR\n\nvoid __kmp_create_worker(int gtid, kmp_info_t *th, size_t stack_size) {\n  pthread_t handle;\n  pthread_attr_t thread_attr;\n  int status;\n\n  th->th.th_info.ds.ds_gtid = gtid;\n\n#if KMP_STATS_ENABLED\n  // sets up worker thread stats\n  __kmp_acquire_tas_lock(&__kmp_stats_lock, gtid);\n\n  // th->th.th_stats is used to transfer thread-specific stats-pointer to\n  // __kmp_launch_worker. So when thread is created (goes into\n  // __kmp_launch_worker) it will set its thread local pointer to\n  // th->th.th_stats\n  if (!KMP_UBER_GTID(gtid)) {\n    th->th.th_stats = __kmp_stats_list->push_back(gtid);\n  } else {\n    // For root threads, __kmp_stats_thread_ptr is set in __kmp_register_root(),\n    // so set the th->th.th_stats field to it.\n    th->th.th_stats = __kmp_stats_thread_ptr;\n  }\n  __kmp_release_tas_lock(&__kmp_stats_lock, gtid);\n\n#endif // KMP_STATS_ENABLED\n\n  if (KMP_UBER_GTID(gtid)) {\n    KA_TRACE(10, (\"__kmp_create_worker: uber thread (%d)\\n\", gtid));\n    th->th.th_info.ds.ds_thread = pthread_self();\n    __kmp_set_stack_info(gtid, th);\n    __kmp_check_stack_overlap(th);\n    return;\n  }\n\n  KA_TRACE(10, (\"__kmp_create_worker: try to create thread (%d)\\n\", gtid));\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n#ifdef KMP_THREAD_ATTR\n  status = pthread_attr_init(&thread_attr);\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(CantInitThreadAttrs), KMP_ERR(status), __kmp_msg_null);\n  }\n  status = pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(CantSetWorkerState), KMP_ERR(status), __kmp_msg_null);\n  }\n\n  /* Set stack size for this thread now.\n     The multiple of 2 is there because on some machines, requesting an unusual\n     stacksize causes the thread to have an offset before the dummy alloca()\n     takes place to create the offset.  Since we want the user to have a\n     sufficient stacksize AND support a stack offset, we alloca() twice the\n     offset so that the upcoming alloca() does not eliminate any premade offset,\n     and also gives the user the stack space they requested for all threads */\n  stack_size += gtid * __kmp_stkoffset * 2;\n\n  KA_TRACE(10, (\"__kmp_create_worker: T#%d, default stacksize = %lu bytes, \"\n                \"__kmp_stksize = %lu bytes, final stacksize = %lu bytes\\n\",\n                gtid, KMP_DEFAULT_STKSIZE, __kmp_stksize, stack_size));\n\n#ifdef _POSIX_THREAD_ATTR_STACKSIZE\n  status = pthread_attr_setstacksize(&thread_attr, stack_size);\n#ifdef KMP_BACKUP_STKSIZE\n  if (status != 0) {\n    if (!__kmp_env_stksize) {\n      stack_size = KMP_BACKUP_STKSIZE + gtid * __kmp_stkoffset;\n      __kmp_stksize = KMP_BACKUP_STKSIZE;\n      KA_TRACE(10, (\"__kmp_create_worker: T#%d, default stacksize = %lu bytes, \"\n                    \"__kmp_stksize = %lu bytes, (backup) final stacksize = %lu \"\n                    \"bytes\\n\",\n                    gtid, KMP_DEFAULT_STKSIZE, __kmp_stksize, stack_size));\n      status = pthread_attr_setstacksize(&thread_attr, stack_size);\n    }\n  }\n#endif /* KMP_BACKUP_STKSIZE */\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(CantSetWorkerStackSize, stack_size), KMP_ERR(status),\n                KMP_HNT(ChangeWorkerStackSize), __kmp_msg_null);\n  }\n#endif /* _POSIX_THREAD_ATTR_STACKSIZE */\n\n#endif /* KMP_THREAD_ATTR */\n\n  status =\n      pthread_create(&handle, &thread_attr, __kmp_launch_worker, (void *)th);\n  if (status != 0 || !handle) { // ??? Why do we check handle??\n#ifdef _POSIX_THREAD_ATTR_STACKSIZE\n    if (status == EINVAL) {\n      __kmp_fatal(KMP_MSG(CantSetWorkerStackSize, stack_size), KMP_ERR(status),\n                  KMP_HNT(IncreaseWorkerStackSize), __kmp_msg_null);\n    }\n    if (status == ENOMEM) {\n      __kmp_fatal(KMP_MSG(CantSetWorkerStackSize, stack_size), KMP_ERR(status),\n                  KMP_HNT(DecreaseWorkerStackSize), __kmp_msg_null);\n    }\n#endif /* _POSIX_THREAD_ATTR_STACKSIZE */\n    if (status == EAGAIN) {\n      __kmp_fatal(KMP_MSG(NoResourcesForWorkerThread), KMP_ERR(status),\n                  KMP_HNT(Decrease_NUM_THREADS), __kmp_msg_null);\n    }\n    KMP_SYSFAIL(\"pthread_create\", status);\n  }\n\n  th->th.th_info.ds.ds_thread = handle;\n\n#ifdef KMP_THREAD_ATTR\n  status = pthread_attr_destroy(&thread_attr);\n  if (status) {\n    kmp_msg_t err_code = KMP_ERR(status);\n    __kmp_msg(kmp_ms_warning, KMP_MSG(CantDestroyThreadAttrs), err_code,\n              __kmp_msg_null);\n    if (__kmp_generate_warnings == kmp_warnings_off) {\n      __kmp_str_free(&err_code.str);\n    }\n  }\n#endif /* KMP_THREAD_ATTR */\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  KA_TRACE(10, (\"__kmp_create_worker: done creating thread (%d)\\n\", gtid));\n\n} // __kmp_create_worker\n\n#if KMP_USE_MONITOR\nvoid __kmp_create_monitor(kmp_info_t *th) {\n  pthread_t handle;\n  pthread_attr_t thread_attr;\n  size_t size;\n  int status;\n  int auto_adj_size = FALSE;\n\n  if (__kmp_dflt_blocktime == KMP_MAX_BLOCKTIME) {\n    // We don't need monitor thread in case of MAX_BLOCKTIME\n    KA_TRACE(10, (\"__kmp_create_monitor: skipping monitor thread because of \"\n                  \"MAX blocktime\\n\"));\n    th->th.th_info.ds.ds_tid = 0; // this makes reap_monitor no-op\n    th->th.th_info.ds.ds_gtid = 0;\n    return;\n  }\n  KA_TRACE(10, (\"__kmp_create_monitor: try to create monitor\\n\"));\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  th->th.th_info.ds.ds_tid = KMP_GTID_MONITOR;\n  th->th.th_info.ds.ds_gtid = KMP_GTID_MONITOR;\n#if KMP_REAL_TIME_FIX\n  TCW_4(__kmp_global.g.g_time.dt.t_value,\n        -1); // Will use it for synchronization a bit later.\n#else\n  TCW_4(__kmp_global.g.g_time.dt.t_value, 0);\n#endif // KMP_REAL_TIME_FIX\n\n#ifdef KMP_THREAD_ATTR\n  if (__kmp_monitor_stksize == 0) {\n    __kmp_monitor_stksize = KMP_DEFAULT_MONITOR_STKSIZE;\n    auto_adj_size = TRUE;\n  }\n  status = pthread_attr_init(&thread_attr);\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(CantInitThreadAttrs), KMP_ERR(status), __kmp_msg_null);\n  }\n  status = pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(CantSetMonitorState), KMP_ERR(status), __kmp_msg_null);\n  }\n\n#ifdef _POSIX_THREAD_ATTR_STACKSIZE\n  status = pthread_attr_getstacksize(&thread_attr, &size);\n  KMP_CHECK_SYSFAIL(\"pthread_attr_getstacksize\", status);\n#else\n  size = __kmp_sys_min_stksize;\n#endif /* _POSIX_THREAD_ATTR_STACKSIZE */\n#endif /* KMP_THREAD_ATTR */\n\n  if (__kmp_monitor_stksize == 0) {\n    __kmp_monitor_stksize = KMP_DEFAULT_MONITOR_STKSIZE;\n  }\n  if (__kmp_monitor_stksize < __kmp_sys_min_stksize) {\n    __kmp_monitor_stksize = __kmp_sys_min_stksize;\n  }\n\n  KA_TRACE(10, (\"__kmp_create_monitor: default stacksize = %lu bytes,\"\n                \"requested stacksize = %lu bytes\\n\",\n                size, __kmp_monitor_stksize));\n\nretry:\n\n/* Set stack size for this thread now. */\n#ifdef _POSIX_THREAD_ATTR_STACKSIZE\n  KA_TRACE(10, (\"__kmp_create_monitor: setting stacksize = %lu bytes,\",\n                __kmp_monitor_stksize));\n  status = pthread_attr_setstacksize(&thread_attr, __kmp_monitor_stksize);\n  if (status != 0) {\n    if (auto_adj_size) {\n      __kmp_monitor_stksize *= 2;\n      goto retry;\n    }\n    kmp_msg_t err_code = KMP_ERR(status);\n    __kmp_msg(kmp_ms_warning, // should this be fatal?  BB\n              KMP_MSG(CantSetMonitorStackSize, (long int)__kmp_monitor_stksize),\n              err_code, KMP_HNT(ChangeMonitorStackSize), __kmp_msg_null);\n    if (__kmp_generate_warnings == kmp_warnings_off) {\n      __kmp_str_free(&err_code.str);\n    }\n  }\n#endif /* _POSIX_THREAD_ATTR_STACKSIZE */\n\n  status =\n      pthread_create(&handle, &thread_attr, __kmp_launch_monitor, (void *)th);\n\n  if (status != 0) {\n#ifdef _POSIX_THREAD_ATTR_STACKSIZE\n    if (status == EINVAL) {\n      if (auto_adj_size && (__kmp_monitor_stksize < (size_t)0x40000000)) {\n        __kmp_monitor_stksize *= 2;\n        goto retry;\n      }\n      __kmp_fatal(KMP_MSG(CantSetMonitorStackSize, __kmp_monitor_stksize),\n                  KMP_ERR(status), KMP_HNT(IncreaseMonitorStackSize),\n                  __kmp_msg_null);\n    }\n    if (status == ENOMEM) {\n      __kmp_fatal(KMP_MSG(CantSetMonitorStackSize, __kmp_monitor_stksize),\n                  KMP_ERR(status), KMP_HNT(DecreaseMonitorStackSize),\n                  __kmp_msg_null);\n    }\n#endif /* _POSIX_THREAD_ATTR_STACKSIZE */\n    if (status == EAGAIN) {\n      __kmp_fatal(KMP_MSG(NoResourcesForMonitorThread), KMP_ERR(status),\n                  KMP_HNT(DecreaseNumberOfThreadsInUse), __kmp_msg_null);\n    }\n    KMP_SYSFAIL(\"pthread_create\", status);\n  }\n\n  th->th.th_info.ds.ds_thread = handle;\n\n#if KMP_REAL_TIME_FIX\n  // Wait for the monitor thread is really started and set its *priority*.\n  KMP_DEBUG_ASSERT(sizeof(kmp_uint32) ==\n                   sizeof(__kmp_global.g.g_time.dt.t_value));\n  __kmp_wait_yield_4((kmp_uint32 volatile *)&__kmp_global.g.g_time.dt.t_value,\n                     -1, &__kmp_neq_4, NULL);\n#endif // KMP_REAL_TIME_FIX\n\n#ifdef KMP_THREAD_ATTR\n  status = pthread_attr_destroy(&thread_attr);\n  if (status != 0) {\n    kmp_msg_t err_code = KMP_ERR(status);\n    __kmp_msg(kmp_ms_warning, KMP_MSG(CantDestroyThreadAttrs), err_code,\n              __kmp_msg_null);\n    if (__kmp_generate_warnings == kmp_warnings_off) {\n      __kmp_str_free(&err_code.str);\n    }\n  }\n#endif\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  KA_TRACE(10, (\"__kmp_create_monitor: monitor created %#.8lx\\n\",\n                th->th.th_info.ds.ds_thread));\n\n} // __kmp_create_monitor\n#endif // KMP_USE_MONITOR\n\nvoid __kmp_exit_thread(int exit_status) {\n  pthread_exit((void *)(intptr_t)exit_status);\n} // __kmp_exit_thread\n\n#if KMP_USE_MONITOR\nvoid __kmp_resume_monitor();\n\nvoid __kmp_reap_monitor(kmp_info_t *th) {\n  int status;\n  void *exit_val;\n\n  KA_TRACE(10, (\"__kmp_reap_monitor: try to reap monitor thread with handle\"\n                \" %#.8lx\\n\",\n                th->th.th_info.ds.ds_thread));\n\n  // If monitor has been created, its tid and gtid should be KMP_GTID_MONITOR.\n  // If both tid and gtid are 0, it means the monitor did not ever start.\n  // If both tid and gtid are KMP_GTID_DNE, the monitor has been shut down.\n  KMP_DEBUG_ASSERT(th->th.th_info.ds.ds_tid == th->th.th_info.ds.ds_gtid);\n  if (th->th.th_info.ds.ds_gtid != KMP_GTID_MONITOR) {\n    KA_TRACE(10, (\"__kmp_reap_monitor: monitor did not start, returning\\n\"));\n    return;\n  }\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  /* First, check to see whether the monitor thread exists to wake it up. This\n     is to avoid performance problem when the monitor sleeps during\n     blocktime-size interval */\n\n  status = pthread_kill(th->th.th_info.ds.ds_thread, 0);\n  if (status != ESRCH) {\n    __kmp_resume_monitor(); // Wake up the monitor thread\n  }\n  KA_TRACE(10, (\"__kmp_reap_monitor: try to join with monitor\\n\"));\n  status = pthread_join(th->th.th_info.ds.ds_thread, &exit_val);\n  if (exit_val != th) {\n    __kmp_fatal(KMP_MSG(ReapMonitorError), KMP_ERR(status), __kmp_msg_null);\n  }\n\n  th->th.th_info.ds.ds_tid = KMP_GTID_DNE;\n  th->th.th_info.ds.ds_gtid = KMP_GTID_DNE;\n\n  KA_TRACE(10, (\"__kmp_reap_monitor: done reaping monitor thread with handle\"\n                \" %#.8lx\\n\",\n                th->th.th_info.ds.ds_thread));\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n}\n#endif // KMP_USE_MONITOR\n\nvoid __kmp_reap_worker(kmp_info_t *th) {\n  int status;\n  void *exit_val;\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  KA_TRACE(\n      10, (\"__kmp_reap_worker: try to reap T#%d\\n\", th->th.th_info.ds.ds_gtid));\n\n  status = pthread_join(th->th.th_info.ds.ds_thread, &exit_val);\n#ifdef KMP_DEBUG\n  /* Don't expose these to the user until we understand when they trigger */\n  if (status != 0) {\n    __kmp_fatal(KMP_MSG(ReapWorkerError), KMP_ERR(status), __kmp_msg_null);\n  }\n  if (exit_val != th) {\n    KA_TRACE(10, (\"__kmp_reap_worker: worker T#%d did not reap properly, \"\n                  \"exit_val = %p\\n\",\n                  th->th.th_info.ds.ds_gtid, exit_val));\n  }\n#endif /* KMP_DEBUG */\n\n  KA_TRACE(10, (\"__kmp_reap_worker: done reaping T#%d\\n\",\n                th->th.th_info.ds.ds_gtid));\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n}\n\n#if KMP_HANDLE_SIGNALS\n\nstatic void __kmp_null_handler(int signo) {\n  //  Do nothing, for doing SIG_IGN-type actions.\n} // __kmp_null_handler\n\nstatic void __kmp_team_handler(int signo) {\n  if (__kmp_global.g.g_abort == 0) {\n/* Stage 1 signal handler, let's shut down all of the threads */\n#ifdef KMP_DEBUG\n    __kmp_debug_printf(\"__kmp_team_handler: caught signal = %d\\n\", signo);\n#endif\n    switch (signo) {\n    case SIGHUP:\n    case SIGINT:\n    case SIGQUIT:\n    case SIGILL:\n    case SIGABRT:\n    case SIGFPE:\n    case SIGBUS:\n    case SIGSEGV:\n#ifdef SIGSYS\n    case SIGSYS:\n#endif\n    case SIGTERM:\n      if (__kmp_debug_buf) {\n        __kmp_dump_debug_buffer();\n      }\n      KMP_MB(); // Flush all pending memory write invalidates.\n      TCW_4(__kmp_global.g.g_abort, signo);\n      KMP_MB(); // Flush all pending memory write invalidates.\n      TCW_4(__kmp_global.g.g_done, TRUE);\n      KMP_MB(); // Flush all pending memory write invalidates.\n      break;\n    default:\n#ifdef KMP_DEBUG\n      __kmp_debug_printf(\"__kmp_team_handler: unknown signal type\");\n#endif\n      break;\n    }\n  }\n} // __kmp_team_handler\n\nstatic void __kmp_sigaction(int signum, const struct sigaction *act,\n                            struct sigaction *oldact) {\n  int rc = sigaction(signum, act, oldact);\n  KMP_CHECK_SYSFAIL_ERRNO(\"sigaction\", rc);\n}\n\nstatic void __kmp_install_one_handler(int sig, sig_func_t handler_func,\n                                      int parallel_init) {\n  KMP_MB(); // Flush all pending memory write invalidates.\n  KB_TRACE(60,\n           (\"__kmp_install_one_handler( %d, ..., %d )\\n\", sig, parallel_init));\n  if (parallel_init) {\n    struct sigaction new_action;\n    struct sigaction old_action;\n    new_action.sa_handler = handler_func;\n    new_action.sa_flags = 0;\n    sigfillset(&new_action.sa_mask);\n    __kmp_sigaction(sig, &new_action, &old_action);\n    if (old_action.sa_handler == __kmp_sighldrs[sig].sa_handler) {\n      sigaddset(&__kmp_sigset, sig);\n    } else {\n      // Restore/keep user's handler if one previously installed.\n      __kmp_sigaction(sig, &old_action, NULL);\n    }\n  } else {\n    // Save initial/system signal handlers to see if user handlers installed.\n    __kmp_sigaction(sig, NULL, &__kmp_sighldrs[sig]);\n  }\n  KMP_MB(); // Flush all pending memory write invalidates.\n} // __kmp_install_one_handler\n\nstatic void __kmp_remove_one_handler(int sig) {\n  KB_TRACE(60, (\"__kmp_remove_one_handler( %d )\\n\", sig));\n  if (sigismember(&__kmp_sigset, sig)) {\n    struct sigaction old;\n    KMP_MB(); // Flush all pending memory write invalidates.\n    __kmp_sigaction(sig, &__kmp_sighldrs[sig], &old);\n    if ((old.sa_handler != __kmp_team_handler) &&\n        (old.sa_handler != __kmp_null_handler)) {\n      // Restore the users signal handler.\n      KB_TRACE(10, (\"__kmp_remove_one_handler: oops, not our handler, \"\n                    \"restoring: sig=%d\\n\",\n                    sig));\n      __kmp_sigaction(sig, &old, NULL);\n    }\n    sigdelset(&__kmp_sigset, sig);\n    KMP_MB(); // Flush all pending memory write invalidates.\n  }\n} // __kmp_remove_one_handler\n\nvoid __kmp_install_signals(int parallel_init) {\n  KB_TRACE(10, (\"__kmp_install_signals( %d )\\n\", parallel_init));\n  if (__kmp_handle_signals || !parallel_init) {\n    // If ! parallel_init, we do not install handlers, just save original\n    // handlers. Let us do it even __handle_signals is 0.\n    sigemptyset(&__kmp_sigset);\n    __kmp_install_one_handler(SIGHUP, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGINT, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGQUIT, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGILL, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGABRT, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGFPE, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGBUS, __kmp_team_handler, parallel_init);\n    __kmp_install_one_handler(SIGSEGV, __kmp_team_handler, parallel_init);\n#ifdef SIGSYS\n    __kmp_install_one_handler(SIGSYS, __kmp_team_handler, parallel_init);\n#endif // SIGSYS\n    __kmp_install_one_handler(SIGTERM, __kmp_team_handler, parallel_init);\n#ifdef SIGPIPE\n    __kmp_install_one_handler(SIGPIPE, __kmp_team_handler, parallel_init);\n#endif // SIGPIPE\n  }\n} // __kmp_install_signals\n\nvoid __kmp_remove_signals(void) {\n  int sig;\n  KB_TRACE(10, (\"__kmp_remove_signals()\\n\"));\n  for (sig = 1; sig < NSIG; ++sig) {\n    __kmp_remove_one_handler(sig);\n  }\n} // __kmp_remove_signals\n\n#endif // KMP_HANDLE_SIGNALS\n\nvoid __kmp_enable(int new_state) {\n#ifdef KMP_CANCEL_THREADS\n  int status, old_state;\n  status = pthread_setcancelstate(new_state, &old_state);\n  KMP_CHECK_SYSFAIL(\"pthread_setcancelstate\", status);\n  KMP_DEBUG_ASSERT(old_state == PTHREAD_CANCEL_DISABLE);\n#endif\n}\n\nvoid __kmp_disable(int *old_state) {\n#ifdef KMP_CANCEL_THREADS\n  int status;\n  status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, old_state);\n  KMP_CHECK_SYSFAIL(\"pthread_setcancelstate\", status);\n#endif\n}\n\nstatic void __kmp_atfork_prepare(void) {\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n}\n\nstatic void __kmp_atfork_parent(void) {\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n}\n\n/* Reset the library so execution in the child starts \"all over again\" with\n   clean data structures in initial states.  Don't worry about freeing memory\n   allocated by parent, just abandon it to be safe. */\nstatic void __kmp_atfork_child(void) {\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n  /* TODO make sure this is done right for nested/sibling */\n  // ATT:  Memory leaks are here? TODO: Check it and fix.\n  /* KMP_ASSERT( 0 ); */\n\n  ++__kmp_fork_count;\n\n#if KMP_AFFINITY_SUPPORTED\n#if KMP_OS_LINUX\n  // reset the affinity in the child to the initial thread\n  // affinity in the parent\n  kmp_set_thread_affinity_mask_initial();\n#endif\n  // Set default not to bind threads tightly in the child (we\u2019re expecting\n  // over-subscription after the fork and this can improve things for\n  // scripting languages that use OpenMP inside process-parallel code).\n  __kmp_affinity_type = affinity_none;\n#if OMP_40_ENABLED\n  if (__kmp_nested_proc_bind.bind_types != NULL) {\n    __kmp_nested_proc_bind.bind_types[0] = proc_bind_false;\n  }\n#endif // OMP_40_ENABLED\n#endif // KMP_AFFINITY_SUPPORTED\n\n  __kmp_init_runtime = FALSE;\n#if KMP_USE_MONITOR\n  __kmp_init_monitor = 0;\n#endif\n  __kmp_init_parallel = FALSE;\n  __kmp_init_middle = FALSE;\n  __kmp_init_serial = FALSE;\n  TCW_4(__kmp_init_gtid, FALSE);\n  __kmp_init_common = FALSE;\n\n  TCW_4(__kmp_init_user_locks, FALSE);\n#if !KMP_USE_DYNAMIC_LOCK\n  __kmp_user_lock_table.used = 1;\n  __kmp_user_lock_table.allocated = 0;\n  __kmp_user_lock_table.table = NULL;\n  __kmp_lock_blocks = NULL;\n#endif\n\n  __kmp_all_nth = 0;\n  TCW_4(__kmp_nth, 0);\n\n  __kmp_thread_pool = NULL;\n  __kmp_thread_pool_insert_pt = NULL;\n  __kmp_team_pool = NULL;\n\n  /* Must actually zero all the *cache arguments passed to __kmpc_threadprivate\n     here so threadprivate doesn't use stale data */\n  KA_TRACE(10, (\"__kmp_atfork_child: checking cache address list %p\\n\",\n                __kmp_threadpriv_cache_list));\n\n  while (__kmp_threadpriv_cache_list != NULL) {\n\n    if (*__kmp_threadpriv_cache_list->addr != NULL) {\n      KC_TRACE(50, (\"__kmp_atfork_child: zeroing cache at address %p\\n\",\n                    &(*__kmp_threadpriv_cache_list->addr)));\n\n      *__kmp_threadpriv_cache_list->addr = NULL;\n    }\n    __kmp_threadpriv_cache_list = __kmp_threadpriv_cache_list->next;\n  }\n\n  __kmp_init_runtime = FALSE;\n\n  /* reset statically initialized locks */\n  __kmp_init_bootstrap_lock(&__kmp_initz_lock);\n  __kmp_init_bootstrap_lock(&__kmp_stdio_lock);\n  __kmp_init_bootstrap_lock(&__kmp_console_lock);\n  __kmp_init_bootstrap_lock(&__kmp_task_team_lock);\n\n#if USE_ITT_BUILD\n  __kmp_itt_reset(); // reset ITT's global state\n#endif /* USE_ITT_BUILD */\n\n  /* This is necessary to make sure no stale data is left around */\n  /* AC: customers complain that we use unsafe routines in the atfork\n     handler. Mathworks: dlsym() is unsafe. We call dlsym and dlopen\n     in dynamic_link when check the presence of shared tbbmalloc library.\n     Suggestion is to make the library initialization lazier, similar\n     to what done for __kmpc_begin(). */\n  // TODO: synchronize all static initializations with regular library\n  //       startup; look at kmp_global.cpp and etc.\n  //__kmp_internal_begin ();\n}\n\nvoid __kmp_register_atfork(void) {\n  if (__kmp_need_register_atfork) {\n    int status = pthread_atfork(__kmp_atfork_prepare, __kmp_atfork_parent,\n                                __kmp_atfork_child);\n    KMP_CHECK_SYSFAIL(\"pthread_atfork\", status);\n    __kmp_need_register_atfork = FALSE;\n  }\n}\n\nvoid __kmp_suspend_initialize(void) {\n  int status;\n  status = pthread_mutexattr_init(&__kmp_suspend_mutex_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_mutexattr_init\", status);\n  status = pthread_condattr_init(&__kmp_suspend_cond_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_condattr_init\", status);\n}\n\nstatic void __kmp_suspend_initialize_thread(kmp_info_t *th) {\n  ANNOTATE_HAPPENS_AFTER(&th->th.th_suspend_init_count);\n  if (th->th.th_suspend_init_count <= __kmp_fork_count) {\n    /* this means we haven't initialized the suspension pthread objects for this\n       thread in this instance of the process */\n    int status;\n    status = pthread_cond_init(&th->th.th_suspend_cv.c_cond,\n                               &__kmp_suspend_cond_attr);\n    KMP_CHECK_SYSFAIL(\"pthread_cond_init\", status);\n    status = pthread_mutex_init(&th->th.th_suspend_mx.m_mutex,\n                                &__kmp_suspend_mutex_attr);\n    KMP_CHECK_SYSFAIL(\"pthread_mutex_init\", status);\n    *(volatile int *)&th->th.th_suspend_init_count = __kmp_fork_count + 1;\n    ANNOTATE_HAPPENS_BEFORE(&th->th.th_suspend_init_count);\n  }\n}\n\nvoid __kmp_suspend_uninitialize_thread(kmp_info_t *th) {\n  if (th->th.th_suspend_init_count > __kmp_fork_count) {\n    /* this means we have initialize the suspension pthread objects for this\n       thread in this instance of the process */\n    int status;\n\n    status = pthread_cond_destroy(&th->th.th_suspend_cv.c_cond);\n    if (status != 0 && status != EBUSY) {\n      KMP_SYSFAIL(\"pthread_cond_destroy\", status);\n    }\n    status = pthread_mutex_destroy(&th->th.th_suspend_mx.m_mutex);\n    if (status != 0 && status != EBUSY) {\n      KMP_SYSFAIL(\"pthread_mutex_destroy\", status);\n    }\n    --th->th.th_suspend_init_count;\n    KMP_DEBUG_ASSERT(th->th.th_suspend_init_count == __kmp_fork_count);\n  }\n}\n\n/* This routine puts the calling thread to sleep after setting the\n   sleep bit for the indicated flag variable to true. */\ntemplate <class C>\nstatic inline void __kmp_suspend_template(int th_gtid, C *flag) {\n  KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(USER_suspend);\n  kmp_info_t *th = __kmp_threads[th_gtid];\n  int status;\n  typename C::flag_t old_spin;\n\n  KF_TRACE(30, (\"__kmp_suspend_template: T#%d enter for flag = %p\\n\", th_gtid,\n                flag->get()));\n\n  __kmp_suspend_initialize_thread(th);\n\n  status = pthread_mutex_lock(&th->th.th_suspend_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_lock\", status);\n\n  KF_TRACE(10, (\"__kmp_suspend_template: T#%d setting sleep bit for spin(%p)\\n\",\n                th_gtid, flag->get()));\n\n  /* TODO: shouldn't this use release semantics to ensure that\n     __kmp_suspend_initialize_thread gets called first? */\n  old_spin = flag->set_sleeping();\n\n  KF_TRACE(5, (\"__kmp_suspend_template: T#%d set sleep bit for spin(%p)==%x,\"\n               \" was %x\\n\",\n               th_gtid, flag->get(), flag->load(), old_spin));\n\n  if (flag->done_check_val(old_spin)) {\n    old_spin = flag->unset_sleeping();\n    KF_TRACE(5, (\"__kmp_suspend_template: T#%d false alarm, reset sleep bit \"\n                 \"for spin(%p)\\n\",\n                 th_gtid, flag->get()));\n  } else {\n    /* Encapsulate in a loop as the documentation states that this may\n       \"with low probability\" return when the condition variable has\n       not been signaled or broadcast */\n    int deactivated = FALSE;\n    TCW_PTR(th->th.th_sleep_loc, (void *)flag);\n\n    while (flag->is_sleeping()) {\n#ifdef DEBUG_SUSPEND\n      char buffer[128];\n      __kmp_suspend_count++;\n      __kmp_print_cond(buffer, &th->th.th_suspend_cv);\n      __kmp_printf(\"__kmp_suspend_template: suspending T#%d: %s\\n\", th_gtid,\n                   buffer);\n#endif\n      // Mark the thread as no longer active (only in the first iteration of the\n      // loop).\n      if (!deactivated) {\n        th->th.th_active = FALSE;\n        if (th->th.th_active_in_pool) {\n          th->th.th_active_in_pool = FALSE;\n          KMP_ATOMIC_DEC(&__kmp_thread_pool_active_nth);\n          KMP_DEBUG_ASSERT(TCR_4(__kmp_thread_pool_active_nth) >= 0);\n        }\n        deactivated = TRUE;\n      }\n\n#if USE_SUSPEND_TIMEOUT\n      struct timespec now;\n      struct timeval tval;\n      int msecs;\n\n      status = gettimeofday(&tval, NULL);\n      KMP_CHECK_SYSFAIL_ERRNO(\"gettimeofday\", status);\n      TIMEVAL_TO_TIMESPEC(&tval, &now);\n\n      msecs = (4 * __kmp_dflt_blocktime) + 200;\n      now.tv_sec += msecs / 1000;\n      now.tv_nsec += (msecs % 1000) * 1000;\n\n      KF_TRACE(15, (\"__kmp_suspend_template: T#%d about to perform \"\n                    \"pthread_cond_timedwait\\n\",\n                    th_gtid));\n      status = pthread_cond_timedwait(&th->th.th_suspend_cv.c_cond,\n                                      &th->th.th_suspend_mx.m_mutex, &now);\n#else\n      KF_TRACE(15, (\"__kmp_suspend_template: T#%d about to perform\"\n                    \" pthread_cond_wait\\n\",\n                    th_gtid));\n      status = pthread_cond_wait(&th->th.th_suspend_cv.c_cond,\n                                 &th->th.th_suspend_mx.m_mutex);\n#endif\n\n      if ((status != 0) && (status != EINTR) && (status != ETIMEDOUT)) {\n        KMP_SYSFAIL(\"pthread_cond_wait\", status);\n      }\n#ifdef KMP_DEBUG\n      if (status == ETIMEDOUT) {\n        if (flag->is_sleeping()) {\n          KF_TRACE(100,\n                   (\"__kmp_suspend_template: T#%d timeout wakeup\\n\", th_gtid));\n        } else {\n          KF_TRACE(2, (\"__kmp_suspend_template: T#%d timeout wakeup, sleep bit \"\n                       \"not set!\\n\",\n                       th_gtid));\n        }\n      } else if (flag->is_sleeping()) {\n        KF_TRACE(100,\n                 (\"__kmp_suspend_template: T#%d spurious wakeup\\n\", th_gtid));\n      }\n#endif\n    } // while\n\n    // Mark the thread as active again (if it was previous marked as inactive)\n    if (deactivated) {\n      th->th.th_active = TRUE;\n      if (TCR_4(th->th.th_in_pool)) {\n        KMP_ATOMIC_INC(&__kmp_thread_pool_active_nth);\n        th->th.th_active_in_pool = TRUE;\n      }\n    }\n  }\n#ifdef DEBUG_SUSPEND\n  {\n    char buffer[128];\n    __kmp_print_cond(buffer, &th->th.th_suspend_cv);\n    __kmp_printf(\"__kmp_suspend_template: T#%d has awakened: %s\\n\", th_gtid,\n                 buffer);\n  }\n#endif\n\n  status = pthread_mutex_unlock(&th->th.th_suspend_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n  KF_TRACE(30, (\"__kmp_suspend_template: T#%d exit\\n\", th_gtid));\n}\n\nvoid __kmp_suspend_32(int th_gtid, kmp_flag_32 *flag) {\n  __kmp_suspend_template(th_gtid, flag);\n}\nvoid __kmp_suspend_64(int th_gtid, kmp_flag_64 *flag) {\n  __kmp_suspend_template(th_gtid, flag);\n}\nvoid __kmp_suspend_oncore(int th_gtid, kmp_flag_oncore *flag) {\n  __kmp_suspend_template(th_gtid, flag);\n}\n\n/* This routine signals the thread specified by target_gtid to wake up\n   after setting the sleep bit indicated by the flag argument to FALSE.\n   The target thread must already have called __kmp_suspend_template() */\ntemplate <class C>\nstatic inline void __kmp_resume_template(int target_gtid, C *flag) {\n  KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(USER_resume);\n  kmp_info_t *th = __kmp_threads[target_gtid];\n  int status;\n\n#ifdef KMP_DEBUG\n  int gtid = TCR_4(__kmp_init_gtid) ? __kmp_get_gtid() : -1;\n#endif\n\n  KF_TRACE(30, (\"__kmp_resume_template: T#%d wants to wakeup T#%d enter\\n\",\n                gtid, target_gtid));\n  KMP_DEBUG_ASSERT(gtid != target_gtid);\n\n  __kmp_suspend_initialize_thread(th);\n\n  status = pthread_mutex_lock(&th->th.th_suspend_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_lock\", status);\n\n  if (!flag) { // coming from __kmp_null_resume_wrapper\n    flag = (C *)CCAST(void *, th->th.th_sleep_loc);\n  }\n\n  // First, check if the flag is null or its type has changed. If so, someone\n  // else woke it up.\n  if (!flag || flag->get_type() != flag->get_ptr_type()) { // get_ptr_type\n    // simply shows what\n    // flag was cast to\n    KF_TRACE(5, (\"__kmp_resume_template: T#%d exiting, thread T#%d already \"\n                 \"awake: flag(%p)\\n\",\n                 gtid, target_gtid, NULL));\n    status = pthread_mutex_unlock(&th->th.th_suspend_mx.m_mutex);\n    KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n    return;\n  } else { // if multiple threads are sleeping, flag should be internally\n    // referring to a specific thread here\n    typename C::flag_t old_spin = flag->unset_sleeping();\n    if (!flag->is_sleeping_val(old_spin)) {\n      KF_TRACE(5, (\"__kmp_resume_template: T#%d exiting, thread T#%d already \"\n                   \"awake: flag(%p): \"\n                   \"%u => %u\\n\",\n                   gtid, target_gtid, flag->get(), old_spin, flag->load()));\n      status = pthread_mutex_unlock(&th->th.th_suspend_mx.m_mutex);\n      KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n      return;\n    }\n    KF_TRACE(5, (\"__kmp_resume_template: T#%d about to wakeup T#%d, reset \"\n                 \"sleep bit for flag's loc(%p): \"\n                 \"%u => %u\\n\",\n                 gtid, target_gtid, flag->get(), old_spin, flag->load()));\n  }\n  TCW_PTR(th->th.th_sleep_loc, NULL);\n\n#ifdef DEBUG_SUSPEND\n  {\n    char buffer[128];\n    __kmp_print_cond(buffer, &th->th.th_suspend_cv);\n    __kmp_printf(\"__kmp_resume_template: T#%d resuming T#%d: %s\\n\", gtid,\n                 target_gtid, buffer);\n  }\n#endif\n  status = pthread_cond_signal(&th->th.th_suspend_cv.c_cond);\n  KMP_CHECK_SYSFAIL(\"pthread_cond_signal\", status);\n  status = pthread_mutex_unlock(&th->th.th_suspend_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n  KF_TRACE(30, (\"__kmp_resume_template: T#%d exiting after signaling wake up\"\n                \" for T#%d\\n\",\n                gtid, target_gtid));\n}\n\nvoid __kmp_resume_32(int target_gtid, kmp_flag_32 *flag) {\n  __kmp_resume_template(target_gtid, flag);\n}\nvoid __kmp_resume_64(int target_gtid, kmp_flag_64 *flag) {\n  __kmp_resume_template(target_gtid, flag);\n}\nvoid __kmp_resume_oncore(int target_gtid, kmp_flag_oncore *flag) {\n  __kmp_resume_template(target_gtid, flag);\n}\n\n#if KMP_USE_MONITOR\nvoid __kmp_resume_monitor() {\n  KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(USER_resume);\n  int status;\n#ifdef KMP_DEBUG\n  int gtid = TCR_4(__kmp_init_gtid) ? __kmp_get_gtid() : -1;\n  KF_TRACE(30, (\"__kmp_resume_monitor: T#%d wants to wakeup T#%d enter\\n\", gtid,\n                KMP_GTID_MONITOR));\n  KMP_DEBUG_ASSERT(gtid != KMP_GTID_MONITOR);\n#endif\n  status = pthread_mutex_lock(&__kmp_wait_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_lock\", status);\n#ifdef DEBUG_SUSPEND\n  {\n    char buffer[128];\n    __kmp_print_cond(buffer, &__kmp_wait_cv.c_cond);\n    __kmp_printf(\"__kmp_resume_monitor: T#%d resuming T#%d: %s\\n\", gtid,\n                 KMP_GTID_MONITOR, buffer);\n  }\n#endif\n  status = pthread_cond_signal(&__kmp_wait_cv.c_cond);\n  KMP_CHECK_SYSFAIL(\"pthread_cond_signal\", status);\n  status = pthread_mutex_unlock(&__kmp_wait_mx.m_mutex);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_unlock\", status);\n  KF_TRACE(30, (\"__kmp_resume_monitor: T#%d exiting after signaling wake up\"\n                \" for T#%d\\n\",\n                gtid, KMP_GTID_MONITOR));\n}\n#endif // KMP_USE_MONITOR\n\nvoid __kmp_yield(int cond) {\n  if (!cond)\n    return;\n#if KMP_USE_MONITOR\n  if (!__kmp_yielding_on)\n    return;\n#else\n  if (__kmp_yield_cycle && !KMP_YIELD_NOW())\n    return;\n#endif\n  sched_yield();\n}\n\nvoid __kmp_gtid_set_specific(int gtid) {\n  if (__kmp_init_gtid) {\n    int status;\n    status = pthread_setspecific(__kmp_gtid_threadprivate_key,\n                                 (void *)(intptr_t)(gtid + 1));\n    KMP_CHECK_SYSFAIL(\"pthread_setspecific\", status);\n  } else {\n    KA_TRACE(50, (\"__kmp_gtid_set_specific: runtime shutdown, returning\\n\"));\n  }\n}\n\nint __kmp_gtid_get_specific() {\n  int gtid;\n  if (!__kmp_init_gtid) {\n    KA_TRACE(50, (\"__kmp_gtid_get_specific: runtime shutdown, returning \"\n                  \"KMP_GTID_SHUTDOWN\\n\"));\n    return KMP_GTID_SHUTDOWN;\n  }\n  gtid = (int)(size_t)pthread_getspecific(__kmp_gtid_threadprivate_key);\n  if (gtid == 0) {\n    gtid = KMP_GTID_DNE;\n  } else {\n    gtid--;\n  }\n  KA_TRACE(50, (\"__kmp_gtid_get_specific: key:%d gtid:%d\\n\",\n                __kmp_gtid_threadprivate_key, gtid));\n  return gtid;\n}\n\ndouble __kmp_read_cpu_time(void) {\n  /*clock_t   t;*/\n  struct tms buffer;\n\n  /*t =*/times(&buffer);\n\n  return (buffer.tms_utime + buffer.tms_cutime) / (double)CLOCKS_PER_SEC;\n}\n\nint __kmp_read_system_info(struct kmp_sys_info *info) {\n  int status;\n  struct rusage r_usage;\n\n  memset(info, 0, sizeof(*info));\n\n  status = getrusage(RUSAGE_SELF, &r_usage);\n  KMP_CHECK_SYSFAIL_ERRNO(\"getrusage\", status);\n\n  // The maximum resident set size utilized (in kilobytes)\n  info->maxrss = r_usage.ru_maxrss;\n  // The number of page faults serviced without any I/O\n  info->minflt = r_usage.ru_minflt;\n  // The number of page faults serviced that required I/O\n  info->majflt = r_usage.ru_majflt;\n  // The number of times a process was \"swapped\" out of memory\n  info->nswap = r_usage.ru_nswap;\n  // The number of times the file system had to perform input\n  info->inblock = r_usage.ru_inblock;\n  // The number of times the file system had to perform output\n  info->oublock = r_usage.ru_oublock;\n  // The number of times a context switch was voluntarily\n  info->nvcsw = r_usage.ru_nvcsw;\n  // The number of times a context switch was forced\n  info->nivcsw = r_usage.ru_nivcsw;\n\n  return (status != 0);\n}\n\nvoid __kmp_read_system_time(double *delta) {\n  double t_ns;\n  struct timeval tval;\n  struct timespec stop;\n  int status;\n\n  status = gettimeofday(&tval, NULL);\n  KMP_CHECK_SYSFAIL_ERRNO(\"gettimeofday\", status);\n  TIMEVAL_TO_TIMESPEC(&tval, &stop);\n  t_ns = TS2NS(stop) - TS2NS(__kmp_sys_timer_data.start);\n  *delta = (t_ns * 1e-9);\n}\n\nvoid __kmp_clear_system_time(void) {\n  struct timeval tval;\n  int status;\n  status = gettimeofday(&tval, NULL);\n  KMP_CHECK_SYSFAIL_ERRNO(\"gettimeofday\", status);\n  TIMEVAL_TO_TIMESPEC(&tval, &__kmp_sys_timer_data.start);\n}\n\nstatic int __kmp_get_xproc(void) {\n\n  int r = 0;\n\n#if KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_NETBSD\n\n  r = sysconf(_SC_NPROCESSORS_ONLN);\n\n#elif KMP_OS_DARWIN\n\n  // Bug C77011 High \"OpenMP Threads and number of active cores\".\n\n  // Find the number of available CPUs.\n  kern_return_t rc;\n  host_basic_info_data_t info;\n  mach_msg_type_number_t num = HOST_BASIC_INFO_COUNT;\n  rc = host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&info, &num);\n  if (rc == 0 && num == HOST_BASIC_INFO_COUNT) {\n    // Cannot use KA_TRACE() here because this code works before trace support\n    // is initialized.\n    r = info.avail_cpus;\n  } else {\n    KMP_WARNING(CantGetNumAvailCPU);\n    KMP_INFORM(AssumedNumCPU);\n  }\n\n#else\n\n#error \"Unknown or unsupported OS.\"\n\n#endif\n\n  return r > 0 ? r : 2; /* guess value of 2 if OS told us 0 */\n\n} // __kmp_get_xproc\n\nint __kmp_read_from_file(char const *path, char const *format, ...) {\n  int result;\n  va_list args;\n\n  va_start(args, format);\n  FILE *f = fopen(path, \"rb\");\n  if (f == NULL)\n    return 0;\n  result = vfscanf(f, format, args);\n  fclose(f);\n\n  return result;\n}\n\nvoid __kmp_runtime_initialize(void) {\n  int status;\n  pthread_mutexattr_t mutex_attr;\n  pthread_condattr_t cond_attr;\n\n  if (__kmp_init_runtime) {\n    return;\n  }\n\n#if (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n  if (!__kmp_cpuinfo.initialized) {\n    __kmp_query_cpuid(&__kmp_cpuinfo);\n  }\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n  __kmp_xproc = __kmp_get_xproc();\n\n  if (sysconf(_SC_THREADS)) {\n\n    /* Query the maximum number of threads */\n    __kmp_sys_max_nth = sysconf(_SC_THREAD_THREADS_MAX);\n    if (__kmp_sys_max_nth == -1) {\n      /* Unlimited threads for NPTL */\n      __kmp_sys_max_nth = INT_MAX;\n    } else if (__kmp_sys_max_nth <= 1) {\n      /* Can't tell, just use PTHREAD_THREADS_MAX */\n      __kmp_sys_max_nth = KMP_MAX_NTH;\n    }\n\n    /* Query the minimum stack size */\n    __kmp_sys_min_stksize = sysconf(_SC_THREAD_STACK_MIN);\n    if (__kmp_sys_min_stksize <= 1) {\n      __kmp_sys_min_stksize = KMP_MIN_STKSIZE;\n    }\n  }\n\n  /* Set up minimum number of threads to switch to TLS gtid */\n  __kmp_tls_gtid_min = KMP_TLS_GTID_MIN;\n\n  status = pthread_key_create(&__kmp_gtid_threadprivate_key,\n                              __kmp_internal_end_dest);\n  KMP_CHECK_SYSFAIL(\"pthread_key_create\", status);\n  status = pthread_mutexattr_init(&mutex_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_mutexattr_init\", status);\n  status = pthread_mutex_init(&__kmp_wait_mx.m_mutex, &mutex_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_mutex_init\", status);\n  status = pthread_condattr_init(&cond_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_condattr_init\", status);\n  status = pthread_cond_init(&__kmp_wait_cv.c_cond, &cond_attr);\n  KMP_CHECK_SYSFAIL(\"pthread_cond_init\", status);\n#if USE_ITT_BUILD\n  __kmp_itt_initialize();\n#endif /* USE_ITT_BUILD */\n\n  __kmp_init_runtime = TRUE;\n}\n\nvoid __kmp_runtime_destroy(void) {\n  int status;\n\n  if (!__kmp_init_runtime) {\n    return; // Nothing to do.\n  }\n\n#if USE_ITT_BUILD\n  __kmp_itt_destroy();\n#endif /* USE_ITT_BUILD */\n\n  status = pthread_key_delete(__kmp_gtid_threadprivate_key);\n  KMP_CHECK_SYSFAIL(\"pthread_key_delete\", status);\n\n  status = pthread_mutex_destroy(&__kmp_wait_mx.m_mutex);\n  if (status != 0 && status != EBUSY) {\n    KMP_SYSFAIL(\"pthread_mutex_destroy\", status);\n  }\n  status = pthread_cond_destroy(&__kmp_wait_cv.c_cond);\n  if (status != 0 && status != EBUSY) {\n    KMP_SYSFAIL(\"pthread_cond_destroy\", status);\n  }\n#if KMP_AFFINITY_SUPPORTED\n  __kmp_affinity_uninitialize();\n#endif\n\n  __kmp_init_runtime = FALSE;\n}\n\n/* Put the thread to sleep for a time period */\n/* NOTE: not currently used anywhere */\nvoid __kmp_thread_sleep(int millis) { sleep((millis + 500) / 1000); }\n\n/* Calculate the elapsed wall clock time for the user */\nvoid __kmp_elapsed(double *t) {\n  int status;\n#ifdef FIX_SGI_CLOCK\n  struct timespec ts;\n\n  status = clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);\n  KMP_CHECK_SYSFAIL_ERRNO(\"clock_gettime\", status);\n  *t =\n      (double)ts.tv_nsec * (1.0 / (double)KMP_NSEC_PER_SEC) + (double)ts.tv_sec;\n#else\n  struct timeval tv;\n\n  status = gettimeofday(&tv, NULL);\n  KMP_CHECK_SYSFAIL_ERRNO(\"gettimeofday\", status);\n  *t =\n      (double)tv.tv_usec * (1.0 / (double)KMP_USEC_PER_SEC) + (double)tv.tv_sec;\n#endif\n}\n\n/* Calculate the elapsed wall clock tick for the user */\nvoid __kmp_elapsed_tick(double *t) { *t = 1 / (double)CLOCKS_PER_SEC; }\n\n/* Return the current time stamp in nsec */\nkmp_uint64 __kmp_now_nsec() {\n  struct timeval t;\n  gettimeofday(&t, NULL);\n  return KMP_NSEC_PER_SEC * t.tv_sec + 1000 * t.tv_usec;\n}\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n/* Measure clock ticks per millisecond */\nvoid __kmp_initialize_system_tick() {\n  kmp_uint64 delay = 100000; // 50~100 usec on most machines.\n  kmp_uint64 nsec = __kmp_now_nsec();\n  kmp_uint64 goal = __kmp_hardware_timestamp() + delay;\n  kmp_uint64 now;\n  while ((now = __kmp_hardware_timestamp()) < goal)\n    ;\n  __kmp_ticks_per_msec =\n      (kmp_uint64)(1e6 * (delay + (now - goal)) / (__kmp_now_nsec() - nsec));\n}\n#endif\n\n/* Determine whether the given address is mapped into the current address\n   space. */\n\nint __kmp_is_address_mapped(void *addr) {\n\n  int found = 0;\n  int rc;\n\n#if KMP_OS_LINUX || KMP_OS_FREEBSD\n\n  /* On Linux* OS, read the /proc/<pid>/maps pseudo-file to get all the address\n     ranges mapped into the address space. */\n\n  char *name = __kmp_str_format(\"/proc/%d/maps\", getpid());\n  FILE *file = NULL;\n\n  file = fopen(name, \"r\");\n  KMP_ASSERT(file != NULL);\n\n  for (;;) {\n\n    void *beginning = NULL;\n    void *ending = NULL;\n    char perms[5];\n\n    rc = fscanf(file, \"%p-%p %4s %*[^\\n]\\n\", &beginning, &ending, perms);\n    if (rc == EOF) {\n      break;\n    }\n    KMP_ASSERT(rc == 3 &&\n               KMP_STRLEN(perms) == 4); // Make sure all fields are read.\n\n    // Ending address is not included in the region, but beginning is.\n    if ((addr >= beginning) && (addr < ending)) {\n      perms[2] = 0; // 3th and 4th character does not matter.\n      if (strcmp(perms, \"rw\") == 0) {\n        // Memory we are looking for should be readable and writable.\n        found = 1;\n      }\n      break;\n    }\n  }\n\n  // Free resources.\n  fclose(file);\n  KMP_INTERNAL_FREE(name);\n\n#elif KMP_OS_DARWIN\n\n  /* On OS X*, /proc pseudo filesystem is not available. Try to read memory\n     using vm interface. */\n\n  int buffer;\n  vm_size_t count;\n  rc = vm_read_overwrite(\n      mach_task_self(), // Task to read memory of.\n      (vm_address_t)(addr), // Address to read from.\n      1, // Number of bytes to be read.\n      (vm_address_t)(&buffer), // Address of buffer to save read bytes in.\n      &count // Address of var to save number of read bytes in.\n      );\n  if (rc == 0) {\n    // Memory successfully read.\n    found = 1;\n  }\n\n#elif KMP_OS_FREEBSD || KMP_OS_NETBSD\n\n  // FIXME(FreeBSD, NetBSD): Implement this\n  found = 1;\n\n#else\n\n#error \"Unknown or unsupported OS\"\n\n#endif\n\n  return found;\n\n} // __kmp_is_address_mapped\n\n#ifdef USE_LOAD_BALANCE\n\n#if KMP_OS_DARWIN\n\n// The function returns the rounded value of the system load average\n// during given time interval which depends on the value of\n// __kmp_load_balance_interval variable (default is 60 sec, other values\n// may be 300 sec or 900 sec).\n// It returns -1 in case of error.\nint __kmp_get_load_balance(int max) {\n  double averages[3];\n  int ret_avg = 0;\n\n  int res = getloadavg(averages, 3);\n\n  // Check __kmp_load_balance_interval to determine which of averages to use.\n  // getloadavg() may return the number of samples less than requested that is\n  // less than 3.\n  if (__kmp_load_balance_interval < 180 && (res >= 1)) {\n    ret_avg = averages[0]; // 1 min\n  } else if ((__kmp_load_balance_interval >= 180 &&\n              __kmp_load_balance_interval < 600) &&\n             (res >= 2)) {\n    ret_avg = averages[1]; // 5 min\n  } else if ((__kmp_load_balance_interval >= 600) && (res == 3)) {\n    ret_avg = averages[2]; // 15 min\n  } else { // Error occurred\n    return -1;\n  }\n\n  return ret_avg;\n}\n\n#else // Linux* OS\n\n// The fuction returns number of running (not sleeping) threads, or -1 in case\n// of error. Error could be reported if Linux* OS kernel too old (without\n// \"/proc\" support). Counting running threads stops if max running threads\n// encountered.\nint __kmp_get_load_balance(int max) {\n  static int permanent_error = 0;\n  static int glb_running_threads = 0; // Saved count of the running threads for\n  // the thread balance algortihm\n  static double glb_call_time = 0; /* Thread balance algorithm call time */\n\n  int running_threads = 0; // Number of running threads in the system.\n\n  DIR *proc_dir = NULL; // Handle of \"/proc/\" directory.\n  struct dirent *proc_entry = NULL;\n\n  kmp_str_buf_t task_path; // \"/proc/<pid>/task/<tid>/\" path.\n  DIR *task_dir = NULL; // Handle of \"/proc/<pid>/task/<tid>/\" directory.\n  struct dirent *task_entry = NULL;\n  int task_path_fixed_len;\n\n  kmp_str_buf_t stat_path; // \"/proc/<pid>/task/<tid>/stat\" path.\n  int stat_file = -1;\n  int stat_path_fixed_len;\n\n  int total_processes = 0; // Total number of processes in system.\n  int total_threads = 0; // Total number of threads in system.\n\n  double call_time = 0.0;\n\n  __kmp_str_buf_init(&task_path);\n  __kmp_str_buf_init(&stat_path);\n\n  __kmp_elapsed(&call_time);\n\n  if (glb_call_time &&\n      (call_time - glb_call_time < __kmp_load_balance_interval)) {\n    running_threads = glb_running_threads;\n    goto finish;\n  }\n\n  glb_call_time = call_time;\n\n  // Do not spend time on scanning \"/proc/\" if we have a permanent error.\n  if (permanent_error) {\n    running_threads = -1;\n    goto finish;\n  }\n\n  if (max <= 0) {\n    max = INT_MAX;\n  }\n\n  // Open \"/proc/\" directory.\n  proc_dir = opendir(\"/proc\");\n  if (proc_dir == NULL) {\n    // Cannot open \"/prroc/\". Probably the kernel does not support it. Return an\n    // error now and in subsequent calls.\n    running_threads = -1;\n    permanent_error = 1;\n    goto finish;\n  }\n\n  // Initialize fixed part of task_path. This part will not change.\n  __kmp_str_buf_cat(&task_path, \"/proc/\", 6);\n  task_path_fixed_len = task_path.used; // Remember number of used characters.\n\n  proc_entry = readdir(proc_dir);\n  while (proc_entry != NULL) {\n    // Proc entry is a directory and name starts with a digit. Assume it is a\n    // process' directory.\n    if (proc_entry->d_type == DT_DIR && isdigit(proc_entry->d_name[0])) {\n\n      ++total_processes;\n      // Make sure init process is the very first in \"/proc\", so we can replace\n      // strcmp( proc_entry->d_name, \"1\" ) == 0 with simpler total_processes ==\n      // 1. We are going to check that total_processes == 1 => d_name == \"1\" is\n      // true (where \"=>\" is implication). Since C++ does not have => operator,\n      // let us replace it with its equivalent: a => b == ! a || b.\n      KMP_DEBUG_ASSERT(total_processes != 1 ||\n                       strcmp(proc_entry->d_name, \"1\") == 0);\n\n      // Construct task_path.\n      task_path.used = task_path_fixed_len; // Reset task_path to \"/proc/\".\n      __kmp_str_buf_cat(&task_path, proc_entry->d_name,\n                        KMP_STRLEN(proc_entry->d_name));\n      __kmp_str_buf_cat(&task_path, \"/task\", 5);\n\n      task_dir = opendir(task_path.str);\n      if (task_dir == NULL) {\n        // Process can finish between reading \"/proc/\" directory entry and\n        // opening process' \"task/\" directory. So, in general case we should not\n        // complain, but have to skip this process and read the next one. But on\n        // systems with no \"task/\" support we will spend lot of time to scan\n        // \"/proc/\" tree again and again without any benefit. \"init\" process\n        // (its pid is 1) should exist always, so, if we cannot open\n        // \"/proc/1/task/\" directory, it means \"task/\" is not supported by\n        // kernel. Report an error now and in the future.\n        if (strcmp(proc_entry->d_name, \"1\") == 0) {\n          running_threads = -1;\n          permanent_error = 1;\n          goto finish;\n        }\n      } else {\n        // Construct fixed part of stat file path.\n        __kmp_str_buf_clear(&stat_path);\n        __kmp_str_buf_cat(&stat_path, task_path.str, task_path.used);\n        __kmp_str_buf_cat(&stat_path, \"/\", 1);\n        stat_path_fixed_len = stat_path.used;\n\n        task_entry = readdir(task_dir);\n        while (task_entry != NULL) {\n          // It is a directory and name starts with a digit.\n          if (proc_entry->d_type == DT_DIR && isdigit(task_entry->d_name[0])) {\n            ++total_threads;\n\n            // Consruct complete stat file path. Easiest way would be:\n            //  __kmp_str_buf_print( & stat_path, \"%s/%s/stat\", task_path.str,\n            //  task_entry->d_name );\n            // but seriae of __kmp_str_buf_cat works a bit faster.\n            stat_path.used =\n                stat_path_fixed_len; // Reset stat path to its fixed part.\n            __kmp_str_buf_cat(&stat_path, task_entry->d_name,\n                              KMP_STRLEN(task_entry->d_name));\n            __kmp_str_buf_cat(&stat_path, \"/stat\", 5);\n\n            // Note: Low-level API (open/read/close) is used. High-level API\n            // (fopen/fclose)  works ~ 30 % slower.\n            stat_file = open(stat_path.str, O_RDONLY);\n            if (stat_file == -1) {\n              // We cannot report an error because task (thread) can terminate\n              // just before reading this file.\n            } else {\n              /* Content of \"stat\" file looks like:\n                 24285 (program) S ...\n\n                 It is a single line (if program name does not include funny\n                 symbols). First number is a thread id, then name of executable\n                 file name in paretheses, then state of the thread. We need just\n                 thread state.\n\n                 Good news: Length of program name is 15 characters max. Longer\n                 names are truncated.\n\n                 Thus, we need rather short buffer: 15 chars for program name +\n                 2 parenthesis, + 3 spaces + ~7 digits of pid = 37.\n\n                 Bad news: Program name may contain special symbols like space,\n                 closing parenthesis, or even new line. This makes parsing\n                 \"stat\" file not 100 % reliable. In case of fanny program names\n                 parsing may fail (report incorrect thread state).\n\n                 Parsing \"status\" file looks more promissing (due to different\n                 file structure and escaping special symbols) but reading and\n                 parsing of \"status\" file works slower.\n                  -- ln\n              */\n              char buffer[65];\n              int len;\n              len = read(stat_file, buffer, sizeof(buffer) - 1);\n              if (len >= 0) {\n                buffer[len] = 0;\n                // Using scanf:\n                //     sscanf( buffer, \"%*d (%*s) %c \", & state );\n                // looks very nice, but searching for a closing parenthesis\n                // works a bit faster.\n                char *close_parent = strstr(buffer, \") \");\n                if (close_parent != NULL) {\n                  char state = *(close_parent + 2);\n                  if (state == 'R') {\n                    ++running_threads;\n                    if (running_threads >= max) {\n                      goto finish;\n                    }\n                  }\n                }\n              }\n              close(stat_file);\n              stat_file = -1;\n            }\n          }\n          task_entry = readdir(task_dir);\n        }\n        closedir(task_dir);\n        task_dir = NULL;\n      }\n    }\n    proc_entry = readdir(proc_dir);\n  }\n\n  // There _might_ be a timing hole where the thread executing this\n  // code get skipped in the load balance, and running_threads is 0.\n  // Assert in the debug builds only!!!\n  KMP_DEBUG_ASSERT(running_threads > 0);\n  if (running_threads <= 0) {\n    running_threads = 1;\n  }\n\nfinish: // Clean up and exit.\n  if (proc_dir != NULL) {\n    closedir(proc_dir);\n  }\n  __kmp_str_buf_free(&task_path);\n  if (task_dir != NULL) {\n    closedir(task_dir);\n  }\n  __kmp_str_buf_free(&stat_path);\n  if (stat_file != -1) {\n    close(stat_file);\n  }\n\n  glb_running_threads = running_threads;\n\n  return running_threads;\n\n} // __kmp_get_load_balance\n\n#endif // KMP_OS_DARWIN\n\n#endif // USE_LOAD_BALANCE\n\n#if !(KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_MIC ||                            \\\n      ((KMP_OS_LINUX || KMP_OS_DARWIN) && KMP_ARCH_AARCH64) || KMP_ARCH_PPC64)\n\n// we really only need the case with 1 argument, because CLANG always build\n// a struct of pointers to shared variables referenced in the outlined function\nint __kmp_invoke_microtask(microtask_t pkfn, int gtid, int tid, int argc,\n                           void *p_argv[]\n#if OMPT_SUPPORT\n                           ,\n                           void **exit_frame_ptr\n#endif\n                           ) {\n#if OMPT_SUPPORT\n  *exit_frame_ptr = OMPT_GET_FRAME_ADDRESS(0);\n#endif\n\n  switch (argc) {\n  default:\n    fprintf(stderr, \"Too many args to microtask: %d!\\n\", argc);\n    fflush(stderr);\n    exit(-1);\n  case 0:\n    (*pkfn)(&gtid, &tid);\n    break;\n  case 1:\n    (*pkfn)(&gtid, &tid, p_argv[0]);\n    break;\n  case 2:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1]);\n    break;\n  case 3:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2]);\n    break;\n  case 4:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3]);\n    break;\n  case 5:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4]);\n    break;\n  case 6:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5]);\n    break;\n  case 7:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6]);\n    break;\n  case 8:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7]);\n    break;\n  case 9:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8]);\n    break;\n  case 10:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9]);\n    break;\n  case 11:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9], p_argv[10]);\n    break;\n  case 12:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9], p_argv[10],\n            p_argv[11]);\n    break;\n  case 13:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9], p_argv[10],\n            p_argv[11], p_argv[12]);\n    break;\n  case 14:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9], p_argv[10],\n            p_argv[11], p_argv[12], p_argv[13]);\n    break;\n  case 15:\n    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],\n            p_argv[5], p_argv[6], p_argv[7], p_argv[8], p_argv[9], p_argv[10],\n            p_argv[11], p_argv[12], p_argv[13], p_argv[14]);\n    break;\n  }\n\n#if OMPT_SUPPORT\n  *exit_frame_ptr = 0;\n#endif\n\n  return 1;\n}\n\n#endif\n\n// end of file //\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/runtime/src/ompt-general.cpp": "/*\n * ompt-general.cpp -- OMPT implementation of interface functions\n */\n\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.txt for details.\n//\n//===----------------------------------------------------------------------===//\n\n/*****************************************************************************\n * system include files\n ****************************************************************************/\n\n#include <assert.h>\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if KMP_OS_UNIX\n#include <dlfcn.h>\n#endif\n\n/*****************************************************************************\n * ompt include files\n ****************************************************************************/\n\n#include \"ompt-specific.cpp\"\n\n/*****************************************************************************\n * macros\n ****************************************************************************/\n\n#define ompt_get_callback_success 1\n#define ompt_get_callback_failure 0\n\n#define no_tool_present 0\n\n#define OMPT_API_ROUTINE static\n\n#ifndef OMPT_STR_MATCH\n#define OMPT_STR_MATCH(haystack, needle) (!strcasecmp(haystack, needle))\n#endif\n\n/*****************************************************************************\n * types\n ****************************************************************************/\n\ntypedef struct {\n  const char *state_name;\n  omp_state_t state_id;\n} omp_state_info_t;\n\ntypedef struct {\n  const char *name;\n  kmp_mutex_impl_t id;\n} kmp_mutex_impl_info_t;\n\nenum tool_setting_e {\n  omp_tool_error,\n  omp_tool_unset,\n  omp_tool_disabled,\n  omp_tool_enabled\n};\n\n/*****************************************************************************\n * global variables\n ****************************************************************************/\n\nompt_callbacks_active_t ompt_enabled;\n\nomp_state_info_t omp_state_info[] = {\n#define omp_state_macro(state, code) {#state, state},\n    FOREACH_OMP_STATE(omp_state_macro)\n#undef omp_state_macro\n};\n\nkmp_mutex_impl_info_t kmp_mutex_impl_info[] = {\n#define kmp_mutex_impl_macro(name, id) {#name, name},\n    FOREACH_KMP_MUTEX_IMPL(kmp_mutex_impl_macro)\n#undef kmp_mutex_impl_macro\n};\n\nompt_callbacks_internal_t ompt_callbacks;\n\nstatic ompt_start_tool_result_t *ompt_start_tool_result = NULL;\n\n/*****************************************************************************\n * forward declarations\n ****************************************************************************/\n\nstatic ompt_interface_fn_t ompt_fn_lookup(const char *s);\n\nOMPT_API_ROUTINE ompt_data_t *ompt_get_thread_data(void);\n\n/*****************************************************************************\n * initialization and finalization (private operations)\n ****************************************************************************/\n\ntypedef ompt_start_tool_result_t *(*ompt_start_tool_t)(unsigned int,\n                                                       const char *);\n\n#if KMP_OS_DARWIN\n\n// While Darwin supports weak symbols, the library that wishes to provide a new\n// implementation has to link against this runtime which defeats the purpose\n// of having tools that are agnostic of the underlying runtime implementation.\n//\n// Fortunately, the linker includes all symbols of an executable in the global\n// symbol table by default so dlsym() even finds static implementations of\n// ompt_start_tool. For this to work on Linux, -Wl,--export-dynamic needs to be\n// passed when building the application which we don't want to rely on.\n\nstatic ompt_start_tool_result_t *ompt_tool_darwin(unsigned int omp_version,\n                                                  const char *runtime_version) {\n  ompt_start_tool_result_t *ret = NULL;\n  // Search symbol in the current address space.\n  ompt_start_tool_t start_tool =\n      (ompt_start_tool_t)dlsym(RTLD_DEFAULT, \"ompt_start_tool\");\n  if (start_tool) {\n    ret = start_tool(omp_version, runtime_version);\n  }\n  return ret;\n}\n\n#elif OMPT_HAVE_WEAK_ATTRIBUTE\n\n// On Unix-like systems that support weak symbols the following implementation\n// of ompt_start_tool() will be used in case no tool-supplied implementation of\n// this function is present in the address space of a process.\n\n_OMP_EXTERN OMPT_WEAK_ATTRIBUTE ompt_start_tool_result_t *\nompt_start_tool(unsigned int omp_version, const char *runtime_version) {\n  ompt_start_tool_result_t *ret = NULL;\n  // Search next symbol in the current address space. This can happen if the\n  // runtime library is linked before the tool. Since glibc 2.2 strong symbols\n  // don't override weak symbols that have been found before unless the user\n  // sets the environment variable LD_DYNAMIC_WEAK.\n  ompt_start_tool_t next_tool =\n      (ompt_start_tool_t)dlsym(RTLD_NEXT, \"ompt_start_tool\");\n  if (next_tool) {\n    ret = next_tool(omp_version, runtime_version);\n  }\n  return ret;\n}\n\n#elif OMPT_HAVE_PSAPI\n\n// On Windows, the ompt_tool_windows function is used to find the\n// ompt_start_tool symbol across all modules loaded by a process. If\n// ompt_start_tool is found, ompt_start_tool's return value is used to\n// initialize the tool. Otherwise, NULL is returned and OMPT won't be enabled.\n\n#include <psapi.h>\n#pragma comment(lib, \"psapi.lib\")\n\n// The number of loaded modules to start enumeration with EnumProcessModules()\n#define NUM_MODULES 128\n\nstatic ompt_start_tool_result_t *\nompt_tool_windows(unsigned int omp_version, const char *runtime_version) {\n  int i;\n  DWORD needed, new_size;\n  HMODULE *modules;\n  HANDLE process = GetCurrentProcess();\n  modules = (HMODULE *)malloc(NUM_MODULES * sizeof(HMODULE));\n  ompt_start_tool_t ompt_tool_p = NULL;\n\n#if OMPT_DEBUG\n  printf(\"ompt_tool_windows(): looking for ompt_start_tool\\n\");\n#endif\n  if (!EnumProcessModules(process, modules, NUM_MODULES * sizeof(HMODULE),\n                          &needed)) {\n    // Regardless of the error reason use the stub initialization function\n    free(modules);\n    return NULL;\n  }\n  // Check if NUM_MODULES is enough to list all modules\n  new_size = needed / sizeof(HMODULE);\n  if (new_size > NUM_MODULES) {\n#if OMPT_DEBUG\n    printf(\"ompt_tool_windows(): resize buffer to %d bytes\\n\", needed);\n#endif\n    modules = (HMODULE *)realloc(modules, needed);\n    // If resizing failed use the stub function.\n    if (!EnumProcessModules(process, modules, needed, &needed)) {\n      free(modules);\n      return NULL;\n    }\n  }\n  for (i = 0; i < new_size; ++i) {\n    (FARPROC &)ompt_tool_p = GetProcAddress(modules[i], \"ompt_start_tool\");\n    if (ompt_tool_p) {\n#if OMPT_DEBUG\n      TCHAR modName[MAX_PATH];\n      if (GetModuleFileName(modules[i], modName, MAX_PATH))\n        printf(\"ompt_tool_windows(): ompt_start_tool found in module %s\\n\",\n               modName);\n#endif\n      free(modules);\n      return (*ompt_tool_p)(omp_version, runtime_version);\n    }\n#if OMPT_DEBUG\n    else {\n      TCHAR modName[MAX_PATH];\n      if (GetModuleFileName(modules[i], modName, MAX_PATH))\n        printf(\"ompt_tool_windows(): ompt_start_tool not found in module %s\\n\",\n               modName);\n    }\n#endif\n  }\n  free(modules);\n  return NULL;\n}\n#else\n#error Activation of OMPT is not supported on this platform.\n#endif\n\nstatic ompt_start_tool_result_t *\nompt_try_start_tool(unsigned int omp_version, const char *runtime_version) {\n  ompt_start_tool_result_t *ret = NULL;\n  ompt_start_tool_t start_tool = NULL;\n#if KMP_OS_WINDOWS\n  // Cannot use colon to describe a list of absolute paths on Windows\n  const char *sep = \";\";\n#else\n  const char *sep = \":\";\n#endif\n\n#if KMP_OS_DARWIN\n  // Try in the current address space\n  ret = ompt_tool_darwin(omp_version, runtime_version);\n#elif OMPT_HAVE_WEAK_ATTRIBUTE\n  ret = ompt_start_tool(omp_version, runtime_version);\n#elif OMPT_HAVE_PSAPI\n  ret = ompt_tool_windows(omp_version, runtime_version);\n#else\n#error Activation of OMPT is not supported on this platform.\n#endif\n  if (ret)\n    return ret;\n\n  // Try tool-libraries-var ICV\n  const char *tool_libs = getenv(\"OMP_TOOL_LIBRARIES\");\n  if (tool_libs) {\n    char *libs = __kmp_str_format(\"%s\", tool_libs);\n    char *buf;\n    char *fname = __kmp_str_token(libs, sep, &buf);\n    while (fname) {\n#if KMP_OS_UNIX\n      void *h = dlopen(fname, RTLD_LAZY);\n      if (h) {\n        start_tool = (ompt_start_tool_t)dlsym(h, \"ompt_start_tool\");\n#elif KMP_OS_WINDOWS\n      HMODULE h = LoadLibrary(fname);\n      if (h) {\n        start_tool = (ompt_start_tool_t)GetProcAddress(h, \"ompt_start_tool\");\n#else\n#error Activation of OMPT is not supported on this platform.\n#endif\n        if (start_tool && (ret = (*start_tool)(omp_version, runtime_version)))\n          break;\n      }\n      fname = __kmp_str_token(NULL, sep, &buf);\n    }\n    __kmp_str_free(&libs);\n  }\n  return ret;\n}\n\nvoid ompt_pre_init() {\n  //--------------------------------------------------\n  // Execute the pre-initialization logic only once.\n  //--------------------------------------------------\n  static int ompt_pre_initialized = 0;\n\n  if (ompt_pre_initialized)\n    return;\n\n  ompt_pre_initialized = 1;\n\n  //--------------------------------------------------\n  // Use a tool iff a tool is enabled and available.\n  //--------------------------------------------------\n  const char *ompt_env_var = getenv(\"OMP_TOOL\");\n  tool_setting_e tool_setting = omp_tool_error;\n\n  if (!ompt_env_var || !strcmp(ompt_env_var, \"\"))\n    tool_setting = omp_tool_unset;\n  else if (OMPT_STR_MATCH(ompt_env_var, \"disabled\"))\n    tool_setting = omp_tool_disabled;\n  else if (OMPT_STR_MATCH(ompt_env_var, \"enabled\"))\n    tool_setting = omp_tool_enabled;\n\n#if OMPT_DEBUG\n  printf(\"ompt_pre_init(): tool_setting = %d\\n\", tool_setting);\n#endif\n  switch (tool_setting) {\n  case omp_tool_disabled:\n    break;\n\n  case omp_tool_unset:\n  case omp_tool_enabled:\n\n    //--------------------------------------------------\n    // Load tool iff specified in environment variable\n    //--------------------------------------------------\n    ompt_start_tool_result =\n        ompt_try_start_tool(__kmp_openmp_version, ompt_get_runtime_version());\n\n    memset(&ompt_enabled, 0, sizeof(ompt_enabled));\n    break;\n\n  case omp_tool_error:\n    fprintf(stderr, \"Warning: OMP_TOOL has invalid value \\\"%s\\\".\\n\"\n                    \"  legal values are (NULL,\\\"\\\",\\\"disabled\\\",\"\n                    \"\\\"enabled\\\").\\n\",\n            ompt_env_var);\n    break;\n  }\n#if OMPT_DEBUG\n  printf(\"ompt_pre_init(): ompt_enabled = %d\\n\", ompt_enabled);\n#endif\n}\n\nvoid ompt_post_init() {\n  //--------------------------------------------------\n  // Execute the post-initialization logic only once.\n  //--------------------------------------------------\n  static int ompt_post_initialized = 0;\n\n  if (ompt_post_initialized)\n    return;\n\n  ompt_post_initialized = 1;\n\n  //--------------------------------------------------\n  // Initialize the tool if so indicated.\n  //--------------------------------------------------\n  if (ompt_start_tool_result) {\n    ompt_enabled.enabled = !!ompt_start_tool_result->initialize(\n        ompt_fn_lookup, &(ompt_start_tool_result->tool_data));\n\n    if (!ompt_enabled.enabled) {\n      // tool not enabled, zero out the bitmap, and done\n      memset(&ompt_enabled, 0, sizeof(ompt_enabled));\n      return;\n    }\n\n    ompt_thread_t *root_thread = ompt_get_thread();\n\n    ompt_set_thread_state(root_thread, omp_state_overhead);\n\n    if (ompt_enabled.ompt_callback_thread_begin) {\n      ompt_callbacks.ompt_callback(ompt_callback_thread_begin)(\n          ompt_thread_initial, __ompt_get_thread_data_internal());\n    }\n    ompt_data_t *task_data;\n    __ompt_get_task_info_internal(0, NULL, &task_data, NULL, NULL, NULL);\n    if (ompt_enabled.ompt_callback_task_create) {\n      ompt_callbacks.ompt_callback(ompt_callback_task_create)(\n          NULL, NULL, task_data, ompt_task_initial, 0, NULL);\n    }\n\n    ompt_set_thread_state(root_thread, omp_state_work_serial);\n  }\n}\n\nvoid ompt_fini() {\n  if (ompt_enabled.enabled) {\n    ompt_start_tool_result->finalize(&(ompt_start_tool_result->tool_data));\n  }\n\n  memset(&ompt_enabled, 0, sizeof(ompt_enabled));\n}\n\n/*****************************************************************************\n * interface operations\n ****************************************************************************/\n\n/*****************************************************************************\n * state\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_enumerate_states(int current_state, int *next_state,\n                                           const char **next_state_name) {\n  const static int len = sizeof(omp_state_info) / sizeof(omp_state_info_t);\n  int i = 0;\n\n  for (i = 0; i < len - 1; i++) {\n    if (omp_state_info[i].state_id == current_state) {\n      *next_state = omp_state_info[i + 1].state_id;\n      *next_state_name = omp_state_info[i + 1].state_name;\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nOMPT_API_ROUTINE int ompt_enumerate_mutex_impls(int current_impl,\n                                                int *next_impl,\n                                                const char **next_impl_name) {\n  const static int len =\n      sizeof(kmp_mutex_impl_info) / sizeof(kmp_mutex_impl_info_t);\n  int i = 0;\n  for (i = 0; i < len - 1; i++) {\n    if (kmp_mutex_impl_info[i].id != current_impl)\n      continue;\n    *next_impl = kmp_mutex_impl_info[i + 1].id;\n    *next_impl_name = kmp_mutex_impl_info[i + 1].name;\n    return 1;\n  }\n  return 0;\n}\n\n/*****************************************************************************\n * callbacks\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_set_callback(ompt_callbacks_t which,\n                                       ompt_callback_t callback) {\n  switch (which) {\n\n#define ompt_event_macro(event_name, callback_type, event_id)                  \\\n  case event_name:                                                             \\\n    if (ompt_event_implementation_status(event_name)) {                        \\\n      ompt_callbacks.ompt_callback(event_name) = (callback_type)callback;      \\\n      ompt_enabled.event_name = (callback != 0);                               \\\n    }                                                                          \\\n    if (callback)                                                              \\\n      return ompt_event_implementation_status(event_name);                     \\\n    else                                                                       \\\n      return ompt_set_always;\n\n    FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n\n  default:\n    return ompt_set_error;\n  }\n}\n\nOMPT_API_ROUTINE int ompt_get_callback(ompt_callbacks_t which,\n                                       ompt_callback_t *callback) {\n  switch (which) {\n\n#define ompt_event_macro(event_name, callback_type, event_id)                  \\\n  case event_name:                                                             \\\n    if (ompt_event_implementation_status(event_name)) {                        \\\n      ompt_callback_t mycb =                                                   \\\n          (ompt_callback_t)ompt_callbacks.ompt_callback(event_name);           \\\n      if (mycb) {                                                              \\\n        *callback = mycb;                                                      \\\n        return ompt_get_callback_success;                                      \\\n      }                                                                        \\\n    }                                                                          \\\n    return ompt_get_callback_failure;\n\n    FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n\n  default:\n    return ompt_get_callback_failure;\n  }\n}\n\n/*****************************************************************************\n * parallel regions\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_parallel_info(int ancestor_level,\n                                            ompt_data_t **parallel_data,\n                                            int *team_size) {\n  return __ompt_get_parallel_info_internal(ancestor_level, parallel_data,\n                                           team_size);\n}\n\nOMPT_API_ROUTINE omp_state_t ompt_get_state(omp_wait_id_t *wait_id) {\n  omp_state_t thread_state = __ompt_get_state_internal(wait_id);\n\n  if (thread_state == omp_state_undefined) {\n    thread_state = omp_state_work_serial;\n  }\n\n  return thread_state;\n}\n\n/*****************************************************************************\n * tasks\n ****************************************************************************/\n\nOMPT_API_ROUTINE ompt_data_t *ompt_get_thread_data(void) {\n  return __ompt_get_thread_data_internal();\n}\n\nOMPT_API_ROUTINE int ompt_get_task_info(int ancestor_level, int *type,\n                                        ompt_data_t **task_data,\n                                        omp_frame_t **task_frame,\n                                        ompt_data_t **parallel_data,\n                                        int *thread_num) {\n  return __ompt_get_task_info_internal(ancestor_level, type, task_data,\n                                       task_frame, parallel_data, thread_num);\n}\n\n/*****************************************************************************\n * num_procs\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_num_procs(void) {\n  // copied from kmp_ftn_entry.h (but modified: OMPT can only be called when\n  // runtime is initialized)\n  return __kmp_avail_proc;\n}\n\n/*****************************************************************************\n * places\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_num_places(void) {\n// copied from kmp_ftn_entry.h (but modified)\n#if !KMP_AFFINITY_SUPPORTED\n  return 0;\n#else\n  if (!KMP_AFFINITY_CAPABLE())\n    return 0;\n  return __kmp_affinity_num_masks;\n#endif\n}\n\nOMPT_API_ROUTINE int ompt_get_place_proc_ids(int place_num, int ids_size,\n                                             int *ids) {\n// copied from kmp_ftn_entry.h (but modified)\n#if !KMP_AFFINITY_SUPPORTED\n  return 0;\n#else\n  int i, count;\n  int tmp_ids[ids_size];\n  if (!KMP_AFFINITY_CAPABLE())\n    return 0;\n  if (place_num < 0 || place_num >= (int)__kmp_affinity_num_masks)\n    return 0;\n  /* TODO: Is this safe for asynchronous call from signal handler during runtime\n   * shutdown? */\n  kmp_affin_mask_t *mask = KMP_CPU_INDEX(__kmp_affinity_masks, place_num);\n  count = 0;\n  KMP_CPU_SET_ITERATE(i, mask) {\n    if ((!KMP_CPU_ISSET(i, __kmp_affin_fullMask)) ||\n        (!KMP_CPU_ISSET(i, mask))) {\n      continue;\n    }\n    if (count < ids_size)\n      tmp_ids[count] = i;\n    count++;\n  }\n  if (ids_size >= count) {\n    for (i = 0; i < count; i++) {\n      ids[i] = tmp_ids[i];\n    }\n  }\n  return count;\n#endif\n}\n\nOMPT_API_ROUTINE int ompt_get_place_num(void) {\n// copied from kmp_ftn_entry.h (but modified)\n#if !KMP_AFFINITY_SUPPORTED\n  return -1;\n#else\n  if (__kmp_get_gtid() < 0)\n    return -1;\n\n  int gtid;\n  kmp_info_t *thread;\n  if (!KMP_AFFINITY_CAPABLE())\n    return -1;\n  gtid = __kmp_entry_gtid();\n  thread = __kmp_thread_from_gtid(gtid);\n  if (thread == NULL || thread->th.th_current_place < 0)\n    return -1;\n  return thread->th.th_current_place;\n#endif\n}\n\nOMPT_API_ROUTINE int ompt_get_partition_place_nums(int place_nums_size,\n                                                   int *place_nums) {\n// copied from kmp_ftn_entry.h (but modified)\n#if !KMP_AFFINITY_SUPPORTED\n  return 0;\n#else\n  if (__kmp_get_gtid() < 0)\n    return 0;\n\n  int i, gtid, place_num, first_place, last_place, start, end;\n  kmp_info_t *thread;\n  if (!KMP_AFFINITY_CAPABLE())\n    return 0;\n  gtid = __kmp_entry_gtid();\n  thread = __kmp_thread_from_gtid(gtid);\n  if (thread == NULL)\n    return 0;\n  first_place = thread->th.th_first_place;\n  last_place = thread->th.th_last_place;\n  if (first_place < 0 || last_place < 0)\n    return 0;\n  if (first_place <= last_place) {\n    start = first_place;\n    end = last_place;\n  } else {\n    start = last_place;\n    end = first_place;\n  }\n  if (end - start <= place_nums_size)\n    for (i = 0, place_num = start; place_num <= end; ++place_num, ++i) {\n      place_nums[i] = place_num;\n    }\n  return end - start + 1;\n#endif\n}\n\n/*****************************************************************************\n * places\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_proc_id(void) {\n#if KMP_OS_LINUX\n  if (__kmp_get_gtid() < 0)\n    return -1;\n\n  return sched_getcpu();\n#else\n  return -1;\n#endif\n}\n\n/*****************************************************************************\n * compatability\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_ompt_version() { return OMPT_VERSION; }\n\n/*****************************************************************************\n* application-facing API\n ****************************************************************************/\n\n/*----------------------------------------------------------------------------\n | control\n ---------------------------------------------------------------------------*/\n\nint __kmp_control_tool(uint64_t command, uint64_t modifier, void *arg) {\n\n  if (ompt_enabled.enabled) {\n    if (ompt_enabled.ompt_callback_control_tool) {\n      return ompt_callbacks.ompt_callback(ompt_callback_control_tool)(\n          command, modifier, arg, OMPT_LOAD_RETURN_ADDRESS(__kmp_entry_gtid()));\n    } else {\n      return -1;\n    }\n  } else {\n    return -2;\n  }\n}\n\n/*****************************************************************************\n * misc\n ****************************************************************************/\n\nOMPT_API_ROUTINE uint64_t ompt_get_unique_id(void) {\n  return __ompt_get_unique_id_internal();\n}\n\n/*****************************************************************************\n * Target\n ****************************************************************************/\n\nOMPT_API_ROUTINE int ompt_get_target_info(uint64_t *device_num,\n                                          ompt_id_t *target_id,\n                                          ompt_id_t *host_op_id) {\n  return 0; // thread is not in a target region\n}\n\nOMPT_API_ROUTINE int ompt_get_num_devices(void) {\n  return 1; // only one device (the current device) is available\n}\n\n/*****************************************************************************\n * API inquiry for tool\n ****************************************************************************/\n\nstatic ompt_interface_fn_t ompt_fn_lookup(const char *s) {\n\n#define ompt_interface_fn(fn)                                                  \\\n  fn##_t fn##_f = fn;                                                          \\\n  if (strcmp(s, #fn) == 0)                                                     \\\n    return (ompt_interface_fn_t)fn##_f;\n\n  FOREACH_OMPT_INQUIRY_FN(ompt_interface_fn)\n\n  return (ompt_interface_fn_t)0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/runtime/src/thirdparty/ittnotify/ittnotify_config.h": "\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.txt for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM_MAC\n#  define ITT_PLATFORM_MAC 3\n#endif /* ITT_PLATFORM_MAC */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  elif ITT_OS==ITT_OS_MAC\n#    define ITT_PLATFORM ITT_PLATFORM_MAC\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define CDECL __attribute__ ((cdecl))\n#    else  /* _M_IX86 || __i386__ */\n#      define CDECL /* actual only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define STDCALL __attribute__ ((stdcall))\n#    else  /* _M_IX86 || __i386__ */\n#      define STDCALL /* supported only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#define ITT_INLINE_ATTRIBUTE __attribute__((unused))\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#define ITT_INLINE_ATTRIBUTE __attribute__((always_inline, unused))\n#endif /* __STRICT_ANSI__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n/* Was there a magical reason we didn't have 3 here before? */\n#ifndef ITT_ARCH_AARCH64\n#  define ITT_ARCH_AARCH64  3\n#endif /* ITT_ARCH_AARCH64 */\n\n#ifndef ITT_ARCH_ARM\n#  define ITT_ARCH_ARM  4\n#endif /* ITT_ARCH_ARM */\n\n#ifndef ITT_ARCH_PPC64\n#  define ITT_ARCH_PPC64  5\n#endif /* ITT_ARCH_PPC64 */\n\n#ifndef ITT_ARCH_MIPS\n#  define ITT_ARCH_MIPS  6\n#endif /* ITT_ARCH_MIPS */\n\n#ifndef ITT_ARCH_MIPS64\n#  define ITT_ARCH_MIPS64  6\n#endif /* ITT_ARCH_MIPS64 */\n\n\n#ifndef ITT_ARCH\n#  if defined _M_IX86 || defined __i386__\n#    define ITT_ARCH ITT_ARCH_IA32\n#  elif defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64__\n#    define ITT_ARCH ITT_ARCH_IA64\n#  elif defined _M_ARM || __arm__\n#    define ITT_ARCH ITT_ARCH_ARM\n#  elif defined __powerpc64__\n#    define ITT_ARCH ITT_ARCH_PPC64\n#  elif defined __aarch64__\n#    define ITT_ARCH ITT_ARCH_AARCH64\n#  elif defined __mips__ && !defined __mips64\n#    define ITT_ARCH ITT_ARCH_MIPS\n#  elif defined __mips__ && defined __mips64\n#    define ITT_ARCH ITT_ARCH_MIPS64\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#  define ITT_EXTERN_C_BEGIN extern \"C\" {\n#  define ITT_EXTERN_C_END }\n#else\n#  define ITT_EXTERN_C /* nothing */\n#  define ITT_EXTERN_C_BEGIN /* nothing */\n#  define ITT_EXTERN_C_END /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#ifndef __USE_UNIX98\n#define __USE_UNIX98 1 /* need for PTHREAD_MUTEX_RECURSIVE, on SLES11.1 with gcc 4.3.4 wherein pthread.h missing dependency on __USE_XOPEN2K8 */\n#endif /*__USE_UNIX98*/\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrlen(s)          lstrlenA(s)\n#define __itt_fstrcpyn(s1, s2, l) lstrcpynA(s1, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n#define __itt_fstrlen(s)          strlen(s)\n#define __itt_fstrcpyn(s1, s2, l) strncpy(s1, s2, l)\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA-64 architecture */\n#endif /* __INTEL_COMPILER */\n#elif ITT_ARCH==ITT_ARCH_IA32 || ITT_ARCH==ITT_ARCH_IA32E /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(volatile int*)ptr)\n                          : \"0\"(addend), \"m\"(*(volatile int*)ptr)\n                          : \"memory\");\n    return result;\n}\n#elif ITT_ARCH==ITT_ARCH_ARM || ITT_ARCH==ITT_ARCH_PPC64 || ITT_ARCH==ITT_ARCH_AARCH64 || ITT_ARCH==ITT_ARCH_MIPS ||  ITT_ARCH==ITT_ARCH_MIPS64\n#define __TBB_machine_fetchadd4(addr, val) __sync_fetch_and_add(addr, val)\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 0;    /* domain is disabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/libomptarget/src/rtl.cpp": "//===----------- rtl.cpp - Target independent OpenMP target RTL -----------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.txt for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// Functionality for handling RTL plugins.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"device.h\"\n#include \"private.h\"\n#include \"rtl.h\"\n\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <dlfcn.h>\n#include <mutex>\n#include <string>\n\n// List of all plugins that can support offloading.\nstatic const char *RTLNames[] = {\n    /* PowerPC target */ \"libomptarget.rtl.ppc64.so\",\n    /* x86_64 target  */ \"libomptarget.rtl.x86_64.so\",\n    /* CUDA target    */ \"libomptarget.rtl.cuda.so\",\n    /* AArch64 target */ \"libomptarget.rtl.aarch64.so\"};\n\nRTLsTy RTLs;\nstd::mutex RTLsMtx;\n\nHostEntriesBeginToTransTableTy HostEntriesBeginToTransTable;\nstd::mutex TrlTblMtx;\n\nHostPtrToTableMapTy HostPtrToTableMap;\nstd::mutex TblMapMtx;\n\nvoid RTLsTy::LoadRTLs() {\n#ifdef OMPTARGET_DEBUG\n  if (char *envStr = getenv(\"LIBOMPTARGET_DEBUG\")) {\n    DebugLevel = std::stoi(envStr);\n  }\n#endif // OMPTARGET_DEBUG\n\n  // Parse environment variable OMP_TARGET_OFFLOAD (if set)\n  char *envStr = getenv(\"OMP_TARGET_OFFLOAD\");\n  if (envStr && !strcmp(envStr, \"DISABLED\")) {\n    DP(\"Target offloading disabled by environment\\n\");\n    return;\n  }\n\n  DP(\"Loading RTLs...\\n\");\n\n  // Attempt to open all the plugins and, if they exist, check if the interface\n  // is correct and if they are supporting any devices.\n  for (auto *Name : RTLNames) {\n    DP(\"Loading library '%s'...\\n\", Name);\n    void *dynlib_handle = dlopen(Name, RTLD_NOW);\n\n    if (!dynlib_handle) {\n      // Library does not exist or cannot be found.\n      DP(\"Unable to load library '%s': %s!\\n\", Name, dlerror());\n      continue;\n    }\n\n    DP(\"Successfully loaded library '%s'!\\n\", Name);\n\n    // Retrieve the RTL information from the runtime library.\n    RTLInfoTy R;\n\n    R.LibraryHandler = dynlib_handle;\n    R.isUsed = false;\n\n#ifdef OMPTARGET_DEBUG\n    R.RTLName = Name;\n#endif\n\n    if (!(*((void**) &R.is_valid_binary) = dlsym(\n              dynlib_handle, \"__tgt_rtl_is_valid_binary\")))\n      continue;\n    if (!(*((void**) &R.number_of_devices) = dlsym(\n              dynlib_handle, \"__tgt_rtl_number_of_devices\")))\n      continue;\n    if (!(*((void**) &R.init_device) = dlsym(\n              dynlib_handle, \"__tgt_rtl_init_device\")))\n      continue;\n    if (!(*((void**) &R.load_binary) = dlsym(\n              dynlib_handle, \"__tgt_rtl_load_binary\")))\n      continue;\n    if (!(*((void**) &R.data_alloc) = dlsym(\n              dynlib_handle, \"__tgt_rtl_data_alloc\")))\n      continue;\n    if (!(*((void**) &R.data_submit) = dlsym(\n              dynlib_handle, \"__tgt_rtl_data_submit\")))\n      continue;\n    if (!(*((void**) &R.data_retrieve) = dlsym(\n              dynlib_handle, \"__tgt_rtl_data_retrieve\")))\n      continue;\n    if (!(*((void**) &R.data_delete) = dlsym(\n              dynlib_handle, \"__tgt_rtl_data_delete\")))\n      continue;\n    if (!(*((void**) &R.run_region) = dlsym(\n              dynlib_handle, \"__tgt_rtl_run_target_region\")))\n      continue;\n    if (!(*((void**) &R.run_team_region) = dlsym(\n              dynlib_handle, \"__tgt_rtl_run_target_team_region\")))\n      continue;\n\n    // No devices are supported by this RTL?\n    if (!(R.NumberOfDevices = R.number_of_devices())) {\n      DP(\"No devices supported in this RTL\\n\");\n      continue;\n    }\n\n    DP(\"Registering RTL %s supporting %d devices!\\n\",\n        R.RTLName.c_str(), R.NumberOfDevices);\n\n    // The RTL is valid! Will save the information in the RTLs list.\n    AllRTLs.push_back(R);\n  }\n\n  DP(\"RTLs loaded!\\n\");\n\n  return;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Functionality for registering libs\n\nstatic void RegisterImageIntoTranslationTable(TranslationTable &TT,\n    RTLInfoTy &RTL, __tgt_device_image *image) {\n\n  // same size, as when we increase one, we also increase the other.\n  assert(TT.TargetsTable.size() == TT.TargetsImages.size() &&\n         \"We should have as many images as we have tables!\");\n\n  // Resize the Targets Table and Images to accommodate the new targets if\n  // required\n  unsigned TargetsTableMinimumSize = RTL.Idx + RTL.NumberOfDevices;\n\n  if (TT.TargetsTable.size() < TargetsTableMinimumSize) {\n    TT.TargetsImages.resize(TargetsTableMinimumSize, 0);\n    TT.TargetsTable.resize(TargetsTableMinimumSize, 0);\n  }\n\n  // Register the image in all devices for this target type.\n  for (int32_t i = 0; i < RTL.NumberOfDevices; ++i) {\n    // If we are changing the image we are also invalidating the target table.\n    if (TT.TargetsImages[RTL.Idx + i] != image) {\n      TT.TargetsImages[RTL.Idx + i] = image;\n      TT.TargetsTable[RTL.Idx + i] = 0; // lazy initialization of target table.\n    }\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Functionality for registering Ctors/Dtors\n\nstatic void RegisterGlobalCtorsDtorsForImage(__tgt_bin_desc *desc,\n    __tgt_device_image *img, RTLInfoTy *RTL) {\n\n  for (int32_t i = 0; i < RTL->NumberOfDevices; ++i) {\n    DeviceTy &Device = Devices[RTL->Idx + i];\n    Device.PendingGlobalsMtx.lock();\n    Device.HasPendingGlobals = true;\n    for (__tgt_offload_entry *entry = img->EntriesBegin;\n        entry != img->EntriesEnd; ++entry) {\n      if (entry->flags & OMP_DECLARE_TARGET_CTOR) {\n        DP(\"Adding ctor \" DPxMOD \" to the pending list.\\n\",\n            DPxPTR(entry->addr));\n        Device.PendingCtorsDtors[desc].PendingCtors.push_back(entry->addr);\n      } else if (entry->flags & OMP_DECLARE_TARGET_DTOR) {\n        // Dtors are pushed in reverse order so they are executed from end\n        // to beginning when unregistering the library!\n        DP(\"Adding dtor \" DPxMOD \" to the pending list.\\n\",\n            DPxPTR(entry->addr));\n        Device.PendingCtorsDtors[desc].PendingDtors.push_front(entry->addr);\n      }\n\n      if (entry->flags & OMP_DECLARE_TARGET_LINK) {\n        DP(\"The \\\"link\\\" attribute is not yet supported!\\n\");\n      }\n    }\n    Device.PendingGlobalsMtx.unlock();\n  }\n}\n\nvoid RTLsTy::RegisterLib(__tgt_bin_desc *desc) {\n  // Attempt to load all plugins available in the system.\n  std::call_once(initFlag, &RTLsTy::LoadRTLs, this);\n\n  RTLsMtx.lock();\n  // Register the images with the RTLs that understand them, if any.\n  for (int32_t i = 0; i < desc->NumDeviceImages; ++i) {\n    // Obtain the image.\n    __tgt_device_image *img = &desc->DeviceImages[i];\n\n    RTLInfoTy *FoundRTL = NULL;\n\n    // Scan the RTLs that have associated images until we find one that supports\n    // the current image.\n    for (auto &R : RTLs.AllRTLs) {\n      if (!R.is_valid_binary(img)) {\n        DP(\"Image \" DPxMOD \" is NOT compatible with RTL %s!\\n\",\n            DPxPTR(img->ImageStart), R.RTLName.c_str());\n        continue;\n      }\n\n      DP(\"Image \" DPxMOD \" is compatible with RTL %s!\\n\",\n          DPxPTR(img->ImageStart), R.RTLName.c_str());\n\n      // If this RTL is not already in use, initialize it.\n      if (!R.isUsed) {\n        // Initialize the device information for the RTL we are about to use.\n        DeviceTy device(&R);\n\n        size_t start = Devices.size();\n        Devices.resize(start + R.NumberOfDevices, device);\n        for (int32_t device_id = 0; device_id < R.NumberOfDevices;\n            device_id++) {\n          // global device ID\n          Devices[start + device_id].DeviceID = start + device_id;\n          // RTL local device ID\n          Devices[start + device_id].RTLDeviceID = device_id;\n\n          // Save pointer to device in RTL in case we want to unregister the RTL\n          R.Devices.push_back(&Devices[start + device_id]);\n        }\n\n        // Initialize the index of this RTL and save it in the used RTLs.\n        R.Idx = (RTLs.UsedRTLs.empty())\n                    ? 0\n                    : RTLs.UsedRTLs.back()->Idx +\n                          RTLs.UsedRTLs.back()->NumberOfDevices;\n        assert((size_t) R.Idx == start &&\n            \"RTL index should equal the number of devices used so far.\");\n        R.isUsed = true;\n        RTLs.UsedRTLs.push_back(&R);\n\n        DP(\"RTL \" DPxMOD \" has index %d!\\n\", DPxPTR(R.LibraryHandler), R.Idx);\n      }\n\n      // Initialize (if necessary) translation table for this library.\n      TrlTblMtx.lock();\n      if(!HostEntriesBeginToTransTable.count(desc->HostEntriesBegin)){\n        TranslationTable &tt =\n            HostEntriesBeginToTransTable[desc->HostEntriesBegin];\n        tt.HostTable.EntriesBegin = desc->HostEntriesBegin;\n        tt.HostTable.EntriesEnd = desc->HostEntriesEnd;\n      }\n\n      // Retrieve translation table for this library.\n      TranslationTable &TransTable =\n          HostEntriesBeginToTransTable[desc->HostEntriesBegin];\n\n      DP(\"Registering image \" DPxMOD \" with RTL %s!\\n\",\n          DPxPTR(img->ImageStart), R.RTLName.c_str());\n      RegisterImageIntoTranslationTable(TransTable, R, img);\n      TrlTblMtx.unlock();\n      FoundRTL = &R;\n\n      // Load ctors/dtors for static objects\n      RegisterGlobalCtorsDtorsForImage(desc, img, FoundRTL);\n\n      // if an RTL was found we are done - proceed to register the next image\n      break;\n    }\n\n    if (!FoundRTL) {\n      DP(\"No RTL found for image \" DPxMOD \"!\\n\", DPxPTR(img->ImageStart));\n    }\n  }\n  RTLsMtx.unlock();\n\n\n  DP(\"Done registering entries!\\n\");\n}\n\nvoid RTLsTy::UnregisterLib(__tgt_bin_desc *desc) {\n  DP(\"Unloading target library!\\n\");\n\n  RTLsMtx.lock();\n  // Find which RTL understands each image, if any.\n  for (int32_t i = 0; i < desc->NumDeviceImages; ++i) {\n    // Obtain the image.\n    __tgt_device_image *img = &desc->DeviceImages[i];\n\n    RTLInfoTy *FoundRTL = NULL;\n\n    // Scan the RTLs that have associated images until we find one that supports\n    // the current image. We only need to scan RTLs that are already being used.\n    for (auto *R : RTLs.UsedRTLs) {\n\n      assert(R->isUsed && \"Expecting used RTLs.\");\n\n      if (!R->is_valid_binary(img)) {\n        DP(\"Image \" DPxMOD \" is NOT compatible with RTL \" DPxMOD \"!\\n\",\n            DPxPTR(img->ImageStart), DPxPTR(R->LibraryHandler));\n        continue;\n      }\n\n      DP(\"Image \" DPxMOD \" is compatible with RTL \" DPxMOD \"!\\n\",\n          DPxPTR(img->ImageStart), DPxPTR(R->LibraryHandler));\n\n      FoundRTL = R;\n\n      // Execute dtors for static objects if the device has been used, i.e.\n      // if its PendingCtors list has been emptied.\n      for (int32_t i = 0; i < FoundRTL->NumberOfDevices; ++i) {\n        DeviceTy &Device = Devices[FoundRTL->Idx + i];\n        Device.PendingGlobalsMtx.lock();\n        if (Device.PendingCtorsDtors[desc].PendingCtors.empty()) {\n          for (auto &dtor : Device.PendingCtorsDtors[desc].PendingDtors) {\n            int rc = target(Device.DeviceID, dtor, 0, NULL, NULL, NULL, NULL, 1,\n                1, true /*team*/);\n            if (rc != OFFLOAD_SUCCESS) {\n              DP(\"Running destructor \" DPxMOD \" failed.\\n\", DPxPTR(dtor));\n            }\n          }\n          // Remove this library's entry from PendingCtorsDtors\n          Device.PendingCtorsDtors.erase(desc);\n        }\n        Device.PendingGlobalsMtx.unlock();\n      }\n\n      DP(\"Unregistered image \" DPxMOD \" from RTL \" DPxMOD \"!\\n\",\n          DPxPTR(img->ImageStart), DPxPTR(R->LibraryHandler));\n\n      break;\n    }\n\n    // if no RTL was found proceed to unregister the next image\n    if (!FoundRTL){\n      DP(\"No RTLs in use support the image \" DPxMOD \"!\\n\",\n          DPxPTR(img->ImageStart));\n    }\n  }\n  RTLsMtx.unlock();\n  DP(\"Done unregistering images!\\n\");\n\n  // Remove entries from HostPtrToTableMap\n  TblMapMtx.lock();\n  for (__tgt_offload_entry *cur = desc->HostEntriesBegin;\n      cur < desc->HostEntriesEnd; ++cur) {\n    HostPtrToTableMap.erase(cur->addr);\n  }\n\n  // Remove translation table for this descriptor.\n  auto tt = HostEntriesBeginToTransTable.find(desc->HostEntriesBegin);\n  if (tt != HostEntriesBeginToTransTable.end()) {\n    DP(\"Removing translation table for descriptor \" DPxMOD \"\\n\",\n        DPxPTR(desc->HostEntriesBegin));\n    HostEntriesBeginToTransTable.erase(tt);\n  } else {\n    DP(\"Translation table for descriptor \" DPxMOD \" cannot be found, probably \"\n        \"it has been already removed.\\n\", DPxPTR(desc->HostEntriesBegin));\n  }\n\n  TblMapMtx.unlock();\n\n  // TODO: Remove RTL and the devices it manages if it's not used anymore?\n  // TODO: Write some RTL->unload_image(...) function?\n\n  DP(\"Done unregistering library!\\n\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp": "//===-RTLs/generic-64bit/src/rtl.cpp - Target RTLs Implementation - C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.txt for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// RTL for generic 64-bit machine\n//\n//===----------------------------------------------------------------------===//\n\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <dlfcn.h>\n#include <ffi.h>\n#include <gelf.h>\n#include <link.h>\n#include <list>\n#include <string>\n#include <vector>\n\n#include \"omptargetplugin.h\"\n\n#ifndef TARGET_NAME\n#define TARGET_NAME Generic ELF - 64bit\n#endif\n\n#ifndef TARGET_ELF_ID\n#define TARGET_ELF_ID 0\n#endif\n\n#ifdef OMPTARGET_DEBUG\nstatic int DebugLevel = 0;\n\n#define GETNAME2(name) #name\n#define GETNAME(name) GETNAME2(name)\n#define DP(...) \\\n  do { \\\n    if (DebugLevel > 0) { \\\n      DEBUGP(\"Target \" GETNAME(TARGET_NAME) \" RTL\", __VA_ARGS__); \\\n    } \\\n  } while (false)\n#else // OMPTARGET_DEBUG\n#define DP(...) {}\n#endif // OMPTARGET_DEBUG\n\n#include \"../../common/elf_common.c\"\n\n#define NUMBER_OF_DEVICES 4\n#define OFFLOADSECTIONNAME \".omp_offloading.entries\"\n\n/// Array of Dynamic libraries loaded for this target.\nstruct DynLibTy {\n  char *FileName;\n  void *Handle;\n};\n\n/// Keep entries table per device.\nstruct FuncOrGblEntryTy {\n  __tgt_target_table Table;\n};\n\n/// Class containing all the device information.\nclass RTLDeviceInfoTy {\n  std::vector<FuncOrGblEntryTy> FuncGblEntries;\n\npublic:\n  std::list<DynLibTy> DynLibs;\n\n  // Record entry point associated with device.\n  void createOffloadTable(int32_t device_id, __tgt_offload_entry *begin,\n                          __tgt_offload_entry *end) {\n    assert(device_id < (int32_t)FuncGblEntries.size() &&\n           \"Unexpected device id!\");\n    FuncOrGblEntryTy &E = FuncGblEntries[device_id];\n\n    E.Table.EntriesBegin = begin;\n    E.Table.EntriesEnd = end;\n  }\n\n  // Return true if the entry is associated with device.\n  bool findOffloadEntry(int32_t device_id, void *addr) {\n    assert(device_id < (int32_t)FuncGblEntries.size() &&\n           \"Unexpected device id!\");\n    FuncOrGblEntryTy &E = FuncGblEntries[device_id];\n\n    for (__tgt_offload_entry *i = E.Table.EntriesBegin, *e = E.Table.EntriesEnd;\n         i < e; ++i) {\n      if (i->addr == addr)\n        return true;\n    }\n\n    return false;\n  }\n\n  // Return the pointer to the target entries table.\n  __tgt_target_table *getOffloadEntriesTable(int32_t device_id) {\n    assert(device_id < (int32_t)FuncGblEntries.size() &&\n           \"Unexpected device id!\");\n    FuncOrGblEntryTy &E = FuncGblEntries[device_id];\n\n    return &E.Table;\n  }\n\n  RTLDeviceInfoTy(int32_t num_devices) {\n#ifdef OMPTARGET_DEBUG\n    if (char *envStr = getenv(\"LIBOMPTARGET_DEBUG\")) {\n      DebugLevel = std::stoi(envStr);\n    }\n#endif // OMPTARGET_DEBUG\n\n    FuncGblEntries.resize(num_devices);\n  }\n\n  ~RTLDeviceInfoTy() {\n    // Close dynamic libraries\n    for (auto &lib : DynLibs) {\n      if (lib.Handle) {\n        dlclose(lib.Handle);\n        remove(lib.FileName);\n      }\n    }\n  }\n};\n\nstatic RTLDeviceInfoTy DeviceInfo(NUMBER_OF_DEVICES);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint32_t __tgt_rtl_is_valid_binary(__tgt_device_image *image) {\n// If we don't have a valid ELF ID we can just fail.\n#if TARGET_ELF_ID < 1\n  return 0;\n#else\n  return elf_check_machine(image, TARGET_ELF_ID);\n#endif\n}\n\nint32_t __tgt_rtl_number_of_devices() { return NUMBER_OF_DEVICES; }\n\nint32_t __tgt_rtl_init_device(int32_t device_id) { return OFFLOAD_SUCCESS; }\n\n__tgt_target_table *__tgt_rtl_load_binary(int32_t device_id,\n                                          __tgt_device_image *image) {\n\n  DP(\"Dev %d: load binary from \" DPxMOD \" image\\n\", device_id,\n     DPxPTR(image->ImageStart));\n\n  assert(device_id >= 0 && device_id < NUMBER_OF_DEVICES && \"bad dev id\");\n\n  size_t ImageSize = (size_t)image->ImageEnd - (size_t)image->ImageStart;\n  size_t NumEntries = (size_t)(image->EntriesEnd - image->EntriesBegin);\n  DP(\"Expecting to have %zd entries defined.\\n\", NumEntries);\n\n  // Is the library version incompatible with the header file?\n  if (elf_version(EV_CURRENT) == EV_NONE) {\n    DP(\"Incompatible ELF library!\\n\");\n    return NULL;\n  }\n\n  // Obtain elf handler\n  Elf *e = elf_memory((char *)image->ImageStart, ImageSize);\n  if (!e) {\n    DP(\"Unable to get ELF handle: %s!\\n\", elf_errmsg(-1));\n    return NULL;\n  }\n\n  if (elf_kind(e) != ELF_K_ELF) {\n    DP(\"Invalid Elf kind!\\n\");\n    elf_end(e);\n    return NULL;\n  }\n\n  // Find the entries section offset\n  Elf_Scn *section = 0;\n  Elf64_Off entries_offset = 0;\n\n  size_t shstrndx;\n\n  if (elf_getshdrstrndx(e, &shstrndx)) {\n    DP(\"Unable to get ELF strings index!\\n\");\n    elf_end(e);\n    return NULL;\n  }\n\n  while ((section = elf_nextscn(e, section))) {\n    GElf_Shdr hdr;\n    gelf_getshdr(section, &hdr);\n\n    if (!strcmp(elf_strptr(e, shstrndx, hdr.sh_name), OFFLOADSECTIONNAME)) {\n      entries_offset = hdr.sh_addr;\n      break;\n    }\n  }\n\n  if (!entries_offset) {\n    DP(\"Entries Section Offset Not Found\\n\");\n    elf_end(e);\n    return NULL;\n  }\n\n  DP(\"Offset of entries section is (\" DPxMOD \").\\n\", DPxPTR(entries_offset));\n\n  // load dynamic library and get the entry points. We use the dl library\n  // to do the loading of the library, but we could do it directly to avoid the\n  // dump to the temporary file.\n  //\n  // 1) Create tmp file with the library contents.\n  // 2) Use dlopen to load the file and dlsym to retrieve the symbols.\n  char tmp_name[] = \"/tmp/tmpfile_XXXXXX\";\n  int tmp_fd = mkstemp(tmp_name);\n\n  if (tmp_fd == -1) {\n    elf_end(e);\n    return NULL;\n  }\n\n  FILE *ftmp = fdopen(tmp_fd, \"wb\");\n\n  if (!ftmp) {\n    elf_end(e);\n    return NULL;\n  }\n\n  fwrite(image->ImageStart, ImageSize, 1, ftmp);\n  fclose(ftmp);\n\n  DynLibTy Lib = {tmp_name, dlopen(tmp_name, RTLD_LAZY)};\n\n  if (!Lib.Handle) {\n    DP(\"Target library loading error: %s\\n\", dlerror());\n    elf_end(e);\n    return NULL;\n  }\n\n  DeviceInfo.DynLibs.push_back(Lib);\n\n  struct link_map *libInfo = (struct link_map *)Lib.Handle;\n\n  // The place where the entries info is loaded is the library base address\n  // plus the offset determined from the ELF file.\n  Elf64_Addr entries_addr = libInfo->l_addr + entries_offset;\n\n  DP(\"Pointer to first entry to be loaded is (\" DPxMOD \").\\n\",\n      DPxPTR(entries_addr));\n\n  // Table of pointers to all the entries in the target.\n  __tgt_offload_entry *entries_table = (__tgt_offload_entry *)entries_addr;\n\n  __tgt_offload_entry *entries_begin = &entries_table[0];\n  __tgt_offload_entry *entries_end = entries_begin + NumEntries;\n\n  if (!entries_begin) {\n    DP(\"Can't obtain entries begin\\n\");\n    elf_end(e);\n    return NULL;\n  }\n\n  DP(\"Entries table range is (\" DPxMOD \")->(\" DPxMOD \")\\n\",\n      DPxPTR(entries_begin), DPxPTR(entries_end));\n  DeviceInfo.createOffloadTable(device_id, entries_begin, entries_end);\n\n  elf_end(e);\n\n  return DeviceInfo.getOffloadEntriesTable(device_id);\n}\n\nvoid *__tgt_rtl_data_alloc(int32_t device_id, int64_t size, void *hst_ptr) {\n  void *ptr = malloc(size);\n  return ptr;\n}\n\nint32_t __tgt_rtl_data_submit(int32_t device_id, void *tgt_ptr, void *hst_ptr,\n                              int64_t size) {\n  memcpy(tgt_ptr, hst_ptr, size);\n  return OFFLOAD_SUCCESS;\n}\n\nint32_t __tgt_rtl_data_retrieve(int32_t device_id, void *hst_ptr, void *tgt_ptr,\n                                int64_t size) {\n  memcpy(hst_ptr, tgt_ptr, size);\n  return OFFLOAD_SUCCESS;\n}\n\nint32_t __tgt_rtl_data_delete(int32_t device_id, void *tgt_ptr) {\n  free(tgt_ptr);\n  return OFFLOAD_SUCCESS;\n}\n\nint32_t __tgt_rtl_run_target_team_region(int32_t device_id, void *tgt_entry_ptr,\n    void **tgt_args, ptrdiff_t *tgt_offsets, int32_t arg_num, int32_t team_num,\n    int32_t thread_limit, uint64_t loop_tripcount /*not used*/) {\n  // ignore team num and thread limit.\n\n  // Use libffi to launch execution.\n  ffi_cif cif;\n\n  // All args are references.\n  std::vector<ffi_type *> args_types(arg_num, &ffi_type_pointer);\n  std::vector<void *> args(arg_num);\n  std::vector<void *> ptrs(arg_num);\n\n  for (int32_t i = 0; i < arg_num; ++i) {\n    ptrs[i] = (void *)((intptr_t)tgt_args[i] + tgt_offsets[i]);\n    args[i] = &ptrs[i];\n  }\n\n  ffi_status status = ffi_prep_cif(&cif, FFI_DEFAULT_ABI, arg_num,\n                                   &ffi_type_void, &args_types[0]);\n\n  assert(status == FFI_OK && \"Unable to prepare target launch!\");\n\n  if (status != FFI_OK)\n    return OFFLOAD_FAIL;\n\n  DP(\"Running entry point at \" DPxMOD \"...\\n\", DPxPTR(tgt_entry_ptr));\n\n  void (*entry)(void);\n  *((void**) &entry) = tgt_entry_ptr;\n  ffi_call(&cif, entry, NULL, &args[0]);\n  return OFFLOAD_SUCCESS;\n}\n\nint32_t __tgt_rtl_run_target_region(int32_t device_id, void *tgt_entry_ptr,\n    void **tgt_args, ptrdiff_t *tgt_offsets, int32_t arg_num) {\n  // use one team and one thread.\n  return __tgt_rtl_run_target_team_region(device_id, tgt_entry_ptr, tgt_args,\n      tgt_offsets, arg_num, 1, 1, 0);\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/line-profiler/cmake/Modules/targetLinkLibrariesWithDynamicLookup.cmake": "#.rst:\n#\n# Public Functions\n# ^^^^^^^^^^^^^^^^\n#\n# The following functions are defined:\n#\n# .. cmake:command:: target_link_libraries_with_dynamic_lookup\n#\n# ::\n#\n#     target_link_libraries_with_dynamic_lookup(<Target> [<Libraries>])\n#\n#\n# Useful to \"weakly\" link a loadable module. For example, it should be used\n# when compiling a loadable module when the symbols should be resolve from\n# the run-time environment where the module is loaded, and not a specific\n# system library.\n#\n# Like proper linking, except that the given ``<Libraries>`` are not necessarily\n# linked. Instead, the ``<Target>`` is produced in a manner that allows for\n# symbols unresolved within it to be resolved at runtime, presumably by the\n# given ``<Libraries>``.  If such a target can be produced, the provided\n# ``<Libraries>`` are not actually linked.\n#\n# It links a library to a target such that the symbols are resolved at\n# run-time not link-time.\n#\n# The linker is checked to see if it supports undefined\n# symbols when linking a shared library. If it does then the library\n# is not linked when specified with this function.\n#\n# On platforms that do not support weak-linking, this function works just\n# like ``target_link_libraries``.\n#\n# .. note::\n#\n#     For OSX it uses ``undefined dynamic_lookup``. This is similar to using\n#     ``-shared`` on Linux where undefined symbols are ignored.\n#\n#     For more details, see `blog <http://blog.tim-smith.us/2015/09/python-extension-modules-os-x/>`_\n#     from Tim D. Smith.\n#\n#\n# .. cmake:command:: check_dynamic_lookup\n#\n# Check if the linker requires a command line flag to allow leaving symbols\n# unresolved when producing a target of type ``<TargetType>`` that is\n# weakly-linked against a dependency of type ``<LibType>``.\n#\n# ``<TargetType>``\n#   can be one of \"STATIC\", \"SHARED\", \"MODULE\", or \"EXE\".\n#\n# ``<LibType>``\n#   can be one of \"STATIC\", \"SHARED\", or \"MODULE\".\n#\n# Long signature:\n#\n# ::\n#\n#     check_dynamic_lookup(<TargetType>\n#                          <LibType>\n#                          <ResultVar>\n#                          [<LinkFlagsVar>])\n#\n#\n# Short signature:\n#\n# ::\n#\n#     check_dynamic_lookup(<ResultVar>) # <TargetType> set to \"MODULE\"\n#                                       # <LibType> set to \"SHARED\"\n#\n#\n# The result is cached between invocations and recomputed only when the value\n# of CMake's linker flag list changes; ``CMAKE_STATIC_LINKER_FLAGS`` if\n# ``<TargetType>`` is \"STATIC\", and ``CMAKE_SHARED_LINKER_FLAGS`` otherwise.\n#\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   Whether the current C toolchain supports weak-linking for target binaries of\n#   type ``<TargetType>`` that are weakly-linked against a dependency target of\n#   type ``<LibType>``.\n#\n# ``<LinkFlagsVar>``\n#   List of flags to add to the linker command to produce a working target\n#   binary of type ``<TargetType>`` that is weakly-linked against a dependency\n#   target of type ``<LibType>``.\n#\n# ``HAS_DYNAMIC_LOOKUP_<TargetType>_<LibType>``\n#   Cached, global alias for ``<ResultVar>``\n#\n# ``DYNAMIC_LOOKUP_FLAGS_<TargetType>_<LibType>``\n#   Cached, global alias for ``<LinkFlagsVar>``\n#\n#\n# Private Functions\n# ^^^^^^^^^^^^^^^^^\n#\n# The following private functions are defined:\n#\n# .. warning:: These functions are not part of the scikit-build API. They\n#     exist purely as an implementation detail and may change from version\n#     to version without notice, or even be removed.\n#\n#     We mean it.\n#\n#\n# .. cmake:command:: _get_target_type\n#\n# ::\n#\n#     _get_target_type(<ResultVar> <Target>)\n#\n#\n# Shorthand for querying an abbreviated version of the target type\n# of the given ``<Target>``.\n#\n# ``<ResultVar>`` is set to:\n#\n# - \"STATIC\" for a STATIC_LIBRARY,\n# - \"SHARED\" for a SHARED_LIBRARY,\n# - \"MODULE\" for a MODULE_LIBRARY,\n# - and \"EXE\" for an EXECUTABLE.\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   The abbreviated version of the ``<Target>``'s type.\n#\n#\n# .. cmake:command:: _test_weak_link_project\n#\n# ::\n#\n#     _test_weak_link_project(<TargetType>\n#                             <LibType>\n#                             <ResultVar>\n#                             <LinkFlagsVar>)\n#\n#\n# Attempt to compile and run a test project where a target of type\n# ``<TargetType>`` is weakly-linked against a dependency of type ``<LibType>``:\n#\n# - ``<TargetType>`` can be one of \"STATIC\", \"SHARED\", \"MODULE\", or \"EXE\".\n# - ``<LibType>`` can be one of \"STATIC\", \"SHARED\", or \"MODULE\".\n#\n# Defined variables:\n#\n# ``<ResultVar>``\n#   Whether the current C toolchain can produce a working target binary of type\n#   ``<TargetType>`` that is weakly-linked against a dependency target of type\n#   ``<LibType>``.\n#\n# ``<LinkFlagsVar>``\n#   List of flags to add to the linker command to produce a working target\n#   binary of type ``<TargetType>`` that is weakly-linked against a dependency\n#   target of type ``<LibType>``.\n#\n\nfunction(_get_target_type result_var target)\n  set(target_type \"SHARED_LIBRARY\")\n  if(TARGET ${target})\n    get_property(target_type TARGET ${target} PROPERTY TYPE)\n  endif()\n\n  set(result \"STATIC\")\n\n  if(target_type STREQUAL \"STATIC_LIBRARY\")\n    set(result \"STATIC\")\n  endif()\n\n  if(target_type STREQUAL \"SHARED_LIBRARY\")\n    set(result \"SHARED\")\n  endif()\n\n  if(target_type STREQUAL \"MODULE_LIBRARY\")\n    set(result \"MODULE\")\n  endif()\n\n  if(target_type STREQUAL \"EXECUTABLE\")\n    set(result \"EXE\")\n  endif()\n\n  set(${result_var} ${result} PARENT_SCOPE)\nendfunction()\n\n\nfunction(_test_weak_link_project\n         target_type\n         lib_type\n         can_weak_link_var\n         project_name)\n\n  set(gnu_ld_ignore      \"-Wl,--unresolved-symbols=ignore-all\")\n  set(osx_dynamic_lookup           \"-undefined dynamic_lookup\")\n  set(no_flag                                               \"\")\n\n  foreach(link_flag_spec gnu_ld_ignore osx_dynamic_lookup no_flag)\n    set(link_flag \"${${link_flag_spec}}\")\n\n    set(test_project_dir \"${PROJECT_BINARY_DIR}/CMakeTmp\")\n    set(test_project_dir \"${test_project_dir}/${project_name}\")\n    set(test_project_dir \"${test_project_dir}/${link_flag_spec}\")\n    set(test_project_dir \"${test_project_dir}/${target_type}\")\n    set(test_project_dir \"${test_project_dir}/${lib_type}\")\n\n    set(test_project_src_dir \"${test_project_dir}/src\")\n    set(test_project_bin_dir \"${test_project_dir}/build\")\n\n    file(MAKE_DIRECTORY ${test_project_src_dir})\n    file(MAKE_DIRECTORY ${test_project_bin_dir})\n\n    set(mod_type \"STATIC\")\n    set(link_mod_lib TRUE)\n    set(link_exe_lib TRUE)\n    set(link_exe_mod FALSE)\n\n    if(\"${target_type}\" STREQUAL \"EXE\")\n      set(link_exe_lib FALSE)\n      set(link_exe_mod TRUE)\n    else()\n      set(mod_type \"${target_type}\")\n    endif()\n\n    if(\"${mod_type}\" STREQUAL \"MODULE\")\n      set(link_mod_lib FALSE)\n    endif()\n\n\n    file(WRITE \"${test_project_src_dir}/CMakeLists.txt\" \"\n      cmake_minimum_required(VERSION ${CMAKE_VERSION})\n      project(${project_name} C)\n\n      include_directories(${test_project_src_dir})\n\n      add_library(number ${lib_type} number.c)\n      add_library(counter ${mod_type} counter.c)\n    \")\n\n    if(\"${mod_type}\" STREQUAL \"MODULE\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        set_target_properties(counter PROPERTIES PREFIX \\\"\\\")\n      \")\n    endif()\n\n    if(link_mod_lib)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(counter number)\n      \")\n    elseif(NOT link_flag STREQUAL \"\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        set_target_properties(counter PROPERTIES LINK_FLAGS \\\"${link_flag}\\\")\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n      add_executable(main main.c)\n    \")\n\n    if(link_exe_lib)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main number)\n      \")\n    elseif(NOT link_flag STREQUAL \"\")\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main \\\"${link_flag}\\\")\n      \")\n    endif()\n\n    if(link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main counter)\n      \")\n    else()\n      file(APPEND \"${test_project_src_dir}/CMakeLists.txt\" \"\n        target_link_libraries(main \\\"${CMAKE_DL_LIBS}\\\")\n      \")\n    endif()\n\n    file(WRITE \"${test_project_src_dir}/number.c\" \"\n      #include <number.h>\n\n      static int _number;\n      void set_number(int number) { _number = number; }\n      int get_number() { return _number; }\n    \")\n\n    file(WRITE \"${test_project_src_dir}/number.h\" \"\n      #ifndef _NUMBER_H\n      #define _NUMBER_H\n      extern void set_number(int);\n      extern int get_number(void);\n      #endif\n    \")\n\n    file(WRITE \"${test_project_src_dir}/counter.c\" \"\n      #include <number.h>\n      int count() {\n        int result = get_number();\n        set_number(result + 1);\n        return result;\n      }\n    \")\n\n    file(WRITE \"${test_project_src_dir}/counter.h\" \"\n      #ifndef _COUNTER_H\n      #define _COUNTER_H\n      extern int count(void);\n      #endif\n    \")\n\n    file(WRITE \"${test_project_src_dir}/main.c\" \"\n      #include <stdlib.h>\n      #include <stdio.h>\n      #include <number.h>\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        #include <dlfcn.h>\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n      int my_count() {\n        int result = get_number();\n        set_number(result + 1);\n        return result;\n      }\n\n      int main(int argc, char **argv) {\n        int result;\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        void *counter_module;\n        int (*count)(void);\n\n        counter_module = dlopen(\\\"./counter.so\\\", RTLD_LAZY | RTLD_GLOBAL);\n        if(!counter_module) goto error;\n\n        count = dlsym(counter_module, \\\"count\\\");\n        if(!count) goto error;\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n        result = count()    != 0 ? EXIT_FAILURE :\n                 my_count() != 1 ? EXIT_FAILURE :\n                 my_count() != 2 ? EXIT_FAILURE :\n                 count()    != 3 ? EXIT_FAILURE :\n                 count()    != 4 ? EXIT_FAILURE :\n                 count()    != 5 ? EXIT_FAILURE :\n                 my_count() != 6 ? EXIT_FAILURE : EXIT_SUCCESS;\n    \")\n\n    if(NOT link_exe_mod)\n      file(APPEND \"${test_project_src_dir}/main.c\" \"\n        goto done;\n        error:\n          fprintf(stderr, \\\"Error occured:\\\\n    %s\\\\n\\\", dlerror());\n          result = 1;\n\n        done:\n          if(counter_module) dlclose(counter_module);\n      \")\n    endif()\n\n    file(APPEND \"${test_project_src_dir}/main.c\" \"\n          return result;\n      }\n    \")\n\n    set(_rpath_arg)\n    if(APPLE AND ${CMAKE_VERSION} VERSION_GREATER 2.8.11)\n      set(_rpath_arg \"-DCMAKE_MACOSX_RPATH='${CMAKE_MACOSX_RPATH}'\")\n    endif()\n\n    try_compile(project_compiles\n                \"${test_project_bin_dir}\"\n                \"${test_project_src_dir}\"\n                \"${project_name}\"\n                CMAKE_FLAGS\n                  \"-DCMAKE_SHARED_LINKER_FLAGS='${CMAKE_SHARED_LINKER_FLAGS}'\"\n                  \"-DCMAKE_ENABLE_EXPORTS=ON\"\n                  ${_rpath_arg}\n                OUTPUT_VARIABLE compile_output)\n\n    set(project_works 1)\n    set(run_output)\n\n    if(project_compiles)\n      execute_process(COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR}\n                              \"${test_project_bin_dir}/main\"\n                      WORKING_DIRECTORY \"${test_project_bin_dir}\"\n                      RESULT_VARIABLE project_works\n                      OUTPUT_VARIABLE run_output\n                      ERROR_VARIABLE run_output)\n    endif()\n\n    set(test_description\n        \"Weak Link ${target_type} -> ${lib_type} (${link_flag_spec})\")\n\n    if(project_works EQUAL 0)\n      set(project_works TRUE)\n      message(STATUS \"Performing Test ${test_description} - Success\")\n    else()\n      set(project_works FALSE)\n      message(STATUS \"Performing Test ${test_description} - Failed\")\n      file(APPEND ${CMAKE_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/CMakeError.log\n           \"Performing Test ${test_description} failed with the \"\n           \"following output:\\n\"\n           \"BUILD\\n-----\\n${compile_output}\\nRUN\\n---\\n${run_output}\\n\")\n    endif()\n\n    set(${can_weak_link_var} ${project_works} PARENT_SCOPE)\n    if(project_works)\n      set(${project_name} ${link_flag} PARENT_SCOPE)\n      break()\n    endif()\n  endforeach()\nendfunction()\n\nfunction(check_dynamic_lookup)\n  # Two signatures are supported:\n\n  if(ARGC EQUAL \"1\")\n    #\n    # check_dynamic_lookup(<ResultVar>)\n    #\n    set(target_type \"MODULE\")\n    set(lib_type \"SHARED\")\n    set(has_dynamic_lookup_var \"${ARGV0}\")\n    set(link_flags_var \"unused\")\n\n  elseif(ARGC GREATER \"2\")\n    #\n    # check_dynamic_lookup(<TargetType>\n    #                      <LibType>\n    #                      <ResultVar>\n    #                      [<LinkFlagsVar>])\n    #\n    set(target_type \"${ARGV0}\")\n    set(lib_type \"${ARGV1}\")\n    set(has_dynamic_lookup_var \"${ARGV2}\")\n    if(ARGC EQUAL \"3\")\n      set(link_flags_var \"unused\")\n    else()\n      set(link_flags_var \"${ARGV3}\")\n    endif()\n  else()\n    message(FATAL_ERROR \"missing arguments\")\n  endif()\n\n  _check_dynamic_lookup(\n    ${target_type}\n    ${lib_type}\n    ${has_dynamic_lookup_var}\n    ${link_flags_var}\n    )\n  set(${has_dynamic_lookup_var} ${${has_dynamic_lookup_var}} PARENT_SCOPE)\n  if(NOT \"x${link_flags_var}x\" STREQUAL \"xunusedx\")\n    set(${link_flags_var} ${${link_flags_var}} PARENT_SCOPE)\n  endif()\nendfunction()\n\nfunction(_check_dynamic_lookup\n         target_type\n         lib_type\n         has_dynamic_lookup_var\n         link_flags_var\n         )\n\n  # hash the CMAKE_FLAGS passed and check cache to know if we need to rerun\n  if(\"${target_type}\" STREQUAL \"STATIC\")\n    string(MD5 cmake_flags_hash \"${CMAKE_STATIC_LINKER_FLAGS}\")\n  else()\n    string(MD5 cmake_flags_hash \"${CMAKE_SHARED_LINKER_FLAGS}\")\n  endif()\n\n  set(cache_var \"HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}\")\n  set(cache_hash_var \"HAS_DYNAMIC_LOOKUP_${target_type}_${lib_type}_hash\")\n  set(result_var \"DYNAMIC_LOOKUP_FLAGS_${target_type}_${lib_type}\")\n\n  if(     NOT DEFINED ${cache_hash_var}\n       OR NOT \"${${cache_hash_var}}\" STREQUAL \"${cmake_flags_hash}\")\n    unset(${cache_var} CACHE)\n  endif()\n\n  if(NOT DEFINED ${cache_var})\n    set(skip_test FALSE)\n\n   if(CMAKE_CROSSCOMPILING AND NOT CMAKE_CROSSCOMPILING_EMULATOR)\n      set(skip_test TRUE)\n    endif()\n\n    if(skip_test)\n      set(has_dynamic_lookup FALSE)\n      set(link_flags)\n    else()\n      _test_weak_link_project(${target_type}\n                              ${lib_type}\n                              has_dynamic_lookup\n                              link_flags)\n    endif()\n\n    set(caveat \" (when linking ${target_type} against ${lib_type})\")\n\n    set(${cache_var} \"${has_dynamic_lookup}\"\n        CACHE BOOL\n        \"linker supports dynamic lookup for undefined symbols${caveat}\")\n    mark_as_advanced(${cache_var})\n\n    set(${result_var} \"${link_flags}\"\n        CACHE STRING\n        \"linker flags for dynamic lookup${caveat}\")\n    mark_as_advanced(${result_var})\n\n    set(${cache_hash_var} \"${cmake_flags_hash}\"\n        CACHE INTERNAL \"hashed flags for ${cache_var} check\")\n  endif()\n\n  set(${has_dynamic_lookup_var} \"${${cache_var}}\" PARENT_SCOPE)\n  set(${link_flags_var} \"${${result_var}}\" PARENT_SCOPE)\nendfunction()\n\nfunction(target_link_libraries_with_dynamic_lookup target)\n  _get_target_type(target_type ${target})\n\n  set(link_props)\n  set(link_items)\n  set(link_libs)\n\n  foreach(lib ${ARGN})\n    _get_target_type(lib_type ${lib})\n    check_dynamic_lookup(${target_type}\n                         ${lib_type}\n                         has_dynamic_lookup\n                         dynamic_lookup_flags)\n\n    if(has_dynamic_lookup)\n      if(dynamic_lookup_flags)\n        if(\"${target_type}\" STREQUAL \"EXE\")\n          list(APPEND link_items \"${dynamic_lookup_flags}\")\n        else()\n          list(APPEND link_props \"${dynamic_lookup_flags}\")\n        endif()\n      endif()\n    elseif(${lib} MATCHES \"(debug|optimized|general)\")\n      # See gh-255\n    else()\n      list(APPEND link_libs \"${lib}\")\n    endif()\n  endforeach()\n\n  if(link_props)\n    list(REMOVE_DUPLICATES link_props)\n  endif()\n\n  if(link_items)\n    list(REMOVE_DUPLICATES link_items)\n  endif()\n\n  if(link_libs)\n    list(REMOVE_DUPLICATES link_libs)\n  endif()\n\n  if(link_props)\n    set_target_properties(${target}\n                          PROPERTIES LINK_FLAGS \"${link_props}\")\n  endif()\n\n  set(links \"${link_items}\" \"${link_libs}\")\n  if(links)\n    target_link_libraries(${target} \"${links}\")\n  endif()\nendfunction()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  debug_printf(1, \"User called dlsym(%p, %s)\\n\", handle, symbol_name);\n\n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  if(handle == RTLD_DEFAULT) {\n    return _dl_sym(RTLD_DEFAULT, symbol_name,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/test/dlopen/test_dlopen.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"gotcha/gotcha.h\"\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n#ifndef LIB_NAME_RAW\n#define LIB_NAME_RAW libnum.so\n#endif\n\n#define LIB_NAME QUOTE(LIB_NAME_RAW)\nint correct_return_four()\n{\n   return 4;\n}\n\nint return_five() \n{\n   /* Intentional bug, gotcha will correct this to return 5*/\n   return 3;\n}\n\nint correct_return_five()\n{\n   return 5;\n}\n\n\nstatic gotcha_wrappee_handle_t buggy_return_four;\nstatic gotcha_wrappee_handle_t buggy_return_five;\nstruct gotcha_binding_t funcs[] = {\n   { \"return_four\", correct_return_four, &buggy_return_four },\n   { \"return_five\", correct_return_five, &buggy_return_five }\n};\n\nint main()\n{\n   void *libnum;\n   int (*retfour)(void);\n   int (*test_retfive)(void);\n   int had_error = 0;\n   int result;\n\n   result = gotcha_wrap(funcs, 2, \"dlopen_test\");\n   if(result != GOTCHA_FUNCTION_NOT_FOUND){\n     fprintf(stderr, \"GOTCHA should have failed to find a function, but found it\\n\");\n     return -1;\n   }\n\n   libnum = dlopen(LIB_NAME, RTLD_NOW);\n   if (!libnum) {\n      fprintf(stderr, \"ERROR: Test failed to dlopen libnum.so\\n\");\n      return -1;\n   }\n\n   /* Test 1: Check if a dlsym generated indirect call gets re-routed by gotcha */\n   retfour = (int (*)(void)) dlsym(libnum, \"return_four\");\n   if (retfour() != 4) {\n      fprintf(stderr, \"ERROR: dlsym returned original function, not wrapped\\n\");\n      had_error = -1;\n   }\n\n   /* Test 2: Does a call in a dlopen'd library get rerouted by gotcha */\n   test_retfive = (int (*)(void)) dlsym(libnum, \"test_return_five\");\n   if (test_retfive() != 5) {\n      fprintf(stderr, \"ERROR: call to return_five in libnum.so was not wrapped by correct_return_five\\n\");\n      had_error = -1;\n   }\n\n   return had_error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/test/multi_agent_dlopen/dlsym.c": "/*\n *  dlsym.c  -->  libsym.so\n *\n *  Override dlsym() and replace with __libc_dlsym().\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MYNAME  \"libsym.so\"\n\ntypedef void * dlsym_fcn_t(void *, const char *);\ntypedef void * dlopen_mode_fcn_t(const char *, int);\n\ndlsym_fcn_t __libc_dlsym;\ndlopen_mode_fcn_t __libc_dlopen_mode;\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n    fprintf(stderr, \"%s:  enter dlsym:  sym = %s\\n\", MYNAME, symbol);\n\n    void * dl_handle = __libc_dlopen_mode(\"libdl.so\", RTLD_LAZY);\n\n    if (dl_handle == NULL) {\n\terr(1, \"__libc_dlopen_mode failed\");\n    }\n\n    dlsym_fcn_t * the_dlsym = __libc_dlsym(dl_handle, \"dlsym\");\n\n    if (the_dlsym == NULL) {\n\terr(1, \"__libc_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  mid   dlsym:  dlsym = %p\\n\", MYNAME, the_dlsym);\n\n#if 0\n    if (handle == RTLD_NEXT) { handle = RTLD_DEFAULT; }\n#endif\n\n    void *ans = the_dlsym(handle, symbol);\n\n    if (ans == NULL) {\n\terr(1, \"the_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  exit  dlsym:  ans = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/test/multi_agent_dlopen/monitor.c": "/*\n *  monitor.c  -->  libmon.so\n *\n *  Override dlopen() use dlsym(RTLD_NEXT).\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n#include <gotcha/gotcha.h>\n\n#define MYNAME  \"libmon.so\"\n\ntypedef void *dlopen_fcn_t(const char *, int);\n\ngotcha_wrappee_handle_t reel_dlopen_handle;\n\nvoid *\nwrap_dlopen(const char *file, int flag)\n{\n    typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n    fprintf(stderr, \"ENTER WRAP: %p\\n\", reel_dlopen);\n    fprintf(stderr, \"%s:  enter dlopen:  file = %s\\n\", MYNAME, file);\n\n    void *ans = reel_dlopen ? (reel_dlopen)(file, flag) : NULL;\n    if(!ans){\n      fprintf(stderr, \"Real dlopen not found\\n\");\n    }\n    fprintf(stderr, \"%s:  exit  dlopen:  handle = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\nvoid* opaque;\nstruct gotcha_binding_t binds[] = {\n  { \"dlopen\", wrap_dlopen, &reel_dlopen_handle}\n};\nvoid fix_things(){\n  reel_dlopen_handle = NULL;\n  gotcha_wrap(binds, 1, \"silly\");\n  typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n  fprintf(stderr, \"IMMEDIATE WRITE: %p\\n\", reel_dlopen);\n}\n__attribute__((constructor)) void startup_fix_things(){\n  fix_things(); \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/test/multi_agent_dlopen/main.c": "/*\n *  Try dlopen(libm.so, ...) and call sin().\n */\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <math.h>\n#include <stdio.h>\n\n#define MYNAME  \"main\"\n\ntypedef double sin_fcn_t(double);\n\nint\nmain(int argc, char **argv)\n{\n    sin_fcn_t *sin_fcn = NULL;\n    double val = 4.0;\n    double ans = 0.0;\n\n    fprintf(stderr, \"%s:  val = %.6f\\n\", MYNAME, val);\n\n    void *handle = dlopen(\"libm.so\", RTLD_NOW);\n    if (handle == NULL) {\n\terr(1, \"dlopen failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    sin_fcn = dlsym(handle, \"sin\");\n    if (sin_fcn == NULL) {\n\terr(1, \"dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    ans = (*sin_fcn)(val);\n\n    fprintf(stderr, \"%s:  ans = %.6f\\n\", MYNAME, ans);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/gotcha/test/multi_agent_dlopen/CMakeLists.txt": "set(CMAKE_C_FLAGS \"-g -O -fPIC\")\nadd_library(multi_agent_sym SHARED dlsym.c)\nadd_library(multi_agent_mon SHARED monitor.c)\nadd_executable(multi_agent_main main.c)\ntarget_link_libraries(multi_agent_main dl)\ntarget_link_libraries(multi_agent_mon dl gotcha)\ngotcha_add_test(multi_agent_dlopen multi_agent_main)\nenvironment_add(multi_agent_dlopen TEST \"LD_PRELOAD=${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_sym.so:${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_mon.so GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/ext/gotcha/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/docs/tools.md": "# Tools\n\n```eval_rst\n.. toctree::\n   :glob:\n   :maxdepth: 1\n\n   tools/timemory-timem/README\n   tools/timemory-avail/README\n   tools/timemory-run/README\n   tools/timemory-stubs/README\n   tools/timemory-jump/README\n   tools/timemory-mpip/README\n   tools/timemory-ncclp/README\n   tools/timemory-mallocp/README\n   tools/timemory-ompt/README\n   tools/timemory-compiler-instrument/README\n   tools/kokkos-connector/README\n```\n\nThis section covers the executables and libraries that are distributed as part of the library.\n\n- Executables\n    - [timem](tools/timemory-timem/README.md)\n        - Drop-in replacement for `time` (UNIX)\n        - For MPI applications, use `timem-mpi`\n    - [timemory-avail](tools/timemory-avail/README.md)\n        - Use this executable to query available components, available settings, and available hardware counters\n    - [timemory-run](tools/timemory-run/README.md)\n        - Use this executable (Linux-only) for dynamic instrumentation\n- Libraries\n    - [timemory-stubs](tools/timemory-stubs/README.md)\n        - Provides timemory instrumentation stubs for dynamic library preloading\n    - [timemory-jump](tools/timemory-jump/README.md)\n        - Provides timemory instrumentation via `dlopen` and `dlsym`\n    - [timemory-mpip](tools/timemory-mpip/README.md)\n        - Provide MPI profiling via GOTCHA\n    - [timemory-ncclp](tools/timemory-ncclp/README.md)\n        - Provide NCCL profiling via GOTCHA\n    - [timemory-mallocp](tools/timemory-mallocp/README.md)\n        - Records amount of memory allocated and freed on the CPU and GPU via GOTCHA wrappers around malloc, free, cudaMalloc, etc.\n    - [timemory-ompt](tools/timemory-ompt/README.md)\n        - Provide OpenMP profiling via OMPT (OpenMP Tools)\n    - [timemory-compiler-instrument](tools/timemory-compiler-instrument/README.md)\n        - Automatically instrument C and C++ source code via `-finstrument-functions` compiler flag\n    - [Kokkos Connectors](tools/kokkos-connector/README.md)\n        - Libraries for Kokkos profiling\n\n## Profiling with timemory\n\n### Instrumenting Existing Binary\n\nTimemory includes the [timemory-run](tools/timemory-run/README.md) as a full profiler for Linux systems.\nThis executable supports dynamic instrumentation (instrumenting at the target applicaiton's runtime), attaching\nto a running process, and binary re-writing (creating a new instrumented binary). The instrumented applications\nsupport flat-profiling, call-stack profiling, and timeline profiling and can be configured to use any of the\ncomponents timemory provides or, with a little work, can also be used to instrument custom components defined by the user. It is highly recommended for custom tools targetting specific functions to use the combination of\nGOTCHA and the dynamic instrumentation. Using the GOTCHA extensions for\nprofiling specific functions enables creating components which replace the function or audit the\nincoming arguments and return values for the functions and the dynamic instrumentation makes it\neasy to inject using the GOTCHA wrappers into an executable or library.\n\n### Instrumentation Binary at Compile-Time\n\nTimemory includes support for compile-time instrumentation via the\n[timemory-compiler-instrument](tools/timemory-compiler-instrument/README.md) library.\nThis form of instrumentation is available on UNIX systems and compilers which support the `-finstrument-functions`\ncompiler flag. It is generally recommended that the compiler instrumentation be propagated all the way to the\ncompilation of the executable (as opposed to only the libraries called by the executable) since finalization is\ntypically triggered when the executable returns from `main`. Failure to insert instrumentation\naround `main` may or may not result in segmentation faults.\n",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/docs/tools/timemory-jump/README.md": "# timemory-jump library\n\nThe timemory jump library implements the **jump** instrumentation mode for `timemory-run` tool. Additionally, this library can\nbe linked to in lieu of the traditional timemory library and provide instrumentation via setting the environment variable\n`TIMEMORY_JUMP_LIBRARY` on libraries which provide `dlsym` and `dlopen`.\n\n## Description\n\nThe **jump** mode is used to insert dynamic instrumentation code in an application binary using **function pointers**. The inserted function pointers dereference to the instrumentation code at runtime alleviating the risk of self instrumentation loop in case a library that is being used by instrumentation code is instrumented. For example, dynamic instrumentation of `libm` may lead to a self instrumentation loop. The **jump** instrumentation mode can be used by using the `--jump` option with `timemory-run` tool.\n\n## About timemory-run tool\n\nPlease refer to [timemory-run documentation](../timemory-run/README.md) for infomation about this tool.\n\n## Usage\n\n**NOTE:** Make sure the libtimemory-jump.so is in the `LD_LIBRARY_PATH` environment variable before running `timemory-run`.\n\n```bash\n$ timemory-run --jump [OPTIONS] -o <INSTRUMENTED_BINARY> -- <BINARY>\n```\n\n## Examples\n\n```bash\n$ timemory-run --jump -o lscpu.inst -- /usr/bin/lscpu\n\n [command]: /usr/bin/lscpu\n\ninstrumentation target: /usr/bin/lscpu\nloading library: 'libtimemory-jump.so'...\ntimemory-run: Unable to find function exit\ntimemory-run: Unable to find function MPI_Init\ntimemory-run: Unable to find function MPI_Finalize\nInstrumenting with 'timemory_push_trace' and 'timemory_pop_trace'...\nParsing module: lscpu\nDumping 'available_module_functions.txt'...\nDumping 'instrumented_module_functions.txt'...\n\nThe instrumented executable image is stored in '/home/mhaseeb/lscpu.inst'\n[timemory-run]> Getting linked libraries for /usr/bin/lscpu...\n[timemory-run]> Consider instrumenting the relevant libraries...\n\n        /lib/x86_64-linux-gnu/libsmartcols.so.1\n        /lib/x86_64-linux-gnu/libc.so.6\n        /lib64/ld-linux-x86-64.so.2\n```\n\n### Testing the instrumented binary\n```bash\n$ ./lscpu.inst\n#------------------------- tim::manager initialized [id=0][pid=12885] -------------------------#\n\n[pid=12885][tid=0][timemory_trace_init@'../source/trace.cpp':636]> rank = 0, pid = 12885, thread = 0, args = wall_clock...\nArchitecture:        x86_64\nCPU op-mode(s):      32-bit, 64-bit\nByte Order:          Little Endian\nCPU(s):              12\nOn-line CPU(s) list: 0-11\nThread(s) per core:  2\nCore(s) per socket:  6\nSocket(s):           1\nNUMA node(s):        1\nVendor ID:           GenuineIntel\nCPU family:          6\nModel:               79\nModel name:          Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz\nStepping:            1\nCPU MHz:             1204.187\nCPU max MHz:         4000.0000\nCPU min MHz:         1200.0000\nBogoMIPS:            6799.28\nVirtualization:      VT-x\nL1d cache:           32K\nL1i cache:           32K\nL2 cache:            256K\nL3 cache:            15360K\nNUMA node0 CPU(s):   0-11\nFlags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cdp_l3 invpcid_single pti intel_ppin ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdt_a rdseed adx smap intel_pt xsaveopt cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts md_clear flush_l1d\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.flamegraph.json'...\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.json'...\n[wall]|0> Outputting 'timemory-lscpu.inst-output/wall.txt'...\n/home/mhaseeb/repos/spack/opt/spack/linux-ubuntu18.04-broadwell/gcc-8.4.0/python-3.7.7-2dybrjceqs3qc4k7ci56t56bvzb4csxc/bin/python: Error while finding module specification for 'timemory.plotting' (ModuleNotFoundError: No module named 'timemory')\n[timemory]> Command: '/home/mhaseeb/repos/spack/opt/spack/linux-ubuntu18.04-broadwell/gcc-8.4.0/python-3.7.7-2dybrjceqs3qc4k7ci56t56bvzb4csxc/bin/python -m timemory.plotting -f timemory-lscpu.inst-output/wall.json -t \"wall \" -o timemory-lscpu.inst-output' returned a non-zero exit code: 256... plot/definition.hpp:77 plot generation failed\n\n|------------------------------------------------------------------------------------------------------------------------|\n|                                            REAL-CLOCK TIMER (I.E. WALL-CLOCK TIMER)                                    |\n| ---------------------------------------------------------------------------------------------------------------------- |\n|   LABEL  | COUNT    | DEPTH    | METRIC   | UNITS    | SUM      | MEAN     | MIN      | MAX      | STDDEV   | % SELF   |\n| ---------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|\n| >>> main | 1        | 0        | wall     | sec      | 0.026    | 0.026    | 0.026    | 0.026    | 0.000    | 100.0    |\n|------------------------------------------------------------------------------------------------------------------------|\n\n[metadata::manager::finalize]> Outputting 'timemory-lscpu.inst-output/metadata.json'...\n```\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/objects/pack/pack-497b453a36e542e4c0b0d0fe2e951d71a63c2e35.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/objects/pack/pack-497b453a36e542e4c0b0d0fe2e951d71a63c2e35.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/source/tests/external/nccl-tests/objects/pack/pack-54cfaf49a0b6c11512a71a89c51e661795d73b7d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/source/tests/external/nccl-tests/objects/pack/pack-54cfaf49a0b6c11512a71a89c51e661795d73b7d.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/llvm-ompt/objects/pack/pack-eef35224abc65044ae2ddd373cad8c27deab765e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/llvm-ompt/objects/pack/pack-eef35224abc65044ae2ddd373cad8c27deab765e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/line-profiler/objects/pack/pack-c45dc11444fc3e4368a0ac45d7b32623f820fbb9.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/line-profiler/objects/pack/pack-c45dc11444fc3e4368a0ac45d7b32623f820fbb9.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/hatchet/objects/pack/pack-ddaaf9be7f35592530d616a1c71313621ebd7616.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/hatchet/objects/pack/pack-ddaaf9be7f35592530d616a1c71313621ebd7616.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/gotcha/objects/pack/pack-51e0ef4d00429036785c48d7a858aaedade72d39.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/google-test/objects/pack/pack-ddb9da44d637ad7530b6ec1f9133d963b6c09cf3.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/google-test/objects/pack/pack-ddb9da44d637ad7530b6ec1f9133d963b6c09cf3.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/pybind11/objects/pack/pack-075ad05d3dd551f84af905ed4628f28821559509.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/pybind11/objects/pack/pack-075ad05d3dd551f84af905ed4628f28821559509.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/caliper/objects/pack/pack-6440cefe96e52a05767a367f0153c763f4737b4e.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/PTL/objects/pack/pack-d424a65a65dbda764d6883765baedfc02374c15a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/.git/modules/external/PTL/objects/pack/pack-d424a65a65dbda764d6883765baedfc02374c15a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/runtime/doc/Reference.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/llvm-ompt/www/Reference.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/logo-hex.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/cprofile-hatchet-pstats/cprofile-cycle-py2.pstats",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/cprofile-hatchet-pstats/cprofile-cycle.pstats",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-cpi-database/1.cpi-000001-000-a8c00270-160444-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-cpi-database/1.cpi-000002-000-a8c00270-160445-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-cpi-database/1.cpi-000000-000-a8c00270-160443-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-cpi-database/1.cpi-000003-000-a8c00270-160446-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000007-001-a8c00471-152584-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000003-001-a8c00471-152580-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000001-001-a8c00471-152578-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000006-001-a8c00471-152583-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000004-000-a8c00471-152581-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000005-001-a8c00471-152582-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000008-001-a8c00471-152585-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000009-000-a8c00471-152586-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000002-001-a8c00471-152579-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000007-000-a8c00471-152584-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000008-000-a8c00471-152585-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000005-000-a8c00471-152582-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000004-001-a8c00471-152581-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000003-000-a8c00471-152580-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000002-000-a8c00471-152579-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000000-000-a8c00471-152577-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000009-001-a8c00471-152586-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000006-000-a8c00471-152583-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000000-001-a8c00471-152577-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/hatchet/tests/data/hpctoolkit-allgather-database/1.osu_allgather-000001-000-a8c00471-152578-0.metric-db",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/jupyter-query-filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/lulesh-diff-df.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/diff-graph1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/strong-scale-graph3.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/lulesh-mpi.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/diff-graph3.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/jupyter-tree-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/diff-graph2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/lulesh-line-plot.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/query-dataframe.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/strong-scale-graph2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/vis-flamegraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/lulesh-load-imb.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/scale-offset-df.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/lulesh-plot.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/weak-scale-graph3.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/weak-scale-graph1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/strong-scale-graph1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/sample-dataframe.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/flat-function.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/filter-dataframe.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/weak-scale-graph2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/sample-graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/vis-terminal.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/squash-graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/vis-dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/05-tree-inc-time.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/09-dataframe-drop-index-levels.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/11-graphframe-squash.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/13-divide-graphframes.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/01-dataframe.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/07-tree-invert-colormap.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/03-dataframe-sorted.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/04-dataframe-with-new-column.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/06-tree-depth.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/10-graphframe-filter.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/12-lulesh-64cores.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/08-dataframe-index-levels.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/basic-tutorial/02-tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/tutorial-output/caliper-cali-dataframe.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/hatchet/docs/images/tutorial-output/caliper-cali-graph.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/ptl/examples/extended/rotation/data/cameraman.tif",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/pybind11/docs/pybind11_vs_boost_python1.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/pybind11/docs/pybind11-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/pybind11/docs/pybind11_vs_boost_python2.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/src/mpi/services/mpit/mpitdesign/design.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/src/mpi/services/mpit/mpitdesign/caliper.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/doc/sphinx/caliper-services-workflow.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/external/caliper/doc/sphinx/caliper-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/docs/components/mpi_macro_dp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/docs/components/work_macro_sp_roofline.png",
        "/tmp/vanessa/spack-stage/spack-stage-timemory-develop-22f2t7cgyasmazjkmojcucgty4ptwuuh/spack-src/docs/getting_started/roofline.jpg"
    ],
    "total_files": 3058
}