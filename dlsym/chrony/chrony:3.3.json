{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-chrony-3.3-5rxu5grjixk6ocyyx3tyuqerdu7vyfko/spack-src/sys_macosx.c": "/*\n  chronyd/chronyc - Programs for keeping computer clocks accurate.\n\n **********************************************************************\n * Copyright (C) Richard P. Curnow  1997-2001\n * Copyright (C) J. Hannken-Illjes  2001\n * Copyright (C) Bryan Christianson  2015, 2017\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of version 2 of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n **********************************************************************\n\n  =======================================================================\n\n  Driver file for the macOS operating system.\n\n  */\n\n#include \"config.h\"\n\n#ifdef MACOSX\n\n#include \"sysincl.h\"\n\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n#include <pthread.h>\n\n#include \"sys_macosx.h\"\n#include \"conf.h\"\n#include \"local.h\"\n#include \"localp.h\"\n#include \"logging.h\"\n#include \"sched.h\"\n#include \"privops.h\"\n#include \"util.h\"\n\n#ifdef HAVE_MACOS_SYS_TIMEX\n#include <dlfcn.h>\n#include \"sys_netbsd.h\"\n#include \"sys_timex.h\"\n\nstatic int have_ntp_adjtime = 0;\nstatic int have_bad_adjtime = 0;\n#endif\n\n/* ================================================== */\n\n/* This register contains the number of seconds by which the local\n   clock was estimated to be fast of reference time at the epoch when\n   LCL_ReadRawTime() returned T0 */\n\nstatic double offset_register;\n\n/* This register contains the epoch to which the offset is referenced */\n\nstatic struct timespec T0;\n\n/* This register contains the current estimate of the system\n   frequency, in absolute (NOT ppm) */\n\nstatic double current_freq;\n\n/* This register contains the number of seconds of adjustment that\n   were passed to adjtime last time it was called. */\n\nstatic double adjustment_requested;\n\n/* Interval in seconds between adjustments to cancel systematic drift */\n\n#define DRIFT_REMOVAL_INTERVAL (4.0)\n#define DRIFT_REMOVAL_INTERVAL_MIN (0.5)\n\n/* If current_drift_removal_interval / drift_removal_interval exceeds this\n   ratio, then restart the drift removal timer */\n\n#define DRIFT_REMOVAL_RESTART_RATIO (8.0)\n\nstatic double drift_removal_interval;\nstatic double current_drift_removal_interval;\nstatic struct timespec Tdrift;\n\n/* weighting applied to error in calculating drift_removal_interval */\n#define ERROR_WEIGHT (0.5)\n\n/* minimum resolution of current_frequency */\n#define FREQUENCY_RES (1.0e-9)\n\n#define NANOS_PER_MSEC (1000000ULL)\n\n/* RTC synchronisation - once an hour */\n\nstatic struct timespec last_rtc_sync;\n#define RTC_SYNC_INTERVAL (60 * 60.0)\n\n/* ================================================== */\n\nstatic void\nclock_initialise(void)\n{\n  struct timeval newadj, oldadj;\n\n  offset_register = 0.0;\n  adjustment_requested = 0.0;\n  current_freq = 0.0;\n  drift_removal_interval = DRIFT_REMOVAL_INTERVAL;\n  current_drift_removal_interval = DRIFT_REMOVAL_INTERVAL;\n\n  LCL_ReadRawTime(&T0);\n  Tdrift = T0;\n  last_rtc_sync = T0;\n\n  newadj.tv_sec = 0;\n  newadj.tv_usec = 0;\n\n  if (PRV_AdjustTime(&newadj, &oldadj) < 0) {\n    LOG_FATAL(\"adjtime() failed\");\n  }\n}\n\n/* ================================================== */\n\nstatic void\nclock_finalise(void)\n{\n  /* Nothing to do yet */\n}\n\n/* ================================================== */\n\nstatic void\nstart_adjust(void)\n{\n  struct timeval newadj, oldadj;\n  struct timespec T1;\n  double elapsed, accrued_error, predicted_error, drift_removal_elapsed;\n  double adjust_required;\n  double rounding_error;\n  double old_adjust_remaining;\n\n  /* Determine the amount of error built up since the last adjustment */\n  LCL_ReadRawTime(&T1);\n\n  elapsed = UTI_DiffTimespecsToDouble(&T1, &T0);\n  accrued_error = elapsed * current_freq;\n\n  drift_removal_elapsed = UTI_DiffTimespecsToDouble(&T1, &Tdrift);\n\n  /* To allow for the clock being stepped either forward or backwards, clamp\n     the elapsed time to bounds [ 0.0, current_drift_removal_interval ] */\n  drift_removal_elapsed = MIN(MAX(0.0, drift_removal_elapsed), current_drift_removal_interval);\n\n  predicted_error = (current_drift_removal_interval - drift_removal_elapsed) / 2.0 * current_freq;\n\n  DEBUG_LOG(\"drift_removal_elapsed: %.3f current_drift_removal_interval: %.3f predicted_error: %.3f\",\n            1.0e6 * drift_removal_elapsed, 1.0e6 * current_drift_removal_interval,\n            1.0e6 * predicted_error);\n\n  adjust_required = - (accrued_error + offset_register + predicted_error);\n\n  UTI_DoubleToTimeval(adjust_required, &newadj);\n  adjustment_requested = UTI_TimevalToDouble(&newadj);\n  rounding_error = adjust_required - adjustment_requested;\n\n  if (PRV_AdjustTime(&newadj, &oldadj) < 0) {\n    LOG_FATAL(\"adjtime() failed\");\n  }\n\n  old_adjust_remaining = UTI_TimevalToDouble(&oldadj);\n\n  offset_register = rounding_error - old_adjust_remaining - predicted_error;\n\n  T0 = T1;\n}\n\n/* ================================================== */\n\nstatic void\nstop_adjust(void)\n{\n  struct timespec T1;\n  struct timeval zeroadj, remadj;\n  double adjustment_remaining, adjustment_achieved;\n  double elapsed, elapsed_plus_adjust;\n\n  zeroadj.tv_sec = 0;\n  zeroadj.tv_usec = 0;\n\n  if (PRV_AdjustTime(&zeroadj, &remadj) < 0) {\n    LOG_FATAL(\"adjtime() failed\");\n  }\n\n  LCL_ReadRawTime(&T1);\n\n  elapsed = UTI_DiffTimespecsToDouble(&T1, &T0);\n  adjustment_remaining = UTI_TimevalToDouble(&remadj);\n\n  adjustment_achieved = adjustment_requested - adjustment_remaining;\n  elapsed_plus_adjust = elapsed - adjustment_achieved;\n\n  offset_register += current_freq * elapsed_plus_adjust - adjustment_remaining;\n\n  adjustment_requested = 0.0;\n  T0 = T1;\n}\n\n/* ================================================== */\n\n/* Positive offset means system clock is fast of true time, therefore\n   slew backwards */\n\nstatic void\naccrue_offset(double offset, double corr_rate)\n{\n  stop_adjust();\n  offset_register += offset;\n  start_adjust();\n}\n\n/* ================================================== */\n\n/* Positive offset means system clock is fast of true time, therefore\n   step backwards */\n\nstatic int\napply_step_offset(double offset)\n{\n  struct timespec old_time, new_time, T1;\n  struct timeval new_time_tv;\n\n  stop_adjust();\n\n  LCL_ReadRawTime(&old_time);\n\n  UTI_AddDoubleToTimespec(&old_time, -offset, &new_time);\n  UTI_TimespecToTimeval(&new_time, &new_time_tv);\n\n  if (PRV_SetTime(&new_time_tv, NULL) < 0) {\n    DEBUG_LOG(\"settimeofday() failed\");\n    return 0;\n  }\n\n  UTI_AddDoubleToTimespec(&T0, -offset, &T1);\n  T0 = T1;\n\n  start_adjust();\n\n  return 1;\n}\n\n/* ================================================== */\n\nstatic double\nset_frequency(double new_freq_ppm)\n{\n  stop_adjust();\n  current_freq = new_freq_ppm * 1.0e-6;\n  start_adjust();\n\n  return current_freq * 1.0e6;\n}\n\n/* ================================================== */\n\nstatic double\nread_frequency(void)\n{\n  return current_freq * 1.0e6;\n}\n\n/* ================================================== */\n\nstatic void\nget_offset_correction(struct timespec *raw,\n                      double *corr, double *err)\n{\n  stop_adjust();\n  *corr = -offset_register;\n  start_adjust();\n  if (err)\n    *err = 0.0;\n}\n\n/* ================================================== */\n\n/* Cancel systematic drift */\n\nstatic SCH_TimeoutID drift_removal_id;\n\n/* ================================================== */\n/* This is the timer callback routine which is called periodically to\n invoke a time adjustment to take out the machine's drift.\n Otherwise, times reported through this software (e.g. by running\n ntpdate from another machine) show the machine being correct (since\n they correct for drift build-up), but any program on this machine\n that reads the system time will be given an erroneous value, the\n degree of error depending on how long it is since\n get_offset_correction was last called. */\n\nstatic void\ndrift_removal_timeout(SCH_ArbitraryArgument not_used)\n{\n\n  stop_adjust();\n\n  LCL_ReadRawTime(&Tdrift);\n\n  current_drift_removal_interval = drift_removal_interval;\n\n  start_adjust();\n\n  drift_removal_id = SCH_AddTimeoutByDelay(drift_removal_interval, drift_removal_timeout, NULL);\n}\n\n/* ================================================== */\n\n/* use est_error to calculate the drift_removal_interval and\n   update the RTC */\n\nstatic void\nset_sync_status(int synchronised, double est_error, double max_error)\n{\n  double interval;\n\n  if (!synchronised) {\n    drift_removal_interval = MAX(drift_removal_interval, DRIFT_REMOVAL_INTERVAL);\n  } else {\n    if (CNF_GetRtcSync()) {\n      struct timespec now;\n      double rtc_sync_elapsed;\n\n      SCH_GetLastEventTime(NULL, NULL, &now);\n      rtc_sync_elapsed = UTI_DiffTimespecsToDouble(&now, &last_rtc_sync);\n      if (fabs(rtc_sync_elapsed) >= RTC_SYNC_INTERVAL) {\n        /* update the RTC by applying a step of 0.0 secs */\n        apply_step_offset(0.0);\n        last_rtc_sync = now;\n        DEBUG_LOG(\"rtc synchronised\");\n      }\n    }\n\n    interval = ERROR_WEIGHT * est_error / (fabs(current_freq) + FREQUENCY_RES);\n    drift_removal_interval = MAX(interval, DRIFT_REMOVAL_INTERVAL_MIN);\n\n    DEBUG_LOG(\"est_error: %.3f current_freq: %.3f est drift_removal_interval: %.3f act drift_removal_interval: %.3f\",\n                est_error * 1.0e6, current_freq * 1.0e6, interval, drift_removal_interval);\n  }\n\n  if (current_drift_removal_interval / drift_removal_interval > DRIFT_REMOVAL_RESTART_RATIO) {\n    /* recover from a large est_error by resetting the timer */\n    SCH_ArbitraryArgument unused;\n    SCH_RemoveTimeout(drift_removal_id);\n    unused = NULL;\n    drift_removal_timeout(unused);\n  }\n}\n\n/* ================================================== */\n/*\n  Give chronyd real time priority so that time critical calculations\n  are not pre-empted by the kernel.\n*/\n\nstatic int\nset_realtime(void)\n{\n  /* https://developer.apple.com/library/ios/technotes/tn2169/_index.html */\n\n  mach_timebase_info_data_t timebase_info;\n  double clock2abs;\n  thread_time_constraint_policy_data_t policy;\n  int kr;\n\n  mach_timebase_info(&timebase_info);\n  clock2abs = ((double)timebase_info.denom / (double)timebase_info.numer) * NANOS_PER_MSEC;\n\n  policy.period = 0;\n  policy.computation = (uint32_t)(5 * clock2abs); /* 5 ms of work */\n  policy.constraint = (uint32_t)(10 * clock2abs);\n  policy.preemptible = 0;\n\n  kr = thread_policy_set(\n          pthread_mach_thread_np(pthread_self()),\n          THREAD_TIME_CONSTRAINT_POLICY,\n          (thread_policy_t)&policy,\n          THREAD_TIME_CONSTRAINT_POLICY_COUNT);\n\n  if (kr != KERN_SUCCESS) {\n    LOG(LOGS_WARN, \"Cannot set real-time priority: %d\", kr);\n    return -1;\n  }\n  return 0;\n}\n\n/* ================================================== */\n\nvoid\nSYS_MacOSX_SetScheduler(int SchedPriority)\n{\n  if (SchedPriority) {\n    set_realtime();\n  }\n}\n\n/* ================================================== */\n\n#ifdef FEAT_PRIVDROP\nvoid SYS_MacOSX_DropRoot(uid_t uid, gid_t gid)\n{\n  PRV_StartHelper();\n\n  UTI_DropRoot(uid, gid);\n}\n#endif\n\n/* ================================================== */\n\nstatic void\nlegacy_MacOSX_Initialise(void)\n{\n  clock_initialise();\n\n  lcl_RegisterSystemDrivers(read_frequency, set_frequency,\n                            accrue_offset, apply_step_offset,\n                            get_offset_correction,\n                            NULL /* set_leap */,\n                            set_sync_status);\n\n\n  drift_removal_id = SCH_AddTimeoutByDelay(drift_removal_interval, drift_removal_timeout, NULL);\n}\n\n/* ================================================== */\n\nstatic void\nlegacy_MacOSX_Finalise(void)\n{\n  SCH_RemoveTimeout(drift_removal_id);\n\n  clock_finalise();\n}\n\n/* ================================================== */\n\n#ifdef HAVE_MACOS_SYS_TIMEX\n/*\n    Test adjtime() to see if Apple have fixed the signed/unsigned bug\n*/\nstatic int\ntest_adjtime()\n{\n  struct timeval tv1 = {-1, 0};\n  struct timeval tv2 = {0, 0};\n  struct timeval tv;\n\n  if (PRV_AdjustTime(&tv1, &tv) != 0) {\n    return 0;\n  }\n  if (PRV_AdjustTime(&tv2, &tv) != 0) {\n    return 0;\n  }\n  if (tv.tv_sec < -1 || tv.tv_sec > 1) {\n    return 0;\n  }\n  return 1;\n}\n#endif\n\n/* ================================================== */\n\nvoid\nSYS_MacOSX_Initialise(void)\n{\n#ifdef HAVE_MACOS_SYS_TIMEX\n  have_ntp_adjtime = (dlsym(RTLD_NEXT, \"ntp_adjtime\") != NULL);\n  if (have_ntp_adjtime) {\n    have_bad_adjtime = !test_adjtime();\n    if (have_bad_adjtime) {\n      LOG(LOGS_WARN, \"adjtime() is buggy - using timex driver\");\n      SYS_Timex_Initialise();\n    } else {\n      SYS_NetBSD_Initialise();\n    }\n    return;\n  }\n#endif\n  legacy_MacOSX_Initialise();\n}\n\n/* ================================================== */\n\nvoid\nSYS_MacOSX_Finalise(void)\n{\n#ifdef HAVE_MACOS_SYS_TIMEX\n  if (have_ntp_adjtime) {\n    if (have_bad_adjtime) {\n      SYS_Timex_Finalise();\n    } else {\n      SYS_NetBSD_Finalise();\n    }\n    return;\n  }\n#endif\n  legacy_MacOSX_Finalise();\n}\n\n#endif\n"
    },
    "skipped": [],
    "total_files": 143
}