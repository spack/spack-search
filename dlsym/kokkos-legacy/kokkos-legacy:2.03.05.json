{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.03.05-7se5hglvnohyeanlodqlk6u2snkei64x/spack-src/core/src/impl/Kokkos_Profiling_Interface.cpp": "/*\n //@HEADER\n // ************************************************************************\n //\n //                        Kokkos v. 2.0\n //              Copyright (2014) Sandia Corporation\n //\n // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n // the U.S. Government retains certain rights in this software.\n //\n // Redistribution and use in source and binary forms, with or without\n // modification, are permitted provided that the following conditions are\n // met:\n //\n // 1. Redistributions of source code must retain the above copyright\n // notice, this list of conditions and the following disclaimer.\n //\n // 2. Redistributions in binary form must reproduce the above copyright\n // notice, this list of conditions and the following disclaimer in the\n // documentation and/or other materials provided with the distribution.\n //\n // 3. Neither the name of the Corporation nor the names of the\n // contributors may be used to endorse or promote products derived from\n // this software without specific prior written permission.\n //\n // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n //\n // Questions? Contact  H. Carter Edwards (hcedwar@sandia.gov)\n //\n // ************************************************************************\n //@HEADER\n */\n\n#include <Kokkos_Macros.hpp>\n#if defined(KOKKOS_ENABLE_PROFILING)\n\n#include <impl/Kokkos_Profiling_Interface.hpp>\n#include <cstring>\n\nnamespace Kokkos {\nnamespace Profiling {\n\nSpaceHandle::SpaceHandle(const char* space_name) {\n  strncpy(name,space_name,64);\n}\n\nbool profileLibraryLoaded() {\n  return (NULL != initProfileLibrary);\n}\n\nvoid beginParallelFor(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(NULL != beginForCallee) {\n    Kokkos::fence();\n    (*beginForCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelFor(const uint64_t kernelID) {\n  if(NULL != endForCallee) {\n    Kokkos::fence();\n    (*endForCallee)(kernelID);\n  }\n}\n\nvoid beginParallelScan(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(NULL != beginScanCallee) {\n    Kokkos::fence();\n    (*beginScanCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelScan(const uint64_t kernelID) {\n  if(NULL != endScanCallee) {\n    Kokkos::fence();\n    (*endScanCallee)(kernelID);\n  }\n}\n\nvoid beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID, uint64_t* kernelID) {\n  if(NULL != beginReduceCallee) {\n    Kokkos::fence();\n    (*beginReduceCallee)(kernelPrefix.c_str(), devID, kernelID);\n  }\n}\n\nvoid endParallelReduce(const uint64_t kernelID) {\n  if(NULL != endReduceCallee) {\n    Kokkos::fence();\n    (*endReduceCallee)(kernelID);\n  }\n}\n\n\nvoid pushRegion(const std::string& kName) {\n  if( NULL != pushRegionCallee ) {\n    Kokkos::fence();\n    (*pushRegionCallee)(kName.c_str());\n  }\n}\n\nvoid popRegion() {\n  if( NULL != popRegionCallee ) {\n    Kokkos::fence();\n    (*popRegionCallee)();\n  }\n}\n\nvoid allocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n  if(NULL != allocateDataCallee) {\n    (*allocateDataCallee)(space,label.c_str(),ptr,size);\n  }\n}\n\nvoid deallocateData(const SpaceHandle space, const std::string label, const void* ptr, const uint64_t size) {\n  if(NULL != allocateDataCallee) {\n    (*deallocateDataCallee)(space,label.c_str(),ptr,size);\n  }\n}\n\nvoid initialize() {\n\n  // Make sure initialize calls happens only once\n  static int is_initialized = 0;\n  if(is_initialized) return;\n  is_initialized = 1;\n\n  void* firstProfileLibrary;\n\n  char* envProfileLibrary  = getenv(\"KOKKOS_PROFILE_LIBRARY\");\n\n  // If we do not find a profiling library in the environment then exit\n  // early.\n  if( NULL == envProfileLibrary ) {\n    return ;\n  }\n\n  char* envProfileCopy = (char*) malloc(sizeof(char) * (strlen(envProfileLibrary) + 1));\n  sprintf(envProfileCopy, \"%s\", envProfileLibrary);\n\n  char* profileLibraryName = strtok(envProfileCopy, \";\");\n\n  if( (NULL != profileLibraryName) && (strcmp(profileLibraryName, \"\") != 0) ) {\n    firstProfileLibrary = dlopen(profileLibraryName, RTLD_NOW | RTLD_GLOBAL);\n\n    if(NULL == firstProfileLibrary) {\n      std::cerr << \"Error: Unable to load KokkosP library: \" <<\n        profileLibraryName << std::endl;\n    } else {\n#ifdef KOKKOS_ENABLE_PROFILING_LOAD_PRINT\n      std::cout << \"KokkosP: Library Loaded: \" << profileLibraryName << std::endl;\n#endif\n\n      // dlsym returns a pointer to an object, while we want to assign to pointer to function\n      // A direct cast will give warnings hence, we have to workaround the issue by casting pointer to pointers.\n      auto p1 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_for\");\n      beginForCallee = *((beginFunction*) &p1);\n      auto p2 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_scan\");\n      beginScanCallee = *((beginFunction*) &p2);\n      auto p3 = dlsym(firstProfileLibrary, \"kokkosp_begin_parallel_reduce\");\n      beginReduceCallee = *((beginFunction*) &p3);\n\n      auto p4 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_scan\");\n      endScanCallee = *((endFunction*) &p4);\n      auto p5 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_for\");\n      endForCallee = *((endFunction*) &p5);\n      auto p6 = dlsym(firstProfileLibrary, \"kokkosp_end_parallel_reduce\");\n      endReduceCallee = *((endFunction*) &p6);\n\n      auto p7 = dlsym(firstProfileLibrary, \"kokkosp_init_library\");\n      initProfileLibrary = *((initFunction*) &p7);\n      auto p8 = dlsym(firstProfileLibrary, \"kokkosp_finalize_library\");\n      finalizeProfileLibrary = *((finalizeFunction*) &p8);\n\n      auto p9 = dlsym(firstProfileLibrary, \"kokkosp_push_profile_region\");\n      pushRegionCallee = *((pushFunction*) &p9);\n      auto p10 = dlsym(firstProfileLibrary, \"kokkosp_pop_profile_region\");\n      popRegionCallee = *((popFunction*) &p10);\n\n      auto p11 = dlsym(firstProfileLibrary, \"kokkosp_allocate_data\");\n      allocateDataCallee = *((allocateDataFunction*) &p11);\n      auto p12 = dlsym(firstProfileLibrary, \"kokkosp_deallocate_data\");\n      deallocateDataCallee = *((deallocateDataFunction*) &p12);\n\n    }\n  }\n\n  if(NULL != initProfileLibrary) {\n    (*initProfileLibrary)(0,\n        (uint64_t) KOKKOSP_INTERFACE_VERSION,\n        (uint32_t) 0,\n        NULL);\n  }\n\n  free(envProfileCopy);\n}\n\nvoid finalize() {\n  // Make sure finalize calls happens only once\n  static int is_finalized = 0;\n  if(is_finalized) return;\n  is_finalized = 1;\n\n  if(NULL != finalizeProfileLibrary) {\n    (*finalizeProfileLibrary)();\n\n    // Set all profile hooks to NULL to prevent\n    // any additional calls. Once we are told to\n    // finalize, we mean it\n    initProfileLibrary = NULL;\n    finalizeProfileLibrary = NULL;\n\n    beginForCallee = NULL;\n    beginScanCallee = NULL;\n    beginReduceCallee = NULL;\n    endScanCallee = NULL;\n    endForCallee = NULL;\n    endReduceCallee = NULL;\n\n    pushRegionCallee = NULL;\n    popRegionCallee = NULL;\n\n    allocateDataCallee = NULL;\n    deallocateDataCallee = NULL;\n\n  }\n}\n}\n}\n\n#else\nvoid KOKKOS_CORE_SRC_IMPL_PROFILING_INTERFACE_PREVENT_LINK_ERROR() {}\n#endif\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kokkos-legacy-2.03.05-7se5hglvnohyeanlodqlk6u2snkei64x/spack-src/doc/Kokkos_PG.pdf"
    ],
    "total_files": 652
}