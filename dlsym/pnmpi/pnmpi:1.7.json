{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pnmpi-1.7-4mubdeexdagwkt5wrvoolxpq52e7nwme/spack-src/src/pnmpi/core.h": "/* This file is part of P^nMPI.\n *\n * Copyright (c)\n *  2008-2017 Lawrence Livermore National Laboratories, United States of America\n *  2011-2017 ZIH, Technische Universitaet Dresden, Federal Republic of Germany\n *  2013-2017 RWTH Aachen University, Federal Republic of Germany\n *\n *\n * P^nMPI is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation version 2.1 dated February 1999.\n *\n * P^nMPI is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with P^nMPI; if not, write to the\n *\n *   Free Software Foundation, Inc.\n *   51 Franklin St, Fifth Floor\n *   Boston, MA 02110, USA\n *\n *\n * Written by Martin Schulz, schulzm@llnl.gov.\n *\n * LLNL-CODE-402774\n */\n\n#ifndef PNMPI_CORE_H\n#define PNMPI_CORE_H\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define PNMPI_IMPLEMENTATION\n\n#include \"pnmpi.h\"\n#include \"pnmpimod.h\"\n#include <mpi.h>\n\n#include \"wrapper.h\"\n#include <pnmpi/private/tls.h>\n\n\n/* Private Interface for PNMPI */\n\n#define NUM_MPI_CALLS 300\n\n#define MODULE_SKIP 20\n#define MAX_ARG_NAME 30\n#define MAX_ARG_VALUE 2048\n#define MAX_LINE MAX_ARG_VALUE + MAX_ARG_NAME\n/*Was once: (2*PNMPI_MODULE_FILENAMELEN), needs to be long for some projects\n * ...*/\n\n#define MAX_CMDARGS 10\n\n\n#define PNMPI_PCONTROL_SINGLEorMULTIPLE 0x1\n#define PNMPI_PCONTROL_VARGorPTR 0x2\n#define PNMPI_PCONTROL_SINGLEorMULTIPLEERROR 0x4\n\n#define CONFNAME \".pnmpi-conf\"\n\n\ntypedef char module_name_t[PNMPI_MODULE_FILENAMELEN];\n\ntypedef struct module_servlist_d *module_servlist_p;\ntypedef struct module_servlist_d\n{\n  PNMPI_Service_descriptor_t desc;\n  module_servlist_p next;\n} module_servlist_t;\n\ntypedef struct module_globlist_d *module_globlist_p;\ntypedef struct module_globlist_d\n{\n  PNMPI_Global_descriptor_t desc;\n  module_globlist_p next;\n} module_globlist_t;\n\ntypedef struct module_arg_d *module_arg_p;\ntypedef struct module_arg_d\n{\n  char name[MAX_ARG_NAME];\n  char value[MAX_ARG_VALUE];\n  module_arg_p next;\n} module_arg_t;\n\ntypedef struct module_def_d *module_def_p;\ntypedef struct module_def_d\n{\n  char name[PNMPI_MODULE_FILENAMELEN - 4];\n  module_name_t path;\n  char username[PNMPI_MODULE_USERNAMELEN];\n  int registered;\n  void *handle;\n  module_arg_p args;\n  int pcontrol;\n  module_servlist_p services;\n  module_globlist_p globals;\n  int stack_delimiter;\n} module_def_t;\n\ntypedef struct modules_d\n{\n  int num;\n  int numalloc;\n  int pcontrol;\n  int pcontrol_typed_level;\n  int pcontrol_typed_type;\n  module_def_p *module;\n} modules_t;\n\nextern modules_t modules;\n\n// extern int pnmpi_level;\nextern int pnmpi_mpi_level; /**< Is used to control recursive wrapping of MPI\n                               calls, right now we only use it for MPI_X calls\n                               that are triggered be MPI_Finalize (as these\n                               really hurt as we shut down our tools already in\n                               that case).*/\n\n/** \\brief \\ref pnmpi_level is used to store the current level of MPI calls.\n */\nextern pnmpi_compiler_tls_keyword int pnmpi_level;\nextern pnmpi_compiler_tls_keyword int initial_thread;\n\nextern int pnmpi_max_level;\nextern int pnmpi_initialization_complete;\nextern int pnmpi_init_done;\n\nvoid pnmpi_PreInit(void);\n\nextern int iargc_(void);\nextern char *getarg_(int *, char *, int);\n\n// bit vector implementation for determining which functions are activated\n#define NUM_MPI_CELLS (NUM_MPI_CALLS / sizeof(pnmpi_cell_t) + 1)\ntypedef uintptr_t pnmpi_cell_t;\nextern pnmpi_cell_t pnmpi_activated[NUM_MPI_CELLS];\nextern pnmpi_functions_t pnmpi_function_ptrs;\n\n#define CELL_INDEX(id) (id / (sizeof(pnmpi_cell_t) * 8))\n#define CELL_BMASK(id) (((pnmpi_cell_t)1) << (id % (sizeof(pnmpi_cell_t) * 8)))\n#define IS_ACTIVATED(id) (pnmpi_activated[CELL_INDEX(id)] & CELL_BMASK(id))\n#define SET_ACTIVATED(id) pnmpi_activated[CELL_INDEX(id)] |= CELL_BMASK(id)\n#define NOT_ACTIVATED(id) (!IS_ACTIVATED(id))\n\nvoid *find_symbol(const module_def_p module, const char *symbol_name);\n\nvoid pnmpi_print_banner(void);\n\n\n// Helper to check for RTLDNEXT Availability\n/**\n * Rational on RTLDNEXT usage:\n * If a module has a dependency to the MPI libs (which makes sense as it uses\n * MPI symbols),\n * a call to dlsym on this module will either return the modules own MPI wrapper\n * for the call (if present) or\n * the MPI call implementation in the MPI library. In our\n * INITIALIZE_FUNCTION_STACK macro however,\n * we are only interested in MPI calls within the module (i.e. wrappers), not\n * any symbols of the original\n * MPI library (i.e. implementations). With that, modules must not have MPI\n * dependencies, which sometimes makes\n * your live a bit harder. So we provide a mechanism that uses RTLD_NEXT to\n * check what\n * the symbol of a respective call is in the MPI lib, with that we can check\n * whether a dlsym\n * call on a module returned a wrapper function or just a function in the MPI\n * lib, if the later\n * happens we do not mark the module as having a wrapper for this function.\n *\n * Note: RTLD_NEXT is unfortunately not available everywhere, thats why we use\n * the templates below.\n */\n#ifdef RTLD_NEXT\n#define RTLDNEXT_RETRIEVAL(r_type, routine) \\\n  r_type __tmp_function_ptr = (r_type)dlsym(RTLD_NEXT, routine);\n#define RTLDNEXT_CHECK(stack) pnmpi_function_ptrs.stack[i] != __tmp_function_ptr\n#else\n#define RTLDNEXT_RETRIEVAL(r_type, routine)\n#define RTLDNEXT_CHECK(stack) 1\n#endif\n\n// actual stack initialization macro\n#define INITIALIZE_FUNCTION_STACK(routine, routine_id, r_type, stack, mods, \\\n                                  mpiroutine)                               \\\n  {                                                                         \\\n    int i;                                                                  \\\n    DBGPRINT2(\"Initialize stack for %s\\n\", routine);                        \\\n    if (pnmpi_function_ptrs.stack == NULL)                                  \\\n      {                                                                     \\\n        pnmpi_function_ptrs.stack =                                         \\\n          (r_type *)malloc(mods.num * sizeof(r_type));                      \\\n      }                                                                     \\\n    if (pnmpi_function_ptrs.stack == NULL)                                  \\\n      {                                                                     \\\n        WARNPRINT(\"Can't allocate stack for (%i) - exiting\", routine_id);   \\\n        exit(1);                                                            \\\n      }                                                                     \\\n    for (i = 0; i < mods.num; i++)                                          \\\n      {                                                                     \\\n        if (mods.module[i]->stack_delimiter)                                \\\n          continue;                                                         \\\n        pnmpi_function_ptrs.stack[i] =                                      \\\n          (r_type)find_symbol(mods.module[i], routine);                     \\\n        RTLDNEXT_RETRIEVAL(r_type, routine)                                 \\\n        WRAP_MPI_CALL_PREFIX                                                \\\n        if (pnmpi_function_ptrs.stack[i] != NULL &&                         \\\n            pnmpi_function_ptrs.stack[i] != (r_type)P##mpiroutine &&        \\\n            RTLDNEXT_CHECK(stack))                                          \\\n          {                                                                 \\\n            SET_ACTIVATED(routine_id);                                      \\\n          }                                                                 \\\n        else                                                                \\\n          {                                                                 \\\n            pnmpi_function_ptrs.stack[i] =                                  \\\n              NULL; /*needed to make RTLD_NEXT check work*/                 \\\n          }                                                                 \\\n        WRAP_MPI_CALL_POSTFIX                                               \\\n        DBGPRINT2(\"Symbol for routine %s in module %s: value %px\", routine, \\\n                  mods.module[i]->name, pnmpi_function_ptrs.stack[i]);      \\\n      }                                                                     \\\n  }\n\n\nstatic inline int get_pnmpi_mpi_level(void)\n{\n  return pnmpi_mpi_level;\n}\n\nstatic inline int inc_pnmpi_mpi_level(void)\n{\n  return ++pnmpi_mpi_level;\n}\n\nstatic inline int dec_pnmpi_mpi_level(void)\n{\n  return --pnmpi_mpi_level;\n}\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-pnmpi-1.7-4mubdeexdagwkt5wrvoolxpq52e7nwme/spack-src/src/pnmpi/core.c": "/* This file is part of P^nMPI.\n *\n * Copyright (c)\n *  2008-2017 Lawrence Livermore National Laboratories, United States of America\n *  2011-2017 ZIH, Technische Universitaet Dresden, Federal Republic of Germany\n *  2013-2017 RWTH Aachen University, Federal Republic of Germany\n *\n *\n * P^nMPI is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation version 2.1 dated February 1999.\n *\n * P^nMPI is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with P^nMPI; if not, write to the\n *\n *   Free Software Foundation, Inc.\n *   51 Franklin St, Fifth Floor\n *   Boston, MA 02110, USA\n *\n *\n * Written by Martin Schulz, schulzm@llnl.gov.\n *\n * LLNL-CODE-402774\n */\n\n#include <alloca.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"core.h\"\n#include \"pnmpi-config.h\"\n#include <pnmpi/debug_io.h>\n#include <pnmpi/private/attributes.h>\n#include <pnmpi/private/modules.h>\n\n#ifdef HAVE_ADEPT_UTILS\n#include \"link_utils.h\"\n#endif // HAVE_ADEPT_UTILS\n\n\n/* Map the old debug macros to the new debug functions and macros.\n *\n * WARNING:\n * - These macros are not portable to non-GCC compatible compilers, as\n *   ##__VA_ARGS__ is a GNU extension.\n * - These macros are for legacy support only. Use the functions and macros\n *   defined in debug_io.h for new code!\n */\n#define WARNPRINT(format, ...) PNMPI_Warning(format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT2(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_MODULE, format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT3(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_CALL, format \"\\n\", ##__VA_ARGS__);\n#define DBGPRINT4(format, ...) \\\n  PNMPI_Debug(PNMPI_DEBUG_INIT, format \"\\n\", ##__VA_ARGS__);\n\n/* Enable all debug levels, as checking the debug level to print is part of\n * pnmpi_debug now. */\n#define DBGLEVEL\n\n\npnmpi_cell_t pnmpi_activated[NUM_MPI_CELLS];\npnmpi_functions_t pnmpi_function_ptrs;\n\nint pnmpi_mpi_level = 0;\nint pnmpi_max_level;\nint pnmpi_initialization_complete;\nint pnmpi_init_done = 0;\npnmpi_compiler_tls_keyword int pnmpi_level = 0;\npnmpi_compiler_tls_keyword int initial_thread = 0;\n\n\nmodules_t modules;\n\n// array of paths to directories to search for libraries in.\ntypedef char **path_array_t;\n\n// This parses a :-separated path into strings for each component, and returns\n// a null-terminated array of those strings.\nstatic path_array_t parse_path(const char *path)\n{\n  char *pathdup = strdup(path);\n  char *start, *end;\n  int pos, path_size;\n  path_array_t path_array;\n\n  // start with one element plus null terminator\n  path_size = 2;\n  for (start = pathdup; *start; start++)\n    {\n      if (*start == ':')\n        {\n          path_size++;\n        }\n    }\n  path_array = (path_array_t)malloc(path_size * sizeof(char *));\n\n  start = pathdup;\n  pos = 0;\n  do\n    {\n      end = strchr(start, ':');\n      if (end)\n        *end = '\\0';\n\n      path_array[pos] = strdup(start);\n      pos++;\n      start = end + 1;\n    }\n  while (end);\n\n  path_array[pos] = NULL;\n  free(pathdup);\n  return path_array;\n}\n\nstatic void free_path(path_array_t path_array)\n{\n  if (!path_array)\n    return;\n\n  path_array_t cur = path_array;\n  while (*cur)\n    {\n      free(*cur);\n      cur++;\n    }\n  free(path_array);\n}\n\n\n// This finds a module in a particular library path, given by an array of\n// directories\n// to search in order.\nstatic int find_module(const char *lib_name, path_array_t library_path,\n                       void **handle, char *mod_path)\n{\n  path_array_t path;\n  module_name_t location;\n  dlerror();\n\n  if (!library_path)\n    {\n      DBGPRINT2(\"ERROR: no module path defined\\n\");\n      *handle = NULL;\n      return 1;\n    }\n\n  for (path = library_path; *path; path++)\n    {\n      snprintf(location, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", *path, lib_name);\n      if (access(location, R_OK) != -1)\n        {\n          *handle = dlopen(location, RTLD_LAZY);\n          if (*handle)\n            {\n              DBGPRINT2(\"Loading module %s\\n\", lib_name);\n              strcpy(mod_path, location);\n              return 0;\n            }\n          WARNPRINT(\"Loading error for module %s in %s ( Error %s )\", lib_name,\n                    *path, dlerror());\n        }\n      else if (access(location, F_OK) != -1)\n        {\n          WARNPRINT(\"Can't load module %s at %s, no reading permissions\",\n                    lib_name, *path);\n        }\n    }\n  WARNPRINT(\"Can't find module %s in PNMPI_LIB_PATH\", lib_name);\n  return 1;\n}\n\n\nPNMPI_INTERNAL\nvoid *find_symbol(const module_def_p module, const char *symbol_name)\n{\n  void *symbol = dlsym(module->handle, symbol_name);\n\n#ifdef HAVE_ADEPT_UTILS\n  /* In some situations the found symbol is not part of the loaded module but\n   * one of its dependencies. If adept utils is available, check if the symbol\n   * is really in the module's symbol table. */\n  struct link_map *module_lmap = get_module_by_full_path(module->path);\n  struct link_map *symbol_lmap = get_module_for_address(symbol);\n  if (symbol_lmap != module_lmap)\n    {\n      DBGPRINT2(\"WARNING: Ignoring symbol %s found in '%s' while loading '%s'.\",\n                symbol_name, symbol_lmap->l_name, module_lmap->l_name);\n      return NULL;\n    }\n#endif // HAVE_ADEPT_UTILS\n\n  return symbol;\n}\n\n\n/* Core functionality for PNMPI */\nPNMPI_INTERNAL\nvoid pnmpi_PreInit(void)\n{\n  path_array_t library_path;\n  char *lib_path_string, *confdir;\n  module_name_t filename, modname;\n  FILE *conffile = NULL;\n  char line[MAX_LINE], c, lastc;\n  int pos, err;\n  char *cmdargv[MAX_CMDARGS + 1];\n  int cmdargc, comment, i;\n\n  /* setup vars */\n\n  pnmpi_max_level = 0;\n  pnmpi_initialization_complete = 0;\n\n  /* set global defaults */\n  /* none at this moment */\n\n  modules.module = NULL;\n  modules.num = 0;\n  modules.numalloc = 0;\n  modules.pcontrol = PNMPI_PCONTROL_INT;\n\n  /* locate library */\n\n  lib_path_string = getenv(\"PNMPI_LIB_PATH\");\n  if (lib_path_string == NULL)\n    {\n      // no user lib_path_string; just use the install destination's module\n      // path.\n      lib_path_string = PNMPI_MODULES_DIR;\n    }\n  else\n    {\n      // concat the user lib_path_string with the install destination's module\n      // path.\n      size_t len = strlen(lib_path_string) + strlen(PNMPI_MODULES_DIR) + 2;\n      const char *old_lib_path_string = lib_path_string;\n      lib_path_string = (char *)alloca(len * sizeof(char));\n      sprintf(lib_path_string, \"%s:%s\", old_lib_path_string, PNMPI_MODULES_DIR);\n    }\n  library_path = parse_path(lib_path_string);\n  DBGPRINT2(\"Library path is: %s\", lib_path_string);\n\n  /* locate and open file */\n\n  /* check the environment variable first */\n  confdir = getenv(\"PNMPI_CONF\");\n  if (confdir != NULL)\n    {\n      /* try to open it */\n      conffile = fopen(confdir, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error == ENOENT)\n            {\n              WARNPRINT(\n                \"Configuration file not found at %s - reverting to defaults.\",\n                confdir);\n            }\n          else\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        confdir, error);\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via environment variable - %s\", confdir);\n        }\n    }\n\n  if (conffile == NULL)\n    {\n      /* now check the local directory */\n\n      size_t confsize = 1024;\n      confdir = malloc(confsize * sizeof(char));\n      while (NULL == getcwd(confdir, confsize))\n        {\n          if (errno != ERANGE)\n            {\n              free(confdir);\n              confdir = NULL;\n              break;\n            }\n          confsize *= 2;\n          confdir = realloc(confdir, confsize);\n        }\n\n      if (confdir == NULL)\n        {\n          WARNPRINT(\n            \"Can't find local directory - not loading any PNMPI modules.\");\n          free_path(library_path);\n          return;\n        }\n\n      snprintf(filename, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", confdir, CONFNAME);\n      free(confdir);\n      conffile = fopen(filename, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error != ENOENT)\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        filename, error);\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via local directory - %s\", filename);\n        }\n    }\n\n\n  if (conffile == NULL)\n    {\n      /* now check the home directory */\n\n      confdir = getenv(\"HOME\");\n      if (confdir == NULL)\n        {\n          WARNPRINT(\n            \"Can't find local directory - not loading any PNMPI modules.\");\n          free_path(library_path);\n          return;\n        }\n\n      snprintf(filename, PNMPI_MODULE_FILENAMELEN, \"%s/%s\", confdir, CONFNAME);\n      conffile = fopen(filename, \"r\");\n      if (conffile == NULL)\n        {\n          int error = errno;\n          if (error != ENOENT)\n            {\n              WARNPRINT(\"Can't open configuration file %s (Error %i) - not \"\n                        \"loading any PNMPI modules.\",\n                        filename, error);\n              free_path(library_path);\n              return;\n            }\n          else\n            {\n              /* WARNPRINT(\"Can't find any configuration file - not loading any\n               * PNMPI modules.\"); */\n              free_path(library_path);\n              return;\n            }\n        }\n      else\n        {\n          DBGPRINT2(\"Open file via home directory - %s\", filename);\n        }\n    }\n\n  if (conffile == NULL)\n    PNMPI_Error(\"Config file not open.\\n\");\n\n  /* read configuration file and load modules */\n\n  DBGPRINT2(\"Starting to read config file\");\n\n  if (conffile != NULL)\n    {\n      while (!feof(conffile))\n        {\n          /* read next command */\n\n          pos = 0;\n          comment = 0;\n          lastc = ' ';\n          c = ' ';\n          while ((!feof(conffile)) && (c != '\\n'))\n            {\n              c = (char)getc(conffile);\n              if ((c == '#') || (c == (char)255))\n                comment = 1;\n              if (!comment)\n                {\n                  if (pos == MAX_LINE - 1)\n                    {\n                      WARNPRINT(\"Line too long - ignoring the rest\");\n                      comment = 1;\n                    }\n                  else\n                    {\n                      if ((!(isspace(c))) || (!(isspace(lastc))))\n                        {\n                          if (isspace(c))\n                            line[pos] = ' ';\n                          else\n                            line[pos] = c;\n                          lastc = c;\n                          pos++;\n                        }\n                    }\n                }\n            }\n\n          if (pos > 0)\n            {\n              if (isspace(line[pos - 1]))\n                pos--;\n            }\n\n          line[pos] = (char)0;\n\n          DBGPRINT2(\"Read a line: %s### - first is %i - pos %i\", line,\n                    (int)line[0], pos);\n\n          /* decode the line */\n\n          for (i = 0; i < MAX_CMDARGS + 1; i++)\n            cmdargv[i] = NULL;\n\n          if (strcmp(line, \"\") == 0)\n            cmdargv[0] = NULL;\n          else\n            cmdargv[0] = line;\n\n          cmdargc = 0;\n          while (cmdargv[cmdargc] != NULL)\n            {\n              cmdargv[cmdargc + 1] = strchr(cmdargv[cmdargc], ' ');\n              if ((cmdargc == 2) && (strcmp(cmdargv[0], \"argument\") == 0))\n                cmdargv[cmdargc + 1] = NULL;\n              if (cmdargv[cmdargc + 1])\n                {\n                  *cmdargv[cmdargc + 1] = (char)0;\n                  cmdargv[cmdargc + 1]++;\n                }\n              if (cmdargc == MAX_CMDARGS - 1)\n                {\n                  WARNPRINT(\"Too many arguments - ignoring the rest\");\n                  cmdargv[cmdargc] = NULL;\n                }\n              cmdargc++;\n            }\n\n#ifdef DBGLEVEL\n          DBGPRINT2(\"CMDARGC = %i\", cmdargc);\n          for (i = 0; i < cmdargc; i++)\n            {\n              DBGPRINT2(\"  %i: %s\", i, cmdargv[i]);\n            }\n#endif\n\n          /* now that we all components, interprete them */\n\n          if (cmdargc == 0)\n            {\n              /* do nothing */\n            }\n          else if ((cmdargc == 2) && (strcmp(cmdargv[0], \"stack\") == 0))\n            {\n              /* new substack */\n\n              if (modules.num == modules.numalloc)\n                {\n                  DBGPRINT2(\"Getting new memory for names\");\n                  modules.module =\n                    realloc(modules.module, (modules.numalloc + MODULE_SKIP) *\n                                              sizeof(module_def_p));\n                  if (modules.module == NULL)\n                    {\n                      WARNPRINT(\"Out memory to load configuration file - not \"\n                                \"loading any PNMPI modules.\");\n                      modules.num = 0;\n                      modules.numalloc = 0;\n                      fclose(conffile);\n                      return;\n                    }\n                  modules.numalloc += MODULE_SKIP;\n                }\n\n              /* now allocate the actual memory */\n\n              modules.module[modules.num] =\n                (module_def_p)malloc(sizeof(module_def_t));\n              if (modules.module[modules.num] == NULL)\n                {\n                  WARNPRINT(\n                    \"Out memory to load stack defintion - ignoring delimiter.\");\n                }\n              else\n                {\n                  module_def_t empty = { { 0 } };\n                  *(modules.module[modules.num]) = empty;\n\n                  /* now we have space and can store the information */\n\n                  DBGPRINT2(\"Found stack %i: %s\", modules.num + 1, cmdargv[1]);\n                  if (strlen(cmdargv[1]) >= PNMPI_MODULE_FILENAMELEN)\n                    {\n                      WARNPRINT(\"Stack name too long - shortening it\");\n                    }\n                  strncpy(modules.module[modules.num]->name, cmdargv[1],\n                          PNMPI_MODULE_FILENAMELEN - 4);\n                  modules.module[modules.num]\n                    ->name[PNMPI_MODULE_FILENAMELEN - 5] = (char)0;\n\n                  /* I don't think we need this - seems copy and paste error\n                     sprintf(modname,\"%s/%s.so\",libdir,modules.module[modules.num]->name);\n                     */\n\n                  modules.module[modules.num]->stack_delimiter = 1;\n                  modules.module[modules.num]->registered = 0;\n                  modules.module[modules.num]->services = NULL;\n                  modules.module[modules.num]->username[0] = (char)0;\n                  modules.num++;\n                }\n            }\n          else if ((cmdargc == 2) && (strcmp(cmdargv[0], \"module\") == 0))\n            {\n              /* start a new module */\n\n              if (modules.num == modules.numalloc)\n                {\n                  DBGPRINT2(\"Getting new memory for names\");\n                  modules.module =\n                    realloc(modules.module, (modules.numalloc + MODULE_SKIP) *\n                                              sizeof(module_def_p));\n                  if (modules.module == NULL)\n                    {\n                      WARNPRINT(\"Out memory to load configuration file - not \"\n                                \"loading any PNMPI modules.\");\n                      modules.num = 0;\n                      modules.numalloc = 0;\n                      fclose(conffile);\n                      return;\n                    }\n                  modules.numalloc += MODULE_SKIP;\n                }\n\n              /* now allocate the actual memory */\n\n              modules.module[modules.num] =\n                (module_def_p)malloc(sizeof(module_def_t));\n              if (modules.module[modules.num] == NULL)\n                {\n                  WARNPRINT(\n                    \"Out memory to load module defintion - ignoring module.\");\n                }\n              else\n                {\n                  module_def_t empty_module = { { 0 } };\n                  *(modules.module[modules.num]) = empty_module;\n\n                  /* now we have space and can store the information */\n\n                  DBGPRINT2(\"Found module %i: %s\", modules.num + 1, cmdargv[1]);\n                  if (strlen(cmdargv[1]) >= PNMPI_MODULE_FILENAMELEN)\n                    {\n                      WARNPRINT(\"Module name too long - shortening it\");\n                    }\n                  strncpy(modules.module[modules.num]->name, cmdargv[1],\n                          PNMPI_MODULE_FILENAMELEN - 4);\n                  modules.module[modules.num]\n                    ->name[PNMPI_MODULE_FILENAMELEN - 5] = (char)0;\n                  snprintf(modname, PNMPI_MODULE_FILENAMELEN, \"%s.so\",\n                           modules.module[modules.num]->name);\n\n                  /* The first module gets the pcontrol by default */\n\n                  if (modules.num == 0)\n                    {\n                      modules.module[modules.num]->pcontrol = 1;\n                    }\n                  else\n                    {\n                      modules.module[modules.num]->pcontrol = 0;\n                    }\n\n                  find_module(modname, library_path,\n                              &modules.module[modules.num]->handle,\n                              modules.module[modules.num]->path);\n                  if (modules.module[modules.num]->handle == NULL)\n                    {\n                      WARNPRINT(\"Can't load module %s at all!\", modname);\n                    }\n                  else\n                    {\n                      /* we could open the module - hence we are good to go */\n                      DBGPRINT2(\"dlopen successful\");\n\n                      modules.module[modules.num]->stack_delimiter = 0;\n                      modules.module[modules.num]->registered = 0;\n                      modules.module[modules.num]->services = NULL;\n                      modules.module[modules.num]->globals = NULL;\n                      modules.module[modules.num]->args = NULL;\n                      modules.module[modules.num]->username[0] = (char)0;\n\n                      /* Check, if the module provides a module name, so it can\n                       * be registered. */\n                      const char **module_name = find_symbol(\n                        modules.module[modules.num], \"PNMPI_ModuleName\");\n                      if (module_name != NULL)\n                        {\n                          pnmpi_level = modules.num;\n                          PNMPI_Service_RegisterModule(*module_name);\n                        }\n\n                      /* PNMPI_RegistrationPoint will be called later */\n\n                      pnmpi_level = modules.num;\n                      modules.num++;\n                    }\n                }\n            }\n          else if (((cmdargc == 1) || (cmdargc == 2)) &&\n                   (strcmp(cmdargv[0], \"pcontrol\") == 0))\n            {\n              /* check if module is active */\n\n              if (modules.num > 0)\n                {\n                  int turnon;\n\n                  /* mark the module as receiving pcontrol commands */\n\n                  if (cmdargc == 1)\n                    turnon = 1;\n                  else\n                    {\n                      if (strcmp(cmdargv[1], \"on\") == 0)\n                        turnon = 1;\n                      else if (strcmp(cmdargv[1], \"off\") == 0)\n                        turnon = 0;\n                      else\n                        {\n                          WARNPRINT(\"Can't understand pcontrol argument - \"\n                                    \"turning pcontrol off\");\n                          turnon = 0;\n                        }\n                    }\n                  modules.module[modules.num - 1]->pcontrol = turnon;\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"No module active - ignoring local command pcontrol\");\n                }\n            }\n          else if ((cmdargc == 2) &&\n                   (strcmp(cmdargv[0], \"globalpcontrol\") == 0))\n            {\n              /* find global pcontrol setting with no extra argument */\n\n              if (strcmp(cmdargv[1], \"on\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_ON;\n              else if (strcmp(cmdargv[1], \"off\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_OFF;\n              else if (strcmp(cmdargv[1], \"pmpi\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_PMPI;\n              else if (strcmp(cmdargv[1], \"pnmpi\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_PNMPI;\n              else if (strcmp(cmdargv[1], \"mixed\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_MIXED;\n              else if (strcmp(cmdargv[1], \"int\") == 0)\n                modules.pcontrol = PNMPI_PCONTROL_INT;\n              else\n                {\n                  WARNPRINT(\n                    \"Can't understand globalpcontrol argument - ignoring it\");\n                }\n            }\n          else if ((cmdargc == 4) &&\n                   (strcmp(cmdargv[0], \"globalpcontrol\") == 0))\n            {\n              /* find global pcontrol setting with two extra arguments */\n\n              if (strcmp(cmdargv[1], \"typed\") == 0)\n                {\n                  modules.pcontrol = PNMPI_PCONTROL_TYPED;\n                  modules.pcontrol_typed_level = atoi(cmdargv[2]);\n                  if (strcmp(cmdargv[3], \"int\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_INT;\n                  else if (strcmp(cmdargv[3], \"pointer\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_PTR;\n                  else if (strcmp(cmdargv[3], \"double\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_DOUBLE;\n                  else if (strcmp(cmdargv[3], \"long\") == 0)\n                    modules.pcontrol_typed_type = PNMPI_PCONTROL_TYPE_LONG;\n                  else\n                    {\n                      WARNPRINT(\"Can't understand globalpcontrol argument - \"\n                                \"ignoring it\");\n                    }\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"Can't understand globalpcontrol argument - ignoring it\");\n                }\n            }\n          else if ((cmdargc >= 3) && (strcmp(cmdargv[0], \"argument\") == 0))\n            {\n              /* check if module is active */\n\n              if (modules.num > 0)\n                {\n                  module_arg_p arg, argl;\n\n                  /* record argumemt */\n\n                  arg = (module_arg_p)malloc(sizeof(module_arg_t));\n                  if (arg == NULL)\n                    {\n                      WARNPRINT(\"No memory to allocate argument - ignoring it\");\n                    }\n                  else\n                    {\n                      if (strlen(cmdargv[1]) >= MAX_ARG_NAME)\n                        WARNPRINT(\"Argument name too long - trunacting it\");\n                      if (strlen(cmdargv[2]) >= MAX_ARG_VALUE)\n                        WARNPRINT(\"Argument value too long - trunacting it\");\n                      strncpy(arg->name, cmdargv[1], MAX_ARG_NAME);\n                      strncpy(arg->value, cmdargv[2], MAX_ARG_VALUE);\n                      arg->name[MAX_ARG_NAME - 1] = (char)0;\n                      arg->value[MAX_ARG_VALUE - 1] = (char)0;\n                      argl = modules.module[modules.num - 1]->args;\n                      arg->next = NULL;\n                      if (argl)\n                        {\n                          while (argl->next)\n                            argl = argl->next;\n                          argl->next = arg;\n                        }\n                      else\n                        modules.module[modules.num - 1]->args = arg;\n                    }\n                }\n              else\n                {\n                  WARNPRINT(\n                    \"No module active - ignoring local command argument\");\n                }\n            }\n          else\n            {\n              WARNPRINT(\"Illegal command %s - ignoring it\", cmdargv[0]);\n            }\n        } /* while eof */\n    }     /* if file open */\n\n  /*Free what we allocated*/\n  if (conffile)\n    fclose(conffile);\n\n  /*\n   * Call the module registration point functions\n   * (done now as to load arguments first)\n   */\n  pnmpi_call_hook(PNMPI_REGISTRATION_POINT, PNMPI_CALL_HOOK_ALL_MODULES, 0);\n\n  /* After all hooks have been registered, call the module initialization hook.\n   * Modules may access other modules in this hook. */\n  pnmpi_call_hook(\"PNMPI_Init\", PNMPI_CALL_HOOK_ALL_MODULES, 0);\n\n/* if we are debugging, print the parsed information */\n\n#ifdef DBGLEVEL\n  {\n    int _i, _j;\n    module_arg_p arg;\n    DBGPRINT4(\"Parsed information from configuration file\");\n    for (_i = 0; _i < modules.num; _i++)\n      {\n        DBGPRINT4(\"- Module %s (pcontrol %i)\", modules.module[_i]->name,\n                  modules.module[_i]->pcontrol);\n        _j = 1;\n        arg = modules.module[_i]->args;\n        while (arg != NULL)\n          {\n            DBGPRINT4(\"\\t Argument %2i: %s = %s\", _j, arg->name, arg->value);\n            arg = arg->next;\n            _j++;\n          }\n      }\n    DBGPRINT4(\"\\n\");\n  }\n#endif /* DBGLEVEL */\n\n\n  /* Initialize and load the indirection arrays */\n\n  if (modules.num > 0)\n    {\n      INITIALIZE_ALL_FUNCTION_STACKS(modules);\n    }\n\n#ifdef DBGLEVEL\n  {\n    int _i;\n    for (_i = 0; _i < NUM_MPI_CELLS; _i++)\n      {\n        DBGPRINT3(\"Cell %i = %lx\", _i, pnmpi_activated[_i]);\n      }\n  }\n#endif\n\n  free_path(library_path);\n\n  /* fix variables */\n  pnmpi_max_level = modules.num;\n  pnmpi_level = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-pnmpi-1.7-4mubdeexdagwkt5wrvoolxpq52e7nwme/spack-src/externals/adept-utils/cutils/test.c": "#define _GNU_SOURCE\n#include \"link_utils.h\"\n#include <stdlib.h>\n#include <dlfcn.h>\n\n#define printsymbol(symbol) \\\n  { \\\n    void *mysym = dlsym(RTLD_NEXT, #symbol); \\\n    struct link_map *map = get_module_for_address(mysym); \\\n    printf(\"module for \" #symbol \"(%#tx): %#tx(%s)\\n\", mysym, map->l_addr, map->l_name); \\\n  }\n\n\n\nint main(int argc, char **argv) {\n  dump_link_map(stdout);\n\n  printsymbol(printf);\n  printsymbol(malloc);\n  printsymbol(dlsym);\n\n\n  struct link_map *map = get_module_by_full_path(\"/lib64/libdl.so.2\");\n  if (map) {\n    printf(\"%s\\n\", map->l_name);\n  } else {\n    printf(\"not found.\\n\");\n  }\n\n}\n"
    },
    "skipped": [],
    "total_files": 294
}