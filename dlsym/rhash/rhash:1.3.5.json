{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rhash-1.3.5-h7libxtafzikl3ufjjmbzimbrhf5luy2/spack-src/librhash/plug_openssl.c": "/* plug_openssl.c - plug-in openssl algorithms\n *\n * Copyright: 2011-2012 Aleksey Kravchenko <rhash.admin@gmail.com>\n *\n * Permission is hereby granted,  free of charge,  to any person  obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction,  including without limitation\n * the rights to  use, copy, modify,  merge, publish, distribute, sublicense,\n * and/or sell copies  of  the Software,  and to permit  persons  to whom the\n * Software is furnished to do so.\n *\n * This program  is  distributed  in  the  hope  that it will be useful,  but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  Use this program  at  your own risk!\n */\n#if defined(USE_OPENSSL) || defined(OPENSSL_RUNTIME)\n\n#include <string.h>\n#include <assert.h>\n#include <openssl/opensslv.h>\n#include <openssl/md4.h>\n#include <openssl/md5.h>\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10000000L)\n#include <openssl/whrlpool.h>\n#define USE_OPENSSL_WHIRLPOOL\n#endif\n\n#include \"algorithms.h\"\n#include \"plug_openssl.h\"\n\n#if defined(OPENSSL_RUNTIME)\n# ifdef _WIN32\n#  include <windows.h>\n# else\n#  include <dlfcn.h>\n# endif\n#endif\n\n/* the mask of ids of hashing algorithms to use from the OpenSLL library */\nunsigned rhash_openssl_hash_mask = RHASH_OPENSSL_DEFAULT_HASHES;\n\n#ifdef OPENSSL_RUNTIME\ntypedef void (*os_fin_t)(void*, void*);\n#define OS_METHOD(name) os_fin_t p##name##_final = 0\nOS_METHOD(MD4);\nOS_METHOD(MD5);\nOS_METHOD(RIPEMD160);\nOS_METHOD(SHA1);\nOS_METHOD(SHA224);\nOS_METHOD(SHA256);\nOS_METHOD(SHA384);\nOS_METHOD(SHA512);\nOS_METHOD(WHIRLPOOL);\n\n#define CALL_FINAL(name, result, ctx) p##name##_final(result, ctx)\n\n#define HASH_INFO_METHODS(name) 0, 0, wrap##name##_Final, 0\n#else /* non-runtime linking */\n#define CALL_FINAL(name, result, ctx) name##_Final(result, ctx)\n#define HASH_INFO_METHODS(name) (pinit_t)name##_Init, (pupdate_t)name##_Update, wrap##name##_Final, 0\n#endif\n\n\n/* The openssl * _Update functions have the same signature as RHash ones:\n * void update_func(void *ctx, const void* msg, size_t size),\n * so we can use them in RHash directly. But the _Final functions\n * have different order of arguments, so we need to wrap them. */\n#define WRAP_FINAL(name) WRAP_FINAL2(name, name##_CTX)\n#define WRAP_FINAL2(name, CTX_TYPE) \\\n\tstatic void wrap##name##_Final(void* ctx, unsigned char* result) { \\\n\t\tCALL_FINAL(name, result, (CTX_TYPE*)ctx); \\\n\t}\n\nWRAP_FINAL(MD4)\nWRAP_FINAL(MD5)\nWRAP_FINAL(RIPEMD160)\nWRAP_FINAL2(SHA1, SHA_CTX)\nWRAP_FINAL2(SHA224, SHA256_CTX)\nWRAP_FINAL(SHA256)\nWRAP_FINAL2(SHA384, SHA512_CTX)\nWRAP_FINAL(SHA512)\n\n/* wrapping WHIRLPOOL_Final requires special attention. */\n#ifdef USE_OPENSSL_WHIRLPOOL\nstatic void wrapWHIRLPOOL_Final(void* ctx, unsigned char* result)\n{\n\t/* must pass NULL as the result argument, otherwise ctx will be zeroed */\n\tCALL_FINAL(WHIRLPOOL, NULL, ctx);\n\tmemcpy(result, ((WHIRLPOOL_CTX*)ctx)->H.c, 64);\n}\n#endif\n\nrhash_info info_sslwhpl = { RHASH_WHIRLPOOL, 0, 64, \"WHIRLPOOL\", \"whirlpool\" };\n\n/* The table of supported OpenSSL hash functions */\nrhash_hash_info rhash_openssl_methods[] = {\n\t{ &info_md4, sizeof(MD4_CTX), offsetof(MD4_CTX, A), HASH_INFO_METHODS(MD4) }, /* 128 bit */\n\t{ &info_md5, sizeof(MD5_CTX), offsetof(MD5_CTX, A), HASH_INFO_METHODS(MD5) }, /* 128 bit */\n\t{ &info_sha1, sizeof(SHA_CTX), offsetof(SHA_CTX, h0),  HASH_INFO_METHODS(SHA1) }, /* 160 bit */\n\t{ &info_rmd160, sizeof(RIPEMD160_CTX), offsetof(RIPEMD160_CTX, A), HASH_INFO_METHODS(RIPEMD160) }, /* 160 bit */\n\t{ &info_sha224, sizeof(SHA256_CTX), offsetof(SHA256_CTX, h), HASH_INFO_METHODS(SHA224) }, /* 224 bit */\n\t{ &info_sha256, sizeof(SHA256_CTX), offsetof(SHA256_CTX, h), HASH_INFO_METHODS(SHA256) }, /* 256 bit */\n\t{ &info_sha384, sizeof(SHA512_CTX), offsetof(SHA512_CTX, h), HASH_INFO_METHODS(SHA384) }, /* 384 bit */\n\t{ &info_sha512, sizeof(SHA512_CTX), offsetof(SHA512_CTX, h), HASH_INFO_METHODS(SHA512) }, /* 512 bit */\n#ifdef USE_OPENSSL_WHIRLPOOL\n\t/* note: should be flags=0 */\n\t{ &info_sslwhpl, sizeof(WHIRLPOOL_CTX), offsetof(WHIRLPOOL_CTX, H.c), HASH_INFO_METHODS(WHIRLPOOL) }, /* 512 bit */\n#endif\n};\n\n/* The rhash_openssl_hash_info static array initialized by rhash_plug_openssl() replaces\n * rhash internal algorithms table. It is kept in an uninitialized-data segment\n * taking no space in the executable. */\nrhash_hash_info rhash_openssl_hash_info[RHASH_HASH_COUNT];\n\n#ifdef OPENSSL_RUNTIME\n#ifdef _WIN32\n#define LOAD_ADDR(n, name) \\\n\tp##name##_final = (os_fin_t)GetProcAddress(handle, #name \"_Final\"); \\\n\trhash_openssl_methods[n].update = (pupdate_t)GetProcAddress(handle, #name \"_Update\"); \\\n\trhash_openssl_methods[n].init = (rhash_openssl_methods[n].update && p##name##_final ? \\\n\t\t(pinit_t)GetProcAddress(handle, #name \"_Init\") : 0);\n#else  /* _WIN32 */\n#define LOAD_ADDR(n, name) \\\n\tp##name##_final = (os_fin_t)dlsym(handle, #name \"_Final\"); \\\n\trhash_openssl_methods[n].update = (pupdate_t)dlsym(handle, #name \"_Update\"); \\\n\trhash_openssl_methods[n].init = (rhash_openssl_methods[n].update && p##name##_final ? \\\n\t\t(pinit_t)dlsym(handle, #name \"_Init\") : 0);\n#endif /* _WIN32 */\n\n/**\n * Load OpenSSL DLL at runtime, store pointers to functions of all\n * supported hash algorithms.\n *\n * @return 1 on success, 0 if the library not found\n */\nstatic int load_openssl_runtime(void)\n{\n#ifdef _WIN32\n\tHMODULE handle;\n\t/* suppress the error popup dialogs */\n\tUINT oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);\n\tSetErrorMode(oldErrorMode | SEM_FAILCRITICALERRORS);\n\n\thandle = LoadLibraryA(\"libeay32.dll\");\n\n\tSetErrorMode(oldErrorMode); /* restore error mode */\n#else\n\tvoid* handle = dlopen(\"libcrypto.so\", RTLD_NOW);\n\tif (!handle) handle = dlopen(\"libcrypto.so.1.1\", RTLD_NOW);\n\tif (!handle) handle = dlopen(\"libcrypto.so.1.0.2\", RTLD_NOW);\n\tif (!handle) handle = dlopen(\"libcrypto.so.1.0.0\", RTLD_NOW);\n\tif (!handle) handle = dlopen(\"libcrypto.so.0.9.8\", RTLD_NOW);\n#endif\n\n\tif (handle == NULL) return 0; /* could not load OpenSSL */\n\n\tLOAD_ADDR(0, MD4)\n\tLOAD_ADDR(1, MD5);\n\tLOAD_ADDR(2, SHA1);\n\tLOAD_ADDR(3, RIPEMD160);\n\tLOAD_ADDR(4, SHA224);\n\tLOAD_ADDR(5, SHA256);\n\tLOAD_ADDR(6, SHA384);\n\tLOAD_ADDR(7, SHA512);\n#ifdef USE_OPENSSL_WHIRLPOOL\n\tLOAD_ADDR(8, WHIRLPOOL);\n#endif\n\treturn 1;\n}\n#endif\n\n/**\n * Replace several RHash internal algorithms with the OpenSSL ones.\n * It replaces MD4/MD5, SHA1/SHA2, RIPEMD, WHIRLPOOL.\n *\n * @return 1 on success, 0 if OpenSSL library not found\n */\nint rhash_plug_openssl(void)\n{\n\tint i, bit_index;\n\n\tassert(rhash_info_size <= RHASH_HASH_COUNT); /* buffer-overflow protection */\n\n\tif ( (rhash_openssl_hash_mask & RHASH_OPENSSL_SUPPORTED_HASHES) == 0) {\n\t\treturn 1; /* do not load OpenSSL */\n\t}\n\n#ifdef OPENSSL_RUNTIME\n\tif (!load_openssl_runtime()) return 0;\n#endif\n\n\tmemcpy(rhash_openssl_hash_info, rhash_info_table, sizeof(rhash_openssl_hash_info));\n\n\t/* replace internal rhash methods with the OpenSSL ones */\n\tfor (i = 0; i < (int)(sizeof(rhash_openssl_methods) / sizeof(rhash_hash_info)); i++)\n\t{\n\t\trhash_hash_info *method = &rhash_openssl_methods[i];\n\t\tif ((rhash_openssl_hash_mask & method->info->hash_id) == 0) continue;\n\t\tif (!method->init) continue;\n\t\tbit_index = rhash_ctz(method->info->hash_id);\n\t\tassert(method->info->hash_id == rhash_openssl_hash_info[bit_index].info->hash_id);\n\t\tmemcpy(&rhash_openssl_hash_info[bit_index], method, sizeof(rhash_hash_info));\n\t}\n\n\trhash_info_table = rhash_openssl_hash_info;\n\treturn 1;\n}\n#else\ntypedef int dummy_declaration_required_by_strict_iso_c;\n#endif /* defined(USE_OPENSSL) || defined(OPENSSL_RUNTIME) */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rhash-1.3.5-h7libxtafzikl3ufjjmbzimbrhf5luy2/spack-src/tests/test1K.data",
        "/tmp/vanessa/spack-stage/spack-stage-rhash-1.3.5-h7libxtafzikl3ufjjmbzimbrhf5luy2/spack-src/bindings/mono/RHash.snk",
        "/tmp/vanessa/spack-stage/spack-stage-rhash-1.3.5-h7libxtafzikl3ufjjmbzimbrhf5luy2/spack-src/bindings/php/tests/002.phpt"
    ],
    "total_files": 155
}