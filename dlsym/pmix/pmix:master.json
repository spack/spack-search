{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-3nm2cbtpodn7gevu77hyhtvfwxy5lviq/spack-src/src/mca/pdl/pdl.h": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2020      Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n/**\n * @file\n *\n * Dynamic library framework\n *\n * General Description:\n *\n * This framework provides portable access to dlopen- and dlsym-like\n * functionality, very similar to Libtool's libltdl.  Indeed, one of\n * the components in this framework will use libltdl, if it is\n * present/available.  However, on some common types systems where\n * libltdl headers and libraries are *not* available, we can support\n * plugins via this simple framework.\n *\n * This is a compile-time framework: a single component will be\n * selected by the priority that its configure.m4 provides.  All other\n * components will be ignored (i.e., not built/not part of the\n * installation).  Meaning: the static_components of the pdl framework\n * will always contain 0 or 1 components.\n *\n * SIDENOTE: PMIX used to embed libltdl.  However, as of early\n * 2015, this became problematic, for a variety of complex and\n * uninteresting reasons (see the following if you care about the\n * details: https://github.com/open-mpi/ompi/issues/311,\n * http://debbugs.gnu.org/cgi/bugreport.cgi?bug=19370,\n * https://github.com/open-mpi/ompi/pull/366,\n * https://github.com/open-mpi/ompi/pull/390).  That being said, we,\n * as a developer community, still wanted to be able to natively use\n * DSOs by default.  A small/simple framework for PDL functionality,\n * along with a simple component that supports dlopen/dlsym on POSIX\n * platforms and another component that natively uses libltdl seemed\n * like a good solution.\n */\n\n#ifndef PMIX_MCA_PDL_PDL_H\n#define PMIX_MCA_PDL_PDL_H\n\n#include \"src/include/pmix_config.h\"\n\n#include \"src/mca/mca.h\"\n#include \"src/mca/base/base.h\"\n\nBEGIN_C_DECLS\n\n/**\n * Handle for an opened file\n */\nstruct pmix_pdl_handle_t;\ntypedef struct pmix_pdl_handle_t pmix_pdl_handle_t;\n\n/**\n * Dynamically open the file specified.\n *\n * Arguments:\n *   fname   = Base filename to open.  If NULL, open this process.\n *   use_ext = If true, try various filename suffixes that are\n *       relevant on this platform (e.g., .so, .dll, .dylib).  If\n *       false, just use exactly whatever was passed as fname.\n *   private = If true, open the file in a private namespace.\n *       Otherwise, open the file in a global namespace.\n *   handle = Upon successful open, a handle to the opened file will\n *       be returned.\n *   err_msg= if non-NULL and !=PMIX_SUCCESS is returned, will point to a\n *       string error message\n *\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n * Space for the handle must be allocated by the module (it can be\n * freed during the call to pmix_pdl_base_module_dlclose_fn_t).\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to pmix_pdl API calls.\n */\ntypedef int (*pmix_pdl_base_module_open_fn_t)\n    (const char *fname, bool use_ext, bool private_namespace,\n     pmix_pdl_handle_t **handle, char **err_msg);\n\n/**\n * Lookup a symbol in an opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file\n *   symbol = name of the symbol to lookup\n *   ptr    = if found, a pointer to the symbol.  Otherwise, NULL.\n *   err_msg= if non-NULL and !=PMIX_SUCCESS is returned, will point to a\n *            string error message\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n *\n * The err_msg points to an internal string and should not be altered\n * or freed by the caller.  The contents of the err_msg string may\n * change after successive calls to pmix_pdl API calls.\n */\ntypedef int (*pmix_pdl_base_module_lookup_fn_t)\n    (pmix_pdl_handle_t *handle, const char *symbol, void **ptr, char **err_msg);\n\n/**\n * Dynamically close a previously dynamically-opened file.\n *\n * Arguments:\n *   handle = handle of a previously dynamically opened file.\n * Returns:\n *   PMIX_SUCCESS on success, or PMIX_ERROR\n *\n * This function should close the file and free and resources\n * associated with it (e.g., whatever is cached on the handle).\n */\ntypedef int (*pmix_pdl_base_module_close_fn_t)\n    (pmix_pdl_handle_t *handle);\n\n/**\n * Search through a path of directories, invoking a callback on each\n * unique regular (non-Libtool) file basename found (e.g., will only\n * be invoked once for the files \"foo.la\" and \"foo.so\", with the\n * parameter \"foo\").\n *\n * Arguments:\n *   path   = PMIX_ENV_SEP-delimited list of directories\n *   cb_func= function to invoke on each filename found\n *   data   = context for callback function\n * Returns:\n *   PMIX_SUCESS on success, PMIX_ERR* otherwise\n */\ntypedef int (*pmix_pdl_base_module_foreachfile_fn_t)\n    (const char *search_path,\n     int (*cb_func)(const char *filename, void *context),\n     void *context);\n\n/**\n * Structure for PDL components.\n */\nstruct pmix_pdl_base_component_1_0_0_t {\n    /** MCA base component */\n    pmix_mca_base_component_t base_version;\n    /** MCA base data */\n    pmix_mca_base_component_data_t base_data;\n\n    /** Default priority */\n    int priority;\n};\ntypedef struct pmix_pdl_base_component_1_0_0_t pmix_pdl_base_component_1_0_0_t;\ntypedef struct pmix_pdl_base_component_1_0_0_t pmix_pdl_base_component_t;\n\n/**\n * Structure for PDL modules\n */\nstruct pmix_pdl_base_module_1_0_0_t {\n    pmix_mca_base_module_2_0_0_t            super;\n\n    /** Open / close */\n    pmix_pdl_base_module_open_fn_t           open;\n    pmix_pdl_base_module_close_fn_t          close;\n\n    /** Lookup a symbol */\n    pmix_pdl_base_module_lookup_fn_t         lookup;\n\n    /** Iterate looking for files */\n    pmix_pdl_base_module_foreachfile_fn_t    foreachfile;\n};\ntypedef struct pmix_pdl_base_module_1_0_0_t pmix_pdl_base_module_1_0_0_t;\ntypedef struct pmix_pdl_base_module_1_0_0_t pmix_pdl_base_module_t;\n\n/**\n * Macro for use in components that are of type PDL\n */\n#define PMIX_PDL_BASE_VERSION_1_0_0              \\\n    PMIX_MCA_BASE_VERSION_1_0_0(\"pdl\", 1, 0, 0)\n\nEND_C_DECLS\n\n#endif /* PMIX_MCA_PDL_PDL_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-3nm2cbtpodn7gevu77hyhtvfwxy5lviq/spack-src/src/mca/pdl/plibltdl/pdl_libltdl_module.c": "/*\n * Copyright (c) 2015      Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2017-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"pmix_config.h\"\n\n#include \"pmix/constants.h\"\n#include \"pmix/mca/pdl/pdl.h\"\n\n#include \"pdl_libltdl.h\"\n\n\nstatic int plibltpdl_open(const char *fname, bool use_ext, bool private_namespace,\n                          pmix_pdl_handle_t **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = NULL;\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    lt_dlhandle local_handle;\n\n#if PMIX_DL_LIBLTDL_HAVE_LT_DLADVISE\n    pmix_pdl_plibltpdl_component_t *c = &mca_pdl_plibltpdl_component;\n\n    if (use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_ext);\n    } else if (use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_ext);\n    } else if (!use_ext && private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_private_noext);\n    } else if (!use_ext && !private_namespace) {\n        local_handle = lt_dlopenadvise(fname, c->advise_public_noext);\n    }\n#else\n    if (use_ext) {\n        local_handle = lt_dlopenext(fname);\n    } else {\n        local_handle = lt_dlopen(fname);\n    }\n#endif\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(pmix_pdl_handle_t));\n        (*handle)->ltpdl_handle = local_handle;\n\n#if PMIX_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int plibltpdl_lookup(pmix_pdl_handle_t *handle, const char *symbol,\n                            void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->ltpdl_handle);\n    assert(symbol);\n    assert(ptr);\n\n    if (NULL != err_msg) {\n        *err_msg = NULL;\n    }\n\n    *ptr = lt_dlsym(handle->ltpdl_handle, symbol);\n    if (NULL != *ptr) {\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = strdup((char*) lt_dlerror());\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int plibltpdl_close(pmix_pdl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = lt_dlclose(handle->ltpdl_handle);\n\n#if PMIX_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\nstatic int plibltpdl_foreachfile(const char *search_path,\n                                 int (*func)(const char *filename, void *data),\n                                 void *data)\n{\n    assert(search_path);\n    assert(func);\n\n    int ret = lt_dlforeachfile(search_path, func, data);\n    return (0 == ret) ? PMIX_SUCCESS : PMIX_ERROR;\n}\n\n\n/*\n * Module definition\n */\npmix_pdl_base_module_t pmix_pdl_plibltpdl_module = {\n    .open = plibltpdl_open,\n    .lookup = plibltpdl_lookup,\n    .close = plibltpdl_close,\n    .foreachfile = plibltpdl_foreachfile\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-3nm2cbtpodn7gevu77hyhtvfwxy5lviq/spack-src/src/mca/pdl/pdlopen/pdl_pdlopen_module.c": "/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2015 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2015      Los Alamos National Security, LLC. All rights\n *                         reserved.\n * Copyright (c) 2016      IBM Corporation.  All rights reserved.\n * Copyright (c) 2016-2020 Intel, Inc.  All rights reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"src/include/pmix_config.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"include/pmix_common.h\"\n#include \"src/mca/pdl/pdl.h\"\n#include \"src/util/argv.h\"\n#include \"src/util/error.h\"\n\n#include \"pdl_pdlopen.h\"\n\n\n/*\n * Trivial helper function to avoid replicating code\n */\nstatic void do_pdlopen(const char *fname, int flags,\n                      void **handle, char **err_msg)\n{\n    assert(handle);\n\n    *handle = dlopen(fname, flags);\n\n    if (NULL != err_msg) {\n        if (NULL != *handle) {\n            *err_msg = NULL;\n        } else {\n            *err_msg = dlerror();\n        }\n    }\n}\n\n\nstatic int pdlopen_open(const char *fname, bool use_ext, bool private_namespace,\n                       pmix_pdl_handle_t **handle, char **err_msg)\n{\n    int rc;\n\n    assert(handle);\n\n    *handle = NULL;\n\n    /* Setup the dlopen flags */\n    int flags = RTLD_LAZY;\n    if (private_namespace) {\n        flags |= RTLD_LOCAL;\n    } else {\n        flags |= RTLD_GLOBAL;\n    }\n\n    /* If the caller wants to use filename extensions, loop through\n       them */\n    void *local_handle = NULL;\n    if (use_ext && NULL != fname) {\n        int i;\n        char *ext;\n\n        for (i = 0, ext = mca_pdl_pdlopen_component.filename_suffixes[i];\n             NULL != ext;\n             ext = mca_pdl_pdlopen_component.filename_suffixes[++i]) {\n            char *name;\n\n            rc = asprintf(&name, \"%s%s\", fname, ext);\n            if (0 > rc) {\n                return PMIX_ERR_NOMEM;\n            }\n            if (NULL == name) {\n                return PMIX_ERR_IN_ERRNO;\n            }\n\n            /* Does the file exist? */\n            struct stat buf;\n            /* coverity[toctou] */\n            if (stat(name, &buf) < 0) {\n                if (NULL != err_msg) {\n                    rc = asprintf(err_msg, \"File %s not found\", name);\n                    if (0 > rc) {\n                        free(name);\n                        return PMIX_ERR_NOMEM;\n                    }\n                }\n                free(name);\n                continue;\n            }\n\n            /* Yes, the file exists -- try to dlopen it.  If we can't\n               dlopen it, bail. */\n            do_pdlopen(name, flags, &local_handle, err_msg);\n            free(name);\n            break;\n        }\n    }\n\n    /* Otherwise, the caller does not want to use filename extensions,\n       so just use the single filename that the caller provided */\n    else {\n        do_pdlopen(fname, flags, &local_handle, err_msg);\n    }\n\n    if (NULL != local_handle) {\n        *handle = calloc(1, sizeof(pmix_pdl_handle_t));\n        (*handle)->dlopen_handle = local_handle;\n\n#if PMIX_ENABLE_DEBUG\n        if( NULL != fname ) {\n            (*handle)->filename = strdup(fname);\n        }\n        else {\n            (*handle)->filename = strdup(\"(null)\");\n        }\n#endif\n    }\n    return (NULL != local_handle) ? PMIX_SUCCESS : PMIX_ERROR;\n}\n\n\nstatic int pdlopen_lookup(pmix_pdl_handle_t *handle, const char *symbol,\n                         void **ptr, char **err_msg)\n{\n    assert(handle);\n    assert(handle->dlopen_handle);\n    assert(symbol);\n    assert(ptr);\n\n    *ptr = dlsym(handle->dlopen_handle, symbol);\n    if (NULL != *ptr) {\n        return PMIX_SUCCESS;\n    }\n\n    if (NULL != err_msg) {\n        *err_msg = dlerror();\n    }\n    return PMIX_ERROR;\n}\n\n\nstatic int pdlopen_close(pmix_pdl_handle_t *handle)\n{\n    assert(handle);\n\n    int ret;\n    ret = dlclose(handle->dlopen_handle);\n\n#if PMIX_ENABLE_DEBUG\n    free(handle->filename);\n#endif\n    free(handle);\n\n    return ret;\n}\n\n/*\n * Scan all the files in a directory (or path) and invoke a callback\n * on each one.\n */\nstatic int pdlopen_foreachfile(const char *search_path,\n                              int (*func)(const char *filename, void *data),\n                              void *data)\n{\n    int ret;\n    DIR *dp = NULL;\n    char **dirs = NULL;\n    char **good_files = NULL;\n\n    dirs = pmix_argv_split(search_path, PMIX_ENV_SEP);\n    for (int i = 0; NULL != dirs && NULL != dirs[i]; ++i) {\n\n        dp = opendir(dirs[i]);\n        if (NULL == dp) {\n            ret = PMIX_ERR_IN_ERRNO;\n            goto error;\n        }\n\n        struct dirent *de;\n        while (NULL != (de = readdir(dp))) {\n\n            /* Make the absolute path name */\n            char *abs_name = NULL;\n            ret = asprintf(&abs_name, \"%s/%s\", dirs[i], de->d_name);\n            if (0 > ret) {\n                goto error;\n            }\n            if (NULL == abs_name) {\n                ret = PMIX_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Stat the file */\n            struct stat buf;\n            /* coverity[toctou] */\n            if (stat(abs_name, &buf) < 0) {\n                free(abs_name);\n                ret = PMIX_ERR_IN_ERRNO;\n                goto error;\n            }\n\n            /* Skip if not a file */\n            if (!S_ISREG(buf.st_mode)) {\n                free(abs_name);\n                continue;\n            }\n\n            /* Find the suffix */\n            char *ptr = strrchr(abs_name, '.');\n            if (NULL != ptr) {\n\n                /* Skip libtool files */\n                if (strcmp(ptr, \".la\") == 0 ||\n                    strcmp(ptr, \".lo\") == 0) {\n                    free (abs_name);\n                    continue;\n                }\n\n                *ptr = '\\0';\n            }\n\n            /* Have we already found this file?  Or already found a\n               file with the same basename (but different suffix)? */\n            bool found = false;\n            for (int j = 0; NULL != good_files &&\n                     NULL != good_files[j]; ++j) {\n                if (strcmp(good_files[j], abs_name) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                pmix_argv_append_nosize(&good_files, abs_name);\n            }\n            free(abs_name);\n        }\n        closedir(dp);\n    }\n    dp = NULL;\n\n    /* Invoke the callback on all the found files */\n    if (NULL != good_files) {\n        for (int i = 0; NULL != good_files[i]; ++i) {\n            ret = func(good_files[i], data);\n            if (PMIX_SUCCESS != ret) {\n                goto error;\n            }\n        }\n    }\n\n    ret = PMIX_SUCCESS;\n\n error:\n    if (NULL != dp) {\n        closedir(dp);\n    }\n    if (NULL != dirs) {\n        pmix_argv_free(dirs);\n    }\n    if (NULL != good_files) {\n        pmix_argv_free(good_files);\n    }\n\n    return ret;\n}\n\n\n/*\n * Module definition\n */\npmix_pdl_base_module_t pmix_pdl_pdlopen_module = {\n    .open = pdlopen_open,\n    .lookup = pdlopen_lookup,\n    .close = pdlopen_close,\n    .foreachfile = pdlopen_foreachfile\n};\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-3nm2cbtpodn7gevu77hyhtvfwxy5lviq/spack-src/.git/objects/pack/pack-9d1d4f535b452e7c71306500b697ea5e4997d2e5.idx",
        "/tmp/vanessa/spack-stage/spack-stage-pmix-master-3nm2cbtpodn7gevu77hyhtvfwxy5lviq/spack-src/.git/objects/pack/pack-9d1d4f535b452e7c71306500b697ea5e4997d2e5.pack"
    ],
    "total_files": 897
}