{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/linking/prlink.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <string.h>\n\n#ifdef XP_BEOS\n#include <image.h>\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n#include <Carbon/Carbon.h>\n#include <CoreFoundation/CoreFoundation.h>\n#endif\n\n#ifdef XP_UNIX\n#ifdef USE_DLFCN\n#include <dlfcn.h>\n/* Define these on systems that don't have them. */\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY RTLD_NOW\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n#ifdef AIX\n#include <sys/ldr.h>\n#ifndef L_IGNOREUNLOAD /* AIX 4.3.3 does not have L_IGNOREUNLOAD. */\n#define L_IGNOREUNLOAD 0x10000000\n#endif\n#endif\n#ifdef OSF1\n#include <loader.h>\n#include <rld_interface.h>\n#endif\n#elif defined(USE_HPSHL)\n#include <dl.h>\n#elif defined(USE_MACH_DYLD)\n#include <mach-o/dyld.h>\n#endif\n#endif /* XP_UNIX */\n\n#define _PR_DEFAULT_LD_FLAGS PR_LD_LAZY\n\n/*\n * On these platforms, symbols have a leading '_'.\n */\n#if (defined(DARWIN) && defined(USE_MACH_DYLD)) \\\n    || defined(XP_OS2) \\\n    || ((defined(OPENBSD) || defined(NETBSD)) && !defined(__ELF__))\n#define NEED_LEADING_UNDERSCORE\n#endif\n\n#define PR_LD_PATHW 0x8000  /* for PR_LibSpec_PathnameU */\n\n/************************************************************************/\n\nstruct PRLibrary {\n    char*                       name;  /* Our own copy of the name string */\n    PRLibrary*                  next;\n    int                         refCount;\n    const PRStaticLinkTable*    staticTable;\n\n#ifdef XP_PC\n#ifdef XP_OS2\n    HMODULE                     dlh;\n#else\n    HINSTANCE                   dlh;\n#endif\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    CFragConnectionID           connection;\n    CFBundleRef                 bundle;\n    Ptr                         main;\n    CFMutableDictionaryRef      wrappers;\n    const struct mach_header*   image;\n#endif\n\n#ifdef XP_UNIX\n#if defined(USE_HPSHL)\n    shl_t                       dlh;\n#elif defined(USE_MACH_DYLD)\n    NSModule                    dlh;\n#else\n    void*                       dlh;\n#endif \n#endif \n\n#ifdef XP_BEOS\n    void*                       dlh;\n    void*                       stub_dlh;\n#endif\n};\n\nstatic PRLibrary *pr_loadmap;\nstatic PRLibrary *pr_exe_loadmap;\nstatic PRMonitor *pr_linker_lock;\nstatic char* _pr_currentLibPath = NULL;\n\nstatic PRLibrary *pr_LoadLibraryByPathname(const char *name, PRIntn flags);\n\n/************************************************************************/\n\n#if !defined(USE_DLFCN) && !defined(HAVE_STRERROR)\n#define ERR_STR_BUF_LENGTH    20\n#endif\n\nstatic void DLLErrorInternal(PRIntn oserr)\n/*\n** This whole function, and most of the code in this file, are run\n** with a big hairy lock wrapped around it. Not the best of situations,\n** but will eventually come up with the right answer.\n*/\n{\n    const char *error = NULL;\n#ifdef USE_DLFCN\n    error = dlerror();  /* $$$ That'll be wrong some of the time - AOF */\n#elif defined(HAVE_STRERROR)\n    error = strerror(oserr);  /* this should be okay */\n#else\n    char errStrBuf[ERR_STR_BUF_LENGTH];\n    PR_snprintf(errStrBuf, sizeof(errStrBuf), \"error %d\", oserr);\n    error = errStrBuf;\n#endif\n    if (NULL != error)\n        PR_SetErrorText(strlen(error), error);\n}  /* DLLErrorInternal */\n\nvoid _PR_InitLinker(void)\n{\n    PRLibrary *lm = NULL;\n#if defined(XP_UNIX)\n    void *h;\n#endif\n\n    if (!pr_linker_lock) {\n        pr_linker_lock = PR_NewNamedMonitor(\"linker-lock\");\n    }\n    PR_EnterMonitor(pr_linker_lock);\n\n#if defined(XP_PC)\n    lm = PR_NEWZAP(PRLibrary);\n    lm->name = strdup(\"Executable\");\n#if defined(XP_OS2)\n    lm->dlh = NULLHANDLE;\n#else\n    /* A module handle for the executable. */\n    lm->dlh = GetModuleHandle(NULL);\n#endif /* ! XP_OS2 */\n\n    lm->refCount    = 1;\n    lm->staticTable = NULL;\n    pr_exe_loadmap  = lm;\n    pr_loadmap      = lm;\n\n#elif defined(XP_UNIX)\n#ifdef HAVE_DLL\n#if defined(USE_DLFCN) && !defined(NO_DLOPEN_NULL)\n    h = dlopen(0, RTLD_LAZY);\n    if (!h) {\n        char *error;\n        \n        DLLErrorInternal(_MD_ERRNO());\n        error = (char*)PR_MALLOC(PR_GetErrorTextLength());\n        (void) PR_GetErrorText(error);\n        fprintf(stderr, \"failed to initialize shared libraries [%s]\\n\",\n            error);\n        PR_DELETE(error);\n        abort();/* XXX */\n    }\n#elif defined(USE_HPSHL)\n    h = NULL;\n    /* don't abort with this NULL */\n#elif defined(USE_MACH_DYLD) || defined(NO_DLOPEN_NULL)\n    h = NULL; /* XXXX  toshok */ /* XXXX  vlad */\n#else\n#error no dll strategy\n#endif /* USE_DLFCN */\n\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm) {\n        lm->name = strdup(\"a.out\");\n        lm->refCount = 1;\n        lm->dlh = h;\n        lm->staticTable = NULL;\n    }\n    pr_exe_loadmap = lm;\n    pr_loadmap = lm;\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n\n    if (lm) {\n        PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n            (\"Loaded library %s (init)\", lm->name));\n    }\n\n    PR_ExitMonitor(pr_linker_lock);\n}\n\n/*\n * _PR_ShutdownLinker does not unload the dlls loaded by the application\n * via calls to PR_LoadLibrary.  Any dlls that still remain on the\n * pr_loadmap list when NSPR shuts down are application programming errors.\n * The only exception is pr_exe_loadmap, which was added to the list by\n * NSPR and hence should be cleaned up by NSPR.\n */\nvoid _PR_ShutdownLinker(void)\n{\n    /* FIXME: pr_exe_loadmap should be destroyed. */\n    \n    PR_DestroyMonitor(pr_linker_lock);\n    pr_linker_lock = NULL;\n\n    if (_pr_currentLibPath) {\n        free(_pr_currentLibPath);\n        _pr_currentLibPath = NULL;\n    }\n}\n\n/******************************************************************************/\n\nPR_IMPLEMENT(PRStatus) PR_SetLibraryPath(const char *path)\n{\n    PRStatus rv = PR_SUCCESS;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    PR_EnterMonitor(pr_linker_lock);\n    if (_pr_currentLibPath) {\n        free(_pr_currentLibPath);\n    }\n    if (path) {\n        _pr_currentLibPath = strdup(path);\n        if (!_pr_currentLibPath) {\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        rv = PR_FAILURE;\n        }\n    } else {\n        _pr_currentLibPath = 0;\n    }\n    PR_ExitMonitor(pr_linker_lock);\n    return rv;\n}\n\n/*\n** Return the library path for finding shared libraries.\n*/\nPR_IMPLEMENT(char *) \nPR_GetLibraryPath(void)\n{\n    char *ev;\n    char *copy = NULL;  /* a copy of _pr_currentLibPath */\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    PR_EnterMonitor(pr_linker_lock);\n    if (_pr_currentLibPath != NULL) {\n        goto exit;\n    }\n\n    /* initialize pr_currentLibPath */\n\n#ifdef XP_PC\n    ev = getenv(\"LD_LIBRARY_PATH\");\n    if (!ev) {\n    ev = \".;\\\\lib\";\n    }\n    ev = strdup(ev);\n#endif\n\n#if defined(XP_UNIX) || defined(XP_BEOS)\n#if defined(USE_DLFCN) || defined(USE_MACH_DYLD) || defined(XP_BEOS)\n    {\n    char *p=NULL;\n    int len;\n\n#ifdef XP_BEOS\n    ev = getenv(\"LIBRARY_PATH\");\n    if (!ev) {\n        ev = \"%A/lib:/boot/home/config/lib:/boot/beos/system/lib\";\n    }\n#else\n    ev = getenv(\"LD_LIBRARY_PATH\");\n    if (!ev) {\n        ev = \"/usr/lib:/lib\";\n    }\n#endif\n    len = strlen(ev) + 1;        /* +1 for the null */\n\n    p = (char*) malloc(len);\n    if (p) {\n        strcpy(p, ev);\n    }   /* if (p)  */\n    ev = p;\n    PR_LOG(_pr_io_lm, PR_LOG_NOTICE, (\"linker path '%s'\", ev));\n\n    }\n#else\n    /* AFAIK there isn't a library path with the HP SHL interface --Rob */\n    ev = strdup(\"\");\n#endif\n#endif\n\n    /*\n     * If ev is NULL, we have run out of memory\n     */\n    _pr_currentLibPath = ev;\n\n  exit:\n    if (_pr_currentLibPath) {\n        copy = strdup(_pr_currentLibPath);\n    }\n    PR_ExitMonitor(pr_linker_lock);\n    if (!copy) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    }\n    return copy;\n}\n\n/*\n** Build library name from path, lib and extensions\n*/\nPR_IMPLEMENT(char*) \nPR_GetLibraryName(const char *path, const char *lib)\n{\n    char *fullname;\n\n#ifdef XP_PC\n    if (strstr(lib, PR_DLL_SUFFIX) == NULL)\n    {\n        if (path) {\n            fullname = PR_smprintf(\"%s\\\\%s%s\", path, lib, PR_DLL_SUFFIX);\n        } else {\n            fullname = PR_smprintf(\"%s%s\", lib, PR_DLL_SUFFIX);\n        }\n    } else {\n        if (path) {\n            fullname = PR_smprintf(\"%s\\\\%s\", path, lib);\n        } else {\n            fullname = PR_smprintf(\"%s\", lib);\n        }\n    }\n#endif /* XP_PC */\n#if defined(XP_UNIX) || defined(XP_BEOS)\n    if (strstr(lib, PR_DLL_SUFFIX) == NULL)\n    {\n        if (path) {\n            fullname = PR_smprintf(\"%s/lib%s%s\", path, lib, PR_DLL_SUFFIX);\n        } else {\n            fullname = PR_smprintf(\"lib%s%s\", lib, PR_DLL_SUFFIX);\n        }\n    } else {\n        if (path) {\n            fullname = PR_smprintf(\"%s/%s\", path, lib);\n        } else {\n            fullname = PR_smprintf(\"%s\", lib);\n        }\n    }\n#endif /* XP_UNIX || XP_BEOS */\n    return fullname;\n}\n\n/*\n** Free the memory allocated, for the caller, by PR_GetLibraryName\n*/\nPR_IMPLEMENT(void) \nPR_FreeLibraryName(char *mem)\n{\n    PR_smprintf_free(mem);\n}\n\nstatic PRLibrary* \npr_UnlockedFindLibrary(const char *name)\n{\n    PRLibrary* lm = pr_loadmap;\n    const char* np = strrchr(name, PR_DIRECTORY_SEPARATOR);\n    np = np ? np + 1 : name;\n    while (lm) {\n    const char* cp = strrchr(lm->name, PR_DIRECTORY_SEPARATOR);\n    cp = cp ? cp + 1 : lm->name;\n#ifdef WIN32\n        /* Windows DLL names are case insensitive... */\n    if (strcmpi(np, cp) == 0) \n#elif defined(XP_OS2)\n    if (stricmp(np, cp) == 0)\n#else\n    if (strcmp(np, cp)  == 0) \n#endif\n    {\n        /* found */\n        lm->refCount++;\n        PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n           (\"%s incr => %d (find lib)\",\n            lm->name, lm->refCount));\n        return lm;\n    }\n    lm = lm->next;\n    }\n    return NULL;\n}\n\nPR_IMPLEMENT(PRLibrary*)\nPR_LoadLibraryWithFlags(PRLibSpec libSpec, PRIntn flags)\n{\n    if (flags == 0) {\n        flags = _PR_DEFAULT_LD_FLAGS;\n    }\n    switch (libSpec.type) {\n        case PR_LibSpec_Pathname:\n            return pr_LoadLibraryByPathname(libSpec.value.pathname, flags);\n#ifdef WIN32\n        case PR_LibSpec_PathnameU:\n            /*\n             * cast to |char *| and set PR_LD_PATHW flag so that\n             * it can be cast back to PRUnichar* in the callee.\n             */\n            return pr_LoadLibraryByPathname((const char*) \n                                            libSpec.value.pathname_u, \n                                            flags | PR_LD_PATHW);\n#endif\n        default:\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            return NULL;\n    }\n}\n            \nPR_IMPLEMENT(PRLibrary*) \nPR_LoadLibrary(const char *name)\n{\n    PRLibSpec libSpec;\n\n    libSpec.type = PR_LibSpec_Pathname;\n    libSpec.value.pathname = name;\n    return PR_LoadLibraryWithFlags(libSpec, 0);\n}\n\n#if defined(USE_MACH_DYLD)\nstatic NSModule\npr_LoadMachDyldModule(const char *name)\n{\n    NSObjectFileImage ofi;\n    NSModule h = NULL;\n    if (NSCreateObjectFileImageFromFile(name, &ofi)\n            == NSObjectFileImageSuccess) {\n        h = NSLinkModule(ofi, name, NSLINKMODULE_OPTION_PRIVATE\n                         | NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n        if (h == NULL) {\n            NSLinkEditErrors linkEditError;\n            int errorNum;\n            const char *fileName;\n            const char *errorString;\n            NSLinkEditError(&linkEditError, &errorNum, &fileName, &errorString);\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN, \n                   (\"LoadMachDyldModule error %d:%d for file %s:\\n%s\",\n                    linkEditError, errorNum, fileName, errorString));\n        }\n        if (NSDestroyObjectFileImage(ofi) == FALSE) {\n            if (h) {\n                (void)NSUnLinkModule(h, NSUNLINKMODULE_OPTION_NONE);\n                h = NULL;\n            }\n        }\n    }\n    return h;\n}\n#endif\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n\n/*\n** macLibraryLoadProc is a function definition for a Mac shared library\n** loading method. The \"name\" param is the same full or partial pathname\n** that was passed to pr_LoadLibraryByPathName. The function must fill\n** in the fields of \"lm\" which apply to its library type. Returns\n** PR_SUCCESS if successful.\n*/\n\ntypedef PRStatus (*macLibraryLoadProc)(const char *name, PRLibrary *lm);\n\n#ifdef __ppc__\n\n/*\n** CFM and its TVectors only exist on PowerPC.  Other OS X architectures\n** only use Mach-O as a native binary format.\n*/\n\nstatic void* TV2FP(CFMutableDictionaryRef dict, const char* name, void *tvp)\n{\n    static uint32 glue[6] = { 0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420 };\n    uint32* newGlue = NULL;\n\n    if (tvp != NULL) {\n        CFStringRef nameRef = CFStringCreateWithCString(NULL, name, kCFStringEncodingASCII);\n        if (nameRef) {\n            CFMutableDataRef glueData = (CFMutableDataRef) CFDictionaryGetValue(dict, nameRef);\n            if (glueData == NULL) {\n                glueData = CFDataCreateMutable(NULL, sizeof(glue));\n                if (glueData != NULL) {\n                    newGlue = (uint32*) CFDataGetMutableBytePtr(glueData);\n                    memcpy(newGlue, glue, sizeof(glue));\n                    newGlue[0] |= ((UInt32)tvp >> 16);\n                    newGlue[1] |= ((UInt32)tvp & 0xFFFF);\n                    MakeDataExecutable(newGlue, sizeof(glue));\n                    CFDictionaryAddValue(dict, nameRef, glueData);\n                    CFRelease(glueData);\n\n                    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"TV2FP: created wrapper for CFM function %s().\", name));\n                }\n            } else {\n                PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"TV2FP: found wrapper for CFM function %s().\", name));\n\n                newGlue = (uint32*) CFDataGetMutableBytePtr(glueData);\n            }\n            CFRelease(nameRef);\n        }\n    }\n    \n    return newGlue;\n}\n\nstatic PRStatus\npr_LoadViaCFM(const char *name, PRLibrary *lm)\n{\n    OSErr err;\n    Str255 errName;\n    FSRef ref;\n    FSSpec fileSpec;\n    Boolean tempUnusedBool;\n\n    /*\n     * Make an FSSpec from the path name and call GetDiskFragment.\n     */\n\n    /* Use direct conversion of POSIX path to FSRef to FSSpec. */\n    err = FSPathMakeRef((const UInt8*)name, &ref, NULL);\n    if (err != noErr)\n        return PR_FAILURE;\n    err = FSGetCatalogInfo(&ref, kFSCatInfoNone, NULL, NULL,\n                           &fileSpec, NULL);\n    if (err != noErr)\n        return PR_FAILURE;\n\n    /* Resolve an alias if this was one */\n    err = ResolveAliasFile(&fileSpec, true, &tempUnusedBool,\n                           &tempUnusedBool);\n    if (err != noErr)\n        return PR_FAILURE;\n\n    /* Finally, try to load the library */\n    err = GetDiskFragment(&fileSpec, 0, kCFragGoesToEOF, fileSpec.name,\n                          kLoadCFrag, &lm->connection, &lm->main, errName);\n\n    if (err == noErr && lm->connection) {\n        /*\n         * if we're a mach-o binary, need to wrap all CFM function\n         * pointers. need a hash-table of already seen function\n         * pointers, etc.\n         */\n        lm->wrappers = CFDictionaryCreateMutable(NULL, 16,\n                       &kCFTypeDictionaryKeyCallBacks,\n                       &kCFTypeDictionaryValueCallBacks);\n        if (lm->wrappers) {\n            lm->main = TV2FP(lm->wrappers, \"main\", lm->main);\n        } else\n            err = memFullErr;\n    }\n    return (err == noErr) ? PR_SUCCESS : PR_FAILURE;\n}\n#endif /* __ppc__ */\n\n/*\n** Creates a CFBundleRef if the pathname refers to a Mac OS X bundle\n** directory. The caller is responsible for calling CFRelease() to\n** deallocate.\n*/\n\nstatic PRStatus\npr_LoadCFBundle(const char *name, PRLibrary *lm)\n{\n    CFURLRef bundleURL;\n    CFBundleRef bundle = NULL;\n    char pathBuf[PATH_MAX];\n    const char *resolvedPath;\n    CFStringRef pathRef;\n\n    /* Takes care of relative paths and symlinks */\n    resolvedPath = realpath(name, pathBuf);\n    if (!resolvedPath)\n        return PR_FAILURE;\n        \n    pathRef = CFStringCreateWithCString(NULL, pathBuf, kCFStringEncodingUTF8);\n    if (pathRef) {\n        bundleURL = CFURLCreateWithFileSystemPath(NULL, pathRef,\n                                                  kCFURLPOSIXPathStyle, true);\n        if (bundleURL) {\n            bundle = CFBundleCreate(NULL, bundleURL);\n            CFRelease(bundleURL);\n        }\n        CFRelease(pathRef);\n    }\n\n    lm->bundle = bundle;\n    return (bundle != NULL) ? PR_SUCCESS : PR_FAILURE;\n}\n\nstatic PRStatus\npr_LoadViaDyld(const char *name, PRLibrary *lm)\n{\n    lm->dlh = pr_LoadMachDyldModule(name);\n    if (lm->dlh == NULL) {\n        lm->image = NSAddImage(name, NSADDIMAGE_OPTION_RETURN_ON_ERROR\n                               | NSADDIMAGE_OPTION_WITH_SEARCHING);\n        if (lm->image == NULL) {\n            NSLinkEditErrors linkEditError;\n            int errorNum;\n            const char *fileName;\n            const char *errorString;\n            NSLinkEditError(&linkEditError, &errorNum, &fileName, &errorString);\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN, \n                   (\"LoadMachDyldModule error %d:%d for file %s:\\n%s\",\n                    linkEditError, errorNum, fileName, errorString));\n        }\n    }\n    return (lm->dlh != NULL || lm->image != NULL) ? PR_SUCCESS : PR_FAILURE;\n}\n\n#endif /* XP_MACOSX && USE_MACH_DYLD */\n\n/*\n** Dynamically load a library. Only load libraries once, so scan the load\n** map first.\n*/\nstatic PRLibrary*\npr_LoadLibraryByPathname(const char *name, PRIntn flags)\n{\n    PRLibrary *lm;\n    PRLibrary* result = NULL;\n    PRInt32 oserr;\n#ifdef WIN32\n    char utf8name_stack[MAX_PATH];\n    char *utf8name_malloc = NULL;\n    char *utf8name = utf8name_stack;\n    PRUnichar wname_stack[MAX_PATH];\n    PRUnichar *wname_malloc = NULL;\n    PRUnichar *wname = wname_stack;\n    int len;\n#endif\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    /* See if library is already loaded */\n    PR_EnterMonitor(pr_linker_lock);\n\n#ifdef WIN32\n    if (flags & PR_LD_PATHW) {\n        /* cast back what's cast to |char *| for the argument passing. */\n        wname = (LPWSTR) name;\n    } else {\n        int wlen = MultiByteToWideChar(CP_ACP, 0, name, -1, NULL, 0);\n        if (wlen > MAX_PATH)\n            wname = wname_malloc = PR_Malloc(wlen * sizeof(PRUnichar));\n        if (wname == NULL ||\n            !MultiByteToWideChar(CP_ACP, 0,  name, -1, wname, wlen)) {\n            oserr = _MD_ERRNO();\n            goto unlock;\n        }\n    }\n    len = WideCharToMultiByte(CP_UTF8, 0, wname, -1, NULL, 0, NULL, NULL);\n    if (len > MAX_PATH)\n        utf8name = utf8name_malloc = PR_Malloc(len);\n    if (utf8name == NULL ||\n        !WideCharToMultiByte(CP_UTF8, 0, wname, -1,\n                             utf8name, len, NULL, NULL)) {\n        oserr = _MD_ERRNO();\n        goto unlock;\n    }\n    /* the list of loaded library names are always kept in UTF-8 \n     * on Win32 platforms */\n    result = pr_UnlockedFindLibrary(utf8name);\n#else\n    result = pr_UnlockedFindLibrary(name);\n#endif\n\n    if (result != NULL) goto unlock;\n\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm == NULL) {\n        oserr = _MD_ERRNO();\n        goto unlock;\n    }\n    lm->staticTable = NULL;\n\n#ifdef XP_OS2  /* Why isn't all this stuff in MD code?! */\n    {\n        HMODULE h;\n        UCHAR pszError[_MAX_PATH];\n        ULONG ulRc = NO_ERROR;\n\n          ulRc = DosLoadModule(pszError, _MAX_PATH, (PSZ) name, &h);\n          if (ulRc != NO_ERROR) {\n              oserr = ulRc;\n              PR_DELETE(lm);\n              goto unlock;\n          }\n          lm->name = strdup(name);\n          lm->dlh  = h;\n          lm->next = pr_loadmap;\n          pr_loadmap = lm;\n    }\n#endif /* XP_OS2 */\n\n#ifdef WIN32\n    {\n    HINSTANCE h;\n\n    h = LoadLibraryExW(wname, NULL,\n                       (flags & PR_LD_ALT_SEARCH_PATH) ?\n                       LOAD_WITH_ALTERED_SEARCH_PATH : 0);\n    if (h == NULL) {\n        oserr = _MD_ERRNO();\n        PR_DELETE(lm);\n        goto unlock;\n    }\n    lm->name = strdup(utf8name);\n    lm->dlh = h;\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif /* WIN32 */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    {\n    int     i;\n    PRStatus status;\n\n    static const macLibraryLoadProc loadProcs[] = {\n#ifdef __ppc__\n        pr_LoadViaDyld, pr_LoadCFBundle, pr_LoadViaCFM\n#else  /* __ppc__ */\n        pr_LoadViaDyld, pr_LoadCFBundle\n#endif /* __ppc__ */\n    };\n\n    for (i = 0; i < sizeof(loadProcs) / sizeof(loadProcs[0]); i++) {\n        if ((status = loadProcs[i](name, lm)) == PR_SUCCESS)\n            break;\n    }\n    if (status != PR_SUCCESS) {\n        oserr = cfragNoLibraryErr;\n        PR_DELETE(lm);\n        goto unlock;        \n    }\n    lm->name = strdup(name);\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif\n\n#if defined(XP_UNIX) && !(defined(XP_MACOSX) && defined(USE_MACH_DYLD))\n#ifdef HAVE_DLL\n    {\n#if defined(USE_DLFCN)\n#ifdef NTO\n    /* Neutrino needs RTLD_GROUP to load Netscape plugins. (bug 71179) */\n    int dl_flags = RTLD_GROUP;\n#elif defined(AIX)\n    /* AIX needs RTLD_MEMBER to load an archive member.  (bug 228899) */\n    int dl_flags = RTLD_MEMBER;\n#else\n    int dl_flags = 0;\n#endif\n    void *h = NULL;\n\n    if (flags & PR_LD_LAZY) {\n        dl_flags |= RTLD_LAZY;\n    }\n    if (flags & PR_LD_NOW) {\n        dl_flags |= RTLD_NOW;\n    }\n    if (flags & PR_LD_GLOBAL) {\n        dl_flags |= RTLD_GLOBAL;\n    }\n    if (flags & PR_LD_LOCAL) {\n        dl_flags |= RTLD_LOCAL;\n    }\n#if defined(DARWIN)\n    /* ensure the file exists if it contains a slash character i.e. path */\n    /* DARWIN's dlopen ignores the provided path and checks for the */\n    /* plain filename in DYLD_LIBRARY_PATH */\n    if (strchr(name, PR_DIRECTORY_SEPARATOR) == NULL ||\n        PR_Access(name, PR_ACCESS_EXISTS) == PR_SUCCESS) {\n            h = dlopen(name, dl_flags);\n        }\n#else\n    h = dlopen(name, dl_flags);\n#endif\n#elif defined(USE_HPSHL)\n    int shl_flags = 0;\n    shl_t h;\n\n    /*\n     * Use the DYNAMIC_PATH flag only if 'name' is a plain file\n     * name (containing no directory) to match the behavior of\n     * dlopen().\n     */\n    if (strchr(name, PR_DIRECTORY_SEPARATOR) == NULL) {\n        shl_flags |= DYNAMIC_PATH;\n    }\n    if (flags & PR_LD_LAZY) {\n        shl_flags |= BIND_DEFERRED;\n    }\n    if (flags & PR_LD_NOW) {\n        shl_flags |= BIND_IMMEDIATE;\n    }\n    /* No equivalent of PR_LD_GLOBAL and PR_LD_LOCAL. */\n    h = shl_load(name, shl_flags, 0L);\n#elif defined(USE_MACH_DYLD)\n    NSModule h = pr_LoadMachDyldModule(name);\n#else\n#error Configuration error\n#endif\n    if (!h) {\n        oserr = _MD_ERRNO();\n        PR_DELETE(lm);\n        goto unlock;\n    }\n    lm->name = strdup(name);\n    lm->dlh = h;\n    lm->next = pr_loadmap;\n    pr_loadmap = lm;\n    }\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX && !(XP_MACOSX && USE_MACH_DYLD) */\n\n    lm->refCount = 1;\n\n#ifdef XP_BEOS\n    {\n        image_info info;\n        int32 cookie = 0;\n        image_id imageid = B_ERROR;\n        image_id stubid = B_ERROR;\n        PRLibrary *p;\n\n        for (p = pr_loadmap; p != NULL; p = p->next) {\n            /* hopefully, our caller will always use the same string\n               to refer to the same library */\n            if (strcmp(name, p->name) == 0) {\n                /* we've already loaded this library */\n                imageid = info.id;\n                lm->refCount++;\n                break;\n            }\n        }\n\n        if(imageid == B_ERROR) {\n            /* it appears the library isn't yet loaded - load it now */\n            char stubName [B_PATH_NAME_LENGTH + 1];\n\n            /* the following is a work-around to a \"bug\" in the beos -\n               the beos system loader allows only 32M (system-wide)\n               to be used by code loaded as \"add-ons\" (code loaded\n               through the 'load_add_on()' system call, which includes\n               mozilla components), but allows 256M to be used by\n               shared libraries.\n               \n               unfortunately, mozilla is too large to fit into the\n               \"add-on\" space, so we must trick the loader into\n               loading some of the components as shared libraries.  this\n               is accomplished by creating a \"stub\" add-on (an empty\n               shared object), and linking it with the component\n               (the actual .so file generated by the build process,\n               without any modifications).  when this stub is loaded\n               by load_add_on(), the loader will automatically load the\n               component into the shared library space.\n            */\n\n            strcpy(stubName, name);\n            strcat(stubName, \".stub\");\n\n            /* first, attempt to load the stub (thereby loading the\n               component as a shared library */\n            if ((stubid = load_add_on(stubName)) > B_ERROR) {\n                /* the stub was loaded successfully. */\n                imageid = B_FILE_NOT_FOUND;\n\n                cookie = 0;\n                while (get_next_image_info(0, &cookie, &info) == B_OK) {\n                    const char *endOfSystemName = strrchr(info.name, '/');\n                    const char *endOfPassedName = strrchr(name, '/');\n                    if( 0 == endOfSystemName ) \n                        endOfSystemName = info.name;\n                    else\n                        endOfSystemName++;\n                    if( 0 == endOfPassedName )\n                        endOfPassedName = name;\n                    else\n                        endOfPassedName++;\n                    if (strcmp(endOfSystemName, endOfPassedName) == 0) {\n                        /* this is the actual component - remember it */\n                        imageid = info.id;\n                        break;\n                    }\n                }\n\n            } else {\n                /* we failed to load the \"stub\" - try to load the\n                   component directly as an add-on */\n                stubid = B_ERROR;\n                imageid = load_add_on(name);\n            }\n        }\n\n        if (imageid <= B_ERROR) {\n            oserr = imageid;\n            PR_DELETE( lm );\n            goto unlock;\n        }\n        lm->name = strdup(name);\n        lm->dlh = (void*)imageid;\n        lm->stub_dlh = (void*)stubid;\n        lm->next = pr_loadmap;\n        pr_loadmap = lm;\n    }\n#endif\n\n    result = lm;    /* success */\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Loaded library %s (load lib)\", lm->name));\n\n  unlock:\n    if (result == NULL) {\n        PR_SetError(PR_LOAD_LIBRARY_ERROR, oserr);\n        DLLErrorInternal(oserr);  /* sets error text */\n    }\n#ifdef WIN32\n    if (utf8name_malloc) \n        PR_Free(utf8name_malloc);\n    if (wname_malloc)\n        PR_Free(wname_malloc);\n#endif\n    PR_ExitMonitor(pr_linker_lock);\n    return result;\n}\n\n/*\n** Unload a shared library which was loaded via PR_LoadLibrary\n*/\nPR_IMPLEMENT(PRStatus) \nPR_UnloadLibrary(PRLibrary *lib)\n{\n    int result = 0;\n    PRStatus status = PR_SUCCESS;\n\n    if (lib == 0) {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    PR_EnterMonitor(pr_linker_lock);\n\n    if (lib->refCount <= 0) {\n        PR_ExitMonitor(pr_linker_lock);\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    if (--lib->refCount > 0) {\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n           (\"%s decr => %d\",\n        lib->name, lib->refCount));\n    goto done;\n    }\n\n#ifdef XP_BEOS\n    if(((image_id)lib->stub_dlh) == B_ERROR)\n        unload_add_on( (image_id) lib->dlh );\n    else\n        unload_add_on( (image_id) lib->stub_dlh);\n#endif\n\n#ifdef XP_UNIX\n#ifdef HAVE_DLL\n#ifdef USE_DLFCN\n    result = dlclose(lib->dlh);\n#elif defined(USE_HPSHL)\n    result = shl_unload(lib->dlh);\n#elif defined(USE_MACH_DYLD)\n    if (lib->dlh)\n        result = NSUnLinkModule(lib->dlh, NSUNLINKMODULE_OPTION_NONE) ? 0 : -1;\n#else\n#error Configuration error\n#endif\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n#ifdef XP_PC\n    if (lib->dlh) {\n        FreeLibrary((HINSTANCE)(lib->dlh));\n        lib->dlh = (HINSTANCE)NULL;\n    }\n#endif  /* XP_PC */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n    /* Close the connection */\n    if (lib->connection)\n        CloseConnection(&(lib->connection));\n    if (lib->bundle)\n        CFRelease(lib->bundle);\n    if (lib->wrappers)\n        CFRelease(lib->wrappers);\n    /* No way to unload an image (lib->image) */\n#endif\n\n    /* unlink from library search list */\n    if (pr_loadmap == lib)\n        pr_loadmap = pr_loadmap->next;\n    else if (pr_loadmap != NULL) {\n        PRLibrary* prev = pr_loadmap;\n        PRLibrary* next = pr_loadmap->next;\n        while (next != NULL) {\n            if (next == lib) {\n                prev->next = next->next;\n                goto freeLib;\n            }\n            prev = next;\n            next = next->next;\n        }\n        /*\n         * fail (the library is not on the _pr_loadmap list),\n         * but don't wipe out an error from dlclose/shl_unload.\n         */\n        PR_NOT_REACHED(\"_pr_loadmap and lib->refCount inconsistent\");\n        if (result == 0) {\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            status = PR_FAILURE;\n        }\n    }\n    /*\n     * We free the PRLibrary structure whether dlclose/shl_unload\n     * succeeds or not.\n     */\n\n  freeLib:\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Unloaded library %s\", lib->name));\n    free(lib->name);\n    lib->name = NULL;\n    PR_DELETE(lib);\n    if (result != 0) {\n        PR_SetError(PR_UNLOAD_LIBRARY_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        status = PR_FAILURE;\n    }\n\ndone:\n    PR_ExitMonitor(pr_linker_lock);\n    return status;\n}\n\nstatic void* \npr_FindSymbolInLib(PRLibrary *lm, const char *name)\n{\n    void *f = NULL;\n#ifdef XP_OS2\n    int rc;\n#endif\n\n    if (lm->staticTable != NULL) {\n        const PRStaticLinkTable* tp;\n        for (tp = lm->staticTable; tp->name; tp++) {\n            if (strcmp(name, tp->name) == 0) {\n                return (void*) tp->fp;\n            }\n        }\n        /* \n        ** If the symbol was not found in the static table then check if\n        ** the symbol was exported in the DLL... Win16 only!!\n        */\n#if !defined(WIN16) && !defined(XP_BEOS)\n        PR_SetError(PR_FIND_SYMBOL_ERROR, 0);\n        return (void*)NULL;\n#endif\n    }\n    \n#ifdef XP_OS2\n    rc = DosQueryProcAddr(lm->dlh, 0, (PSZ) name, (PFN *) &f);\n#if defined(NEED_LEADING_UNDERSCORE)\n    /*\n     * Older plugins (not built using GCC) will have symbols that are not\n     * underscore prefixed.  We check for that here.\n     */\n    if (rc != NO_ERROR) {\n        name++;\n        DosQueryProcAddr(lm->dlh, 0, (PSZ) name, (PFN *) &f);\n    }\n#endif\n#endif  /* XP_OS2 */\n\n#ifdef WIN32\n    f = GetProcAddress(lm->dlh, name);\n#endif  /* WIN32 */\n\n#if defined(XP_MACOSX) && defined(USE_MACH_DYLD)\n/* add this offset to skip the leading underscore in name */\n#define SYM_OFFSET 1\n    if (lm->bundle) {\n        CFStringRef nameRef = CFStringCreateWithCString(NULL, name + SYM_OFFSET, kCFStringEncodingASCII);\n        if (nameRef) {\n            f = CFBundleGetFunctionPointerForName(lm->bundle, nameRef);\n            CFRelease(nameRef);\n        }\n    }\n    if (lm->connection) {\n        Ptr                 symAddr;\n        CFragSymbolClass    symClass;\n        Str255              pName;\n        \n        PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Looking up symbol: %s\", name + SYM_OFFSET));\n        \n        c2pstrcpy(pName, name + SYM_OFFSET);\n        \n        f = (FindSymbol(lm->connection, pName, &symAddr, &symClass) == noErr) ? symAddr : NULL;\n        \n#ifdef __ppc__\n        /* callers expect mach-o function pointers, so must wrap tvectors with glue. */\n        if (f && symClass == kTVectorCFragSymbol) {\n            f = TV2FP(lm->wrappers, name + SYM_OFFSET, f);\n        }\n#endif /* __ppc__ */\n        \n        if (f == NULL && strcmp(name + SYM_OFFSET, \"main\") == 0) f = lm->main;\n    }\n    if (lm->image) {\n        NSSymbol symbol;\n        symbol = NSLookupSymbolInImage(lm->image, name,\n                 NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n                 | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n        if (symbol != NULL)\n            f = NSAddressOfSymbol(symbol);\n        else\n            f = NULL;\n    }\n#undef SYM_OFFSET\n#endif /* XP_MACOSX && USE_MACH_DYLD */\n\n#ifdef XP_BEOS\n    if( B_NO_ERROR != get_image_symbol( (image_id)lm->dlh, name, B_SYMBOL_TYPE_TEXT, &f ) ) {\n        f = NULL;\n    }\n#endif\n\n#ifdef XP_UNIX\n#ifdef HAVE_DLL\n#ifdef USE_DLFCN\n    f = dlsym(lm->dlh, name);\n#elif defined(USE_HPSHL)\n    if (shl_findsym(&lm->dlh, name, TYPE_PROCEDURE, &f) == -1) {\n        f = NULL;\n    }\n#elif defined(USE_MACH_DYLD)\n    if (lm->dlh) {\n        NSSymbol symbol;\n        symbol = NSLookupSymbolInModule(lm->dlh, name);\n        if (symbol != NULL)\n            f = NSAddressOfSymbol(symbol);\n        else\n            f = NULL;\n    }\n#endif\n#endif /* HAVE_DLL */\n#endif /* XP_UNIX */\n    if (f == NULL) {\n        PR_SetError(PR_FIND_SYMBOL_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n    }\n    return f;\n}\n\n/*\n** Called by class loader to resolve missing native's\n*/\nPR_IMPLEMENT(void*) \nPR_FindSymbol(PRLibrary *lib, const char *raw_name)\n{\n    void *f = NULL;\n#if defined(NEED_LEADING_UNDERSCORE)\n    char *name;\n#else\n    const char *name;\n#endif\n    /*\n    ** Mangle the raw symbol name in any way that is platform specific.\n    */\n#if defined(NEED_LEADING_UNDERSCORE)\n    /* Need a leading _ */\n    name = PR_smprintf(\"_%s\", raw_name);\n#elif defined(AIX)\n    /*\n    ** AIX with the normal linker put's a \".\" in front of the symbol\n    ** name.  When use \"svcc\" and \"svld\" then the \".\" disappears. Go\n    ** figure.\n    */\n    name = raw_name;\n#else\n    name = raw_name;\n#endif\n\n    PR_EnterMonitor(pr_linker_lock);\n    PR_ASSERT(lib != NULL);\n    f = pr_FindSymbolInLib(lib, name);\n\n#if defined(NEED_LEADING_UNDERSCORE)\n    PR_smprintf_free(name);\n#endif\n\n    PR_ExitMonitor(pr_linker_lock);\n    return f;\n}\n\n/*\n** Return the address of the function 'raw_name' in the library 'lib'\n*/\nPR_IMPLEMENT(PRFuncPtr) \nPR_FindFunctionSymbol(PRLibrary *lib, const char *raw_name)\n{\n    return ((PRFuncPtr) PR_FindSymbol(lib, raw_name));\n}\n\nPR_IMPLEMENT(void*) \nPR_FindSymbolAndLibrary(const char *raw_name, PRLibrary* *lib)\n{\n    void *f = NULL;\n#if defined(NEED_LEADING_UNDERSCORE)\n    char *name;\n#else\n    const char *name;\n#endif\n    PRLibrary* lm;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    /*\n    ** Mangle the raw symbol name in any way that is platform specific.\n    */\n#if defined(NEED_LEADING_UNDERSCORE)\n    /* Need a leading _ */\n    name = PR_smprintf(\"_%s\", raw_name);\n#elif defined(AIX)\n    /*\n    ** AIX with the normal linker put's a \".\" in front of the symbol\n    ** name.  When use \"svcc\" and \"svld\" then the \".\" disappears. Go\n    ** figure.\n    */\n    name = raw_name;\n#else\n    name = raw_name;\n#endif\n\n    PR_EnterMonitor(pr_linker_lock);\n\n    /* search all libraries */\n    for (lm = pr_loadmap; lm != NULL; lm = lm->next) {\n        f = pr_FindSymbolInLib(lm, name);\n        if (f != NULL) {\n            *lib = lm;\n            lm->refCount++;\n            PR_LOG(_pr_linker_lm, PR_LOG_MIN,\n                       (\"%s incr => %d (for %s)\",\n                    lm->name, lm->refCount, name));\n            break;\n        }\n    }\n#if defined(NEED_LEADING_UNDERSCORE)\n    PR_smprintf_free(name);\n#endif\n\n    PR_ExitMonitor(pr_linker_lock);\n    return f;\n}\n\nPR_IMPLEMENT(PRFuncPtr) \nPR_FindFunctionSymbolAndLibrary(const char *raw_name, PRLibrary* *lib)\n{\n    return ((PRFuncPtr) PR_FindSymbolAndLibrary(raw_name, lib));\n}\n\n/*\n** Add a static library to the list of loaded libraries. If LoadLibrary\n** is called with the name then we will pretend it was already loaded\n*/\nPR_IMPLEMENT(PRLibrary*) \nPR_LoadStaticLibrary(const char *name, const PRStaticLinkTable *slt)\n{\n    PRLibrary *lm=NULL;\n    PRLibrary* result = NULL;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    /* See if library is already loaded */\n    PR_EnterMonitor(pr_linker_lock);\n\n    /* If the lbrary is already loaded, then add the static table information... */\n    result = pr_UnlockedFindLibrary(name);\n    if (result != NULL) {\n        PR_ASSERT( (result->staticTable == NULL) || (result->staticTable == slt) );\n        result->staticTable = slt;\n        goto unlock;\n    }\n\n    /* Add library to list...Mark it static */\n    lm = PR_NEWZAP(PRLibrary);\n    if (lm == NULL) goto unlock;\n\n    lm->name = strdup(name);\n    lm->refCount    = 1;\n    lm->dlh         = pr_exe_loadmap ? pr_exe_loadmap->dlh : 0;\n    lm->staticTable = slt;\n    lm->next        = pr_loadmap;\n    pr_loadmap      = lm;\n\n    result = lm;    /* success */\n    PR_ASSERT(lm->refCount == 1);\n    PR_LOG(_pr_linker_lm, PR_LOG_MIN, (\"Loaded library %s (static lib)\", lm->name));\n  unlock:\n    PR_ExitMonitor(pr_linker_lock);\n    return result;\n}\n\nPR_IMPLEMENT(char *)\nPR_GetLibraryFilePathname(const char *name, PRFuncPtr addr)\n{\n#if defined(USE_DLFCN) && defined(HAVE_DLADDR)\n    Dl_info dli;\n    char *result;\n\n    if (dladdr((void *)addr, &dli) == 0) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(dli.dli_fname)+1);\n    if (result != NULL) {\n        strcpy(result, dli.dli_fname);\n    }\n    return result;\n#elif defined(USE_MACH_DYLD)\n    char *result;\n    const char *image_name;\n    int i, count = _dyld_image_count();\n\n    for (i = 0; i < count; i++) {\n        image_name = _dyld_get_image_name(i);\n        if (strstr(image_name, name) != NULL) {\n            result = PR_Malloc(strlen(image_name)+1);\n            if (result != NULL) {\n                strcpy(result, image_name);\n            }\n            return result;\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(AIX)\n    char *result;\n#define LD_INFO_INCREMENT 64\n    struct ld_info *info;\n    unsigned int info_length = LD_INFO_INCREMENT * sizeof(struct ld_info);\n    struct ld_info *infop;\n    int loadflags = L_GETINFO | L_IGNOREUNLOAD;\n\n    for (;;) {\n        info = PR_Malloc(info_length);\n        if (info == NULL) {\n            return NULL;\n        }\n        /* If buffer is too small, loadquery fails with ENOMEM. */\n        if (loadquery(loadflags, info, info_length) != -1) {\n            break;\n        }\n        /*\n         * Calling loadquery when compiled for 64-bit with the\n         * L_IGNOREUNLOAD flag can cause an invalid argument error\n         * on AIX 5.1. Detect this error the first time that\n         * loadquery is called, and try calling it again without\n         * this flag set.\n         */\n        if (errno == EINVAL && (loadflags & L_IGNOREUNLOAD)) {\n            loadflags &= ~L_IGNOREUNLOAD;\n            if (loadquery(loadflags, info, info_length) != -1) {\n                break;\n            }\n        }\n        PR_Free(info);\n        if (errno != ENOMEM) {\n            /* should not happen */\n            _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n            return NULL;\n        }\n        /* retry with a larger buffer */\n        info_length += LD_INFO_INCREMENT * sizeof(struct ld_info);\n    }\n\n    for (infop = info;\n         ;\n         infop = (struct ld_info *)((char *)infop + infop->ldinfo_next)) {\n        unsigned long start = (unsigned long)infop->ldinfo_dataorg;\n        unsigned long end = start + infop->ldinfo_datasize;\n        if (start <= (unsigned long)addr && end > (unsigned long)addr) {\n            result = PR_Malloc(strlen(infop->ldinfo_filename)+1);\n            if (result != NULL) {\n                strcpy(result, infop->ldinfo_filename);\n            }\n            break;\n        }\n        if (!infop->ldinfo_next) {\n            PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n            result = NULL;\n            break;\n        }\n    }\n    PR_Free(info);\n    return result;\n#elif defined(OSF1)\n    /* Contributed by Steve Streeter of HP */\n    ldr_process_t process, ldr_my_process();\n    ldr_module_t mod_id;\n    ldr_module_info_t info;\n    ldr_region_t regno;\n    ldr_region_info_t reginfo;\n    size_t retsize;\n    int rv;\n    char *result;\n\n    /* Get process for which dynamic modules will be listed */\n\n    process = ldr_my_process();\n\n    /* Attach to process */\n\n    rv = ldr_xattach(process);\n    if (rv) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n\n    /* Print information for list of modules */\n\n    mod_id = LDR_NULL_MODULE;\n\n    for (;;) {\n\n        /* Get information for the next module in the module list. */\n\n        ldr_next_module(process, &mod_id);\n        if (ldr_inq_module(process, mod_id, &info, sizeof(info),\n                           &retsize) != 0) {\n            /* No more modules */\n            break;\n        }\n        if (retsize < sizeof(info)) {\n            continue;\n        }\n\n        /*\n         * Get information for each region in the module and check if any\n         * contain the address of this function.\n         */\n\n        for (regno = 0; ; regno++) {\n            if (ldr_inq_region(process, mod_id, regno, &reginfo,\n                               sizeof(reginfo), &retsize) != 0) {\n                /* No more regions */\n                break;\n            }\n            if (((unsigned long)reginfo.lri_mapaddr <=\n                (unsigned long)addr) &&\n                (((unsigned long)reginfo.lri_mapaddr + reginfo.lri_size) >\n                (unsigned long)addr)) {\n                /* Found it. */\n                result = PR_Malloc(strlen(info.lmi_name)+1);\n                if (result != NULL) {\n                    strcpy(result, info.lmi_name);\n                }\n                return result;\n            }\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(HPUX) && defined(USE_HPSHL)\n    int index;\n    struct shl_descriptor desc;\n    char *result;\n\n    for (index = 0; shl_get_r(index, &desc) == 0; index++) {\n        if (strstr(desc.filename, name) != NULL) {\n            result = PR_Malloc(strlen(desc.filename)+1);\n            if (result != NULL) {\n                strcpy(result, desc.filename);\n            }\n            return result;\n        }\n    }\n    /*\n     * Since the index value of a library is decremented if\n     * a library preceding it in the shared library search\n     * list was unloaded, it is possible that we missed some\n     * libraries as we went up the list.  So we should go\n     * down the list to be sure that we not miss anything.\n     */\n    for (index--; index >= 0; index--) {\n        if ((shl_get_r(index, &desc) == 0)\n                && (strstr(desc.filename, name) != NULL)) {\n            result = PR_Malloc(strlen(desc.filename)+1);\n            if (result != NULL) {\n                strcpy(result, desc.filename);\n            }\n            return result;\n        }\n    }\n    PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, 0);\n    return NULL;\n#elif defined(HPUX) && defined(USE_DLFCN)\n    struct load_module_desc desc;\n    char *result;\n    const char *module_name;\n\n    if (dlmodinfo((unsigned long)addr, &desc, sizeof desc, NULL, 0, 0) == 0) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    module_name = dlgetname(&desc, sizeof desc, NULL, 0, 0);\n    if (module_name == NULL) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(module_name)+1);\n    if (result != NULL) {\n        strcpy(result, module_name);\n    }\n    return result;\n#elif defined(WIN32)\n    PRUnichar wname[MAX_PATH];\n    HMODULE handle = NULL;\n    PRUnichar module_name[MAX_PATH];\n    int len;\n    char *result;\n\n    if (MultiByteToWideChar(CP_ACP, 0, name, -1, wname, MAX_PATH)) {\n        handle = GetModuleHandleW(wname);\n    }\n    if (handle == NULL) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    if (GetModuleFileNameW(handle, module_name, MAX_PATH) == 0) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    len = WideCharToMultiByte(CP_ACP, 0, module_name, -1,\n                              NULL, 0, NULL, NULL);\n    if (len == 0) {\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(len * sizeof(PRUnichar));\n    if (result != NULL) {\n        WideCharToMultiByte(CP_ACP, 0, module_name, -1,\n                            result, len, NULL, NULL);\n    }\n    return result;\n#elif defined(XP_OS2)\n    HMODULE module = NULL;\n    char module_name[_MAX_PATH];\n    char *result;\n    APIRET ulrc = DosQueryModFromEIP(&module, NULL, 0, NULL, NULL, (ULONG) addr);\n    if ((NO_ERROR != ulrc) || (NULL == module) ) {\n        PR_SetError(PR_LIBRARY_NOT_LOADED_ERROR, _MD_ERRNO());\n        DLLErrorInternal(_MD_ERRNO());\n        return NULL;\n    }\n    ulrc = DosQueryModuleName(module, sizeof module_name, module_name);\n    if (NO_ERROR != ulrc) {\n        /* should not happen */\n        _PR_MD_MAP_DEFAULT_ERROR(_MD_ERRNO());\n        return NULL;\n    }\n    result = PR_Malloc(strlen(module_name)+1);\n    if (result != NULL) {\n        strcpy(result, module_name);\n    }\n    return result;\n#else\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/malloc/prmem.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n** Thread safe versions of malloc, free, realloc, calloc and cfree.\n*/\n\n#include \"primpl.h\"\n\n#ifdef _PR_ZONE_ALLOCATOR\n\n/*\n** The zone allocator code must use native mutexes and cannot\n** use PRLocks because PR_NewLock calls PR_Calloc, resulting\n** in cyclic dependency of initialization.\n*/\n\n#include <string.h>\t\n\nunion memBlkHdrUn;\n\ntypedef struct MemoryZoneStr {\n    union memBlkHdrUn    *head;         /* free list */\n    pthread_mutex_t       lock;\n    size_t                blockSize;    /* size of blocks on this free list */\n    PRUint32              locked;       /* current state of lock */\n    PRUint32              contention;   /* counter: had to wait for lock */\n    PRUint32              hits;         /* allocated from free list */\n    PRUint32              misses;       /* had to call malloc */\n    PRUint32              elements;     /* on free list */\n} MemoryZone;\n\ntypedef union memBlkHdrUn {\n    unsigned char filler[48];  /* fix the size of this beast */\n    struct memBlkHdrStr {\n        union memBlkHdrUn    *next;\n        MemoryZone           *zone;\n        size_t                blockSize;\n        size_t                requestedSize;\n        PRUint32              magic;\n    } s;\n} MemBlockHdr;\n\n#define MEM_ZONES     7\n#define THREAD_POOLS 11  /* prime number for modulus */\n#define ZONE_MAGIC  0x0BADC0DE\n\nstatic MemoryZone zones[MEM_ZONES][THREAD_POOLS];\n\nstatic PRBool use_zone_allocator = PR_FALSE;\n\nstatic void pr_ZoneFree(void *ptr);\n\nvoid\n_PR_DestroyZones(void)\n{   \n    int i, j;\n\n    if (!use_zone_allocator)\n        return;\n    \n    for (j = 0; j < THREAD_POOLS; j++) {\n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone *mz = &zones[i][j];\n            pthread_mutex_destroy(&mz->lock);\n            while (mz->head) {\n                MemBlockHdr *hdr = mz->head;\n                mz->head = hdr->s.next;  /* unlink it */\n                free(hdr);\n                mz->elements--;\n            }\n        }\n    } \n    use_zone_allocator = PR_FALSE;\n} \n\n/*\n** pr_FindSymbolInProg\n**\n** Find the specified data symbol in the program and return\n** its address.\n*/\n\n#ifdef HAVE_DLL\n\n#if defined(USE_DLFCN) && !defined(NO_DLOPEN_NULL)\n\n#include <dlfcn.h>\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    void *h;\n    void *sym;\n\n    h = dlopen(0, RTLD_LAZY);\n    if (h == NULL)\n        return NULL;\n    sym = dlsym(h, name);\n    (void)dlclose(h);\n    return sym;\n}\n\n#elif defined(USE_HPSHL)\n\n#include <dl.h>\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    shl_t h = NULL;\n    void *sym;\n\n    if (shl_findsym(&h, name, TYPE_DATA, &sym) == -1)\n        return NULL;\n    return sym;\n}\n\n#elif defined(USE_MACH_DYLD) || defined(NO_DLOPEN_NULL)\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    /* FIXME: not implemented */\n    return NULL;\n}\n\n#else\n\n#error \"The zone allocator is not supported on this platform\"\n\n#endif\n\n#else /* !defined(HAVE_DLL) */\n\nstatic void *\npr_FindSymbolInProg(const char *name)\n{\n    /* can't be implemented */\n    return NULL;\n}\n\n#endif /* HAVE_DLL */\n\nvoid\n_PR_InitZones(void)\n{\n    int i, j;\n    char *envp;\n    PRBool *sym;\n\n    if ((sym = (PRBool *)pr_FindSymbolInProg(\"nspr_use_zone_allocator\")) != NULL) {\n        use_zone_allocator = *sym;\n    } else if ((envp = getenv(\"NSPR_USE_ZONE_ALLOCATOR\")) != NULL) {\n        use_zone_allocator = (atoi(envp) == 1);\n    }\n\n    if (!use_zone_allocator)\n        return;\n\n    for (j = 0; j < THREAD_POOLS; j++) { \n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone *mz = &zones[i][j];\n            int rv = pthread_mutex_init(&mz->lock, NULL);\n            PR_ASSERT(0 == rv);\n            if (rv != 0) {\n                goto loser;\n            } \n            mz->blockSize = 16 << ( 2 * i);\n        }\n    }\n    return;\n\nloser:\n    _PR_DestroyZones();\n    return;\n}\n\nPR_IMPLEMENT(void)\nPR_FPrintZoneStats(PRFileDesc *debug_out)\n{\n    int i, j;\n\n    for (j = 0; j < THREAD_POOLS; j++) {\n        for (i = 0; i < MEM_ZONES; i++) {\n            MemoryZone   *mz   = &zones[i][j];\n            MemoryZone    zone = *mz;\n            if (zone.elements || zone.misses || zone.hits) {\n                PR_fprintf(debug_out,\n\"pool: %d, zone: %d, size: %d, free: %d, hit: %d, miss: %d, contend: %d\\n\",\n                    j, i, zone.blockSize, zone.elements,\n                    zone.hits, zone.misses, zone.contention);\n            }\n\t}\n    }\n}\n\nstatic void *\npr_ZoneMalloc(PRUint32 size)\n{\n    void         *rv;\n    unsigned int  zone;\n    size_t        blockSize;\n    MemBlockHdr  *mb, *mt;\n    MemoryZone   *mz;\n\n    /* Always allocate a non-zero amount of bytes */\n    if (size < 1) {\n        size = 1;\n    }\n    for (zone = 0, blockSize = 16; zone < MEM_ZONES; ++zone, blockSize <<= 2) {\n        if (size <= blockSize) {\n            break;\n        }\n    }\n    if (zone < MEM_ZONES) {\n        pthread_t me = pthread_self();\n        unsigned int pool = (PRUptrdiff)me % THREAD_POOLS;\n        PRUint32     wasLocked;\n        mz = &zones[zone][pool];\n        wasLocked = mz->locked;\n        pthread_mutex_lock(&mz->lock);\n        mz->locked = 1;\n        if (wasLocked)\n            mz->contention++;\n        if (mz->head) {\n            mb = mz->head;\n            PR_ASSERT(mb->s.magic == ZONE_MAGIC);\n            PR_ASSERT(mb->s.zone  == mz);\n            PR_ASSERT(mb->s.blockSize == blockSize);\n            PR_ASSERT(mz->blockSize == blockSize);\n\n            mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n            PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n            PR_ASSERT(mt->s.zone  == mz);\n            PR_ASSERT(mt->s.blockSize == blockSize);\n\n            mz->hits++;\n            mz->elements--;\n            mz->head = mb->s.next;    /* take off free list */\n            mz->locked = 0;\n            pthread_mutex_unlock(&mz->lock);\n\n            mt->s.next          = mb->s.next          = NULL;\n            mt->s.requestedSize = mb->s.requestedSize = size;\n\n            rv = (void *)(mb + 1);\n            return rv;\n        }\n\n        mz->misses++;\n        mz->locked = 0;\n        pthread_mutex_unlock(&mz->lock);\n\n        mb = (MemBlockHdr *)malloc(blockSize + 2 * (sizeof *mb));\n        if (!mb) {\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n            return NULL;\n        }\n        mb->s.next          = NULL;\n        mb->s.zone          = mz;\n        mb->s.magic         = ZONE_MAGIC;\n        mb->s.blockSize     = blockSize;\n        mb->s.requestedSize = size;\n\n        mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n        memcpy(mt, mb, sizeof *mb);\n\n        rv = (void *)(mb + 1);\n        return rv;\n    }\n\n    /* size was too big.  Create a block with no zone */\n    blockSize = (size & 15) ? size + 16 - (size & 15) : size;\n    mb = (MemBlockHdr *)malloc(blockSize + 2 * (sizeof *mb));\n    if (!mb) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        return NULL;\n    }\n    mb->s.next          = NULL;\n    mb->s.zone          = NULL;\n    mb->s.magic         = ZONE_MAGIC;\n    mb->s.blockSize     = blockSize;\n    mb->s.requestedSize = size;\n\n    mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n    memcpy(mt, mb, sizeof *mb);\n\n    rv = (void *)(mb + 1);\n    return rv;\n}\n\n\nstatic void *\npr_ZoneCalloc(PRUint32 nelem, PRUint32 elsize)\n{\n    PRUint32 size = nelem * elsize;\n    void *p = pr_ZoneMalloc(size);\n    if (p) {\n        memset(p, 0, size);\n    }\n    return p;\n}\n\nstatic void *\npr_ZoneRealloc(void *oldptr, PRUint32 bytes)\n{\n    void         *rv;\n    MemBlockHdr  *mb;\n    int           ours;\n    MemBlockHdr   phony;\n\n    if (!oldptr)\n        return pr_ZoneMalloc(bytes);\n    mb = (MemBlockHdr *)((char *)oldptr - (sizeof *mb));\n    if (mb->s.magic != ZONE_MAGIC) {\n        /* Maybe this just came from ordinary malloc */\n#ifdef DEBUG\n        fprintf(stderr,\n            \"Warning: reallocing memory block %p from ordinary malloc\\n\",\n            oldptr);\n#endif\n        /*\n         * We are going to realloc oldptr.  If realloc succeeds, the\n         * original value of oldptr will point to freed memory.  So this\n         * function must not fail after a successfull realloc call.  We\n         * must perform any operation that may fail before the realloc\n         * call.\n         */\n        rv = pr_ZoneMalloc(bytes);  /* this may fail */\n        if (!rv) {\n            return rv;\n        }\n\n        /* We don't know how big it is.  But we can fix that. */\n        oldptr = realloc(oldptr, bytes);\n        /*\n         * If realloc returns NULL, this function loses the original\n         * value of oldptr.  This isn't a leak because the caller of\n         * this function still has the original value of oldptr.\n         */\n        if (!oldptr) {\n            if (bytes) {\n                PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                pr_ZoneFree(rv);\n                return oldptr;\n            }\n        }\n        phony.s.requestedSize = bytes;\n        mb = &phony;\n        ours = 0;\n    } else {\n        size_t blockSize = mb->s.blockSize;\n        MemBlockHdr *mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n\n        PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n        PR_ASSERT(mt->s.zone  == mb->s.zone);\n        PR_ASSERT(mt->s.blockSize == blockSize);\n\t\n        if (bytes <= blockSize) {\n            /* The block is already big enough. */\n            mt->s.requestedSize = mb->s.requestedSize = bytes;\n            return oldptr;\n        }\n        ours = 1;\n        rv = pr_ZoneMalloc(bytes);\n        if (!rv) {\n            return rv;\n        }\n    }\n    \n    if (oldptr && mb->s.requestedSize)\n        memcpy(rv, oldptr, mb->s.requestedSize);\n    if (ours)\n        pr_ZoneFree(oldptr);\n    else if (oldptr)\n        free(oldptr);\n    return rv;\n}\n\nstatic void\npr_ZoneFree(void *ptr)\n{\n    MemBlockHdr  *mb, *mt;\n    MemoryZone   *mz;\n    size_t        blockSize;\n    PRUint32      wasLocked;\n\n    if (!ptr)\n        return;\n\n    mb = (MemBlockHdr *)((char *)ptr - (sizeof *mb));\n\n    if (mb->s.magic != ZONE_MAGIC) {\n        /* maybe this came from ordinary malloc */\n#ifdef DEBUG\n        fprintf(stderr,\n            \"Warning: freeing memory block %p from ordinary malloc\\n\", ptr);\n#endif\n        free(ptr);\n        return;\n    }\n\n    blockSize = mb->s.blockSize;\n    mz        = mb->s.zone;\n    mt = (MemBlockHdr *)(((char *)(mb + 1)) + blockSize);\n    PR_ASSERT(mt->s.magic == ZONE_MAGIC);\n    PR_ASSERT(mt->s.zone  == mz);\n    PR_ASSERT(mt->s.blockSize == blockSize);\n    if (!mz) {\n        PR_ASSERT(blockSize > 65536);\n        /* This block was not in any zone.  Just free it. */\n        free(mb);\n        return;\n    }\n    PR_ASSERT(mz->blockSize == blockSize);\n    wasLocked = mz->locked;\n    pthread_mutex_lock(&mz->lock);\n    mz->locked = 1;\n    if (wasLocked)\n        mz->contention++;\n    mt->s.next = mb->s.next = mz->head;        /* put on head of list */\n    mz->head = mb;\n    mz->elements++;\n    mz->locked = 0;\n    pthread_mutex_unlock(&mz->lock);\n}\n\nPR_IMPLEMENT(void *) PR_Malloc(PRUint32 size)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ? pr_ZoneMalloc(size) : malloc(size);\n}\n\nPR_IMPLEMENT(void *) PR_Calloc(PRUint32 nelem, PRUint32 elsize)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ?\n        pr_ZoneCalloc(nelem, elsize) : calloc(nelem, elsize);\n}\n\nPR_IMPLEMENT(void *) PR_Realloc(void *ptr, PRUint32 size)\n{\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    return use_zone_allocator ? pr_ZoneRealloc(ptr, size) : realloc(ptr, size);\n}\n\nPR_IMPLEMENT(void) PR_Free(void *ptr)\n{\n    if (use_zone_allocator)\n        pr_ZoneFree(ptr);\n    else\n        free(ptr);\n}\n\n#else /* !defined(_PR_ZONE_ALLOCATOR) */\n\n/*\n** The PR_Malloc, PR_Calloc, PR_Realloc, and PR_Free functions simply\n** call their libc equivalents now.  This may seem redundant, but it\n** ensures that we are calling into the same runtime library.  On\n** Win32, it is possible to have multiple runtime libraries (e.g.,\n** objects compiled with /MD and /MDd) in the same process, and\n** they maintain separate heaps, which cannot be mixed.\n*/\nPR_IMPLEMENT(void *) PR_Malloc(PRUint32 size)\n{\n#if defined (WIN16)\n    return PR_MD_malloc( (size_t) size);\n#else\n    return malloc(size);\n#endif\n}\n\nPR_IMPLEMENT(void *) PR_Calloc(PRUint32 nelem, PRUint32 elsize)\n{\n#if defined (WIN16)\n    return PR_MD_calloc( (size_t)nelem, (size_t)elsize );\n    \n#else\n    return calloc(nelem, elsize);\n#endif\n}\n\nPR_IMPLEMENT(void *) PR_Realloc(void *ptr, PRUint32 size)\n{\n#if defined (WIN16)\n    return PR_MD_realloc( ptr, (size_t) size);\n#else\n    return realloc(ptr, size);\n#endif\n}\n\nPR_IMPLEMENT(void) PR_Free(void *ptr)\n{\n#if defined (WIN16)\n    PR_MD_free( ptr );\n#else\n    free(ptr);\n#endif\n}\n\n#endif /* _PR_ZONE_ALLOCATOR */\n\n/*\n** Complexity alert!\n**\n** If malloc/calloc/free (etc.) were implemented to use pr lock's then\n** the entry points could block when called if some other thread had the\n** lock.\n**\n** Most of the time this isn't a problem. However, in the case that we\n** are using the thread safe malloc code after PR_Init but before\n** PR_AttachThread has been called (on a native thread that nspr has yet\n** to be told about) we could get royally screwed if the lock was busy\n** and we tried to context switch the thread away. In this scenario\n** \tPR_CURRENT_THREAD() == NULL\n**\n** To avoid this unfortunate case, we use the low level locking\n** facilities for malloc protection instead of the slightly higher level\n** locking. This makes malloc somewhat faster so maybe it's a good thing\n** anyway.\n*/\n#ifdef _PR_OVERRIDE_MALLOC\n\n/* Imports */\nextern void *_PR_UnlockedMalloc(size_t size);\nextern void *_PR_UnlockedMemalign(size_t alignment, size_t size);\nextern void _PR_UnlockedFree(void *ptr);\nextern void *_PR_UnlockedRealloc(void *ptr, size_t size);\nextern void *_PR_UnlockedCalloc(size_t n, size_t elsize);\n\nstatic PRBool _PR_malloc_initialised = PR_FALSE;\n\n#ifdef _PR_PTHREADS\nstatic pthread_mutex_t _PR_MD_malloc_crustylock;\n\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\tPRStatus rv;\t\t\t\\\n\t\t\t\t\trv = pthread_mutex_lock(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t\tPR_ASSERT(0 == rv);\t\t\\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\tPRStatus rv;\t\t\t\\\n\t\t\t\t\trv = pthread_mutex_unlock(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t\tPR_ASSERT(0 == rv);\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#else /* _PR_PTHREADS */\nstatic _MDLock _PR_MD_malloc_crustylock;\n\n#ifdef IRIX\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n\t\t\t   PRIntn _is;\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\tif (_PR_MD_GET_ATTACHED_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_GET_ATTACHED_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSOFF(_is); \t\\\n\t\t\t\t\t_PR_MD_LOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\t_PR_MD_UNLOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\tif (_PR_MD_GET_ATTACHED_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_GET_ATTACHED_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSON(_is);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#else\t/* IRIX */\n#define _PR_Lock_Malloc() {\t\t\t\t\t\t\\\n\t\t\t   PRIntn _is;\t\t\t\t\t\\\n    \t\t\t\tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\tif (_PR_MD_CURRENT_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_CURRENT_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSOFF(_is); \t\\\n\t\t\t\t\t_PR_MD_LOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\t}\n\n#define _PR_Unlock_Malloc() \tif(PR_TRUE == _PR_malloc_initialised) { \\\n\t\t\t\t\t_PR_MD_UNLOCK(&_PR_MD_malloc_crustylock); \\\n\t\t\t\tif (_PR_MD_CURRENT_THREAD() && \t\t\\\n\t\t\t\t\t!_PR_IS_NATIVE_THREAD( \t\t\\\n\t\t\t\t\t_PR_MD_CURRENT_THREAD()))\t\\\n\t\t\t\t\t\t_PR_INTSON(_is);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t  }\n#endif\t/* IRIX\t*/\n#endif /* _PR_PTHREADS */\n\nPR_IMPLEMENT(PRStatus) _PR_MallocInit(void)\n{\n    PRStatus rv = PR_SUCCESS;\n\n    if( PR_TRUE == _PR_malloc_initialised ) return PR_SUCCESS;\n\n#ifdef _PR_PTHREADS\n    {\n\tint status;\n\tpthread_mutexattr_t mattr;\n\n\tstatus = _PT_PTHREAD_MUTEXATTR_INIT(&mattr);\n\tPR_ASSERT(0 == status);\n\tstatus = _PT_PTHREAD_MUTEX_INIT(_PR_MD_malloc_crustylock, mattr);\n\tPR_ASSERT(0 == status);\n\tstatus = _PT_PTHREAD_MUTEXATTR_DESTROY(&mattr);\n\tPR_ASSERT(0 == status);\n    }\n#else /* _PR_PTHREADS */\n    _MD_NEW_LOCK(&_PR_MD_malloc_crustylock);\n#endif /* _PR_PTHREADS */\n\n    if( PR_SUCCESS == rv )\n    {\n        _PR_malloc_initialised = PR_TRUE;\n    }\n\n    return rv;\n}\n\nvoid *malloc(size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedMalloc(size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\n#if defined(IRIX)\nvoid *memalign(size_t alignment, size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedMemalign(alignment, size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid *valloc(size_t size)\n{\n    return(memalign(sysconf(_SC_PAGESIZE),size));\n}\n#endif\t/* IRIX */\n\nvoid free(void *ptr)\n{\n    _PR_Lock_Malloc();\n    _PR_UnlockedFree(ptr);\n    _PR_Unlock_Malloc();\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedRealloc(ptr, size);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid *calloc(size_t n, size_t elsize)\n{\n    void *p;\n    _PR_Lock_Malloc();\n    p = _PR_UnlockedCalloc(n, elsize);\n    _PR_Unlock_Malloc();\n    return p;\n}\n\nvoid cfree(void *p)\n{\n    _PR_Lock_Malloc();\n    _PR_UnlockedFree(p);\n    _PR_Unlock_Malloc();\n}\n\nvoid _PR_InitMem(void)\n{\n    PRStatus rv;\n    rv = _PR_MallocInit();\n    PR_ASSERT(PR_SUCCESS == rv);\n}\n\n#endif /* _PR_OVERRIDE_MALLOC */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/pthreads/ptthread.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n** File:            ptthread.c\n** Descritpion:        Implemenation for threds using pthreds\n** Exports:            ptthread.h\n*/\n\n#if defined(_PR_PTHREADS) || defined(_PR_DCETHREADS)\n\n#include \"prlog.h\"\n#include \"primpl.h\"\n#include \"prpdce.h\"\n\n#include <pthread.h>\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <dlfcn.h>\n\n#if defined(OPENBSD) || defined(FREEBSD) || defined(DRAGONFLY)\n#include <pthread_np.h>\n#endif\n\n#ifdef SYMBIAN\n/* In Open C sched_get_priority_min/max do not work properly, so we undefine\n * _POSIX_THREAD_PRIORITY_SCHEDULING here.\n */\n#undef _POSIX_THREAD_PRIORITY_SCHEDULING\n#endif\n\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n#undef _POSIX_THREAD_PRIORITY_SCHEDULING\n#include <sys/resource.h>\n#ifndef HAVE_GETTID\n#define gettid() (syscall(SYS_gettid))\n#endif\n#endif\n\n/*\n * Record whether or not we have the privilege to set the scheduling\n * policy and priority of threads.  0 means that privilege is available.\n * EPERM means that privilege is not available.\n */\n\nstatic PRIntn pt_schedpriv = 0;\nextern PRLock *_pr_sleeplock;\n\nstatic struct _PT_Bookeeping\n{\n    PRLock *ml;                 /* a lock to protect ourselves */\n    PRCondVar *cv;              /* used to signal global things */\n    PRInt32 system, user;       /* a count of the two different types */\n    PRUintn this_many;          /* number of threads allowed for exit */\n    pthread_key_t key;          /* thread private data key */\n    PRBool keyCreated;          /* whether 'key' should be deleted */\n    PRThread *first, *last;     /* list of threads we know about */\n#if defined(_PR_DCETHREADS) || _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n    PRInt32 minPrio, maxPrio;   /* range of scheduling priorities */\n#endif\n} pt_book = {0};\n\nstatic void _pt_thread_death(void *arg);\nstatic void _pt_thread_death_internal(void *arg, PRBool callDestructors);\nstatic void init_pthread_gc_support(void);\n\n#if defined(_PR_DCETHREADS) || _POSIX_THREAD_PRIORITY_SCHEDULING > 0\nstatic PRIntn pt_PriorityMap(PRThreadPriority pri)\n{\n#ifdef NTO\n    /* This priority algorithm causes lots of problems on Neutrino\n     * for now I have just hard coded everything to run at priority 10\n     * until I can come up with a new algorithm.\n     *     Jerry.Kirk@Nexwarecorp.com\n     */\n    return 10;\n#else\n    return pt_book.minPrio +\n\t    pri * (pt_book.maxPrio - pt_book.minPrio) / PR_PRIORITY_LAST;\n#endif\n}\n#elif defined(_PR_NICE_PRIORITY_SCHEDULING)\n/*\n * This functions maps higher priorities to lower nice values relative to the\n * nice value specified in the |nice| parameter. The corresponding relative\n * adjustments are:\n *\n * PR_PRIORITY_LOW    +1\n * PR_PRIORITY_NORMAL  0\n * PR_PRIORITY_HIGH   -1\n * PR_PRIORITY_URGENT -2\n */\nstatic int pt_RelativePriority(int nice, PRThreadPriority pri)\n{\n    return nice + (1 - pri);\n}\n#endif\n\n/*\n** Initialize a stack for a native pthread thread\n*/\nstatic void _PR_InitializeStack(PRThreadStack *ts)\n{\n    if( ts && (ts->stackTop == 0) ) {\n        ts->allocBase = (char *) &ts;\n        ts->allocSize = ts->stackSize;\n\n        /*\n        ** Setup stackTop and stackBottom values.\n        */\n#ifdef HAVE_STACK_GROWING_UP\n        ts->stackBottom = ts->allocBase + ts->stackSize;\n        ts->stackTop = ts->allocBase;\n#else\n        ts->stackTop    = ts->allocBase;\n        ts->stackBottom = ts->allocBase - ts->stackSize;\n#endif\n    }\n}\n\nstatic void *_pt_root(void *arg)\n{\n    PRIntn rv;\n    PRThread *thred = (PRThread*)arg;\n    PRBool detached = (thred->state & PT_THREAD_DETACHED) ? PR_TRUE : PR_FALSE;\n    pthread_t id = pthread_self();\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n    pid_t tid;\n#endif\n\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n    /*\n     * We need to know the kernel thread ID of each thread in order to\n     * set its nice value hence we do it here instead of at creation time.\n     */\n    tid = gettid();\n    errno = 0;\n    rv = getpriority(PRIO_PROCESS, 0);\n\n    /* If we cannot read the main thread's nice value don't try to change the\n     * new thread's nice value. */\n    if (errno == 0) {\n        setpriority(PRIO_PROCESS, tid,\n                    pt_RelativePriority(rv, thred->priority));\n    }\n#endif\n\n    /*\n    ** DCE Threads can't detach during creation, so do it late.\n    ** I would like to do it only here, but that doesn't seem\n    ** to work.\n    */\n#if defined(_PR_DCETHREADS)\n    if (detached)\n    {\n        /* pthread_detach() modifies its argument, so we must pass a copy */\n        pthread_t self = id;\n        rv = pthread_detach(&self);\n        PR_ASSERT(0 == rv);\n    }\n#endif /* defined(_PR_DCETHREADS) */\n\n    /* Set up the thread stack information */\n    _PR_InitializeStack(thred->stack);\n\n    /*\n     * Set within the current thread the pointer to our object.\n     * This object will be deleted when the thread termintates,\n     * whether in a join or detached (see _PR_InitThreads()).\n     */\n    rv = pthread_setspecific(pt_book.key, thred);\n    PR_ASSERT(0 == rv);\n\n    /* make the thread visible to the rest of the runtime */\n    PR_Lock(pt_book.ml);\n    /*\n     * Both the parent thread and this new thread set thred->id.\n     * The new thread must ensure that thred->id is set before\n     * it executes its startFunc.  The parent thread must ensure\n     * that thred->id is set before PR_CreateThread() returns.\n     * Both threads set thred->id while holding pt_book.ml and\n     * use thred->idSet to ensure thred->id is written only once.\n     */\n    if (!thred->idSet)\n    {\n        thred->id = id;\n        thred->idSet = PR_TRUE;\n    }\n    else\n    {\n        PR_ASSERT(pthread_equal(thred->id, id));\n    }\n\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n    thred->tid = tid;\n    PR_NotifyAllCondVar(pt_book.cv);\n#endif\n\n    /* If this is a GCABLE thread, set its state appropriately */\n    if (thred->suspend & PT_THREAD_SETGCABLE)\n\t    thred->state |= PT_THREAD_GCABLE;\n    thred->suspend = 0;\n\n    thred->prev = pt_book.last;\n    if (pt_book.last)\n        pt_book.last->next = thred;\n    else\n        pt_book.first = thred;\n    thred->next = NULL;\n    pt_book.last = thred;\n    PR_Unlock(pt_book.ml);\n\n    thred->startFunc(thred->arg);  /* make visible to the client */\n\n    /* unhook the thread from the runtime */\n    PR_Lock(pt_book.ml);\n    /*\n     * At this moment, PR_CreateThread() may not have set thred->id yet.\n     * It is safe for a detached thread to free thred only after\n     * PR_CreateThread() has accessed thred->id and thred->idSet.\n     */\n    if (detached)\n    {\n        while (!thred->okToDelete)\n            PR_WaitCondVar(pt_book.cv, PR_INTERVAL_NO_TIMEOUT);\n    }\n\n    if (thred->state & PT_THREAD_SYSTEM)\n        pt_book.system -= 1;\n    else if (--pt_book.user == pt_book.this_many)\n        PR_NotifyAllCondVar(pt_book.cv);\n    if (NULL == thred->prev)\n        pt_book.first = thred->next;\n    else\n        thred->prev->next = thred->next;\n    if (NULL == thred->next)\n        pt_book.last = thred->prev;\n    else\n        thred->next->prev = thred->prev;\n    PR_Unlock(pt_book.ml);\n\n    /*\n    * Here we set the pthread's backpointer to the PRThread to NULL.\n    * Otherwise the destructor would get called eagerly as the thread\n    * returns to the pthread runtime. The joining thread would them be\n    * the proud possessor of a dangling reference. However, this is the\n    * last chance to delete the object if the thread is detached, so\n    * just let the destructor do the work.\n    */\n    if (PR_FALSE == detached)\n    {\n        /* Call TPD destructors on this thread. */\n        _PR_DestroyThreadPrivate(thred);\n        rv = pthread_setspecific(pt_book.key, NULL);\n        PR_ASSERT(0 == rv);\n    }\n\n    return NULL;\n}  /* _pt_root */\n\nstatic PRThread* pt_AttachThread(void)\n{\n    PRThread *thred = NULL;\n\n    /*\n     * NSPR must have been initialized when PR_AttachThread is called.\n     * We cannot have PR_AttachThread call implicit initialization\n     * because if multiple threads call PR_AttachThread simultaneously,\n     * NSPR may be initialized more than once.\n     * We can't call any function that calls PR_GetCurrentThread()\n     * either (e.g., PR_SetError()) as that will result in infinite\n     * recursion.\n     */\n    if (!_pr_initialized) return NULL;\n\n    /* PR_NEWZAP must not call PR_GetCurrentThread() */\n    thred = PR_NEWZAP(PRThread);\n    if (NULL != thred)\n    {\n        int rv;\n\n        thred->priority = PR_PRIORITY_NORMAL;\n        thred->id = pthread_self();\n        thred->idSet = PR_TRUE;\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n        thred->tid = gettid();\n#endif\n        rv = pthread_setspecific(pt_book.key, thred);\n        PR_ASSERT(0 == rv);\n\n        thred->state = PT_THREAD_GLOBAL | PT_THREAD_FOREIGN;\n        PR_Lock(pt_book.ml);\n\n        /* then put it into the list */\n        thred->prev = pt_book.last;\n        if (pt_book.last)\n            pt_book.last->next = thred;\n        else\n            pt_book.first = thred;\n        thred->next = NULL;\n        pt_book.last = thred;\n        PR_Unlock(pt_book.ml);\n\n    }\n    return thred;  /* may be NULL */\n}  /* pt_AttachThread */\n\nstatic PRThread* _PR_CreateThread(\n    PRThreadType type, void (*start)(void *arg),\n    void *arg, PRThreadPriority priority, PRThreadScope scope,\n    PRThreadState state, PRUint32 stackSize, PRBool isGCAble)\n{\n    int rv;\n    PRThread *thred;\n    pthread_attr_t tattr;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if ((PRIntn)PR_PRIORITY_FIRST > (PRIntn)priority)\n        priority = PR_PRIORITY_FIRST;\n    else if ((PRIntn)PR_PRIORITY_LAST < (PRIntn)priority)\n        priority = PR_PRIORITY_LAST;\n\n    rv = _PT_PTHREAD_ATTR_INIT(&tattr);\n    PR_ASSERT(0 == rv);\n\n    if (EPERM != pt_schedpriv)\n    {\n#if !defined(_PR_DCETHREADS) && _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n        struct sched_param schedule;\n#endif\n\n#if _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n        rv = pthread_attr_setinheritsched(&tattr, PTHREAD_EXPLICIT_SCHED);\n        PR_ASSERT(0 == rv);\n#endif\n\n        /* Use the default scheduling policy */\n\n#if defined(_PR_DCETHREADS)\n        rv = pthread_attr_setprio(&tattr, pt_PriorityMap(priority));\n        PR_ASSERT(0 == rv);\n#elif _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n        rv = pthread_attr_getschedparam(&tattr, &schedule);\n        PR_ASSERT(0 == rv);\n        schedule.sched_priority = pt_PriorityMap(priority);\n        rv = pthread_attr_setschedparam(&tattr, &schedule);\n        PR_ASSERT(0 == rv);\n#ifdef NTO\n        rv = pthread_attr_setschedpolicy(&tattr, SCHED_RR); /* Round Robin */\n        PR_ASSERT(0 == rv);\n#endif\n#endif /* !defined(_PR_DCETHREADS) */\n    }\n\n    /*\n     * DCE threads can't set detach state before creating the thread.\n     * AIX can't set detach late. Why can't we all just get along?\n     */\n#if !defined(_PR_DCETHREADS)\n    rv = pthread_attr_setdetachstate(&tattr,\n        ((PR_JOINABLE_THREAD == state) ?\n            PTHREAD_CREATE_JOINABLE : PTHREAD_CREATE_DETACHED));\n    PR_ASSERT(0 == rv);\n#endif /* !defined(_PR_DCETHREADS) */\n\n    /*\n     * If stackSize is 0, we use the default pthread stack size.\n     */\n    if (stackSize)\n    {\n#ifdef _MD_MINIMUM_STACK_SIZE\n        if (stackSize < _MD_MINIMUM_STACK_SIZE)\n            stackSize = _MD_MINIMUM_STACK_SIZE;\n#endif\n        rv = pthread_attr_setstacksize(&tattr, stackSize);\n        PR_ASSERT(0 == rv);\n    }\n\n    thred = PR_NEWZAP(PRThread);\n    if (NULL == thred)\n    {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, errno);\n        goto done;\n    }\n    else\n    {\n        pthread_t id;\n\n        thred->arg = arg;\n        thred->startFunc = start;\n        thred->priority = priority;\n        if (PR_UNJOINABLE_THREAD == state)\n            thred->state |= PT_THREAD_DETACHED;\n\n        if (PR_LOCAL_THREAD == scope)\n        \tscope = PR_GLOBAL_THREAD;\n\t\t\t\n        if (PR_GLOBAL_BOUND_THREAD == scope) {\n#if _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n    \t\trv = pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM);\n\t\t\tif (rv) {\n\t\t\t\t/*\n\t\t\t\t * system scope not supported\n\t\t\t\t */\n        \t\tscope = PR_GLOBAL_THREAD;\n\t\t\t\t/*\n\t\t\t\t * reset scope\n\t\t\t\t */\n    \t\t\trv = pthread_attr_setscope(&tattr, PTHREAD_SCOPE_PROCESS);\n    \t\t\tPR_ASSERT(0 == rv);\n\t\t\t}\n#endif\n\t\t}\n        if (PR_GLOBAL_THREAD == scope)\n            thred->state |= PT_THREAD_GLOBAL;\n        else if (PR_GLOBAL_BOUND_THREAD == scope)\n            thred->state |= (PT_THREAD_GLOBAL | PT_THREAD_BOUND);\n\t\telse\t/* force it global */\n            thred->state |= PT_THREAD_GLOBAL;\n        if (PR_SYSTEM_THREAD == type)\n            thred->state |= PT_THREAD_SYSTEM;\n\n        thred->suspend =(isGCAble) ? PT_THREAD_SETGCABLE : 0;\n\n        thred->stack = PR_NEWZAP(PRThreadStack);\n        if (thred->stack == NULL) {\n            PRIntn oserr = errno;\n            PR_Free(thred);  /* all that work ... poof! */\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, oserr);\n            thred = NULL;  /* and for what? */\n            goto done;\n        }\n        thred->stack->stackSize = stackSize;\n        thred->stack->thr = thred;\n\n#ifdef PT_NO_SIGTIMEDWAIT\n        pthread_mutex_init(&thred->suspendResumeMutex,NULL);\n        pthread_cond_init(&thred->suspendResumeCV,NULL);\n#endif\n\n        /* make the thread counted to the rest of the runtime */\n        PR_Lock(pt_book.ml);\n        if (PR_SYSTEM_THREAD == type)\n            pt_book.system += 1;\n        else pt_book.user += 1;\n        PR_Unlock(pt_book.ml);\n\n        /*\n         * We pass a pointer to a local copy (instead of thred->id)\n         * to pthread_create() because who knows what wacky things\n         * pthread_create() may be doing to its argument.\n         */\n        rv = _PT_PTHREAD_CREATE(&id, tattr, _pt_root, thred);\n\n#if !defined(_PR_DCETHREADS)\n        if (EPERM == rv)\n        {\n#if defined(IRIX)\n        \tif (PR_GLOBAL_BOUND_THREAD == scope) {\n\t\t\t\t/*\n\t\t\t\t * SCOPE_SYSTEM requires appropriate privilege\n\t\t\t\t * reset to process scope and try again\n\t\t\t\t */\n    \t\t\trv = pthread_attr_setscope(&tattr, PTHREAD_SCOPE_PROCESS);\n    \t\t\tPR_ASSERT(0 == rv);\n            \tthred->state &= ~PT_THREAD_BOUND;\n\t\t\t}\n#else\n            /* Remember that we don't have thread scheduling privilege. */\n            pt_schedpriv = EPERM;\n            PR_LOG(_pr_thread_lm, PR_LOG_MIN,\n                (\"_PR_CreateThread: no thread scheduling privilege\"));\n            /* Try creating the thread again without setting priority. */\n#if _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n            rv = pthread_attr_setinheritsched(&tattr, PTHREAD_INHERIT_SCHED);\n            PR_ASSERT(0 == rv);\n#endif\n#endif\t/* IRIX */\n            rv = _PT_PTHREAD_CREATE(&id, tattr, _pt_root, thred);\n        }\n#endif\n\n        if (0 != rv)\n        {\n#if defined(_PR_DCETHREADS)\n            PRIntn oserr = errno;\n#else\n            PRIntn oserr = rv;\n#endif\n            PR_Lock(pt_book.ml);\n            if (thred->state & PT_THREAD_SYSTEM)\n                pt_book.system -= 1;\n            else if (--pt_book.user == pt_book.this_many)\n                PR_NotifyAllCondVar(pt_book.cv);\n            PR_Unlock(pt_book.ml);\n\n            PR_Free(thred->stack);\n            PR_Free(thred);  /* all that work ... poof! */\n            PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, oserr);\n            thred = NULL;  /* and for what? */\n            goto done;\n        }\n\n        PR_Lock(pt_book.ml);\n        /*\n         * Both the parent thread and this new thread set thred->id.\n         * The parent thread must ensure that thred->id is set before\n         * PR_CreateThread() returns.  (See comments in _pt_root().)\n         */\n        if (!thred->idSet)\n        {\n            thred->id = id;\n            thred->idSet = PR_TRUE;\n        }\n        else\n        {\n            PR_ASSERT(pthread_equal(thred->id, id));\n        }\n\n        /*\n         * If the new thread is detached, tell it that PR_CreateThread() has\n         * accessed thred->id and thred->idSet so it's ok to delete thred.\n         */\n        if (PR_UNJOINABLE_THREAD == state)\n        {\n            thred->okToDelete = PR_TRUE;\n            PR_NotifyAllCondVar(pt_book.cv);\n        }\n        PR_Unlock(pt_book.ml);\n    }\n\ndone:\n    rv = _PT_PTHREAD_ATTR_DESTROY(&tattr);\n    PR_ASSERT(0 == rv);\n\n    return thred;\n}  /* _PR_CreateThread */\n\nPR_IMPLEMENT(PRThread*) PR_CreateThread(\n    PRThreadType type, void (*start)(void *arg), void *arg,\n    PRThreadPriority priority, PRThreadScope scope,\n    PRThreadState state, PRUint32 stackSize)\n{\n    return _PR_CreateThread(\n        type, start, arg, priority, scope, state, stackSize, PR_FALSE);\n} /* PR_CreateThread */\n\nPR_IMPLEMENT(PRThread*) PR_CreateThreadGCAble(\n    PRThreadType type, void (*start)(void *arg), void *arg, \n    PRThreadPriority priority, PRThreadScope scope,\n    PRThreadState state, PRUint32 stackSize)\n{\n    return _PR_CreateThread(\n        type, start, arg, priority, scope, state, stackSize, PR_TRUE);\n}  /* PR_CreateThreadGCAble */\n\nPR_IMPLEMENT(void*) GetExecutionEnvironment(PRThread *thred)\n{\n    return thred->environment;\n}  /* GetExecutionEnvironment */\n \nPR_IMPLEMENT(void) SetExecutionEnvironment(PRThread *thred, void *env)\n{\n    thred->environment = env;\n}  /* SetExecutionEnvironment */\n\nPR_IMPLEMENT(PRThread*) PR_AttachThread(\n    PRThreadType type, PRThreadPriority priority, PRThreadStack *stack)\n{\n    return PR_GetCurrentThread();\n}  /* PR_AttachThread */\n\n\nPR_IMPLEMENT(PRStatus) PR_JoinThread(PRThread *thred)\n{\n    int rv = -1;\n    void *result = NULL;\n    PR_ASSERT(thred != NULL);\n\n    if ((0xafafafaf == thred->state)\n    || (PT_THREAD_DETACHED == (PT_THREAD_DETACHED & thred->state))\n    || (PT_THREAD_FOREIGN == (PT_THREAD_FOREIGN & thred->state)))\n    {\n        /*\n         * This might be a bad address, but if it isn't, the state should\n         * either be an unjoinable thread or it's already had the object\n         * deleted. However, the client that called join on a detached\n         * thread deserves all the rath I can muster....\n         */\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        PR_LogPrint(\n            \"PR_JoinThread: %p not joinable | already smashed\\n\", thred);\n    }\n    else\n    {\n        pthread_t id = thred->id;\n        rv = pthread_join(id, &result);\n        PR_ASSERT(rv == 0 && result == NULL);\n        if (0 == rv)\n        {\n#ifdef _PR_DCETHREADS\n            rv = pthread_detach(&id);\n            PR_ASSERT(0 == rv);\n#endif\n            /*\n             * PR_FALSE, because the thread already called the TPD\n             * destructors before exiting _pt_root.\n             */\n            _pt_thread_death_internal(thred, PR_FALSE);\n        }\n        else\n        {\n            PRErrorCode prerror;\n            switch (rv)\n            {\n                case EINVAL:  /* not a joinable thread */\n                case ESRCH:   /* no thread with given ID */\n                    prerror = PR_INVALID_ARGUMENT_ERROR;\n                    break;\n                case EDEADLK: /* a thread joining with itself */\n                    prerror = PR_DEADLOCK_ERROR;\n                    break;\n                default:\n                    prerror = PR_UNKNOWN_ERROR;\n                    break;\n            }\n            PR_SetError(prerror, rv);\n        }\n    }\n    return (0 == rv) ? PR_SUCCESS : PR_FAILURE;\n}  /* PR_JoinThread */\n\nPR_IMPLEMENT(void) PR_DetachThread(void)\n{\n    void *thred;\n    int rv;\n\n    _PT_PTHREAD_GETSPECIFIC(pt_book.key, thred);\n    if (NULL == thred) return;\n    _pt_thread_death(thred);\n    rv = pthread_setspecific(pt_book.key, NULL);\n    PR_ASSERT(0 == rv);\n}  /* PR_DetachThread */\n\nPR_IMPLEMENT(PRThread*) PR_GetCurrentThread(void)\n{\n    void *thred;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    _PT_PTHREAD_GETSPECIFIC(pt_book.key, thred);\n    if (NULL == thred) thred = pt_AttachThread();\n    PR_ASSERT(NULL != thred);\n    return (PRThread*)thred;\n}  /* PR_GetCurrentThread */\n\nPR_IMPLEMENT(PRThreadScope) PR_GetThreadScope(const PRThread *thred)\n{\n    return (thred->state & PT_THREAD_BOUND) ?\n        PR_GLOBAL_BOUND_THREAD : PR_GLOBAL_THREAD;\n}  /* PR_GetThreadScope() */\n\nPR_IMPLEMENT(PRThreadType) PR_GetThreadType(const PRThread *thred)\n{\n    return (thred->state & PT_THREAD_SYSTEM) ?\n        PR_SYSTEM_THREAD : PR_USER_THREAD;\n}\n\nPR_IMPLEMENT(PRThreadState) PR_GetThreadState(const PRThread *thred)\n{\n    return (thred->state & PT_THREAD_DETACHED) ?\n        PR_UNJOINABLE_THREAD : PR_JOINABLE_THREAD;\n}  /* PR_GetThreadState */\n\nPR_IMPLEMENT(PRThreadPriority) PR_GetThreadPriority(const PRThread *thred)\n{\n    PR_ASSERT(thred != NULL);\n    return thred->priority;\n}  /* PR_GetThreadPriority */\n\nPR_IMPLEMENT(void) PR_SetThreadPriority(PRThread *thred, PRThreadPriority newPri)\n{\n    PRIntn rv;\n\n    PR_ASSERT(NULL != thred);\n\n    if ((PRIntn)PR_PRIORITY_FIRST > (PRIntn)newPri)\n        newPri = PR_PRIORITY_FIRST;\n    else if ((PRIntn)PR_PRIORITY_LAST < (PRIntn)newPri)\n        newPri = PR_PRIORITY_LAST;\n\n#if defined(_PR_DCETHREADS)\n    rv = pthread_setprio(thred->id, pt_PriorityMap(newPri));\n    /* pthread_setprio returns the old priority */\n#elif _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n    if (EPERM != pt_schedpriv)\n    {\n        int policy;\n        struct sched_param schedule;\n\n        rv = pthread_getschedparam(thred->id, &policy, &schedule);\n        if(0 == rv) {\n\t\t\tschedule.sched_priority = pt_PriorityMap(newPri);\n\t\t\trv = pthread_setschedparam(thred->id, policy, &schedule);\n\t\t\tif (EPERM == rv)\n\t\t\t{\n\t\t\t\tpt_schedpriv = EPERM;\n\t\t\t\tPR_LOG(_pr_thread_lm, PR_LOG_MIN,\n\t\t\t\t\t(\"PR_SetThreadPriority: no thread scheduling privilege\"));\n\t\t\t}\n\t\t}\n\t\tif (rv != 0)\n\t\t\trv = -1;\n    }\n#elif defined(_PR_NICE_PRIORITY_SCHEDULING)\n    PR_Lock(pt_book.ml);\n    while (thred->tid == 0)\n        PR_WaitCondVar(pt_book.cv, PR_INTERVAL_NO_TIMEOUT);\n    PR_Unlock(pt_book.ml);\n\n    errno = 0;\n    rv = getpriority(PRIO_PROCESS, 0);\n\n    /* Do not proceed unless we know the main thread's nice value. */\n    if (errno == 0) {\n        rv = setpriority(PRIO_PROCESS, thred->tid,\n                         pt_RelativePriority(rv, newPri));\n\n        if (rv == -1)\n        {\n            /* We don't set pt_schedpriv to EPERM in case errno == EPERM\n             * because adjusting the nice value might be permitted for certain\n             * ranges but not for others. */\n            PR_LOG(_pr_thread_lm, PR_LOG_MIN,\n                (\"PR_SetThreadPriority: setpriority failed with error %d\",\n                 errno));\n        }\n    }\n#else\n    (void)rv; /* rv is unused */\n#endif\n\n    thred->priority = newPri;\n}  /* PR_SetThreadPriority */\n\nPR_IMPLEMENT(PRStatus) PR_Interrupt(PRThread *thred)\n{\n    /*\n    ** If the target thread indicates that it's waiting,\n    ** find the condition and broadcast to it. Broadcast\n    ** since we don't know which thread (if there are more\n    ** than one). This sounds risky, but clients must\n    ** test their invariants when resumed from a wait and\n    ** I don't expect very many threads to be waiting on\n    ** a single condition and I don't expect interrupt to\n    ** be used very often.\n    **\n    ** I don't know why I thought this would work. Must have\n    ** been one of those weaker momements after I'd been\n    ** smelling the vapors.\n    **\n    ** Even with the followng changes it is possible that\n    ** the pointer to the condition variable is pointing\n    ** at a bogus value. Will the unerlying code detect\n    ** that?\n    */\n    PRCondVar *cv;\n    PR_ASSERT(NULL != thred);\n    if (NULL == thred) return PR_FAILURE;\n\n    thred->state |= PT_THREAD_ABORTED;\n\n    cv = thred->waiting;\n    if ((NULL != cv) && !thred->interrupt_blocked)\n    {\n        PRIntn rv;\n        (void)PR_ATOMIC_INCREMENT(&cv->notify_pending);\n        rv = pthread_cond_broadcast(&cv->cv);\n        PR_ASSERT(0 == rv);\n        if (0 > PR_ATOMIC_DECREMENT(&cv->notify_pending))\n            PR_DestroyCondVar(cv);\n    }\n    return PR_SUCCESS;\n}  /* PR_Interrupt */\n\nPR_IMPLEMENT(void) PR_ClearInterrupt(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    me->state &= ~PT_THREAD_ABORTED;\n}  /* PR_ClearInterrupt */\n\nPR_IMPLEMENT(void) PR_BlockInterrupt(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    _PT_THREAD_BLOCK_INTERRUPT(me);\n}  /* PR_BlockInterrupt */\n\nPR_IMPLEMENT(void) PR_UnblockInterrupt(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    _PT_THREAD_UNBLOCK_INTERRUPT(me);\n}  /* PR_UnblockInterrupt */\n\nPR_IMPLEMENT(PRStatus) PR_Yield(void)\n{\n    static PRBool warning = PR_TRUE;\n    if (warning) warning = _PR_Obsolete(\n        \"PR_Yield()\", \"PR_Sleep(PR_INTERVAL_NO_WAIT)\");\n    return PR_Sleep(PR_INTERVAL_NO_WAIT);\n}\n\nPR_IMPLEMENT(PRStatus) PR_Sleep(PRIntervalTime ticks)\n{\n    PRStatus rv = PR_SUCCESS;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (PR_INTERVAL_NO_WAIT == ticks)\n    {\n        _PT_PTHREAD_YIELD();\n    }\n    else\n    {\n        PRCondVar *cv;\n        PRIntervalTime timein;\n\n        timein = PR_IntervalNow();\n        cv = PR_NewCondVar(_pr_sleeplock);\n        PR_ASSERT(cv != NULL);\n        PR_Lock(_pr_sleeplock);\n        do\n        {\n            PRIntervalTime now = PR_IntervalNow();\n            PRIntervalTime delta = now - timein;\n            if (delta > ticks) break;\n            rv = PR_WaitCondVar(cv, ticks - delta);\n        } while (PR_SUCCESS == rv);\n        PR_Unlock(_pr_sleeplock);\n        PR_DestroyCondVar(cv);\n    }\n    return rv;\n}  /* PR_Sleep */\n\nstatic void _pt_thread_death(void *arg)\n{\n    void *thred;\n    int rv;\n\n    _PT_PTHREAD_GETSPECIFIC(pt_book.key, thred);\n    if (NULL == thred)\n    {\n        /*\n         * Have PR_GetCurrentThread return the expected value to the\n         * destructors.\n         */\n        rv = pthread_setspecific(pt_book.key, arg);\n        PR_ASSERT(0 == rv);\n    }\n\n    /* PR_TRUE for: call destructors */ \n    _pt_thread_death_internal(arg, PR_TRUE);\n\n    if (NULL == thred)\n    {\n        rv = pthread_setspecific(pt_book.key, NULL);\n        PR_ASSERT(0 == rv);\n    }\n}\n\nstatic void _pt_thread_death_internal(void *arg, PRBool callDestructors)\n{\n    PRThread *thred = (PRThread*)arg;\n\n    if (thred->state & (PT_THREAD_FOREIGN|PT_THREAD_PRIMORD))\n    {\n        PR_Lock(pt_book.ml);\n        if (NULL == thred->prev)\n            pt_book.first = thred->next;\n        else\n            thred->prev->next = thred->next;\n        if (NULL == thred->next)\n            pt_book.last = thred->prev;\n        else\n            thred->next->prev = thred->prev;\n        PR_Unlock(pt_book.ml);\n    }\n    if (callDestructors)\n        _PR_DestroyThreadPrivate(thred);\n    PR_Free(thred->privateData);\n    if (NULL != thred->errorString)\n        PR_Free(thred->errorString);\n    if (NULL != thred->name)\n        PR_Free(thred->name);\n    PR_Free(thred->stack);\n    if (NULL != thred->syspoll_list)\n        PR_Free(thred->syspoll_list);\n#if defined(_PR_POLL_WITH_SELECT)\n    if (NULL != thred->selectfd_list)\n        PR_Free(thred->selectfd_list);\n#endif\n#if defined(DEBUG)\n    memset(thred, 0xaf, sizeof(PRThread));\n#endif /* defined(DEBUG) */\n    PR_Free(thred);\n}  /* _pt_thread_death */\n\nvoid _PR_InitThreads(\n    PRThreadType type, PRThreadPriority priority, PRUintn maxPTDs)\n{\n    int rv;\n    PRThread *thred;\n\n    PR_ASSERT(priority == PR_PRIORITY_NORMAL);\n\n#ifdef _PR_NEED_PTHREAD_INIT\n    /*\n     * On BSD/OS (3.1 and 4.0), the pthread subsystem is lazily\n     * initialized, but pthread_self() fails to initialize\n     * pthreads and hence returns a null thread ID if invoked\n     * by the primordial thread before any other pthread call.\n     * So we explicitly initialize pthreads here.\n     */\n    pthread_init();\n#endif\n\n#if defined(_PR_DCETHREADS) || _POSIX_THREAD_PRIORITY_SCHEDULING > 0\n#if defined(FREEBSD)\n    {\n    pthread_attr_t attr;\n    int policy;\n    /* get the min and max priorities of the default policy */\n    pthread_attr_init(&attr);\n    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    pthread_attr_getschedpolicy(&attr, &policy);\n    pt_book.minPrio = sched_get_priority_min(policy);\n    PR_ASSERT(-1 != pt_book.minPrio);\n    pt_book.maxPrio = sched_get_priority_max(policy);\n    PR_ASSERT(-1 != pt_book.maxPrio);\n    pthread_attr_destroy(&attr);\n    }\n#else\n    /*\n    ** These might be function evaluations\n    */\n    pt_book.minPrio = PT_PRIO_MIN;\n    pt_book.maxPrio = PT_PRIO_MAX;\n#endif\n#endif\n    \n    PR_ASSERT(NULL == pt_book.ml);\n    pt_book.ml = PR_NewLock();\n    PR_ASSERT(NULL != pt_book.ml);\n    pt_book.cv = PR_NewCondVar(pt_book.ml);\n    PR_ASSERT(NULL != pt_book.cv);\n    thred = PR_NEWZAP(PRThread);\n    PR_ASSERT(NULL != thred);\n    thred->arg = NULL;\n    thred->startFunc = NULL;\n    thred->priority = priority;\n    thred->id = pthread_self();\n    thred->idSet = PR_TRUE;\n#ifdef _PR_NICE_PRIORITY_SCHEDULING\n    thred->tid = gettid();\n#endif\n\n    thred->state = (PT_THREAD_DETACHED | PT_THREAD_PRIMORD);\n    if (PR_SYSTEM_THREAD == type)\n    {\n        thred->state |= PT_THREAD_SYSTEM;\n        pt_book.system += 1;\n\t    pt_book.this_many = 0;\n    }\n    else\n    {\n\t    pt_book.user += 1;\n\t    pt_book.this_many = 1;\n    }\n    thred->next = thred->prev = NULL;\n    pt_book.first = pt_book.last = thred;\n\n    thred->stack = PR_NEWZAP(PRThreadStack);\n    PR_ASSERT(thred->stack != NULL);\n    thred->stack->stackSize = 0;\n    thred->stack->thr = thred;\n\t_PR_InitializeStack(thred->stack);\n\n    /*\n     * Create a key for our use to store a backpointer in the pthread\n     * to our PRThread object. This object gets deleted when the thread\n     * returns from its root in the case of a detached thread. Other\n     * threads delete the objects in Join.\n     *\n     * NB: The destructor logic seems to have a bug so it isn't used.\n     * NBB: Oh really? I'm going to give it a spin - AOF 19 June 1998.\n     * More info - the problem is that pthreads calls the destructor\n     * eagerly as the thread returns from its root, rather than lazily\n     * after the thread is joined. Therefore, threads that are joining\n     * and holding PRThread references are actually holding pointers to\n     * nothing.\n     */\n    rv = _PT_PTHREAD_KEY_CREATE(&pt_book.key, _pt_thread_death);\n    if (0 != rv)\n        PR_Assert(\"0 == rv\", __FILE__, __LINE__);\n    pt_book.keyCreated = PR_TRUE;\n    rv = pthread_setspecific(pt_book.key, thred);\n    PR_ASSERT(0 == rv);\n}  /* _PR_InitThreads */\n\n#ifdef __GNUC__\n/*\n * GCC supports the constructor and destructor attributes as of\n * version 2.5.\n */\nstatic void _PR_Fini(void) __attribute__ ((destructor));\n#elif defined(__SUNPRO_C)\n/*\n * Sun Studio compiler\n */\n#pragma fini(_PR_Fini)\nstatic void _PR_Fini(void);\n#elif defined(HPUX)\n/*\n * Current versions of HP C compiler define __HP_cc.\n * HP C compiler A.11.01.20 doesn't define __HP_cc.\n */\n#if defined(__ia64) || defined(_LP64)\n#pragma FINI \"_PR_Fini\"\nstatic void _PR_Fini(void);\n#else\n/*\n * Only HP-UX 10.x style initializers are supported in 32-bit links.\n * Need to use the +I PR_HPUX10xInit linker option.\n */\n#include <dl.h>\n\nstatic void _PR_Fini(void);\n\nvoid PR_HPUX10xInit(shl_t handle, int loading)\n{\n    /*\n     * This function is called when a shared library is loaded as well\n     * as when the shared library is unloaded.  Note that it may not\n     * be called when the user's program terminates.\n     *\n     * handle is the shl_load API handle for the shared library being\n     * initialized.\n     *\n     * loading is non-zero at startup and zero at termination.\n     */\n    if (loading) {\n\t/* ... do some initializations ... */\n    } else {\n\t_PR_Fini();\n    }\n}\n#endif\n#elif defined(AIX)\n/* Need to use the -binitfini::_PR_Fini linker option. */\n#endif\n\nvoid _PR_Fini(void)\n{\n    void *thred;\n    int rv;\n\n    if (!_pr_initialized) {\n        /* Either NSPR was never successfully initialized or \n         * PR_Cleanup has been called already. */\n        if (pt_book.keyCreated)\n        {\n            rv = pthread_key_delete(pt_book.key);\n            PR_ASSERT(0 == rv);\n            pt_book.keyCreated = PR_FALSE;\n        }\n        return;\n    }\n\n    _PT_PTHREAD_GETSPECIFIC(pt_book.key, thred);\n    if (NULL != thred)\n    {\n        /*\n         * PR_FALSE, because it is unsafe to call back to the \n         * thread private data destructors at final cleanup.\n         */\n        _pt_thread_death_internal(thred, PR_FALSE);\n        rv = pthread_setspecific(pt_book.key, NULL);\n        PR_ASSERT(0 == rv);\n    }\n    rv = pthread_key_delete(pt_book.key);\n    PR_ASSERT(0 == rv);\n    pt_book.keyCreated = PR_FALSE;\n    /* TODO: free other resources used by NSPR */\n    /* _pr_initialized = PR_FALSE; */\n}  /* _PR_Fini */\n\nPR_IMPLEMENT(PRStatus) PR_Cleanup(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    int rv;\n    PR_LOG(_pr_thread_lm, PR_LOG_MIN, (\"PR_Cleanup: shutting down NSPR\"));\n    PR_ASSERT(me->state & PT_THREAD_PRIMORD);\n    if (me->state & PT_THREAD_PRIMORD)\n    {\n        PR_Lock(pt_book.ml);\n        while (pt_book.user > pt_book.this_many)\n            PR_WaitCondVar(pt_book.cv, PR_INTERVAL_NO_TIMEOUT);\n        if (me->state & PT_THREAD_SYSTEM)\n            pt_book.system -= 1;\n        else\n            pt_book.user -= 1;\n        PR_Unlock(pt_book.ml);\n\n        _PR_MD_EARLY_CLEANUP();\n\n        _PR_CleanupMW();\n        _PR_CleanupTime();\n        _PR_CleanupDtoa();\n        _PR_CleanupCallOnce();\n        _PR_ShutdownLinker();\n        _PR_LogCleanup();\n        _PR_CleanupNet();\n        /* Close all the fd's before calling _PR_CleanupIO */\n        _PR_CleanupIO();\n        _PR_CleanupCMon();\n\n        _pt_thread_death(me);\n        rv = pthread_setspecific(pt_book.key, NULL);\n        PR_ASSERT(0 == rv);\n        /*\n         * I am not sure if it's safe to delete the cv and lock here,\n         * since there may still be \"system\" threads around. If this\n         * call isn't immediately prior to exiting, then there's a\n         * problem.\n         */\n        if (0 == pt_book.system)\n        {\n            PR_DestroyCondVar(pt_book.cv); pt_book.cv = NULL;\n            PR_DestroyLock(pt_book.ml); pt_book.ml = NULL;\n        }\n        PR_DestroyLock(_pr_sleeplock);\n        _pr_sleeplock = NULL;\n        _PR_CleanupLayerCache();\n        _PR_CleanupEnv();\n#ifdef _PR_ZONE_ALLOCATOR\n        _PR_DestroyZones();\n#endif\n        _pr_initialized = PR_FALSE;\n        return PR_SUCCESS;\n    }\n    return PR_FAILURE;\n}  /* PR_Cleanup */\n\nPR_IMPLEMENT(void) PR_ProcessExit(PRIntn status)\n{\n    _exit(status);\n}\n\nPR_IMPLEMENT(PRUint32) PR_GetThreadID(PRThread *thred)\n{\n#if defined(_PR_DCETHREADS)\n    return (PRUint32)&thred->id;  /* this is really a sham! */\n#else\n    return (PRUint32)thred->id;  /* and I don't know what they will do with it */\n#endif\n}\n\n/*\n * $$$\n * The following two thread-to-processor affinity functions are not\n * yet implemented for pthreads.  By the way, these functions should return\n * PRStatus rather than PRInt32 to indicate the success/failure status.\n * $$$\n */\n\nPR_IMPLEMENT(PRInt32) PR_GetThreadAffinityMask(PRThread *thread, PRUint32 *mask)\n{\n    return 0;  /* not implemented */\n}\n\nPR_IMPLEMENT(PRInt32) PR_SetThreadAffinityMask(PRThread *thread, PRUint32 mask )\n{\n    return 0;  /* not implemented */\n}\n\nPR_IMPLEMENT(void)\nPR_SetThreadDumpProc(PRThread* thread, PRThreadDumpProc dump, void *arg)\n{\n    thread->dump = dump;\n    thread->dumpArg = arg;\n}\n\n/* \n * Garbage collection support follows.\n */\n\n#if defined(_PR_DCETHREADS)\n\n/*\n * statics for Garbage Collection support.  We don't need to protect these\n * signal masks since the garbage collector itself is protected by a lock\n * and multiple threads will not be garbage collecting at the same time.\n */\nstatic sigset_t javagc_vtalarm_sigmask;\nstatic sigset_t javagc_intsoff_sigmask;\n\n#else /* defined(_PR_DCETHREADS) */\n\n/* a bogus signal mask for forcing a timed wait */\n/* Not so bogus in AIX as we really do a sigwait */\nstatic sigset_t sigwait_set;\n\nstatic struct timespec onemillisec = {0, 1000000L};\n#ifndef PT_NO_SIGTIMEDWAIT\nstatic struct timespec hundredmillisec = {0, 100000000L};\n#endif\n\nstatic void suspend_signal_handler(PRIntn sig);\n\n#ifdef PT_NO_SIGTIMEDWAIT\nstatic void null_signal_handler(PRIntn sig);\n#endif\n\n#endif /* defined(_PR_DCETHREADS) */\n\n/*\n * Linux pthreads use SIGUSR1 and SIGUSR2 internally, which\n * conflict with the use of these two signals in our GC support.\n * So we don't know how to support GC on Linux pthreads.\n */\nstatic void init_pthread_gc_support(void)\n{\n#ifndef SYMBIAN\n    PRIntn rv;\n\n#if defined(_PR_DCETHREADS)\n\trv = sigemptyset(&javagc_vtalarm_sigmask);\n    PR_ASSERT(0 == rv);\n\trv = sigaddset(&javagc_vtalarm_sigmask, SIGVTALRM);\n    PR_ASSERT(0 == rv);\n#else  /* defined(_PR_DCETHREADS) */\n\t{\n\t    struct sigaction sigact_usr2;\n\n\t    sigact_usr2.sa_handler = suspend_signal_handler;\n\t    sigact_usr2.sa_flags = SA_RESTART;\n\t    sigemptyset (&sigact_usr2.sa_mask);\n\n        rv = sigaction (SIGUSR2, &sigact_usr2, NULL);\n        PR_ASSERT(0 == rv);\n\n        sigemptyset (&sigwait_set);\n#if defined(PT_NO_SIGTIMEDWAIT)\n        sigaddset (&sigwait_set, SIGUSR1);\n#else\n        sigaddset (&sigwait_set, SIGUSR2);\n#endif  /* defined(PT_NO_SIGTIMEDWAIT) */\n\t}\n#if defined(PT_NO_SIGTIMEDWAIT)\n\t{\n\t    struct sigaction sigact_null;\n\t    sigact_null.sa_handler = null_signal_handler;\n\t    sigact_null.sa_flags = SA_RESTART;\n\t    sigemptyset (&sigact_null.sa_mask);\n        rv = sigaction (SIGUSR1, &sigact_null, NULL);\n\t    PR_ASSERT(0 ==rv); \n    }\n#endif  /* defined(PT_NO_SIGTIMEDWAIT) */\n#endif /* defined(_PR_DCETHREADS) */\n#endif /* SYMBIAN */\n}\n\nPR_IMPLEMENT(void) PR_SetThreadGCAble(void)\n{\n    PR_Lock(pt_book.ml);\n\tPR_GetCurrentThread()->state |= PT_THREAD_GCABLE;\n    PR_Unlock(pt_book.ml);\n}\n\nPR_IMPLEMENT(void) PR_ClearThreadGCAble(void)\n{\n    PR_Lock(pt_book.ml);\n\tPR_GetCurrentThread()->state &= (~PT_THREAD_GCABLE);\n    PR_Unlock(pt_book.ml);\n}\n\n#if defined(DEBUG)\nstatic PRBool suspendAllOn = PR_FALSE;\n#endif\n\nstatic PRBool suspendAllSuspended = PR_FALSE;\n\nPR_IMPLEMENT(PRStatus) PR_EnumerateThreads(PREnumerator func, void *arg)\n{\n    PRIntn count = 0;\n    PRStatus rv = PR_SUCCESS;\n    PRThread* thred = pt_book.first;\n\n#if defined(DEBUG) || defined(FORCE_PR_ASSERT)\n#if !defined(_PR_DCETHREADS)\n    PRThread *me = PR_GetCurrentThread();\n#endif\n#endif\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_EnumerateThreads\\n\"));\n    /*\n     * $$$\n     * Need to suspend all threads other than me before doing this.\n     * This is really a gross and disgusting thing to do. The only\n     * good thing is that since all other threads are suspended, holding\n     * the lock during a callback seems like child's play.\n     * $$$\n     */\n    PR_ASSERT(suspendAllOn);\n\n    while (thred != NULL)\n    {\n        /* Steve Morse, 4-23-97: Note that we can't walk a queue by taking\n         * qp->next after applying the function \"func\".  In particular, \"func\"\n         * might remove the thread from the queue and put it into another one in\n         * which case qp->next no longer points to the next entry in the original\n         * queue.\n         *\n         * To get around this problem, we save qp->next in qp_next before applying\n         * \"func\" and use that saved value as the next value after applying \"func\".\n         */\n        PRThread* next = thred->next;\n\n        if (_PT_IS_GCABLE_THREAD(thred))\n        {\n#if !defined(_PR_DCETHREADS)\n            PR_ASSERT((thred == me) || (thred->suspend & PT_THREAD_SUSPENDED));\n#endif\n            PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n                   (\"In PR_EnumerateThreads callback thread %p thid = %X\\n\", \n                    thred, thred->id));\n\n            rv = func(thred, count++, arg);\n            if (rv != PR_SUCCESS)\n                return rv;\n        }\n        thred = next;\n    }\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"End PR_EnumerateThreads count = %d \\n\", count));\n    return rv;\n}  /* PR_EnumerateThreads */\n\n/*\n * PR_SuspendAll and PR_ResumeAll are called during garbage collection.  The strategy \n * we use is to send a SIGUSR2 signal to every gc able thread that we intend to suspend.\n * The signal handler will record the stack pointer and will block until resumed by\n * the resume call.  Since the signal handler is the last routine called for the\n * suspended thread, the stack pointer will also serve as a place where all the\n * registers have been saved on the stack for the previously executing routines.\n *\n * Through global variables, we also make sure that PR_Suspend and PR_Resume does not\n * proceed until the thread is suspended or resumed.\n */\n\n#if !defined(_PR_DCETHREADS)\n\n/*\n * In the signal handler, we can not use condition variable notify or wait.\n * This does not work consistently across all pthread platforms.  We also can not \n * use locking since that does not seem to work reliably across platforms.\n * Only thing we can do is yielding while testing for a global condition\n * to change.  This does work on pthread supported platforms.  We may have\n * to play with priortities if there are any problems detected.\n */\n\n /* \n  * In AIX, you cannot use ANY pthread calls in the signal handler except perhaps\n  * pthread_yield. But that is horribly inefficient. Hence we use only sigwait, no\n  * sigtimedwait is available. We need to use another user signal, SIGUSR1. Actually\n  * SIGUSR1 is also used by exec in Java. So our usage here breaks the exec in Java,\n  * for AIX. You cannot use pthread_cond_wait or pthread_delay_np in the signal\n  * handler as all synchronization mechanisms just break down. \n  */\n\n#if defined(PT_NO_SIGTIMEDWAIT)\nstatic void null_signal_handler(PRIntn sig)\n{\n\treturn;\n}\n#endif\n\nstatic void suspend_signal_handler(PRIntn sig)\n{\n\tPRThread *me = PR_GetCurrentThread();\n\n\tPR_ASSERT(me != NULL);\n\tPR_ASSERT(_PT_IS_GCABLE_THREAD(me));\n\tPR_ASSERT((me->suspend & PT_THREAD_SUSPENDED) == 0);\n\n\tPR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n        (\"Begin suspend_signal_handler thred %p thread id = %X\\n\", \n\t\tme, me->id));\n\n\t/*\n\t * save stack pointer\n\t */\n\tme->sp = &me;\n\n\t/* \n\t   At this point, the thread's stack pointer has been saved,\n\t   And it is going to enter a wait loop until it is resumed.\n\t   So it is _really_ suspended \n\t*/\n\n\tme->suspend |= PT_THREAD_SUSPENDED;\n\n\t/*\n\t * now, block current thread\n\t */\n#if defined(PT_NO_SIGTIMEDWAIT)\n\tpthread_cond_signal(&me->suspendResumeCV);\n\twhile (me->suspend & PT_THREAD_SUSPENDED)\n\t{\n#if !defined(FREEBSD) && !defined(NETBSD) && !defined(OPENBSD) \\\n    && !defined(BSDI) && !defined(UNIXWARE) \\\n    && !defined(DARWIN) && !defined(RISCOS) \\\n    && !defined(SYMBIAN) /*XXX*/\n        PRIntn rv;\n\t    sigwait(&sigwait_set, &rv);\n#endif\n\t}\n\tme->suspend |= PT_THREAD_RESUMED;\n\tpthread_cond_signal(&me->suspendResumeCV);\n#else /* defined(PT_NO_SIGTIMEDWAIT) */\n\twhile (me->suspend & PT_THREAD_SUSPENDED)\n\t{\n\t\tPRIntn rv = sigtimedwait(&sigwait_set, NULL, &hundredmillisec);\n    \tPR_ASSERT(-1 == rv);\n\t}\n\tme->suspend |= PT_THREAD_RESUMED;\n#endif\n\n    /*\n     * At this point, thread has been resumed, so set a global condition.\n     * The ResumeAll needs to know that this has really been resumed. \n     * So the signal handler sets a flag which PR_ResumeAll will reset. \n     * The PR_ResumeAll must reset this flag ...\n     */\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n        (\"End suspend_signal_handler thred = %p tid = %X\\n\", me, me->id));\n}  /* suspend_signal_handler */\n\nstatic void pt_SuspendSet(PRThread *thred)\n{\n    PRIntn rv;\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"pt_SuspendSet thred %p thread id = %X\\n\", thred, thred->id));\n\n\n    /*\n     * Check the thread state and signal the thread to suspend\n     */\n\n    PR_ASSERT((thred->suspend & PT_THREAD_SUSPENDED) == 0);\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"doing pthread_kill in pt_SuspendSet thred %p tid = %X\\n\",\n\t   thred, thred->id));\n#if defined(SYMBIAN)\n    /* All signal group functions are not implemented in Symbian OS */\n    rv = 0;\n#else\n    rv = pthread_kill (thred->id, SIGUSR2);\n#endif\n    PR_ASSERT(0 == rv);\n}\n\nstatic void pt_SuspendTest(PRThread *thred)\n{\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"Begin pt_SuspendTest thred %p thread id = %X\\n\", thred, thred->id));\n\n\n    /*\n     * Wait for the thread to be really suspended. This happens when the\n     * suspend signal handler stores the stack pointer and sets the state\n     * to suspended. \n     */\n\n#if defined(PT_NO_SIGTIMEDWAIT)\n    pthread_mutex_lock(&thred->suspendResumeMutex);\n    while ((thred->suspend & PT_THREAD_SUSPENDED) == 0)\n    {\n\t    pthread_cond_timedwait(\n\t        &thred->suspendResumeCV, &thred->suspendResumeMutex, &onemillisec);\n\t}\n\tpthread_mutex_unlock(&thred->suspendResumeMutex);\n#else\n    while ((thred->suspend & PT_THREAD_SUSPENDED) == 0)\n    {\n\t\tPRIntn rv = sigtimedwait(&sigwait_set, NULL, &onemillisec);\n    \tPR_ASSERT(-1 == rv);\n\t}\n#endif\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS,\n        (\"End pt_SuspendTest thred %p tid %X\\n\", thred, thred->id));\n}  /* pt_SuspendTest */\n\nstatic void pt_ResumeSet(PRThread *thred)\n{\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"pt_ResumeSet thred %p thread id = %X\\n\", thred, thred->id));\n\n    /*\n     * Clear the global state and set the thread state so that it will\n     * continue past yield loop in the suspend signal handler\n     */\n\n    PR_ASSERT(thred->suspend & PT_THREAD_SUSPENDED);\n\n\n    thred->suspend &= ~PT_THREAD_SUSPENDED;\n\n#if defined(PT_NO_SIGTIMEDWAIT)\n#if defined(SYMBIAN) \n\t/* All signal group functions are not implemented in Symbian OS */\n#else\n\tpthread_kill(thred->id, SIGUSR1);\n#endif\n#endif\n\n}  /* pt_ResumeSet */\n\nstatic void pt_ResumeTest(PRThread *thred)\n{\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t   (\"Begin pt_ResumeTest thred %p thread id = %X\\n\", thred, thred->id));\n\n    /*\n     * Wait for the threads resume state to change\n     * to indicate it is really resumed \n     */\n#if defined(PT_NO_SIGTIMEDWAIT)\n    pthread_mutex_lock(&thred->suspendResumeMutex);\n    while ((thred->suspend & PT_THREAD_RESUMED) == 0)\n    {\n\t    pthread_cond_timedwait(\n\t        &thred->suspendResumeCV, &thred->suspendResumeMutex, &onemillisec);\n    }\n    pthread_mutex_unlock(&thred->suspendResumeMutex);\n#else\n    while ((thred->suspend & PT_THREAD_RESUMED) == 0) {\n\t\tPRIntn rv = sigtimedwait(&sigwait_set, NULL, &onemillisec);\n    \tPR_ASSERT(-1 == rv);\n\t}\n#endif\n\n    thred->suspend &= ~PT_THREAD_RESUMED;\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\n        \"End pt_ResumeTest thred %p tid %X\\n\", thred, thred->id));\n}  /* pt_ResumeTest */\n\nstatic pthread_once_t pt_gc_support_control = PTHREAD_ONCE_INIT;\n\nPR_IMPLEMENT(void) PR_SuspendAll(void)\n{\n#ifdef DEBUG\n    PRIntervalTime stime, etime;\n#endif\n    PRThread* thred = pt_book.first;\n    PRThread *me = PR_GetCurrentThread();\n    int rv;\n\n    rv = pthread_once(&pt_gc_support_control, init_pthread_gc_support);\n    PR_ASSERT(0 == rv);\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_SuspendAll\\n\"));\n    /*\n     * Stop all threads which are marked GC able.\n     */\n    PR_Lock(pt_book.ml);\n#ifdef DEBUG\n    suspendAllOn = PR_TRUE;\n    stime = PR_IntervalNow();\n#endif\n    while (thred != NULL)\n    {\n\t    if ((thred != me) && _PT_IS_GCABLE_THREAD(thred))\n    \t\tpt_SuspendSet(thred);\n        thred = thred->next;\n    }\n\n    /* Wait till they are really suspended */\n    thred = pt_book.first;\n    while (thred != NULL)\n    {\n\t    if ((thred != me) && _PT_IS_GCABLE_THREAD(thred))\n            pt_SuspendTest(thred);\n        thred = thred->next;\n    }\n\n    suspendAllSuspended = PR_TRUE;\n\n#ifdef DEBUG\n    etime = PR_IntervalNow();\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS,\\\n        (\"End PR_SuspendAll (time %dms)\\n\",\n        PR_IntervalToMilliseconds(etime - stime)));\n#endif\n}  /* PR_SuspendAll */\n\nPR_IMPLEMENT(void) PR_ResumeAll(void)\n{\n#ifdef DEBUG\n    PRIntervalTime stime, etime;\n#endif\n    PRThread* thred = pt_book.first;\n    PRThread *me = PR_GetCurrentThread();\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_ResumeAll\\n\"));\n    /*\n     * Resume all previously suspended GC able threads.\n     */\n    suspendAllSuspended = PR_FALSE;\n#ifdef DEBUG\n    stime = PR_IntervalNow();\n#endif\n\n    while (thred != NULL)\n    {\n\t    if ((thred != me) && _PT_IS_GCABLE_THREAD(thred))\n    \t    pt_ResumeSet(thred);\n        thred = thred->next;\n    }\n\n    thred = pt_book.first;\n    while (thred != NULL)\n    {\n\t    if ((thred != me) && _PT_IS_GCABLE_THREAD(thred))\n    \t    pt_ResumeTest(thred);\n        thred = thred->next;\n    }\n\n    PR_Unlock(pt_book.ml);\n#ifdef DEBUG\n    suspendAllOn = PR_FALSE;\n    etime = PR_IntervalNow();\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS,\n        (\"End PR_ResumeAll (time %dms)\\n\",\n        PR_IntervalToMilliseconds(etime - stime)));\n#endif\n}  /* PR_ResumeAll */\n\n/* Return the stack pointer for the given thread- used by the GC */\nPR_IMPLEMENT(void *)PR_GetSP(PRThread *thred)\n{\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, \n\t    (\"in PR_GetSP thred %p thid = %X, sp = %p\\n\", \n\t    thred, thred->id, thred->sp));\n    return thred->sp;\n}  /* PR_GetSP */\n\n#else /* !defined(_PR_DCETHREADS) */\n\nstatic pthread_once_t pt_gc_support_control = pthread_once_init;\n\n/*\n * For DCE threads, there is no pthread_kill or a way of suspending or resuming a\n * particular thread.  We will just disable the preemption (virtual timer alarm) and\n * let the executing thread finish the garbage collection.  This stops all other threads\n * (GC able or not) and is very inefficient but there is no other choice.\n */\nPR_IMPLEMENT(void) PR_SuspendAll()\n{\n    PRIntn rv;\n\n    rv = pthread_once(&pt_gc_support_control, init_pthread_gc_support);\n    PR_ASSERT(0 == rv);  /* returns -1 on failure */\n#ifdef DEBUG\n    suspendAllOn = PR_TRUE;\n#endif\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_SuspendAll\\n\"));\n    /* \n     * turn off preemption - i.e add virtual alarm signal to the set of \n     * blocking signals \n     */\n    rv = sigprocmask(\n        SIG_BLOCK, &javagc_vtalarm_sigmask, &javagc_intsoff_sigmask);\n    PR_ASSERT(0 == rv);\n    suspendAllSuspended = PR_TRUE;\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"End PR_SuspendAll\\n\"));\n}  /* PR_SuspendAll */\n\nPR_IMPLEMENT(void) PR_ResumeAll()\n{\n    PRIntn rv;\n    \n    suspendAllSuspended = PR_FALSE;\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_ResumeAll\\n\"));\n    /* turn on preemption - i.e re-enable virtual alarm signal */\n\n    rv = sigprocmask(SIG_SETMASK, &javagc_intsoff_sigmask, (sigset_t *)NULL);\n    PR_ASSERT(0 == rv);\n#ifdef DEBUG\n    suspendAllOn = PR_FALSE;\n#endif\n\n    PR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"End PR_ResumeAll\\n\"));\n}  /* PR_ResumeAll */\n\n/* Return the stack pointer for the given thread- used by the GC */\nPR_IMPLEMENT(void*)PR_GetSP(PRThread *thred)\n{\n\tpthread_t tid = thred->id;\n\tchar *thread_tcb, *top_sp;\n\n\t/*\n\t * For HPUX DCE threads, pthread_t is a struct with the\n\t * following three fields (see pthread.h, dce/cma.h):\n\t *     cma_t_address       field1;\n\t *     short int           field2;\n\t *     short int           field3;\n\t * where cma_t_address is typedef'd to be either void*\n\t * or char*.\n\t */\n\tPR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"Begin PR_GetSP\\n\"));\n\tthread_tcb = (char*)tid.field1;\n\ttop_sp = *(char**)(thread_tcb + 128);\n\tPR_LOG(_pr_gc_lm, PR_LOG_ALWAYS, (\"End PR_GetSP %p \\n\", top_sp));\n\treturn top_sp;\n}  /* PR_GetSP */\n\n#endif /* !defined(_PR_DCETHREADS) */\n\nPR_IMPLEMENT(PRStatus) PR_SetCurrentThreadName(const char *name)\n{\n    PRThread *thread;\n    size_t nameLen;\n    int result = 0;\n\n    if (!name) {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    thread = PR_GetCurrentThread();\n    if (!thread)\n        return PR_FAILURE;\n\n    PR_Free(thread->name);\n    nameLen = strlen(name);\n    thread->name = (char *)PR_Malloc(nameLen + 1);\n    if (!thread->name)\n        return PR_FAILURE;\n    memcpy(thread->name, name, nameLen + 1);\n\n#if defined(OPENBSD) || defined(FREEBSD) || defined(DRAGONFLY)\n    pthread_set_name_np(thread->id, name);\n#elif defined(NETBSD)\n    result = pthread_setname_np(thread->id, \"%s\", (void *)name);\n#else /* not BSD */\n    /*\n     * On OSX, pthread_setname_np is only available in 10.6 or later, so test\n     * for it at runtime.  It also may not be available on all linux distros.\n     */\n#if defined(DARWIN)\n    int (*dynamic_pthread_setname_np)(const char*);\n#else\n    int (*dynamic_pthread_setname_np)(pthread_t, const char*);\n#endif\n\n    *(void**)(&dynamic_pthread_setname_np) =\n        dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n    if (!dynamic_pthread_setname_np)\n        return PR_SUCCESS;\n\n    /*\n     * The 15-character name length limit is an experimentally determined\n     * length of a null-terminated string that most linux distros and OS X\n     * accept as an argument to pthread_setname_np.  Otherwise the E2BIG\n     * error is returned by the function.\n     */\n#define SETNAME_LENGTH_CONSTRAINT 15\n#define SETNAME_FRAGMENT1_LENGTH (SETNAME_LENGTH_CONSTRAINT >> 1)\n#define SETNAME_FRAGMENT2_LENGTH \\\n    (SETNAME_LENGTH_CONSTRAINT - SETNAME_FRAGMENT1_LENGTH - 1)\n    char name_dup[SETNAME_LENGTH_CONSTRAINT + 1];\n    if (nameLen > SETNAME_LENGTH_CONSTRAINT) {\n        memcpy(name_dup, name, SETNAME_FRAGMENT1_LENGTH);\n        name_dup[SETNAME_FRAGMENT1_LENGTH] = '~';\n        /* Note that this also copies the null terminator. */\n        memcpy(name_dup + SETNAME_FRAGMENT1_LENGTH + 1,\n               name + nameLen - SETNAME_FRAGMENT2_LENGTH,\n               SETNAME_FRAGMENT2_LENGTH + 1);\n        name = name_dup;\n    }\n\n#if defined(DARWIN)\n    result = dynamic_pthread_setname_np(name);\n#else\n    result = dynamic_pthread_setname_np(thread->id, name);\n#endif\n#endif /* not BSD */\n\n    if (result) {\n        PR_SetError(PR_UNKNOWN_ERROR, result);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}\n\nPR_IMPLEMENT(const char *) PR_GetThreadName(const PRThread *thread)\n{\n    if (!thread)\n        return NULL;\n    return thread->name;\n}\n\n#endif  /* defined(_PR_PTHREADS) || defined(_PR_DCETHREADS) */\n\n/* ptthread.c */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/pthreads/ptio.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/*\n** File:   ptio.c\n** Descritpion:  Implemenation of I/O methods for pthreads\n*/\n\n#if defined(_PR_PTHREADS)\n\n#if defined(_PR_POLL_WITH_SELECT)\n#if !(defined(HPUX) && defined(_USE_BIG_FDS))\n/* set fd limit for select(), before including system header files */\n#define FD_SETSIZE (16 * 1024)\n#endif\n#endif\n\n#include <pthread.h>\n#include <string.h>  /* for memset() */\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#if defined(DARWIN)\n#include <sys/utsname.h> /* for uname */\n#endif\n#if defined(SOLARIS) || defined(UNIXWARE)\n#include <sys/filio.h>  /* to pick up FIONREAD */\n#endif\n#ifdef _PR_POLL_AVAILABLE\n#include <poll.h>\n#endif\n#ifdef AIX\n/* To pick up sysconf() */\n#include <unistd.h>\n#include <dlfcn.h>  /* for dlopen */\n#else\n/* To pick up getrlimit() etc. */\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef SOLARIS\n/*\n * Define HAVE_SENDFILEV if the system has the sendfilev() system call.\n * Code built this way won't run on a system without sendfilev().\n * We can define HAVE_SENDFILEV by default when the minimum release\n * of Solaris that NSPR supports has sendfilev().\n */\n#ifdef HAVE_SENDFILEV\n\n#include <sys/sendfile.h>\n\n#define SOLARIS_SENDFILEV(a, b, c, d) sendfilev((a), (b), (c), (d))\n\n#else\n\n#include <dlfcn.h>  /* for dlopen */\n\n/*\n * Match the definitions in <sys/sendfile.h>.\n */\ntypedef struct sendfilevec {\n    int sfv_fd;       /* input fd */\n    uint_t sfv_flag;  /* flags */\n    off_t sfv_off;    /* offset to start reading from */\n    size_t sfv_len;   /* amount of data */\n} sendfilevec_t;\n\n#define SFV_FD_SELF (-2)\n\n/*\n * extern ssize_t sendfilev(int, const struct sendfilevec *, int, size_t *);\n */\nstatic ssize_t (*pt_solaris_sendfilev_fptr)() = NULL;\n\n#define SOLARIS_SENDFILEV(a, b, c, d) \\\n        (*pt_solaris_sendfilev_fptr)((a), (b), (c), (d))\n\n#endif /* HAVE_SENDFILEV */\n#endif /* SOLARIS */\n\n/*\n * The send_file() system call is available in AIX 4.3.2 or later.\n * If this file is compiled on an older AIX system, it attempts to\n * look up the send_file symbol at run time to determine whether\n * we can use the faster PR_SendFile/PR_TransmitFile implementation based on\n * send_file().  On AIX 4.3.2 or later, we can safely skip this\n * runtime function dispatching and just use the send_file based\n * implementation.\n */\n#ifdef AIX\n#ifdef SF_CLOSE\n#define HAVE_SEND_FILE\n#endif\n\n#ifdef HAVE_SEND_FILE\n\n#define AIX_SEND_FILE(a, b, c) send_file(a, b, c)\n\n#else /* HAVE_SEND_FILE */\n\n/*\n * The following definitions match those in <sys/socket.h>\n * on AIX 4.3.2.\n */\n\n/*\n * Structure for the send_file() system call\n */\nstruct sf_parms {\n    /* --------- header parms ---------- */\n    void      *header_data;         /* Input/Output. Points to header buf */\n    uint_t    header_length;        /* Input/Output. Length of the header */\n    /* --------- file parms ------------ */\n    int       file_descriptor;      /* Input. File descriptor of the file */\n    unsigned long long file_size;   /* Output. Size of the file */\n    unsigned long long file_offset; /* Input/Output. Starting offset */\n    long long file_bytes;           /* Input/Output. no. of bytes to send */\n    /* --------- trailer parms --------- */\n    void      *trailer_data;        /* Input/Output. Points to trailer buf */\n    uint_t    trailer_length;       /* Input/Output. Length of the trailer */\n    /* --------- return info ----------- */\n    unsigned long long bytes_sent;  /* Output. no. of bytes sent */\n};\n\n/*\n * Flags for the send_file() system call\n */\n#define SF_CLOSE        0x00000001      /* close the socket after completion */\n#define SF_REUSE        0x00000002      /* reuse socket. not supported */\n#define SF_DONT_CACHE   0x00000004      /* don't apply network buffer cache */\n#define SF_SYNC_CACHE   0x00000008      /* sync/update network buffer cache */\n\n/*\n * prototype: size_t send_file(int *, struct sf_parms *, uint_t);\n */\nstatic ssize_t (*pt_aix_sendfile_fptr)() = NULL;\n\n#define AIX_SEND_FILE(a, b, c) (*pt_aix_sendfile_fptr)(a, b, c)\n\n#endif /* HAVE_SEND_FILE */\n#endif /* AIX */\n\n#ifdef LINUX\n#include <sys/sendfile.h>\n#endif\n\n#include \"primpl.h\"\n\n#ifdef HAVE_NETINET_TCP_H\n#include <netinet/tcp.h>  /* TCP_NODELAY, TCP_MAXSEG */\n#endif\n\n#ifdef LINUX\n/* TCP_CORK is not defined in <netinet/tcp.h> on Red Hat Linux 6.0 */\n#ifndef TCP_CORK\n#define TCP_CORK 3\n#endif\n#endif\n\n#ifdef _PR_IPV6_V6ONLY_PROBE\nstatic PRBool _pr_ipv6_v6only_on_by_default;\n#endif\n\n#if (defined(HPUX) && !defined(HPUX10_30) && !defined(HPUX11))\n#define _PRSelectFdSetArg_t int *\n#elif defined(AIX4_1)\n#define _PRSelectFdSetArg_t void *\n#elif defined(IRIX) || (defined(AIX) && !defined(AIX4_1)) \\\n    || defined(OSF1) || defined(SOLARIS) \\\n    || defined(HPUX10_30) || defined(HPUX11) \\\n    || defined(LINUX) || defined(__GNU__) || defined(__GLIBC__) \\\n    || defined(FREEBSD) || defined(NETBSD) || defined(OPENBSD) \\\n    || defined(BSDI) || defined(NTO) || defined(DARWIN) \\\n    || defined(UNIXWARE) || defined(RISCOS) || defined(SYMBIAN)\n#define _PRSelectFdSetArg_t fd_set *\n#else\n#error \"Cannot determine architecture\"\n#endif\n\n#if defined(SOLARIS)            \n#ifndef PROTO_SDP\n/* on solaris, SDP is a new type of protocol */\n#define PROTO_SDP   257\n#endif \n#define _PR_HAVE_SDP\n#elif defined(LINUX)\n#ifndef AF_INET_SDP\n/* on linux, SDP is a new type of address family */\n#define AF_INET_SDP 27\n#endif\n#define _PR_HAVE_SDP\n#endif /* LINUX */\n\nstatic PRFileDesc *pt_SetMethods(\n    PRIntn osfd, PRDescType type, PRBool isAcceptedSocket, PRBool imported);\n\nstatic PRLock *_pr_flock_lock;  /* For PR_LockFile() etc. */\nstatic PRCondVar *_pr_flock_cv;  /* For PR_LockFile() etc. */\nstatic PRLock *_pr_rename_lock;  /* For PR_Rename() */\n\n/**************************************************************************/\n\n/* These two functions are only used in assertions. */\n#if defined(DEBUG)\n\nPRBool IsValidNetAddr(const PRNetAddr *addr)\n{\n    if ((addr != NULL)\n            && (addr->raw.family != AF_UNIX)\n            && (addr->raw.family != PR_AF_INET6)\n            && (addr->raw.family != AF_INET)) {\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n\nstatic PRBool IsValidNetAddrLen(const PRNetAddr *addr, PRInt32 addr_len)\n{\n    /*\n     * The definition of the length of a Unix domain socket address\n     * is not uniform, so we don't check it.\n     */\n    if ((addr != NULL)\n            && (addr->raw.family != AF_UNIX)\n            && (PR_NETADDR_SIZE(addr) != addr_len)) {\n#if defined(LINUX) && __GLIBC__ == 2 && __GLIBC_MINOR__ == 1\n        /*\n         * In glibc 2.1, struct sockaddr_in6 is 24 bytes.  In glibc 2.2\n         * and in the 2.4 kernel, struct sockaddr_in6 has the scope_id\n         * field and is 28 bytes.  It is possible for socket functions\n         * to return an addr_len greater than sizeof(struct sockaddr_in6).\n         * We need to allow that.  (Bugzilla bug #77264)\n         */\n        if ((PR_AF_INET6 == addr->raw.family)\n                && (sizeof(addr->ipv6) == addr_len)) {\n            return PR_TRUE;\n        }\n#endif\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n\n#endif /* DEBUG */\n\n/*****************************************************************************/\n/************************* I/O Continuation machinery ************************/\n/*****************************************************************************/\n\n/*\n * The polling interval defines the maximum amount of time that a thread\n * might hang up before an interrupt is noticed.\n */\n#define PT_DEFAULT_POLL_MSEC 5000\n#if defined(_PR_POLL_WITH_SELECT)\n#define PT_DEFAULT_SELECT_SEC (PT_DEFAULT_POLL_MSEC/PR_MSEC_PER_SEC)\n#define PT_DEFAULT_SELECT_USEC\t\t\t\t\t\t\t\\\n\t\t((PT_DEFAULT_POLL_MSEC % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC)\n#endif\n\n/*\n * pt_SockLen is the type for the length of a socket address\n * structure, used in the address length argument to bind,\n * connect, accept, getsockname, getpeername, etc.  Posix.1g\n * defines this type as socklen_t.  It is size_t or int on\n * most current systems.\n */\n#if defined(HAVE_SOCKLEN_T) \\\n    || (defined(__GLIBC__) && __GLIBC__ >= 2)\ntypedef socklen_t pt_SockLen;\n#elif (defined(AIX) && !defined(AIX4_1)) \ntypedef PRSize pt_SockLen;\n#else\ntypedef PRIntn pt_SockLen;\n#endif\n\ntypedef struct pt_Continuation pt_Continuation;\ntypedef PRBool (*ContinuationFn)(pt_Continuation *op, PRInt16 revents);\n\ntypedef enum pr_ContuationStatus\n{\n    pt_continuation_pending,\n    pt_continuation_done\n} pr_ContuationStatus;\n\nstruct pt_Continuation\n{\n    /* The building of the continuation operation */\n    ContinuationFn function;                /* what function to continue */\n    union { PRIntn osfd; } arg1;            /* #1 - the op's fd */\n    union { void* buffer; } arg2;           /* #2 - primary transfer buffer */\n    union {\n        PRSize amount;                      /* #3 - size of 'buffer', or */\n        pt_SockLen *addr_len;                  /*    - length of address */\n#ifdef HPUX11\n        /*\n         * For sendfile()\n         */\n\t\tstruct file_spec {\t\t\n        \toff_t offset;                       /* offset in file to send */\n        \tsize_t nbytes;                      /* length of file data to send */\n        \tsize_t st_size;                     /* file size */\n\t\t} file_spec;\n#endif\n    } arg3;\n    union { PRIntn flags; } arg4;           /* #4 - read/write flags */\n    union { PRNetAddr *addr; } arg5;        /* #5 - send/recv address */\n\n#ifdef HPUX11\n    /*\n     * For sendfile()\n     */\n    int filedesc;                           /* descriptor of file to send */\n    int nbytes_to_send;                     /* size of header and file */\n#endif  /* HPUX11 */\n    \n#ifdef SOLARIS\n    /*\n     * For sendfilev()\n     */\n    int nbytes_to_send;                     /* size of header and file */\n#endif  /* SOLARIS */\n\n#ifdef LINUX\n    /*\n     * For sendfile()\n     */\n    int in_fd;                              /* descriptor of file to send */\n    off_t offset;\n    size_t count;\n#endif  /* LINUX */\n \n    PRIntervalTime timeout;                 /* client (relative) timeout */\n\n    PRInt16 event;                           /* flags for poll()'s events */\n\n    /*\n    ** The representation and notification of the results of the operation.\n    ** These function can either return an int return code or a pointer to\n    ** some object.\n    */\n    union { PRSize code; void *object; } result;\n\n    PRIntn syserrno;                        /* in case it failed, why (errno) */\n    pr_ContuationStatus status;             /* the status of the operation */\n};\n\n#if defined(DEBUG)\n\nPTDebug pt_debug;  /* this is shared between several modules */\n\nPR_IMPLEMENT(void) PT_FPrintStats(PRFileDesc *debug_out, const char *msg)\n{\n    PTDebug stats;\n    char buffer[100];\n    PRExplodedTime tod;\n    PRInt64 elapsed, aMil;\n    stats = pt_debug;  /* a copy */\n    PR_ExplodeTime(stats.timeStarted, PR_LocalTimeParameters, &tod);\n    (void)PR_FormatTime(buffer, sizeof(buffer), \"%T\", &tod);\n\n    LL_SUB(elapsed, PR_Now(), stats.timeStarted);\n    LL_I2L(aMil, 1000000);\n    LL_DIV(elapsed, elapsed, aMil);\n    \n    if (NULL != msg) PR_fprintf(debug_out, \"%s\", msg);\n    PR_fprintf(\n        debug_out, \"\\tstarted: %s[%lld]\\n\", buffer, elapsed);\n    PR_fprintf(\n        debug_out, \"\\tlocks [created: %u, destroyed: %u]\\n\",\n        stats.locks_created, stats.locks_destroyed);\n    PR_fprintf(\n        debug_out, \"\\tlocks [acquired: %u, released: %u]\\n\",\n        stats.locks_acquired, stats.locks_released);\n    PR_fprintf(\n        debug_out, \"\\tcvars [created: %u, destroyed: %u]\\n\",\n        stats.cvars_created, stats.cvars_destroyed);\n    PR_fprintf(\n        debug_out, \"\\tcvars [notified: %u, delayed_delete: %u]\\n\",\n        stats.cvars_notified, stats.delayed_cv_deletes);\n}  /* PT_FPrintStats */\n\n#else\n\nPR_IMPLEMENT(void) PT_FPrintStats(PRFileDesc *debug_out, const char *msg)\n{\n    /* do nothing */\n}  /* PT_FPrintStats */\n\n#endif  /* DEBUG */\n\n#if defined(_PR_POLL_WITH_SELECT)\n/*\n * OSF1 and HPUX report the POLLHUP event for a socket when the\n * shutdown(SHUT_WR) operation is called for the remote end, even though\n * the socket is still writeable. Use select(), instead of poll(), to\n * workaround this problem.\n */\nstatic void pt_poll_now_with_select(pt_Continuation *op)\n{\n    PRInt32 msecs;\n\tfd_set rd, wr, *rdp, *wrp;\n\tstruct timeval tv;\n\tPRIntervalTime epoch, now, elapsed, remaining;\n\tPRBool wait_for_remaining;\n    PRThread *self = PR_GetCurrentThread();\n    \n\tPR_ASSERT(PR_INTERVAL_NO_WAIT != op->timeout);\n\tPR_ASSERT(op->arg1.osfd < FD_SETSIZE);\n\n    switch (op->timeout) {\n        case PR_INTERVAL_NO_TIMEOUT:\n\t\t\ttv.tv_sec = PT_DEFAULT_SELECT_SEC;\n\t\t\ttv.tv_usec = PT_DEFAULT_SELECT_USEC;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\n\t\t\t\tif (op->event & POLLIN) {\n\t\t\t\t\tFD_ZERO(&rd);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &rd);\n\t\t\t\t\trdp = &rd;\n\t\t\t\t} else\n\t\t\t\t\trdp = NULL;\n\t\t\t\tif (op->event & POLLOUT) {\n\t\t\t\t\tFD_ZERO(&wr);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &wr);\n\t\t\t\t\twrp = &wr;\n\t\t\t\t} else\n\t\t\t\t\twrp = NULL;\n\n\t\t\t\trv = select(op->arg1.osfd + 1, rdp, wrp, NULL, &tv);\n\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((-1 == rv) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\t\t\tcontinue; /* go around the loop again */\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 revents = 0;\n\n\t\t\t\t\tif ((op->event & POLLIN) && FD_ISSET(op->arg1.osfd, &rd))\n\t\t\t\t\t\trevents |= POLLIN;\n\t\t\t\t\tif ((op->event & POLLOUT) && FD_ISSET(op->arg1.osfd, &wr))\n\t\t\t\t\t\trevents |= POLLOUT;\n\t\t\t\t\t\t\n\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t} else if (rv == -1) {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t\t/* else, select timed out */\n\t\t\t} while (pt_continuation_done != op->status);\n\t\t\tbreak;\n        default:\n            now = epoch = PR_IntervalNow();\n            remaining = op->timeout;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\n\t\t\t\tif (op->event & POLLIN) {\n\t\t\t\t\tFD_ZERO(&rd);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &rd);\n\t\t\t\t\trdp = &rd;\n\t\t\t\t} else\n\t\t\t\t\trdp = NULL;\n\t\t\t\tif (op->event & POLLOUT) {\n\t\t\t\t\tFD_ZERO(&wr);\n\t\t\t\t\tFD_SET(op->arg1.osfd, &wr);\n\t\t\t\t\twrp = &wr;\n\t\t\t\t} else\n\t\t\t\t\twrp = NULL;\n\n    \t\t\twait_for_remaining = PR_TRUE;\n    \t\t\tmsecs = (PRInt32)PR_IntervalToMilliseconds(remaining);\n\t\t\t\tif (msecs > PT_DEFAULT_POLL_MSEC) {\n\t\t\t\t\twait_for_remaining = PR_FALSE;\n\t\t\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\t\t}\n\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC;\n\t\t\t\trv = select(op->arg1.osfd + 1, rdp, wrp, NULL, &tv);\n\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (rv > 0) {\n\t\t\t\t\tPRInt16 revents = 0;\n\n\t\t\t\t\tif ((op->event & POLLIN) && FD_ISSET(op->arg1.osfd, &rd))\n\t\t\t\t\t\trevents |= POLLIN;\n\t\t\t\t\tif ((op->event & POLLOUT) && FD_ISSET(op->arg1.osfd, &wr))\n\t\t\t\t\t\trevents |= POLLOUT;\n\t\t\t\t\t\t\n\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\top->status = pt_continuation_done;\n\n\t\t\t\t} else if ((rv == 0) ||\n\t\t\t\t\t\t((errno == EINTR) || (errno == EAGAIN))) {\n\t\t\t\t\tif (rv == 0) {\t/* select timed out */\n\t\t\t\t\t\tif (wait_for_remaining)\n\t\t\t\t\t\t\tnow += remaining;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnow += PR_MillisecondsToInterval(msecs);\n\t\t\t\t\t} else\n\t\t\t\t\t\tnow = PR_IntervalNow();\n\t\t\t\t\telapsed = (PRIntervalTime) (now - epoch);\n\t\t\t\t\tif (elapsed >= op->timeout) {\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\top->syserrno = ETIMEDOUT;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else\n\t\t\t\t\t\tremaining = op->timeout - elapsed;\n\t\t\t\t} else {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t} while (pt_continuation_done != op->status);\n            break;\n    }\n\n}  /* pt_poll_now_with_select */\n\n#endif\t/* _PR_POLL_WITH_SELECT */\n\nstatic void pt_poll_now(pt_Continuation *op)\n{\n    PRInt32 msecs;\n\tPRIntervalTime epoch, now, elapsed, remaining;\n\tPRBool wait_for_remaining;\n    PRThread *self = PR_GetCurrentThread();\n    \n\tPR_ASSERT(PR_INTERVAL_NO_WAIT != op->timeout);\n#if defined (_PR_POLL_WITH_SELECT)\n\t/*\n \t * If the fd is small enough call the select-based poll operation\n\t */\n\tif (op->arg1.osfd < FD_SETSIZE) {\n\t\tpt_poll_now_with_select(op);\n\t\treturn;\n\t}\n#endif\n\n    switch (op->timeout) {\n        case PR_INTERVAL_NO_TIMEOUT:\n\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\t\t\t\tstruct pollfd tmp_pfd;\n\n\t\t\t\ttmp_pfd.revents = 0;\n\t\t\t\ttmp_pfd.fd = op->arg1.osfd;\n\t\t\t\ttmp_pfd.events = op->event;\n\n\t\t\t\trv = poll(&tmp_pfd, 1, msecs);\n\t\t\t\t\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((-1 == rv) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\t\t\tcontinue; /* go around the loop again */\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 events = tmp_pfd.events;\n\t\t\t\t\tPRInt16 revents = tmp_pfd.revents;\n\n\t\t\t\t\tif ((revents & POLLNVAL)  /* busted in all cases */\n\t\t\t\t\t|| ((events & POLLOUT) && (revents & POLLHUP)))\n\t\t\t\t\t\t/* write op & hup */\n\t\t\t\t\t{\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\tif (POLLNVAL & revents) op->syserrno = EBADF;\n\t\t\t\t\t\telse if (POLLHUP & revents) op->syserrno = EPIPE;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t}\n\t\t\t\t} else if (rv == -1) {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t\t/* else, poll timed out */\n\t\t\t} while (pt_continuation_done != op->status);\n\t\t\tbreak;\n        default:\n            now = epoch = PR_IntervalNow();\n            remaining = op->timeout;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPRIntn rv;\n\t\t\t\tstruct pollfd tmp_pfd;\n\n\t\t\t\ttmp_pfd.revents = 0;\n\t\t\t\ttmp_pfd.fd = op->arg1.osfd;\n\t\t\t\ttmp_pfd.events = op->event;\n\n    \t\t\twait_for_remaining = PR_TRUE;\n    \t\t\tmsecs = (PRInt32)PR_IntervalToMilliseconds(remaining);\n\t\t\t\tif (msecs > PT_DEFAULT_POLL_MSEC)\n\t\t\t\t{\n\t\t\t\t\twait_for_remaining = PR_FALSE;\n\t\t\t\t\tmsecs = PT_DEFAULT_POLL_MSEC;\n\t\t\t\t}\n\t\t\t\trv = poll(&tmp_pfd, 1, msecs);\n\t\t\t\t\n\t\t\t\tif (_PT_THREAD_INTERRUPTED(self))\n\t\t\t\t{\n\t\t\t\t\tself->state &= ~PT_THREAD_ABORTED;\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = EINTR;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (rv > 0)\n\t\t\t\t{\n\t\t\t\t\tPRInt16 events = tmp_pfd.events;\n\t\t\t\t\tPRInt16 revents = tmp_pfd.revents;\n\n\t\t\t\t\tif ((revents & POLLNVAL)  /* busted in all cases */\n\t\t\t\t\t\t|| ((events & POLLOUT) && (revents & POLLHUP))) \n\t\t\t\t\t\t\t\t\t\t\t/* write op & hup */\n\t\t\t\t\t{\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\tif (POLLNVAL & revents) op->syserrno = EBADF;\n\t\t\t\t\t\telse if (POLLHUP & revents) op->syserrno = EPIPE;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->function(op, revents))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ((rv == 0) ||\n\t\t\t\t\t\t((errno == EINTR) || (errno == EAGAIN))) {\n\t\t\t\t\tif (rv == 0)\t/* poll timed out */\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wait_for_remaining)\n\t\t\t\t\t\t\tnow += remaining;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnow += PR_MillisecondsToInterval(msecs);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tnow = PR_IntervalNow();\n\t\t\t\t\telapsed = (PRIntervalTime) (now - epoch);\n\t\t\t\t\tif (elapsed >= op->timeout) {\n\t\t\t\t\t\top->result.code = -1;\n\t\t\t\t\t\top->syserrno = ETIMEDOUT;\n\t\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t\t} else\n\t\t\t\t\t\tremaining = op->timeout - elapsed;\n\t\t\t\t} else {\n\t\t\t\t\top->result.code = -1;\n\t\t\t\t\top->syserrno = errno;\n\t\t\t\t\top->status = pt_continuation_done;\n\t\t\t\t}\n\t\t\t} while (pt_continuation_done != op->status);\n            break;\n    }\n\n}  /* pt_poll_now */\n\nstatic PRIntn pt_Continue(pt_Continuation *op)\n{\n    op->status = pt_continuation_pending;  /* set default value */\n\t/*\n\t * let each thread call poll directly\n\t */\n\tpt_poll_now(op);\n\tPR_ASSERT(pt_continuation_done == op->status);\n    return op->result.code;\n}  /* pt_Continue */\n\n/*****************************************************************************/\n/*********************** specific continuation functions *********************/\n/*****************************************************************************/\nstatic PRBool pt_connect_cont(pt_Continuation *op, PRInt16 revents)\n{\n    op->syserrno = _MD_unix_get_nonblocking_connect_error(op->arg1.osfd);\n    if (op->syserrno != 0) {\n        op->result.code = -1;\n    } else {\n        op->result.code = 0;\n    }\n    return PR_TRUE; /* this one is cooked */\n}  /* pt_connect_cont */\n\nstatic PRBool pt_accept_cont(pt_Continuation *op, PRInt16 revents)\n{\n    op->syserrno = 0;\n    op->result.code = accept(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.addr_len);\n    if (-1 == op->result.code)\n    {\n        op->syserrno = errno;\n        if (EWOULDBLOCK == errno || EAGAIN == errno || ECONNABORTED == errno)\n            return PR_FALSE;  /* do nothing - this one ain't finished */\n    }\n    return PR_TRUE;\n}  /* pt_accept_cont */\n\nstatic PRBool pt_read_cont(pt_Continuation *op, PRInt16 revents)\n{\n    /*\n     * Any number of bytes will complete the operation. It need\n     * not (and probably will not) satisfy the request. The only\n     * error we continue is EWOULDBLOCK|EAGAIN.\n     */\n    op->result.code = read(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_read_cont */\n\nstatic PRBool pt_recv_cont(pt_Continuation *op, PRInt16 revents)\n{\n    /*\n     * Any number of bytes will complete the operation. It need\n     * not (and probably will not) satisfy the request. The only\n     * error we continue is EWOULDBLOCK|EAGAIN.\n     */\n#if defined(SOLARIS)\n    if (0 == op->arg4.flags)\n        op->result.code = read(\n            op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    else\n        op->result.code = recv(\n            op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#else\n    op->result.code = recv(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#endif\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_recv_cont */\n\nstatic PRBool pt_send_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n#if defined(SOLARIS)\n    PRInt32 tmp_amount = op->arg3.amount;\n#endif\n    /*\n     * We want to write the entire amount out, no matter how many\n     * tries it takes. Keep advancing the buffer and the decrementing\n     * the amount until the amount goes away. Return the total bytes\n     * (which should be the original amount) when finished (or an\n     * error).\n     */\n#if defined(SOLARIS)\nretry:\n    bytes = write(op->arg1.osfd, op->arg2.buffer, tmp_amount);\n#else\n    bytes = send(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags);\n#endif\n    op->syserrno = errno;\n\n#if defined(SOLARIS)\n    /*\n     * The write system call has been reported to return the ERANGE error\n     * on occasion. Try to write in smaller chunks to workaround this bug.\n     */\n    if ((bytes == -1) && (op->syserrno == ERANGE))\n    {\n        if (tmp_amount > 1)\n        {\n            tmp_amount = tmp_amount/2;  /* half the bytes */\n            goto retry;\n        }\n    }\n#endif\n\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_send_cont */\n\nstatic PRBool pt_write_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n    /*\n     * We want to write the entire amount out, no matter how many\n     * tries it takes. Keep advancing the buffer and the decrementing\n     * the amount until the amount goes away. Return the total bytes\n     * (which should be the original amount) when finished (or an\n     * error).\n     */\n    bytes = write(op->arg1.osfd, op->arg2.buffer, op->arg3.amount);\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_write_cont */\n\nstatic PRBool pt_writev_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes;\n    struct iovec *iov = (struct iovec*)op->arg2.buffer;\n    /*\n     * Same rules as write, but continuing seems to be a bit more\n     * complicated. As the number of bytes sent grows, we have to\n     * redefine the vector we're pointing at. We might have to\n     * modify an individual vector parms or we might have to eliminate\n     * a pair altogether.\n     */\n    bytes = writev(op->arg1.osfd, iov, op->arg3.amount);\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        PRIntn iov_index;\n        op->result.code += bytes;  /* accumulate the number sent */\n        for (iov_index = 0; iov_index < op->arg3.amount; ++iov_index)\n        {\n            /* how much progress did we make in the i/o vector? */\n            if (bytes < iov[iov_index].iov_len)\n            {\n                /* this element's not done yet */\n                char **bp = (char**)&(iov[iov_index].iov_base);\n                iov[iov_index].iov_len -= bytes;  /* there's that much left */\n                *bp += bytes;  /* starting there */\n                break;  /* go off and do that */\n            }\n            bytes -= iov[iov_index].iov_len;  /* that element's consumed */\n        }\n        op->arg2.buffer = &iov[iov_index];  /* new start of array */\n        op->arg3.amount -= iov_index;  /* and array length */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_writev_cont */\n\nstatic PRBool pt_sendto_cont(pt_Continuation *op, PRInt16 revents)\n{\n    PRIntn bytes = sendto(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount, op->arg4.flags,\n        (struct sockaddr*)op->arg5.addr, PR_NETADDR_SIZE(op->arg5.addr));\n    op->syserrno = errno;\n    if (bytes >= 0)  /* this is progress */\n    {\n        char *bp = (char*)op->arg2.buffer;\n        bp += bytes;  /* adjust the buffer pointer */\n        op->arg2.buffer = bp;\n        op->result.code += bytes;  /* accumulate the number sent */\n        op->arg3.amount -= bytes;  /* and reduce the required count */\n        return (0 == op->arg3.amount) ? PR_TRUE : PR_FALSE;\n    }\n    else if ((EWOULDBLOCK != op->syserrno) && (EAGAIN != op->syserrno))\n    {\n        op->result.code = -1;\n        return PR_TRUE;\n    }\n    else return PR_FALSE;\n}  /* pt_sendto_cont */\n\nstatic PRBool pt_recvfrom_cont(pt_Continuation *op, PRInt16 revents)\n{\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n    op->result.code = recvfrom(\n        op->arg1.osfd, op->arg2.buffer, op->arg3.amount,\n        op->arg4.flags, (struct sockaddr*)op->arg5.addr, &addr_len);\n    op->syserrno = errno;\n    return ((-1 == op->result.code) && \n            (EWOULDBLOCK == op->syserrno || EAGAIN == op->syserrno)) ?\n        PR_FALSE : PR_TRUE;\n}  /* pt_recvfrom_cont */\n\n#ifdef AIX\nstatic PRBool pt_aix_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct sf_parms *sf_struct = (struct sf_parms *) op->arg2.buffer;\n    ssize_t rv;\n\tunsigned long long saved_file_offset;\n\tlong long saved_file_bytes;\n\n\tsaved_file_offset = sf_struct->file_offset;\n\tsaved_file_bytes = sf_struct->file_bytes;\n\tsf_struct->bytes_sent = 0;\n\n\tif ((sf_struct->file_bytes > 0) && (sf_struct->file_size > 0))\n\tPR_ASSERT((sf_struct->file_bytes + sf_struct->file_offset) <=\n\t\t\t\t\t\t\t\t\tsf_struct->file_size);\n    rv = AIX_SEND_FILE(&op->arg1.osfd, sf_struct, op->arg4.flags);\n    op->syserrno = errno;\n\n    if (rv != -1) {\n        op->result.code += sf_struct->bytes_sent;\n\t\t/*\n\t\t * A bug in AIX 4.3.2 prevents the 'file_bytes' field from\n\t\t * being updated. So, 'file_bytes' is maintained by NSPR to\n\t\t * avoid conflict when this bug is fixed in AIX, in the future.\n\t\t */\n\t\tif (saved_file_bytes != -1)\n\t\t\tsaved_file_bytes -= (sf_struct->file_offset - saved_file_offset);\n\t\tsf_struct->file_bytes = saved_file_bytes;\n    } else if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n        op->result.code = -1;\n    } else {\n        return PR_FALSE;\n    }\n\n    if (rv == 1) {    /* more data to send */\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* AIX */\n\n#ifdef HPUX11\nstatic PRBool pt_hpux_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct iovec *hdtrl = (struct iovec *) op->arg2.buffer;\n    int count;\n\n    count = sendfile(op->arg1.osfd, op->filedesc, op->arg3.file_spec.offset,\n\t\t\top->arg3.file_spec.nbytes, hdtrl, op->arg4.flags);\n    PR_ASSERT(count <= op->nbytes_to_send);\n    op->syserrno = errno;\n\n    if (count != -1) {\n        op->result.code += count;\n    } else if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n        op->result.code = -1;\n    } else {\n        return PR_FALSE;\n    }\n    if (count != -1 && count < op->nbytes_to_send) {\n        if (count < hdtrl[0].iov_len) {\n\t\t\t/* header not sent */\n\n            hdtrl[0].iov_base = ((char *) hdtrl[0].iov_base) + count;\n            hdtrl[0].iov_len -= count;\n\n        } else if (count < (hdtrl[0].iov_len + op->arg3.file_spec.nbytes)) {\n\t\t\t/* header sent, file not sent */\n            PRUint32 file_nbytes_sent = count - hdtrl[0].iov_len;\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\n            op->arg3.file_spec.offset += file_nbytes_sent;\n            op->arg3.file_spec.nbytes -= file_nbytes_sent;\n        } else if (count < (hdtrl[0].iov_len + op->arg3.file_spec.nbytes +\n\t\t\t\t\t\t\t\t\t\t\thdtrl[1].iov_len)) {\n            PRUint32 trailer_nbytes_sent = count - (hdtrl[0].iov_len +\n                                         op->arg3.file_spec.nbytes);\n\n\t\t\t/* header sent, file sent, trailer not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\t\t\t/*\n\t\t\t * set file offset and len so that no more file data is\n\t\t\t * sent\n\t\t\t */\n            op->arg3.file_spec.offset = op->arg3.file_spec.st_size;\n            op->arg3.file_spec.nbytes = 0;\n\n            hdtrl[1].iov_base =((char *) hdtrl[1].iov_base)+ trailer_nbytes_sent;\n            hdtrl[1].iov_len -= trailer_nbytes_sent;\n\t\t}\n        op->nbytes_to_send -= count;\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* HPUX11 */\n\n#ifdef SOLARIS  \nstatic PRBool pt_solaris_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    struct sendfilevec *vec = (struct sendfilevec *) op->arg2.buffer;\n    size_t xferred;\n    ssize_t count;\n\n    count = SOLARIS_SENDFILEV(op->arg1.osfd, vec, op->arg3.amount, &xferred);\n    op->syserrno = errno;\n    PR_ASSERT((count == -1) || (count == xferred));\n\n    if (count == -1) {\n        if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN\n                && op->syserrno != EINTR) {\n            op->result.code = -1;\n            return PR_TRUE;\n        }\n        count = xferred;\n    } else if (count == 0) {\n        /* \n         * We are now at EOF. The file was truncated. Solaris sendfile is\n         * supposed to return 0 and no error in this case, though some versions\n         * may return -1 and EINVAL .\n         */\n        op->result.code = -1;\n        op->syserrno = 0; /* will be treated as EOF */\n        return PR_TRUE;\n    }\n    PR_ASSERT(count <= op->nbytes_to_send);\n    \n    op->result.code += count;\n    if (count < op->nbytes_to_send) {\n        op->nbytes_to_send -= count;\n\n        while (count >= vec->sfv_len) {\n            count -= vec->sfv_len;\n            vec++;\n            op->arg3.amount--;\n        }\n        PR_ASSERT(op->arg3.amount > 0);\n\n        vec->sfv_off += count;\n        vec->sfv_len -= count;\n        PR_ASSERT(vec->sfv_len > 0);\n        op->arg2.buffer = vec;\n\n        return PR_FALSE;\n    }\n\n    return PR_TRUE;\n}\n#endif  /* SOLARIS */\n\n#ifdef LINUX \nstatic PRBool pt_linux_sendfile_cont(pt_Continuation *op, PRInt16 revents)\n{\n    ssize_t rv;\n    off_t oldoffset;\n\n    oldoffset = op->offset;\n    rv = sendfile(op->arg1.osfd, op->in_fd, &op->offset, op->count);\n    op->syserrno = errno;\n\n    if (rv == -1) {\n        if (op->syserrno != EWOULDBLOCK && op->syserrno != EAGAIN) {\n            op->result.code = -1;\n            return PR_TRUE;\n        }\n        rv = 0;\n    }\n    PR_ASSERT(rv == op->offset - oldoffset);\n    op->result.code += rv;\n    if (rv < op->count) {\n        op->count -= rv;\n        return PR_FALSE;\n    }\n    return PR_TRUE;\n}\n#endif  /* LINUX */\n\nvoid _PR_InitIO(void)\n{\n#if defined(DEBUG)\n    memset(&pt_debug, 0, sizeof(PTDebug));\n    pt_debug.timeStarted = PR_Now();\n#endif\n\n    _pr_flock_lock = PR_NewLock();\n    PR_ASSERT(NULL != _pr_flock_lock);\n    _pr_flock_cv = PR_NewCondVar(_pr_flock_lock);\n    PR_ASSERT(NULL != _pr_flock_cv);\n    _pr_rename_lock = PR_NewLock();\n    PR_ASSERT(NULL != _pr_rename_lock); \n\n    _PR_InitFdCache();  /* do that */   \n\n    _pr_stdin = pt_SetMethods(0, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    _pr_stdout = pt_SetMethods(1, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    _pr_stderr = pt_SetMethods(2, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    PR_ASSERT(_pr_stdin && _pr_stdout && _pr_stderr);\n\n#ifdef _PR_IPV6_V6ONLY_PROBE\n    /* In Mac OS X v10.3 Panther Beta the IPV6_V6ONLY socket option\n     * is turned on by default, contrary to what RFC 3493, Section\n     * 5.3 says.  So we have to turn it off.  Find out whether we\n     * are running on such a system.\n     */\n    {\n        int osfd;\n        osfd = socket(AF_INET6, SOCK_STREAM, 0);\n        if (osfd != -1) {\n            int on;\n            socklen_t optlen = sizeof(on);\n            if (getsockopt(osfd, IPPROTO_IPV6, IPV6_V6ONLY,\n                    &on, &optlen) == 0) {\n                _pr_ipv6_v6only_on_by_default = on;\n            }\n            close(osfd);\n        }\n    }\n#endif\n}  /* _PR_InitIO */\n\nvoid _PR_CleanupIO(void)\n{\n    _PR_Putfd(_pr_stdin);\n    _pr_stdin = NULL;\n    _PR_Putfd(_pr_stdout);\n    _pr_stdout = NULL;\n    _PR_Putfd(_pr_stderr); \n    _pr_stderr = NULL;\n\n    _PR_CleanupFdCache();\n    \n    if (_pr_flock_cv)\n    {\n        PR_DestroyCondVar(_pr_flock_cv);\n        _pr_flock_cv = NULL;\n    }\n    if (_pr_flock_lock)\n    {\n        PR_DestroyLock(_pr_flock_lock);\n        _pr_flock_lock = NULL;\n    }\n    if (_pr_rename_lock)\n    {\n        PR_DestroyLock(_pr_rename_lock);\n        _pr_rename_lock = NULL;\n    }\n}  /* _PR_CleanupIO */\n\nPR_IMPLEMENT(PRFileDesc*) PR_GetSpecialFD(PRSpecialFD osfd)\n{\n    PRFileDesc *result = NULL;\n    PR_ASSERT(osfd >= PR_StandardInput && osfd <= PR_StandardError);\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    \n    switch (osfd)\n    {\n        case PR_StandardInput: result = _pr_stdin; break;\n        case PR_StandardOutput: result = _pr_stdout; break;\n        case PR_StandardError: result = _pr_stderr; break;\n        default:\n            (void)PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n    }\n    return result;\n}  /* PR_GetSpecialFD */\n\n/*****************************************************************************/\n/***************************** I/O private methods ***************************/\n/*****************************************************************************/\n\nstatic PRBool pt_TestAbort(void)\n{\n    PRThread *me = PR_GetCurrentThread();\n    if(_PT_THREAD_INTERRUPTED(me))\n    {\n        PR_SetError(PR_PENDING_INTERRUPT_ERROR, 0);\n        me->state &= ~PT_THREAD_ABORTED;\n        return PR_TRUE;\n    }\n    return PR_FALSE;\n}  /* pt_TestAbort */\n\nstatic void pt_MapError(void (*mapper)(PRIntn), PRIntn syserrno)\n{\n    switch (syserrno)\n    {\n        case EINTR:\n            PR_SetError(PR_PENDING_INTERRUPT_ERROR, 0); break;\n        case ETIMEDOUT:\n            PR_SetError(PR_IO_TIMEOUT_ERROR, 0); break;\n        default:\n            mapper(syserrno);\n    }\n}  /* pt_MapError */\n\nstatic PRStatus pt_Close(PRFileDesc *fd)\n{\n    if ((NULL == fd) || (NULL == fd->secret)\n        || ((_PR_FILEDESC_OPEN != fd->secret->state)\n        && (_PR_FILEDESC_CLOSED != fd->secret->state)))\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (_PR_FILEDESC_OPEN == fd->secret->state)\n    {\n        if (-1 == close(fd->secret->md.osfd))\n        {\n#ifdef OSF1\n            /*\n             * Bug 86941: On Tru64 UNIX V5.0A and V5.1, the close()\n             * system call, when called to close a TCP socket, may\n             * return -1 with errno set to EINVAL but the system call\n             * does close the socket successfully.  An application\n             * may safely ignore the EINVAL error.  This bug is fixed\n             * on Tru64 UNIX V5.1A and later.  The defect tracking\n             * number is QAR 81431.\n             */\n            if (PR_DESC_SOCKET_TCP != fd->methods->file_type\n            || EINVAL != errno)\n            {\n                pt_MapError(_PR_MD_MAP_CLOSE_ERROR, errno);\n                return PR_FAILURE;\n            }\n#else\n            pt_MapError(_PR_MD_MAP_CLOSE_ERROR, errno);\n            return PR_FAILURE;\n#endif\n        }\n        fd->secret->state = _PR_FILEDESC_CLOSED;\n    }\n    _PR_Putfd(fd);\n    return PR_SUCCESS;\n}  /* pt_Close */\n\nstatic PRInt32 pt_Read(PRFileDesc *fd, void *buf, PRInt32 amount)\n{\n    PRInt32 syserrno, bytes = -1;\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = read(fd->secret->md.osfd, buf, amount);\n    syserrno = errno;\n\n    if ((bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking))\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = buf;\n        op.arg3.amount = amount;\n        op.timeout = PR_INTERVAL_NO_TIMEOUT;\n        op.function = pt_read_cont;\n        op.event = POLLIN | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_READ_ERROR, syserrno);\n    return bytes;\n}  /* pt_Read */\n\nstatic PRInt32 pt_Write(PRFileDesc *fd, const void *buf, PRInt32 amount)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = write(fd->secret->md.osfd, buf, amount);\n    syserrno = errno;\n\n    if ( (bytes >= 0) && (bytes < amount) && (!fd->secret->nonblocking) )\n    {\n        buf = (char *) buf + bytes;\n        amount -= bytes;\n        fNeedContinue = PR_TRUE;\n    }\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        bytes = 0;\n        fNeedContinue = PR_TRUE;\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.timeout = PR_INTERVAL_NO_TIMEOUT;\n        op.result.code = bytes;  /* initialize the number sent */\n        op.function = pt_write_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes == -1)\n        pt_MapError(_PR_MD_MAP_WRITE_ERROR, syserrno);\n    return bytes;\n}  /* pt_Write */\n\nstatic PRInt32 pt_Writev(\n    PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_len, PRIntervalTime timeout)\n{\n    PRIntn iov_index;\n    PRBool fNeedContinue = PR_FALSE;\n    PRInt32 syserrno, bytes, rv = -1;\n    struct iovec osiov_local[PR_MAX_IOVECTOR_SIZE], *osiov;\n    int osiov_len;\n\n    if (pt_TestAbort()) return rv;\n\n    /* Ensured by PR_Writev */\n    PR_ASSERT(iov_len <= PR_MAX_IOVECTOR_SIZE);\n\n    /*\n     * We can't pass iov to writev because PRIOVec and struct iovec\n     * may not be binary compatible.  Make osiov a copy of iov and\n     * pass osiov to writev.  We can modify osiov if we need to\n     * continue the operation.\n     */\n    osiov = osiov_local;\n    osiov_len = iov_len;\n    for (iov_index = 0; iov_index < osiov_len; iov_index++)\n    {\n        osiov[iov_index].iov_base = iov[iov_index].iov_base;\n        osiov[iov_index].iov_len = iov[iov_index].iov_len;\n    }\n\n    rv = bytes = writev(fd->secret->md.osfd, osiov, osiov_len);\n    syserrno = errno;\n\n    if (!fd->secret->nonblocking)\n    {\n        if (bytes >= 0)\n        {\n            /*\n             * If we moved some bytes, how does that implicate the\n             * i/o vector list?  In other words, exactly where are\n             * we within that array?  What are the parameters for\n             * resumption?  Maybe we're done!\n             */\n            for ( ;osiov_len > 0; osiov++, osiov_len--)\n            {\n                if (bytes < osiov->iov_len)\n                {\n                    /* this one's not done yet */\n                    osiov->iov_base = (char*)osiov->iov_base + bytes;\n                    osiov->iov_len -= bytes;\n                    break;  /* go off and do that */\n                }\n                bytes -= osiov->iov_len;  /* this one's done cooked */\n            }\n            PR_ASSERT(osiov_len > 0 || bytes == 0);\n            if (osiov_len > 0)\n            {\n                if (PR_INTERVAL_NO_WAIT == timeout)\n                {\n                    rv = -1;\n                    syserrno = ETIMEDOUT;\n                }\n                else fNeedContinue = PR_TRUE;\n            }\n        }\n        else if (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        {\n            if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n            else\n            {\n                rv = 0;\n                fNeedContinue = PR_TRUE;\n            }\n        }\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)osiov;\n        op.arg3.amount = osiov_len;\n        op.timeout = timeout;\n        op.result.code = rv;\n        op.function = pt_writev_cont;\n        op.event = POLLOUT | POLLPRI;\n        rv = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (rv == -1) pt_MapError(_PR_MD_MAP_WRITEV_ERROR, syserrno);\n    return rv;\n}  /* pt_Writev */\n\nstatic PRInt32 pt_Seek(PRFileDesc *fd, PRInt32 offset, PRSeekWhence whence)\n{\n    return _PR_MD_LSEEK(fd, offset, whence);\n}  /* pt_Seek */\n\nstatic PRInt64 pt_Seek64(PRFileDesc *fd, PRInt64 offset, PRSeekWhence whence)\n{\n    return _PR_MD_LSEEK64(fd, offset, whence);\n}  /* pt_Seek64 */\n\nstatic PRInt32 pt_Available_f(PRFileDesc *fd)\n{\n    PRInt32 result, cur, end;\n\n    cur = _PR_MD_LSEEK(fd, 0, PR_SEEK_CUR);\n\n    if (cur >= 0)\n        end = _PR_MD_LSEEK(fd, 0, PR_SEEK_END);\n\n    if ((cur < 0) || (end < 0)) {\n        return -1;\n    }\n\n    result = end - cur;\n    _PR_MD_LSEEK(fd, cur, PR_SEEK_SET);\n\n    return result;\n}  /* pt_Available_f */\n\nstatic PRInt64 pt_Available64_f(PRFileDesc *fd)\n{\n    PRInt64 result, cur, end;\n    PRInt64 minus_one;\n\n    LL_I2L(minus_one, -1);\n    cur = _PR_MD_LSEEK64(fd, LL_ZERO, PR_SEEK_CUR);\n\n    if (LL_GE_ZERO(cur))\n        end = _PR_MD_LSEEK64(fd, LL_ZERO, PR_SEEK_END);\n\n    if (!LL_GE_ZERO(cur) || !LL_GE_ZERO(end)) return minus_one;\n\n    LL_SUB(result, end, cur);\n    (void)_PR_MD_LSEEK64(fd, cur, PR_SEEK_SET);\n\n    return result;\n}  /* pt_Available64_f */\n\nstatic PRInt32 pt_Available_s(PRFileDesc *fd)\n{\n    PRInt32 rv, bytes = -1;\n    if (pt_TestAbort()) return bytes;\n\n    rv = ioctl(fd->secret->md.osfd, FIONREAD, &bytes);\n\n    if (rv == -1)\n        pt_MapError(_PR_MD_MAP_SOCKETAVAILABLE_ERROR, errno);\n    return bytes;\n}  /* pt_Available_s */\n\nstatic PRInt64 pt_Available64_s(PRFileDesc *fd)\n{\n    PRInt64 rv;\n    LL_I2L(rv, pt_Available_s(fd));\n    return rv;\n}  /* pt_Available64_s */\n\nstatic PRStatus pt_FileInfo(PRFileDesc *fd, PRFileInfo *info)\n{\n    PRInt32 rv = _PR_MD_GETOPENFILEINFO(fd, info);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_FileInfo */\n\nstatic PRStatus pt_FileInfo64(PRFileDesc *fd, PRFileInfo64 *info)\n{\n    PRInt32 rv = _PR_MD_GETOPENFILEINFO64(fd, info);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_FileInfo64 */\n\nstatic PRStatus pt_Synch(PRFileDesc *fd)\n{\n    return (NULL == fd) ? PR_FAILURE : PR_SUCCESS;\n} /* pt_Synch */\n\nstatic PRStatus pt_Fsync(PRFileDesc *fd)\n{\n    PRIntn rv = -1;\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = fsync(fd->secret->md.osfd);\n    if (rv < 0) {\n        pt_MapError(_PR_MD_MAP_FSYNC_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Fsync */\n\nstatic PRStatus pt_Connect(\n    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRIntn rv = -1, syserrno;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n    addr_len = PR_NETADDR_SIZE(addr);\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    rv = connect(fd->secret->md.osfd, (struct sockaddr*)addrp, addr_len);\n    syserrno = errno;\n    if ((-1 == rv) && (EINPROGRESS == syserrno) && (!fd->secret->nonblocking))\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            pt_Continuation op;\n            op.arg1.osfd = fd->secret->md.osfd;\n            op.arg2.buffer = (void*)addrp;\n            op.arg3.amount = addr_len;\n            op.timeout = timeout;\n            op.function = pt_connect_cont;\n            op.event = POLLOUT | POLLPRI;\n            rv = pt_Continue(&op);\n            syserrno = op.syserrno;\n        }\n    }\n    if (-1 == rv) {\n        pt_MapError(_PR_MD_MAP_CONNECT_ERROR, syserrno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Connect */\n\nstatic PRStatus pt_ConnectContinue(\n    PRFileDesc *fd, PRInt16 out_flags)\n{\n    int err;\n    PRInt32 osfd;\n\n    if (out_flags & PR_POLL_NVAL)\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if ((out_flags & (PR_POLL_WRITE | PR_POLL_EXCEPT | PR_POLL_ERR\n        | PR_POLL_HUP)) == 0)\n    {\n        PR_ASSERT(out_flags == 0);\n        PR_SetError(PR_IN_PROGRESS_ERROR, 0);\n        return PR_FAILURE;\n    }\n\n    osfd = fd->secret->md.osfd;\n\n    err = _MD_unix_get_nonblocking_connect_error(osfd);\n    if (err != 0)\n    {\n        _PR_MD_MAP_CONNECT_ERROR(err);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_ConnectContinue */\n\nPR_IMPLEMENT(PRStatus) PR_GetConnectStatus(const PRPollDesc *pd)\n{\n    /* Find the NSPR layer and invoke its connectcontinue method */\n    PRFileDesc *bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);\n\n    if (NULL == bottom)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n    return pt_ConnectContinue(bottom, pd->out_flags);\n}  /* PR_GetConnectStatus */\n\nstatic PRFileDesc* pt_Accept(\n    PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRFileDesc *newfd = NULL;\n    PRIntn syserrno, osfd = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n#ifdef SYMBIAN\n    PRNetAddr dummy_addr;\n#endif\n\n    if (pt_TestAbort()) return newfd;\n\n#ifdef SYMBIAN\n    /* On Symbian OS, accept crashes if addr is NULL. */\n    if (!addr)\n        addr = &dummy_addr;\n#endif\n\n#ifdef _PR_STRICT_ADDR_LEN\n    if (addr)\n    {\n        /*\n         * Set addr->raw.family just so that we can use the\n         * PR_NETADDR_SIZE macro.\n         */\n        addr->raw.family = fd->secret->af;\n        addr_len = PR_NETADDR_SIZE(addr);\n    }\n#endif\n\n    osfd = accept(fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n    syserrno = errno;\n\n    if (osfd == -1)\n    {\n        if (fd->secret->nonblocking) goto failed;\n\n        if (EWOULDBLOCK != syserrno && EAGAIN != syserrno\n        && ECONNABORTED != syserrno)\n            goto failed;\n        else\n        {\n            if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n            else\n            {\n                pt_Continuation op;\n                op.arg1.osfd = fd->secret->md.osfd;\n                op.arg2.buffer = addr;\n                op.arg3.addr_len = &addr_len;\n                op.timeout = timeout;\n                op.function = pt_accept_cont;\n                op.event = POLLIN | POLLPRI;\n                osfd = pt_Continue(&op);\n                syserrno = op.syserrno;\n            }\n            if (osfd < 0) goto failed;\n        }\n    }\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    /* ignore the sa_len field of struct sockaddr */\n    if (addr)\n    {\n        addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n    }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\tif (addr && (AF_INET6 == addr->raw.family))\n        addr->raw.family = PR_AF_INET6;\n#endif\n    newfd = pt_SetMethods(osfd, PR_DESC_SOCKET_TCP, PR_TRUE, PR_FALSE);\n    if (newfd == NULL) close(osfd);  /* $$$ whoops! this doesn't work $$$ */\n    else\n    {\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n#ifdef LINUX\n        /*\n         * On Linux, experiments showed that the accepted sockets\n         * inherit the TCP_NODELAY socket option of the listening\n         * socket.\n         */\n        newfd->secret->md.tcp_nodelay = fd->secret->md.tcp_nodelay;\n#endif\n    }\n    return newfd;\n\nfailed:\n    pt_MapError(_PR_MD_MAP_ACCEPT_ERROR, syserrno);\n    return NULL;\n}  /* pt_Accept */\n\nstatic PRStatus pt_Bind(PRFileDesc *fd, const PRNetAddr *addr)\n{\n    PRIntn rv;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n    if (addr->raw.family == AF_UNIX)\n    {\n        /* Disallow relative pathnames */\n        if (addr->local.path[0] != '/')\n        {\n            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n            return PR_FAILURE;\n        }\n    }\n\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n    addr_len = PR_NETADDR_SIZE(addr);\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    rv = bind(fd->secret->md.osfd, (struct sockaddr*)addrp, addr_len);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_BIND_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Bind */\n\nstatic PRStatus pt_Listen(PRFileDesc *fd, PRIntn backlog)\n{\n    PRIntn rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = listen(fd->secret->md.osfd, backlog);\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_LISTEN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Listen */\n\nstatic PRStatus pt_Shutdown(PRFileDesc *fd, PRIntn how)\n{\n    PRIntn rv = -1;\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = shutdown(fd->secret->md.osfd, how);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_SHUTDOWN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}  /* pt_Shutdown */\n\nstatic PRInt16 pt_Poll(PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)\n{\n    *out_flags = 0;\n    return in_flags;\n}  /* pt_Poll */\n\nstatic PRInt32 pt_Recv(\n    PRFileDesc *fd, void *buf, PRInt32 amount,\n    PRIntn flags, PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRIntn osflags;\n\n    if (0 == flags)\n        osflags = 0;\n    else if (PR_MSG_PEEK == flags)\n    {\n#ifdef SYMBIAN\n        /* MSG_PEEK doesn't work as expected. */\n        PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n        return bytes;\n#else\n        osflags = MSG_PEEK;\n#endif\n    }\n    else\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return bytes;\n    }\n\n    if (pt_TestAbort()) return bytes;\n\n    /* recv() is a much slower call on pre-2.6 Solaris than read(). */\n#if defined(SOLARIS)\n    if (0 == osflags)\n        bytes = read(fd->secret->md.osfd, buf, amount);\n    else\n        bytes = recv(fd->secret->md.osfd, buf, amount, osflags);\n#else\n    bytes = recv(fd->secret->md.osfd, buf, amount, osflags);\n#endif\n    syserrno = errno;\n\n    if ((bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking))\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            pt_Continuation op;\n            op.arg1.osfd = fd->secret->md.osfd;\n            op.arg2.buffer = buf;\n            op.arg3.amount = amount;\n            op.arg4.flags = osflags;\n            op.timeout = timeout;\n            op.function = pt_recv_cont;\n            op.event = POLLIN | POLLPRI;\n            bytes = pt_Continue(&op);\n            syserrno = op.syserrno;\n        }\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_RECV_ERROR, syserrno);\n    return bytes;\n}  /* pt_Recv */\n\nstatic PRInt32 pt_SocketRead(PRFileDesc *fd, void *buf, PRInt32 amount)\n{\n    return pt_Recv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);\n}  /* pt_SocketRead */\n\nstatic PRInt32 pt_Send(\n    PRFileDesc *fd, const void *buf, PRInt32 amount,\n    PRIntn flags, PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n#if defined(SOLARIS)\n\tPRInt32 tmp_amount = amount;\n#endif\n\n    /*\n     * Under HP-UX DCE threads, pthread.h includes dce/cma_ux.h,\n     * which has the following:\n     *     #  define send        cma_send\n     *     extern int  cma_send (int , void *, int, int );\n     * So we need to cast away the 'const' of argument #2 for send().\n     */\n#if defined (HPUX) && defined(_PR_DCETHREADS)\n#define PT_SENDBUF_CAST (void *)\n#else\n#define PT_SENDBUF_CAST\n#endif\n\n    if (pt_TestAbort()) return bytes;\n\n    /*\n     * On pre-2.6 Solaris, send() is much slower than write().\n     * On 2.6 and beyond, with in-kernel sockets, send() and\n     * write() are fairly equivalent in performance.\n     */\n#if defined(SOLARIS)\n    PR_ASSERT(0 == flags);\nretry:\n    bytes = write(fd->secret->md.osfd, PT_SENDBUF_CAST buf, tmp_amount);\n#else\n    bytes = send(fd->secret->md.osfd, PT_SENDBUF_CAST buf, amount, flags);\n#endif\n    syserrno = errno;\n\n#if defined(SOLARIS)\n    /*\n     * The write system call has been reported to return the ERANGE error\n     * on occasion. Try to write in smaller chunks to workaround this bug.\n     */\n    if ((bytes == -1) && (syserrno == ERANGE))\n    {\n        if (tmp_amount > 1)\n        {\n            tmp_amount = tmp_amount/2;  /* half the bytes */\n            goto retry;\n        }\n    }\n#endif\n\n    if ( (bytes >= 0) && (bytes < amount) && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout)\n        {\n            bytes = -1;\n            syserrno = ETIMEDOUT;\n        }\n        else\n        {\n            buf = (char *) buf + bytes;\n            amount -= bytes;\n            fNeedContinue = PR_TRUE;\n        }\n    }\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else\n        {\n            bytes = 0;\n            fNeedContinue = PR_TRUE;\n        }\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.timeout = timeout;\n        op.result.code = bytes;  /* initialize the number sent */\n        op.function = pt_send_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes == -1)\n        pt_MapError(_PR_MD_MAP_SEND_ERROR, syserrno);\n    return bytes;\n}  /* pt_Send */\n\nstatic PRInt32 pt_SocketWrite(PRFileDesc *fd, const void *buf, PRInt32 amount)\n{\n    return pt_Send(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);\n}  /* pt_SocketWrite */\n\nstatic PRInt32 pt_SendTo(\n    PRFileDesc *fd, const void *buf,\n    PRInt32 amount, PRIntn flags, const PRNetAddr *addr,\n    PRIntervalTime timeout)\n{\n    PRInt32 syserrno, bytes = -1;\n    PRBool fNeedContinue = PR_FALSE;\n    pt_SockLen addr_len;\n\tconst PRNetAddr *addrp = addr;\n#if defined(_PR_HAVE_SOCKADDR_LEN) || defined(_PR_INET6)\n\tPRUint16 md_af = addr->raw.family;\n    PRNetAddr addrCopy;\n#endif\n\n    if (pt_TestAbort()) return bytes;\n\n    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n#if defined(_PR_INET6)\n\tif (addr->raw.family == PR_AF_INET6) {\n\t\tmd_af = AF_INET6;\n#ifndef _PR_HAVE_SOCKADDR_LEN\n\t\taddrCopy = *addr;\n\t\taddrCopy.raw.family = AF_INET6;\n\t\taddrp = &addrCopy;\n#endif\n\t}\n#endif\n\n    addr_len = PR_NETADDR_SIZE(addr);\n#ifdef _PR_HAVE_SOCKADDR_LEN\n    addrCopy = *addr;\n    ((struct sockaddr*)&addrCopy)->sa_len = addr_len;\n    ((struct sockaddr*)&addrCopy)->sa_family = md_af;\n    addrp = &addrCopy;\n#endif\n    bytes = sendto(\n        fd->secret->md.osfd, buf, amount, flags,\n        (struct sockaddr*)addrp, addr_len);\n    syserrno = errno;\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else fNeedContinue = PR_TRUE;\n    }\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = (void*)buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.arg5.addr = (PRNetAddr*)addrp;\n        op.timeout = timeout;\n        op.result.code = 0;  /* initialize the number sent */\n        op.function = pt_sendto_cont;\n        op.event = POLLOUT | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes < 0)\n        pt_MapError(_PR_MD_MAP_SENDTO_ERROR, syserrno);\n    return bytes;\n}  /* pt_SendTo */\n\nstatic PRInt32 pt_RecvFrom(PRFileDesc *fd, void *buf, PRInt32 amount,\n    PRIntn flags, PRNetAddr *addr, PRIntervalTime timeout)\n{\n    PRBool fNeedContinue = PR_FALSE;\n    PRInt32 syserrno, bytes = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return bytes;\n\n    bytes = recvfrom(\n        fd->secret->md.osfd, buf, amount, flags,\n        (struct sockaddr*)addr, &addr_len);\n    syserrno = errno;\n\n    if ( (bytes == -1) && (syserrno == EWOULDBLOCK || syserrno == EAGAIN)\n        && (!fd->secret->nonblocking) )\n    {\n        if (PR_INTERVAL_NO_WAIT == timeout) syserrno = ETIMEDOUT;\n        else fNeedContinue = PR_TRUE;\n    }\n\n    if (fNeedContinue == PR_TRUE)\n    {\n        pt_Continuation op;\n        op.arg1.osfd = fd->secret->md.osfd;\n        op.arg2.buffer = buf;\n        op.arg3.amount = amount;\n        op.arg4.flags = flags;\n        op.arg5.addr = addr;\n        op.timeout = timeout;\n        op.function = pt_recvfrom_cont;\n        op.event = POLLIN | POLLPRI;\n        bytes = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n    if (bytes >= 0)\n    {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n        if (addr && (AF_INET6 == addr->raw.family))\n            addr->raw.family = PR_AF_INET6;\n#endif\n    }\n    else\n        pt_MapError(_PR_MD_MAP_RECVFROM_ERROR, syserrno);\n    return bytes;\n}  /* pt_RecvFrom */\n\n#ifdef AIX\n#ifndef HAVE_SEND_FILE\nstatic pthread_once_t pt_aix_sendfile_once_block = PTHREAD_ONCE_INIT;\n\nstatic void pt_aix_sendfile_init_routine(void)\n{\n    void *handle = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);\n    pt_aix_sendfile_fptr = (ssize_t (*)()) dlsym(handle, \"send_file\");\n    dlclose(handle);\n}\n\n/* \n * pt_AIXDispatchSendFile\n */\nstatic PRInt32 pt_AIXDispatchSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n\t  PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    int rv;\n\n    rv = pthread_once(&pt_aix_sendfile_once_block,\n            pt_aix_sendfile_init_routine);\n    PR_ASSERT(0 == rv);\n    if (pt_aix_sendfile_fptr) {\n        return pt_AIXSendFile(sd, sfd, flags, timeout);\n    } else {\n        return PR_EmulateSendFile(sd, sfd, flags, timeout);\n    }\n}\n#endif /* !HAVE_SEND_FILE */\n\n\n/*\n * pt_AIXSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively. \n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the send_file() system\n *      call available in AIX 4.3.2.\n */\n\nstatic PRInt32 pt_AIXSendFile(PRFileDesc *sd, PRSendFileData *sfd, \n\t\tPRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct sf_parms sf_struct;\n    uint_t send_flags;\n    ssize_t rv;\n    int syserrno;\n    PRInt32 count;\n\tunsigned long long saved_file_offset;\n\tlong long saved_file_bytes;\n\n    sf_struct.header_data = (void *) sfd->header;  /* cast away the 'const' */\n    sf_struct.header_length = sfd->hlen;\n    sf_struct.file_descriptor = sfd->fd->secret->md.osfd;\n    sf_struct.file_size = 0;\n    sf_struct.file_offset = sfd->file_offset;\n    if (sfd->file_nbytes == 0)\n    \tsf_struct.file_bytes = -1;\n\telse\n    \tsf_struct.file_bytes = sfd->file_nbytes;\n    sf_struct.trailer_data = (void *) sfd->trailer;\n    sf_struct.trailer_length = sfd->tlen;\n    sf_struct.bytes_sent = 0;\n\n\tsaved_file_offset = sf_struct.file_offset;\n    saved_file_bytes = sf_struct.file_bytes;\n\n    send_flags = 0;\t\t\t/* flags processed at the end */\n\n    /* The first argument to send_file() is int*. */\n    PR_ASSERT(sizeof(int) == sizeof(sd->secret->md.osfd));\n    do {\n        rv = AIX_SEND_FILE(&sd->secret->md.osfd, &sf_struct, send_flags);\n    } while (rv == -1 && (syserrno = errno) == EINTR);\n\n    if (rv == -1) {\n        if (syserrno == EAGAIN || syserrno == EWOULDBLOCK) {\n            count = 0; /* Not a real error.  Need to continue. */\n        } else {\n            count = -1;\n        }\n    } else {\n        count = sf_struct.bytes_sent;\n\t\t/*\n\t\t * A bug in AIX 4.3.2 prevents the 'file_bytes' field from\n\t\t * being updated. So, 'file_bytes' is maintained by NSPR to\n\t\t * avoid conflict when this bug is fixed in AIX, in the future.\n\t\t */\n\t\tif (saved_file_bytes != -1)\n\t\t\tsaved_file_bytes -= (sf_struct.file_offset - saved_file_offset);\n\t\tsf_struct.file_bytes = saved_file_bytes;\n    }\n\n    if ((rv == 1) || ((rv == -1) && (count == 0))) {\n        pt_Continuation op;\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.arg2.buffer = &sf_struct;\n        op.arg4.flags = send_flags;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_aix_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\n    if (count == -1) {\n        pt_MapError(_MD_aix_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n\tPR_ASSERT(count == (sfd->hlen + sfd->tlen +\n\t\t\t\t\t\t((sfd->file_nbytes ==  0) ?\n\t\t\t\t\t\tsf_struct.file_size - sfd->file_offset :\n\t\t\t\t\t\tsfd->file_nbytes)));\n    return count;\n}\n#endif /* AIX */\n\n#ifdef HPUX11\n/*\n * pt_HPUXSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the sendfile() system\n *      call available in HP-UX B.11.00.\n */\n\nstatic PRInt32 pt_HPUXSendFile(PRFileDesc *sd, PRSendFileData *sfd, \n\t\tPRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t nbytes_to_send, file_nbytes_to_send;\n    struct iovec hdtrl[2];  /* optional header and trailer buffers */\n    int send_flags;\n    PRInt32 count;\n    int syserrno;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n    nbytes_to_send = sfd->hlen + sfd->tlen + file_nbytes_to_send;\n\n    hdtrl[0].iov_base = (void *) sfd->header;  /* cast away the 'const' */\n    hdtrl[0].iov_len = sfd->hlen;\n    hdtrl[1].iov_base = (void *) sfd->trailer;\n    hdtrl[1].iov_len = sfd->tlen;\n    /*\n     * SF_DISCONNECT seems to close the socket even if sendfile()\n     * only does a partial send on a nonblocking socket.  This\n     * would prevent the subsequent sendfile() calls on that socket\n     * from working.  So we don't use the SD_DISCONNECT flag.\n     */\n    send_flags = 0;\n\n    do {\n        count = sendfile(sd->secret->md.osfd, sfd->fd->secret->md.osfd,\n                sfd->file_offset, file_nbytes_to_send, hdtrl, send_flags);\n    } while (count == -1 && (syserrno = errno) == EINTR);\n\n    if (count == -1 && (syserrno == EAGAIN || syserrno == EWOULDBLOCK)) {\n        count = 0;\n    }\n    if (count != -1 && count < nbytes_to_send) {\n        pt_Continuation op;\n\n        if (count < sfd->hlen) {\n\t\t\t/* header not sent */\n\n            hdtrl[0].iov_base = ((char *) sfd->header) + count;\n            hdtrl[0].iov_len = sfd->hlen - count;\n            op.arg3.file_spec.offset = sfd->file_offset;\n            op.arg3.file_spec.nbytes = file_nbytes_to_send;\n        } else if (count < (sfd->hlen + file_nbytes_to_send)) {\n\t\t\t/* header sent, file not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\n            op.arg3.file_spec.offset = sfd->file_offset + count - sfd->hlen;\n            op.arg3.file_spec.nbytes = file_nbytes_to_send - (count - sfd->hlen);\n        } else if (count < (sfd->hlen + file_nbytes_to_send + sfd->tlen)) {\n\t\t\tPRUint32 trailer_nbytes_sent;\n\n\t\t\t/* header sent, file sent, trailer not sent */\n\n            hdtrl[0].iov_base = NULL;\n            hdtrl[0].iov_len = 0;\n\t\t\t/*\n\t\t\t * set file offset and len so that no more file data is\n\t\t\t * sent\n\t\t\t */\n            op.arg3.file_spec.offset = statbuf.st_size;\n            op.arg3.file_spec.nbytes = 0;\n\n\t\t\ttrailer_nbytes_sent = count - sfd->hlen - file_nbytes_to_send;\n            hdtrl[1].iov_base = ((char *) sfd->trailer) + trailer_nbytes_sent;\n            hdtrl[1].iov_len = sfd->tlen - trailer_nbytes_sent;\n\t\t}\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.filedesc = sfd->fd->secret->md.osfd;\n        op.arg2.buffer = hdtrl;\n        op.arg3.file_spec.st_size = statbuf.st_size;\n        op.arg4.flags = send_flags;\n        op.nbytes_to_send = nbytes_to_send - count;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_hpux_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\n    if (count == -1) {\n        pt_MapError(_MD_hpux_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n    PR_ASSERT(count == nbytes_to_send);\n    return count;\n}\n\n#endif  /* HPUX11 */\n\n#ifdef SOLARIS \n\n/*\n *    pt_SolarisSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *\n *    return number of bytes sent or -1 on error\n *\n *    This implementation takes advantage of the sendfilev() system\n *    call available in Solaris 8.\n */\n\nstatic PRInt32 pt_SolarisSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n                PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t nbytes_to_send, file_nbytes_to_send;\t\n    struct sendfilevec sfv_struct[3];  \n    int sfvcnt = 0;\t\n    size_t xferred;\n    PRInt32 count;\n    int syserrno;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n\n    nbytes_to_send = sfd->hlen + sfd->tlen + file_nbytes_to_send;\n\n    if (sfd->hlen != 0) {\n        sfv_struct[sfvcnt].sfv_fd = SFV_FD_SELF;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = (off_t) sfd->header; \n        sfv_struct[sfvcnt].sfv_len = sfd->hlen;\n        sfvcnt++;\n    }\n\n    if (file_nbytes_to_send != 0) {\n        sfv_struct[sfvcnt].sfv_fd = sfd->fd->secret->md.osfd;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = sfd->file_offset;\n        sfv_struct[sfvcnt].sfv_len = file_nbytes_to_send;\n        sfvcnt++;\n    }\n\n    if (sfd->tlen != 0) {\n        sfv_struct[sfvcnt].sfv_fd = SFV_FD_SELF;\n        sfv_struct[sfvcnt].sfv_flag = 0;\n        sfv_struct[sfvcnt].sfv_off = (off_t) sfd->trailer; \n        sfv_struct[sfvcnt].sfv_len = sfd->tlen;\n        sfvcnt++;\n    }\n\n    if (0 == sfvcnt) {\n        count = 0;\n        goto done;\n    }\n   \t   \n    /*\n     * Strictly speaking, we may have sent some bytes when the\n     * sendfilev() is interrupted and we should retry it from an\n     * updated offset.  We are not doing that here.\n     */\n    count = SOLARIS_SENDFILEV(sd->secret->md.osfd, sfv_struct,\n            sfvcnt, &xferred);\n\n    PR_ASSERT((count == -1) || (count == xferred));\n\n    if (count == -1) {\n        syserrno = errno;\n        if (syserrno == EINTR\n                || syserrno == EAGAIN || syserrno == EWOULDBLOCK) {\n            count = xferred;\n        }\n    } else if (count == 0) {\n        /*\n         * We are now at EOF. The file was truncated. Solaris sendfile is\n         * supposed to return 0 and no error in this case, though some versions\n         * may return -1 and EINVAL .\n         */\n        count = -1;\n        syserrno = 0;  /* will be treated as EOF */\n    }\n\n    if (count != -1 && count < nbytes_to_send) {\n        pt_Continuation op;\n        struct sendfilevec *vec = sfv_struct;\n        PRInt32 rem = count;\n\n        while (rem >= vec->sfv_len) {\n            rem -= vec->sfv_len;\n            vec++;\n            sfvcnt--;\n        }\n        PR_ASSERT(sfvcnt > 0);\n\n        vec->sfv_off += rem;\n        vec->sfv_len -= rem;\n        PR_ASSERT(vec->sfv_len > 0);\n\n        op.arg1.osfd = sd->secret->md.osfd;\n        op.arg2.buffer = vec;\n        op.arg3.amount = sfvcnt;\n        op.arg4.flags = 0;\n        op.nbytes_to_send = nbytes_to_send - count;\n        op.result.code = count;\n        op.timeout = timeout;\n        op.function = pt_solaris_sendfile_cont;\n        op.event = POLLOUT | POLLPRI;\n        count = pt_Continue(&op);\n        syserrno = op.syserrno;\n    }\n\ndone:\n    if (count == -1) {\n        pt_MapError(_MD_solaris_map_sendfile_error, syserrno);\n        return -1;\n    }\n    if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n        PR_Close(sd);\n    }\n    PR_ASSERT(count == nbytes_to_send);\n    return count;\n}\n\n#ifndef HAVE_SENDFILEV\nstatic pthread_once_t pt_solaris_sendfilev_once_block = PTHREAD_ONCE_INIT;\n\nstatic void pt_solaris_sendfilev_init_routine(void)\n{\n    void *handle;\n    PRBool close_it = PR_FALSE;\n \n    /*\n     * We do not want to unload libsendfile.so.  This handle is leaked\n     * intentionally.\n     */\n    handle = dlopen(\"libsendfile.so\", RTLD_LAZY | RTLD_GLOBAL);\n    PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n        (\"dlopen(libsendfile.so) returns %p\", handle));\n\n    if (NULL == handle) {\n        /*\n         * The dlopen(0, mode) call is to allow for the possibility that\n         * sendfilev() may become part of a standard system library in a\n         * future Solaris release.\n         */\n        handle = dlopen(0, RTLD_LAZY | RTLD_GLOBAL);\n        PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n            (\"dlopen(0) returns %p\", handle));\n        close_it = PR_TRUE;\n    }\n    pt_solaris_sendfilev_fptr = (ssize_t (*)()) dlsym(handle, \"sendfilev\");\n    PR_LOG(_pr_io_lm, PR_LOG_DEBUG,\n        (\"dlsym(sendfilev) returns %p\", pt_solaris_sendfilev_fptr));\n    \n    if (close_it) {\n        dlclose(handle);\n    }\n}\n\n/* \n * pt_SolarisDispatchSendFile\n */\nstatic PRInt32 pt_SolarisDispatchSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n\t  PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    int rv;\n\n    rv = pthread_once(&pt_solaris_sendfilev_once_block,\n            pt_solaris_sendfilev_init_routine);\n    PR_ASSERT(0 == rv);\n    if (pt_solaris_sendfilev_fptr) {\n        return pt_SolarisSendFile(sd, sfd, flags, timeout);\n    } else {\n        return PR_EmulateSendFile(sd, sfd, flags, timeout);\n    }\n}\n#endif /* !HAVE_SENDFILEV */\n\n#endif  /* SOLARIS */\n\n#ifdef LINUX\n/*\n * pt_LinuxSendFile\n *\n *    Send file sfd->fd across socket sd. If specified, header and trailer\n *    buffers are sent before and after the file, respectively.\n *\n *    PR_TRANSMITFILE_CLOSE_SOCKET flag - close socket after sending file\n *    \n *    return number of bytes sent or -1 on error\n *\n *      This implementation takes advantage of the sendfile() system\n *      call available in Linux kernel 2.2 or higher.\n */\n\nstatic PRInt32 pt_LinuxSendFile(PRFileDesc *sd, PRSendFileData *sfd,\n                PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    struct stat statbuf;\n    size_t file_nbytes_to_send;\t\n    PRInt32 count = 0;\n    ssize_t rv;\n    int syserrno;\n    off_t offset;\n    PRBool tcp_cork_enabled = PR_FALSE;\n    int tcp_cork;\n\n    if (sfd->file_nbytes == 0) {\n        /* Get file size */\n        if (fstat(sfd->fd->secret->md.osfd, &statbuf) == -1) {\n            _PR_MD_MAP_FSTAT_ERROR(errno);\n            return -1;\n        } \t\t\n        file_nbytes_to_send = statbuf.st_size - sfd->file_offset;\n    } else {\n        file_nbytes_to_send = sfd->file_nbytes;\n    }\n\n    if ((sfd->hlen != 0 || sfd->tlen != 0)\n            && sd->secret->md.tcp_nodelay == 0) {\n        tcp_cork = 1;\n        if (setsockopt(sd->secret->md.osfd, SOL_TCP, TCP_CORK,\n                &tcp_cork, sizeof tcp_cork) == 0) {\n            tcp_cork_enabled = PR_TRUE;\n        } else {\n            syserrno = errno;\n            if (syserrno != EINVAL) {\n                _PR_MD_MAP_SETSOCKOPT_ERROR(syserrno);\n                return -1;\n            }\n            /*\n             * The most likely reason for the EINVAL error is that\n             * TCP_NODELAY is set (with a function other than\n             * PR_SetSocketOption).  This is not fatal, so we keep\n             * on going.\n             */\n            PR_LOG(_pr_io_lm, PR_LOG_WARNING,\n                (\"pt_LinuxSendFile: \"\n                \"setsockopt(TCP_CORK) failed with EINVAL\\n\"));\n        }\n    }\n\n    if (sfd->hlen != 0) {\n        count = PR_Send(sd, sfd->header, sfd->hlen, 0, timeout);\n        if (count == -1) {\n            goto failed;\n        }\n    }\n\n    if (file_nbytes_to_send != 0) {\n        offset = sfd->file_offset;\n        do {\n            rv = sendfile(sd->secret->md.osfd, sfd->fd->secret->md.osfd,\n                &offset, file_nbytes_to_send);\n        } while (rv == -1 && (syserrno = errno) == EINTR);\n        if (rv == -1) {\n            if (syserrno != EAGAIN && syserrno != EWOULDBLOCK) {\n                _MD_linux_map_sendfile_error(syserrno);\n                count = -1;\n                goto failed;\n            }\n            rv = 0;\n        }\n        PR_ASSERT(rv == offset - sfd->file_offset);\n        count += rv;\n\n        if (rv < file_nbytes_to_send) {\n            pt_Continuation op;\n\n            op.arg1.osfd = sd->secret->md.osfd;\n            op.in_fd = sfd->fd->secret->md.osfd;\n            op.offset = offset;\n            op.count = file_nbytes_to_send - rv;\n            op.result.code = count;\n            op.timeout = timeout;\n            op.function = pt_linux_sendfile_cont;\n            op.event = POLLOUT | POLLPRI;\n            count = pt_Continue(&op);\n            syserrno = op.syserrno;\n            if (count == -1) {\n                pt_MapError(_MD_linux_map_sendfile_error, syserrno);\n                goto failed;\n            }\n        }\n    }\n\n    if (sfd->tlen != 0) {\n        rv = PR_Send(sd, sfd->trailer, sfd->tlen, 0, timeout);\n        if (rv == -1) {\n            count = -1;\n            goto failed;\n        }\n        count += rv;\n    }\n\nfailed:\n    if (tcp_cork_enabled) {\n        tcp_cork = 0;\n        if (setsockopt(sd->secret->md.osfd, SOL_TCP, TCP_CORK,\n                &tcp_cork, sizeof tcp_cork) == -1 && count != -1) {\n            _PR_MD_MAP_SETSOCKOPT_ERROR(errno);\n            count = -1;\n        }\n    }\n    if (count != -1) {\n        if (flags & PR_TRANSMITFILE_CLOSE_SOCKET) {\n            PR_Close(sd);\n        }\n        PR_ASSERT(count == sfd->hlen + sfd->tlen + file_nbytes_to_send);\n    }\n    return count;\n}\n#endif  /* LINUX */\n\n#ifdef AIX\nextern\tint _pr_aix_send_file_use_disabled;\n#endif\n\nstatic PRInt32 pt_SendFile(\n    PRFileDesc *sd, PRSendFileData *sfd,\n    PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n    if (pt_TestAbort()) return -1;\n    /* The socket must be in blocking mode. */\n    if (sd->secret->nonblocking)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return -1;\n    }\n#ifdef HPUX11\n    return(pt_HPUXSendFile(sd, sfd, flags, timeout));\n#elif defined(AIX)\n#ifdef HAVE_SEND_FILE\n\t/*\n\t * A bug in AIX 4.3.2 results in corruption of data transferred by\n\t * send_file(); AIX patch PTF U463956 contains the fix.  A user can\n\t * disable the use of send_file function in NSPR, when this patch is\n\t * not installed on the system, by setting the envionment variable\n\t * NSPR_AIX_SEND_FILE_USE_DISABLED to 1.\n\t */\n\tif (_pr_aix_send_file_use_disabled)\n\t\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n\telse\n    \treturn(pt_AIXSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n    /* return(pt_AIXDispatchSendFile(sd, sfd, flags, timeout));*/\n#endif /* HAVE_SEND_FILE */\n#elif defined(SOLARIS)\n#ifdef HAVE_SENDFILEV\n    \treturn(pt_SolarisSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(pt_SolarisDispatchSendFile(sd, sfd, flags, timeout));\n#endif /* HAVE_SENDFILEV */\n#elif defined(LINUX)\n    \treturn(pt_LinuxSendFile(sd, sfd, flags, timeout));\n#else\n\treturn(PR_EmulateSendFile(sd, sfd, flags, timeout));\n#endif\n}\n\nstatic PRInt32 pt_TransmitFile(\n    PRFileDesc *sd, PRFileDesc *fd, const void *headers,\n    PRInt32 hlen, PRTransmitFileFlags flags, PRIntervalTime timeout)\n{\n\tPRSendFileData sfd;\n\n\tsfd.fd = fd;\n\tsfd.file_offset = 0;\n\tsfd.file_nbytes = 0;\n\tsfd.header = headers;\n\tsfd.hlen = hlen;\n\tsfd.trailer = NULL;\n\tsfd.tlen = 0;\n\n\treturn(pt_SendFile(sd, &sfd, flags, timeout));\n}  /* pt_TransmitFile */\n\nstatic PRInt32 pt_AcceptRead(\n    PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr,\n    void *buf, PRInt32 amount, PRIntervalTime timeout)\n{\n    PRInt32 rv = -1;\n\n    if (pt_TestAbort()) return rv;\n    /* The socket must be in blocking mode. */\n    if (sd->secret->nonblocking)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return rv;\n    }\n\n    rv = PR_EmulateAcceptRead(sd, nd, raddr, buf, amount, timeout);\n    return rv;\n}  /* pt_AcceptRead */\n\nstatic PRStatus pt_GetSockName(PRFileDesc *fd, PRNetAddr *addr)\n{\n    PRIntn rv = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = getsockname(\n        fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_GETSOCKNAME_ERROR, errno);\n        return PR_FAILURE;\n    } else {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\t\tif (AF_INET6 == addr->raw.family)\n\t\t\taddr->raw.family = PR_AF_INET6;\n#endif\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n        return PR_SUCCESS;\n    }\n}  /* pt_GetSockName */\n\nstatic PRStatus pt_GetPeerName(PRFileDesc *fd, PRNetAddr *addr)\n{\n    PRIntn rv = -1;\n    pt_SockLen addr_len = sizeof(PRNetAddr);\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = getpeername(\n        fd->secret->md.osfd, (struct sockaddr*)addr, &addr_len);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_GETPEERNAME_ERROR, errno);\n        return PR_FAILURE;\n    } else {\n#ifdef _PR_HAVE_SOCKADDR_LEN\n        /* ignore the sa_len field of struct sockaddr */\n        if (addr)\n        {\n            addr->raw.family = ((struct sockaddr*)addr)->sa_family;\n        }\n#endif /* _PR_HAVE_SOCKADDR_LEN */\n#ifdef _PR_INET6\n\t\tif (AF_INET6 == addr->raw.family)\n        \taddr->raw.family = PR_AF_INET6;\n#endif\n        PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);\n        PR_ASSERT(IsValidNetAddrLen(addr, addr_len) == PR_TRUE);\n        return PR_SUCCESS;\n    }\n}  /* pt_GetPeerName */\n\nstatic PRStatus pt_GetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)\n{\n    PRIntn rv;\n    pt_SockLen length;\n    PRInt32 level, name;\n\n    /*\n     * PR_SockOpt_Nonblocking is a special case that does not\n     * translate to a getsockopt() call\n     */\n    if (PR_SockOpt_Nonblocking == data->option)\n    {\n        data->value.non_blocking = fd->secret->nonblocking;\n        return PR_SUCCESS;\n    }\n\n    rv = _PR_MapOptionName(data->option, &level, &name);\n    if (PR_SUCCESS == rv)\n    {\n        switch (data->option)\n        {\n            case PR_SockOpt_Linger:\n            {\n                struct linger linger;\n                length = sizeof(linger);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char *) &linger, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(linger) == length));\n                data->value.linger.polarity =\n                    (linger.l_onoff) ? PR_TRUE : PR_FALSE;\n                data->value.linger.linger =\n                    PR_SecondsToInterval(linger.l_linger);\n                break;\n            }\n            case PR_SockOpt_Reuseaddr:\n            case PR_SockOpt_Keepalive:\n            case PR_SockOpt_NoDelay:\n            case PR_SockOpt_Broadcast:\n            case PR_SockOpt_Reuseport:\n            {\n                PRIntn value;\n                length = sizeof(PRIntn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&value, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                data->value.reuse_addr = (0 == value) ? PR_FALSE : PR_TRUE;\n                break;\n            }\n            case PR_SockOpt_McastLoopback:\n            {\n                PRUint8 xbool;\n                length = sizeof(xbool);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&xbool, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(xbool) == length));\n                data->value.mcast_loopback = (0 == xbool) ? PR_FALSE : PR_TRUE;\n                break;\n            }\n            case PR_SockOpt_RecvBufferSize:\n            case PR_SockOpt_SendBufferSize:\n            case PR_SockOpt_MaxSegment:\n            {\n                PRIntn value;\n                length = sizeof(PRIntn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&value, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                data->value.recv_buffer_size = value;\n                break;\n            }\n            case PR_SockOpt_IpTimeToLive:\n            case PR_SockOpt_IpTypeOfService:\n            {\n                length = sizeof(PRUintn);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.ip_ttl, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(PRIntn) == length));\n                break;\n            }\n            case PR_SockOpt_McastTimeToLive:\n            {\n                PRUint8 ttl;\n                length = sizeof(ttl);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&ttl, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(ttl) == length));\n                data->value.mcast_ttl = ttl;\n                break;\n            }\n            case PR_SockOpt_AddMember:\n            case PR_SockOpt_DropMember:\n            {\n                struct ip_mreq mreq;\n                length = sizeof(mreq);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&mreq, &length);\n                PR_ASSERT((-1 == rv) || (sizeof(mreq) == length));\n                data->value.add_member.mcaddr.inet.ip =\n                    mreq.imr_multiaddr.s_addr;\n                data->value.add_member.ifaddr.inet.ip =\n                    mreq.imr_interface.s_addr;\n                break;\n            }\n            case PR_SockOpt_McastInterface:\n            {\n                length = sizeof(data->value.mcast_if.inet.ip);\n                rv = getsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.mcast_if.inet.ip, &length);\n                PR_ASSERT((-1 == rv)\n                    || (sizeof(data->value.mcast_if.inet.ip) == length));\n                break;\n            }\n            default:\n                PR_NOT_REACHED(\"Unknown socket option\");\n                break;\n        }\n        if (-1 == rv) _PR_MD_MAP_GETSOCKOPT_ERROR(errno);\n    }\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_GetSocketOption */\n\nstatic PRStatus pt_SetSocketOption(PRFileDesc *fd, const PRSocketOptionData *data)\n{\n    PRIntn rv;\n    PRInt32 level, name;\n\n    /*\n     * PR_SockOpt_Nonblocking is a special case that does not\n     * translate to a setsockopt call.\n     */\n    if (PR_SockOpt_Nonblocking == data->option)\n    {\n        fd->secret->nonblocking = data->value.non_blocking;\n        return PR_SUCCESS;\n    }\n\n    rv = _PR_MapOptionName(data->option, &level, &name);\n    if (PR_SUCCESS == rv)\n    {\n        switch (data->option)\n        {\n            case PR_SockOpt_Linger:\n            {\n                struct linger linger;\n                linger.l_onoff = data->value.linger.polarity;\n                linger.l_linger = PR_IntervalToSeconds(data->value.linger.linger);\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name, (char*)&linger, sizeof(linger));\n                break;\n            }\n            case PR_SockOpt_Reuseaddr:\n            case PR_SockOpt_Keepalive:\n            case PR_SockOpt_NoDelay:\n            case PR_SockOpt_Broadcast:\n            case PR_SockOpt_Reuseport:\n            {\n                PRIntn value = (data->value.reuse_addr) ? 1 : 0;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&value, sizeof(PRIntn));\n#ifdef LINUX\n                /* for pt_LinuxSendFile */\n                if (name == TCP_NODELAY && rv == 0) {\n                    fd->secret->md.tcp_nodelay = value;\n                }\n#endif\n                break;\n            }\n            case PR_SockOpt_McastLoopback:\n            {\n                PRUint8 xbool = data->value.mcast_loopback ? 1 : 0;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&xbool, sizeof(xbool));\n                break;\n            }\n            case PR_SockOpt_RecvBufferSize:\n            case PR_SockOpt_SendBufferSize:\n            case PR_SockOpt_MaxSegment:\n            {\n                PRIntn value = data->value.recv_buffer_size;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&value, sizeof(PRIntn));\n                break;\n            }\n            case PR_SockOpt_IpTimeToLive:\n            case PR_SockOpt_IpTypeOfService:\n            {\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.ip_ttl, sizeof(PRUintn));\n                break;\n            }\n            case PR_SockOpt_McastTimeToLive:\n            {\n                PRUint8 ttl = data->value.mcast_ttl;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&ttl, sizeof(ttl));\n                break;\n            }\n            case PR_SockOpt_AddMember:\n            case PR_SockOpt_DropMember:\n            {\n                struct ip_mreq mreq;\n                mreq.imr_multiaddr.s_addr =\n                    data->value.add_member.mcaddr.inet.ip;\n                mreq.imr_interface.s_addr =\n                    data->value.add_member.ifaddr.inet.ip;\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&mreq, sizeof(mreq));\n                break;\n            }\n            case PR_SockOpt_McastInterface:\n            {\n                rv = setsockopt(\n                    fd->secret->md.osfd, level, name,\n                    (char*)&data->value.mcast_if.inet.ip,\n                    sizeof(data->value.mcast_if.inet.ip));\n                break;\n            }\n            default:\n                PR_NOT_REACHED(\"Unknown socket option\");\n                break;\n        }\n        if (-1 == rv) _PR_MD_MAP_SETSOCKOPT_ERROR(errno);\n    }\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* pt_SetSocketOption */\n\n/*****************************************************************************/\n/****************************** I/O method objects ***************************/\n/*****************************************************************************/\n\nstatic PRIOMethods _pr_file_methods = {\n    PR_DESC_FILE,\n    pt_Close,\n    pt_Read,\n    pt_Write,\n    pt_Available_f,\n    pt_Available64_f,\n    pt_Fsync,\n    pt_Seek,\n    pt_Seek64,\n    pt_FileInfo,\n    pt_FileInfo64,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_pipe_methods = {\n    PR_DESC_PIPE,\n    pt_Close,\n    pt_Read,\n    pt_Write,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_tcp_methods = {\n    PR_DESC_SOCKET_TCP,\n    pt_Close,\n    pt_SocketRead,\n    pt_SocketWrite,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    pt_Writev,\n    pt_Connect,\n    pt_Accept,\n    pt_Bind,\n    pt_Listen,\n    pt_Shutdown,\n    pt_Recv,\n    pt_Send,\n    (PRRecvfromFN)_PR_InvalidInt,\n    (PRSendtoFN)_PR_InvalidInt,\n    pt_Poll,\n    pt_AcceptRead,\n    pt_TransmitFile,\n    pt_GetSockName,\n    pt_GetPeerName,\n    (PRReservedFN)_PR_InvalidInt,\n    (PRReservedFN)_PR_InvalidInt,\n    pt_GetSocketOption,\n    pt_SetSocketOption,\n    pt_SendFile, \n    pt_ConnectContinue,\n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_udp_methods = {\n    PR_DESC_SOCKET_UDP,\n    pt_Close,\n    pt_SocketRead,\n    pt_SocketWrite,\n    pt_Available_s,\n    pt_Available64_s,\n    pt_Synch,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    pt_Writev,\n    pt_Connect,\n    (PRAcceptFN)_PR_InvalidDesc,\n    pt_Bind,\n    pt_Listen,\n    pt_Shutdown,\n    pt_Recv,\n    pt_Send,\n    pt_RecvFrom,\n    pt_SendTo,\n    pt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,\n    (PRTransmitfileFN)_PR_InvalidInt,\n    pt_GetSockName,\n    pt_GetPeerName,\n    (PRReservedFN)_PR_InvalidInt,\n    (PRReservedFN)_PR_InvalidInt,\n    pt_GetSocketOption,\n    pt_SetSocketOption,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\nstatic PRIOMethods _pr_socketpollfd_methods = {\n    (PRDescType) 0,\n    (PRCloseFN)_PR_InvalidStatus,\n    (PRReadFN)_PR_InvalidInt,\n    (PRWriteFN)_PR_InvalidInt,\n    (PRAvailableFN)_PR_InvalidInt,\n    (PRAvailable64FN)_PR_InvalidInt64,\n    (PRFsyncFN)_PR_InvalidStatus,\n    (PRSeekFN)_PR_InvalidInt,\n    (PRSeek64FN)_PR_InvalidInt64,\n    (PRFileInfoFN)_PR_InvalidStatus,\n    (PRFileInfo64FN)_PR_InvalidStatus,\n    (PRWritevFN)_PR_InvalidInt,        \n    (PRConnectFN)_PR_InvalidStatus,        \n    (PRAcceptFN)_PR_InvalidDesc,        \n    (PRBindFN)_PR_InvalidStatus,        \n    (PRListenFN)_PR_InvalidStatus,        \n    (PRShutdownFN)_PR_InvalidStatus,    \n    (PRRecvFN)_PR_InvalidInt,        \n    (PRSendFN)_PR_InvalidInt,        \n    (PRRecvfromFN)_PR_InvalidInt,    \n    (PRSendtoFN)_PR_InvalidInt,        \n\tpt_Poll,\n    (PRAcceptreadFN)_PR_InvalidInt,   \n    (PRTransmitfileFN)_PR_InvalidInt, \n    (PRGetsocknameFN)_PR_InvalidStatus,    \n    (PRGetpeernameFN)_PR_InvalidStatus,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRReservedFN)_PR_InvalidInt,    \n    (PRGetsocketoptionFN)_PR_InvalidStatus,\n    (PRSetsocketoptionFN)_PR_InvalidStatus,\n    (PRSendfileFN)_PR_InvalidInt, \n    (PRConnectcontinueFN)_PR_InvalidStatus, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt, \n    (PRReservedFN)_PR_InvalidInt\n};\n\n#if defined(HPUX) || defined(OSF1) || defined(SOLARIS) || defined (IRIX) \\\n    || defined(LINUX) || defined(__GNU__) || defined(__GLIBC__) \\\n    || defined(AIX) || defined(FREEBSD) || defined(NETBSD) \\\n    || defined(OPENBSD) || defined(BSDI) || defined(NTO) \\\n    || defined(DARWIN) || defined(UNIXWARE) || defined(RISCOS) \\\n    || defined(SYMBIAN)\n#define _PR_FCNTL_FLAGS O_NONBLOCK\n#else\n#error \"Can't determine architecture\"\n#endif\n\n/*\n * Put a Unix file descriptor in non-blocking mode.\n */\nstatic void pt_MakeFdNonblock(PRIntn osfd)\n{\n    PRIntn flags;\n    flags = fcntl(osfd, F_GETFL, 0);\n    flags |= _PR_FCNTL_FLAGS;\n    (void)fcntl(osfd, F_SETFL, flags);\n}\n\n/*\n * Put a Unix socket fd in non-blocking mode that can\n * ideally be inherited by an accepted socket.\n *\n * Why doesn't pt_MakeFdNonblock do?  This is to deal with\n * the special case of HP-UX.  HP-UX has three kinds of\n * non-blocking modes for sockets: the fcntl() O_NONBLOCK\n * and O_NDELAY flags and ioctl() FIOSNBIO request.  Only\n * the ioctl() FIOSNBIO form of non-blocking mode is\n * inherited by an accepted socket.\n *\n * Other platforms just use the generic pt_MakeFdNonblock\n * to put a socket in non-blocking mode.\n */\n#ifdef HPUX\nstatic void pt_MakeSocketNonblock(PRIntn osfd)\n{\n    PRIntn one = 1;\n    (void)ioctl(osfd, FIOSNBIO, &one);\n}\n#else\n#define pt_MakeSocketNonblock pt_MakeFdNonblock\n#endif\n\nstatic PRFileDesc *pt_SetMethods(\n    PRIntn osfd, PRDescType type, PRBool isAcceptedSocket, PRBool imported)\n{\n    PRFileDesc *fd = _PR_Getfd();\n    \n    if (fd == NULL) PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    else\n    {\n        fd->secret->md.osfd = osfd;\n        fd->secret->state = _PR_FILEDESC_OPEN;\n        if (imported) fd->secret->inheritable = _PR_TRI_UNKNOWN;\n        else\n        {\n            /* By default, a Unix fd is not closed on exec. */\n#ifdef DEBUG\n            PRIntn flags;\n            flags = fcntl(osfd, F_GETFD, 0);\n            PR_ASSERT(0 == flags);\n#endif\n            fd->secret->inheritable = _PR_TRI_TRUE;\n        }\n        switch (type)\n        {\n            case PR_DESC_FILE:\n                fd->methods = PR_GetFileMethods();\n                break;\n            case PR_DESC_SOCKET_TCP:\n                fd->methods = PR_GetTCPMethods();\n#ifdef _PR_ACCEPT_INHERIT_NONBLOCK\n                if (!isAcceptedSocket) pt_MakeSocketNonblock(osfd);\n#else\n                pt_MakeSocketNonblock(osfd);\n#endif\n                break;\n            case PR_DESC_SOCKET_UDP:\n                fd->methods = PR_GetUDPMethods();\n                pt_MakeFdNonblock(osfd);\n                break;\n            case PR_DESC_PIPE:\n                fd->methods = PR_GetPipeMethods();\n                pt_MakeFdNonblock(osfd);\n                break;\n            default:\n                break;\n        }\n    }\n    return fd;\n}  /* pt_SetMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetFileMethods(void)\n{\n    return &_pr_file_methods;\n}  /* PR_GetFileMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetPipeMethods(void)\n{\n    return &_pr_pipe_methods;\n}  /* PR_GetPipeMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetTCPMethods(void)\n{\n    return &_pr_tcp_methods;\n}  /* PR_GetTCPMethods */\n\nPR_IMPLEMENT(const PRIOMethods*) PR_GetUDPMethods(void)\n{\n    return &_pr_udp_methods;\n}  /* PR_GetUDPMethods */\n\nstatic const PRIOMethods* PR_GetSocketPollFdMethods(void)\n{\n    return &_pr_socketpollfd_methods;\n}  /* PR_GetSocketPollFdMethods */\n\nPR_IMPLEMENT(PRFileDesc*) PR_AllocFileDesc(\n    PRInt32 osfd, const PRIOMethods *methods)\n{\n    PRFileDesc *fd = _PR_Getfd();\n\n    if (NULL == fd) goto failed;\n\n    fd->methods = methods;\n    fd->secret->md.osfd = osfd;\n    /* Make fd non-blocking */\n    if (osfd > 2)\n    {\n        /* Don't mess around with stdin, stdout or stderr */\n        if (&_pr_tcp_methods == methods) pt_MakeSocketNonblock(osfd);\n        else pt_MakeFdNonblock(osfd);\n    }\n    fd->secret->state = _PR_FILEDESC_OPEN;\n    fd->secret->inheritable = _PR_TRI_UNKNOWN;\n    return fd;\n    \nfailed:\n    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    return fd;\n}  /* PR_AllocFileDesc */\n\n#if !defined(_PR_INET6) || defined(_PR_INET6_PROBE)\nPR_EXTERN(PRStatus) _pr_push_ipv6toipv4_layer(PRFileDesc *fd);\n#if defined(_PR_INET6_PROBE)\nextern PRBool _pr_ipv6_is_present(void);\nPR_IMPLEMENT(PRBool) _pr_test_ipv6_socket()\n{\n    int osfd;\n\n#if defined(DARWIN)\n    /*\n     * Disable IPv6 if Darwin version is less than 7.0.0 (OS X 10.3).  IPv6 on\n     * lesser versions is not ready for general use (see bug 222031).\n     */\n    {\n        struct utsname u;\n        if (uname(&u) != 0 || atoi(u.release) < 7)\n            return PR_FALSE;\n    }\n#endif\n\n    /*\n     * HP-UX only: HP-UX IPv6 Porting Guide (dated February 2001)\n     * suggests that we call open(\"/dev/ip6\", O_RDWR) to determine\n     * whether IPv6 APIs and the IPv6 stack are on the system.\n     * Our portable test below seems to work fine, so I am using it.\n     */\n    osfd = socket(AF_INET6, SOCK_STREAM, 0);\n    if (osfd != -1) {\n        close(osfd);\n        return PR_TRUE;\n    }\n    return PR_FALSE;\n}\n#endif\t/* _PR_INET6_PROBE */\n#endif\n\nPR_IMPLEMENT(PRFileDesc*) PR_Socket(PRInt32 domain, PRInt32 type, PRInt32 proto)\n{\n    PRIntn osfd;\n    PRDescType ftype;\n    PRFileDesc *fd = NULL;\n#if defined(_PR_INET6_PROBE) || !defined(_PR_INET6)\n    PRInt32 tmp_domain = domain;\n#endif\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return NULL;\n\n    if (PF_INET != domain\n        && PR_AF_INET6 != domain\n#if defined(_PR_HAVE_SDP)\n        && PR_AF_INET_SDP != domain\n#if defined(SOLARIS)\n        && PR_AF_INET6_SDP != domain\n#endif /* SOLARIS */\n#endif /* _PR_HAVE_SDP */\n        && PF_UNIX != domain)\n    {\n        PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);\n        return fd;\n    }\n\tif (type == SOCK_STREAM) ftype = PR_DESC_SOCKET_TCP;\n\telse if (type == SOCK_DGRAM) ftype = PR_DESC_SOCKET_UDP;\n\telse\n\t{\n\t\t(void)PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);\n\t\treturn fd;\n\t}\n#if defined(_PR_HAVE_SDP)\n#if defined(LINUX)\n    if (PR_AF_INET_SDP == domain)\n        domain = AF_INET_SDP;\n#elif defined(SOLARIS)\n    if (PR_AF_INET_SDP == domain) {\n        domain = AF_INET;\n        proto = PROTO_SDP;\n    } else if(PR_AF_INET6_SDP == domain) {\n        domain = AF_INET6;\n        proto = PROTO_SDP;\n    }\n#endif /* SOLARIS */\n#endif /* _PR_HAVE_SDP */\n#if defined(_PR_INET6_PROBE)\n\tif (PR_AF_INET6 == domain)\n\t\tdomain = _pr_ipv6_is_present() ? AF_INET6 : AF_INET;\n#elif defined(_PR_INET6) \n\tif (PR_AF_INET6 == domain)\n\t\tdomain = AF_INET6;\n#else\n\tif (PR_AF_INET6 == domain)\n\t\tdomain = AF_INET;\n#endif\n\n    osfd = socket(domain, type, proto);\n    if (osfd == -1) pt_MapError(_PR_MD_MAP_SOCKET_ERROR, errno);\n    else\n    {\n#ifdef _PR_IPV6_V6ONLY_PROBE\n        if ((domain == AF_INET6) && _pr_ipv6_v6only_on_by_default)\n        {\n            int on = 0;\n            (void)setsockopt(osfd, IPPROTO_IPV6, IPV6_V6ONLY,\n                    &on, sizeof(on));\n        }\n#endif\n        fd = pt_SetMethods(osfd, ftype, PR_FALSE, PR_FALSE);\n        if (fd == NULL) close(osfd);\n    }\n#ifdef _PR_NEED_SECRET_AF\n    if (fd != NULL) fd->secret->af = domain;\n#endif\n#if defined(_PR_INET6_PROBE) || !defined(_PR_INET6)\n\tif (fd != NULL) {\n\t\t/*\n\t\t * For platforms with no support for IPv6 \n\t\t * create layered socket for IPv4-mapped IPv6 addresses\n\t\t */\n\t\tif (PR_AF_INET6 == tmp_domain && PR_AF_INET == domain) {\n\t\t\tif (PR_FAILURE == _pr_push_ipv6toipv4_layer(fd)) {\n\t\t\t\tPR_Close(fd);\n\t\t\t\tfd = NULL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n    return fd;\n}  /* PR_Socket */\n\n/*****************************************************************************/\n/****************************** I/O public methods ***************************/\n/*****************************************************************************/\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenFile(\n    const char *name, PRIntn flags, PRIntn mode)\n{\n    PRFileDesc *fd = NULL;\n    PRIntn syserrno, osfd = -1, osflags = 0;;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return NULL;\n\n    if (flags & PR_RDONLY) osflags |= O_RDONLY;\n    if (flags & PR_WRONLY) osflags |= O_WRONLY;\n    if (flags & PR_RDWR) osflags |= O_RDWR;\n    if (flags & PR_APPEND) osflags |= O_APPEND;\n    if (flags & PR_TRUNCATE) osflags |= O_TRUNC;\n    if (flags & PR_EXCL) osflags |= O_EXCL;\n    if (flags & PR_SYNC)\n    {\n#if defined(O_SYNC)\n        osflags |= O_SYNC;\n#elif defined(O_FSYNC)\n        osflags |= O_FSYNC;\n#else\n#error \"Neither O_SYNC nor O_FSYNC is defined on this platform\"\n#endif\n    }\n\n    /*\n    ** We have to hold the lock across the creation in order to\n    ** enforce the sematics of PR_Rename(). (see the latter for\n    ** more details)\n    */\n    if (flags & PR_CREATE_FILE)\n    {\n        osflags |= O_CREAT;\n        if (NULL !=_pr_rename_lock)\n            PR_Lock(_pr_rename_lock);\n    }\n\n    osfd = _md_iovector._open64(name, osflags, mode);\n    syserrno = errno;\n\n    if ((flags & PR_CREATE_FILE) && (NULL !=_pr_rename_lock))\n        PR_Unlock(_pr_rename_lock);\n\n    if (osfd == -1)\n        pt_MapError(_PR_MD_MAP_OPEN_ERROR, syserrno);\n    else\n    {\n        fd = pt_SetMethods(osfd, PR_DESC_FILE, PR_FALSE, PR_FALSE);\n        if (fd == NULL) close(osfd);  /* $$$ whoops! this is bad $$$ */\n    }\n    return fd;\n}  /* PR_OpenFile */\n\nPR_IMPLEMENT(PRFileDesc*) PR_Open(const char *name, PRIntn flags, PRIntn mode)\n{\n    return PR_OpenFile(name, flags, mode);\n}  /* PR_Open */\n\nPR_IMPLEMENT(PRStatus) PR_Delete(const char *name)\n{\n    PRIntn rv = -1;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = unlink(name);\n\n    if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_UNLINK_ERROR, errno);\n        return PR_FAILURE;\n    } else\n        return PR_SUCCESS;\n}  /* PR_Delete */\n\nPR_IMPLEMENT(PRStatus) PR_Access(const char *name, PRAccessHow how)\n{\n    PRIntn rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    switch (how)\n    {\n    case PR_ACCESS_READ_OK:\n        rv =  access(name, R_OK);\n        break;\n    case PR_ACCESS_WRITE_OK:\n        rv = access(name, W_OK);\n        break;\n    case PR_ACCESS_EXISTS:\n    default:\n        rv = access(name, F_OK);\n    }\n    if (0 == rv) return PR_SUCCESS;\n    pt_MapError(_PR_MD_MAP_ACCESS_ERROR, errno);\n    return PR_FAILURE;\n    \n}  /* PR_Access */\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo(const char *fn, PRFileInfo *info)\n{\n    PRInt32 rv = _PR_MD_GETFILEINFO(fn, info);\n    return (0 == rv) ? PR_SUCCESS : PR_FAILURE;\n}  /* PR_GetFileInfo */\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo64(const char *fn, PRFileInfo64 *info)\n{\n    PRInt32 rv;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    rv = _PR_MD_GETFILEINFO64(fn, info);\n    return (0 == rv) ? PR_SUCCESS : PR_FAILURE;\n}  /* PR_GetFileInfo64 */\n\nPR_IMPLEMENT(PRStatus) PR_Rename(const char *from, const char *to)\n{\n    PRIntn rv = -1;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    /*\n    ** We have to acquire a lock here to stiffle anybody trying to create\n    ** a new file at the same time. And we have to hold that lock while we\n    ** test to see if the file exists and do the rename. The other place\n    ** where the lock is held is in PR_Open() when possibly creating a \n    ** new file.\n    */\n\n    PR_Lock(_pr_rename_lock);\n    rv = access(to, F_OK);\n    if (0 == rv)\n    {\n        PR_SetError(PR_FILE_EXISTS_ERROR, 0);\n        rv = -1;\n    }\n    else\n    {\n        rv = rename(from, to);\n        if (rv == -1)\n            pt_MapError(_PR_MD_MAP_RENAME_ERROR, errno);\n    }\n    PR_Unlock(_pr_rename_lock);\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* PR_Rename */\n\nPR_IMPLEMENT(PRStatus) PR_CloseDir(PRDir *dir)\n{\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (NULL != dir->md.d)\n    {\n        if (closedir(dir->md.d) == -1)\n        {\n            _PR_MD_MAP_CLOSEDIR_ERROR(errno);\n            return PR_FAILURE;\n        }\n        dir->md.d = NULL;\n        PR_DELETE(dir);\n    }\n    return PR_SUCCESS;\n}  /* PR_CloseDir */\n\nPR_IMPLEMENT(PRStatus) PR_MakeDir(const char *name, PRIntn mode)\n{\n    PRInt32 rv = -1;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    /*\n    ** This lock is used to enforce rename semantics as described\n    ** in PR_Rename.\n    */\n    if (NULL !=_pr_rename_lock)\n        PR_Lock(_pr_rename_lock);\n    rv = mkdir(name, mode);\n    if (-1 == rv)\n        pt_MapError(_PR_MD_MAP_MKDIR_ERROR, errno);\n    if (NULL !=_pr_rename_lock)\n        PR_Unlock(_pr_rename_lock);\n\n    return (-1 == rv) ? PR_FAILURE : PR_SUCCESS;\n}  /* PR_Makedir */\n\nPR_IMPLEMENT(PRStatus) PR_MkDir(const char *name, PRIntn mode)\n{\n    return PR_MakeDir(name, mode);\n}  /* PR_Mkdir */\n\nPR_IMPLEMENT(PRStatus) PR_RmDir(const char *name)\n{\n    PRInt32 rv;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    rv = rmdir(name);\n    if (0 == rv) {\n    return PR_SUCCESS;\n    } else {\n    pt_MapError(_PR_MD_MAP_RMDIR_ERROR, errno);\n    return PR_FAILURE;\n    }\n}  /* PR_Rmdir */\n\n\nPR_IMPLEMENT(PRDir*) PR_OpenDir(const char *name)\n{\n    DIR *osdir;\n    PRDir *dir = NULL;\n\n    if (pt_TestAbort()) return dir;\n\n    osdir = opendir(name);\n    if (osdir == NULL)\n        pt_MapError(_PR_MD_MAP_OPENDIR_ERROR, errno);\n    else\n    {\n        dir = PR_NEWZAP(PRDir);\n        if (dir)\n            dir->md.d = osdir;\n        else\n            (void)closedir(osdir);\n    }\n    return dir;\n}  /* PR_OpenDir */\n\nstatic PRInt32 _pr_poll_with_poll(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n    PRInt32 ready = 0;\n    /*\n     * For restarting poll() if it is interrupted by a signal.\n     * We use these variables to figure out how much time has\n     * elapsed and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    if (pt_TestAbort()) return -1;\n\n    if (0 == npds) PR_Sleep(timeout);\n    else\n    {\n#define STACK_POLL_DESC_COUNT 64\n        struct pollfd stack_syspoll[STACK_POLL_DESC_COUNT];\n        struct pollfd *syspoll;\n        PRIntn index, msecs;\n\n        if (npds <= STACK_POLL_DESC_COUNT)\n        {\n            syspoll = stack_syspoll;\n        }\n        else\n        {\n            PRThread *me = PR_GetCurrentThread();\n            if (npds > me->syspoll_count)\n            {\n                PR_Free(me->syspoll_list);\n                me->syspoll_list =\n                    (struct pollfd*)PR_MALLOC(npds * sizeof(struct pollfd));\n                if (NULL == me->syspoll_list)\n                {\n                    me->syspoll_count = 0;\n                    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                    return -1;\n                }\n                me->syspoll_count = npds;\n            }\n            syspoll = me->syspoll_list;\n        }\n\n        for (index = 0; index < npds; ++index)\n        {\n            PRInt16 in_flags_read = 0, in_flags_write = 0;\n            PRInt16 out_flags_read = 0, out_flags_write = 0;\n\n            if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n            {\n                if (pds[index].in_flags & PR_POLL_READ)\n                {\n                    in_flags_read = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_WRITE,\n                        &out_flags_read);\n                }\n                if (pds[index].in_flags & PR_POLL_WRITE)\n                {\n                    in_flags_write = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_READ,\n                        &out_flags_write);\n                }\n                if ((0 != (in_flags_read & out_flags_read))\n                || (0 != (in_flags_write & out_flags_write)))\n                {\n                    /* this one is ready right now */\n                    if (0 == ready)\n                    {\n                        /*\n                         * We will return without calling the system\n                         * poll function.  So zero the out_flags\n                         * fields of all the poll descriptors before\n                         * this one.\n                         */\n                        int i;\n                        for (i = 0; i < index; i++)\n                        {\n                            pds[i].out_flags = 0;\n                        }\n                    }\n                    ready += 1;\n                    pds[index].out_flags = out_flags_read | out_flags_write;\n                }\n                else\n                {\n                    /* now locate the NSPR layer at the bottom of the stack */\n                    PRFileDesc *bottom = PR_GetIdentitiesLayer(\n                        pds[index].fd, PR_NSPR_IO_LAYER);\n                    PR_ASSERT(NULL != bottom);  /* what to do about that? */\n                    pds[index].out_flags = 0;  /* pre-condition */\n                    if ((NULL != bottom)\n                    && (_PR_FILEDESC_OPEN == bottom->secret->state))\n                    {\n                        if (0 == ready)\n                        {\n                            syspoll[index].fd = bottom->secret->md.osfd;\n                            syspoll[index].events = 0;\n                            if (in_flags_read & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_READ;\n                                syspoll[index].events |= POLLIN;\n                            }\n                            if (in_flags_read & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_WRITE;\n                                syspoll[index].events |= POLLOUT;\n                            }\n                            if (in_flags_write & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_READ;\n                                syspoll[index].events |= POLLIN;\n                            }\n                            if (in_flags_write & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_WRITE;\n                                syspoll[index].events |= POLLOUT;\n                            }\n                            if (pds[index].in_flags & PR_POLL_EXCEPT)\n                                syspoll[index].events |= POLLPRI;\n                        }\n                    }\n                    else\n                    {\n                        if (0 == ready)\n                        {\n                            int i;\n                            for (i = 0; i < index; i++)\n                            {\n                                pds[i].out_flags = 0;\n                            }\n                        }\n                        ready += 1;  /* this will cause an abrupt return */\n                        pds[index].out_flags = PR_POLL_NVAL;  /* bogii */\n                    }\n                }\n            }\n            else\n            {\n                /* make poll() ignore this entry */\n                syspoll[index].fd = -1;\n                syspoll[index].events = 0;\n                pds[index].out_flags = 0;\n            }\n        }\n        if (0 == ready)\n        {\n            switch (timeout)\n            {\n            case PR_INTERVAL_NO_WAIT: msecs = 0; break;\n            case PR_INTERVAL_NO_TIMEOUT: msecs = -1; break;\n            default:\n                msecs = PR_IntervalToMilliseconds(timeout);\n                start = PR_IntervalNow();\n            }\n\nretry:\n            ready = poll(syspoll, npds, msecs);\n            if (-1 == ready)\n            {\n                PRIntn oserror = errno;\n\n                if (EINTR == oserror)\n                {\n                    if (timeout == PR_INTERVAL_NO_TIMEOUT)\n                        goto retry;\n                    else if (timeout == PR_INTERVAL_NO_WAIT)\n                        ready = 0;  /* don't retry, just time out */\n                    else\n                    {\n                        elapsed = (PRIntervalTime) (PR_IntervalNow()\n                                - start);\n                        if (elapsed > timeout)\n                            ready = 0;  /* timed out */\n                        else\n                        {\n                            remaining = timeout - elapsed;\n                            msecs = PR_IntervalToMilliseconds(remaining);\n                            goto retry;\n                        }\n                    }\n                }\n                else\n                {\n                    _PR_MD_MAP_POLL_ERROR(oserror);\n                }\n            }\n            else if (ready > 0)\n            {\n                for (index = 0; index < npds; ++index)\n                {\n                    PRInt16 out_flags = 0;\n                    if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n                    {\n                        if (0 != syspoll[index].revents)\n                        {\n                            if (syspoll[index].revents & POLLIN)\n                            {\n                                if (pds[index].out_flags\n                                & _PR_POLL_READ_SYS_READ)\n                                {\n                                    out_flags |= PR_POLL_READ;\n                                }\n                                if (pds[index].out_flags\n                                & _PR_POLL_WRITE_SYS_READ)\n                                {\n                                    out_flags |= PR_POLL_WRITE;\n                                }\n                            }\n                            if (syspoll[index].revents & POLLOUT)\n                            {\n                                if (pds[index].out_flags\n                                & _PR_POLL_READ_SYS_WRITE)\n                                {\n                                    out_flags |= PR_POLL_READ;\n                                }\n                                if (pds[index].out_flags\n                                & _PR_POLL_WRITE_SYS_WRITE)\n                                {\n                                    out_flags |= PR_POLL_WRITE;\n                                }\n                            }\n                            if (syspoll[index].revents & POLLPRI)\n                                out_flags |= PR_POLL_EXCEPT;\n                            if (syspoll[index].revents & POLLERR)\n                                out_flags |= PR_POLL_ERR;\n                            if (syspoll[index].revents & POLLNVAL)\n                                out_flags |= PR_POLL_NVAL;\n                            if (syspoll[index].revents & POLLHUP)\n                                out_flags |= PR_POLL_HUP;\n                        }\n                    }\n                    pds[index].out_flags = out_flags;\n                }\n            }\n        }\n    }\n    return ready;\n\n} /* _pr_poll_with_poll */\n\n#if defined(_PR_POLL_WITH_SELECT)\n/*\n * OSF1 and HPUX report the POLLHUP event for a socket when the\n * shutdown(SHUT_WR) operation is called for the remote end, even though\n * the socket is still writeable. Use select(), instead of poll(), to\n * workaround this problem.\n */\nstatic PRInt32 _pr_poll_with_select(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n    PRInt32 ready = 0;\n    /*\n     * For restarting select() if it is interrupted by a signal.\n     * We use these variables to figure out how much time has\n     * elapsed and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    if (pt_TestAbort()) return -1;\n\n    if (0 == npds) PR_Sleep(timeout);\n    else\n    {\n#define STACK_POLL_DESC_COUNT 64\n        int stack_selectfd[STACK_POLL_DESC_COUNT];\n        int *selectfd;\n\t\tfd_set rd, wr, ex, *rdp = NULL, *wrp = NULL, *exp = NULL;\n\t\tstruct timeval tv, *tvp;\n        PRIntn index, msecs, maxfd = 0;\n\n        if (npds <= STACK_POLL_DESC_COUNT)\n        {\n            selectfd = stack_selectfd;\n        }\n        else\n        {\n            PRThread *me = PR_GetCurrentThread();\n            if (npds > me->selectfd_count)\n            {\n                PR_Free(me->selectfd_list);\n                me->selectfd_list = (int *)PR_MALLOC(npds * sizeof(int));\n                if (NULL == me->selectfd_list)\n                {\n                    me->selectfd_count = 0;\n                    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n                    return -1;\n                }\n                me->selectfd_count = npds;\n            }\n            selectfd = me->selectfd_list;\n        }\n\t\tFD_ZERO(&rd);\n\t\tFD_ZERO(&wr);\n\t\tFD_ZERO(&ex);\n\n        for (index = 0; index < npds; ++index)\n        {\n            PRInt16 in_flags_read = 0, in_flags_write = 0;\n            PRInt16 out_flags_read = 0, out_flags_write = 0;\n\n            if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n            {\n                if (pds[index].in_flags & PR_POLL_READ)\n                {\n                    in_flags_read = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_WRITE,\n                        &out_flags_read);\n                }\n                if (pds[index].in_flags & PR_POLL_WRITE)\n                {\n                    in_flags_write = (pds[index].fd->methods->poll)(\n                        pds[index].fd,\n                        pds[index].in_flags & ~PR_POLL_READ,\n                        &out_flags_write);\n                }\n                if ((0 != (in_flags_read & out_flags_read))\n                || (0 != (in_flags_write & out_flags_write)))\n                {\n                    /* this one is ready right now */\n                    if (0 == ready)\n                    {\n                        /*\n                         * We will return without calling the system\n                         * poll function.  So zero the out_flags\n                         * fields of all the poll descriptors before\n                         * this one.\n                         */\n                        int i;\n                        for (i = 0; i < index; i++)\n                        {\n                            pds[i].out_flags = 0;\n                        }\n                    }\n                    ready += 1;\n                    pds[index].out_flags = out_flags_read | out_flags_write;\n                }\n                else\n                {\n                    /* now locate the NSPR layer at the bottom of the stack */\n                    PRFileDesc *bottom = PR_GetIdentitiesLayer(\n                        pds[index].fd, PR_NSPR_IO_LAYER);\n                    PR_ASSERT(NULL != bottom);  /* what to do about that? */\n                    pds[index].out_flags = 0;  /* pre-condition */\n                    if ((NULL != bottom)\n                    && (_PR_FILEDESC_OPEN == bottom->secret->state))\n                    {\n                        if (0 == ready)\n                        {\n                            PRBool add_to_rd = PR_FALSE;\n                            PRBool add_to_wr = PR_FALSE;\n                            PRBool add_to_ex = PR_FALSE;\n\n                            selectfd[index] = bottom->secret->md.osfd;\n                            if (in_flags_read & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_READ;\n                                add_to_rd = PR_TRUE;\n                            }\n                            if (in_flags_read & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_READ_SYS_WRITE;\n                                add_to_wr = PR_TRUE;\n                            }\n                            if (in_flags_write & PR_POLL_READ)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_READ;\n                                add_to_rd = PR_TRUE;\n                            }\n                            if (in_flags_write & PR_POLL_WRITE)\n                            {\n                                pds[index].out_flags |=\n                                    _PR_POLL_WRITE_SYS_WRITE;\n                                add_to_wr = PR_TRUE;\n                            }\n                            if (pds[index].in_flags & PR_POLL_EXCEPT)\n                            {\n                                add_to_ex = PR_TRUE;\n                            }\n                            if ((selectfd[index] > maxfd) &&\n                                    (add_to_rd || add_to_wr || add_to_ex))\n                            {\n                                maxfd = selectfd[index];\n                                /*\n                                 * If maxfd is too large to be used with\n                                 * select, fall back to calling poll.\n                                 */\n                                if (maxfd >= FD_SETSIZE)\n                                    break;\n                            }\n                            if (add_to_rd)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &rd);\n                                rdp = &rd;\n                            }\n                            if (add_to_wr)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &wr);\n                                wrp = &wr;\n                            }\n                            if (add_to_ex)\n                            {\n                                FD_SET(bottom->secret->md.osfd, &ex);\n                                exp = &ex;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (0 == ready)\n                        {\n                            int i;\n                            for (i = 0; i < index; i++)\n                            {\n                                pds[i].out_flags = 0;\n                            }\n                        }\n                        ready += 1;  /* this will cause an abrupt return */\n                        pds[index].out_flags = PR_POLL_NVAL;  /* bogii */\n                    }\n                }\n            }\n            else\n            {\n                pds[index].out_flags = 0;\n            }\n        }\n        if (0 == ready)\n        {\n\t\t\tif (maxfd >= FD_SETSIZE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * maxfd too large to be used with select, fall back to\n\t\t\t\t * calling poll\n\t\t\t\t */\n\t\t\t\treturn(_pr_poll_with_poll(pds, npds, timeout));\n\t\t\t}\n            switch (timeout)\n            {\n            case PR_INTERVAL_NO_WAIT:\n\t\t\t\ttv.tv_sec = 0;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\ttvp = &tv;\n\t\t\t\tbreak;\n            case PR_INTERVAL_NO_TIMEOUT:\n\t\t\t\ttvp = NULL;\n\t\t\t\tbreak;\n            default:\n                msecs = PR_IntervalToMilliseconds(timeout);\n\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) * PR_USEC_PER_MSEC;\n\t\t\t\ttvp = &tv;\n                start = PR_IntervalNow();\n            }\n\nretry:\n            ready = select(maxfd + 1, rdp, wrp, exp, tvp);\n            if (-1 == ready)\n            {\n                PRIntn oserror = errno;\n\n                if ((EINTR == oserror) || (EAGAIN == oserror))\n                {\n                    if (timeout == PR_INTERVAL_NO_TIMEOUT)\n                        goto retry;\n                    else if (timeout == PR_INTERVAL_NO_WAIT)\n                        ready = 0;  /* don't retry, just time out */\n                    else\n                    {\n                        elapsed = (PRIntervalTime) (PR_IntervalNow()\n                                - start);\n                        if (elapsed > timeout)\n                            ready = 0;  /* timed out */\n                        else\n                        {\n                            remaining = timeout - elapsed;\n                            msecs = PR_IntervalToMilliseconds(remaining);\n\t\t\t\t\t\t\ttv.tv_sec = msecs/PR_MSEC_PER_SEC;\n\t\t\t\t\t\t\ttv.tv_usec = (msecs % PR_MSEC_PER_SEC) *\n\t\t\t\t\t\t\t\t\t\t\t\t\tPR_USEC_PER_MSEC;\n                            goto retry;\n                        }\n                    }\n                } else if (EBADF == oserror)\n                {\n\t\t\t\t\t/* find all the bad fds */\n\t\t\t\t\tready = 0;\n                \tfor (index = 0; index < npds; ++index)\n\t\t\t\t\t{\n                    \tpds[index].out_flags = 0;\n            \t\t\tif ((NULL != pds[index].fd) &&\n\t\t\t\t\t\t\t\t\t\t\t(0 != pds[index].in_flags))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (fcntl(selectfd[index], F_GETFL, 0) == -1)\n\t\t\t\t\t\t\t{\n                    \t\t\tpds[index].out_flags = PR_POLL_NVAL;\n\t\t\t\t\t\t\t\tready++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                } else \n                    _PR_MD_MAP_SELECT_ERROR(oserror);\n            }\n            else if (ready > 0)\n            {\n                for (index = 0; index < npds; ++index)\n                {\n                    PRInt16 out_flags = 0;\n                    if ((NULL != pds[index].fd) && (0 != pds[index].in_flags))\n                    {\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &rd))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_READ_SYS_READ)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_READ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_WRITE_SYS_READ)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_WRITE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &wr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_READ_SYS_WRITE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_READ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pds[index].out_flags\n\t\t\t\t\t\t\t& _PR_POLL_WRITE_SYS_WRITE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tout_flags |= PR_POLL_WRITE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FD_ISSET(selectfd[index], &ex))\n\t\t\t\t\t\t\tout_flags |= PR_POLL_EXCEPT;\n                    }\n                    pds[index].out_flags = out_flags;\n                }\n            }\n        }\n    }\n    return ready;\n\n} /* _pr_poll_with_select */\n#endif\t/* _PR_POLL_WITH_SELECT */\n\nPR_IMPLEMENT(PRInt32) PR_Poll(\n    PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)\n{\n#if defined(_PR_POLL_WITH_SELECT)\n\treturn(_pr_poll_with_select(pds, npds, timeout));\n#else\n\treturn(_pr_poll_with_poll(pds, npds, timeout));\n#endif\n}\n\nPR_IMPLEMENT(PRDirEntry*) PR_ReadDir(PRDir *dir, PRDirFlags flags)\n{\n    struct dirent *dp;\n\n    if (pt_TestAbort()) return NULL;\n\n    for (;;)\n    {\n        errno = 0;\n        dp = readdir(dir->md.d);\n        if (NULL == dp)\n        {\n            pt_MapError(_PR_MD_MAP_READDIR_ERROR, errno);\n            return NULL;\n        }\n        if ((flags & PR_SKIP_DOT)\n            && ('.' == dp->d_name[0])\n            && (0 == dp->d_name[1])) continue;\n        if ((flags & PR_SKIP_DOT_DOT)\n            && ('.' == dp->d_name[0])\n            && ('.' == dp->d_name[1])\n            && (0 == dp->d_name[2])) continue;\n        if ((flags & PR_SKIP_HIDDEN) && ('.' == dp->d_name[0]))\n            continue;\n        break;\n    }\n    dir->d.name = dp->d_name;\n    return &dir->d;\n}  /* PR_ReadDir */\n\nPR_IMPLEMENT(PRFileDesc*) PR_NewUDPSocket(void)\n{\n    PRIntn domain = PF_INET;\n\n    return PR_Socket(domain, SOCK_DGRAM, 0);\n}  /* PR_NewUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_NewTCPSocket(void)\n{\n    PRIntn domain = PF_INET;\n\n    return PR_Socket(domain, SOCK_STREAM, 0);\n}  /* PR_NewTCPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenUDPSocket(PRIntn af)\n{\n    return PR_Socket(af, SOCK_DGRAM, 0);\n}  /* PR_NewUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_OpenTCPSocket(PRIntn af)\n{\n    return PR_Socket(af, SOCK_STREAM, 0);\n}  /* PR_NewTCPSocket */\n\nPR_IMPLEMENT(PRStatus) PR_NewTCPSocketPair(PRFileDesc *fds[2])\n{\n#ifdef SYMBIAN\n    /*\n     * For the platforms that don't have socketpair.\n     *\n     * Copied from prsocket.c, with the parameter f[] renamed fds[] and the\n     * _PR_CONNECT_DOES_NOT_BIND code removed.\n     */\n    PRFileDesc *listenSock;\n    PRNetAddr selfAddr, peerAddr;\n    PRUint16 port;\n\n    fds[0] = fds[1] = NULL;\n    listenSock = PR_NewTCPSocket();\n    if (listenSock == NULL) {\n        goto failed;\n    }\n    PR_InitializeNetAddr(PR_IpAddrLoopback, 0, &selfAddr); /* BugZilla: 35408 */\n    if (PR_Bind(listenSock, &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    if (PR_GetSockName(listenSock, &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    port = ntohs(selfAddr.inet.port);\n    if (PR_Listen(listenSock, 5) == PR_FAILURE) {\n        goto failed;\n    }\n    fds[0] = PR_NewTCPSocket();\n    if (fds[0] == NULL) {\n        goto failed;\n    }\n    PR_InitializeNetAddr(PR_IpAddrLoopback, port, &selfAddr);\n\n    /*\n     * Only a thread is used to do the connect and accept.\n     * I am relying on the fact that PR_Connect returns\n     * successfully as soon as the connect request is put\n     * into the listen queue (but before PR_Accept is called).\n     * This is the behavior of the BSD socket code.  If\n     * connect does not return until accept is called, we\n     * will need to create another thread to call connect.\n     */\n    if (PR_Connect(fds[0], &selfAddr, PR_INTERVAL_NO_TIMEOUT)\n            == PR_FAILURE) {\n        goto failed;\n    }\n    /*\n     * A malicious local process may connect to the listening\n     * socket, so we need to verify that the accepted connection\n     * is made from our own socket fds[0].\n     */\n    if (PR_GetSockName(fds[0], &selfAddr) == PR_FAILURE) {\n        goto failed;\n    }\n    fds[1] = PR_Accept(listenSock, &peerAddr, PR_INTERVAL_NO_TIMEOUT);\n    if (fds[1] == NULL) {\n        goto failed;\n    }\n    if (peerAddr.inet.port != selfAddr.inet.port) {\n        /* the connection we accepted is not from fds[0] */\n        PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, 0);\n        goto failed;\n    }\n    PR_Close(listenSock);\n    return PR_SUCCESS;\n\nfailed:\n    if (listenSock) {\n        PR_Close(listenSock);\n    }\n    if (fds[0]) {\n        PR_Close(fds[0]);\n    }\n    if (fds[1]) {\n        PR_Close(fds[1]);\n    }\n    return PR_FAILURE;\n#else\n    PRInt32 osfd[2];\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, osfd) == -1) {\n        pt_MapError(_PR_MD_MAP_SOCKETPAIR_ERROR, errno);\n        return PR_FAILURE;\n    }\n\n    fds[0] = pt_SetMethods(osfd[0], PR_DESC_SOCKET_TCP, PR_FALSE, PR_FALSE);\n    if (fds[0] == NULL) {\n        close(osfd[0]);\n        close(osfd[1]);\n        return PR_FAILURE;\n    }\n    fds[1] = pt_SetMethods(osfd[1], PR_DESC_SOCKET_TCP, PR_FALSE, PR_FALSE);\n    if (fds[1] == NULL) {\n        PR_Close(fds[0]);\n        close(osfd[1]);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n#endif\n}  /* PR_NewTCPSocketPair */\n\nPR_IMPLEMENT(PRStatus) PR_CreatePipe(\n    PRFileDesc **readPipe,\n    PRFileDesc **writePipe\n)\n{\n    int pipefd[2];\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    if (pipe(pipefd) == -1)\n    {\n    /* XXX map pipe error */\n        PR_SetError(PR_UNKNOWN_ERROR, errno);\n        return PR_FAILURE;\n    }\n    *readPipe = pt_SetMethods(pipefd[0], PR_DESC_PIPE, PR_FALSE, PR_FALSE);\n    if (NULL == *readPipe)\n    {\n        close(pipefd[0]);\n        close(pipefd[1]);\n        return PR_FAILURE;\n    }\n    *writePipe = pt_SetMethods(pipefd[1], PR_DESC_PIPE, PR_FALSE, PR_FALSE);\n    if (NULL == *writePipe)\n    {\n        PR_Close(*readPipe);\n        close(pipefd[1]);\n        return PR_FAILURE;\n    }\n    return PR_SUCCESS;\n}\n\n/*\n** Set the inheritance attribute of a file descriptor.\n*/\nPR_IMPLEMENT(PRStatus) PR_SetFDInheritable(\n    PRFileDesc *fd,\n    PRBool inheritable)\n{\n    /*\n     * Only a non-layered, NSPR file descriptor can be inherited\n     * by a child process.\n     */\n    if (fd->identity != PR_NSPR_IO_LAYER)\n    {\n        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n        return PR_FAILURE;\n    }\n    if (fd->secret->inheritable != inheritable)\n    {\n        if (fcntl(fd->secret->md.osfd, F_SETFD,\n        inheritable ? 0 : FD_CLOEXEC) == -1)\n        {\n            _PR_MD_MAP_DEFAULT_ERROR(errno);\n            return PR_FAILURE;\n        }\n        fd->secret->inheritable = (_PRTriStateBool) inheritable;\n    }\n    return PR_SUCCESS;\n}\n\n/*****************************************************************************/\n/***************************** I/O friends methods ***************************/\n/*****************************************************************************/\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportFile(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_FILE, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportFile */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportPipe(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_PIPE, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportPipe */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportTCPSocket(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_SOCKET_TCP, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n#ifdef _PR_NEED_SECRET_AF\n    if (NULL != fd) fd->secret->af = PF_INET;\n#endif\n    return fd;\n}  /* PR_ImportTCPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_ImportUDPSocket(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n    fd = pt_SetMethods(osfd, PR_DESC_SOCKET_UDP, PR_FALSE, PR_TRUE);\n    if (NULL == fd) close(osfd);\n    return fd;\n}  /* PR_ImportUDPSocket */\n\nPR_IMPLEMENT(PRFileDesc*) PR_CreateSocketPollFd(PRInt32 osfd)\n{\n    PRFileDesc *fd;\n\n    if (!_pr_initialized) _PR_ImplicitInitialization();\n\n    fd = _PR_Getfd();\n\n    if (fd == NULL) PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n    else\n    {\n        fd->secret->md.osfd = osfd;\n        fd->secret->inheritable = _PR_TRI_FALSE;\n    \tfd->secret->state = _PR_FILEDESC_OPEN;\n        fd->methods = PR_GetSocketPollFdMethods();\n    }\n\n    return fd;\n}  /* PR_CreateSocketPollFD */\n\nPR_IMPLEMENT(PRStatus) PR_DestroySocketPollFd(PRFileDesc *fd)\n{\n    if (NULL == fd)\n    {\n        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);\n        return PR_FAILURE;\n    }\n    fd->secret->state = _PR_FILEDESC_CLOSED;\n    _PR_Putfd(fd);\n    return PR_SUCCESS;\n}  /* PR_DestroySocketPollFd */\n\nPR_IMPLEMENT(PRInt32) PR_FileDesc2NativeHandle(PRFileDesc *bottom)\n{\n    PRInt32 osfd = -1;\n    bottom = (NULL == bottom) ?\n        NULL : PR_GetIdentitiesLayer(bottom, PR_NSPR_IO_LAYER);\n    if (NULL == bottom) PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n    else osfd = bottom->secret->md.osfd;\n    return osfd;\n}  /* PR_FileDesc2NativeHandle */\n\nPR_IMPLEMENT(void) PR_ChangeFileDescNativeHandle(PRFileDesc *fd,\n    PRInt32 handle)\n{\n    if (fd) fd->secret->md.osfd = handle;\n}  /*  PR_ChangeFileDescNativeHandle*/\n\nPR_IMPLEMENT(PRStatus) PR_LockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    while (-1 == fd->secret->lockCount)\n        PR_WaitCondVar(_pr_flock_cv, PR_INTERVAL_NO_TIMEOUT);\n    if (0 == fd->secret->lockCount)\n    {\n        fd->secret->lockCount = -1;\n        PR_Unlock(_pr_flock_lock);\n        status = _PR_MD_LOCKFILE(fd->secret->md.osfd);\n        PR_Lock(_pr_flock_lock);\n        fd->secret->lockCount = (PR_SUCCESS == status) ? 1 : 0;\n        PR_NotifyAllCondVar(_pr_flock_cv);\n    }\n    else\n    {\n        fd->secret->lockCount += 1;\n    }\n    PR_Unlock(_pr_flock_lock);\n \n    return status;\n}  /* PR_LockFile */\n\nPR_IMPLEMENT(PRStatus) PR_TLockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    if (0 == fd->secret->lockCount)\n    {\n        status = _PR_MD_TLOCKFILE(fd->secret->md.osfd);\n        if (PR_SUCCESS == status) fd->secret->lockCount = 1;\n    }\n    else fd->secret->lockCount += 1;\n    PR_Unlock(_pr_flock_lock);\n \n    return status;\n}  /* PR_TLockFile */\n\nPR_IMPLEMENT(PRStatus) PR_UnlockFile(PRFileDesc *fd)\n{\n    PRStatus status = PR_SUCCESS;\n\n    if (pt_TestAbort()) return PR_FAILURE;\n\n    PR_Lock(_pr_flock_lock);\n    if (fd->secret->lockCount == 1)\n    {\n        status = _PR_MD_UNLOCKFILE(fd->secret->md.osfd);\n        if (PR_SUCCESS == status) fd->secret->lockCount = 0;\n    }\n    else fd->secret->lockCount -= 1;\n    PR_Unlock(_pr_flock_lock);\n\n    return status;\n}\n\n/*\n * The next two entry points should not be in the API, but they are\n * defined here for historical (or hysterical) reasons.\n */\n\nPR_IMPLEMENT(PRInt32) PR_GetSysfdTableMax(void)\n{\n#if defined(AIX) || defined(SYMBIAN)\n    return sysconf(_SC_OPEN_MAX);\n#else\n    struct rlimit rlim;\n\n    if ( getrlimit(RLIMIT_NOFILE, &rlim) < 0) \n       return -1;\n\n    return rlim.rlim_max;\n#endif\n}\n\nPR_IMPLEMENT(PRInt32) PR_SetSysfdTableSize(PRIntn table_size)\n{\n#if defined(AIX) || defined(SYMBIAN)\n    return -1;\n#else\n    struct rlimit rlim;\n    PRInt32 tableMax = PR_GetSysfdTableMax();\n\n    if (tableMax < 0) return -1;\n    rlim.rlim_max = tableMax;\n\n    /* Grow as much as we can; even if too big */\n    if ( rlim.rlim_max < table_size )\n        rlim.rlim_cur = rlim.rlim_max;\n    else\n        rlim.rlim_cur = table_size;\n\n    if ( setrlimit(RLIMIT_NOFILE, &rlim) < 0) \n        return -1;\n\n    return rlim.rlim_cur;\n#endif\n}\n\n/*\n * PR_Stat is supported for backward compatibility; some existing Java\n * code uses it.  New code should use PR_GetFileInfo.\n */\n\n#ifndef NO_NSPR_10_SUPPORT\nPR_IMPLEMENT(PRInt32) PR_Stat(const char *name, struct stat *buf)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_Stat\", \"PR_GetFileInfo\");\n\n    if (pt_TestAbort()) return -1;\n\n    if (-1 == stat(name, buf)) {\n        pt_MapError(_PR_MD_MAP_STAT_ERROR, errno);\n        return -1;\n    } else {\n        return 0;\n    }\n}\n#endif /* ! NO_NSPR_10_SUPPORT */\n\n\nPR_IMPLEMENT(void) PR_FD_ZERO(PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_ZERO (PR_Select)\", \"PR_Poll\");\n    memset(set, 0, sizeof(PR_fd_set));\n}\n\nPR_IMPLEMENT(void) PR_FD_SET(PRFileDesc *fh, PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_SET (PR_Select)\", \"PR_Poll\");\n    PR_ASSERT( set->hsize < PR_MAX_SELECT_DESC );\n\n    set->harray[set->hsize++] = fh;\n}\n\nPR_IMPLEMENT(void) PR_FD_CLR(PRFileDesc *fh, PR_fd_set *set)\n{\n    PRUint32 index, index2;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_CLR (PR_Select)\", \"PR_Poll\");\n\n    for (index = 0; index<set->hsize; index++)\n       if (set->harray[index] == fh) {\n           for (index2=index; index2 < (set->hsize-1); index2++) {\n               set->harray[index2] = set->harray[index2+1];\n           }\n           set->hsize--;\n           break;\n       }\n}\n\nPR_IMPLEMENT(PRInt32) PR_FD_ISSET(PRFileDesc *fh, PR_fd_set *set)\n{\n    PRUint32 index;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_ISSET (PR_Select)\", \"PR_Poll\");\n    for (index = 0; index<set->hsize; index++)\n       if (set->harray[index] == fh) {\n           return 1;\n       }\n    return 0;\n}\n\nPR_IMPLEMENT(void) PR_FD_NSET(PRInt32 fd, PR_fd_set *set)\n{\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NSET (PR_Select)\", \"PR_Poll\");\n    PR_ASSERT( set->nsize < PR_MAX_SELECT_DESC );\n\n    set->narray[set->nsize++] = fd;\n}\n\nPR_IMPLEMENT(void) PR_FD_NCLR(PRInt32 fd, PR_fd_set *set)\n{\n    PRUint32 index, index2;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NCLR (PR_Select)\", \"PR_Poll\");\n\n    for (index = 0; index<set->nsize; index++)\n       if (set->narray[index] == fd) {\n           for (index2=index; index2 < (set->nsize-1); index2++) {\n               set->narray[index2] = set->narray[index2+1];\n           }\n           set->nsize--;\n           break;\n       }\n}\n\nPR_IMPLEMENT(PRInt32) PR_FD_NISSET(PRInt32 fd, PR_fd_set *set)\n{\n    PRUint32 index;\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete(\"PR_FD_NISSET (PR_Select)\", \"PR_Poll\");\n    for (index = 0; index<set->nsize; index++)\n       if (set->narray[index] == fd) {\n           return 1;\n       }\n    return 0;\n}\n\n#include <sys/types.h>\n#include <sys/time.h>\n#if !defined(HPUX) \\\n    && !defined(LINUX) && !defined(__GNU__) && !defined(__GLIBC__)\n#include <sys/select.h>\n#endif\n\nstatic PRInt32\n_PR_getset(PR_fd_set *pr_set, fd_set *set)\n{\n    PRUint32 index;\n    PRInt32 max = 0;\n\n    if (!pr_set)\n        return 0;\n   \n    FD_ZERO(set);\n\n    /* First set the pr file handle osfds */\n    for (index=0; index<pr_set->hsize; index++) {\n        FD_SET(pr_set->harray[index]->secret->md.osfd, set);\n        if (pr_set->harray[index]->secret->md.osfd > max)\n            max = pr_set->harray[index]->secret->md.osfd;\n    }\n    /* Second set the native osfds */\n    for (index=0; index<pr_set->nsize; index++) {\n        FD_SET(pr_set->narray[index], set);\n        if (pr_set->narray[index] > max)\n            max = pr_set->narray[index];\n    }\n    return max;\n}\n\nstatic void\n_PR_setset(PR_fd_set *pr_set, fd_set *set)\n{\n    PRUint32 index, last_used;\n\n    if (!pr_set)\n        return;\n\n    for (last_used=0, index=0; index<pr_set->hsize; index++) {\n        if ( FD_ISSET(pr_set->harray[index]->secret->md.osfd, set) ) {\n            pr_set->harray[last_used++] = pr_set->harray[index];\n        }\n    }\n    pr_set->hsize = last_used;\n\n    for (last_used=0, index=0; index<pr_set->nsize; index++) {\n        if ( FD_ISSET(pr_set->narray[index], set) ) {\n            pr_set->narray[last_used++] = pr_set->narray[index];\n        }\n    }\n    pr_set->nsize = last_used;\n}\n\nPR_IMPLEMENT(PRInt32) PR_Select(\n    PRInt32 unused, PR_fd_set *pr_rd, PR_fd_set *pr_wr, \n    PR_fd_set *pr_ex, PRIntervalTime timeout)\n{\n    fd_set rd, wr, ex;\n    struct timeval tv, *tvp;\n    PRInt32 max, max_fd;\n    PRInt32 rv;\n    /*\n     * For restarting select() if it is interrupted by a Unix signal.\n     * We use these variables to figure out how much time has elapsed\n     * and how much of the timeout still remains.\n     */\n    PRIntervalTime start = 0, elapsed, remaining;\n\n    static PRBool unwarned = PR_TRUE;\n    if (unwarned) unwarned = _PR_Obsolete( \"PR_Select\", \"PR_Poll\");\n\n    FD_ZERO(&rd);\n    FD_ZERO(&wr);\n    FD_ZERO(&ex);\n\n    max_fd = _PR_getset(pr_rd, &rd);\n    max_fd = (max = _PR_getset(pr_wr, &wr))>max_fd?max:max_fd;\n    max_fd = (max = _PR_getset(pr_ex, &ex))>max_fd?max:max_fd;\n\n    if (timeout == PR_INTERVAL_NO_TIMEOUT) {\n        tvp = NULL;\n    } else {\n        tv.tv_sec = (PRInt32)PR_IntervalToSeconds(timeout);\n        tv.tv_usec = (PRInt32)PR_IntervalToMicroseconds(\n                timeout - PR_SecondsToInterval(tv.tv_sec));\n        tvp = &tv;\n        start = PR_IntervalNow();\n    }\n\nretry:\n    rv = select(max_fd + 1, (_PRSelectFdSetArg_t) &rd,\n        (_PRSelectFdSetArg_t) &wr, (_PRSelectFdSetArg_t) &ex, tvp);\n\n    if (rv == -1 && errno == EINTR) {\n        if (timeout == PR_INTERVAL_NO_TIMEOUT) {\n            goto retry;\n        } else {\n            elapsed = (PRIntervalTime) (PR_IntervalNow() - start);\n            if (elapsed > timeout) {\n                rv = 0;  /* timed out */\n            } else {\n                remaining = timeout - elapsed;\n                tv.tv_sec = (PRInt32)PR_IntervalToSeconds(remaining);\n                tv.tv_usec = (PRInt32)PR_IntervalToMicroseconds(\n                        remaining - PR_SecondsToInterval(tv.tv_sec));\n                goto retry;\n            }\n        }\n    }\n\n    if (rv > 0) {\n        _PR_setset(pr_rd, &rd);\n        _PR_setset(pr_wr, &wr);\n        _PR_setset(pr_ex, &ex);\n    } else if (rv == -1) {\n        pt_MapError(_PR_MD_MAP_SELECT_ERROR, errno);\n    }\n    return rv;\n}\n#endif /* defined(_PR_PTHREADS) */\n\n#ifdef MOZ_UNICODE \n/* ================ UTF16 Interfaces ================================ */\nPR_IMPLEMENT(PRFileDesc*) PR_OpenFileUTF16(\n    const PRUnichar *name, PRIntn flags, PRIntn mode)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRStatus) PR_CloseDirUTF16(PRDir *dir)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return PR_FAILURE;\n}\n\nPR_IMPLEMENT(PRDirUTF16*) PR_OpenDirUTF16(const PRUnichar *name)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRDirEntryUTF16*) PR_ReadDirUTF16(PRDirUTF16 *dir, PRDirFlags flags)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return NULL;\n}\n\nPR_IMPLEMENT(PRStatus) PR_GetFileInfo64UTF16(const PRUnichar *fn, PRFileInfo64 *info)\n{\n    PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n    return PR_FAILURE;\n}\n/* ================ UTF16 Interfaces ================================ */\n#endif /* MOZ_UNICODE */\n\n/* ptio.c */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/aix.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#ifdef AIX_HAVE_ATOMIC_OP_H\n#include <sys/atomic_op.h>\n\nPRInt32 _AIX_AtomicSet(PRInt32 *val, PRInt32 newval)\n{\n    PRIntn oldval;\n    boolean_t stored;\n    oldval = fetch_and_add((atomic_p)val, 0);\n    do\n    {\n        stored = compare_and_swap((atomic_p)val, &oldval, newval);\n    } while (!stored);\n    return oldval;\n}  /* _AIX_AtomicSet */\n#endif /* AIX_HAVE_ATOMIC_OP_H */\n\n#if defined(AIX_TIMERS)\n\n#include <sys/time.h>\n\nstatic PRUint32 _aix_baseline_epoch;\n\nstatic void _MD_AixIntervalInit(void)\n{\n    timebasestruct_t real_time;\n    read_real_time(&real_time, TIMEBASE_SZ);\n    (void)time_base_to_time(&real_time, TIMEBASE_SZ);\n    _aix_baseline_epoch = real_time.tb_high;\n}  /* _MD_AixIntervalInit */\n\nPRIntervalTime _MD_AixGetInterval(void)\n{\n    PRIntn rv;\n    PRUint64 temp;\n    timebasestruct_t real_time;\n    read_real_time(&real_time, TIMEBASE_SZ);\n    (void)time_base_to_time(&real_time, TIMEBASE_SZ);\n    /* tb_high is in seconds, tb_low in 10(-9)seconds */\n    temp = 1000000000ULL * (PRUint64)(real_time.tb_high - _aix_baseline_epoch);\n    temp += (PRUint64)real_time.tb_low;  /* everything's 10(-9) seconds */\n    temp >>= 16;  /* now it's something way different */\n    return (PRIntervalTime)temp;\n}  /* _MD_AixGetInterval */\n\nPRIntervalTime _MD_AixIntervalPerSec(void)\n{\n    return 1000000000ULL >> 16;  /* that's 15258, I think */\n}  /* _MD_AixIntervalPerSec */\n\n#endif /* defined(AIX_TIMERS) */\n\n#if !defined(PTHREADS_USER)\n\n#if defined(_PR_PTHREADS)\n\n/*\n * AIX 4.3 has sched_yield().  AIX 4.2 has pthread_yield().\n * So we look up the appropriate function pointer at run time.\n */\n\n#include <dlfcn.h>\n\nint (*_PT_aix_yield_fcn)() = NULL;\nint _pr_aix_send_file_use_disabled = 0;\n\nvoid _MD_EarlyInit(void)\n{\n    void *main_app_handle;\n\tchar *evp;\n\n    main_app_handle = dlopen(NULL, RTLD_NOW);\n    PR_ASSERT(NULL != main_app_handle);\n\n    _PT_aix_yield_fcn = (int(*)())dlsym(main_app_handle, \"sched_yield\");\n    if (!_PT_aix_yield_fcn) {\n        _PT_aix_yield_fcn = (int(*)())dlsym(main_app_handle,\"pthread_yield\");\n        PR_ASSERT(NULL != _PT_aix_yield_fcn);\n    }\n    dlclose(main_app_handle);\n\n\tif (evp = getenv(\"NSPR_AIX_SEND_FILE_USE_DISABLED\")) {\n\t\tif (1 == atoi(evp))\n\t\t\t_pr_aix_send_file_use_disabled = 1;\n\t}\n\n#if defined(AIX_TIMERS)\n    _MD_AixIntervalInit();\n#endif\n}\n\n#else /* _PR_PTHREADS */\n\nvoid _MD_EarlyInit(void)\n{\n#if defined(AIX_TIMERS)\n    _MD_AixIntervalInit();\n#endif\n}\n\n#endif /* _PR_PTHREADS */\n\nPRWord *_MD_HomeGCRegisters(PRThread *t, int isCurrent, int *np)\n{\n#ifndef _PR_PTHREADS\n    if (isCurrent) {\n\t(void) setjmp(CONTEXT(t));\n    }\n    *np = sizeof(CONTEXT(t)) / sizeof(PRWord);\n    return (PRWord *) CONTEXT(t);\n#else\n\t*np = 0;\n\treturn NULL;\n#endif\n}\n\n#ifndef _PR_PTHREADS\nPR_IMPLEMENT(void)\n_MD_SET_PRIORITY(_MDThread *thread, PRUintn newPri)\n{\n    return;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_InitializeThread(PRThread *thread)\n{\n\treturn PR_SUCCESS;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_WAIT(PRThread *thread, PRIntervalTime ticks)\n{\n    PR_ASSERT(!(thread->flags & _PR_GLOBAL_SCOPE));\n    _PR_MD_SWITCH_CONTEXT(thread);\n    return PR_SUCCESS;\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_WAKEUP_WAITER(PRThread *thread)\n{\n    if (thread) {\n\tPR_ASSERT(!(thread->flags & _PR_GLOBAL_SCOPE));\n    }\n    return PR_SUCCESS;\n}\n\n/* These functions should not be called for AIX */\nPR_IMPLEMENT(void)\n_MD_YIELD(void)\n{\n    PR_NOT_REACHED(\"_MD_YIELD should not be called for AIX.\");\n}\n\nPR_IMPLEMENT(PRStatus)\n_MD_CREATE_THREAD(\n    PRThread *thread,\n    void (*start) (void *),\n    PRThreadPriority priority,\n    PRThreadScope scope,\n    PRThreadState state,\n    PRUint32 stackSize)\n{\n    PR_NOT_REACHED(\"_MD_CREATE_THREAD should not be called for AIX.\");\n}\n#endif /* _PR_PTHREADS */\n#endif /* PTHREADS_USER */\n\n/*\n * NSPR 2.0 overrides the system select() and poll() functions.\n * On AIX 4.2, we use dlopen(\"/unix\", RTLD_NOW) and dlsym() to get\n * at the original system select() and poll() functions.\n */\n\n#if !defined(AIX_RENAME_SELECT)\n\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <dlfcn.h>\n\nstatic int (*aix_select_fcn)() = NULL;\nstatic int (*aix_poll_fcn)() = NULL;\n\nint _MD_SELECT(int width, fd_set *r, fd_set *w, fd_set *e, struct timeval *t)\n{\n    int rv;\n\n    if (!aix_select_fcn) {\n        void *aix_handle;\n\n\taix_handle = dlopen(\"/unix\", RTLD_NOW);\n\tif (!aix_handle) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n\taix_select_fcn = (int(*)())dlsym(aix_handle,\"select\");\n        dlclose(aix_handle);\n\tif (!aix_select_fcn) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n    }\n    rv = (*aix_select_fcn)(width, r, w, e, t);\n    return rv;\n}\n\nint _MD_POLL(void *listptr, unsigned long nfds, long timeout)\n{\n    int rv;\n\n    if (!aix_poll_fcn) {\n        void *aix_handle;\n\n\taix_handle = dlopen(\"/unix\", RTLD_NOW);\n\tif (!aix_handle) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n\taix_poll_fcn = (int(*)())dlsym(aix_handle,\"poll\");\n        dlclose(aix_handle);\n\tif (!aix_poll_fcn) {\n\t    PR_SetError(PR_UNKNOWN_ERROR, 0);\n\t    return -1;\n\t}\n    }\n    rv = (*aix_poll_fcn)(listptr, nfds, timeout);\n    return rv;\n}\n\n#else\n\n/*\n * In AIX versions prior to 4.2, we use the two-step rename/link trick.\n * The binary must contain at least one \"poll\" symbol for linker's rename\n * to work.  So we must have this dummy function that references poll().\n */\n#include <sys/poll.h>\nvoid _pr_aix_dummy()\n{\n    poll(0,0,0);\n}\n\n#endif /* !defined(AIX_RENAME_SELECT) */\n\n#ifdef _PR_HAVE_ATOMIC_CAS\n\n#include \"pratom.h\"\n\n#define _PR_AIX_ATOMIC_LOCK\t-1\n\nPR_IMPLEMENT(void)\nPR_StackPush(PRStack *stack, PRStackElem *stack_elem)\n{\nPRStackElem *addr;\nboolean_t locked = TRUE;\n\n\t/* Is it safe to cast a pointer to an int? */\n\tPR_ASSERT(sizeof(int) == sizeof(PRStackElem *));\n\tdo {\n\t\twhile ((addr = stack->prstk_head.prstk_elem_next) ==\n\t\t\t\t\t\t\t\t\t\t\t(PRStackElem *)_PR_AIX_ATOMIC_LOCK)\n\t\t\t;\n\t\tlocked = _check_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t(int) addr, _PR_AIX_ATOMIC_LOCK);\n\t} while (locked == TRUE);\n\tstack_elem->prstk_elem_next = addr;\n\t_clear_lock((atomic_p)&stack->prstk_head.prstk_elem_next, (int)stack_elem);\n    return;\n}\n\nPR_IMPLEMENT(PRStackElem *)\nPR_StackPop(PRStack *stack)\n{\nPRStackElem *element;\nboolean_t locked = TRUE;\n\n\t/* Is it safe to cast a pointer to an int? */\n\tPR_ASSERT(sizeof(int) == sizeof(PRStackElem *));\n\tdo {\n\t\twhile ((element = stack->prstk_head.prstk_elem_next) ==\n\t\t\t\t\t\t\t\t\t\t(PRStackElem *) _PR_AIX_ATOMIC_LOCK)\n\t\t\t;\n\t\tlocked = _check_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t(int)element, _PR_AIX_ATOMIC_LOCK);\n\t} while (locked == TRUE);\n\n\tif (element == NULL) {\n\t\t_clear_lock((atomic_p) &stack->prstk_head.prstk_elem_next, NULL);\n\t} else {\n\t\t_clear_lock((atomic_p) &stack->prstk_head.prstk_elem_next,\n\t\t\t\t\t\t\t\t\t\t(int) element->prstk_elem_next);\n\t}\n\treturn element;\n}\n\n#endif\t/* _PR_HAVE_ATOMIC_CAS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/irix.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <signal.h>\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syssgi.h>\n#include <sys/time.h>\n#include <sys/immu.h>\n#include <sys/utsname.h>\n#include <sys/sysmp.h>\n#include <sys/pda.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/procfs.h>\n#include <task.h>\n#include <dlfcn.h>\n\nstatic void _MD_IrixIntervalInit(void);\n\n#if defined(_PR_PTHREADS)\n/*\n * for compatibility with classic nspr\n */\nvoid _PR_IRIX_CHILD_PROCESS()\n{\n}\n#else  /* defined(_PR_PTHREADS) */\n\nstatic void irix_detach_sproc(void);\nchar *_nspr_sproc_private;    /* ptr. to private region in every sproc */\n\nextern PRUintn    _pr_numCPU;\n\ntypedef struct nspr_arena {\n\tPRCList links;\n\tusptr_t *usarena;\n} nspr_arena;\n\n#define ARENA_PTR(qp) \\\n\t((nspr_arena *) ((char*) (qp) - offsetof(nspr_arena , links)))\n\nstatic usptr_t *alloc_new_arena(void);\n\nPRCList arena_list = PR_INIT_STATIC_CLIST(&arena_list);\nulock_t arena_list_lock;\nnspr_arena first_arena;\nint\t_nspr_irix_arena_cnt = 1;\n\nPRCList sproc_list = PR_INIT_STATIC_CLIST(&sproc_list);\nulock_t sproc_list_lock;\n\ntypedef struct sproc_data {\n\tvoid (*entry) (void *, size_t);\n\tunsigned inh;\n\tvoid *arg;\n\tcaddr_t sp;\n\tsize_t len;\n\tint *pid;\n\tint creator_pid;\n} sproc_data;\n\ntypedef struct sproc_params {\n\tPRCList links;\n\tsproc_data sd;\n} sproc_params;\n\n#define SPROC_PARAMS_PTR(qp) \\\n\t((sproc_params *) ((char*) (qp) - offsetof(sproc_params , links)))\n\nlong\t_nspr_irix_lock_cnt = 0;\nlong\t_nspr_irix_sem_cnt = 0;\nlong\t_nspr_irix_pollsem_cnt = 0;\n\nusptr_t *_pr_usArena;\nulock_t _pr_heapLock;\n\nusema_t *_pr_irix_exit_sem;\nPRInt32 _pr_irix_exit_now = 0;\nPRInt32 _pr_irix_process_exit_code = 0;\t/* exit code for PR_ProcessExit */\nPRInt32 _pr_irix_process_exit = 0; /* process exiting due to call to\n\t\t\t\t\t\t\t\t\t\t   PR_ProcessExit */\n\nint _pr_irix_primoridal_cpu_fd[2] = { -1, -1 };\nstatic void (*libc_exit)(int) = NULL;\nstatic void *libc_handle = NULL;\n\n#define _NSPR_DEF_INITUSERS\t\t100\t/* default value of CONF_INITUSERS */\n#define _NSPR_DEF_INITSIZE\t\t(4 * 1024 * 1024)\t/* 4 MB */\n\nint _irix_initusers = _NSPR_DEF_INITUSERS;\nint _irix_initsize = _NSPR_DEF_INITSIZE;\n\nPRIntn _pr_io_in_progress, _pr_clock_in_progress;\n\nPRInt32 _pr_md_irix_sprocs_created, _pr_md_irix_sprocs_failed;\nPRInt32 _pr_md_irix_sprocs = 1;\nPRCList _pr_md_irix_sproc_list =\nPR_INIT_STATIC_CLIST(&_pr_md_irix_sproc_list);\n\nsigset_t ints_off;\nextern sigset_t timer_set;\n\n#if !defined(PR_SETABORTSIG)\n#define PR_SETABORTSIG 18\n#endif\n/*\n * terminate the entire application if any sproc exits abnormally\n */\nPRBool _nspr_terminate_on_error = PR_TRUE;\n\n/*\n * exported interface to set the shared arena parameters\n */\nvoid _PR_Irix_Set_Arena_Params(PRInt32 initusers, PRInt32 initsize)\n{\n    _irix_initusers = initusers;\n    _irix_initsize = initsize;\n}\n\nstatic usptr_t *alloc_new_arena()\n{\n    return(usinit(\"/dev/zero\"));\n}\n\nstatic PRStatus new_poll_sem(struct _MDThread *mdthr, int val)\n{\nPRIntn _is;\nPRStatus rv = PR_SUCCESS;\nusema_t *sem = NULL;\nPRCList *qp;\nnspr_arena *arena;\nusptr_t *irix_arena;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\t_PR_LOCK(arena_list_lock);\n\tfor (qp = arena_list.next; qp != &arena_list; qp = qp->next) {\n\t\tarena = ARENA_PTR(qp);\n\t\tsem = usnewpollsema(arena->usarena, val);\n\t\tif (sem != NULL) {\n\t\t\tmdthr->cvar_pollsem = sem;\n\t\t\tmdthr->pollsem_arena = arena->usarena;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sem == NULL) {\n\t\t/*\n\t\t * If no space left in the arena allocate a new one.\n\t\t */\n\t\tif (errno == ENOMEM) {\n\t\t\tarena = PR_NEWZAP(nspr_arena);\n\t\t\tif (arena != NULL) {\n\t\t\t\tirix_arena = alloc_new_arena();\n\t\t\t\tif (irix_arena) {\n\t\t\t\t\tPR_APPEND_LINK(&arena->links, &arena_list);\n\t\t\t\t\t_nspr_irix_arena_cnt++;\n\t\t\t\t\tarena->usarena = irix_arena;\n\t\t\t\t\tsem = usnewpollsema(arena->usarena, val);\n\t\t\t\t\tif (sem != NULL) {\n\t\t\t\t\t\tmdthr->cvar_pollsem = sem;\n\t\t\t\t\t\tmdthr->pollsem_arena = arena->usarena;\n\t\t\t\t\t} else\n\t\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tPR_DELETE(arena);\n\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\trv = PR_FAILURE;\n\t\t} else\n\t\t\trv = PR_FAILURE;\n\t}\n\t_PR_UNLOCK(arena_list_lock);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\tif (rv == PR_SUCCESS)\n\t\t_MD_ATOMIC_INCREMENT(&_nspr_irix_pollsem_cnt);\n\treturn rv;\n}\n\nstatic void free_poll_sem(struct _MDThread *mdthr)\n{\nPRIntn _is;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tusfreepollsema(mdthr->cvar_pollsem, mdthr->pollsem_arena);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\t_MD_ATOMIC_DECREMENT(&_nspr_irix_pollsem_cnt);\n}\n\nstatic PRStatus new_lock(struct _MDLock *lockp)\n{\nPRIntn _is;\nPRStatus rv = PR_SUCCESS;\nulock_t lock = NULL;\nPRCList *qp;\nnspr_arena *arena;\nusptr_t *irix_arena;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\t_PR_LOCK(arena_list_lock);\n\tfor (qp = arena_list.next; qp != &arena_list; qp = qp->next) {\n\t\tarena = ARENA_PTR(qp);\n\t\tlock = usnewlock(arena->usarena);\n\t\tif (lock != NULL) {\n\t\t\tlockp->lock = lock;\n\t\t\tlockp->arena = arena->usarena;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (lock == NULL) {\n\t\t/*\n\t\t * If no space left in the arena allocate a new one.\n\t\t */\n\t\tif (errno == ENOMEM) {\n\t\t\tarena = PR_NEWZAP(nspr_arena);\n\t\t\tif (arena != NULL) {\n\t\t\t\tirix_arena = alloc_new_arena();\n\t\t\t\tif (irix_arena) {\n\t\t\t\t\tPR_APPEND_LINK(&arena->links, &arena_list);\n\t\t\t\t\t_nspr_irix_arena_cnt++;\n\t\t\t\t\tarena->usarena = irix_arena;\n\t\t\t\t\tlock = usnewlock(irix_arena);\n\t\t\t\t\tif (lock != NULL) {\n\t\t\t\t\t\tlockp->lock = lock;\n\t\t\t\t\t\tlockp->arena = arena->usarena;\n\t\t\t\t\t} else\n\t\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tPR_DELETE(arena);\n\t\t\t\t\trv = PR_FAILURE;\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\trv = PR_FAILURE;\n\t\t} else\n\t\t\trv = PR_FAILURE;\n\t}\n\t_PR_UNLOCK(arena_list_lock);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\tif (rv == PR_SUCCESS)\n\t\t_MD_ATOMIC_INCREMENT(&_nspr_irix_lock_cnt);\n\treturn rv;\n}\n\nstatic void free_lock(struct _MDLock *lockp)\n{\nPRIntn _is;\nPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tusfreelock(lockp->lock, lockp->arena);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n\t_MD_ATOMIC_DECREMENT(&_nspr_irix_lock_cnt);\n}\n\nvoid _MD_FREE_LOCK(struct _MDLock *lockp)\n{\n\tPRIntn _is;\n\tPRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(_is); \n\tfree_lock(lockp);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(_is);\n}\n\n/*\n * _MD_get_attached_thread\n *\t\tReturn the thread pointer of the current thread if it is attached.\n *\n *\t\tThis function is needed for Irix because the thread-local-storage is\n *\t\timplemented by mmapin'g a page with the MAP_LOCAL flag. This causes the\n *\t\tsproc-private page to inherit contents of the page of the caller of sproc().\n */\nPRThread *_MD_get_attached_thread(void)\n{\n\n\tif (_MD_GET_SPROC_PID() == get_pid())\n\t\treturn _MD_THIS_THREAD();\n\telse\n\t\treturn 0;\n}\n\n/*\n * _MD_get_current_thread\n *\t\tReturn the thread pointer of the current thread (attaching it if\n *\t\tnecessary)\n */\nPRThread *_MD_get_current_thread(void)\n{\nPRThread *me;\n\n\tme = _MD_GET_ATTACHED_THREAD();\n    if (NULL == me) {\n        me = _PRI_AttachThread(\n            PR_USER_THREAD, PR_PRIORITY_NORMAL, NULL, 0);\n    }\n    PR_ASSERT(me != NULL);\n\treturn(me);\n}\n\n/*\n * irix_detach_sproc\n *\t\tauto-detach a sproc when it exits\n */\nvoid irix_detach_sproc(void)\n{\nPRThread *me;\n\n\tme = _MD_GET_ATTACHED_THREAD();\n\tif ((me != NULL) && (me->flags & _PR_ATTACHED)) {\n\t\t_PRI_DetachThread();\n\t}\n}\n\n\nPRStatus _MD_NEW_LOCK(struct _MDLock *lockp)\n{\n    PRStatus rv;\n    PRIntn is;\n    PRThread *me = _MD_GET_ATTACHED_THREAD();\t\n\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(is);\n\trv = new_lock(lockp);\n\tif (me && !_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_FAST_INTSON(is);\n\treturn rv;\n}\n\nstatic void\nsigchld_handler(int sig)\n{\n    pid_t pid;\n    int status;\n\n    /*\n     * If an sproc exited abnormally send a SIGKILL signal to all the\n     * sprocs in the process to terminate the application\n     */\n    while ((pid = waitpid(0, &status, WNOHANG)) > 0) {\n        if (WIFSIGNALED(status) && ((WTERMSIG(status) == SIGSEGV) ||\n            (WTERMSIG(status) == SIGBUS) ||\n            (WTERMSIG(status) == SIGABRT) ||\n            (WTERMSIG(status) == SIGILL))) {\n\n\t\t\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t\t\t_exit(status);\n\t\t\t}\n    }\n}\n\nstatic void save_context_and_block(int sig)\n{\nPRThread *me = _PR_MD_CURRENT_THREAD();\n_PRCPU *cpu = _PR_MD_CURRENT_CPU();\n\n\t/*\n\t * save context\n\t */\n\t(void) setjmp(me->md.jb);\n\t/*\n\t * unblock the suspending thread\n\t */\n\tif (me->cpu) {\n\t\t/*\n\t\t * I am a cpu thread, not a user-created GLOBAL thread\n\t\t */\n\t\tunblockproc(cpu->md.suspending_id);\t\n\t} else {\n\t\tunblockproc(me->md.suspending_id);\t\n\t}\n\t/*\n\t * now, block current thread\n\t */\n\tblockproc(getpid());\n}\n\n/*\n** The irix kernel has a bug in it which causes async connect's which are\n** interrupted by a signal to fail terribly (EADDRINUSE is returned). \n** We work around the bug by blocking signals during the async connect\n** attempt.\n*/\nPRInt32 _MD_irix_connect(\n    PRInt32 osfd, const PRNetAddr *addr, PRInt32 addrlen, PRIntervalTime timeout)\n{\n    PRInt32 rv;\n    sigset_t oldset;\n\n    sigprocmask(SIG_BLOCK, &ints_off, &oldset);\n    rv = connect(osfd, addr, addrlen);\n    sigprocmask(SIG_SETMASK, &oldset, 0);\n\n    return(rv);\n}\n\n#include \"prprf.h\"\n\n/********************************************************************/\n/********************************************************************/\n/*************** Various thread like things for IRIX ****************/\n/********************************************************************/\n/********************************************************************/\n\nvoid *_MD_GetSP(PRThread *t)\n{\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n    void *sp;\n\n    if (me == t)\n        (void) setjmp(t->md.jb);\n\n    sp = (void *)(t->md.jb[JB_SP]);\n    PR_ASSERT((sp >= (void *) t->stack->stackBottom) &&\n        (sp <= (void *) (t->stack->stackBottom + t->stack->stackSize)));\n    return(sp);\n}\n\nvoid _MD_InitLocks()\n{\n    char buf[200];\n    char *init_users, *init_size;\n\n    PR_snprintf(buf, sizeof(buf), \"/dev/zero\");\n\n    if (init_users = getenv(\"_NSPR_IRIX_INITUSERS\"))\n        _irix_initusers = atoi(init_users);\n\n    if (init_size = getenv(\"_NSPR_IRIX_INITSIZE\"))\n        _irix_initsize = atoi(init_size);\n\n    usconfig(CONF_INITUSERS, _irix_initusers);\n    usconfig(CONF_INITSIZE, _irix_initsize);\n    usconfig(CONF_AUTOGROW, 1);\n    usconfig(CONF_AUTORESV, 1);\n\tif (usconfig(CONF_ARENATYPE, US_SHAREDONLY) < 0) {\n\t\tperror(\"PR_Init: unable to config mutex arena\");\n\t\texit(-1);\n\t}\n\n    _pr_usArena = usinit(buf);\n    if (!_pr_usArena) {\n        fprintf(stderr,\n            \"PR_Init: Error - unable to create lock/monitor arena\\n\");\n        exit(-1);\n    }\n    _pr_heapLock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n    arena_list_lock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n    sproc_list_lock = usnewlock(_pr_usArena);\n\t_nspr_irix_lock_cnt++;\n\n\t_pr_irix_exit_sem = usnewsema(_pr_usArena, 0);\n\t_nspr_irix_sem_cnt = 1;\n\n\tfirst_arena.usarena = _pr_usArena;\n\tPR_INIT_CLIST(&first_arena.links);\n\tPR_APPEND_LINK(&first_arena.links, &arena_list);\n}\n\n/* _PR_IRIX_CHILD_PROCESS is a private API for Server group */\nvoid _PR_IRIX_CHILD_PROCESS()\n{\nextern PRUint32 _pr_global_threads;\n\n    PR_ASSERT(_PR_MD_CURRENT_CPU() == _pr_primordialCPU);\n    PR_ASSERT(_pr_numCPU == 1);\n    PR_ASSERT(_pr_global_threads == 0);\n    /*\n     * save the new pid\n     */\n    _pr_primordialCPU->md.id = getpid();\n\t_MD_SET_SPROC_PID(getpid());\t\n}\n\nstatic PRStatus pr_cvar_wait_sem(PRThread *thread, PRIntervalTime timeout)\n{\n    int rv;\n\n#ifdef _PR_USE_POLL\n\tstruct pollfd pfd;\n\tint msecs;\n\n\tif (timeout == PR_INTERVAL_NO_TIMEOUT)\n\t\tmsecs = -1;\n\telse\n\t\tmsecs  = PR_IntervalToMilliseconds(timeout);\n#else\n    struct timeval tv, *tvp;\n    fd_set rd;\n\n\tif(timeout == PR_INTERVAL_NO_TIMEOUT)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = PR_IntervalToSeconds(timeout);\n\t\ttv.tv_usec = PR_IntervalToMicroseconds(\n\t\ttimeout - PR_SecondsToInterval(tv.tv_sec));\n\t\ttvp = &tv;\n\t}\n\tFD_ZERO(&rd);\n\tFD_SET(thread->md.cvar_pollsemfd, &rd);\n#endif\n\n    /*\n     * call uspsema only if a previous select call on this semaphore\n     * did not timeout\n     */\n    if (!thread->md.cvar_pollsem_select) {\n        rv = _PR_WAIT_SEM(thread->md.cvar_pollsem);\n\t\tPR_ASSERT(rv >= 0);\n\t} else\n        rv = 0;\nagain:\n    if(!rv) {\n#ifdef _PR_USE_POLL\n\t\tpfd.events = POLLIN;\n\t\tpfd.fd = thread->md.cvar_pollsemfd;\n\t\trv = _MD_POLL(&pfd, 1, msecs);\n#else\n\t\trv = _MD_SELECT(thread->md.cvar_pollsemfd + 1, &rd, NULL,NULL,tvp);\n#endif\n        if ((rv == -1) && (errno == EINTR)) {\n\t\t\trv = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tPR_ASSERT(rv >= 0);\n\t}\n\n    if (rv > 0) {\n        /*\n         * acquired the semaphore, call uspsema next time\n         */\n        thread->md.cvar_pollsem_select = 0;\n        return PR_SUCCESS;\n    } else {\n        /*\n         * select timed out; must call select, not uspsema, when trying\n         * to acquire the semaphore the next time\n         */\n        thread->md.cvar_pollsem_select = 1;\n        return PR_FAILURE;\n    }\n}\n\nPRStatus _MD_wait(PRThread *thread, PRIntervalTime ticks)\n{\n    if ( thread->flags & _PR_GLOBAL_SCOPE ) {\n\t_MD_CHECK_FOR_EXIT();\n        if (pr_cvar_wait_sem(thread, ticks) == PR_FAILURE) {\n\t    _MD_CHECK_FOR_EXIT();\n            /*\n             * wait timed out\n             */\n            _PR_THREAD_LOCK(thread);\n            if (thread->wait.cvar) {\n                /*\n                 * The thread will remove itself from the waitQ\n                 * of the cvar in _PR_WaitCondVar\n                 */\n                thread->wait.cvar = NULL;\n                thread->state =  _PR_RUNNING;\n                _PR_THREAD_UNLOCK(thread);\n            }  else {\n                _PR_THREAD_UNLOCK(thread);\n                /*\n             * This thread was woken up by a notifying thread\n             * at the same time as a timeout; so, consume the\n             * extra post operation on the semaphore\n             */\n\t        _MD_CHECK_FOR_EXIT();\n            pr_cvar_wait_sem(thread, PR_INTERVAL_NO_TIMEOUT);\n            }\n\t    _MD_CHECK_FOR_EXIT();\n        }\n    } else {\n        _PR_MD_SWITCH_CONTEXT(thread);\n    }\n    return PR_SUCCESS;\n}\n\nPRStatus _MD_WakeupWaiter(PRThread *thread)\n{\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n    PRIntn is;\n\n\tPR_ASSERT(_pr_md_idle_cpus >= 0);\n    if (thread == NULL) {\n\t\tif (_pr_md_idle_cpus)\n        \t_MD_Wakeup_CPUs();\n    } else if (!_PR_IS_NATIVE_THREAD(thread)) {\n\t\tif (_pr_md_idle_cpus)\n       \t\t_MD_Wakeup_CPUs();\n    } else {\n\t\tPR_ASSERT(_PR_IS_NATIVE_THREAD(thread));\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_INTSOFF(is);\n\t\t_MD_CVAR_POST_SEM(thread);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n    } \n    return PR_SUCCESS;\n}\n\nvoid create_sproc (void (*entry) (void *, size_t), unsigned inh,\n\t\t\t\t\tvoid *arg, caddr_t sp, size_t len, int *pid)\n{\nsproc_params sparams;\nchar data;\nint rv;\nPRThread *me = _PR_MD_CURRENT_THREAD();\n\n\tif (!_PR_IS_NATIVE_THREAD(me) && (_PR_MD_CURRENT_CPU()->id == 0)) {\n\t\t*pid = sprocsp(entry,\t\t/* startup func\t\t*/\n\t\t\t\t\t\tinh,        /* attribute flags\t*/\n\t\t\t\t\t\targ,     \t/* thread param\t\t*/\n\t\t\t\t\t\tsp,         /* stack address\t*/\n\t\t\t\t\t\tlen);       /* stack size\t\t*/\n\t} else {\n\t\tsparams.sd.entry = entry;\n\t\tsparams.sd.inh = inh;\n\t\tsparams.sd.arg = arg;\n\t\tsparams.sd.sp = sp;\n\t\tsparams.sd.len = len;\n\t\tsparams.sd.pid = pid;\n\t\tsparams.sd.creator_pid = getpid();\n\t\t_PR_LOCK(sproc_list_lock);\n\t\tPR_APPEND_LINK(&sparams.links, &sproc_list);\n\t\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\t\tPR_ASSERT(rv == 1);\n\t\t_PR_UNLOCK(sproc_list_lock);\n\t\tblockproc(getpid());\n\t}\n}\n\n/*\n * _PR_MD_WAKEUP_PRIMORDIAL_CPU\n *\n *\t\twakeup cpu 0\n */\n\nvoid _PR_MD_WAKEUP_PRIMORDIAL_CPU()\n{\nchar data = '0';\nint rv;\n\n\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\tPR_ASSERT(rv == 1);\n}\n\n/*\n * _PR_MD_primordial_cpu\n *\n *\t\tprocess events that need to executed by the primordial cpu on each\n *\t\titeration through the idle loop\n */\n\nvoid _PR_MD_primordial_cpu()\n{\nPRCList *qp;\nsproc_params *sp;\nint pid;\n\n\t_PR_LOCK(sproc_list_lock);\n\twhile ((qp = sproc_list.next) != &sproc_list) {\n\t\tsp = SPROC_PARAMS_PTR(qp);\n\t\tPR_REMOVE_LINK(&sp->links);\n\t\tpid = sp->sd.creator_pid;\n\t\t(*(sp->sd.pid)) = sprocsp(sp->sd.entry,\t\t/* startup func    */\n\t\t\t\t\t\t\tsp->sd.inh,            \t/* attribute flags     */\n\t\t\t\t\t\t\tsp->sd.arg,     \t\t/* thread param     */\n\t\t\t\t\t\t\tsp->sd.sp,             \t/* stack address    */\n\t\t\t\t\t\t\tsp->sd.len);         \t/* stack size     */\n\t\tunblockproc(pid);\n\t}\n\t_PR_UNLOCK(sproc_list_lock);\n}\n\nPRStatus _MD_CreateThread(PRThread *thread, \nvoid (*start)(void *), \nPRThreadPriority priority, \nPRThreadScope scope, \nPRThreadState state, \nPRUint32 stackSize)\n{\n    typedef void (*SprocEntry) (void *, size_t);\n    SprocEntry spentry = (SprocEntry)start;\n    PRIntn is;\n\tPRThread *me = _PR_MD_CURRENT_THREAD();\t\n\tPRInt32 pid;\n\tPRStatus rv;\n\n\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t_PR_INTSOFF(is);\n    thread->md.cvar_pollsem_select = 0;\n    thread->flags |= _PR_GLOBAL_SCOPE;\n\n\tthread->md.cvar_pollsemfd = -1;\n\tif (new_poll_sem(&thread->md,0) == PR_FAILURE) {\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n\t\treturn PR_FAILURE;\n\t}\n\tthread->md.cvar_pollsemfd =\n\t\t_PR_OPEN_POLL_SEM(thread->md.cvar_pollsem);\n\tif ((thread->md.cvar_pollsemfd < 0)) {\n\t\tfree_poll_sem(&thread->md);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n\t\treturn PR_FAILURE;\n\t}\n\n    create_sproc(spentry,            /* startup func    */\n    \t\t\tPR_SALL,            /* attribute flags     */\n    \t\t\t(void *)thread,     /* thread param     */\n    \t\t\tNULL,               /* stack address    */\n    \t\t\tstackSize, &pid);         /* stack size     */\n    if (pid > 0) {\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs_created);\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs);\n\t\trv = PR_SUCCESS;\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n        return rv;\n    } else {\n        close(thread->md.cvar_pollsemfd);\n        thread->md.cvar_pollsemfd = -1;\n\t\tfree_poll_sem(&thread->md);\n        thread->md.cvar_pollsem = NULL;\n        _MD_ATOMIC_INCREMENT(&_pr_md_irix_sprocs_failed);\n\t\tif (!_PR_IS_NATIVE_THREAD(me))\n\t\t\t_PR_FAST_INTSON(is);\n        return PR_FAILURE;\n    }\n}\n\nvoid _MD_CleanThread(PRThread *thread)\n{\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n        close(thread->md.cvar_pollsemfd);\n        thread->md.cvar_pollsemfd = -1;\n\t\tfree_poll_sem(&thread->md);\n        thread->md.cvar_pollsem = NULL;\n    }\n}\n\nvoid _MD_SetPriority(_MDThread *thread, PRThreadPriority newPri)\n{\n    return;\n}\n\nextern void _MD_unix_terminate_waitpid_daemon(void);\n\nvoid\n_MD_CleanupBeforeExit(void)\n{\n    extern PRInt32    _pr_cpus_exit;\n\n    _MD_unix_terminate_waitpid_daemon();\n\n\t_pr_irix_exit_now = 1;\n    if (_pr_numCPU > 1) {\n        /*\n         * Set a global flag, and wakeup all cpus which will notice the flag\n         * and exit.\n         */\n        _pr_cpus_exit = getpid();\n        _MD_Wakeup_CPUs();\n        while(_pr_numCPU > 1) {\n            _PR_WAIT_SEM(_pr_irix_exit_sem);\n            _pr_numCPU--;\n        }\n    }\n    /*\n     * cause global threads on the recycle list to exit\n     */\n     _PR_DEADQ_LOCK;\n     if (_PR_NUM_DEADNATIVE != 0) {\n\tPRThread *thread;\n    \tPRCList *ptr;\n\n        ptr = _PR_DEADNATIVEQ.next;\n        while( ptr != &_PR_DEADNATIVEQ ) {\n        \tthread = _PR_THREAD_PTR(ptr);\n\t\t_MD_CVAR_POST_SEM(thread);\n                ptr = ptr->next;\n        } \n     }\n     _PR_DEADQ_UNLOCK;\n     while(_PR_NUM_DEADNATIVE > 1) {\n\t_PR_WAIT_SEM(_pr_irix_exit_sem);\n\t_PR_DEC_DEADNATIVE;\n     }\n}\n\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\nextern void __sgi_prda_procmask(int);\n#endif\n\nPRStatus\n_MD_InitAttachedThread(PRThread *thread, PRBool wakeup_parent)\n{\n\tPRStatus rv = PR_SUCCESS;\n\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n\t\tif (new_poll_sem(&thread->md,0) == PR_FAILURE) {\n\t\t\treturn PR_FAILURE;\n\t\t}\n\t\tthread->md.cvar_pollsemfd =\n\t\t\t_PR_OPEN_POLL_SEM(thread->md.cvar_pollsem);\n\t\tif ((thread->md.cvar_pollsemfd < 0)) {\n\t\t\tfree_poll_sem(&thread->md);\n\t\t\treturn PR_FAILURE;\n\t\t}\n\t\tif (_MD_InitThread(thread, PR_FALSE) == PR_FAILURE) {\n\t\t\tclose(thread->md.cvar_pollsemfd);\n\t\t\tthread->md.cvar_pollsemfd = -1;\n\t\t\tfree_poll_sem(&thread->md);\n\t\t\tthread->md.cvar_pollsem = NULL;\n\t\t\treturn PR_FAILURE;\n\t\t}\n    }\n\treturn rv;\n}\n\nPRStatus\n_MD_InitThread(PRThread *thread, PRBool wakeup_parent)\n{\n    struct sigaction sigact;\n\tPRStatus rv = PR_SUCCESS;\n\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n\t\tthread->md.id = getpid();\n        setblockproccnt(thread->md.id, 0);\n\t\t_MD_SET_SPROC_PID(getpid());\t\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\n\t\t/*\n\t\t * enable user-level processing of sigprocmask(); this is an\n\t\t * undocumented feature available in Irix 6.2, 6.3, 6.4 and 6.5\n\t\t */\n\t\t__sgi_prda_procmask(USER_LEVEL);\n#endif\n\t\t/*\n\t\t * set up SIGUSR1 handler; this is used to save state\n\t\t */\n\t\tsigact.sa_handler = save_context_and_block;\n\t\tsigact.sa_flags = SA_RESTART;\n\t\t/*\n\t\t * Must mask clock interrupts\n\t\t */\n\t\tsigact.sa_mask = timer_set;\n\t\tsigaction(SIGUSR1, &sigact, 0);\n\n\n\t\t/*\n\t\t * PR_SETABORTSIG is a new command implemented in a patch to\n\t\t * Irix 6.2, 6.3 and 6.4. This causes a signal to be sent to all\n\t\t * sprocs in the process when one of them terminates abnormally\n\t\t *\n\t\t */\n\t\tif (prctl(PR_SETABORTSIG, SIGKILL) < 0) {\n\t\t\t/*\n\t\t\t *  if (errno == EINVAL)\n\t\t\t *\n\t\t\t *\tPR_SETABORTSIG not supported under this OS.\n\t\t\t *\tYou may want to get a recent kernel rollup patch that\n\t\t\t *\tsupports this feature.\n\t\t\t */\n\t\t}\n\t\t/*\n\t\t * SIGCLD handler for detecting abormally-terminating\n\t\t * sprocs and for reaping sprocs\n\t\t */\n\t\tsigact.sa_handler = sigchld_handler;\n\t\tsigact.sa_flags = SA_RESTART;\n\t\tsigact.sa_mask = ints_off;\n\t\tsigaction(SIGCLD, &sigact, NULL);\n    }\n\treturn rv;\n}\n\n/*\n * PR_Cleanup should be executed on the primordial sproc; migrate the thread\n * to the primordial cpu\n */\n\nvoid _PR_MD_PRE_CLEANUP(PRThread *me)\n{\nPRIntn is;\n_PRCPU *cpu = _pr_primordialCPU;\n\n\tPR_ASSERT(cpu);\n\n\tme->flags |= _PR_BOUND_THREAD;\t\n\n\tif (me->cpu->id != 0) {\n\t\t_PR_INTSOFF(is);\n\t\t_PR_RUNQ_LOCK(cpu);\n\t\tme->cpu = cpu;\n\t\tme->state = _PR_RUNNABLE;\n\t\t_PR_ADD_RUNQ(me, cpu, me->priority);\n\t\t_PR_RUNQ_UNLOCK(cpu);\n\t\t_MD_Wakeup_CPUs();\n\n\t\t_PR_MD_SWITCH_CONTEXT(me);\n\n\t\t_PR_FAST_INTSON(is);\n\t\tPR_ASSERT(me->cpu->id == 0);\n\t}\n}\n\n/*\n * process exiting\n */\nPR_EXTERN(void ) _MD_exit(PRIntn status)\n{\nPRThread *me = _PR_MD_CURRENT_THREAD();\n\n\t/*\n\t * the exit code of the process is the exit code of the primordial\n\t * sproc\n\t */\n\tif (!_PR_IS_NATIVE_THREAD(me) && (_PR_MD_CURRENT_CPU()->id == 0)) {\n\t\t/*\n\t\t * primordial sproc case: call _exit directly\n\t\t * Cause SIGKILL to be sent to other sprocs\n\t\t */\n\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t_exit(status);\n\t} else {\n\t\tint rv;\n\t\tchar data;\n\t\tsigset_t set;\n\n\t\t/*\n\t\t * non-primordial sproc case: cause the primordial sproc, cpu 0,\n\t\t * to wakeup and call _exit\n\t\t */\n\t\t_pr_irix_process_exit = 1;\n\t\t_pr_irix_process_exit_code = status;\n\t\trv = write(_pr_irix_primoridal_cpu_fd[1], &data, 1);\n\t\tPR_ASSERT(rv == 1);\n\t\t/*\n\t\t * block all signals and wait for SIGKILL to terminate this sproc\n\t\t */\n\t\tsigfillset(&set);\n\t\tsigsuspend(&set);\n\t\t/*\n\t\t * this code doesn't (shouldn't) execute\n\t\t */\n\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t_exit(status);\n\t}\n}\n\n/*\n * Override the exit() function in libc to cause the process to exit\n * when the primodial/main nspr thread calls exit. Calls to exit by any\n * other thread simply result in a call to the exit function in libc.\n * The exit code of the process is the exit code of the primordial\n * sproc.\n */\n\nvoid exit(int status)\n{\nPRThread *me, *thr;\nPRCList *qp;\n\n\tif (!_pr_initialized)  {\n\t\tif (!libc_exit) {\n\n\t\t\tif (!libc_handle)\n\t\t\t\tlibc_handle = dlopen(\"libc.so\",RTLD_NOW);\n\t\t\tif (libc_handle)\n\t\t\t\tlibc_exit = (void (*)(int)) dlsym(libc_handle, \"exit\");\n\t\t}\n\t\tif (libc_exit)\n\t\t\t(*libc_exit)(status);\n\t\telse\n\t\t\t_exit(status);\n\t}\n\n\tme = _PR_MD_CURRENT_THREAD();\n\n\tif (me == NULL) \t\t/* detached thread */\n\t\t(*libc_exit)(status);\n\n\tPR_ASSERT(_PR_IS_NATIVE_THREAD(me) ||\n\t\t\t\t\t\t(_PR_MD_CURRENT_CPU())->id == me->cpu->id);\n\n\tif (me->flags & _PR_PRIMORDIAL) {\n\n\t\tme->flags |= _PR_BOUND_THREAD;\t\n\n\t\tPR_ASSERT((_PR_MD_CURRENT_CPU())->id == me->cpu->id);\n\t\tif (me->cpu->id != 0) {\n\t\t\t_PRCPU *cpu = _pr_primordialCPU;\n\t\t\tPRIntn is;\n\n\t\t\t_PR_INTSOFF(is);\n\t\t\t_PR_RUNQ_LOCK(cpu);\n\t\t\tme->cpu = cpu;\n\t\t\tme->state = _PR_RUNNABLE;\n\t\t\t_PR_ADD_RUNQ(me, cpu, me->priority);\n\t\t\t_PR_RUNQ_UNLOCK(cpu);\n\t\t\t_MD_Wakeup_CPUs();\n\n\t\t\t_PR_MD_SWITCH_CONTEXT(me);\n\n\t\t\t_PR_FAST_INTSON(is);\n\t\t}\n\n\t\tPR_ASSERT((_PR_MD_CURRENT_CPU())->id == 0);\n\n\t\tif (prctl(PR_GETNSHARE) > 1) {\n#define SPROC_EXIT_WAIT_TIME 5\n\t\t\tint sleep_cnt = SPROC_EXIT_WAIT_TIME;\n\n\t\t\t/*\n\t\t\t * sprocs still running; caue cpus and recycled global threads\n\t\t\t * to exit\n\t\t\t */\n\t\t\t_pr_irix_exit_now = 1;\n\t\t\tif (_pr_numCPU > 1) {\n\t\t\t\t_MD_Wakeup_CPUs();\n\t\t\t}\n\t\t\t _PR_DEADQ_LOCK;\n\t\t\t if (_PR_NUM_DEADNATIVE != 0) {\n\t\t\t\tPRThread *thread;\n\t\t\t\tPRCList *ptr;\n\n\t\t\t\tptr = _PR_DEADNATIVEQ.next;\n\t\t\t\twhile( ptr != &_PR_DEADNATIVEQ ) {\n\t\t\t\t\tthread = _PR_THREAD_PTR(ptr);\n\t\t\t\t\t_MD_CVAR_POST_SEM(thread);\n\t\t\t\t\tptr = ptr->next;\n\t\t\t\t} \n\t\t\t }\n\n\t\t\twhile (sleep_cnt-- > 0) {\n\t\t\t\tif (waitpid(0, NULL, WNOHANG) >= 0) \n\t\t\t\t\tsleep(1);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprctl(PR_SETEXITSIG, SIGKILL);\n\t\t}\n\t\t(*libc_exit)(status);\n\t} else {\n\t\t/*\n\t\t * non-primordial thread; simply call exit in libc.\n\t\t */\n\t\t(*libc_exit)(status);\n\t}\n}\n\n\nvoid\n_MD_InitRunningCPU(_PRCPU *cpu)\n{\n    extern int _pr_md_pipefd[2];\n\n    _MD_unix_init_running_cpu(cpu);\n    cpu->md.id = getpid();\n\t_MD_SET_SPROC_PID(getpid());\t\n\tif (_pr_md_pipefd[0] >= 0) {\n    \t_PR_IOQ_MAX_OSFD(cpu) = _pr_md_pipefd[0];\n#ifndef _PR_USE_POLL\n    \tFD_SET(_pr_md_pipefd[0], &_PR_FD_READ_SET(cpu));\n#endif\n\t}\n}\n\nvoid\n_MD_ExitThread(PRThread *thread)\n{\n    if (thread->flags & _PR_GLOBAL_SCOPE) {\n        _MD_ATOMIC_DECREMENT(&_pr_md_irix_sprocs);\n        _MD_CLEAN_THREAD(thread);\n        _MD_SET_CURRENT_THREAD(NULL);\n    }\n}\n\nvoid\n_MD_SuspendCPU(_PRCPU *cpu)\n{\n    PRInt32 rv;\n\n\tcpu->md.suspending_id = getpid();\n\trv = kill(cpu->md.id, SIGUSR1);\n\tPR_ASSERT(rv == 0);\n\t/*\n\t * now, block the current thread/cpu until woken up by the suspended\n\t * thread from it's SIGUSR1 signal handler\n\t */\n\tblockproc(getpid());\n\n}\n\nvoid\n_MD_ResumeCPU(_PRCPU *cpu)\n{\n    unblockproc(cpu->md.id);\n}\n\n#if 0\n/*\n * save the register context of a suspended sproc\n */\nvoid get_context(PRThread *thr)\n{\n    int len, fd;\n    char pidstr[24];\n    char path[24];\n\n    /*\n     * open the file corresponding to this process in procfs\n     */\n    sprintf(path,\"/proc/%s\",\"00000\");\n    len = strlen(path);\n    sprintf(pidstr,\"%d\",thr->md.id);\n    len -= strlen(pidstr);\n    sprintf(path + len,\"%s\",pidstr);\n    fd = open(path,O_RDONLY);\n    if (fd >= 0) {\n        (void) ioctl(fd, PIOCGREG, thr->md.gregs);\n        close(fd);\n    }\n    return;\n}\n#endif\t/* 0 */\n\nvoid\n_MD_SuspendThread(PRThread *thread)\n{\n    PRInt32 rv;\n\n    PR_ASSERT((thread->flags & _PR_GLOBAL_SCOPE) &&\n        _PR_IS_GCABLE_THREAD(thread));\n\n\tthread->md.suspending_id = getpid();\n\trv = kill(thread->md.id, SIGUSR1);\n\tPR_ASSERT(rv == 0);\n\t/*\n\t * now, block the current thread/cpu until woken up by the suspended\n\t * thread from it's SIGUSR1 signal handler\n\t */\n\tblockproc(getpid());\n}\n\nvoid\n_MD_ResumeThread(PRThread *thread)\n{\n    PR_ASSERT((thread->flags & _PR_GLOBAL_SCOPE) &&\n        _PR_IS_GCABLE_THREAD(thread));\n    (void)unblockproc(thread->md.id);\n}\n\n/*\n * return the set of processors available for scheduling procs in the\n * \"mask\" argument\n */\nPRInt32 _MD_GetThreadAffinityMask(PRThread *unused, PRUint32 *mask)\n{\n    PRInt32 nprocs, rv;\n    struct pda_stat *pstat;\n#define MAX_PROCESSORS    32\n\n    nprocs = sysmp(MP_NPROCS);\n    if (nprocs < 0)\n        return(-1);\n    pstat = (struct pda_stat*)PR_MALLOC(sizeof(struct pda_stat) * nprocs);\n    if (pstat == NULL)\n        return(-1);\n    rv = sysmp(MP_STAT, pstat);\n    if (rv < 0) {\n        PR_DELETE(pstat);\n        return(-1);\n    }\n    /*\n     * look at the first 32 cpus\n     */\n    nprocs = (nprocs > MAX_PROCESSORS) ? MAX_PROCESSORS : nprocs;\n    *mask = 0;\n    while (nprocs) {\n        if ((pstat->p_flags & PDAF_ENABLED) &&\n            !(pstat->p_flags & PDAF_ISOLATED)) {\n            *mask |= (1 << pstat->p_cpuid);\n        }\n        nprocs--;\n        pstat++;\n    }\n    return 0;\n}\n\nstatic char *_thr_state[] = {\n    \"UNBORN\",\n    \"RUNNABLE\",\n    \"RUNNING\",\n    \"LOCK_WAIT\",\n    \"COND_WAIT\",\n    \"JOIN_WAIT\",\n    \"IO_WAIT\",\n    \"SUSPENDED\",\n    \"DEAD\"\n};\n\nvoid _PR_List_Threads()\n{\n    PRThread *thr;\n    void *handle;\n    struct _PRCPU *cpu;\n    PRCList *qp;\n    int len, fd;\n    char pidstr[24];\n    char path[24];\n    prpsinfo_t pinfo;\n\n\n    printf(\"\\n%s %-s\\n\",\" \",\"LOCAL Threads\");\n    printf(\"%s %-s\\n\",\" \",\"----- -------\");\n    printf(\"%s %-14s %-10s %-12s %-3s %-10s %-10s %-12s\\n\\n\",\" \",\n        \"Thread\", \"State\", \"Wait-Handle\",\n        \"Cpu\",\"Stk-Base\",\"Stk-Sz\",\"SP\");\n    for (qp = _PR_ACTIVE_LOCAL_THREADQ().next;\n        qp != &_PR_ACTIVE_LOCAL_THREADQ(); qp = qp->next) {\n        thr = _PR_ACTIVE_THREAD_PTR(qp);\n        printf(\"%s 0x%-12x %-10s \",\" \",thr,_thr_state[thr->state]);\n        if (thr->state == _PR_LOCK_WAIT)\n            handle = thr->wait.lock;\n        else if (thr->state == _PR_COND_WAIT)\n            handle = thr->wait.cvar;\n        else\n            handle = NULL;\n        if (handle)\n            printf(\"0x%-10x \",handle);\n        else\n            printf(\"%-12s \",\" \");\n        printf(\"%-3d \",thr->cpu->id);\n        printf(\"0x%-8x \",thr->stack->stackBottom);\n        printf(\"0x%-8x \",thr->stack->stackSize);\n        printf(\"0x%-10x\\n\",thr->md.jb[JB_SP]);\n    }\n\n    printf(\"\\n%s %-s\\n\",\" \",\"GLOBAL Threads\");\n    printf(\"%s %-s\\n\",\" \",\"------ -------\");\n    printf(\"%s %-14s %-6s %-12s %-12s %-12s %-12s\\n\\n\",\" \",\"Thread\",\n        \"Pid\",\"State\",\"Wait-Handle\",\n        \"Stk-Base\",\"Stk-Sz\");\n\n    for (qp = _PR_ACTIVE_GLOBAL_THREADQ().next;\n        qp != &_PR_ACTIVE_GLOBAL_THREADQ(); qp = qp->next) {\n        thr = _PR_ACTIVE_THREAD_PTR(qp);\n        if (thr->cpu != NULL)\n            continue;        /* it is a cpu thread */\n        printf(\"%s 0x%-12x %-6d \",\" \",thr,thr->md.id);\n        /*\n         * check if the sproc is still running\n         * first call prctl(PR_GETSHMASK,pid) to check if\n         * the process is part of the share group (the pid\n         * could have been recycled by the OS)\n         */\n        if (prctl(PR_GETSHMASK,thr->md.id) < 0) {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n            continue;\n        }\n        /*\n         * Now, check if the sproc terminated and is in zombie\n         * state\n         */\n        sprintf(path,\"/proc/pinfo/%s\",\"00000\");\n        len = strlen(path);\n        sprintf(pidstr,\"%d\",thr->md.id);\n        len -= strlen(pidstr);\n        sprintf(path + len,\"%s\",pidstr);\n        fd = open(path,O_RDONLY);\n        if (fd >= 0) {\n            if (ioctl(fd, PIOCPSINFO, &pinfo) < 0)\n                printf(\"%-12s \",\"TERMINATED\");\n            else if (pinfo.pr_zomb)\n                printf(\"%-12s \",\"TERMINATED\");\n            else\n                printf(\"%-12s \",_thr_state[thr->state]);\n            close(fd);\n        } else {\n            printf(\"%-12s \",\"TERMINATED\");\n        }\n\n        if (thr->state == _PR_LOCK_WAIT)\n            handle = thr->wait.lock;\n        else if (thr->state == _PR_COND_WAIT)\n            handle = thr->wait.cvar;\n        else\n            handle = NULL;\n        if (handle)\n            printf(\"%-12x \",handle);\n        else\n            printf(\"%-12s \",\" \");\n        printf(\"0x%-10x \",thr->stack->stackBottom);\n        printf(\"0x%-10x\\n\",thr->stack->stackSize);\n    }\n\n    printf(\"\\n%s %-s\\n\",\" \",\"CPUs\");\n    printf(\"%s %-s\\n\",\" \",\"----\");\n    printf(\"%s %-14s %-6s %-12s \\n\\n\",\" \",\"Id\",\"Pid\",\"State\");\n\n\n    for (qp = _PR_CPUQ().next; qp != &_PR_CPUQ(); qp = qp->next) {\n        cpu = _PR_CPU_PTR(qp);\n        printf(\"%s %-14d %-6d \",\" \",cpu->id,cpu->md.id);\n        /*\n         * check if the sproc is still running\n         * first call prctl(PR_GETSHMASK,pid) to check if\n         * the process is part of the share group (the pid\n         * could have been recycled by the OS)\n         */\n        if (prctl(PR_GETSHMASK,cpu->md.id) < 0) {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n            continue;\n        }\n        /*\n         * Now, check if the sproc terminated and is in zombie\n         * state\n         */\n        sprintf(path,\"/proc/pinfo/%s\",\"00000\");\n        len = strlen(path);\n        sprintf(pidstr,\"%d\",cpu->md.id);\n        len -= strlen(pidstr);\n        sprintf(path + len,\"%s\",pidstr);\n        fd = open(path,O_RDONLY);\n        if (fd >= 0) {\n            if (ioctl(fd, PIOCPSINFO, &pinfo) < 0)\n                printf(\"%-12s\\n\",\"TERMINATED\");\n            else if (pinfo.pr_zomb)\n                printf(\"%-12s\\n\",\"TERMINATED\");\n            else\n                printf(\"%-12s\\n\",\"RUNNING\");\n            close(fd);\n        } else {\n            printf(\"%-12s\\n\",\"TERMINATED\");\n        }\n\n    }\n    fflush(stdout);\n}\n#endif /* defined(_PR_PTHREADS) */ \n\nPRWord *_MD_HomeGCRegisters(PRThread *t, int isCurrent, int *np)\n{\n#if !defined(_PR_PTHREADS)\n    if (isCurrent) {\n        (void) setjmp(t->md.jb);\n    }\n    *np = sizeof(t->md.jb) / sizeof(PRWord);\n    return (PRWord *) (t->md.jb);\n#else\n\t*np = 0;\n\treturn NULL;\n#endif\n}\n\nvoid _MD_EarlyInit(void)\n{\n#if !defined(_PR_PTHREADS)\n    char *eval;\n    int fd;\n\textern int __ateachexit(void (*func)(void));\n\n    sigemptyset(&ints_off);\n    sigaddset(&ints_off, SIGALRM);\n    sigaddset(&ints_off, SIGIO);\n    sigaddset(&ints_off, SIGCLD);\n\n    if (eval = getenv(\"_NSPR_TERMINATE_ON_ERROR\"))\n        _nspr_terminate_on_error = (0 == atoi(eval) == 0) ? PR_FALSE : PR_TRUE;\n\n    fd = open(\"/dev/zero\",O_RDWR , 0);\n    if (fd < 0) {\n        perror(\"open /dev/zero failed\");\n        exit(1);\n    }\n    /*\n     * Set up the sproc private data area.\n     * This region exists at the same address, _nspr_sproc_private, for\n     * every sproc, but each sproc gets a private copy of the region.\n     */\n    _nspr_sproc_private = (char*)mmap(0, _pr_pageSize, PROT_READ | PROT_WRITE,\n        MAP_PRIVATE| MAP_LOCAL, fd, 0);\n    if (_nspr_sproc_private == (void*)-1) {\n        perror(\"mmap /dev/zero failed\");\n        exit(1);\n    }\n\t_MD_SET_SPROC_PID(getpid());\t\n    close(fd);\n\t__ateachexit(irix_detach_sproc);\n#endif\n    _MD_IrixIntervalInit();\n}  /* _MD_EarlyInit */\n\nvoid _MD_IrixInit(void)\n{\n#if !defined(_PR_PTHREADS)\n    struct sigaction sigact;\n    PRThread *me = _PR_MD_CURRENT_THREAD();\n\tint rv;\n\n#ifdef _PR_HAVE_SGI_PRDA_PROCMASK\n\t/*\n\t * enable user-level processing of sigprocmask(); this is an undocumented\n\t * feature available in Irix 6.2, 6.3, 6.4 and 6.5\n\t */\n\t__sgi_prda_procmask(USER_LEVEL);\n#endif\n\n\t/*\n\t * set up SIGUSR1 handler; this is used to save state\n\t * during PR_SuspendAll\n\t */\n\tsigact.sa_handler = save_context_and_block;\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_mask = ints_off;\n\tsigaction(SIGUSR1, &sigact, 0);\n\n    /*\n     * Change the name of the core file from core to core.pid,\n     * This is inherited by the sprocs created by this process\n     */\n#ifdef PR_COREPID\n    prctl(PR_COREPID, 0, 1);\n#endif\n    /*\n     * Irix-specific terminate on error processing\n     */\n\t/*\n\t * PR_SETABORTSIG is a new command implemented in a patch to\n\t * Irix 6.2, 6.3 and 6.4. This causes a signal to be sent to all\n\t * sprocs in the process when one of them terminates abnormally\n\t *\n\t */\n\tif (prctl(PR_SETABORTSIG, SIGKILL) < 0) {\n\t\t/*\n\t\t *  if (errno == EINVAL)\n\t\t *\n\t\t *\tPR_SETABORTSIG not supported under this OS.\n\t\t *\tYou may want to get a recent kernel rollup patch that\n\t\t *\tsupports this feature.\n\t\t *\n\t\t */\n\t}\n\t/*\n\t * PR_SETEXITSIG -  send the SIGCLD signal to the parent\n\t *            sproc when any sproc terminates\n\t *\n\t *    This is used to cause the entire application to\n\t *    terminate when    any sproc terminates abnormally by\n\t *     receipt of a SIGSEGV, SIGBUS or SIGABRT signal.\n\t *    If this is not done, the application may seem\n\t *     \"hung\" to the user because the other sprocs may be\n\t *    waiting for resources held by the\n\t *    abnormally-terminating sproc.\n\t */\n\tprctl(PR_SETEXITSIG, 0);\n\n\tsigact.sa_handler = sigchld_handler;\n\tsigact.sa_flags = SA_RESTART;\n\tsigact.sa_mask = ints_off;\n\tsigaction(SIGCLD, &sigact, NULL);\n\n    /*\n     * setup stack fields for the primordial thread\n     */\n    me->stack->stackSize = prctl(PR_GETSTACKSIZE);\n    me->stack->stackBottom = me->stack->stackTop - me->stack->stackSize;\n\n    rv = pipe(_pr_irix_primoridal_cpu_fd);\n    PR_ASSERT(rv == 0);\n#ifndef _PR_USE_POLL\n    _PR_IOQ_MAX_OSFD(me->cpu) = _pr_irix_primoridal_cpu_fd[0];\n    FD_SET(_pr_irix_primoridal_cpu_fd[0], &_PR_FD_READ_SET(me->cpu));\n#endif\n\n\tlibc_handle = dlopen(\"libc.so\",RTLD_NOW);\n\tPR_ASSERT(libc_handle != NULL);\n\tlibc_exit = (void (*)(int)) dlsym(libc_handle, \"exit\");\n\tPR_ASSERT(libc_exit != NULL);\n\t/* dlclose(libc_handle); */\n\n#endif /* _PR_PTHREADS */\n\n    _PR_UnixInit();\n}\n\n/**************************************************************************/\n/************** code and such for NSPR 2.0's interval times ***************/\n/**************************************************************************/\n\n#define PR_PSEC_PER_SEC 1000000000000ULL  /* 10^12 */\n\n#ifndef SGI_CYCLECNTR_SIZE\n#define SGI_CYCLECNTR_SIZE      165     /* Size user needs to use to read CC */\n#endif\n\nstatic PRIntn mmem_fd = -1;\nstatic PRIntn clock_width = 0;\nstatic void *iotimer_addr = NULL;\nstatic PRUint32 pr_clock_mask = 0;\nstatic PRUint32 pr_clock_shift = 0;\nstatic PRIntervalTime pr_ticks = 0;\nstatic PRUint32 pr_clock_granularity = 1;\nstatic PRUint32 pr_previous = 0, pr_residual = 0;\nstatic PRUint32 pr_ticks_per_second = 0;\n\nextern PRIntervalTime _PR_UNIX_GetInterval(void);\nextern PRIntervalTime _PR_UNIX_TicksPerSecond(void);\n\nstatic void _MD_IrixIntervalInit(void)\n{\n    /*\n     * As much as I would like, the service available through this\n     * interface on R3000's (aka, IP12) just isn't going to make it.\n     * The register is only 24 bits wide, and rolls over at a verocious\n     * rate.\n     */\n    PRUint32 one_tick = 0;\n    struct utsname utsinfo;\n    uname(&utsinfo);\n    if ((strncmp(\"IP12\", utsinfo.machine, 4) != 0)\n        && ((mmem_fd = open(\"/dev/mmem\", O_RDONLY)) != -1))\n    {\n        int poffmask = getpagesize() - 1;\n        __psunsigned_t phys_addr, raddr, cycleval;\n\n        phys_addr = syssgi(SGI_QUERY_CYCLECNTR, &cycleval);\n        raddr = phys_addr & ~poffmask;\n        iotimer_addr = mmap(\n            0, poffmask, PROT_READ, MAP_PRIVATE, mmem_fd, (__psint_t)raddr);\n\n        clock_width = syssgi(SGI_CYCLECNTR_SIZE);\n        if (clock_width < 0)\n        {\n            /* \n             * We must be executing on a 6.0 or earlier system, since the\n             * SGI_CYCLECNTR_SIZE call is not supported.\n             * \n             * The only pre-6.1 platforms with 64-bit counters are\n             * IP19 and IP21 (Challenge, PowerChallenge, Onyx).\n             */\n            if (!strncmp(utsinfo.machine, \"IP19\", 4) ||\n                !strncmp(utsinfo.machine, \"IP21\", 4))\n                clock_width = 64;\n            else\n                clock_width = 32;\n        }\n\n        /*\n         * 'cycleval' is picoseconds / increment of the counter.\n         * I'm pushing for a tick to be 100 microseconds, 10^(-4).\n         * That leaves 10^(-8) left over, or 10^8 / cycleval.\n         * Did I do that right?\n         */\n\n        one_tick =  100000000UL / cycleval ;  /* 100 microseconds */\n\n        while (0 != one_tick)\n        {\n            pr_clock_shift += 1;\n            one_tick = one_tick >> 1;\n            pr_clock_granularity = pr_clock_granularity << 1;\n        }\n        pr_clock_mask = pr_clock_granularity - 1;  /* to make a mask out of it */\n        pr_ticks_per_second = PR_PSEC_PER_SEC\n                / ((PRUint64)pr_clock_granularity * (PRUint64)cycleval);\n            \n        iotimer_addr = (void*)\n            ((__psunsigned_t)iotimer_addr + (phys_addr & poffmask));\n    }\n    else\n    {\n        pr_ticks_per_second = _PR_UNIX_TicksPerSecond();\n    }\n}  /* _MD_IrixIntervalInit */\n\nPRIntervalTime _MD_IrixIntervalPerSec(void)\n{\n    return pr_ticks_per_second;\n}\n\nPRIntervalTime _MD_IrixGetInterval(void)\n{\n    if (mmem_fd != -1)\n    {\n        if (64 == clock_width)\n        {\n            PRUint64 temp = *(PRUint64*)iotimer_addr;\n            pr_ticks = (PRIntervalTime)(temp >> pr_clock_shift);\n        }\n        else\n        {\n            PRIntervalTime ticks = pr_ticks;\n            PRUint32 now = *(PRUint32*)iotimer_addr, temp;\n            PRUint32 residual = pr_residual, previous = pr_previous;\n\n            temp = now - previous + residual;\n            residual = temp & pr_clock_mask;\n            ticks += temp >> pr_clock_shift;\n\n            pr_previous = now;\n            pr_residual = residual;\n            pr_ticks = ticks;\n        }\n    }\n    else\n    {\n        /*\n         * No fast access. Use the time of day clock. This isn't the\n         * right answer since this clock can get set back, tick at odd\n         * rates, and it's expensive to acqurie.\n         */\n        pr_ticks = _PR_UNIX_GetInterval();\n    }\n    return pr_ticks;\n}  /* _MD_IrixGetInterval */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-nspr-4.13.1-vntc7ai7kqzc4riwwqstomskyuugrvqz/spack-src/nspr/pr/src/md/unix/uxproces.c": "/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"primpl.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n#if defined(AIX)\n#include <dlfcn.h>  /* For dlopen, dlsym, dlclose */\n#endif\n\n#if defined(DARWIN)\n#if defined(HAVE_CRT_EXTERNS_H)\n#include <crt_externs.h>\n#endif\n#else\nPR_IMPORT_DATA(char **) environ;\n#endif\n\n/*\n * HP-UX 9 doesn't have the SA_RESTART flag.\n */\n#ifndef SA_RESTART\n#define SA_RESTART 0\n#endif\n\n/*\n **********************************************************************\n *\n * The Unix process routines\n *\n **********************************************************************\n */\n\n#define _PR_SIGNALED_EXITSTATUS 256\n\ntypedef enum pr_PidState {\n    _PR_PID_DETACHED,\n    _PR_PID_REAPED,\n    _PR_PID_WAITING\n} pr_PidState;\n\ntypedef struct pr_PidRecord {\n    pid_t pid;\n    int exitStatus;\n    pr_PidState state;\n    PRCondVar *reapedCV;\n    struct pr_PidRecord *next;\n} pr_PidRecord;\n\n/*\n * Irix sprocs and LinuxThreads are actually a kind of processes\n * that can share the virtual address space and file descriptors.\n */\n#if (defined(IRIX) && !defined(_PR_PTHREADS)) \\\n        || ((defined(LINUX) || defined(__GNU__) || defined(__GLIBC__)) \\\n        && defined(_PR_PTHREADS))\n#define _PR_SHARE_CLONES\n#endif\n\n/*\n * The macro _PR_NATIVE_THREADS indicates that we are\n * using native threads only, so waitpid() blocks just the\n * calling thread, not the process.  In this case, the waitpid\n * daemon thread can safely block in waitpid().  So we don't\n * need to catch SIGCHLD, and the pipe to unblock PR_Poll() is\n * also not necessary.\n */\n\n#if defined(_PR_GLOBAL_THREADS_ONLY) \\\n\t|| (defined(_PR_PTHREADS) \\\n\t&& !defined(LINUX) && !defined(__GNU__) && !defined(__GLIBC__))\n#define _PR_NATIVE_THREADS\n#endif\n\n/*\n * All the static variables used by the Unix process routines are\n * collected in this structure.\n */\n\nstatic struct {\n    PRCallOnceType once;\n    PRThread *thread;\n    PRLock *ml;\n#if defined(_PR_NATIVE_THREADS)\n    PRInt32 numProcs;\n    PRCondVar *cv;\n#else\n    int pipefd[2];\n#endif\n    pr_PidRecord **pidTable;\n\n#ifdef _PR_SHARE_CLONES\n    struct pr_CreateProcOp *opHead, *opTail;\n#endif\n\n#ifdef AIX\n    pid_t (*forkptr)(void);  /* Newer versions of AIX (starting in 4.3.2)\n                              * have f_fork, which is faster than the\n                              * regular fork in a multithreaded process\n                              * because it skips calling the fork handlers.\n                              * So we look up the f_fork symbol to see if\n                              * it's available and fall back on fork.\n                              */\n#endif /* AIX */\n} pr_wp;\n\n#ifdef _PR_SHARE_CLONES\nstatic int pr_waitpid_daemon_exit;\n\nvoid\n_MD_unix_terminate_waitpid_daemon(void)\n{\n    if (pr_wp.thread) {\n        pr_waitpid_daemon_exit = 1;\n        write(pr_wp.pipefd[1], \"\", 1);\n        PR_JoinThread(pr_wp.thread);\n    }\n}\n#endif\n\nstatic PRStatus _MD_InitProcesses(void);\n#if !defined(_PR_NATIVE_THREADS)\nstatic void pr_InstallSigchldHandler(void);\n#endif\n\nstatic PRProcess *\nForkAndExec(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    PRProcess *process;\n    int nEnv, idx;\n    char *const *childEnvp;\n    char **newEnvp = NULL;\n    int flags;\n\n    process = PR_NEW(PRProcess);\n    if (!process) {\n        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n        return NULL;\n    }\n\n    childEnvp = envp;\n    if (attr && attr->fdInheritBuffer) {\n        PRBool found = PR_FALSE;\n\n        if (NULL == childEnvp) {\n#ifdef DARWIN\n#ifdef HAVE_CRT_EXTERNS_H\n            childEnvp = *(_NSGetEnviron());\n#else\n            /* _NSGetEnviron() is not available on iOS. */\n            PR_DELETE(process);\n            PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);\n            return NULL;\n#endif\n#else\n            childEnvp = environ;\n#endif\n        }\n\n        for (nEnv = 0; childEnvp[nEnv]; nEnv++) {\n        }\n        newEnvp = (char **) PR_MALLOC((nEnv + 2) * sizeof(char *));\n        if (NULL == newEnvp) {\n            PR_DELETE(process);\n            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n            return NULL;\n        }\n        for (idx = 0; idx < nEnv; idx++) {\n            newEnvp[idx] = childEnvp[idx];\n            if (!found && !strncmp(newEnvp[idx], \"NSPR_INHERIT_FDS=\", 17)) {\n                newEnvp[idx] = attr->fdInheritBuffer;\n                found = PR_TRUE;\n            }\n        }\n        if (!found) {\n            newEnvp[idx++] = attr->fdInheritBuffer;\n        }\n        newEnvp[idx] = NULL;\n        childEnvp = newEnvp;\n    }\n\n#ifdef AIX\n    process->md.pid = (*pr_wp.forkptr)();\n#elif defined(NTO) || defined(SYMBIAN)\n    /*\n     * fork() & exec() does not work in a multithreaded process.\n     * Use spawn() instead.\n     */\n    {\n        int fd_map[3] = { 0, 1, 2 };\n\n        if (attr) {\n            if (attr->stdinFd && attr->stdinFd->secret->md.osfd != 0) {\n                fd_map[0] = dup(attr->stdinFd->secret->md.osfd);\n                flags = fcntl(fd_map[0], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[0], F_SETFL, flags & ~O_NONBLOCK);\n            }\n            if (attr->stdoutFd && attr->stdoutFd->secret->md.osfd != 1) {\n                fd_map[1] = dup(attr->stdoutFd->secret->md.osfd);\n                flags = fcntl(fd_map[1], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[1], F_SETFL, flags & ~O_NONBLOCK);\n            }\n            if (attr->stderrFd && attr->stderrFd->secret->md.osfd != 2) {\n                fd_map[2] = dup(attr->stderrFd->secret->md.osfd);\n                flags = fcntl(fd_map[2], F_GETFL, 0);\n                if (flags & O_NONBLOCK)\n                    fcntl(fd_map[2], F_SETFL, flags & ~O_NONBLOCK);\n            }\n\n            PR_ASSERT(attr->currentDirectory == NULL);  /* not implemented */\n        }\n\n#ifdef SYMBIAN\n        /* In Symbian OS, we use posix_spawn instead of fork() and exec() */\n        posix_spawn(&(process->md.pid), path, NULL, NULL, argv, childEnvp);\n#else\n        process->md.pid = spawn(path, 3, fd_map, NULL, argv, childEnvp);\n#endif\n\n        if (fd_map[0] != 0)\n            close(fd_map[0]);\n        if (fd_map[1] != 1)\n            close(fd_map[1]);\n        if (fd_map[2] != 2)\n            close(fd_map[2]);\n    }\n#else\n    process->md.pid = fork();\n#endif\n    if ((pid_t) -1 == process->md.pid) {\n        PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, errno);\n        PR_DELETE(process);\n        if (newEnvp) {\n            PR_DELETE(newEnvp);\n        }\n        return NULL;\n    } else if (0 == process->md.pid) {  /* the child process */\n        /*\n         * If the child process needs to exit, it must call _exit().\n         * Do not call exit(), because exit() will flush and close\n         * the standard I/O file descriptors, and hence corrupt\n         * the parent process's standard I/O data structures.\n         */\n\n#if !defined(NTO) && !defined(SYMBIAN)\n        if (attr) {\n            /* the osfd's to redirect stdin, stdout, and stderr to */\n            int in_osfd = -1, out_osfd = -1, err_osfd = -1;\n\n            if (attr->stdinFd\n                    && attr->stdinFd->secret->md.osfd != 0) {\n                in_osfd = attr->stdinFd->secret->md.osfd;\n                if (dup2(in_osfd, 0) != 0) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(0, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(0, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (attr->stdoutFd\n                    && attr->stdoutFd->secret->md.osfd != 1) {\n                out_osfd = attr->stdoutFd->secret->md.osfd;\n                if (dup2(out_osfd, 1) != 1) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(1, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(1, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (attr->stderrFd\n                    && attr->stderrFd->secret->md.osfd != 2) {\n                err_osfd = attr->stderrFd->secret->md.osfd;\n                if (dup2(err_osfd, 2) != 2) {\n                    _exit(1);  /* failed */\n                }\n                flags = fcntl(2, F_GETFL, 0);\n                if (flags & O_NONBLOCK) {\n                    fcntl(2, F_SETFL, flags & ~O_NONBLOCK);\n                }\n            }\n            if (in_osfd != -1) {\n                close(in_osfd);\n            }\n            if (out_osfd != -1 && out_osfd != in_osfd) {\n                close(out_osfd);\n            }\n            if (err_osfd != -1 && err_osfd != in_osfd\n                    && err_osfd != out_osfd) {\n                close(err_osfd);\n            }\n            if (attr->currentDirectory) {\n                if (chdir(attr->currentDirectory) < 0) {\n                    _exit(1);  /* failed */\n                }\n            }\n        }\n\n        if (childEnvp) {\n            (void)execve(path, argv, childEnvp);\n        } else {\n            /* Inherit the environment of the parent. */\n            (void)execv(path, argv);\n        }\n        /* Whoops! It returned. That's a bad sign. */\n        _exit(1);\n#endif /* !NTO */\n    }\n\n    if (newEnvp) {\n        PR_DELETE(newEnvp);\n    }\n\n#if defined(_PR_NATIVE_THREADS)\n    PR_Lock(pr_wp.ml);\n    if (0 == pr_wp.numProcs++) {\n        PR_NotifyCondVar(pr_wp.cv);\n    }\n    PR_Unlock(pr_wp.ml);\n#endif\n    return process;\n}\n\n#ifdef _PR_SHARE_CLONES\n\nstruct pr_CreateProcOp {\n    const char *path;\n    char *const *argv;\n    char *const *envp;\n    const PRProcessAttr *attr;\n    PRProcess *process;\n    PRErrorCode prerror;\n    PRInt32 oserror;\n    PRBool done;\n    PRCondVar *doneCV;\n    struct pr_CreateProcOp *next;\n};\n\nPRProcess *\n_MD_CreateUnixProcess(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    struct pr_CreateProcOp *op;\n    PRProcess *proc;\n    int rv;\n\n    if (PR_CallOnce(&pr_wp.once, _MD_InitProcesses) == PR_FAILURE) {\n\treturn NULL;\n    }\n\n    op = PR_NEW(struct pr_CreateProcOp);\n    if (NULL == op) {\n\tPR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\treturn NULL;\n    }\n    op->path = path;\n    op->argv = argv;\n    op->envp = envp;\n    op->attr = attr;\n    op->done = PR_FALSE;\n    op->doneCV = PR_NewCondVar(pr_wp.ml);\n    if (NULL == op->doneCV) {\n\tPR_DELETE(op);\n\treturn NULL;\n    }\n    PR_Lock(pr_wp.ml);\n\n    /* add to the tail of op queue */\n    op->next = NULL;\n    if (pr_wp.opTail) {\n\tpr_wp.opTail->next = op;\n\tpr_wp.opTail = op;\n    } else {\n\tPR_ASSERT(NULL == pr_wp.opHead);\n\tpr_wp.opHead = pr_wp.opTail = op;\n    }\n\n    /* wake up the daemon thread */\n    do {\n        rv = write(pr_wp.pipefd[1], \"\", 1);\n    } while (-1 == rv && EINTR == errno);\n\n    while (op->done == PR_FALSE) {\n\tPR_WaitCondVar(op->doneCV, PR_INTERVAL_NO_TIMEOUT);\n    }\n    PR_Unlock(pr_wp.ml);\n    PR_DestroyCondVar(op->doneCV);\n    proc = op->process;\n    if (!proc) {\n\tPR_SetError(op->prerror, op->oserror);\n    }\n    PR_DELETE(op);\n    return proc;\n}\n\n#else  /* ! _PR_SHARE_CLONES */\n\nPRProcess *\n_MD_CreateUnixProcess(\n    const char *path,\n    char *const *argv,\n    char *const *envp,\n    const PRProcessAttr *attr)\n{\n    if (PR_CallOnce(&pr_wp.once, _MD_InitProcesses) == PR_FAILURE) {\n\treturn NULL;\n    }\n    return ForkAndExec(path, argv, envp, attr);\n}  /* _MD_CreateUnixProcess */\n\n#endif  /* _PR_SHARE_CLONES */\n\n/*\n * The pid table is a hashtable.\n *\n * The number of buckets in the hashtable (NBUCKETS) must be a power of 2.\n */\n#define NBUCKETS_LOG2 6\n#define NBUCKETS (1 << NBUCKETS_LOG2)\n#define PID_HASH_MASK ((pid_t) (NBUCKETS - 1))\n\nstatic pr_PidRecord *\nFindPidTable(pid_t pid)\n{\n    pr_PidRecord *pRec;\n    int keyHash = (int) (pid & PID_HASH_MASK);\n\n    pRec =  pr_wp.pidTable[keyHash];\n    while (pRec) {\n\tif (pRec->pid == pid) {\n\t    break;\n\t}\n\tpRec = pRec->next;\n    }\n    return pRec;\n}\n\nstatic void\nInsertPidTable(pr_PidRecord *pRec)\n{\n    int keyHash = (int) (pRec->pid & PID_HASH_MASK);\n\n    pRec->next = pr_wp.pidTable[keyHash];\n    pr_wp.pidTable[keyHash] = pRec;\n}\n\nstatic void\nDeletePidTable(pr_PidRecord *pRec)\n{\n    int keyHash = (int) (pRec->pid & PID_HASH_MASK);\n\n    if (pr_wp.pidTable[keyHash] == pRec) {\n\tpr_wp.pidTable[keyHash] = pRec->next;\n    } else {\n\tpr_PidRecord *pred, *cur;  /* predecessor and current */\n\n\tpred = pr_wp.pidTable[keyHash];\n\tcur = pred->next;\n\twhile (cur) {\n\t    if (cur == pRec) {\n\t\tpred->next = cur->next;\n\t\tbreak;\n            }\n\t    pred = cur;\n\t    cur = cur->next;\n        }\n\tPR_ASSERT(cur != NULL);\n    }\n}\n\nstatic int\nExtractExitStatus(int rawExitStatus)\n{\n    /*\n     * We did not specify the WCONTINUED and WUNTRACED options\n     * for waitpid, so these two events should not be reported.\n     */\n    PR_ASSERT(!WIFSTOPPED(rawExitStatus));\n#ifdef WIFCONTINUED\n    PR_ASSERT(!WIFCONTINUED(rawExitStatus));\n#endif\n    if (WIFEXITED(rawExitStatus)) {\n\treturn WEXITSTATUS(rawExitStatus);\n    } else {\n\tPR_ASSERT(WIFSIGNALED(rawExitStatus));\n\treturn _PR_SIGNALED_EXITSTATUS;\n    }\n}\n\nstatic void\nProcessReapedChildInternal(pid_t pid, int status)\n{\n    pr_PidRecord *pRec;\n\n    pRec = FindPidTable(pid);\n    if (NULL == pRec) {\n        pRec = PR_NEW(pr_PidRecord);\n        pRec->pid = pid;\n        pRec->state = _PR_PID_REAPED;\n        pRec->exitStatus = ExtractExitStatus(status);\n        pRec->reapedCV = NULL;\n        InsertPidTable(pRec);\n    } else {\n        PR_ASSERT(pRec->state != _PR_PID_REAPED);\n        if (_PR_PID_DETACHED == pRec->state) {\n            PR_ASSERT(NULL == pRec->reapedCV);\n            DeletePidTable(pRec);\n            PR_DELETE(pRec);\n        } else {\n            PR_ASSERT(_PR_PID_WAITING == pRec->state);\n            PR_ASSERT(NULL != pRec->reapedCV);\n            pRec->exitStatus = ExtractExitStatus(status);\n            pRec->state = _PR_PID_REAPED;\n            PR_NotifyCondVar(pRec->reapedCV);\n        }\n    }\n}\n\n#if defined(_PR_NATIVE_THREADS)\n\n/*\n * If all the threads are native threads, the daemon thread is\n * simpler.  We don't need to catch the SIGCHLD signal.  We can\n * just have the daemon thread block in waitpid().\n */\n\nstatic void WaitPidDaemonThread(void *unused)\n{\n    pid_t pid;\n    int status;\n\n    while (1) {\n        PR_Lock(pr_wp.ml);\n        while (0 == pr_wp.numProcs) {\n            PR_WaitCondVar(pr_wp.cv, PR_INTERVAL_NO_TIMEOUT);\n        }\n        PR_Unlock(pr_wp.ml);\n\n\twhile (1) {\n\t    do {\n\t        pid = waitpid((pid_t) -1, &status, 0);\n\t    } while ((pid_t) -1 == pid && EINTR == errno);\n\n            /*\n             * waitpid() cannot return 0 because we did not invoke it\n             * with the WNOHANG option.\n             */ \n\t    PR_ASSERT(0 != pid);\n\n            /*\n             * The only possible error code is ECHILD.  But if we do\n             * our accounting correctly, we should only call waitpid()\n             * when there is a child process to wait for.\n             */\n            PR_ASSERT((pid_t) -1 != pid);\n\t    if ((pid_t) -1 == pid) {\n                break;\n            }\n\n\t    PR_Lock(pr_wp.ml);\n            ProcessReapedChildInternal(pid, status);\n            pr_wp.numProcs--;\n            while (0 == pr_wp.numProcs) {\n                PR_WaitCondVar(pr_wp.cv, PR_INTERVAL_NO_TIMEOUT);\n            }\n\t    PR_Unlock(pr_wp.ml);\n\t}\n    }\n}\n\n#else /* _PR_NATIVE_THREADS */\n\nstatic void WaitPidDaemonThread(void *unused)\n{\n    PRPollDesc pd;\n    PRFileDesc *fd;\n    int rv;\n    char buf[128];\n    pid_t pid;\n    int status;\n#ifdef _PR_SHARE_CLONES\n    struct pr_CreateProcOp *op;\n#endif\n\n#ifdef _PR_SHARE_CLONES\n    pr_InstallSigchldHandler();\n#endif\n\n    fd = PR_ImportFile(pr_wp.pipefd[0]);\n    PR_ASSERT(NULL != fd);\n    pd.fd = fd;\n    pd.in_flags = PR_POLL_READ;\n\n    while (1) {\n        rv = PR_Poll(&pd, 1, PR_INTERVAL_NO_TIMEOUT);\n        PR_ASSERT(1 == rv);\n\n#ifdef _PR_SHARE_CLONES\n        if (pr_waitpid_daemon_exit) {\n            return;\n        }\n\tPR_Lock(pr_wp.ml);\n#endif\n\t    \n        do {\n            rv = read(pr_wp.pipefd[0], buf, sizeof(buf));\n        } while (sizeof(buf) == rv || (-1 == rv && EINTR == errno));\n\n#ifdef _PR_SHARE_CLONES\n\tPR_Unlock(pr_wp.ml);\n\twhile ((op = pr_wp.opHead) != NULL) {\n\t    op->process = ForkAndExec(op->path, op->argv,\n\t\t    op->envp, op->attr);\n\t    if (NULL == op->process) {\n\t\top->prerror = PR_GetError();\n\t\top->oserror = PR_GetOSError();\n\t    }\n\t    PR_Lock(pr_wp.ml);\n\t    pr_wp.opHead = op->next;\n\t    if (NULL == pr_wp.opHead) {\n\t\tpr_wp.opTail = NULL;\n\t    }\n\t    op->done = PR_TRUE;\n\t    PR_NotifyCondVar(op->doneCV);\n\t    PR_Unlock(pr_wp.ml);\n\t}\n#endif\n\n\twhile (1) {\n\t    do {\n\t        pid = waitpid((pid_t) -1, &status, WNOHANG);\n\t    } while ((pid_t) -1 == pid && EINTR == errno);\n\t    if (0 == pid) break;\n\t    if ((pid_t) -1 == pid) {\n\t\t/* must be because we have no child processes */\n\t\tPR_ASSERT(ECHILD == errno);\n\t\tbreak;\n            }\n\n\t    PR_Lock(pr_wp.ml);\n            ProcessReapedChildInternal(pid, status);\n\t    PR_Unlock(pr_wp.ml);\n\t}\n    }\n}\n\nstatic void pr_SigchldHandler(int sig)\n{\n    int errnoCopy;\n    int rv;\n\n    errnoCopy = errno;\n\n    do {\n        rv = write(pr_wp.pipefd[1], \"\", 1);\n    } while (-1 == rv && EINTR == errno);\n\n#ifdef DEBUG\n    if (-1 == rv && EAGAIN != errno && EWOULDBLOCK != errno) {\n        char *msg = \"cannot write to pipe\\n\";\n        write(2, msg, strlen(msg) + 1);\n        _exit(1);\n    }\n#endif\n\n    errno = errnoCopy;\n}\n\nstatic void pr_InstallSigchldHandler()\n{\n#if defined(HPUX) && defined(_PR_DCETHREADS)\n#error \"HP-UX DCE threads have their own SIGCHLD handler\"\n#endif\n\n    struct sigaction act, oact;\n    int rv;\n\n    act.sa_handler = pr_SigchldHandler;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NOCLDSTOP | SA_RESTART;\n    rv = sigaction(SIGCHLD, &act, &oact);\n    PR_ASSERT(0 == rv);\n    /* Make sure we are not overriding someone else's SIGCHLD handler */\n#ifndef _PR_SHARE_CLONES\n    PR_ASSERT(oact.sa_handler == SIG_DFL);\n#endif\n}\n\n#endif  /* !defined(_PR_NATIVE_THREADS) */\n\nstatic PRStatus _MD_InitProcesses(void)\n{\n#if !defined(_PR_NATIVE_THREADS)\n    int rv;\n    int flags;\n#endif\n\n#ifdef AIX\n    {\n        void *handle = dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);\n        pr_wp.forkptr = (pid_t (*)(void)) dlsym(handle, \"f_fork\");\n        if (!pr_wp.forkptr) {\n            pr_wp.forkptr = fork;\n        }\n        dlclose(handle);\n    }\n#endif /* AIX */\n\n    pr_wp.ml = PR_NewLock();\n    PR_ASSERT(NULL != pr_wp.ml);\n\n#if defined(_PR_NATIVE_THREADS)\n    pr_wp.numProcs = 0;\n    pr_wp.cv = PR_NewCondVar(pr_wp.ml);\n    PR_ASSERT(NULL != pr_wp.cv);\n#else\n    rv = pipe(pr_wp.pipefd);\n    PR_ASSERT(0 == rv);\n    flags = fcntl(pr_wp.pipefd[0], F_GETFL, 0);\n    fcntl(pr_wp.pipefd[0], F_SETFL, flags | O_NONBLOCK);\n    flags = fcntl(pr_wp.pipefd[1], F_GETFL, 0);\n    fcntl(pr_wp.pipefd[1], F_SETFL, flags | O_NONBLOCK);\n\n#ifndef _PR_SHARE_CLONES\n    pr_InstallSigchldHandler();\n#endif\n#endif  /* !_PR_NATIVE_THREADS */\n\n    pr_wp.thread = PR_CreateThread(PR_SYSTEM_THREAD,\n\t    WaitPidDaemonThread, NULL, PR_PRIORITY_NORMAL,\n#ifdef _PR_SHARE_CLONES\n            PR_GLOBAL_THREAD,\n#else\n\t    PR_LOCAL_THREAD,\n#endif\n\t    PR_JOINABLE_THREAD, 0);\n    PR_ASSERT(NULL != pr_wp.thread);\n\n    pr_wp.pidTable = (pr_PidRecord**)PR_CALLOC(NBUCKETS * sizeof(pr_PidRecord *));\n    PR_ASSERT(NULL != pr_wp.pidTable);\n    return PR_SUCCESS;\n}\n\nPRStatus _MD_DetachUnixProcess(PRProcess *process)\n{\n    PRStatus retVal = PR_SUCCESS;\n    pr_PidRecord *pRec;\n\n    PR_Lock(pr_wp.ml);\n    pRec = FindPidTable(process->md.pid);\n    if (NULL == pRec) {\n\tpRec = PR_NEW(pr_PidRecord);\n\tif (NULL == pRec) {\n\t    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tpRec->pid = process->md.pid;\n\tpRec->state = _PR_PID_DETACHED;\n\tpRec->reapedCV = NULL;\n\tInsertPidTable(pRec);\n    } else {\n\tPR_ASSERT(_PR_PID_REAPED == pRec->state);\n\tif (_PR_PID_REAPED != pRec->state) {\n\t    PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t} else {\n\t    DeletePidTable(pRec);\n\t    PR_ASSERT(NULL == pRec->reapedCV);\n\t    PR_DELETE(pRec);\n\t}\n    }\n    PR_DELETE(process);\n\ndone:\n    PR_Unlock(pr_wp.ml);\n    return retVal;\n}\n\nPRStatus _MD_WaitUnixProcess(\n    PRProcess *process,\n    PRInt32 *exitCode)\n{\n    pr_PidRecord *pRec;\n    PRStatus retVal = PR_SUCCESS;\n    PRBool interrupted = PR_FALSE;\n\n    PR_Lock(pr_wp.ml);\n    pRec = FindPidTable(process->md.pid);\n    if (NULL == pRec) {\n\tpRec = PR_NEW(pr_PidRecord);\n\tif (NULL == pRec) {\n\t    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tpRec->pid = process->md.pid;\n\tpRec->state = _PR_PID_WAITING;\n\tpRec->reapedCV = PR_NewCondVar(pr_wp.ml);\n\tif (NULL == pRec->reapedCV) {\n\t    PR_DELETE(pRec);\n\t    retVal = PR_FAILURE;\n\t    goto done;\n\t}\n\tInsertPidTable(pRec);\n\twhile (!interrupted && _PR_PID_REAPED != pRec->state) {\n\t    if (PR_WaitCondVar(pRec->reapedCV,\n\t\t    PR_INTERVAL_NO_TIMEOUT) == PR_FAILURE\n\t\t    && PR_GetError() == PR_PENDING_INTERRUPT_ERROR) {\n\t\tinterrupted = PR_TRUE;\n            }\n\t}\n\tif (_PR_PID_REAPED == pRec->state) {\n            if (exitCode) {\n                *exitCode = pRec->exitStatus;\n            }\n\t} else {\n\t    PR_ASSERT(interrupted);\n\t    retVal = PR_FAILURE;\n\t}\n\tDeletePidTable(pRec);\n\tPR_DestroyCondVar(pRec->reapedCV);\n\tPR_DELETE(pRec);\n    } else {\n\tPR_ASSERT(_PR_PID_REAPED == pRec->state);\n\tPR_ASSERT(NULL == pRec->reapedCV);\n\tDeletePidTable(pRec);\n        if (exitCode) {\n            *exitCode = pRec->exitStatus;\n        }\n\tPR_DELETE(pRec);\n    }\n    PR_DELETE(process);\n\ndone:\n    PR_Unlock(pr_wp.ml);\n    return retVal;\n}  /* _MD_WaitUnixProcess */\n\nPRStatus _MD_KillUnixProcess(PRProcess *process)\n{\n    PRErrorCode prerror;\n    PRInt32 oserror;\n\n#ifdef SYMBIAN\n    /* In Symbian OS, we can not kill other process with Open C */\n    PR_SetError(PR_OPERATION_NOT_SUPPORTED_ERROR, oserror);\n    return PR_FAILURE;\n#else\n    if (kill(process->md.pid, SIGKILL) == 0) {\n\treturn PR_SUCCESS;\n    }\n    oserror = errno;\n    switch (oserror) {\n        case EPERM:\n\t    prerror = PR_NO_ACCESS_RIGHTS_ERROR;\n\t    break;\n        case ESRCH:\n\t    prerror = PR_INVALID_ARGUMENT_ERROR;\n\t    break;\n        default:\n\t    prerror = PR_UNKNOWN_ERROR;\n\t    break;\n    }\n    PR_SetError(prerror, oserror);\n    return PR_FAILURE;\n#endif\n}  /* _MD_KillUnixProcess */\n"
    },
    "skipped": [],
    "total_files": 635
}