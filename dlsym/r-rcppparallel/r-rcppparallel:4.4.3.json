{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbb/itt_notify.cpp": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#if DO_ITT_NOTIFY\n\n#if _WIN32||_WIN64\n    #ifndef UNICODE\n        #define UNICODE\n    #endif\n#else\n    #pragma weak dlopen\n    #pragma weak dlsym\n    #pragma weak dlerror\n#endif /* WIN */\n\n#if __TBB_BUILD\n\nextern \"C\" void ITT_DoOneTimeInitialization();\n#define __itt_init_ittlib_name(x,y) (ITT_DoOneTimeInitialization(), true)\n\n#elif __TBBMALLOC_BUILD\n\nextern \"C\" void MallocInitializeITT();\n#define __itt_init_ittlib_name(x,y) (MallocInitializeITT(), true)\n\n#else\n#error This file is expected to be used for either TBB or TBB allocator build.\n#endif // __TBB_BUILD\n\n#include \"tools_api/ittnotify_static.c\"\n\nnamespace tbb {\nnamespace internal {\nint __TBB_load_ittnotify() {\n#if !(_WIN32||_WIN64)\n    // tool_api crashes without dlopen, check that it's present. Common case\n    // for lack of dlopen is static binaries, i.e. ones build with -static.\n    if (dlopen == NULL)\n        return 0;\n#endif\n    return __itt_init_ittlib(NULL,          // groups for:\n      (__itt_group_id)(__itt_group_sync     // prepare/cancel/acquired/releasing\n                       | __itt_group_thread // name threads\n                       | __itt_group_stitch // stack stitching\n#if __TBB_CPF_BUILD\n                       | __itt_group_structure\n#endif\n                           ));\n}\n\n}} // namespaces\n\n#endif /* DO_ITT_NOTIFY */\n\n#define __TBB_NO_IMPLICIT_LINKAGE 1\n#include \"itt_notify.h\"\n\nnamespace tbb {\n\n#if DO_ITT_NOTIFY\n    const tchar\n            *SyncType_GlobalLock = _T(\"TbbGlobalLock\"),\n            *SyncType_Scheduler = _T(\"%Constant\")\n            ;\n    const tchar\n            *SyncObj_SchedulerInitialization = _T(\"TbbSchedulerInitialization\"),\n            *SyncObj_SchedulersList = _T(\"TbbSchedulersList\"),\n            *SyncObj_WorkerLifeCycleMgmt = _T(\"TBB Scheduler\"),\n            *SyncObj_TaskStealingLoop = _T(\"TBB Scheduler\"),\n            *SyncObj_WorkerTaskPool = _T(\"TBB Scheduler\"),\n            *SyncObj_MasterTaskPool = _T(\"TBB Scheduler\"),\n            *SyncObj_TaskPoolSpinning = _T(\"TBB Scheduler\"),\n            *SyncObj_Mailbox = _T(\"TBB Scheduler\"),\n            *SyncObj_TaskReturnList = _T(\"TBB Scheduler\"),\n            *SyncObj_TaskStream = _T(\"TBB Scheduler\"),\n            *SyncObj_ContextsList = _T(\"TBB Scheduler\")\n            ;\n#endif /* DO_ITT_NOTIFY */\n\n} // namespace tbb\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbb/mac64-tbb-export.lst": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#include \"tbb/tbb_config.h\"\n\n/*\n    Sometimes macOS* requires leading underscore (e. g. in export list file), but sometimes not\n    (e. g. when searching symbol in a dynamic library via dlsym()). Symbols in this file SHOULD\n    be listed WITHOUT one leading underscore. __TBB_SYMBOL macro should add underscore when\n    necessary, depending on the indended usage.\n*/\n\n// cache_aligned_allocator.cpp\n__TBB_SYMBOL( _ZN3tbb8internal12NFS_AllocateEmmPv )\n__TBB_SYMBOL( _ZN3tbb8internal15NFS_GetLineSizeEv )\n__TBB_SYMBOL( _ZN3tbb8internal8NFS_FreeEPv )\n__TBB_SYMBOL( _ZN3tbb8internal23allocate_via_handler_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal25deallocate_via_handler_v3EPv )\n__TBB_SYMBOL( _ZN3tbb8internal17is_malloc_used_v3Ev )\n\n// task.cpp v3\n__TBB_SYMBOL( _ZN3tbb4task13note_affinityEt )\n__TBB_SYMBOL( _ZN3tbb4task22internal_set_ref_countEi )\n__TBB_SYMBOL( _ZN3tbb4task28internal_decrement_ref_countEv )\n__TBB_SYMBOL( _ZN3tbb4task22spawn_and_wait_for_allERNS_9task_listE )\n__TBB_SYMBOL( _ZN3tbb4task4selfEv )\n__TBB_SYMBOL( _ZN3tbb10interface58internal9task_base7destroyERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb4task26is_owned_by_current_threadEv )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_root_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_root_proxy8allocateEm )\n__TBB_SYMBOL( _ZN3tbb8internal28affinity_partitioner_base_v36resizeEj )\n__TBB_SYMBOL( _ZN3tbb8internal36get_initial_auto_partitioner_divisorEv )\n__TBB_SYMBOL( _ZNK3tbb8internal20allocate_child_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal20allocate_child_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal27allocate_continuation_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal27allocate_continuation_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal34allocate_additional_child_of_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal34allocate_additional_child_of_proxy8allocateEm )\n__TBB_SYMBOL( _ZTIN3tbb4taskE )\n__TBB_SYMBOL( _ZTSN3tbb4taskE )\n__TBB_SYMBOL( _ZTVN3tbb4taskE )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init19default_num_threadsEv )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init10initializeEim )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init10initializeEi )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init9terminateEv )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init27internal_blocking_terminateEb )\n#if __TBB_SCHEDULER_OBSERVER\n__TBB_SYMBOL( _ZN3tbb8internal26task_scheduler_observer_v37observeEb )\n#endif /* __TBB_SCHEDULER_OBSERVER */\n__TBB_SYMBOL( _ZN3tbb10empty_task7executeEv )\n__TBB_SYMBOL( _ZN3tbb10empty_taskD0Ev )\n__TBB_SYMBOL( _ZN3tbb10empty_taskD1Ev )\n__TBB_SYMBOL( _ZTIN3tbb10empty_taskE )\n__TBB_SYMBOL( _ZTSN3tbb10empty_taskE )\n__TBB_SYMBOL( _ZTVN3tbb10empty_taskE )\n\n/* arena.cpp */\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base19internal_initializeEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base18internal_terminateEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base15internal_attachEv )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base16internal_enqueueERNS_4taskEl )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base16internal_executeERNS1_13delegate_baseE )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base13internal_waitEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base21internal_current_slotEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base24internal_max_concurrencyEPKNS0_10task_arenaE )\n#if __TBB_TASK_ISOLATION\n__TBB_SYMBOL( _ZN3tbb10interface78internal20isolate_within_arenaERNS1_13delegate_baseEl )\n#endif /* __TBB_TASK_ISOLATION */\n\n#if !TBB_NO_LEGACY\n// task_v2.cpp\n__TBB_SYMBOL( _ZN3tbb4task7destroyERS0_ )\n#endif\n\n// Exception handling in task scheduler\n#if __TBB_TASK_GROUP_CONTEXT\n__TBB_SYMBOL( _ZNK3tbb8internal32allocate_root_with_context_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal32allocate_root_with_context_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb4task12change_groupERNS_18task_group_contextE )\n__TBB_SYMBOL( _ZNK3tbb18task_group_context28is_group_execution_cancelledEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context22cancel_group_executionEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context26register_pending_exceptionEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context5resetEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context19capture_fp_settingsEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context4initEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_contextD1Ev )\n__TBB_SYMBOL( _ZN3tbb18task_group_contextD2Ev )\n#if __TBB_TASK_PRIORITY\n__TBB_SYMBOL( _ZN3tbb18task_group_context12set_priorityENS_10priority_tE )\n__TBB_SYMBOL( _ZNK3tbb18task_group_context8priorityEv )\n#endif /* __TBB_TASK_PRIORITY */\n__TBB_SYMBOL( _ZNK3tbb18captured_exception4nameEv )\n__TBB_SYMBOL( _ZNK3tbb18captured_exception4whatEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception10throw_selfEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception3setEPKcS2_ )\n__TBB_SYMBOL( _ZN3tbb18captured_exception4moveEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception5clearEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception7destroyEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception8allocateEPKcS2_ )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD0Ev )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD1Ev )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTSN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTVN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTIN3tbb13tbb_exceptionE )\n__TBB_SYMBOL( _ZTSN3tbb13tbb_exceptionE )\n__TBB_SYMBOL( _ZTVN3tbb13tbb_exceptionE )\n#endif /* __TBB_TASK_GROUP_CONTEXT */\n\n// Symbols for exceptions thrown from TBB\n__TBB_SYMBOL( _ZN3tbb8internal33throw_bad_last_alloc_exception_v4Ev )\n__TBB_SYMBOL( _ZN3tbb8internal18throw_exception_v4ENS0_12exception_idE )\n__TBB_SYMBOL( _ZNSt13runtime_errorD1Ev )\n__TBB_SYMBOL( _ZTISt13runtime_error )\n__TBB_SYMBOL( _ZTSSt13runtime_error )\n__TBB_SYMBOL( _ZNSt16invalid_argumentD1Ev )\n__TBB_SYMBOL( _ZTISt16invalid_argument )\n__TBB_SYMBOL( _ZTSSt16invalid_argument )\n__TBB_SYMBOL( _ZNSt11range_errorD1Ev )\n__TBB_SYMBOL( _ZTISt11range_error )\n__TBB_SYMBOL( _ZTSSt11range_error )\n__TBB_SYMBOL( _ZNSt12length_errorD1Ev )\n__TBB_SYMBOL( _ZTISt12length_error )\n__TBB_SYMBOL( _ZTSSt12length_error )\n__TBB_SYMBOL( _ZNSt12out_of_rangeD1Ev )\n__TBB_SYMBOL( _ZTISt12out_of_range )\n__TBB_SYMBOL( _ZTSSt12out_of_range )\n__TBB_SYMBOL( _ZN3tbb14bad_last_allocD0Ev )\n__TBB_SYMBOL( _ZN3tbb14bad_last_allocD1Ev )\n__TBB_SYMBOL( _ZNK3tbb14bad_last_alloc4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZTSN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZTVN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZN3tbb12missing_waitD0Ev )\n__TBB_SYMBOL( _ZN3tbb12missing_waitD1Ev )\n__TBB_SYMBOL( _ZNK3tbb12missing_wait4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZTSN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZTVN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZN3tbb27invalid_multiple_schedulingD0Ev )\n__TBB_SYMBOL( _ZN3tbb27invalid_multiple_schedulingD1Ev )\n__TBB_SYMBOL( _ZNK3tbb27invalid_multiple_scheduling4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZTSN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZTVN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZN3tbb13improper_lockD0Ev )\n__TBB_SYMBOL( _ZN3tbb13improper_lockD1Ev )\n__TBB_SYMBOL( _ZNK3tbb13improper_lock4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZTSN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZTVN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZN3tbb10user_abortD0Ev )\n__TBB_SYMBOL( _ZN3tbb10user_abortD1Ev )\n__TBB_SYMBOL( _ZNK3tbb10user_abort4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb10user_abortE )\n__TBB_SYMBOL( _ZTSN3tbb10user_abortE )\n__TBB_SYMBOL( _ZTVN3tbb10user_abortE )\n\n\n// tbb_misc.cpp\n__TBB_SYMBOL( _ZN3tbb17assertion_failureEPKciS1_S1_ )\n__TBB_SYMBOL( _ZN3tbb21set_assertion_handlerEPFvPKciS1_S1_E )\n__TBB_SYMBOL( _ZN3tbb8internal13handle_perrorEiPKc )\n__TBB_SYMBOL( _ZN3tbb8internal15runtime_warningEPKcz )\n__TBB_SYMBOL( TBB_runtime_interface_version )\n\n// tbb_main.cpp\n__TBB_SYMBOL( _ZN3tbb8internal32itt_load_pointer_with_acquire_v3EPKv )\n__TBB_SYMBOL( _ZN3tbb8internal33itt_store_pointer_with_release_v3EPvS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal18call_itt_notify_v5EiPv )\n__TBB_SYMBOL( _ZN3tbb8internal19itt_load_pointer_v3EPKv )\n__TBB_SYMBOL( _ZN3tbb8internal20itt_set_sync_name_v3EPvPKc )\n\n// pipeline.cpp\n__TBB_SYMBOL( _ZTIN3tbb6filterE )\n__TBB_SYMBOL( _ZTSN3tbb6filterE )\n__TBB_SYMBOL( _ZTVN3tbb6filterE )\n__TBB_SYMBOL( _ZN3tbb6filterD2Ev )\n__TBB_SYMBOL( _ZN3tbb8pipeline10add_filterERNS_6filterE )\n__TBB_SYMBOL( _ZN3tbb8pipeline12inject_tokenERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb8pipeline13remove_filterERNS_6filterE )\n__TBB_SYMBOL( _ZN3tbb8pipeline3runEm )\n#if __TBB_TASK_GROUP_CONTEXT\n__TBB_SYMBOL( _ZN3tbb8pipeline3runEmRNS_18task_group_contextE )\n#endif\n__TBB_SYMBOL( _ZN3tbb8pipeline5clearEv )\n__TBB_SYMBOL( _ZN3tbb19thread_bound_filter12process_itemEv )\n__TBB_SYMBOL( _ZN3tbb19thread_bound_filter16try_process_itemEv )\n__TBB_SYMBOL( _ZN3tbb8pipelineC1Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineC2Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD0Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD1Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb8pipelineE )\n__TBB_SYMBOL( _ZTSN3tbb8pipelineE )\n__TBB_SYMBOL( _ZTVN3tbb8pipelineE )\n__TBB_SYMBOL( _ZN3tbb6filter16set_end_of_inputEv )\n\n// queuing_rw_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock17upgrade_to_writerEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock19downgrade_to_readerEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock7acquireERS0_b )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock7releaseEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock11try_acquireERS0_b )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex18internal_constructEv )\n\n// reader_writer_lock.cpp\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock11scoped_lock16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock11scoped_lock18internal_constructERS1_ )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock13try_lock_readEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16scoped_lock_read16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16scoped_lock_read18internal_constructERS1_ )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock18internal_constructEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock4lockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock6unlockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock8try_lockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock9lock_readEv )\n\n#if !TBB_NO_LEGACY\n// spin_rw_mutex.cpp v2\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex16internal_upgradeEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex22internal_itt_releasingEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_acquire_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_acquire_writerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex18internal_downgradeEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_release_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_release_writerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex27internal_try_acquire_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex27internal_try_acquire_writerEPS0_ )\n#endif\n\n// spin_rw_mutex v3\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v316internal_upgradeEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v318internal_downgradeEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_acquire_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_acquire_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_release_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_release_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v327internal_try_acquire_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v327internal_try_acquire_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v318internal_constructEv )\n\n// x86_rtm_rw_mutex.cpp\n#if __TBB_TSX_AVAILABLE\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex16internal_releaseERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex16internal_upgradeERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex18internal_constructEv )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex18internal_downgradeERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex23internal_acquire_readerERNS2_11scoped_lockEb )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex23internal_acquire_writerERNS2_11scoped_lockEb )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex27internal_try_acquire_writerERNS2_11scoped_lockE )\n#endif\n\n// spin_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex18internal_constructEv )\n\n// mutex.cpp\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb5mutex16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb5mutex18internal_constructEv )\n\n// recursive_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex18internal_constructEv )\n\n// queuing_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock7acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock7releaseEv )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock11try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex18internal_constructEv )\n\n// critical_section.cpp\n__TBB_SYMBOL( _ZN3tbb8internal19critical_section_v418internal_constructEv )\n\n#if !TBB_NO_LEGACY\n// concurrent_hash_map\n__TBB_SYMBOL( _ZNK3tbb8internal21hash_map_segment_base23internal_grow_predicateEv )\n\n// concurrent_queue.cpp v2\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base12internal_popEPv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base13internal_pushEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base21internal_set_capacityElm )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base23internal_pop_if_presentEPv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base25internal_push_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_baseC2Em )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_baseD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZTSN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZTVN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_base6assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_base7advanceEv )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_baseC2ERKNS0_21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_baseD2Ev )\n__TBB_SYMBOL( _ZNK3tbb8internal21concurrent_queue_base13internal_sizeEv )\n#endif\n\n// concurrent_queue v3\n// constructors\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3C2ERKNS0_24concurrent_queue_base_v3E )\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3C2ERKNS0_24concurrent_queue_base_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v3C2Em )\n// destructors\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3D2Ev )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v3D2Ev )\n// typeinfo\n__TBB_SYMBOL( _ZTIN3tbb8internal24concurrent_queue_base_v3E )\n__TBB_SYMBOL( _ZTSN3tbb8internal24concurrent_queue_base_v3E )\n// vtable\n__TBB_SYMBOL( _ZTVN3tbb8internal24concurrent_queue_base_v3E )\n// methods\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v36assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v37advanceEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v313internal_pushEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v818internal_push_moveEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v325internal_push_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v830internal_push_move_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v312internal_popEPv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v323internal_pop_if_presentEPv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v314internal_abortEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v321internal_finish_clearEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v321internal_set_capacityElm )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v313internal_sizeEv )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v314internal_emptyEv )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v324internal_throw_exceptionEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v36assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v812move_contentERS1_ )\n\n#if !TBB_NO_LEGACY\n// concurrent_vector.cpp v2\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base13internal_copyERKS1_mPFvPvPKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base14internal_clearEPFvPvmEb )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base15internal_assignERKS1_mPFvPvmEPFvS4_PKvmESA_ )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base16internal_grow_byEmmPFvPvmE )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base16internal_reserveEmmm )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base18internal_push_backEmRm )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base25internal_grow_to_at_leastEmmPFvPvmE )\n__TBB_SYMBOL( _ZNK3tbb8internal22concurrent_vector_base17internal_capacityEv )\n#endif\n\n// concurrent_vector v3\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v313internal_copyERKS1_mPFvPvPKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v314internal_clearEPFvPvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v315internal_assignERKS1_mPFvPvmEPFvS4_PKvmESA_ )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_grow_byEmmPFvPvPKvmES4_ )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_reserveEmmm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v318internal_push_backEmRm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v325internal_grow_to_at_leastEmmPFvPvPKvmES4_ )\n__TBB_SYMBOL( _ZNK3tbb8internal25concurrent_vector_base_v317internal_capacityEv )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_compactEmPvPFvS2_mEPFvS2_PKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v313internal_swapERS1_ )\n__TBB_SYMBOL( _ZNK3tbb8internal25concurrent_vector_base_v324internal_throw_exceptionEm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v3D2Ev )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v315internal_resizeEmmmPKvPFvPvmEPFvS4_S3_mE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v337internal_grow_to_at_least_with_resultEmmPFvPvPKvmES4_ )\n\n// tbb_thread\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v320hardware_concurrencyEv )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v36detachEv )\n__TBB_SYMBOL( _ZN3tbb8internal16thread_get_id_v3Ev )\n__TBB_SYMBOL( _ZN3tbb8internal15free_closure_v3EPv )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v34joinEv )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v314internal_startEPFPvS2_ES2_ )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_closure_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal7move_v3ERNS0_13tbb_thread_v3ES2_ )\n__TBB_SYMBOL( _ZN3tbb8internal15thread_yield_v3Ev )\n__TBB_SYMBOL( _ZN3tbb8internal15thread_sleep_v3ERKNS_10tick_count10interval_tE )\n\n// global parameter\n__TBB_SYMBOL( _ZN3tbb10interface914global_control12active_valueEi )\n__TBB_SYMBOL( _ZN3tbb10interface914global_control15internal_createEv )\n__TBB_SYMBOL( _ZN3tbb10interface914global_control16internal_destroyEv )\n\n#undef __TBB_SYMBOL\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbb/dynamic_link.cpp": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#include \"dynamic_link.h\"\n#include \"tbb/tbb_config.h\"\n\n/*\n    This file is used by both TBB and OpenMP RTL. Do not use __TBB_ASSERT() macro\n    and runtime_warning() function because they are not available in OpenMP. Use\n    LIBRARY_ASSERT and DYNAMIC_LINK_WARNING instead.\n*/\n\n#include <cstdarg>          // va_list etc.\n#if _WIN32\n    #include <malloc.h>\n\n    // Unify system calls\n    #define dlopen( name, flags )   LoadLibrary( name )\n    #define dlsym( handle, name )   GetProcAddress( handle, name )\n    #define dlclose( handle )       ( ! FreeLibrary( handle ) )\n    #define dlerror()               GetLastError()\n#ifndef PATH_MAX\n    #define PATH_MAX                MAX_PATH\n#endif\n#else /* _WIN32 */\n    #include <dlfcn.h>\n    #include <string.h>\n    #include <unistd.h>\n    #include <limits.h>\n    #include <stdlib.h>\n#endif /* _WIN32 */\n\n#if __TBB_WEAK_SYMBOLS_PRESENT && !__TBB_DYNAMIC_LOAD_ENABLED\n    //TODO: use function attribute for weak symbols instead of the pragma.\n    #pragma weak dlopen\n    #pragma weak dlsym\n    #pragma weak dlclose\n#endif /* __TBB_WEAK_SYMBOLS_PRESENT && !__TBB_DYNAMIC_LOAD_ENABLED */\n\n#include \"tbb/tbb_misc.h\"\n\n#define __USE_TBB_ATOMICS       ( !(__linux__&&__ia64__) || __TBB_BUILD )\n#define __USE_STATIC_DL_INIT    ( !__ANDROID__ )\n\n#if !__USE_TBB_ATOMICS\n#include <pthread.h>\n#endif\n\n/*\ndynamic_link is a common interface for searching for required symbols in an\nexecutable and dynamic libraries.\n\ndynamic_link provides certain guarantees:\n  1. Either all or none of the requested symbols are resolved. Moreover, if\n  symbols are not resolved, the dynamic_link_descriptor table is not modified;\n  2. All returned symbols have secured lifetime: this means that none of them\n  can be invalidated until dynamic_unlink is called;\n  3. Any loaded library is loaded only via the full path. The full path is that\n  from which the runtime itself was loaded. (This is done to avoid security\n  issues caused by loading libraries from insecure paths).\n\ndynamic_link searches for the requested symbols in three stages, stopping as\nsoon as all of the symbols have been resolved.\n\n  1. Search the global scope:\n    a. On Windows: dynamic_link tries to obtain the handle of the requested\n    library and if it succeeds it resolves the symbols via that handle.\n    b. On Linux: dynamic_link tries to search for the symbols in the global\n    scope via the main program handle. If the symbols are present in the global\n    scope their lifetime is not guaranteed (since dynamic_link does not know\n    anything about the library from which they are exported). Therefore it\n    tries to \"pin\" the symbols by obtaining the library name and reopening it.\n    dlopen may fail to reopen the library in two cases:\n       i. The symbols are exported from the executable. Currently dynamic _link\n      cannot handle this situation, so it will not find these symbols in this\n      step.\n      ii. The necessary library has been unloaded and cannot be reloaded. It\n      seems there is nothing that can be done in this case. No symbols are\n      returned.\n\n  2. Dynamic load: an attempt is made to load the requested library via the\n  full path.\n    The full path used is that from which the runtime itself was loaded. If the\n    library can be loaded, then an attempt is made to resolve the requested\n    symbols in the newly loaded library.\n    If the symbols are not found the library is unloaded.\n\n  3. Weak symbols: if weak symbols are available they are returned.\n*/\n\nOPEN_INTERNAL_NAMESPACE\n\n#if __TBB_WEAK_SYMBOLS_PRESENT || __TBB_DYNAMIC_LOAD_ENABLED\n\n#if !defined(DYNAMIC_LINK_WARNING) && !__TBB_WIN8UI_SUPPORT && __TBB_DYNAMIC_LOAD_ENABLED\n    // Report runtime errors and continue.\n    #define DYNAMIC_LINK_WARNING dynamic_link_warning\n    static void dynamic_link_warning( dynamic_link_error_t code, ... ) {\n        (void) code;\n    } // library_warning\n#endif /* !defined(DYNAMIC_LINK_WARNING) && !__TBB_WIN8UI_SUPPORT && __TBB_DYNAMIC_LOAD_ENABLED */\n\n    static bool resolve_symbols( dynamic_link_handle module, const dynamic_link_descriptor descriptors[], size_t required )\n    {\n        if ( !module )\n            return false;\n\n        #if !__TBB_DYNAMIC_LOAD_ENABLED /* only __TBB_WEAK_SYMBOLS_PRESENT is defined */\n            if ( !dlsym ) return false;\n        #endif /* !__TBB_DYNAMIC_LOAD_ENABLED */\n\n        const size_t n_desc=20; // Usually we don't have more than 20 descriptors per library\n        LIBRARY_ASSERT( required <= n_desc, \"Too many descriptors is required\" );\n        if ( required > n_desc ) return false;\n        pointer_to_handler h[n_desc];\n\n        for ( size_t k = 0; k < required; ++k ) {\n            dynamic_link_descriptor const & desc = descriptors[k];\n            pointer_to_handler addr = (pointer_to_handler)dlsym( module, desc.name );\n            if ( !addr ) {\n                return false;\n            }\n            h[k] = addr;\n        }\n\n        // Commit the entry points.\n        // Cannot use memset here, because the writes must be atomic.\n        for( size_t k = 0; k < required; ++k )\n            *descriptors[k].handler = h[k];\n        return true;\n    }\n\n#if __TBB_WIN8UI_SUPPORT\n    bool dynamic_link( const char*  library, const dynamic_link_descriptor descriptors[], size_t required, dynamic_link_handle*, int flags ) {\n        dynamic_link_handle tmp_handle = NULL;\n        TCHAR wlibrary[256];\n        if ( MultiByteToWideChar(CP_UTF8, 0, library, -1, wlibrary, 255) == 0 ) return false;\n        if ( flags & DYNAMIC_LINK_LOAD )\n            tmp_handle = LoadPackagedLibrary( wlibrary, 0 );\n        if (tmp_handle != NULL){\n            return resolve_symbols(tmp_handle, descriptors, required);\n        }else{\n            return false;\n        }\n    }\n    void dynamic_unlink( dynamic_link_handle ) {}\n    void dynamic_unlink_all() {}\n#else\n#if __TBB_DYNAMIC_LOAD_ENABLED\n/*\n    There is a security issue on Windows: LoadLibrary() may load and execute malicious code.\n    See http://www.microsoft.com/technet/security/advisory/2269637.mspx for details.\n    To avoid the issue, we have to pass full path (not just library name) to LoadLibrary. This\n    function constructs full path to the specified library (it is assumed the library located\n    side-by-side with the tbb.dll.\n\n    The function constructs absolute path for given relative path. Important: Base directory is not\n    current one, it is the directory tbb.dll loaded from.\n\n    Example:\n        Let us assume \"tbb.dll\" is located in \"c:\\program files\\common\\intel\\\" directory, e. g.\n        absolute path of tbb library is \"c:\\program files\\common\\intel\\tbb.dll\". Absolute path for\n        \"tbbmalloc.dll\" would be \"c:\\program files\\common\\intel\\tbbmalloc.dll\". Absolute path for\n        \"malloc\\tbbmalloc.dll\" would be \"c:\\program files\\common\\intel\\malloc\\tbbmalloc.dll\".\n*/\n\n    // Struct handle_storage is used by dynamic_link routine to store handles of\n    // all loaded or pinned dynamic libraries. When TBB is shut down, it calls\n    // dynamic_unlink_all() that unloads modules referenced by handle_storage.\n    // This struct should not have any constructors since it may be used before\n    // the constructor is called.\n    #define MAX_LOADED_MODULES 8 // The number of maximum possible modules which can be loaded\n\n#if __USE_TBB_ATOMICS\n    typedef ::tbb::atomic<size_t> atomic_incrementer;\n    void init_atomic_incrementer( atomic_incrementer & ) {}\n\n    static void atomic_once( void( *func ) (void), tbb::atomic< tbb::internal::do_once_state > &once_state ) {\n        tbb::internal::atomic_do_once( func, once_state );\n    }\n    #define ATOMIC_ONCE_DECL( var ) tbb::atomic< tbb::internal::do_once_state > var\n#else\n    static void pthread_assert( int error_code, const char* msg ) {\n        LIBRARY_ASSERT( error_code == 0, msg );\n    }\n\n    class atomic_incrementer {\n        size_t my_val;\n        pthread_spinlock_t my_lock;\n    public:\n        void init() {\n            my_val = 0;\n            pthread_assert( pthread_spin_init( &my_lock, PTHREAD_PROCESS_PRIVATE ), \"pthread_spin_init failed\" );\n        }\n        size_t operator++(int) {\n            pthread_assert( pthread_spin_lock( &my_lock ), \"pthread_spin_lock failed\" );\n            size_t prev_val = my_val++;\n            pthread_assert( pthread_spin_unlock( &my_lock ), \"pthread_spin_unlock failed\" );\n            return prev_val;\n        }\n        operator size_t() {\n            pthread_assert( pthread_spin_lock( &my_lock ), \"pthread_spin_lock failed\" );\n            size_t val = my_val;\n            pthread_assert( pthread_spin_unlock( &my_lock ), \"pthread_spin_unlock failed\" );\n            return val;\n        }\n        ~atomic_incrementer() {\n            pthread_assert( pthread_spin_destroy( &my_lock ), \"pthread_spin_destroy failed\" );\n        }\n    };\n\n    void init_atomic_incrementer( atomic_incrementer &r ) {\n        r.init();\n    }\n\n    static void atomic_once( void( *func ) (), pthread_once_t &once_state ) {\n        pthread_assert( pthread_once( &once_state, func ), \"pthread_once failed\" );\n    }\n    #define ATOMIC_ONCE_DECL( var ) pthread_once_t var = PTHREAD_ONCE_INIT\n#endif /* __USE_TBB_ATOMICS */\n\n    struct handles_t {\n        atomic_incrementer my_size;\n        dynamic_link_handle my_handles[MAX_LOADED_MODULES];\n\n        void init() {\n            init_atomic_incrementer( my_size );\n        }\n\n        void add(const dynamic_link_handle &handle) {\n            const size_t ind = my_size++;\n            LIBRARY_ASSERT( ind < MAX_LOADED_MODULES, \"Too many modules are loaded\" );\n            my_handles[ind] = handle;\n        }\n\n        void free() {\n            const size_t size = my_size;\n            for (size_t i=0; i<size; ++i)\n                dynamic_unlink( my_handles[i] );\n        }\n    } handles;\n\n    ATOMIC_ONCE_DECL( init_dl_data_state );\n\n    static struct ap_data_t {\n        char _path[PATH_MAX+1];\n        size_t _len;\n    } ap_data;\n\n    static void init_ap_data() {\n    #if _WIN32\n        // Get handle of our DLL first.\n        HMODULE handle;\n        BOOL brc = GetModuleHandleEx(\n            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n            (LPCSTR)( & dynamic_link ), // any function inside the library can be used for the address\n            & handle\n            );\n        if ( !brc ) { // Error occurred.\n            int err = GetLastError();\n            DYNAMIC_LINK_WARNING( dl_sys_fail, \"GetModuleHandleEx\", err );\n            return;\n        }\n        // Now get path to our DLL.\n        DWORD drc = GetModuleFileName( handle, ap_data._path, static_cast< DWORD >( PATH_MAX ) );\n        if ( drc == 0 ) { // Error occurred.\n            int err = GetLastError();\n            DYNAMIC_LINK_WARNING( dl_sys_fail, \"GetModuleFileName\", err );\n            return;\n        }\n        if ( drc >= PATH_MAX ) { // Buffer too short.\n            DYNAMIC_LINK_WARNING( dl_buff_too_small );\n            return;\n        }\n        // Find the position of the last backslash.\n        char *backslash = strrchr( ap_data._path, '\\\\' );\n\n        if ( !backslash ) {    // Backslash not found.\n            LIBRARY_ASSERT( backslash!=NULL, \"Unbelievable.\");\n            return;\n        }\n        LIBRARY_ASSERT( backslash >= ap_data._path, \"Unbelievable.\");\n        ap_data._len = (size_t)(backslash - ap_data._path) + 1;\n        *(backslash+1) = 0;\n    #else\n        // Get the library path\n        Dl_info dlinfo;\n        int res = dladdr( (void*)&dynamic_link, &dlinfo ); // any function inside the library can be used for the address\n        if ( !res ) {\n            char const * err = dlerror();\n            DYNAMIC_LINK_WARNING( dl_sys_fail, \"dladdr\", err );\n            return;\n        } else {\n            LIBRARY_ASSERT( dlinfo.dli_fname!=NULL, \"Unbelievable.\" );\n        }\n\n        char const *slash = strrchr( dlinfo.dli_fname, '/' );\n        size_t fname_len=0;\n        if ( slash ) {\n            LIBRARY_ASSERT( slash >= dlinfo.dli_fname, \"Unbelievable.\");\n            fname_len = (size_t)(slash - dlinfo.dli_fname) + 1;\n        }\n\n        size_t rc;\n        if ( dlinfo.dli_fname[0]=='/' ) {\n            // The library path is absolute\n            rc = 0;\n            ap_data._len = 0;\n        } else {\n            // The library path is relative so get the current working directory\n            if ( !getcwd( ap_data._path, sizeof(ap_data._path)/sizeof(ap_data._path[0]) ) ) {\n                DYNAMIC_LINK_WARNING( dl_buff_too_small );\n                return;\n            }\n            ap_data._len = strlen( ap_data._path );\n            ap_data._path[ap_data._len++]='/';\n            rc = ap_data._len;\n        }\n\n        if ( fname_len>0 ) {\n            if ( ap_data._len>PATH_MAX ) {\n                DYNAMIC_LINK_WARNING( dl_buff_too_small );\n                ap_data._len=0;\n                return;\n            }\n            strncpy( ap_data._path+rc, dlinfo.dli_fname, fname_len );\n            ap_data._len += fname_len;\n            ap_data._path[ap_data._len]=0;\n        }\n    #endif /* _WIN32 */\n    }\n\n    static void init_dl_data() {\n        handles.init();\n        init_ap_data();\n    }\n\n    /*\n        The function constructs absolute path for given relative path. Important: Base directory is not\n        current one, it is the directory libtbb.so loaded from.\n\n        Arguments:\n        in  name -- Name of a file (may be with relative path; it must not be an absolute one).\n        out path -- Buffer to save result (absolute path) to.\n        in  len  -- Size of buffer.\n        ret      -- 0         -- Error occurred.\n                    > len     -- Buffer too short, required size returned.\n                    otherwise -- Ok, number of characters (not counting terminating null) written to\n                    buffer.\n    */\n    static size_t abs_path( char const * name, char * path, size_t len ) {\n        if ( !ap_data._len )\n            return 0;\n\n        size_t name_len = strlen( name );\n        size_t full_len = name_len+ap_data._len;\n        if ( full_len < len ) {\n            strncpy( path, ap_data._path, ap_data._len );\n            memcpy( path+ap_data._len, name, name_len );\n            path[full_len] = 0;\n        }\n        return full_len;\n    }\n#endif  // __TBB_DYNAMIC_LOAD_ENABLED\n\n    void init_dynamic_link_data() {\n    #if __TBB_DYNAMIC_LOAD_ENABLED\n        atomic_once( &init_dl_data, init_dl_data_state );\n    #endif\n    }\n\n    #if __USE_STATIC_DL_INIT\n    // ap_data structure is initialized with current directory on Linux.\n    // So it should be initialized as soon as possible since the current directory may be changed.\n    // static_init_ap_data object provides this initialization during library loading.\n    static struct static_init_dl_data_t {\n        static_init_dl_data_t() {\n            init_dynamic_link_data();\n        }\n    } static_init_dl_data;\n    #endif\n\n    #if __TBB_WEAK_SYMBOLS_PRESENT\n    static bool weak_symbol_link( const dynamic_link_descriptor descriptors[], size_t required )\n    {\n        // Check if the required entries are present in what was loaded into our process.\n        for ( size_t k = 0; k < required; ++k )\n            if ( !descriptors[k].ptr )\n                return false;\n        // Commit the entry points.\n        for ( size_t k = 0; k < required; ++k )\n            *descriptors[k].handler = (pointer_to_handler) descriptors[k].ptr;\n        return true;\n    }\n    #else\n    static bool weak_symbol_link( const dynamic_link_descriptor[], size_t ) {\n        return false;\n    }\n    #endif /* __TBB_WEAK_SYMBOLS_PRESENT */\n\n    void dynamic_unlink( dynamic_link_handle handle ) {\n    #if !__TBB_DYNAMIC_LOAD_ENABLED /* only __TBB_WEAK_SYMBOLS_PRESENT is defined */\n        if ( !dlclose ) return;\n    #endif\n        if ( handle ) {\n            dlclose( handle );\n        }\n    }\n\n    void dynamic_unlink_all() {\n    #if __TBB_DYNAMIC_LOAD_ENABLED\n        handles.free();\n    #endif\n    }\n\n#if !_WIN32\n#if __TBB_DYNAMIC_LOAD_ENABLED\n    static dynamic_link_handle pin_symbols( dynamic_link_descriptor desc, const dynamic_link_descriptor* descriptors, size_t required ) {\n        // It is supposed that all symbols are from the only one library\n        // The library has been loaded by another module and contains at least one requested symbol.\n        // But after we obtained the symbol the library can be unloaded by another thread\n        // invalidating our symbol. Therefore we need to pin the library in memory.\n        dynamic_link_handle library_handle = 0;\n        Dl_info info;\n        // Get library's name from earlier found symbol\n        if ( dladdr( (void*)*desc.handler, &info ) ) {\n            // Pin the library\n            library_handle = dlopen( info.dli_fname, RTLD_LAZY );\n            if ( library_handle ) {\n                // If original library was unloaded before we pinned it\n                // and then another module loaded in its place, the earlier\n                // found symbol would become invalid. So revalidate them.\n                if ( !resolve_symbols( library_handle, descriptors, required ) ) {\n                    // Wrong library.\n                    dynamic_unlink(library_handle);\n                    library_handle = 0;\n                }\n            } else {\n                char const * err = dlerror();\n                DYNAMIC_LINK_WARNING( dl_lib_not_found, info.dli_fname, err );\n            }\n        }\n        // else the library has been unloaded by another thread\n        return library_handle;\n    }\n#endif /* __TBB_DYNAMIC_LOAD_ENABLED */\n#endif /* !_WIN32 */\n\n    static dynamic_link_handle global_symbols_link( const char* library, const dynamic_link_descriptor descriptors[], size_t required ) {\n        ::tbb::internal::suppress_unused_warning( library );\n        dynamic_link_handle library_handle;\n#if _WIN32\n        if ( GetModuleHandleEx( 0, library, &library_handle ) ) {\n            if ( resolve_symbols( library_handle, descriptors, required ) )\n                return library_handle;\n            else\n                FreeLibrary( library_handle );\n        }\n#else /* _WIN32 */\n    #if !__TBB_DYNAMIC_LOAD_ENABLED /* only __TBB_WEAK_SYMBOLS_PRESENT is defined */\n        if ( !dlopen ) return 0;\n    #endif /* !__TBB_DYNAMIC_LOAD_ENABLED */\n        library_handle = dlopen( NULL, RTLD_LAZY );\n    #if !__ANDROID__\n        // On Android dlopen( NULL ) returns NULL if it is called during dynamic module initialization.\n        LIBRARY_ASSERT( library_handle, \"The handle for the main program is NULL\" );\n    #endif\n    #if __TBB_DYNAMIC_LOAD_ENABLED\n        // Check existence of the first symbol only, then use it to find the library and load all necessary symbols.\n        pointer_to_handler handler;\n        dynamic_link_descriptor desc;\n        desc.name = descriptors[0].name;\n        desc.handler = &handler;\n        if ( resolve_symbols( library_handle, &desc, 1 ) ) {\n            dynamic_unlink( library_handle );\n            return pin_symbols( desc, descriptors, required );\n        }\n    #else  /* only __TBB_WEAK_SYMBOLS_PRESENT is defined */\n        if ( resolve_symbols( library_handle, descriptors, required ) )\n            return library_handle;\n    #endif\n        dynamic_unlink( library_handle );\n#endif /* _WIN32 */\n        return 0;\n    }\n\n    static void save_library_handle( dynamic_link_handle src, dynamic_link_handle *dst ) {\n        LIBRARY_ASSERT( src, \"The library handle to store must be non-zero\" );\n        if ( dst )\n            *dst = src;\n    #if __TBB_DYNAMIC_LOAD_ENABLED\n        else\n            handles.add( src );\n    #endif /* __TBB_DYNAMIC_LOAD_ENABLED */\n    }\n\n    dynamic_link_handle dynamic_load( const char* library, const dynamic_link_descriptor descriptors[], size_t required ) {\n    ::tbb::internal::suppress_unused_warning( library, descriptors, required );\n    #if __TBB_DYNAMIC_LOAD_ENABLED\n\n    size_t const len = PATH_MAX + 1;\n    char path[ len ];\n    size_t rc = abs_path( library, path, len );\n    if ( 0 < rc && rc < len ) {\n#if _WIN32\n        // Prevent Windows from displaying silly message boxes if it fails to load library\n        // (e.g. because of MS runtime problems - one of those crazy manifest related ones)\n        UINT prev_mode = SetErrorMode (SEM_FAILCRITICALERRORS);\n#endif /* _WIN32 */\n        dynamic_link_handle library_handle = dlopen( path, RTLD_LAZY );\n#if _WIN32\n        SetErrorMode (prev_mode);\n#endif /* _WIN32 */\n        if( library_handle ) {\n            if( !resolve_symbols( library_handle, descriptors, required ) ) {\n                // The loaded library does not contain all the expected entry points\n                dynamic_unlink( library_handle );\n                library_handle = NULL;\n            }\n        } else\n            DYNAMIC_LINK_WARNING( dl_lib_not_found, path, dlerror() );\n        return library_handle;\n    } else if ( rc>=len )\n            DYNAMIC_LINK_WARNING( dl_buff_too_small );\n            // rc == 0 means failing of init_ap_data so the warning has already been issued.\n\n    #endif /* __TBB_DYNAMIC_LOAD_ENABLED */\n        return 0;\n    }\n\n    bool dynamic_link( const char* library, const dynamic_link_descriptor descriptors[], size_t required, dynamic_link_handle *handle, int flags ) {\n        init_dynamic_link_data();\n\n        // TODO: May global_symbols_link find weak symbols?\n        dynamic_link_handle library_handle = ( flags & DYNAMIC_LINK_GLOBAL ) ? global_symbols_link( library, descriptors, required ) : 0;\n\n        if ( !library_handle && ( flags & DYNAMIC_LINK_LOAD ) )\n            library_handle = dynamic_load( library, descriptors, required );\n\n        if ( !library_handle && ( flags & DYNAMIC_LINK_WEAK ) )\n            return weak_symbol_link( descriptors, required );\n\n        if ( library_handle ) {\n            save_library_handle( library_handle, handle );\n            return true;\n        }\n        return false;\n    }\n\n#endif /*__TBB_WIN8UI_SUPPORT*/\n#else /* __TBB_WEAK_SYMBOLS_PRESENT || __TBB_DYNAMIC_LOAD_ENABLED */\n    bool dynamic_link( const char*, const dynamic_link_descriptor*, size_t, dynamic_link_handle *handle, int ) {\n        if ( handle )\n            *handle=0;\n        return false;\n    }\n    void dynamic_unlink( dynamic_link_handle ) {}\n    void dynamic_unlink_all() {}\n#endif /* __TBB_WEAK_SYMBOLS_PRESENT || __TBB_DYNAMIC_LOAD_ENABLED */\n\nCLOSE_INTERNAL_NAMESPACE\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbb/mac32-tbb-export.lst": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#include \"tbb/tbb_config.h\"\n\n/*\n    Sometimes macOS* requires leading underscore (e. g. in export list file), but sometimes not\n    (e. g. when searching symbol in a dynamic library via dlsym()). Symbols in this file SHOULD\n    be listed WITHOUT one leading underscore. __TBB_SYMBOL macro should add underscore when\n    necessary, depending on the indended usage.\n*/\n\n// cache_aligned_allocator.cpp\n__TBB_SYMBOL( _ZN3tbb8internal12NFS_AllocateEmmPv )\n__TBB_SYMBOL( _ZN3tbb8internal15NFS_GetLineSizeEv )\n__TBB_SYMBOL( _ZN3tbb8internal8NFS_FreeEPv )\n__TBB_SYMBOL( _ZN3tbb8internal23allocate_via_handler_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal25deallocate_via_handler_v3EPv )\n__TBB_SYMBOL( _ZN3tbb8internal17is_malloc_used_v3Ev )\n\n// task.cpp v3\n__TBB_SYMBOL( _ZN3tbb4task13note_affinityEt )\n__TBB_SYMBOL( _ZN3tbb4task22internal_set_ref_countEi )\n__TBB_SYMBOL( _ZN3tbb4task28internal_decrement_ref_countEv )\n__TBB_SYMBOL( _ZN3tbb4task22spawn_and_wait_for_allERNS_9task_listE )\n__TBB_SYMBOL( _ZN3tbb4task4selfEv )\n__TBB_SYMBOL( _ZN3tbb10interface58internal9task_base7destroyERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb4task26is_owned_by_current_threadEv )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_root_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_root_proxy8allocateEm )\n__TBB_SYMBOL( _ZN3tbb8internal28affinity_partitioner_base_v36resizeEj )\n__TBB_SYMBOL( _ZN3tbb8internal36get_initial_auto_partitioner_divisorEv )\n__TBB_SYMBOL( _ZNK3tbb8internal20allocate_child_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal20allocate_child_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal27allocate_continuation_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal27allocate_continuation_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal34allocate_additional_child_of_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZNK3tbb8internal34allocate_additional_child_of_proxy8allocateEm )\n__TBB_SYMBOL( _ZTIN3tbb4taskE )\n__TBB_SYMBOL( _ZTSN3tbb4taskE )\n__TBB_SYMBOL( _ZTVN3tbb4taskE )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init19default_num_threadsEv )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init10initializeEim )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init10initializeEi )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init9terminateEv )\n__TBB_SYMBOL( _ZN3tbb19task_scheduler_init27internal_blocking_terminateEb )\n#if __TBB_SCHEDULER_OBSERVER\n__TBB_SYMBOL( _ZN3tbb8internal26task_scheduler_observer_v37observeEb )\n#endif /* __TBB_SCHEDULER_OBSERVER */\n__TBB_SYMBOL( _ZN3tbb10empty_task7executeEv )\n__TBB_SYMBOL( _ZN3tbb10empty_taskD0Ev )\n__TBB_SYMBOL( _ZN3tbb10empty_taskD1Ev )\n__TBB_SYMBOL( _ZTIN3tbb10empty_taskE )\n__TBB_SYMBOL( _ZTSN3tbb10empty_taskE )\n__TBB_SYMBOL( _ZTVN3tbb10empty_taskE )\n\n/* arena.cpp */\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base19internal_initializeEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base18internal_terminateEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base15internal_attachEv )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base16internal_enqueueERNS_4taskEl )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base16internal_executeERNS1_13delegate_baseE )\n__TBB_SYMBOL( _ZNK3tbb10interface78internal15task_arena_base13internal_waitEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base21internal_current_slotEv )\n__TBB_SYMBOL( _ZN3tbb10interface78internal15task_arena_base24internal_max_concurrencyEPKNS0_10task_arenaE )\n#if __TBB_TASK_ISOLATION\n__TBB_SYMBOL( _ZN3tbb10interface78internal20isolate_within_arenaERNS1_13delegate_baseEl )\n#endif /* __TBB_TASK_ISOLATION */\n\n#if !TBB_NO_LEGACY\n// task_v2.cpp\n__TBB_SYMBOL( _ZN3tbb4task7destroyERS0_ )\n#endif\n\n// Exception handling in task scheduler\n#if __TBB_TASK_GROUP_CONTEXT\n__TBB_SYMBOL( _ZNK3tbb8internal32allocate_root_with_context_proxy8allocateEm )\n__TBB_SYMBOL( _ZNK3tbb8internal32allocate_root_with_context_proxy4freeERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb4task12change_groupERNS_18task_group_contextE )\n__TBB_SYMBOL( _ZNK3tbb18task_group_context28is_group_execution_cancelledEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context22cancel_group_executionEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context26register_pending_exceptionEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context5resetEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context19capture_fp_settingsEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_context4initEv )\n__TBB_SYMBOL( _ZN3tbb18task_group_contextD1Ev )\n__TBB_SYMBOL( _ZN3tbb18task_group_contextD2Ev )\n#if __TBB_TASK_PRIORITY\n__TBB_SYMBOL( _ZN3tbb18task_group_context12set_priorityENS_10priority_tE )\n__TBB_SYMBOL( _ZNK3tbb18task_group_context8priorityEv )\n#endif /* __TBB_TASK_PRIORITY */\n__TBB_SYMBOL( _ZNK3tbb18captured_exception4nameEv )\n__TBB_SYMBOL( _ZNK3tbb18captured_exception4whatEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception10throw_selfEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception3setEPKcS2_ )\n__TBB_SYMBOL( _ZN3tbb18captured_exception4moveEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception5clearEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception7destroyEv )\n__TBB_SYMBOL( _ZN3tbb18captured_exception8allocateEPKcS2_ )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD0Ev )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD1Ev )\n__TBB_SYMBOL( _ZN3tbb18captured_exceptionD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTSN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTVN3tbb18captured_exceptionE )\n__TBB_SYMBOL( _ZTIN3tbb13tbb_exceptionE )\n__TBB_SYMBOL( _ZTSN3tbb13tbb_exceptionE )\n__TBB_SYMBOL( _ZTVN3tbb13tbb_exceptionE )\n#endif /* __TBB_TASK_GROUP_CONTEXT */\n\n// Symbols for exceptions thrown from TBB\n__TBB_SYMBOL( _ZN3tbb8internal33throw_bad_last_alloc_exception_v4Ev )\n__TBB_SYMBOL( _ZN3tbb8internal18throw_exception_v4ENS0_12exception_idE )\n__TBB_SYMBOL( _ZNSt13runtime_errorD1Ev )\n__TBB_SYMBOL( _ZTISt13runtime_error )\n__TBB_SYMBOL( _ZTSSt13runtime_error )\n__TBB_SYMBOL( _ZNSt16invalid_argumentD1Ev )\n__TBB_SYMBOL( _ZTISt16invalid_argument )\n__TBB_SYMBOL( _ZTSSt16invalid_argument )\n__TBB_SYMBOL( _ZNSt11range_errorD1Ev )\n__TBB_SYMBOL( _ZTISt11range_error )\n__TBB_SYMBOL( _ZTSSt11range_error )\n__TBB_SYMBOL( _ZNSt12length_errorD1Ev )\n__TBB_SYMBOL( _ZTISt12length_error )\n__TBB_SYMBOL( _ZTSSt12length_error )\n__TBB_SYMBOL( _ZNSt12out_of_rangeD1Ev )\n__TBB_SYMBOL( _ZTISt12out_of_range )\n__TBB_SYMBOL( _ZTSSt12out_of_range )\n__TBB_SYMBOL( _ZN3tbb14bad_last_allocD0Ev )\n__TBB_SYMBOL( _ZN3tbb14bad_last_allocD1Ev )\n__TBB_SYMBOL( _ZNK3tbb14bad_last_alloc4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZTSN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZTVN3tbb14bad_last_allocE )\n__TBB_SYMBOL( _ZN3tbb12missing_waitD0Ev )\n__TBB_SYMBOL( _ZN3tbb12missing_waitD1Ev )\n__TBB_SYMBOL( _ZNK3tbb12missing_wait4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZTSN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZTVN3tbb12missing_waitE )\n__TBB_SYMBOL( _ZN3tbb27invalid_multiple_schedulingD0Ev )\n__TBB_SYMBOL( _ZN3tbb27invalid_multiple_schedulingD1Ev )\n__TBB_SYMBOL( _ZNK3tbb27invalid_multiple_scheduling4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZTSN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZTVN3tbb27invalid_multiple_schedulingE )\n__TBB_SYMBOL( _ZN3tbb13improper_lockD0Ev )\n__TBB_SYMBOL( _ZN3tbb13improper_lockD1Ev )\n__TBB_SYMBOL( _ZNK3tbb13improper_lock4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZTSN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZTVN3tbb13improper_lockE )\n__TBB_SYMBOL( _ZN3tbb10user_abortD0Ev )\n__TBB_SYMBOL( _ZN3tbb10user_abortD1Ev )\n__TBB_SYMBOL( _ZNK3tbb10user_abort4whatEv )\n__TBB_SYMBOL( _ZTIN3tbb10user_abortE )\n__TBB_SYMBOL( _ZTSN3tbb10user_abortE )\n__TBB_SYMBOL( _ZTVN3tbb10user_abortE )\n\n// tbb_misc.cpp\n__TBB_SYMBOL( _ZN3tbb17assertion_failureEPKciS1_S1_ )\n__TBB_SYMBOL( _ZN3tbb21set_assertion_handlerEPFvPKciS1_S1_E )\n__TBB_SYMBOL( _ZN3tbb8internal13handle_perrorEiPKc )\n__TBB_SYMBOL( _ZN3tbb8internal15runtime_warningEPKcz )\n#if __TBB_x86_32\n__TBB_SYMBOL( __TBB_machine_store8_slow_perf_warning )\n__TBB_SYMBOL( __TBB_machine_store8_slow )\n#endif\n__TBB_SYMBOL( TBB_runtime_interface_version )\n\n// tbb_main.cpp\n__TBB_SYMBOL( _ZN3tbb8internal32itt_load_pointer_with_acquire_v3EPKv )\n__TBB_SYMBOL( _ZN3tbb8internal33itt_store_pointer_with_release_v3EPvS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal18call_itt_notify_v5EiPv )\n__TBB_SYMBOL( _ZN3tbb8internal19itt_load_pointer_v3EPKv )\n__TBB_SYMBOL( _ZN3tbb8internal20itt_set_sync_name_v3EPvPKc )\n\n// pipeline.cpp\n__TBB_SYMBOL( _ZTIN3tbb6filterE )\n__TBB_SYMBOL( _ZTSN3tbb6filterE )\n__TBB_SYMBOL( _ZTVN3tbb6filterE )\n__TBB_SYMBOL( _ZN3tbb6filterD2Ev )\n__TBB_SYMBOL( _ZN3tbb8pipeline10add_filterERNS_6filterE )\n__TBB_SYMBOL( _ZN3tbb8pipeline12inject_tokenERNS_4taskE )\n__TBB_SYMBOL( _ZN3tbb8pipeline13remove_filterERNS_6filterE )\n__TBB_SYMBOL( _ZN3tbb8pipeline3runEm )\n#if __TBB_TASK_GROUP_CONTEXT\n__TBB_SYMBOL( _ZN3tbb8pipeline3runEmRNS_18task_group_contextE )\n#endif\n__TBB_SYMBOL( _ZN3tbb8pipeline5clearEv )\n__TBB_SYMBOL( _ZN3tbb19thread_bound_filter12process_itemEv )\n__TBB_SYMBOL( _ZN3tbb19thread_bound_filter16try_process_itemEv )\n__TBB_SYMBOL( _ZN3tbb8pipelineC1Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineC2Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD0Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD1Ev )\n__TBB_SYMBOL( _ZN3tbb8pipelineD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb8pipelineE )\n__TBB_SYMBOL( _ZTSN3tbb8pipelineE )\n__TBB_SYMBOL( _ZTVN3tbb8pipelineE )\n__TBB_SYMBOL( _ZN3tbb6filter16set_end_of_inputEv )\n\n// queuing_rw_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock17upgrade_to_writerEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock19downgrade_to_readerEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock7acquireERS0_b )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock7releaseEv )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex11scoped_lock11try_acquireERS0_b )\n__TBB_SYMBOL( _ZN3tbb16queuing_rw_mutex18internal_constructEv )\n\n// reader_writer_lock.cpp\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock11scoped_lock16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock11scoped_lock18internal_constructERS1_ )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock13try_lock_readEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16scoped_lock_read16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16scoped_lock_read18internal_constructERS1_ )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock18internal_constructEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock4lockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock6unlockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock8try_lockEv )\n__TBB_SYMBOL( _ZN3tbb10interface518reader_writer_lock9lock_readEv )\n\n#if !TBB_NO_LEGACY\n// spin_rw_mutex.cpp v2\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex16internal_upgradeEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex22internal_itt_releasingEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_acquire_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_acquire_writerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex18internal_downgradeEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_release_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex23internal_release_writerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex27internal_try_acquire_readerEPS0_ )\n__TBB_SYMBOL( _ZN3tbb13spin_rw_mutex27internal_try_acquire_writerEPS0_ )\n#endif\n\n// spin_rw_mutex v3\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v316internal_upgradeEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v318internal_downgradeEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_acquire_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_acquire_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_release_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v323internal_release_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v327internal_try_acquire_readerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v327internal_try_acquire_writerEv )\n__TBB_SYMBOL( _ZN3tbb16spin_rw_mutex_v318internal_constructEv )\n\n// x86_rtm_rw_mutex.cpp\n#if __TBB_TSX_AVAILABLE\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex16internal_releaseERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex16internal_upgradeERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex18internal_constructEv )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex18internal_downgradeERNS2_11scoped_lockE )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex23internal_acquire_readerERNS2_11scoped_lockEb )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex23internal_acquire_writerERNS2_11scoped_lockEb )\n__TBB_SYMBOL( _ZN3tbb10interface88internal16x86_rtm_rw_mutex27internal_try_acquire_writerERNS2_11scoped_lockE )\n#endif\n\n// spin_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb10spin_mutex18internal_constructEv )\n\n// mutex.cpp\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb5mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb5mutex16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb5mutex18internal_constructEv )\n\n// recursive_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock16internal_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock16internal_releaseEv )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex11scoped_lock20internal_try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex16internal_destroyEv )\n__TBB_SYMBOL( _ZN3tbb15recursive_mutex18internal_constructEv )\n\n// queuing_mutex.cpp\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock7acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock7releaseEv )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex11scoped_lock11try_acquireERS0_ )\n__TBB_SYMBOL( _ZN3tbb13queuing_mutex18internal_constructEv )\n\n// critical_section.cpp\n__TBB_SYMBOL( _ZN3tbb8internal19critical_section_v418internal_constructEv )\n\n#if !TBB_NO_LEGACY\n// concurrent_hash_map\n__TBB_SYMBOL( _ZNK3tbb8internal21hash_map_segment_base23internal_grow_predicateEv )\n\n// concurrent_queue.cpp v2\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base12internal_popEPv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base13internal_pushEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base21internal_set_capacityEim )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base23internal_pop_if_presentEPv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_base25internal_push_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_baseC2Em )\n__TBB_SYMBOL( _ZN3tbb8internal21concurrent_queue_baseD2Ev )\n__TBB_SYMBOL( _ZTIN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZTSN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZTVN3tbb8internal21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_base6assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_base7advanceEv )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_baseC2ERKNS0_21concurrent_queue_baseE )\n__TBB_SYMBOL( _ZN3tbb8internal30concurrent_queue_iterator_baseD2Ev )\n__TBB_SYMBOL( _ZNK3tbb8internal21concurrent_queue_base13internal_sizeEv )\n#endif\n\n// concurrent_queue v3\n// constructors\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3C2ERKNS0_24concurrent_queue_base_v3E )\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3C2ERKNS0_24concurrent_queue_base_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v3C2Em )\n// destructors\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v3D2Ev )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v3D2Ev )\n// typeinfo\n__TBB_SYMBOL( _ZTIN3tbb8internal24concurrent_queue_base_v3E )\n__TBB_SYMBOL( _ZTSN3tbb8internal24concurrent_queue_base_v3E )\n// vtable\n__TBB_SYMBOL( _ZTVN3tbb8internal24concurrent_queue_base_v3E )\n// methods\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v37advanceEv )\n__TBB_SYMBOL( _ZN3tbb8internal33concurrent_queue_iterator_base_v36assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v313internal_pushEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v818internal_push_moveEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v325internal_push_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v830internal_push_move_if_not_fullEPKv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v312internal_popEPv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v323internal_pop_if_presentEPv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v314internal_abortEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v321internal_set_capacityEim )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v313internal_sizeEv )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v314internal_emptyEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v321internal_finish_clearEv )\n__TBB_SYMBOL( _ZNK3tbb8internal24concurrent_queue_base_v324internal_throw_exceptionEv )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v36assignERKS1_ )\n__TBB_SYMBOL( _ZN3tbb8internal24concurrent_queue_base_v812move_contentERS1_ )\n\n#if !TBB_NO_LEGACY\n// concurrent_vector.cpp v2\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base13internal_copyERKS1_mPFvPvPKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base14internal_clearEPFvPvmEb )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base15internal_assignERKS1_mPFvPvmEPFvS4_PKvmESA_ )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base16internal_grow_byEmmPFvPvmE )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base16internal_reserveEmmm )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base18internal_push_backEmRm )\n__TBB_SYMBOL( _ZN3tbb8internal22concurrent_vector_base25internal_grow_to_at_leastEmmPFvPvmE )\n__TBB_SYMBOL( _ZNK3tbb8internal22concurrent_vector_base17internal_capacityEv )\n#endif\n\n// concurrent_vector v3\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v313internal_copyERKS1_mPFvPvPKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v314internal_clearEPFvPvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v315internal_assignERKS1_mPFvPvmEPFvS4_PKvmESA_ )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_grow_byEmmPFvPvPKvmES4_ )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_reserveEmmm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v318internal_push_backEmRm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v325internal_grow_to_at_leastEmmPFvPvPKvmES4_ )\n__TBB_SYMBOL( _ZNK3tbb8internal25concurrent_vector_base_v317internal_capacityEv )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v316internal_compactEmPvPFvS2_mEPFvS2_PKvmE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v313internal_swapERS1_ )\n__TBB_SYMBOL( _ZNK3tbb8internal25concurrent_vector_base_v324internal_throw_exceptionEm )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v3D2Ev )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v315internal_resizeEmmmPKvPFvPvmEPFvS4_S3_mE )\n__TBB_SYMBOL( _ZN3tbb8internal25concurrent_vector_base_v337internal_grow_to_at_least_with_resultEmmPFvPvPKvmES4_ )\n\n// tbb_thread\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v314internal_startEPFPvS2_ES2_ )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v320hardware_concurrencyEv )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v34joinEv )\n__TBB_SYMBOL( _ZN3tbb8internal13tbb_thread_v36detachEv )\n__TBB_SYMBOL( _ZN3tbb8internal15free_closure_v3EPv )\n__TBB_SYMBOL( _ZN3tbb8internal15thread_sleep_v3ERKNS_10tick_count10interval_tE )\n__TBB_SYMBOL( _ZN3tbb8internal15thread_yield_v3Ev )\n__TBB_SYMBOL( _ZN3tbb8internal16thread_get_id_v3Ev )\n__TBB_SYMBOL( _ZN3tbb8internal19allocate_closure_v3Em )\n__TBB_SYMBOL( _ZN3tbb8internal7move_v3ERNS0_13tbb_thread_v3ES2_ )\n\n// global parameter\n__TBB_SYMBOL( _ZN3tbb10interface914global_control12active_valueEi )\n__TBB_SYMBOL( _ZN3tbb10interface914global_control15internal_createEv )\n__TBB_SYMBOL( _ZN3tbb10interface914global_control16internal_destroyEv )\n\n#undef __TBB_SYMBOL\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbb/tools_api/ittnotify_config.h": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#ifndef _ITTNOTIFY_CONFIG_H_\n#define _ITTNOTIFY_CONFIG_H_\n\n/** @cond exclude_from_documentation */\n#ifndef ITT_OS_WIN\n#  define ITT_OS_WIN   1\n#endif /* ITT_OS_WIN */\n\n#ifndef ITT_OS_LINUX\n#  define ITT_OS_LINUX 2\n#endif /* ITT_OS_LINUX */\n\n#ifndef ITT_OS_MAC\n#  define ITT_OS_MAC   3\n#endif /* ITT_OS_MAC */\n\n#ifndef ITT_OS_FREEBSD\n#  define ITT_OS_FREEBSD   4\n#endif /* ITT_OS_FREEBSD */\n\n#ifndef ITT_OS\n#  if defined WIN32 || defined _WIN32\n#    define ITT_OS ITT_OS_WIN\n#  elif defined( __APPLE__ ) && defined( __MACH__ )\n#    define ITT_OS ITT_OS_MAC\n#  elif defined( __FreeBSD__ )\n#    define ITT_OS ITT_OS_FREEBSD\n#  else\n#    define ITT_OS ITT_OS_LINUX\n#  endif\n#endif /* ITT_OS */\n\n#ifndef ITT_PLATFORM_WIN\n#  define ITT_PLATFORM_WIN 1\n#endif /* ITT_PLATFORM_WIN */\n\n#ifndef ITT_PLATFORM_POSIX\n#  define ITT_PLATFORM_POSIX 2\n#endif /* ITT_PLATFORM_POSIX */\n\n#ifndef ITT_PLATFORM_MAC\n#  define ITT_PLATFORM_MAC 3\n#endif /* ITT_PLATFORM_MAC */\n\n#ifndef ITT_PLATFORM_FREEBSD\n#  define ITT_PLATFORM_FREEBSD 4\n#endif /* ITT_PLATFORM_FREEBSD */\n\n#ifndef ITT_PLATFORM\n#  if ITT_OS==ITT_OS_WIN\n#    define ITT_PLATFORM ITT_PLATFORM_WIN\n#  elif ITT_OS==ITT_OS_MAC\n#    define ITT_PLATFORM ITT_PLATFORM_MAC\n#  elif ITT_OS==ITT_OS_FREEBSD\n#    define ITT_PLATFORM ITT_PLATFORM_FREEBSD\n#  else\n#    define ITT_PLATFORM ITT_PLATFORM_POSIX\n#  endif\n#endif /* ITT_PLATFORM */\n\n#if defined(_UNICODE) && !defined(UNICODE)\n#define UNICODE\n#endif\n\n#include <stddef.h>\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <tchar.h>\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <stdint.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE || _UNICODE */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#ifndef CDECL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define CDECL __cdecl\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define CDECL __attribute__ ((cdecl))\n#    else  /* _M_IX86 || __i386__ */\n#      define CDECL /* actual only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* CDECL */\n\n#ifndef STDCALL\n#  if ITT_PLATFORM==ITT_PLATFORM_WIN\n#    define STDCALL __stdcall\n#  else /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#    if defined _M_IX86 || defined __i386__\n#      define STDCALL __attribute__ ((stdcall))\n#    else  /* _M_IX86 || __i386__ */\n#      define STDCALL /* supported only on x86 platform */\n#    endif /* _M_IX86 || __i386__ */\n#  endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#endif /* STDCALL */\n\n#define ITTAPI    CDECL\n#define LIBITTAPI CDECL\n\n/* TODO: Temporary for compatibility! */\n#define ITTAPI_CALL    CDECL\n#define LIBITTAPI_CALL CDECL\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n/* use __forceinline (VC++ specific) */\n#define ITT_INLINE           __forceinline\n#define ITT_INLINE_ATTRIBUTE /* nothing */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/*\n * Generally, functions are not inlined unless optimization is specified.\n * For functions declared inline, this attribute inlines the function even\n * if no optimization level was specified.\n */\n#ifdef __STRICT_ANSI__\n#define ITT_INLINE           static\n#define ITT_INLINE_ATTRIBUTE __attribute__((unused))\n#else  /* __STRICT_ANSI__ */\n#define ITT_INLINE           static inline\n#define ITT_INLINE_ATTRIBUTE __attribute__((always_inline, unused))\n#endif /* __STRICT_ANSI__ */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n/** @endcond */\n\n#ifndef ITT_ARCH_IA32\n#  define ITT_ARCH_IA32  1\n#endif /* ITT_ARCH_IA32 */\n\n#ifndef ITT_ARCH_IA32E\n#  define ITT_ARCH_IA32E 2\n#endif /* ITT_ARCH_IA32E */\n\n#ifndef ITT_ARCH_ARM\n#  define ITT_ARCH_ARM  4\n#endif /* ITT_ARCH_ARM */\n\n#ifndef ITT_ARCH_PPC64\n#  define ITT_ARCH_PPC64  5\n#endif /* ITT_ARCH_PPC64 */\n\n#ifndef ITT_ARCH\n#  if defined _M_IX86 || defined __i386__\n#    define ITT_ARCH ITT_ARCH_IA32\n#  elif defined _M_X64 || defined _M_AMD64 || defined __x86_64__\n#    define ITT_ARCH ITT_ARCH_IA32E\n#  elif defined _M_IA64 || defined __ia64__\n#    define ITT_ARCH ITT_ARCH_IA64\n#  elif defined _M_ARM || __arm__\n#    define ITT_ARCH ITT_ARCH_ARM\n#  elif defined __powerpc64__\n#    define ITT_ARCH ITT_ARCH_PPC64\n#  endif\n#endif\n\n#ifdef __cplusplus\n#  define ITT_EXTERN_C extern \"C\"\n#  define ITT_EXTERN_C_BEGIN extern \"C\" {\n#  define ITT_EXTERN_C_END }\n#else\n#  define ITT_EXTERN_C /* nothing */\n#  define ITT_EXTERN_C_BEGIN /* nothing */\n#  define ITT_EXTERN_C_END /* nothing */\n#endif /* __cplusplus */\n\n#define ITT_TO_STR_AUX(x) #x\n#define ITT_TO_STR(x)     ITT_TO_STR_AUX(x)\n\n#define __ITT_BUILD_ASSERT(expr, suffix) do { \\\n    static char __itt_build_check_##suffix[(expr) ? 1 : -1]; \\\n    __itt_build_check_##suffix[0] = 0; \\\n} while(0)\n#define _ITT_BUILD_ASSERT(expr, suffix)  __ITT_BUILD_ASSERT((expr), suffix)\n#define ITT_BUILD_ASSERT(expr)           _ITT_BUILD_ASSERT((expr), __LINE__)\n\n#define ITT_MAGIC { 0xED, 0xAB, 0xAB, 0xEC, 0x0D, 0xEE, 0xDA, 0x30 }\n\n/* Replace with snapshot date YYYYMMDD for promotion build. */\n#define API_VERSION_BUILD    20111111\n\n#ifndef API_VERSION_NUM\n#define API_VERSION_NUM 0.0.0\n#endif /* API_VERSION_NUM */\n\n#define API_VERSION \"ITT-API-Version \" ITT_TO_STR(API_VERSION_NUM) \\\n                                \" (\" ITT_TO_STR(API_VERSION_BUILD) \")\"\n\n/* OS communication functions */\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#include <windows.h>\ntypedef HMODULE           lib_t;\ntypedef DWORD             TIDT;\ntypedef CRITICAL_SECTION  mutex_t;\n#define MUTEX_INITIALIZER { 0 }\n#define strong_alias(name, aliasname) /* empty for Windows */\n#else  /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n#include <dlfcn.h>\n#if defined(UNICODE) || defined(_UNICODE)\n#include <wchar.h>\n#endif /* UNICODE */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE 1 /* need for PTHREAD_MUTEX_RECURSIVE */\n#endif /* _GNU_SOURCE */\n#ifndef __USE_UNIX98\n#define __USE_UNIX98 1 /* need for PTHREAD_MUTEX_RECURSIVE, on SLES11.1 with gcc 4.3.4 wherein pthread.h missing dependency on __USE_XOPEN2K8 */\n#endif /*__USE_UNIX98*/\n#include <pthread.h>\ntypedef void*             lib_t;\ntypedef pthread_t         TIDT;\ntypedef pthread_mutex_t   mutex_t;\n#define MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n#define _strong_alias(name, aliasname) \\\n            extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n#define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\n#if ITT_PLATFORM==ITT_PLATFORM_WIN\n#define __itt_get_proc(lib, name) GetProcAddress(lib, name)\n#define __itt_mutex_init(mutex)   InitializeCriticalSection(mutex)\n#define __itt_mutex_lock(mutex)   EnterCriticalSection(mutex)\n#define __itt_mutex_unlock(mutex) LeaveCriticalSection(mutex)\n#define __itt_load_lib(name)      LoadLibraryA(name)\n#define __itt_unload_lib(handle)  FreeLibrary(handle)\n#define __itt_system_error()      (int)GetLastError()\n#define __itt_fstrcmp(s1, s2)     lstrcmpA(s1, s2)\n#define __itt_fstrnlen(s, l)      strnlen_s(s, l)\n#define __itt_fstrcpyn(s1, b, s2, l) strncpy_s(s1, b, s2, l)\n#define __itt_fstrdup(s)          _strdup(s)\n#define __itt_thread_id()         GetCurrentThreadId()\n#define __itt_thread_yield()      SwitchToThread()\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return InterlockedIncrement(ptr);\n}\n#endif /* ITT_SIMPLE_INIT */\n#else /* ITT_PLATFORM!=ITT_PLATFORM_WIN */\n#define __itt_get_proc(lib, name) dlsym(lib, name)\n#define __itt_mutex_init(mutex)   {\\\n    pthread_mutexattr_t mutex_attr;                                         \\\n    int error_code = pthread_mutexattr_init(&mutex_attr);                   \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_init\",    \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_settype(&mutex_attr,                     \\\n                                           PTHREAD_MUTEX_RECURSIVE);        \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_settype\", \\\n                           error_code);                                     \\\n    error_code = pthread_mutex_init(mutex, &mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutex_init\",        \\\n                           error_code);                                     \\\n    error_code = pthread_mutexattr_destroy(&mutex_attr);                    \\\n    if (error_code)                                                         \\\n        __itt_report_error(__itt_error_system, \"pthread_mutexattr_destroy\", \\\n                           error_code);                                     \\\n}\n#define __itt_mutex_lock(mutex)   pthread_mutex_lock(mutex)\n#define __itt_mutex_unlock(mutex) pthread_mutex_unlock(mutex)\n#define __itt_load_lib(name)      dlopen(name, RTLD_LAZY)\n#define __itt_unload_lib(handle)  dlclose(handle)\n#define __itt_system_error()      errno\n#define __itt_fstrcmp(s1, s2)     strcmp(s1, s2)\n\n/* makes customer code define safe APIs for SDL_STRNLEN_S and SDL_STRNCPY_S */\n#ifdef SDL_STRNLEN_S\n#define __itt_fstrnlen(s, l)      SDL_STRNLEN_S(s, l)\n#else\n#define __itt_fstrnlen(s, l)      strlen(s)\n#endif /* SDL_STRNLEN_S */\n#ifdef SDL_STRNCPY_S\n#define __itt_fstrcpyn(s1, b, s2, l) SDL_STRNCPY_S(s1, b, s2, l)\n#else\n#define __itt_fstrcpyn(s1, b, s2, l) memcpy(s1, s2, l)\n#endif /* SDL_STRNCPY_S */\n\n#define __itt_fstrdup(s)          strdup(s)\n#define __itt_thread_id()         pthread_self()\n#define __itt_thread_yield()      sched_yield()\n#if ITT_ARCH==ITT_ARCH_IA64\n#ifdef __INTEL_COMPILER\n#define __TBB_machine_fetchadd4(addr, val) __fetchadd4_acq((void *)addr, val)\n#else  /* __INTEL_COMPILER */\n/* TODO: Add Support for not Intel compilers for IA-64 architecture */\n#endif /* __INTEL_COMPILER */\n#elif ITT_ARCH==ITT_ARCH_IA32 || ITT_ARCH==ITT_ARCH_IA32E /* ITT_ARCH!=ITT_ARCH_IA64 */\nITT_INLINE long\n__TBB_machine_fetchadd4(volatile void* ptr, long addend) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __TBB_machine_fetchadd4(volatile void* ptr, long addend)\n{\n    long result;\n    __asm__ __volatile__(\"lock\\nxadd %0,%1\"\n                          : \"=r\"(result),\"=m\"(*(int*)ptr)\n                          : \"0\"(addend), \"m\"(*(int*)ptr)\n                          : \"memory\");\n    return result;\n}\n#elif ITT_ARCH==ITT_ARCH_ARM || ITT_ARCH==ITT_ARCH_PPC64\n#define __TBB_machine_fetchadd4(addr, val) __sync_fetch_and_add(addr, val)\n#endif /* ITT_ARCH==ITT_ARCH_IA64 */\n#ifndef ITT_SIMPLE_INIT\nITT_INLINE long\n__itt_interlocked_increment(volatile long* ptr) ITT_INLINE_ATTRIBUTE;\nITT_INLINE long __itt_interlocked_increment(volatile long* ptr)\n{\n    return __TBB_machine_fetchadd4(ptr, 1) + 1L;\n}\n#endif /* ITT_SIMPLE_INIT */\n#endif /* ITT_PLATFORM==ITT_PLATFORM_WIN */\n\ntypedef enum {\n    __itt_collection_normal = 0,\n    __itt_collection_paused = 1\n} __itt_collection_state;\n\ntypedef enum {\n    __itt_thread_normal  = 0,\n    __itt_thread_ignored = 1\n} __itt_thread_state;\n\n#pragma pack(push, 8)\n\ntypedef struct ___itt_thread_info\n{\n    const char* nameA; /*!< Copy of original name in ASCII. */\n#if defined(UNICODE) || defined(_UNICODE)\n    const wchar_t* nameW; /*!< Copy of original name in UNICODE. */\n#else  /* UNICODE || _UNICODE */\n    void* nameW;\n#endif /* UNICODE || _UNICODE */\n    TIDT               tid;\n    __itt_thread_state state;   /*!< Thread state (paused or normal) */\n    int                extra1;  /*!< Reserved to the runtime */\n    void*              extra2;  /*!< Reserved to the runtime */\n    struct ___itt_thread_info* next;\n} __itt_thread_info;\n\n#include \"ittnotify_types.h\" /* For __itt_group_id definition */\n\ntypedef struct ___itt_api_info_20101001\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    __itt_group_id group;\n}  __itt_api_info_20101001;\n\ntypedef struct ___itt_api_info\n{\n    const char*    name;\n    void**         func_ptr;\n    void*          init_func;\n    void*          null_func;\n    __itt_group_id group;\n}  __itt_api_info;\n\nstruct ___itt_domain;\nstruct ___itt_string_handle;\n\ntypedef struct ___itt_global\n{\n    unsigned char          magic[8];\n    unsigned long          version_major;\n    unsigned long          version_minor;\n    unsigned long          version_build;\n    volatile long          api_initialized;\n    volatile long          mutex_initialized;\n    volatile long          atomic_counter;\n    mutex_t                mutex;\n    lib_t                  lib;\n    void*                  error_handler;\n    const char**           dll_path_ptr;\n    __itt_api_info*        api_list_ptr;\n    struct ___itt_global*  next;\n    /* Joinable structures below */\n    __itt_thread_info*     thread_list;\n    struct ___itt_domain*  domain_list;\n    struct ___itt_string_handle* string_list;\n    __itt_collection_state state;\n} __itt_global;\n\n#pragma pack(pop)\n\n#define NEW_THREAD_INFO_W(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = NULL; \\\n        h->nameW  = n ? _wcsdup(n) : NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_THREAD_INFO_A(gptr,h,h_tail,t,s,n) { \\\n    h = (__itt_thread_info*)malloc(sizeof(__itt_thread_info)); \\\n    if (h != NULL) { \\\n        h->tid    = t; \\\n        h->nameA  = n ? __itt_fstrdup(n) : NULL; \\\n        h->nameW  = NULL; \\\n        h->state  = s; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->thread_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_W(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 1;    /* domain is enabled by default */ \\\n        h->nameA  = NULL; \\\n        h->nameW  = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_DOMAIN_A(gptr,h,h_tail,name) { \\\n    h = (__itt_domain*)malloc(sizeof(__itt_domain)); \\\n    if (h != NULL) { \\\n        h->flags  = 1;    /* domain is enabled by default */ \\\n        h->nameA  = name ? __itt_fstrdup(name) : NULL; \\\n        h->nameW  = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->domain_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_W(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = NULL; \\\n        h->strW   = name ? _wcsdup(name) : NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#define NEW_STRING_HANDLE_A(gptr,h,h_tail,name) { \\\n    h = (__itt_string_handle*)malloc(sizeof(__itt_string_handle)); \\\n    if (h != NULL) { \\\n        h->strA   = name ? __itt_fstrdup(name) : NULL; \\\n        h->strW   = NULL; \\\n        h->extra1 = 0;    /* reserved */ \\\n        h->extra2 = NULL; /* reserved */ \\\n        h->next   = NULL; \\\n        if (h_tail == NULL) \\\n            (gptr)->string_list = h; \\\n        else \\\n            h_tail->next = h; \\\n    } \\\n}\n\n#endif /* _ITTNOTIFY_CONFIG_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbbproxy/tbbproxy.cpp": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#include \"tbb/tbb_config.h\"\n#if !__TBB_WIN8UI_SUPPORT\n#define TBB_PREVIEW_RUNTIME_LOADER 1\n#include \"tbb/runtime_loader.h\"\n#include \"tbb/tbb_stddef.h\"\n\n// C standard headers.\n#include <cctype>            // isspace\n#include <cstdarg>           // va_list, etc.\n#include <cstdio>            // fprintf, stderr, etc.\n#include <cstdlib>           // malloc, free, abort.\n#include <cstring>           // strlen, etc.\n\n// C++ standard headers.\n#include <typeinfo>\n\n// OS-specific includes.\n#if _WIN32 || _WIN64\n    #include <windows.h>\n    #define snprintf _snprintf\n    #undef max\n#else\n    #include <dlfcn.h>    // dlopen, dlsym, dlclose, dlerror.\n#endif\n\n#if TBB_USE_ASSERT\n    // We cannot use __TBB_ASSERT as it is because it calls a function from tbb library which may\n    // be not yet loaded. Redefine __TBB_ASSERT not to call tbb functions.\n    #undef __TBB_ASSERT\n    #define __TBB_ASSERT( cond, msg ) {                                                            \\\n        if ( ! (cond) ) {                                                                          \\\n            say( \"%s:%d: Assertion failed: %s.\", __FILE__, __LINE__, (msg) );                      \\\n        } /* if */                                                                                 \\\n        /* TODO: abort? */                                                                         \\\n    }\n#endif\n\n// Declare here, define at the bottom.\nextern \"C\" int __tbb_internal_runtime_loader_stub();\n\nnamespace tbb {\n\nnamespace interface6 {\n\nnamespace internal {\n\nnamespace runtime_loader {\n\n\n/*\n    ------------------------------------------------------------------------------------------------\n    User interaction utilities.\n    ------------------------------------------------------------------------------------------------\n*/\n\n\n// Print message to stderr. Do not call it directly, use say() or tell() instead.\nstatic void _say( char const * format, va_list args ) {\n    /*\n        On 64-bit Linux* OS, vsnprintf() modifies args argument,\n        so vsnprintf() crashes if it is called for the second time with the same args.\n        To prevent the crash, we have to pass a fresh intact copy of args to vsnprintf() each time.\n\n        On Windows* OS, unfortunately, standard va_copy() macro is not available. However, it\n        seems vsnprintf() does not modify args argument.\n    */\n    #if ! ( _WIN32 || _WIN64 )\n        va_list _args;\n        __va_copy( _args, args );  // Make copy of args.\n        #define args _args         // Substitute args with its copy, _args.\n    #endif\n    int len = vsnprintf( NULL, 0, format, args );\n    #if ! ( _WIN32 || _WIN64 )\n        #undef args                // Remove substitution.\n        va_end( _args );\n    #endif\n    char * buf = reinterpret_cast< char * >( malloc( len + 1 ) );\n    if ( buf != NULL ) {\n        vsnprintf( buf, len + 1, format, args );\n        fprintf( stderr, \"TBB: %s\\n\", buf );\n        free( buf );\n    } else {\n        fprintf( stderr, \"TBB: Not enough memory for message: %s\\n\", format );\n    }\n} // _say\n\n\n// Debug/test/troubleshooting printing controlled by TBB_VERSION environment variable.\n// To enable printing, the variable must be set and not empty.\n// Do not call it directly, use tell() instead.\nstatic void _tell( char const * format, va_list args ) {\n    char const * var = getenv( \"TBB_VERSION\" );\n    if ( var != NULL && var[ 0 ] != 0 ) {\n        _say( format, args );\n    } // if\n} // _tell\n\n\n// Print message to stderr unconditionally.\nstatic void say( char const * format, ... ) {\n    va_list args;\n    va_start( args, format );\n    _say( format, args );\n    va_end( args );\n} // say\n\n\n// Debug/test/troubleshooting printing controlled by TBB_VERSION environment variable.\n// To enable printing, the variable must be set and not empty.\nstatic void tell( char const * format, ... ) {\n    va_list args;\n    va_start( args, format );\n    _tell( format, args );\n    va_end( args );\n} // tell\n\n\n// Error reporting utility. Behavior depends on mode.\nstatic tbb::runtime_loader::error_code error( tbb::runtime_loader::error_mode mode, tbb::runtime_loader::error_code err, char const * format, ... ) {\n    va_list args;\n    va_start( args, format );\n    if ( mode == tbb::runtime_loader::em_abort ) {\n        // In em_abort mode error message printed unconditionally.\n        _say( format, args );\n    } else {\n        // In other modes printing depends on TBB_VERSION environment variable.\n        _tell( format, args );\n    } // if\n    va_end( args );\n    switch ( mode ) {\n        case tbb::runtime_loader::em_abort : {\n            say( \"Aborting...\" );\n            #if TBB_USE_DEBUG && ( _WIN32 || _WIN64 )\n                DebugBreak();\n            #endif\n            abort();\n        } break;\n        case tbb::runtime_loader::em_throw : {\n            throw err;\n        } break;\n        case tbb::runtime_loader::em_status : {\n            // Do nothing.\n        } break;\n    } // switch\n    return err;\n} // error\n\n\n/*\n    ------------------------------------------------------------------------------------------------\n    General-purpose string manipulation utilities.\n    ------------------------------------------------------------------------------------------------\n*/\n\n\n// Delete character ch from string str in-place.\nstatic void strip( char * str, char ch ) {\n    int in  = 0;  // Input character index.\n    int out = 0;  // Output character index.\n    for ( ; ; ) {\n        if ( str[ in ] != ch ) {\n            str[ out ] = str[ in ];\n            ++ out;\n        } // if\n        if ( str[ in ] == 0 ) {\n            break;\n        } // if\n        ++ in;\n    } // forever\n} // func strip\n\n\n// Strip trailing whitespaces in-place.\nstatic void trim( char * str ) {\n    size_t len = strlen( str );\n    while ( len > 0 && isspace( str[ len - 1 ] ) ) {\n        -- len;\n    } // while\n    str[ len ] = 0;\n} // func trim\n\n\n#if _WIN32 || _WIN64\n    // \"When specifying a path, be sure to use backslashes (\\), not forward slashes (/).\"\n    // (see http://msdn.microsoft.com/en-us/library/ms886736.aspx).\n    const char proper_slash = '\\\\';\n    inline char char_or_slash( char c ) { return c=='/'? '\\\\': c; }\n#else\n    const char proper_slash = '/';\n    inline char char_or_slash( char c ) { return c; }\n#endif\n\n// Concatenate name of directory and name of file.\nvoid cat_file( char const * dir, char const * file, char * buffer, size_t len ) {\n    size_t i = 0;\n    // Copy directory name\n    for( ; i<len && *dir; ++i, ++dir ) {\n        buffer[i] = char_or_slash(*dir);\n    }\n    // Append trailing slash if missed.\n    if( i>0 && i<len && buffer[i-1]!=proper_slash ) {\n        buffer[i++] = proper_slash;\n    }\n    // Copy file name\n    __TBB_ASSERT( char_or_slash(*file)!=proper_slash, \"File name starts with a slash\" );\n    for( ; i<len && *file; ++i, ++file ) {\n        buffer[i] = *file;\n    }\n    // Append null terminator\n    buffer[ i<len? i: len-1 ] = '\\0';\n} // cat_file\n\n\n/*\n    ------------------------------------------------------------------------------------------------\n    Windows implementation of dlopen, dlclose, dlsym, dlerror.\n    ------------------------------------------------------------------------------------------------\n*/\n\n\n#if _WIN32 || _WIN64\n\n    // Implement Unix-like interface (dlopen, dlclose, dlsym, dlerror) via Win32 API functions.\n\n    // Type of dlopen result.\n    typedef HMODULE handle_t;\n\n    enum rtld_flags_t {\n        RTLD_NOW,\n        RTLD_GLOBAL\n    }; // enum rtld_flags_t\n\n    // Unix-like dlopen().\n    static handle_t dlopen( char const * name, rtld_flags_t ) {\n        return LoadLibrary( name );\n    } // dlopen\n\n    // Unix-like dlsym().\n    static void * dlsym( handle_t lib, char const * sym ) {\n        return (void*)GetProcAddress( lib, sym );\n    } // dlsym\n\n    // Unix-like dlclose().\n    static int dlclose( handle_t lib ) {\n        return ! FreeLibrary( lib );\n    } // dlclose\n\n    // The function mimics Unix dlerror() function.\n    // Note: Not thread-safe due to statically allocated buffer.\n    static char * dlerror() {\n\n        static char buffer[ 2048 ];  // Note: statically allocated buffer.\n\n        DWORD err = GetLastError();\n        if ( err == ERROR_SUCCESS ) {\n            return NULL;\n        } // if\n\n        DWORD rc;\n        rc =\n            FormatMessage(\n                FORMAT_MESSAGE_FROM_SYSTEM,\n                NULL,\n                err,\n                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language.\n                reinterpret_cast< LPTSTR >( & buffer ),\n                sizeof( buffer ),\n                NULL\n            );\n        if ( rc == 0 ) {\n            // FormatMessage() failed to format system error message. Buffer to short or another issue.\n            snprintf( buffer, sizeof( buffer ), \"System error %u.\", err );\n        } else {\n            /*\n                FormatMessage() returns Windows-style end-of-lines, \"\\r\\n\". When string is printed,\n                printf() also replaces all the occurrences of \"\\n\" with \"\\r\\n\" (again!), so sequences\n                like \"\\r\\r\\r\\n\" appear in output. It is not too good. Stripping all \"\\r\" normalizes\n                string and returns it to canonical form, so printf() will produce correct end-of-line\n                sequences.\n            */\n            strip( buffer, '\\r' );   // Delete carriage returns if any.\n            trim( buffer );          // Delete trailing newlines and spaces.\n        } // if\n\n        return buffer;\n\n    } // dlerror\n\n#else\n\n    // Type of dlopen() result.\n    typedef void * handle_t;\n\n#endif\n\n\n/*\n    ------------------------------------------------------------------------------------------------\n    Runtime loader stuff.\n    ------------------------------------------------------------------------------------------------\n*/\n\n\n// Descriptor table declaration. It is defined in assembler file.\nenum symbol_type_t {\n    st_object   = 0,\n    st_function = 1\n}; // enum symbol_type_t\nstruct symbol_t {\n    void *        addr;\n    char const *  name;\n    int           size;\n    symbol_type_t type;\n}; // symbol_t\nextern \"C\" symbol_t __tbb_internal_runtime_loader_symbols[];\n\n// Hooks for internal use (e. g. for testing).\ntbb::runtime_loader::error_mode stub_mode = tbb::runtime_loader::em_abort;\n\nstatic char const * tbb_dll_name = __TBB_STRING(__TBB_DLL_NAME);  // Name of TBB library.\nstatic handle_t     handle       = NULL;                          // Handle of loaded TBB library or NULL.\nstatic int          version      = 0;                             // Version of the loaded library.\nstatic int          counter      = 0;                             // Number of runtime_loader objects using the loaded library.\n\n#define ANOTHER_RTL \"probably multiple runtime_loader objects work in parallel\"\n\n\n// One attempt to load library (dll_name can be a full path or just a file name).\nstatic tbb::runtime_loader::error_code _load( char const * dll_name, int min_ver, int max_ver ) {\n\n    tbb::runtime_loader::error_mode mode = tbb::runtime_loader::em_status;\n    tbb::runtime_loader::error_code code = tbb::runtime_loader::ec_ok;\n\n    /*\n        If these variables declared at the first usage, Intel C++ Compiler may issue warning(s):\n            transfer of control [goto error] bypasses initialization of: ...\n        Declaring variables at the beginning of the function eliminates warnings.\n    */\n    typedef int (*int_func_t)( void );\n    char const * get_ver_name = \"TBB_runtime_interface_version\"; // Name of function.\n    int_func_t   get_ver_func = NULL;                            // Pointer to function.\n    handle_t     _handle      = NULL;\n    int          _version     = 0;\n    int          total        = 0;\n    int          not_found    = 0;\n\n    // This function should be called iff there is no loaded library.\n    __TBB_ASSERT( handle  == NULL, \"Handle is invalid; \"  ANOTHER_RTL );\n    __TBB_ASSERT( version == 0,    \"Version is invalid; \" ANOTHER_RTL );\n    __TBB_ASSERT( counter == 0,    \"Counter is invalid; \" ANOTHER_RTL );\n\n    tell( \"Loading \\\"%s\\\"...\", dll_name );\n\n    // First load the library.\n    _handle = dlopen( dll_name, RTLD_NOW );\n    if ( _handle == NULL ) {\n        const char * msg = dlerror();\n        code = error( mode, tbb::runtime_loader::ec_no_lib, \"Loading \\\"%s\\\" failed; system error: %s\", dll_name, msg );\n        goto error;\n    } // if\n\n    // Then try to find out its version.\n    /*\n        g++ 3.4 issues error:\n            ISO C++ forbids casting between pointer-to-function and pointer-to-object\n        on reinterpret_cast<>. Thus, we have no choice but using C-style type cast.\n    */\n    get_ver_func = (int_func_t) dlsym( _handle, get_ver_name );\n    if ( get_ver_func == NULL ) {\n        code = error( mode, tbb::runtime_loader::ec_bad_lib, \"Symbol \\\"%s\\\" not found; library rejected.\", get_ver_name );\n        goto error;\n    } // if\n    _version = get_ver_func();\n    if ( ! ( min_ver <= _version && _version <= max_ver ) ) {\n        code = error( mode, tbb::runtime_loader::ec_bad_ver, \"Version %d is out of requested range; library rejected.\", _version );\n        goto error;\n    } // if\n\n    // Library is suitable. Mark it as loaded.\n    handle   = _handle;\n    version  = _version;\n    counter += 1;\n    __TBB_ASSERT( counter == 1, \"Counter is invalid; \" ANOTHER_RTL );\n\n    // Now search for all known symbols.\n    for ( int i = 0; __tbb_internal_runtime_loader_symbols[ i ].name != NULL; ++ i ) {\n        symbol_t & symbol = __tbb_internal_runtime_loader_symbols[ i ];\n        // Verify symbol descriptor.\n        __TBB_ASSERT( symbol.type == st_object || symbol.type == st_function, \"Invalid symbol type\" );\n        #if _WIN32 || _WIN64\n            __TBB_ASSERT( symbol.type == st_function, \"Should not be symbols of object type on Windows\" );\n        #endif\n        if ( symbol.type == st_object ) {\n            __TBB_ASSERT( symbol.addr != NULL, \"Object address invalid\" );\n            __TBB_ASSERT( symbol.size > 0, \"Symbol size must be > 0\" );\n            __TBB_ASSERT( symbol.size <= 0x1000, \"Symbol size too big\" );\n        } else {                     // Function\n            // __TBB_ASSERT( symbol.addr == reinterpret_cast< void * >( & stub ), \"Invalid symbol address\" );\n            __TBB_ASSERT( symbol.size == sizeof( void * ), \"Invalid symbol size\" );\n        } // if\n        void * addr = dlsym( _handle, symbol.name );\n        if ( addr != NULL ) {\n            if ( symbol.type == st_object ) {\n                if ( strncmp( symbol.name, \"_ZTS\", 4 ) == 0 ) {\n                    // If object name begins with \"_ZTS\", it is a string, mangled type name.\n                    // Its value must equal to name of symbol without \"_ZTS\" prefix.\n                    char const * name = static_cast< char const * >( addr );\n                    __TBB_ASSERT( strlen( name ) + 1 == size_t( symbol.size ), \"Unexpected size of typeinfo name\" );\n                    __TBB_ASSERT( strcmp( symbol.name + 4, name ) == 0, \"Unexpected content of typeinfo name\" );\n                    strncpy( reinterpret_cast< char * >( symbol.addr ), name, symbol.size );\n                    reinterpret_cast< char * >( symbol.addr )[ symbol.size - 1 ] = 0;\n                } else {\n                    #if TBB_USE_ASSERT\n                        // If object name begins with \"_ZTI\", it is an object of std::type_info class.\n                        // Its protected value must equal to name of symbol without \"_ZTI\" prefix.\n                        if ( strncmp( symbol.name, \"_ZTI\", 4 ) == 0 ) {\n                            std::type_info const * info = static_cast< std::type_info const * >( addr );\n                            __TBB_ASSERT( size_t( symbol.size ) >= sizeof( std::type_info ), \"typeinfo size is too small\" );\n                            // std::type_info::name is not a virtual method, it is safe to call it.\n                            __TBB_ASSERT( strcmp( symbol.name + 4, info->name() ) == 0, \"Unexpected content of typeinfo\" );\n                        } // if\n                    #endif\n                    // Copy object content from libtbb into runtime_loader.\n                    memcpy( symbol.addr, addr, symbol.size );\n                }; // if\n            } else {                     // Function\n                symbol.addr = addr;\n            } // if\n        } else {\n            char const * msg = dlerror();\n            tell( \"Symbol \\\"%s\\\" not found; system error: %s\", symbol.name, msg );\n            ++ not_found;\n        } // if\n        ++ total;\n    } // for i\n\n    if ( not_found > 0 ) {\n        tell( \"%d of %d symbols not found.\", not_found, total );\n    } // if\n\n    tell( \"The library successfully loaded.\" );\n    return code;\n\n    error:\n        if ( _handle != NULL ) {\n            int rc = dlclose( _handle );\n            if ( rc != 0 ) {\n                // Error occurred.\n                __TBB_ASSERT( rc != 0, \"Unexpected error: dlclose() failed\" );\n            } // if\n        } // if\n        _handle = NULL;\n        return code;\n\n} // _load\n\n\nstatic tbb::runtime_loader::error_code load( tbb::runtime_loader::error_mode mode, char const * path[], int min_ver, int max_ver ) {\n    // Check arguments first.\n    if ( min_ver <= 0 ) {\n        return error( mode, tbb::runtime_loader::ec_bad_arg, \"tbb::runtime_loader::load(): Invalid value of min_ver argument: %d.\", min_ver );\n    } // if\n    if ( max_ver <= 0 ) {\n        return error( mode, tbb::runtime_loader::ec_bad_arg, \"tbb::runtime_loader::load(): Invalid value of max_ver argument: %d.\", max_ver );\n    } // if\n    if ( min_ver > max_ver ) {\n        return error( mode, tbb::runtime_loader::ec_bad_arg, \"tbb::runtime_loader::load(): min_ver and max_ver specify empty range: [%d, %d].\", min_ver, max_ver );\n    } // if\n    if ( min_ver == max_ver ) {\n        tell( \"Searching for \\\"%s\\\" version %d...\", tbb_dll_name, min_ver );\n    } else if ( max_ver == INT_MAX ) {\n        tell( \"Searching for \\\"%s\\\" version %d+...\", tbb_dll_name, min_ver );\n    } else {\n        tell( \"Searching for \\\"%s\\\" version in range [%d, %d]...\", tbb_dll_name, min_ver, max_ver );\n    } // if\n    // Then check whether a library already loaded.\n    if ( handle != NULL ) {\n        // Library already loaded. Check whether the version is compatible.\n        __TBB_ASSERT( version > 0, \"Version is invalid; \" ANOTHER_RTL );\n        __TBB_ASSERT( counter > 0, \"Counter is invalid; \" ANOTHER_RTL );\n        if ( min_ver <= version && version <= max_ver ) {\n            // Version is ok, let us use this library.\n            tell( \"Library version %d is already loaded.\", version );\n            counter += 1;\n            return tbb::runtime_loader::ec_ok;\n        } else {\n            // Version is not suitable.\n            return error( mode, tbb::runtime_loader::ec_bad_ver, \"Library version %d is already loaded.\", version );\n        } // if\n    } // if\n    // There is no loaded library, try to load it using provided directories.\n    __TBB_ASSERT( version == 0, \"Version is invalid; \" ANOTHER_RTL );\n    __TBB_ASSERT( counter == 0, \"Counter is invalid; \" ANOTHER_RTL );\n    size_t namelen = strlen(tbb_dll_name);\n    size_t buflen = 0;\n    char * buffer = NULL;\n    for ( int i = 0; path[i] != NULL; ++ i ) {\n        size_t len = strlen(path[i]) + namelen + 2; // 1 for slash and 1 for null terminator\n        if( buflen<len ) {\n            free( buffer );\n            buflen = len;\n            buffer = (char*)malloc( buflen );\n            if( !buffer )\n                return error( mode, tbb::runtime_loader::ec_no_lib, \"Not enough memory.\" );\n        }\n        cat_file( path[i], tbb_dll_name, buffer, buflen );\n        __TBB_ASSERT(strstr(buffer,tbb_dll_name), \"Name concatenation error\");\n        tbb::runtime_loader::error_code ec = _load( buffer, min_ver, max_ver );\n        if ( ec == tbb::runtime_loader::ec_ok ) {\n            return ec;       // Success. Exiting...\n        } // if\n    } // for i\n    free( buffer );\n    return error( mode, tbb::runtime_loader::ec_no_lib, \"No suitable library found.\" );\n} // load\n\n\n\n\n// Suppress \"defined but not used\" compiler warnings.\nstatic void const * dummy[] = {\n    (void *) & strip,\n    (void *) & trim,\n    & dummy,\n    NULL\n};\n\n\n} // namespace runtime_loader\n\n} // namespace internal\n\n\nruntime_loader::runtime_loader( error_mode mode ) :\n    my_mode( mode ),\n    my_status( ec_ok ),\n    my_loaded( false )\n{\n} // ctor\n\n\nruntime_loader::runtime_loader( char const * path[], int min_ver, int max_ver, error_mode mode ) :\n    my_mode( mode ),\n    my_status( ec_ok ),\n    my_loaded( false )\n{\n    load( path, min_ver, max_ver );\n} // ctor\n\n\nruntime_loader::~runtime_loader() {\n} // dtor\n\n\ntbb::runtime_loader::error_code runtime_loader::load( char const * path[], int min_ver, int max_ver ) {\n    if ( my_loaded ) {\n        my_status = tbb::interface6::internal::runtime_loader::error( my_mode, ec_bad_call, \"tbb::runtime_loader::load(): Library already loaded by this runtime_loader object.\" );\n    } else {\n        my_status = internal::runtime_loader::load( my_mode, path, min_ver, max_ver );\n        if ( my_status == ec_ok ) {\n            my_loaded = true;\n        } // if\n    } // if\n    return my_status;\n} // load\n\n\n\n\ntbb::runtime_loader::error_code runtime_loader::status() {\n    return my_status;\n} // status\n\n\n} // namespace interface6\n\n} // namespace tbb\n\n\n// Stub function replaces all TBB entry points when no library is loaded.\nint __tbb_internal_runtime_loader_stub() {\n    char const * msg = NULL;\n    if ( tbb::interface6::internal::runtime_loader::handle == NULL ) {\n        msg = \"A function is called while TBB library is not loaded\";\n    } else {\n        msg = \"A function is called which is not present in loaded TBB library\";\n    } // if\n    return tbb::interface6::internal::runtime_loader::error( tbb::interface6::internal::runtime_loader::stub_mode, tbb::runtime_loader::ec_no_lib, msg );\n} // stub\n\n#endif // !__TBB_WIN8UI_SUPPORT //\n// end of file //\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/src/tbb/src/tbbmalloc/proxy.cpp": "/*\n    Copyright (c) 2005-2017 Intel Corporation\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n\n*/\n\n#include \"proxy.h\"\n#include \"tbb/tbb_config.h\"\n\n#if !defined(__EXCEPTIONS) && !defined(_CPPUNWIND) && !defined(__SUNPRO_CC)\n    #if TBB_USE_EXCEPTIONS\n        #error Compilation settings do not support exception handling. Please do not set TBB_USE_EXCEPTIONS macro or set it to 0.\n    #elif !defined(TBB_USE_EXCEPTIONS)\n        #define TBB_USE_EXCEPTIONS 0\n    #endif\n#elif !defined(TBB_USE_EXCEPTIONS)\n    #define TBB_USE_EXCEPTIONS 1\n#endif\n\n#if MALLOC_UNIXLIKE_OVERLOAD_ENABLED || MALLOC_ZONE_OVERLOAD_ENABLED\n\n#ifndef __THROW\n#define __THROW\n#endif\n\n/*** service functions and variables ***/\n\n#include <string.h> // for memset\n#include <unistd.h> // for sysconf\n\nstatic long memoryPageSize;\n\nstatic inline void initPageSize()\n{\n    memoryPageSize = sysconf(_SC_PAGESIZE);\n}\n\n#if MALLOC_UNIXLIKE_OVERLOAD_ENABLED\n#include \"Customize.h\" // FencedStore\n#include <dlfcn.h>\n#include <malloc.h>    // mallinfo\n\n/* __TBB_malloc_proxy used as a weak symbol by libtbbmalloc for:\n   1) detection that the proxy library is loaded\n   2) check that dlsym(\"malloc\") found something different from our replacement malloc\n*/\nextern \"C\" void *__TBB_malloc_proxy(size_t) __attribute__ ((alias (\"malloc\")));\n\nstatic void *orig_msize;\n\n#elif MALLOC_ZONE_OVERLOAD_ENABLED\n\n#include \"proxy_overload_osx.h\"\n\n#endif // MALLOC_ZONE_OVERLOAD_ENABLED\n\n// Original (i.e., replaced) functions,\n// they are never changed for MALLOC_ZONE_OVERLOAD_ENABLED.\nstatic void *orig_free,\n    *orig_realloc;\n\n#if MALLOC_UNIXLIKE_OVERLOAD_ENABLED\n#define ZONE_ARG\n#define PREFIX(name) name\n\nstatic void *orig_libc_free,\n    *orig_libc_realloc;\n\n// We already tried to find ptr to original functions.\nstatic intptr_t origFuncSearched;\n\ninline void InitOrigPointers()\n{\n    // race is OK here, as different threads found same functions\n    if (!origFuncSearched) {\n        orig_free = dlsym(RTLD_NEXT, \"free\");\n        orig_realloc = dlsym(RTLD_NEXT, \"realloc\");\n        orig_msize = dlsym(RTLD_NEXT, \"malloc_usable_size\");\n        orig_libc_free = dlsym(RTLD_NEXT, \"__libc_free\");\n        orig_libc_realloc = dlsym(RTLD_NEXT, \"__libc_realloc\");\n\n        FencedStore(origFuncSearched, 1);\n    }\n}\n\n/*** replacements for malloc and the family ***/\nextern \"C\" {\n#elif MALLOC_ZONE_OVERLOAD_ENABLED\n\n// each impl_* function has such 1st argument, it's unused\n#define ZONE_ARG struct _malloc_zone_t *,\n#define PREFIX(name) impl_##name\n// not interested in original functions for zone overload\ninline void InitOrigPointers() {}\n\n#endif // MALLOC_UNIXLIKE_OVERLOAD_ENABLED and MALLOC_ZONE_OVERLOAD_ENABLED\n\nvoid *PREFIX(malloc)(ZONE_ARG size_t size) __THROW\n{\n    return scalable_malloc(size);\n}\n\nvoid *PREFIX(calloc)(ZONE_ARG size_t num, size_t size) __THROW\n{\n    return scalable_calloc(num, size);\n}\n\nvoid PREFIX(free)(ZONE_ARG void *object) __THROW\n{\n    InitOrigPointers();\n    __TBB_malloc_safer_free(object, (void (*)(void*))orig_free);\n}\n\nvoid *PREFIX(realloc)(ZONE_ARG void* ptr, size_t sz) __THROW\n{\n    InitOrigPointers();\n    return __TBB_malloc_safer_realloc(ptr, sz, orig_realloc);\n}\n\n/* The older *NIX interface for aligned allocations;\n   it's formally substituted by posix_memalign and deprecated,\n   so we do not expect it to cause cyclic dependency with C RTL. */\nvoid *PREFIX(memalign)(ZONE_ARG size_t alignment, size_t size) __THROW\n{\n    return scalable_aligned_malloc(size, alignment);\n}\n\n/* valloc allocates memory aligned on a page boundary */\nvoid *PREFIX(valloc)(ZONE_ARG size_t size) __THROW\n{\n    if (! memoryPageSize) initPageSize();\n\n    return scalable_aligned_malloc(size, memoryPageSize);\n}\n\n#undef ZONE_ARG\n#undef PREFIX\n\n#if MALLOC_UNIXLIKE_OVERLOAD_ENABLED\n\n// match prototype from system headers\n#if __ANDROID__\nsize_t malloc_usable_size(const void *ptr) __THROW\n#else\nsize_t malloc_usable_size(void *ptr) __THROW\n#endif\n{\n    InitOrigPointers();\n    return __TBB_malloc_safer_msize(const_cast<void*>(ptr), (size_t (*)(void*))orig_msize);\n}\n\nint posix_memalign(void **memptr, size_t alignment, size_t size) __THROW\n{\n    return scalable_posix_memalign(memptr, alignment, size);\n}\n\n/* pvalloc allocates smallest set of complete pages which can hold\n   the requested number of bytes. Result is aligned on page boundary. */\nvoid *pvalloc(size_t size) __THROW\n{\n    if (! memoryPageSize) initPageSize();\n    // align size up to the page size,\n    // pvalloc(0) returns 1 page, see man libmpatrol\n    size = size? ((size-1) | (memoryPageSize-1)) + 1 : memoryPageSize;\n\n    return scalable_aligned_malloc(size, memoryPageSize);\n}\n\nint mallopt(int /*param*/, int /*value*/) __THROW\n{\n    return 1;\n}\n\nstruct mallinfo mallinfo() __THROW\n{\n    struct mallinfo m;\n    memset(&m, 0, sizeof(struct mallinfo));\n\n    return m;\n}\n\n#if __ANDROID__\n// Android doesn't have malloc_usable_size, provide it to be compatible\n// with Linux, in addition overload dlmalloc_usable_size() that presented\n// under Android.\nsize_t dlmalloc_usable_size(const void *ptr) __attribute__ ((alias (\"malloc_usable_size\")));\n#else // __ANDROID__\n// C11 function, supported starting GLIBC 2.16\nvoid *aligned_alloc(size_t alignment, size_t size) __attribute__ ((alias (\"memalign\")));\n// Those non-standard functions are exported by GLIBC, and might be used\n// in conjunction with standard malloc/free, so we must ovberload them.\n// Bionic doesn't have them. Not removing from the linker scripts,\n// as absent entry points are ignored by the linker.\nvoid *__libc_malloc(size_t size) __attribute__ ((alias (\"malloc\")));\nvoid *__libc_calloc(size_t num, size_t size) __attribute__ ((alias (\"calloc\")));\nvoid *__libc_memalign(size_t alignment, size_t size) __attribute__ ((alias (\"memalign\")));\nvoid *__libc_pvalloc(size_t size) __attribute__ ((alias (\"pvalloc\")));\nvoid *__libc_valloc(size_t size) __attribute__ ((alias (\"valloc\")));\n\n// call original __libc_* to support naive replacement of free via __libc_free etc\nvoid __libc_free(void *ptr)\n{\n    InitOrigPointers();\n    __TBB_malloc_safer_free(ptr, (void (*)(void*))orig_libc_free);\n}\n\nvoid *__libc_realloc(void *ptr, size_t size)\n{\n    InitOrigPointers();\n    return __TBB_malloc_safer_realloc(ptr, size, orig_libc_realloc);\n}\n#endif // !__ANDROID__\n\n} /* extern \"C\" */\n\n/*** replacements for global operators new and delete ***/\n\n#include <new>\n\nvoid * operator new(size_t sz) {\n    void *res = scalable_malloc(sz);\n#if TBB_USE_EXCEPTIONS\n    if (NULL == res)\n        throw std::bad_alloc();\n#endif /* TBB_USE_EXCEPTIONS */\n    return res;\n}\nvoid* operator new[](size_t sz) {\n    void *res = scalable_malloc(sz);\n#if TBB_USE_EXCEPTIONS\n    if (NULL == res)\n        throw std::bad_alloc();\n#endif /* TBB_USE_EXCEPTIONS */\n    return res;\n}\nvoid operator delete(void* ptr) throw() {\n    InitOrigPointers();\n    __TBB_malloc_safer_free(ptr, (void (*)(void*))orig_free);\n}\nvoid operator delete[](void* ptr) throw() {\n    InitOrigPointers();\n    __TBB_malloc_safer_free(ptr, (void (*)(void*))orig_free);\n}\nvoid* operator new(size_t sz, const std::nothrow_t&) throw() {\n    return scalable_malloc(sz);\n}\nvoid* operator new[](std::size_t sz, const std::nothrow_t&) throw() {\n    return scalable_malloc(sz);\n}\nvoid operator delete(void* ptr, const std::nothrow_t&) throw() {\n    InitOrigPointers();\n    __TBB_malloc_safer_free(ptr, (void (*)(void*))orig_free);\n}\nvoid operator delete[](void* ptr, const std::nothrow_t&) throw() {\n    InitOrigPointers();\n    __TBB_malloc_safer_free(ptr, (void (*)(void*))orig_free);\n}\n\n#endif /* MALLOC_UNIXLIKE_OVERLOAD_ENABLED */\n#endif /* MALLOC_UNIXLIKE_OVERLOAD_ENABLED || MALLOC_ZONE_OVERLOAD_ENABLED */\n\n\n#ifdef _WIN32\n#include <windows.h>\n\n#if !__TBB_WIN8UI_SUPPORT\n\n#include <stdio.h>\n#include \"tbb_function_replacement.h\"\n#include \"shared_utils.h\"\n\nvoid __TBB_malloc_safer_delete( void *ptr)\n{\n    __TBB_malloc_safer_free( ptr, NULL );\n}\n\nvoid* safer_aligned_malloc( size_t size, size_t alignment )\n{\n    // workaround for \"is power of 2 pow N\" bug that accepts zeros\n    return scalable_aligned_malloc( size, alignment>sizeof(size_t*)?alignment:sizeof(size_t*) );\n}\n\n// we do not support _expand();\nvoid* safer_expand( void *, size_t )\n{\n    return NULL;\n}\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(CRTLIB)                                             \\\nvoid (*orig_free_##CRTLIB)(void*);                                                                   \\\nvoid __TBB_malloc_safer_free_##CRTLIB(void *ptr)                                                     \\\n{                                                                                                    \\\n    __TBB_malloc_safer_free( ptr, orig_free_##CRTLIB );                                              \\\n}                                                                                                    \\\n                                                                                                     \\\nvoid (*orig__aligned_free_##CRTLIB)(void*);                                                          \\\nvoid __TBB_malloc_safer__aligned_free_##CRTLIB(void *ptr)                                            \\\n{                                                                                                    \\\n    __TBB_malloc_safer_free( ptr, orig__aligned_free_##CRTLIB );                                     \\\n}                                                                                                    \\\n                                                                                                     \\\nsize_t (*orig__msize_##CRTLIB)(void*);                                                               \\\nsize_t __TBB_malloc_safer__msize_##CRTLIB(void *ptr)                                                 \\\n{                                                                                                    \\\n    return __TBB_malloc_safer_msize( ptr, orig__msize_##CRTLIB );                                    \\\n}                                                                                                    \\\n                                                                                                     \\\nsize_t (*orig__aligned_msize_##CRTLIB)(void*, size_t, size_t);                                       \\\nsize_t __TBB_malloc_safer__aligned_msize_##CRTLIB( void *ptr, size_t alignment, size_t offset)       \\\n{                                                                                                    \\\n    return __TBB_malloc_safer_aligned_msize( ptr, alignment, offset, orig__aligned_msize_##CRTLIB ); \\\n}                                                                                                    \\\n                                                                                                     \\\nvoid* __TBB_malloc_safer_realloc_##CRTLIB( void *ptr, size_t size )                                  \\\n{                                                                                                    \\\n    orig_ptrs func_ptrs = {orig_free_##CRTLIB, orig__msize_##CRTLIB};                                \\\n    return __TBB_malloc_safer_realloc( ptr, size, &func_ptrs );                                      \\\n}                                                                                                    \\\n                                                                                                     \\\nvoid* __TBB_malloc_safer__aligned_realloc_##CRTLIB( void *ptr, size_t size, size_t aligment )        \\\n{                                                                                                    \\\n    orig_aligned_ptrs func_ptrs = {orig__aligned_free_##CRTLIB, orig__aligned_msize_##CRTLIB};       \\\n    return __TBB_malloc_safer_aligned_realloc( ptr, size, aligment, &func_ptrs );                    \\\n}\n\n// Limit is 30 bytes/60 symbols per line, * can be used to match any digit in bytecodes.\n// Purpose of the pattern is to mark an instruction bound, it should consist of several\n// full instructions plus one more byte. It's not required for the patterns to be unique\n// (i.e., it's OK to have same pattern for unrelated functions).\n// TODO: use hot patch prologues if exist\nconst char* known_bytecodes[] = {\n#if _WIN64\n    \"4883EC284885C974\",       // release free()\n    \"4883EC284885C975\",       // release _msize()\n    \"4885C974375348\",         // release free() 8.0.50727.42, 10.0\n    \"E907000000CCCC\",         // release _aligned_msize(), _aligned_free() ucrtbase.dll\n    \"C7442410000000008B\",     // release free() ucrtbase.dll 10.0.14393.33\n    \"E90B000000CCCC\",         // release _msize() ucrtbase.dll 10.0.14393.33\n    \"48895C24085748\",         // release _aligned_msize() ucrtbase.dll 10.0.14393.33\n    \"48894C24084883EC28BA\",   // debug prologue\n    \"4C894424184889542410\",   // debug _aligned_msize() 10.0\n    \"48894C24084883EC2848\",   // debug _aligned_free 10.0\n #if __TBB_OVERLOAD_OLD_MSVCR\n    \"48895C2408574883EC3049\", // release _aligned_msize 9.0\n    \"4883EC384885C975\",       // release _msize() 9.0\n    \"4C8BC1488B0DA6E4040033\", // an old win64 SDK\n #endif\n#else // _WIN32\n    \"8BFF558BEC8B\",           // multiple\n    \"8BFF558BEC83\",           // release free() & _msize() 10.0.40219.325, _msize() ucrtbase.dll\n    \"8BFF558BECFF\",           // release _aligned_msize ucrtbase.dll\n    \"8BFF558BEC51\",           // release free() & _msize() ucrtbase.dll 10.0.14393.33\n    \"558BEC8B450885C074\",     // release _aligned_free 11.0\n    \"558BEC837D08000F\",       // release _msize() 11.0.51106.1\n    \"558BEC837D08007419FF\",   // release free() 11.0.50727.1\n    \"558BEC8B450885C075\",     // release _aligned_msize() 11.0.50727.1\n    \"558BEC6A018B\",           // debug free() & _msize() 11.0\n    \"558BEC8B451050\",         // debug _aligned_msize() 11.0\n    \"558BEC8B450850\",         // debug _aligned_free 11.0\n    \"8BFF558BEC6A\",           // debug free() & _msize() 10.0.40219.325\n #if __TBB_OVERLOAD_OLD_MSVCR\n    \"6A1868********E8\",       // release free() 8.0.50727.4053, 9.0\n    \"6A1C68********E8\",       // release _msize() 8.0.50727.4053, 9.0\n #endif\n#endif // _WIN64/_WIN32\n    NULL\n    };\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY(CRT_VER,function_name,dbgsuffix) \\\n    ReplaceFunctionWithStore( #CRT_VER #dbgsuffix \".dll\", #function_name, \\\n      (FUNCPTR)__TBB_malloc_safer_##function_name##_##CRT_VER##dbgsuffix, \\\n      known_bytecodes, (FUNCPTR*)&orig_##function_name##_##CRT_VER##dbgsuffix );\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY_NO_FALLBACK(CRT_VER,function_name,dbgsuffix) \\\n    ReplaceFunctionWithStore( #CRT_VER #dbgsuffix \".dll\", #function_name, \\\n      (FUNCPTR)__TBB_malloc_safer_##function_name##_##CRT_VER##dbgsuffix, 0, NULL );\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY_REDIRECT(CRT_VER,function_name,dest_func,dbgsuffix) \\\n    ReplaceFunctionWithStore( #CRT_VER #dbgsuffix \".dll\", #function_name, \\\n      (FUNCPTR)__TBB_malloc_safer_##dest_func##_##CRT_VER##dbgsuffix, 0, NULL );\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_IMPL(CRT_VER,dbgsuffix)                             \\\n    if (BytecodesAreKnown(#CRT_VER #dbgsuffix \".dll\")) {                                          \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY(CRT_VER,free,dbgsuffix)                         \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY(CRT_VER,_msize,dbgsuffix)                       \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY_NO_FALLBACK(CRT_VER,realloc,dbgsuffix)          \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY(CRT_VER,_aligned_free,dbgsuffix)                \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY(CRT_VER,_aligned_msize,dbgsuffix)               \\\n      __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_ENTRY_NO_FALLBACK(CRT_VER,_aligned_realloc,dbgsuffix) \\\n    } else                                                                                        \\\n        SkipReplacement(#CRT_VER #dbgsuffix \".dll\");\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_RELEASE(CRT_VER) __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_IMPL(CRT_VER,)\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_DEBUG(CRT_VER) __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_IMPL(CRT_VER,d)\n\n#define __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(CRT_VER)     \\\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_RELEASE(CRT_VER) \\\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_DEBUG(CRT_VER)\n\n#if __TBB_OVERLOAD_OLD_MSVCR\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr70d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr70);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr71d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr71);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr80d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr80);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr90d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr90);\n#endif\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr100d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr100);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr110d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr110);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr120d);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(msvcr120);\n__TBB_ORIG_ALLOCATOR_REPLACEMENT_WRAPPER(ucrtbase);\n\n\n/*** replacements for global operators new and delete ***/\n\n#include <new>\n\n#if _MSC_VER && !defined(__INTEL_COMPILER)\n#pragma warning( push )\n#pragma warning( disable : 4290 )\n#endif\n\nvoid * operator_new(size_t sz) {\n    void *res = scalable_malloc(sz);\n    if (NULL == res) throw std::bad_alloc();\n    return res;\n}\nvoid* operator_new_arr(size_t sz) {\n    void *res = scalable_malloc(sz);\n    if (NULL == res) throw std::bad_alloc();\n    return res;\n}\nvoid operator_delete(void* ptr) throw() {\n    __TBB_malloc_safer_delete(ptr);\n}\n#if _MSC_VER && !defined(__INTEL_COMPILER)\n#pragma warning( pop )\n#endif\n\nvoid operator_delete_arr(void* ptr) throw() {\n    __TBB_malloc_safer_delete(ptr);\n}\nvoid* operator_new_t(size_t sz, const std::nothrow_t&) throw() {\n    return scalable_malloc(sz);\n}\nvoid* operator_new_arr_t(std::size_t sz, const std::nothrow_t&) throw() {\n    return scalable_malloc(sz);\n}\nvoid operator_delete_t(void* ptr, const std::nothrow_t&) throw() {\n    __TBB_malloc_safer_delete(ptr);\n}\nvoid operator_delete_arr_t(void* ptr, const std::nothrow_t&) throw() {\n    __TBB_malloc_safer_delete(ptr);\n}\n\nstruct Module {\n    const char *name;\n    bool        doFuncReplacement; // do replacement in the DLL\n};\n\nModule modules_to_replace[] = {\n    {\"msvcr100d.dll\", true},\n    {\"msvcr100.dll\", true},\n    {\"msvcr110d.dll\", true},\n    {\"msvcr110.dll\", true},\n    {\"msvcr120d.dll\", true},\n    {\"msvcr120.dll\", true},\n    {\"ucrtbase.dll\", true},\n//    \"ucrtbased.dll\" is not supported because of problems with _dbg functions\n#if __TBB_OVERLOAD_OLD_MSVCR\n    {\"msvcr90d.dll\", true},\n    {\"msvcr90.dll\", true},\n    {\"msvcr80d.dll\", true},\n    {\"msvcr80.dll\", true},\n    {\"msvcr70d.dll\", true},\n    {\"msvcr70.dll\", true},\n    {\"msvcr71d.dll\", true},\n    {\"msvcr71.dll\", true},\n#endif\n#if __TBB_TODO\n    // TODO: Try enabling replacement for non-versioned system binaries below\n    {\"msvcrtd.dll\", true},\n    {\"msvcrt.dll\", true},\n#endif\n    };\n\n/*\nWe need to replace following functions:\nmalloc\ncalloc\n_aligned_malloc\n_expand (by dummy implementation)\n??2@YAPAXI@Z      operator new                         (ia32)\n??_U@YAPAXI@Z     void * operator new[] (size_t size)  (ia32)\n??3@YAXPAX@Z      operator delete                      (ia32)\n??_V@YAXPAX@Z     operator delete[]                    (ia32)\n??2@YAPEAX_K@Z    void * operator new(unsigned __int64)   (intel64)\n??_V@YAXPEAX@Z    void * operator new[](unsigned __int64) (intel64)\n??3@YAXPEAX@Z     operator delete                         (intel64)\n??_V@YAXPEAX@Z    operator delete[]                       (intel64)\n??2@YAPAXIABUnothrow_t@std@@@Z      void * operator new (size_t sz, const std::nothrow_t&) throw()  (optional)\n??_U@YAPAXIABUnothrow_t@std@@@Z     void * operator new[] (size_t sz, const std::nothrow_t&) throw() (optional)\n\nand these functions have runtime-specific replacement:\nrealloc\nfree\n_msize\n_aligned_realloc\n_aligned_free\n_aligned_msize\n*/\n\ntypedef struct FRData_t {\n    //char *_module;\n    const char *_func;\n    FUNCPTR _fptr;\n    FRR_ON_ERROR _on_error;\n} FRDATA;\n\nFRDATA c_routines_to_replace[] = {\n    { \"malloc\",  (FUNCPTR)scalable_malloc, FRR_FAIL },\n    { \"calloc\",  (FUNCPTR)scalable_calloc, FRR_FAIL },\n    { \"_aligned_malloc\",  (FUNCPTR)safer_aligned_malloc, FRR_FAIL },\n    { \"_expand\",  (FUNCPTR)safer_expand, FRR_IGNORE },\n};\n\nFRDATA cxx_routines_to_replace[] = {\n#if _WIN64\n    { \"??2@YAPEAX_K@Z\", (FUNCPTR)operator_new, FRR_FAIL },\n    { \"??_U@YAPEAX_K@Z\", (FUNCPTR)operator_new_arr, FRR_FAIL },\n    { \"??3@YAXPEAX@Z\", (FUNCPTR)operator_delete, FRR_FAIL },\n    { \"??_V@YAXPEAX@Z\", (FUNCPTR)operator_delete_arr, FRR_FAIL },\n#else\n    { \"??2@YAPAXI@Z\", (FUNCPTR)operator_new, FRR_FAIL },\n    { \"??_U@YAPAXI@Z\", (FUNCPTR)operator_new_arr, FRR_FAIL },\n    { \"??3@YAXPAX@Z\", (FUNCPTR)operator_delete, FRR_FAIL },\n    { \"??_V@YAXPAX@Z\", (FUNCPTR)operator_delete_arr, FRR_FAIL },\n#endif\n    { \"??2@YAPAXIABUnothrow_t@std@@@Z\", (FUNCPTR)operator_new_t, FRR_IGNORE },\n    { \"??_U@YAPAXIABUnothrow_t@std@@@Z\", (FUNCPTR)operator_new_arr_t, FRR_IGNORE }\n};\n\n#ifndef UNICODE\ntypedef char unicode_char_t;\n#define WCHAR_SPEC \"%s\"\n#else\ntypedef wchar_t unicode_char_t;\n#define WCHAR_SPEC \"%ls\"\n#endif\n\n// Check that we recognize bytecodes that should be replaced by trampolines.\n// If some functions have unknown prologue patterns, replacement should not be done.\nbool BytecodesAreKnown(const unicode_char_t *dllName)\n{\n    const char *funcName[] = {\"free\", \"_msize\", \"_aligned_free\", \"_aligned_msize\", 0};\n    HMODULE module = GetModuleHandle(dllName);\n\n    if (!module)\n        return false;\n    for (int i=0; funcName[i]; i++)\n        if (! IsPrologueKnown(module, funcName[i], known_bytecodes)) {\n            fprintf(stderr, \"TBBmalloc: skip allocation functions replacement in \" WCHAR_SPEC\n                    \": unknown prologue for function \" WCHAR_SPEC \"\\n\", dllName, funcName[i]);\n            return false;\n        }\n    return true;\n}\n\nvoid SkipReplacement(const unicode_char_t *dllName)\n{\n#ifndef UNICODE\n    const char *dllStr = dllName;\n#else\n    const size_t sz = 128; // all DLL name must fit\n\n    char buffer[sz];\n    size_t real_sz;\n    char *dllStr = buffer;\n\n    errno_t ret = wcstombs_s(&real_sz, dllStr, sz, dllName, sz-1);\n    __TBB_ASSERT(!ret, \"Dll name conversion failed\")\n#endif\n\n    for (size_t i=0; i<arrayLength(modules_to_replace); i++)\n        if (!strcmp(modules_to_replace[i].name, dllStr)) {\n            modules_to_replace[i].doFuncReplacement = false;\n            break;\n        }\n}\n\nvoid ReplaceFunctionWithStore( const unicode_char_t *dllName, const char *funcName, FUNCPTR newFunc, const char ** opcodes, FUNCPTR* origFunc,  FRR_ON_ERROR on_error = FRR_FAIL )\n{\n    FRR_TYPE res = ReplaceFunction( dllName, funcName, newFunc, opcodes, origFunc );\n\n    if (res == FRR_OK || res == FRR_NODLL || (res == FRR_NOFUNC && on_error == FRR_IGNORE))\n        return;\n\n    fprintf(stderr, \"Failed to %s function %s in module %s\\n\",\n            res==FRR_NOFUNC? \"find\" : \"replace\", funcName, dllName);\n    exit(1);\n}\n\nvoid doMallocReplacement()\n{\n    // Replace functions and keep backup of original code (separate for each runtime)\n#if __TBB_OVERLOAD_OLD_MSVCR\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr70)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr71)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr80)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr90)\n#endif\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr100)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr110)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL(msvcr120)\n    __TBB_ORIG_ALLOCATOR_REPLACEMENT_CALL_RELEASE(ucrtbase)\n\n    // Replace functions without storing original code\n    for (size_t j = 0; j < arrayLength(modules_to_replace); j++) {\n        if (!modules_to_replace[j].doFuncReplacement)\n            continue;\n        for (size_t i = 0; i < arrayLength(c_routines_to_replace); i++)\n        {\n            ReplaceFunctionWithStore( modules_to_replace[j].name, c_routines_to_replace[i]._func, c_routines_to_replace[i]._fptr, NULL, NULL,  c_routines_to_replace[i]._on_error );\n        }\n        // ucrtbase.dll does not export operator new/delete.\n        if ( strcmp(modules_to_replace[j].name, \"ucrtbase.dll\") == 0 ){\n            continue;\n        }\n\n        for (size_t i = 0; i < arrayLength(cxx_routines_to_replace); i++)\n        {\n#if !_WIN64\n            // in Microsoft* Visual Studio* 2012 and 2013 32-bit operator delete consists of 2 bytes only: short jump to free(ptr);\n            // replacement should be skipped for this particular case.\n            if ( ((strcmp(modules_to_replace[j].name, \"msvcr110.dll\") == 0) || (strcmp(modules_to_replace[j].name, \"msvcr120.dll\") == 0)) && (strcmp(cxx_routines_to_replace[i]._func, \"??3@YAXPAX@Z\") == 0) ) continue;\n            // in Microsoft* Visual Studio* 2013 32-bit operator delete[] consists of 2 bytes only: short jump to free(ptr);\n            // replacement should be skipped for this particular case.\n            if ( (strcmp(modules_to_replace[j].name, \"msvcr120.dll\") == 0) && (strcmp(cxx_routines_to_replace[i]._func, \"??_V@YAXPAX@Z\") == 0) ) continue;\n#endif\n            ReplaceFunctionWithStore( modules_to_replace[j].name, cxx_routines_to_replace[i]._func, cxx_routines_to_replace[i]._fptr, NULL, NULL,  cxx_routines_to_replace[i]._on_error );\n        }\n    }\n}\n\n#endif // !__TBB_WIN8UI_SUPPORT\n\nextern \"C\" BOOL WINAPI DllMain( HINSTANCE hInst, DWORD callReason, LPVOID reserved )\n{\n\n    if ( callReason==DLL_PROCESS_ATTACH && reserved && hInst ) {\n#if !__TBB_WIN8UI_SUPPORT\n#if TBBMALLOC_USE_TBB_FOR_ALLOCATOR_ENV_CONTROLLED\n        char pinEnvVariable[50];\n        if( GetEnvironmentVariable(\"TBBMALLOC_USE_TBB_FOR_ALLOCATOR\", pinEnvVariable, 50))\n        {\n            doMallocReplacement();\n        }\n#else\n        doMallocReplacement();\n#endif\n#endif // !__TBB_WIN8UI_SUPPORT\n    }\n\n    return TRUE;\n}\n\n// Just to make the linker happy and link the DLL to the application\nextern \"C\" __declspec(dllexport) void __TBB_malloc_proxy()\n{\n\n}\n\n#endif //_WIN32\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-r-rcppparallel-4.4.3-nb5mby6ptmupzbqnhtby7ablnhzocex7/spack-src/inst/presentations/images/big-data-big-machine-tweet.png"
    ],
    "total_files": 506
}