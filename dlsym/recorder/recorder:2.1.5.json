{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-recorder-2.1.5-7vymm6vaffij3yynh6irbsjvecdqxylt/spack-src/lib/recorder-posix.c": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted for any purpose (including commercial purposes)\n * provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions, and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions, and the following disclaimer in the documentation\n *    and/or materials provided with the distribution.\n *\n * 3. In addition, redistributions of modified forms of the source or binary\n *    code must carry prominent notices stating that the original code was\n *    changed and the date of the change.\n *\n * 4. All publications or advertising materials mentioning features or use of\n *    this software are asked, but not required, to acknowledge that it was\n *    developed by The HDF Group and by the National Center for Supercomputing\n *    Applications at the University of Illinois at Urbana-Champaign and\n *    credit the contributors.\n *\n * 5. Neither the name of The HDF Group, the name of the University, nor the\n *    name of any Contributor may be used to endorse or promote products derived\n *    from this software without specific prior written permission from\n *    The HDF Group, the University, or the Contributor, respectively.\n *\n * DISCLAIMER:\n * THIS SOFTWARE IS PROVIDED BY THE HDF GROUP AND THE CONTRIBUTORS\n * \"AS IS\" WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED. In no\n * event shall The HDF Group or the Contributors be liable for any damages\n * suffered by the users arising out of the use of this software, even if\n * advised of the possibility of such damage.\n *\n * Portions of Recorder were developed with support from the Lawrence Berkeley\n * National Laboratory (LBNL) and the United States Department of Energy under\n * Prime Contract No. DE-AC02-05CH11231.\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n#define _XOPEN_SOURCE 500\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/mman.h>\n#include <search.h>\n#include <assert.h>\n#include <limits.h>\n#include <pthread.h>\n\n#include \"recorder.h\"\n\n#ifndef HAVE_OFF64_T\ntypedef int64_t off64_t;\n#endif\n\nint depth;\n\nstatic int recorder_mem_alignment = 1;\n\nstatic inline int stream2fd(FILE *fp) {\n    // Need to map the fileno funciton, because here - this file\n    // may be invoked even before MPI_Init in recorder-mpi-initialize.c\n    // also note that fileno causes segmentation fault if fp is NULL\n    if (fp == NULL) return -1;\n    MAP_OR_FAIL(fileno)\n    int fd = RECORDER_REAL_CALL(fileno(fp));\n    return fd;\n}\n\nstatic inline char* stream2fdstr(FILE *fp) {\n    if (fp == NULL) return NULL;\n    return itoa(stream2fd(fp));\n}\n\n\nint RECORDER_POSIX_DECL(close)(int fd) {\n    RECORDER_INTERCEPTOR_NOIO(int, close, (fd));\n    char** args = assemble_args_list(1, itoa(fd));\n    RECORDER_INTERCEPTOR(1, args);\n}\n\nint RECORDER_POSIX_DECL(fclose)(FILE *fp) {\n    char** args = assemble_args_list(1, stream2fdstr(fp));  // get the fd first otherwise fp will be NULL after went through close\n    RECORDER_INTERCEPTOR_NOIO(int, fclose, (fp));\n    RECORDER_INTERCEPTOR(1, args);\n}\n\nint RECORDER_POSIX_DECL(fsync)(int fd) {\n    RECORDER_INTERCEPTOR_NOIO(int, fsync, (fd));\n    char** args = assemble_args_list(1, itoa(fd));\n    RECORDER_INTERCEPTOR(1, args);\n}\n\nint RECORDER_POSIX_DECL(fdatasync)(int fd) {\n    RECORDER_INTERCEPTOR_NOIO(int, fdatasync, (fd));\n    char** args = assemble_args_list(1, itoa(fd));\n    RECORDER_INTERCEPTOR(1, args);\n}\n\nvoid* RECORDER_POSIX_DECL(mmap64)(void *addr, size_t length, int prot, int flags, int fd, off64_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(void*, mmap64, (addr, length, prot, flags, fd, offset));\n    char** args = assemble_args_list(6, ptoa(addr), itoa(length), itoa(prot), itoa(flags), itoa(fd), itoa(offset));\n    RECORDER_INTERCEPTOR(6, args);\n}\nvoid* RECORDER_POSIX_DECL(mmap)(void *addr, size_t length, int prot, int flags, int fd, off_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(void*, mmap, (addr, length, prot, flags, fd, offset));\n    char** args = assemble_args_list(6, ptoa(addr), itoa(length), itoa(prot), itoa(flags), itoa(fd), itoa(offset));\n    RECORDER_INTERCEPTOR(6, args);\n}\nint RECORDER_POSIX_DECL(msync)(void *addr, size_t length, int flags) {\n    RECORDER_INTERCEPTOR_NOIO(int, msync, (addr, length, flags));\n    char** args = assemble_args_list(3, ptoa(addr), itoa(length), itoa(flags));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nint RECORDER_POSIX_DECL(creat)(const char *path, mode_t mode) {\n    RECORDER_INTERCEPTOR_NOIO(int, creat, (path, mode));\n    record.res = res;\n    char** args = assemble_args_list(2, realrealpath(path), itoa(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\n\nint RECORDER_POSIX_DECL(creat64)(const char *path, mode_t mode) {\n    RECORDER_INTERCEPTOR_NOIO(int, creat64, (path, mode));\n    char** args = assemble_args_list(2, realrealpath(path), itoa(mode));\n    record.res = res;\n    RECORDER_INTERCEPTOR(2, args);\n}\n\nint RECORDER_POSIX_DECL(open64)(const char *path, int flags, ...) {\n    if (flags & O_CREAT) {\n        va_list arg;\n        va_start(arg, flags);\n        int mode = va_arg(arg, int);\n        va_end(arg);\n        RECORDER_INTERCEPTOR_NOIO(int, open64, (path, flags, mode));\n        char** args = assemble_args_list(3, realrealpath(path), itoa(flags), itoa(mode));\n        record.res = res;\n        RECORDER_INTERCEPTOR(3, args);\n\n    } else {\n        RECORDER_INTERCEPTOR_NOIO(int, open64, (path, flags));\n        char** args = assemble_args_list(2, realrealpath(path), itoa(flags));\n        record.res = res;\n        RECORDER_INTERCEPTOR(2, args);\n    }\n}\n\nint RECORDER_POSIX_DECL(open)(const char *path, int flags, ...) {\n    if (flags & O_CREAT) {\n        va_list arg;\n        va_start(arg, flags);\n        int mode = va_arg(arg, int);\n        va_end(arg);\n        RECORDER_INTERCEPTOR_NOIO(int, open, (path, flags, mode));\n        record.res = res;\n        char** args = assemble_args_list(3, realrealpath(path), itoa(flags), itoa(mode));\n        RECORDER_INTERCEPTOR(3, args);\n    } else {\n        RECORDER_INTERCEPTOR_NOIO(int, open, (path, flags));\n        record.res = res;\n        char** args = assemble_args_list(2, realrealpath(path), itoa(flags));\n        RECORDER_INTERCEPTOR(2, args);\n    }\n}\n\nFILE* RECORDER_POSIX_DECL(fopen64)(const char *path, const char *mode) {\n    RECORDER_INTERCEPTOR_NOIO(FILE*, fopen64, (path, mode))\n    record.res = stream2fd(res);\n    char** args = assemble_args_list(2, realrealpath(path), strdup(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\n\nFILE* RECORDER_POSIX_DECL(fopen)(const char *path, const char *mode) {\n    RECORDER_INTERCEPTOR_NOIO(FILE*, fopen, (path, mode));\n    record.res = stream2fd(res);\n    char** args = assemble_args_list(2, realrealpath(path), strdup(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\n\n\n/**\n * From http://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/baselib-xstat-1.html:\n * The functions __xstat(), __lxstat(), and __fxstat() shall implement the ISO POSIX (2003) functions stat(), lstat(), and fstat() respectively\n *\n * This means stat(), lstat(), fstat() are just wrappers in GLIC and dlsym() is not able to hook them.\n * So wee need to hook __xstat(), __lxstat(), and __fxstat()\n */\nint RECORDER_POSIX_DECL(__xstat)(int vers, const char *path, struct stat *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __xstat, (vers, path, buf));\n    char** args = assemble_args_list(3, itoa(vers), realrealpath(path), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(__xstat64)(int vers, const char *path, struct stat64 *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __xstat64, (vers, path, buf));\n    char** args = assemble_args_list(3, itoa(vers), realrealpath(path), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(__lxstat)(int vers, const char *path, struct stat *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __lxstat, (vers, path, buf));\n    char** args = assemble_args_list(3, itoa(vers), realrealpath(path), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(__lxstat64)(int vers, const char *path, struct stat64 *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __lxstat64, (vers, path, buf));\n    char** args = assemble_args_list(3, itoa(vers), realrealpath(path), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(__fxstat)(int vers, int fd, struct stat *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __fxstat, (vers, fd, buf));\n    char** args = assemble_args_list(3, itoa(vers), itoa(fd), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(__fxstat64)(int vers, int fd, struct stat64 *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, __fxstat64, (vers, fd, buf));\n    char** args = assemble_args_list(3, itoa(vers), itoa(fd), ptoa(buf));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nssize_t RECORDER_POSIX_DECL(pread64)(int fd, void *buf, size_t count, off64_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, pread64, (fd, buf, count, offset));\n    char** args = assemble_args_list(4, itoa(fd), ptoa(buf), itoa(count), itoa(offset));\n    RECORDER_INTERCEPTOR(4, args);\n}\nssize_t RECORDER_POSIX_DECL(pread)(int fd, void *buf, size_t count, off_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, pread, (fd, buf, count, offset));\n    char** args = assemble_args_list(4, itoa(fd), ptoa(buf), itoa(count), itoa(offset));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\nssize_t RECORDER_POSIX_DECL(pwrite64)(int fd, const void *buf, size_t count, off64_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, pwrite64, (fd, buf, count, offset));\n    char** args = assemble_args_list(4, itoa(fd), ptoa(buf), itoa(count), itoa(offset));\n    RECORDER_INTERCEPTOR(4, args);\n}\nssize_t RECORDER_POSIX_DECL(pwrite)(int fd, const void *buf, size_t count, off_t offset) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, pwrite, (fd, buf, count, offset));\n    char** args = assemble_args_list(4, itoa(fd), ptoa(buf), itoa(count), itoa(offset));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\n\nssize_t RECORDER_POSIX_DECL(readv)(int fd, const struct iovec *iov, int iovcnt) {\n    // Return total bytes as the second argument\n    // So during post-processing we know both the offset and bytes count\n    int total = 0; int i = 0;\n    for (i = 0; i < iovcnt; i++)\n        total += iov[i].iov_len;\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, readv, (fd, iov, iovcnt));\n    char** args = assemble_args_list(3, itoa(fd), itoa(total), itoa(iovcnt));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nssize_t RECORDER_POSIX_DECL(writev)(int fd, const struct iovec *iov, int iovcnt) {\n    // Return total bytes as the second argument\n    // So during post-processing we know both the offset and bytes count\n    int total = 0; int i = 0;\n    for (i = 0; i < iovcnt; i++)\n        total += iov[i].iov_len;\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, writev, (fd, iov, iovcnt));\n    char** args = assemble_args_list(3, itoa(fd), itoa(total), itoa(iovcnt));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nsize_t RECORDER_POSIX_DECL(fread)(void *ptr, size_t size, size_t nmemb, FILE *stream) {\n    RECORDER_INTERCEPTOR_NOIO(size_t, fread, (ptr, size, nmemb, stream));\n    char** args = assemble_args_list(4, ptoa(ptr), itoa(size), itoa(nmemb), stream2fdstr(stream));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\nsize_t RECORDER_POSIX_DECL(fwrite)(const void *ptr, size_t size, size_t nmemb, FILE *stream) {\n    // TODO:what's this aligned_flag for?\n    // int aligned_flag = 0;\n    //if ((unsigned long)ptr % recorder_mem_alignment == 0)\n    //    aligned_flag = 1;\n    RECORDER_INTERCEPTOR_NOIO(size_t, fwrite, (ptr, size, nmemb, stream));\n    char** args = assemble_args_list(4, ptoa(ptr), itoa(size), itoa(nmemb), stream2fdstr(stream));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\nint RECORDER_POSIX_DECL(fprintf)(FILE *stream, const char *format, ...) {\n    // Get the size of the string fprintf will write\n    va_list fprintf_args;\n    va_start(fprintf_args, format);\n    int size = vsnprintf(NULL, 0, format, fprintf_args) + 1;\n    va_end(fprintf_args);\n\n    va_start(fprintf_args, format);\n    RECORDER_INTERCEPTOR_NOIO(size_t, vfprintf, (stream, format, fprintf_args));\n    va_end(fprintf_args);\n    char** args = assemble_args_list(2, stream2fdstr(stream), itoa(size));\n    RECORDER_INTERCEPTOR(2, args);\n}\n\nssize_t RECORDER_POSIX_DECL(read)(int fd, void *buf, size_t count) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, read, (fd, buf, count));\n    char** args = assemble_args_list(3, itoa(fd), ptoa(buf), itoa(count));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nssize_t RECORDER_POSIX_DECL(write)(int fd, const void *buf, size_t count) {\n    RECORDER_INTERCEPTOR_NOIO(ssize_t, write, (fd, buf, count));\n    char** args = assemble_args_list(3, itoa(fd), ptoa(buf), itoa(count));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nint RECORDER_POSIX_DECL(fseek)(FILE *stream, long offset, int whence) {\n    RECORDER_INTERCEPTOR_NOIO(int, fseek, (stream, offset, whence));\n    char** args = assemble_args_list(3, stream2fdstr(stream), itoa(offset), itoa(whence));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nlong RECORDER_POSIX_DECL(ftell)(FILE *stream) {\n    RECORDER_INTERCEPTOR_NOIO(long, ftell, (stream));\n    char** args = assemble_args_list(1, stream2fdstr(stream));\n    RECORDER_INTERCEPTOR(1, args)\n}\n\noff64_t RECORDER_POSIX_DECL(lseek64)(int fd, off64_t offset, int whence) {\n    RECORDER_INTERCEPTOR_NOIO(off64_t, lseek64, (fd, offset, whence));\n    char** args = assemble_args_list(3, itoa(fd), itoa(offset), itoa(whence));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\noff_t RECORDER_POSIX_DECL(lseek)(int fd, off_t offset, int whence) {\n    RECORDER_INTERCEPTOR_NOIO(off_t, lseek, (fd, offset, whence));\n    char** args = assemble_args_list(3, itoa(fd), itoa(offset), itoa(whence));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\n\n/* Below are non File-I/O related function calls */\nchar* RECORDER_POSIX_DECL(getcwd)(char *buf, size_t size) {\n    RECORDER_INTERCEPTOR_NOIO(char*, getcwd, (buf, size));\n    char** args = assemble_args_list(2, ptoa(buf), itoa(size));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(mkdir)(const char *pathname, mode_t mode) {\n    RECORDER_INTERCEPTOR_NOIO(int, mkdir, (pathname, mode));\n    char** args = assemble_args_list(2, realrealpath(pathname), itoa(mode));\n    RECORDER_INTERCEPTOR(2, args)\n}\nint RECORDER_POSIX_DECL(rmdir)(const char *pathname) {\n    RECORDER_INTERCEPTOR_NOIO(int, rmdir, (pathname));\n    char** args = assemble_args_list(1, realrealpath(pathname));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(chdir)(const char *path) {\n    RECORDER_INTERCEPTOR_NOIO(int, chdir, (path));\n    char** args = assemble_args_list(1, realrealpath(path));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(link)(const char *oldpath, const char *newpath) {\n    RECORDER_INTERCEPTOR_NOIO(int, link, (oldpath, newpath));\n    char** args = assemble_args_list(2, realrealpath(oldpath), realrealpath(newpath));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(unlink)(const char *pathname) {\n    RECORDER_INTERCEPTOR_NOIO(int, unlink, (pathname));\n    char** args = assemble_args_list(1, realrealpath(pathname));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(linkat)(int fd1, const char *path1, int fd2, const char *path2, int flag) {\n    RECORDER_INTERCEPTOR_NOIO(int, linkat, (fd1, path1, fd2, path2, flag));\n    char** args = assemble_args_list(5, itoa(fd1), realrealpath(path1), itoa(fd2), realrealpath(path2), itoa(flag));\n    RECORDER_INTERCEPTOR(5, args);\n}\nint RECORDER_POSIX_DECL(symlink)(const char *path1, const char *path2) {\n    RECORDER_INTERCEPTOR_NOIO(int, symlink, (path1, path2));\n    char** args = assemble_args_list(2, realrealpath(path1), realrealpath(path2));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(symlinkat)(const char *path1, int fd, const char *path2) {\n    RECORDER_INTERCEPTOR_NOIO(int, symlinkat, (path1, fd, path2));\n    char** args = assemble_args_list(3, realrealpath(path1), itoa(fd), realrealpath(path2));\n    RECORDER_INTERCEPTOR(3, args);\n}\nssize_t RECORDER_POSIX_DECL(readlink)(const char *path, char *buf, size_t bufsize) {\n    RECORDER_INTERCEPTOR_NOIO(int, readlink, (path, buf, bufsize));\n    char** args = assemble_args_list(3, realrealpath(path), ptoa(buf), itoa(bufsize));\n    RECORDER_INTERCEPTOR(3, args);\n}\n\nssize_t RECORDER_POSIX_DECL(readlinkat)(int fd, const char *path, char *buf, size_t bufsize) {\n    RECORDER_INTERCEPTOR_NOIO(int, readlinkat, (fd, path, buf, bufsize));\n    char** args = assemble_args_list(4, itoa(fd), realrealpath(path), ptoa(buf), itoa(bufsize));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\nint RECORDER_POSIX_DECL(rename)(const char *oldpath, const char *newpath) {\n    RECORDER_INTERCEPTOR_NOIO(int, rename, (oldpath, newpath));\n    char** args = assemble_args_list(2, realrealpath(oldpath), realrealpath(newpath));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(chmod)(const char *path, mode_t mode) {\n    RECORDER_INTERCEPTOR_NOIO(int, chmod, (path, mode));\n    char** args = assemble_args_list(2, realrealpath(path), itoa(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(chown)(const char *path, uid_t owner, gid_t group) {\n    RECORDER_INTERCEPTOR_NOIO(int, chown, (path, owner, group));\n    char** args = assemble_args_list(3, realrealpath(path), itoa(owner), itoa(group));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(lchown)(const char *path, uid_t owner, gid_t group) {\n    RECORDER_INTERCEPTOR_NOIO(int, lchown, (path, owner, group));\n    char** args = assemble_args_list(3, realrealpath(path), itoa(owner), itoa(group));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(utime)(const char *filename, const struct utimbuf *buf) {\n    RECORDER_INTERCEPTOR_NOIO(int, utime, (filename, buf));\n    char** args = assemble_args_list(2, realrealpath(filename), ptoa(buf));\n    RECORDER_INTERCEPTOR(2, args);\n}\nDIR* RECORDER_POSIX_DECL(opendir)(const char *name) {\n    RECORDER_INTERCEPTOR_NOIO(DIR*, opendir, (name));\n    char** args = assemble_args_list(1, realrealpath(name));\n    RECORDER_INTERCEPTOR(1, args);\n}\nstruct dirent* RECORDER_POSIX_DECL(readdir)(DIR *dir) {\n    // TODO: DIR - get path\n    RECORDER_INTERCEPTOR_NOIO(struct dirent*, readdir, (dir));\n    char** args = assemble_args_list(1, ptoa(dir));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(closedir)(DIR *dir) {\n    char** args = assemble_args_list(1, ptoa(dir));\n    RECORDER_INTERCEPTOR_NOIO(int, closedir, (dir));\n    RECORDER_INTERCEPTOR(1, args);\n}\n/*\nvoid RECORDER_POSIX_DECL(rewinddir)(DIR *dir) {\n    // TODO\n    char log_text[TRACE_LEN];\n    sprintf(log_text, \"rewinddir (%p)\", dir);\n    RECORDER_INTERCEPTOR(rewinddir, NULL, (dir), NULL, 0, 0, log_text)\n\n}\n*/\nint RECORDER_POSIX_DECL(mknod)(const char *path, mode_t mode, dev_t dev) {\n    RECORDER_INTERCEPTOR_NOIO(int, mknod, (path, mode, dev));\n    char** args = assemble_args_list(3, realrealpath(path), itoa(mode), itoa(dev));\n    RECORDER_INTERCEPTOR(3, args);\n}\nint RECORDER_POSIX_DECL(mknodat)(int fd, const char *path, mode_t mode, dev_t dev) {\n    RECORDER_INTERCEPTOR_NOIO(int, mknodat, (fd, path, mode, dev));\n    char** args = assemble_args_list(4, itoa(fd), realrealpath(path), itoa(mode), itoa(dev));\n    RECORDER_INTERCEPTOR(4, args);\n}\n\n\n\n// Advanced File Operations\n/* TODO: third argument\nint RECORDER_POSIX_DECL(fcntl)(int fd, int cmd, ...) {\n    char log_text[TRACE_LEN];\n    sprintf(log_text, \"fcntl %d %d\", fd, cmd);\n    RECORDER_INTERCEPTOR(fcntl, int, (fd, cmd), NULL, 0, 0, log_text)\n\n}\n*/\nint RECORDER_POSIX_DECL(dup)(int oldfd) {\n    RECORDER_INTERCEPTOR_NOIO(int, dup, (oldfd));\n    record.res = res;\n    char** args = assemble_args_list(1, itoa(oldfd));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(dup2)(int oldfd, int newfd) {\n    RECORDER_INTERCEPTOR_NOIO(int, dup2, (oldfd, newfd));\n    record.res = res;\n    char** args = assemble_args_list(2, itoa(oldfd), itoa(newfd));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(pipe)(int pipefd[2]) {\n    // TODO: pipefd?\n    RECORDER_INTERCEPTOR_NOIO(int, pipe, (pipefd));\n    char** args = assemble_args_list(2, itoa(pipefd[0]), itoa(pipefd[1]));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(mkfifo)(const char *pathname, mode_t mode) {\n    RECORDER_INTERCEPTOR_NOIO(int, mkfifo, (pathname, mode));\n    char** args = assemble_args_list(2, realrealpath(pathname), itoa(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\nmode_t RECORDER_POSIX_DECL(umask)(mode_t mask) {\n    RECORDER_INTERCEPTOR_NOIO(mode_t, umask, (mask));\n    char** args = assemble_args_list(1, itoa(mask));\n    RECORDER_INTERCEPTOR(1, args);\n}\nFILE* RECORDER_POSIX_DECL(fdopen)(int fd, const char *mode) {\n    RECORDER_INTERCEPTOR_NOIO(FILE*, fdopen, (fd, mode));\n    record.res = stream2fd(res);\n    char** args = assemble_args_list(2, itoa(fd), ptoa(mode));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(fileno)(FILE *stream) {\n    RECORDER_INTERCEPTOR_NOIO(int, fileno, (stream));\n    char** args = assemble_args_list(1, stream2fdstr(stream));\n    RECORDER_INTERCEPTOR(1, args);\n}\nint RECORDER_POSIX_DECL(access)(const char *path, int amode) {\n    RECORDER_INTERCEPTOR_NOIO(int, access, (path, amode));\n    char** args = assemble_args_list(2, realrealpath(path), itoa(amode));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(faccessat)(int fd, const char *path, int amode, int flag) {\n    RECORDER_INTERCEPTOR_NOIO(int, faccessat, (fd, path, amode, flag));\n    char** args = assemble_args_list(4, itoa(fd), realrealpath(path), itoa(amode), itoa(flag));\n    RECORDER_INTERCEPTOR(4, args);\n}\nFILE* RECORDER_POSIX_DECL(tmpfile)(void) {\n    RECORDER_INTERCEPTOR_NOIO(FILE*, tmpfile, ());\n    record.res = stream2fd(res);\n    char **args = NULL;\n    RECORDER_INTERCEPTOR(0, args);\n}\nint RECORDER_POSIX_DECL(remove)(const char *path) {\n    RECORDER_INTERCEPTOR_NOIO(int, remove, (path));\n    char** args = assemble_args_list(1, realrealpath(path));\n    RECORDER_INTERCEPTOR(1, args)\n}\nint RECORDER_POSIX_DECL(truncate)(const char *path, off_t length) {\n    RECORDER_INTERCEPTOR_NOIO(int, truncate, (path, length));\n    char** args = assemble_args_list(2, realrealpath(path), itoa(length));\n    RECORDER_INTERCEPTOR(2, args);\n}\nint RECORDER_POSIX_DECL(ftruncate)(int fd, off_t length) {\n    RECORDER_INTERCEPTOR_NOIO(int, ftruncate, (fd, length));\n    char** args = assemble_args_list(2, itoa(fd), itoa(length));\n    RECORDER_INTERCEPTOR(2, args);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-recorder-2.1.5-7vymm6vaffij3yynh6irbsjvecdqxylt/spack-src/include/recorder.h": "/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted for any purpose (including commercial purposes)\n * provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions, and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions, and the following disclaimer in the documentation\n *    and/or materials provided with the distribution.\n *\n * 3. In addition, redistributions of modified forms of the source or binary\n *    code must carry prominent notices stating that the original code was\n *    changed and the date of the change.\n *\n * 4. All publications or advertising materials mentioning features or use of\n *    this software are asked, but not required, to acknowledge that it was\n *    developed by The HDF Group and by the National Center for Supercomputing\n *    Applications at the University of Illinois at Urbana-Champaign and\n *    credit the contributors.\n *\n * 5. Neither the name of The HDF Group, the name of the University, nor the\n *    name of any Contributor may be used to endorse or promote products derived\n *    from this software without specific prior written permission from\n *    The HDF Group, the University, or the Contributor, respectively.\n *\n * DISCLAIMER:\n * THIS SOFTWARE IS PROVIDED BY THE HDF GROUP AND THE CONTRIBUTORS\n * \"AS IS\" WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED. In no\n * event shall The HDF Group or the Contributors be liable for any damages\n * suffered by the users arising out of the use of this software, even if\n * advised of the possibility of such damage.\n *\n * Portions of Recorder were developed with support from the Lawrence Berkeley\n * National Laboratory (LBNL) and the United States Department of Energy under\n * Prime Contract No. DE-AC02-05CH11231.\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n#ifndef __RECORDER_H\n#define __RECORDER_H\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <utime.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <stdint.h>\n#include <mpi.h>\n#include <stdbool.h>\n#include \"hdf5.h\"\n#include \"uthash.h\"\n#include \"recorder-log-format.h\"\n\n#define __D_MPI_REQUEST MPIO_Request\n#if MPI_VERSION >= 3\n#define CONST const\n#else\n#define CONST\n#endif\n\ntypedef struct FilenameHashTable_t {\n    char name[PATH_MAX];             // key\n    UT_hash_handle hh;\n} FilenameHashTable;\n\nextern bool __recording;                                // Only true after init() before exit() so we won't track unwanted functions and files\nextern FilenameHashTable* __filename_hashtable;         // map <filename, integer>\n\n\n/* logger.c */\nvoid logger_init(int rank, int nprocs);\nvoid logger_exit();\nvoid write_record(Record record);\n\n/* util.c */\nlong get_file_size(const char *filename);       // return the size of a file\nint exclude_filename(const char *filename);     // if include the file in trace\ndouble recorder_wtime(void);                    // return the timestamp\nchar* itoa(size_t val);                      // convert a integer to string\nchar* ftoa(double val);                         // convert a float to string\nchar* ptoa(const void* ptr);                    // convert a pointer to string\nchar* arrtoa(size_t arr[], int count);          // convert an array of size_t to a string\nchar** assemble_args_list(int arg_count, ...);\nconst char* get_function_name_by_id(int id);\nunsigned char get_function_id_by_name(const char* name);\nchar* realrealpath(const char* path);           // return the absolute path (mapped to id in string)\n\n\n\n#ifdef RECORDER_PRELOAD\n    #include <dlfcn.h>\n    /*\n     * Declare the function signatures for real functions\n     * i.e. The real function point to fwrite would be defined as __real_fwrite\n     */\n    #define RECORDER_FORWARD_DECL(name, ret, args) ret(*__real_##name) args;\n\n    /* Point __real_func to the real funciton using dlsym() */\n    #define MAP_OR_FAIL(func)                                                   \\\n        if (!(__real_##func)) {                                                 \\\n            __real_##func = dlsym(RTLD_NEXT, #func);                            \\\n            if (!(__real_##func)) {                                             \\\n                printf(\"Recorder failed to map symbol: %s\\n\", #func);           \\\n            }                                                                   \\\n        }\n    /*\n     * Call the real funciton\n     * Before call the real function, we need to make sure its mapped by dlsym()\n     * So, every time we use this marco directly, we need to call MAP_OR_FAIL before it\n     */\n    #define RECORDER_REAL_CALL(func) __real_##func\n#else\n    #define RECORDER_FORWARD_DECL(name, ret, args)\n    #define MAP_OR_FAIL(func)\n    #define RECORDER_REAL_CALL(func) func\n#endif\n\n\n/**\n * Decide wether to intercept (override) funciton calls\n */\n#ifdef RECORDER_PRELOAD\n    #ifndef DISABLE_MPIO_TRACE\n        #define RECORDER_MPI_DECL(func) func\n    #else\n        #define RECORDER_MPI_DECL(func) __warp_##func\n    #endif\n\n    #ifndef DISABLE_POSIX_TRACE\n        #define RECORDER_POSIX_DECL(func) func\n    #else\n        #define RECORDER_POSIX_DECL(func) __warp_##func\n    #endif\n\n    #ifndef DISABLE_HDF5_TRACE\n        #define RECORDER_HDF5_DECL(func) func\n    #else\n        #define RECORDER_HDF5_DECL(func) __warp_##func\n    #endif\n#else\n    #define RECORDER_MPI_DECL(func) func\n    #define RECORDER_POSIX_DECL(func) func\n    #define RECORDER_HDF5_DECL(func) func\n#endif\n\n\n/**\n * I/O Interceptor\n * Phase 1:\n *\n * we intercept functions (e.g., from recorder-posix.c) and then\n * call this interception funciton.\n *\n * Here, we first run the original function so we can get the ouput\n * parameters correctly.\n *\n * We also construct a [struct Record] for each function. But latter we\n * can change the fields, e.g., fopen will convert the FILE* to an integer res.\n *\n */\n#define RECORDER_INTERCEPTOR_NOIO(ret, func, real_args)                             \\\n    MAP_OR_FAIL(func)                                                               \\\n    double tstart = recorder_wtime();                                               \\\n    ret res = RECORDER_REAL_CALL(func) real_args ;                                  \\\n    double tend = recorder_wtime();                                                 \\\n    Record record = {                                                               \\\n        .tstart = tstart,                                                           \\\n        .func_id = get_function_id_by_name(#func),                                  \\\n        .tend = tend                                                                \\\n    };\n\n\n/**\n * I/O Interceptor\n * Phase 2:\n *\n * Set other fields of the record, i.e, arg_count and args.\n * Finally write out the record\n *\n */\n#define RECORDER_INTERCEPTOR(record_arg_count, record_args)                         \\\n    record.arg_count = record_arg_count;                                            \\\n    record.args = record_args;                                                      \\\n    write_record(record);                                                           \\\n    return res;\n\n\n\n/* POSIX I/O */\nRECORDER_FORWARD_DECL(creat, int, (const char *path, mode_t mode));\nRECORDER_FORWARD_DECL(creat64, int, (const char *path, mode_t mode));\nRECORDER_FORWARD_DECL(open, int, (const char *path, int flags, ...));\nRECORDER_FORWARD_DECL(open64, int, (const char *path, int flags, ...));\nRECORDER_FORWARD_DECL(close, int, (int fd));\nRECORDER_FORWARD_DECL(write, ssize_t, (int fd, const void *buf, size_t count));\nRECORDER_FORWARD_DECL(read, ssize_t, (int fd, void *buf, size_t count));\nRECORDER_FORWARD_DECL(lseek, off_t, (int fd, off_t offset, int whence));\nRECORDER_FORWARD_DECL(lseek64, off64_t, (int fd, off64_t offset, int whence));\nRECORDER_FORWARD_DECL(pread, ssize_t, (int fd, void *buf, size_t count, off_t offset));\nRECORDER_FORWARD_DECL(pread64, ssize_t, (int fd, void *buf, size_t count, off64_t offset));\nRECORDER_FORWARD_DECL(pwrite, ssize_t, (int fd, const void *buf, size_t count, off_t offset));\nRECORDER_FORWARD_DECL(pwrite64, ssize_t, (int fd, const void *buf, size_t count, off64_t offset));\nRECORDER_FORWARD_DECL(readv, ssize_t, (int fd, const struct iovec *iov, int iovcnt));\nRECORDER_FORWARD_DECL(writev, ssize_t, (int fd, const struct iovec *iov, int iovcnt));\nRECORDER_FORWARD_DECL(mmap, void *, (void *addr, size_t length, int prot, int flags, int fd, off_t offset));\nRECORDER_FORWARD_DECL(mmap64, void *, (void *addr, size_t length, int prot, int flags, int fd, off64_t offset));\nRECORDER_FORWARD_DECL(msync, int, (void *addr, size_t length, int flags));\nRECORDER_FORWARD_DECL(fopen, FILE *, (const char *path, const char *mode));\nRECORDER_FORWARD_DECL(fopen64, FILE *, (const char *path, const char *mode));\nRECORDER_FORWARD_DECL(fclose, int, (FILE * fp));\nRECORDER_FORWARD_DECL(fread, size_t, (void *ptr, size_t size, size_t nmemb, FILE *stream));\nRECORDER_FORWARD_DECL(fwrite, size_t, (const void *ptr, size_t size, size_t nmemb, FILE *stream));\nRECORDER_FORWARD_DECL(ftell, long, (FILE *stream));\nRECORDER_FORWARD_DECL(fseek, int, (FILE * stream, long offset, int whence));\nRECORDER_FORWARD_DECL(fsync, int, (int fd));\nRECORDER_FORWARD_DECL(fdatasync, int, (int fd));\nRECORDER_FORWARD_DECL(vfprintf, int, (FILE *stream, const char *format, va_list ap));   // we need to use vprintf to trace fprintf so we can pass va_list\n// stat/fstat/lstat are wrappers in GLIBC and dlsym can not hook them.\n// Instead, xstat/lxstat/fxstat are their GLIBC implementations so we can hook them.\nRECORDER_FORWARD_DECL(__xstat, int, (int vers, const char *path, struct stat *buf));\nRECORDER_FORWARD_DECL(__xstat64, int, (int vers, const char *path, struct stat64 *buf));\nRECORDER_FORWARD_DECL(__lxstat, int, (int vers, const char *path, struct stat *buf));\nRECORDER_FORWARD_DECL(__lxstat64, int, (int vers, const char *path, struct stat64 *buf));\nRECORDER_FORWARD_DECL(__fxstat, int, (int vers, int fd, struct stat *buf));\nRECORDER_FORWARD_DECL(__fxstat64, int, (int vers, int fd, struct stat64 *buf));\n/* Other POSIX Function Calls, not directly related to I/O */\n// Files and Directories\nRECORDER_FORWARD_DECL(getcwd, char*, (char *buf, size_t size));\nRECORDER_FORWARD_DECL(mkdir, int, (const char *pathname, mode_t mode));\nRECORDER_FORWARD_DECL(rmdir, int, (const char *pathname));\nRECORDER_FORWARD_DECL(chdir, int, (const char *path));\nRECORDER_FORWARD_DECL(link, int, (const char *oldpath, const char *newpath));\nRECORDER_FORWARD_DECL(linkat, int, (int fd1, const char *path1, int fd2, const char *path2, int flag));\nRECORDER_FORWARD_DECL(unlink, int, (const char *pathname));\nRECORDER_FORWARD_DECL(symlink, int, (const char *path1, const char *path2));\nRECORDER_FORWARD_DECL(symlinkat, int, (const char *path1, int fd, const char *path2));\nRECORDER_FORWARD_DECL(readlink, ssize_t, (const char *path, char *buf, size_t bufsize));\nRECORDER_FORWARD_DECL(readlinkat, ssize_t, (int fd, const char *path, char *buf, size_t bufsize));\nRECORDER_FORWARD_DECL(rename, int, (const char *oldpath, const char *newpath));\nRECORDER_FORWARD_DECL(chmod, int, (const char *path, mode_t mode));\nRECORDER_FORWARD_DECL(chown, int, (const char *path, uid_t owner, gid_t group));\nRECORDER_FORWARD_DECL(lchown, int, (const char *path, uid_t owner, gid_t group));\nRECORDER_FORWARD_DECL(utime, int, (const char *filename, const struct utimbuf *buf));\nRECORDER_FORWARD_DECL(opendir, DIR*, (const char *name));\nRECORDER_FORWARD_DECL(readdir, struct dirent*, (DIR *dir));\nRECORDER_FORWARD_DECL(closedir, int, (DIR *dir));\nRECORDER_FORWARD_DECL(rewinddir, void, (DIR *dir));\nRECORDER_FORWARD_DECL(mknod, int, (const char *path, mode_t mode, dev_t dev));\nRECORDER_FORWARD_DECL(mknodat, int, (int fd, const char *path, mode_t mode, dev_t dev));\n// Advanced File Operations\nRECORDER_FORWARD_DECL(fcntl, int, (int fd, int cmd, ...));\nRECORDER_FORWARD_DECL(dup, int, (int oldfd));\nRECORDER_FORWARD_DECL(dup2, int, (int oldfd, int newfd));\nRECORDER_FORWARD_DECL(pipe, int, (int pipefd[2]));\nRECORDER_FORWARD_DECL(mkfifo, int, (const char *pathname, mode_t mode));\nRECORDER_FORWARD_DECL(umask, mode_t, (mode_t mask));\nRECORDER_FORWARD_DECL(fdopen, FILE*, (int fd, const char *mode));\nRECORDER_FORWARD_DECL(fileno, int, (FILE *stream));\nRECORDER_FORWARD_DECL(access, int, (const char *path, int amode));\nRECORDER_FORWARD_DECL(faccessat, int, (int fd, const char *path, int amode, int flag));\nRECORDER_FORWARD_DECL(tmpfile, FILE*, (void));\nRECORDER_FORWARD_DECL(remove, int, (const char *pathname));\nRECORDER_FORWARD_DECL(truncate, int, (const char *pathname, off_t length));\nRECORDER_FORWARD_DECL(ftruncate, int, (int fd, off_t length));\n\n// Others\n//int statfs(const char *path, struct statfs *buf);\n//int fstatfs(int fd, struct statfs *buf);\n\n\n\n\n/* MPI Function Calls */\nRECORDER_FORWARD_DECL(PMPI_File_close, int, (MPI_File * fh));\nRECORDER_FORWARD_DECL(PMPI_File_set_size, int, (MPI_File fh, MPI_Offset size));\nRECORDER_FORWARD_DECL(PMPI_File_iread_at, int, (MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_iread, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_iread_shared, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_iwrite_at, int, (MPI_File fh, MPI_Offset offset, CONST void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_iwrite, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_iwrite_shared, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, __D_MPI_REQUEST *request));\nRECORDER_FORWARD_DECL(PMPI_File_open, int, (MPI_Comm comm, CONST char *filename, int amode, MPI_Info info, MPI_File *fh));\nRECORDER_FORWARD_DECL(PMPI_File_read_all_begin, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_read_all, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_read_at_all, int, (MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_read_at_all_begin, int, (MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_read_at, int, (MPI_File fh, MPI_Offset offset, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_read, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_read_ordered_begin, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_read_ordered, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_read_shared, int, (MPI_File fh, void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_set_view, int, (MPI_File fh, MPI_Offset disp, MPI_Datatype etype, MPI_Datatype filetype, CONST char *datarep, MPI_Info info));\nRECORDER_FORWARD_DECL(PMPI_File_sync, int, (MPI_File fh));\nRECORDER_FORWARD_DECL(PMPI_File_write_all_begin, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_write_all, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_write_at_all_begin, int, (MPI_File fh, MPI_Offset offset, CONST void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_write_at_all, int, (MPI_File fh, MPI_Offset offset, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_write_at, int, (MPI_File fh, MPI_Offset offset, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_write, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_write_ordered_begin, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype));\nRECORDER_FORWARD_DECL(PMPI_File_write_ordered, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_File_write_shared, int, (MPI_File fh, CONST void *buf, int count, MPI_Datatype datatype, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_Finalize, int, ());\nRECORDER_FORWARD_DECL(PMPI_Finalized, int, (int *flag));\nRECORDER_FORWARD_DECL(PMPI_Init, int, (int *argc, char ***argv));\nRECORDER_FORWARD_DECL(PMPI_Init_thread, int, (int *argc, char ***argv, int required, int *provided));\nRECORDER_FORWARD_DECL(PMPI_Wtime, double, ());\nRECORDER_FORWARD_DECL(PMPI_Comm_rank, int, (MPI_Comm comm, int *rank));\nRECORDER_FORWARD_DECL(PMPI_Comm_size, int, (MPI_Comm comm, int *size));\nRECORDER_FORWARD_DECL(PMPI_Get_processor_name, int, (char *name, int *resultlen));\nRECORDER_FORWARD_DECL(PMPI_Comm_set_errhandler, int, (MPI_Comm comm, MPI_Errhandler errhandler));\nRECORDER_FORWARD_DECL(PMPI_Barrier, int, (MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Bcast, int, (void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Gather, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, int rcount, MPI_Datatype rtype, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Gatherv, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, CONST int *rcount, CONST int *displs, MPI_Datatype rtype, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Scatter, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, int rcount, MPI_Datatype rtype, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Scatterv, int, (CONST void *sbuf, CONST int *scount, CONST int *displa, MPI_Datatype stype, void *rbuf, int rcount, MPI_Datatype rtype, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Allgather, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, int rcount, MPI_Datatype rtype, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Allgatherv, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, CONST int *rcount, CONST int *displs, MPI_Datatype rtype, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Alltoall, int, (CONST void *sbuf, int scount, MPI_Datatype stype, void *rbuf, int rcount, MPI_Datatype rtype, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Reduce, int, (CONST void *sbuf, void *rbuf, int count, MPI_Datatype stype, MPI_Op op, int root, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Allreduce, int, (CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Reduce_scatter, int, (CONST void *sbuf, void *rbuf, CONST int *rcounts, MPI_Datatype stype, MPI_Op op, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Scan, int, (CONST void *sendbuf, void *recvbuf, int count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Type_commit, int, (MPI_Datatype * datatype));\nRECORDER_FORWARD_DECL(PMPI_Type_contiguous, int, (int count, MPI_Datatype oldtype, MPI_Datatype *newtype));\nRECORDER_FORWARD_DECL(PMPI_Type_extent, int, (MPI_Datatype datatype, MPI_Aint * extent));\nRECORDER_FORWARD_DECL(PMPI_Type_free, int, (MPI_Datatype * datatype));\nRECORDER_FORWARD_DECL(PMPI_Type_hindexed, int, (int count, int *array_of_blocklengths, MPI_Aint *array_of_displacements, MPI_Datatype oldtype, MPI_Datatype *newtype));\nRECORDER_FORWARD_DECL(PMPI_Op_create, int, (MPI_User_function * function, int commute, MPI_Op *op));\nRECORDER_FORWARD_DECL(PMPI_Op_free, int, (MPI_Op * op));\nRECORDER_FORWARD_DECL(PMPI_Type_get_envelope, int, (MPI_Datatype datatype, int *num_integers, int *num_addresses, int *num_datatypes, int *combiner));\nRECORDER_FORWARD_DECL(PMPI_Type_size, int, (MPI_Datatype datatype, int *size));\nRECORDER_FORWARD_DECL(PMPI_Type_create_darray, int, (int size, int rank, int ndims, CONST int array_of_gsizes[], CONST int array_of_distribs[],CONST int array_of_dargs[], CONST int array_of_psizes[], int order, MPI_Datatype oldtype, MPI_Datatype *newtype));\n// Added 10 new MPI functinos on 2019/01/07\nRECORDER_FORWARD_DECL(PMPI_Cart_rank, int, (MPI_Comm comm, CONST int coords[], int *rank));\nRECORDER_FORWARD_DECL(PMPI_Cart_create, int, (MPI_Comm comm_old, int ndims, CONST int dims[], CONST int periods[], int reorder, MPI_Comm *comm_cart));\nRECORDER_FORWARD_DECL(PMPI_Cart_get, int, (MPI_Comm comm, int maxdims, int dims[], int periods[], int coords[]));\nRECORDER_FORWARD_DECL(PMPI_Cart_shift, int, (MPI_Comm comm, int direction, int disp, int *rank_source, int *rank_dest));\nRECORDER_FORWARD_DECL(PMPI_Wait, int, (MPI_Request *request, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_Send, int, (CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag,MPI_Comm comm));\nRECORDER_FORWARD_DECL(PMPI_Recv, int, (void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_Sendrecv, int, (CONST void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status));\nRECORDER_FORWARD_DECL(PMPI_Isend, int, (CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm, MPI_Request *request));\nRECORDER_FORWARD_DECL(PMPI_Irecv, int, (void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Request *request));\n// Add 3 MPI_Info related functions on 2020/02/24\nRECORDER_FORWARD_DECL(PMPI_Info_create, int, (MPI_Info *info));\nRECORDER_FORWARD_DECL(PMPI_Info_set, int, (MPI_Info info, CONST char *key, CONST char *value));\nRECORDER_FORWARD_DECL(PMPI_Info_get, int, (MPI_Info info, CONST char *key, int valuelen, char *value, int *flag));\n// Add MPI_Waitall, MPI_Waitsome, MPI_Waitany, MPI_Ssend on 2020/08/06\nRECORDER_FORWARD_DECL(PMPI_Waitall, int, (int count, MPI_Request array_of_requests[], MPI_Status array_of_statuses[]));\nRECORDER_FORWARD_DECL(PMPI_Waitsome, int, (int incount, MPI_Request array_of_requests[], int *outcount, int array_of_indices[], MPI_Status array_of_statuses[]));\nRECORDER_FORWARD_DECL(PMPI_Waitany, int, (int count, MPI_Request array_of_requests[], int *indx, MPI_Status * status));\nRECORDER_FORWARD_DECL(PMPI_Ssend, int, (CONST void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm));\n// Add MPI_Comm_split on 2020/08/17\nRECORDER_FORWARD_DECL(PMPI_Comm_split, int, (MPI_Comm comm, int color, int key, MPI_Comm * newcomm));\nRECORDER_FORWARD_DECL(PMPI_Comm_dup, int, (MPI_Comm comm, MPI_Comm * newcomm));\nRECORDER_FORWARD_DECL(PMPI_Comm_create, int, (MPI_Comm comm, MPI_Group group, MPI_Comm * newcomm));\n// Add MPI_File_seek and MPI_File_seek_shared on 2020/08/27\nRECORDER_FORWARD_DECL(PMPI_File_seek, int, (MPI_File fh, MPI_Offset offset, int whence));\nRECORDER_FORWARD_DECL(PMPI_File_seek_shared, int, (MPI_File fh, MPI_Offset offset, int whence));\n\n\n\n\n/* NOTE: using HDF5 1.8 version */\n\n/* File Interface */\nRECORDER_FORWARD_DECL(H5Fcreate, hid_t, (const char *filename, unsigned flags, hid_t create_plist, hid_t access_plist));\nRECORDER_FORWARD_DECL(H5Fopen, hid_t, (const char *filename, unsigned flags, hid_t access_plist));\nRECORDER_FORWARD_DECL(H5Fclose, herr_t, (hid_t file_id));\nRECORDER_FORWARD_DECL(H5Fflush, herr_t, (hid_t object_id, H5F_scope_t scope));\n/* Group Interface */\nRECORDER_FORWARD_DECL(H5Gclose, herr_t, (hid_t group_id));\nRECORDER_FORWARD_DECL(H5Gcreate1, hid_t, (hid_t loc_id, const char *name, size_t size_hint));\nRECORDER_FORWARD_DECL(H5Gcreate2, hid_t, (hid_t loc_id, const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id));\nRECORDER_FORWARD_DECL(H5Gget_objinfo, herr_t, (hid_t loc_id, const char *name, hbool_t follow_link, H5G_stat_t *statbuf));\nRECORDER_FORWARD_DECL(H5Giterate, int, (hid_t loc_id, const char *name, int *idx, H5G_iterate_t operator, void *operator_data));\nRECORDER_FORWARD_DECL(H5Gopen1, hid_t, (hid_t loc_id, const char *name));\nRECORDER_FORWARD_DECL(H5Gopen2, hid_t, (hid_t loc_id, const char *name, hid_t gapl_id));\n/* Dataset Interface  */\nRECORDER_FORWARD_DECL(H5Dclose, herr_t, (hid_t dataset_id));\nRECORDER_FORWARD_DECL(H5Dcreate1, hid_t, (hid_t loc_id, const char *name, hid_t type_id, hid_t space_id, hid_t dcpl_id));\nRECORDER_FORWARD_DECL(H5Dcreate2, hid_t, (hid_t loc_id, const char *name, hid_t dtype_id, hid_t space_id, hid_t lcpl_id, hid_t dcpl_id, hid_t dapl_id));\nRECORDER_FORWARD_DECL(H5Dget_create_plist, hid_t, (hid_t dataset_id));\nRECORDER_FORWARD_DECL(H5Dget_space, hid_t, (hid_t dataset_id));\nRECORDER_FORWARD_DECL(H5Dget_type, hid_t, (hid_t dataset_id));\nRECORDER_FORWARD_DECL(H5Dopen1, hid_t, (hid_t loc_id, const char *name));\nRECORDER_FORWARD_DECL(H5Dopen2, hid_t, (hid_t loc_id, const char *name, hid_t dapl_id));\nRECORDER_FORWARD_DECL(H5Dread, herr_t, (hid_t dataset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t xfer_plist_id, void *buf));\nRECORDER_FORWARD_DECL(H5Dwrite, herr_t, (hid_t dataset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t xfer_plist_id, const void *buf));\nRECORDER_FORWARD_DECL(H5Dset_extent, herr_t, (hid_t dataset_id, const hsize_t size[]));\n/* Dataspace Interface */\nRECORDER_FORWARD_DECL(H5Sclose, herr_t, (hid_t space_id));\nRECORDER_FORWARD_DECL(H5Screate, hid_t, (H5S_class_t type));\nRECORDER_FORWARD_DECL(H5Screate_simple, hid_t, (int rank, const hsize_t *current_dims, const hsize_t *maximum_dims));\nRECORDER_FORWARD_DECL(H5Sget_select_npoints, hssize_t, (hid_t space_id));\nRECORDER_FORWARD_DECL(H5Sget_simple_extent_dims, int, (hid_t space_id, hsize_t * dims, hsize_t * maxdims));\nRECORDER_FORWARD_DECL(H5Sget_simple_extent_npoints, hssize_t, (hid_t space_id));\nRECORDER_FORWARD_DECL(H5Sselect_elements, herr_t, (hid_t space_id, H5S_seloper_t op, size_t num_elements, const hsize_t *coord));\nRECORDER_FORWARD_DECL(H5Sselect_hyperslab, herr_t, (hid_t space_id, H5S_seloper_t op, const hsize_t *start, const hsize_t *stride, const hsize_t *count, const hsize_t *block));\nRECORDER_FORWARD_DECL(H5Sselect_none, herr_t, (hid_t space_id));\n/* Datatype Interface */\nRECORDER_FORWARD_DECL(H5Tclose, herr_t, (hid_t dtype_id));\nRECORDER_FORWARD_DECL(H5Tcopy, hid_t, (hid_t dtype_id));\nRECORDER_FORWARD_DECL(H5Tget_class, H5T_class_t, (hid_t dtype_id));\nRECORDER_FORWARD_DECL(H5Tget_size, size_t, (hid_t dtype_id));\nRECORDER_FORWARD_DECL(H5Tset_size, herr_t, (hid_t dtype_id, size_t size));\nRECORDER_FORWARD_DECL(H5Tcreate, hid_t, (H5T_class_t class, size_t size));\nRECORDER_FORWARD_DECL(H5Tinsert, herr_t, (hid_t dtype_id, const char *name, size_t offset, hid_t field_id));\n/* Attribute Interface */\nRECORDER_FORWARD_DECL(H5Aclose, herr_t, (hid_t attr_id));\nRECORDER_FORWARD_DECL(H5Acreate1, hid_t, (hid_t loc_id, const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id));\nRECORDER_FORWARD_DECL(H5Acreate2, hid_t, (hid_t loc_id, const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id, hid_t aapl_id));\nRECORDER_FORWARD_DECL(H5Aget_name, ssize_t, (hid_t attr_id, size_t buf_size, char *buf));\nRECORDER_FORWARD_DECL(H5Aget_num_attrs, int, (hid_t loc_id));\nRECORDER_FORWARD_DECL(H5Aget_space, hid_t, (hid_t attr_id));\nRECORDER_FORWARD_DECL(H5Aget_type, hid_t, (hid_t attr_id));\nRECORDER_FORWARD_DECL(H5Aopen, hid_t, (hid_t obj_id, const char *attr_name, hid_t aapl_id));\nRECORDER_FORWARD_DECL(H5Aopen_idx, hid_t, (hid_t loc_id, unsigned int idx));\nRECORDER_FORWARD_DECL(H5Aopen_name, hid_t, (hid_t loc_id, const char *name));\nRECORDER_FORWARD_DECL(H5Aread, herr_t, (hid_t attr_id, hid_t mem_type_id, void *buf));\nRECORDER_FORWARD_DECL(H5Awrite, herr_t, (hid_t attr_id, hid_t mem_type_id, const void *buf));\n/* Property List Interface */\nRECORDER_FORWARD_DECL(H5Pclose, herr_t, (hid_t plist));\nRECORDER_FORWARD_DECL(H5Pcreate, hid_t, (hid_t cls_id));\nRECORDER_FORWARD_DECL(H5Pget_chunk, int, (hid_t plist, int max_ndims, hsize_t *dims));\nRECORDER_FORWARD_DECL(H5Pget_mdc_config, herr_t, (hid_t plist_id, H5AC_cache_config_t * config_ptr));\nRECORDER_FORWARD_DECL(H5Pset_alignment, herr_t, (hid_t plist, hsize_t threshold, hsize_t alignment));\nRECORDER_FORWARD_DECL(H5Pset_chunk, herr_t, (hid_t plist, int ndims, const hsize_t *dim));\nRECORDER_FORWARD_DECL(H5Pset_dxpl_mpio, herr_t, (hid_t dxpl_id, H5FD_mpio_xfer_t xfer_mode));\nRECORDER_FORWARD_DECL(H5Pset_fapl_core, herr_t, (hid_t fapl_id, size_t increment, hbool_t backing_store));\nRECORDER_FORWARD_DECL(H5Pset_fapl_mpio, herr_t, (hid_t fapl_id, MPI_Comm comm, MPI_Info info));\nRECORDER_FORWARD_DECL(H5Pset_fapl_mpiposix, herr_t, (hid_t fapl_id, MPI_Comm comm, hbool_t use_gpfs_hints));\nRECORDER_FORWARD_DECL(H5Pset_istore_k, herr_t, (hid_t plist, unsigned ik));\nRECORDER_FORWARD_DECL(H5Pset_mdc_config, herr_t, (hid_t plist_id, H5AC_cache_config_t * config_ptr));\nRECORDER_FORWARD_DECL(H5Pset_meta_block_size, herr_t, (hid_t fapl_id, hsize_t size));\n/* Link Interface */\nRECORDER_FORWARD_DECL(H5Lexists, htri_t, (hid_t loc_id, const char *name, hid_t lapl_id));\nRECORDER_FORWARD_DECL(H5Lget_val, herr_t, (hid_t link_loc_id, const char *link_name, void *linkval_buff, size_t size, hid_t lapl_id));\nRECORDER_FORWARD_DECL(H5Literate, herr_t, (hid_t group_id, H5_index_t index_type, H5_iter_order_t order, hsize_t * idx, H5L_iterate_t op, void *op_data));\nRECORDER_FORWARD_DECL(H5Literate1, herr_t, (hid_t group_id, H5_index_t index_type, H5_iter_order_t order, hsize_t * idx, H5L_iterate_t op, void *op_data));\nRECORDER_FORWARD_DECL(H5Literate2, herr_t, (hid_t group_id, H5_index_t index_type, H5_iter_order_t order, hsize_t * idx, H5L_iterate_t op, void *op_data));\n/* Object Interface */\nRECORDER_FORWARD_DECL(H5Oclose, herr_t, (hid_t object_id));\nRECORDER_FORWARD_DECL(H5Oget_info, herr_t, (hid_t object_id, H5O_info_t * object_info));\nRECORDER_FORWARD_DECL(H5Oget_info_by_name, herr_t, (hid_t loc_id, const char *object_name, H5O_info_t *object_info, hid_t lapl_id));\nRECORDER_FORWARD_DECL(H5Oopen, hid_t, (hid_t loc_id, const char *name, hid_t lapl_id));\n/* Collective Metadata */\nRECORDER_FORWARD_DECL(H5Pset_coll_metadata_write, herr_t, (hid_t fapl_id, hbool_t is_collective));\nRECORDER_FORWARD_DECL(H5Pget_coll_metadata_write, herr_t, (hid_t fapl_id, hbool_t* is_collective));\nRECORDER_FORWARD_DECL(H5Pset_all_coll_metadata_ops, herr_t, (hid_t accpl_id, hbool_t is_collective));\nRECORDER_FORWARD_DECL(H5Pget_all_coll_metadata_ops, herr_t, (hid_t accpl_id, hbool_t* is_collective));\n\n\n#endif /* __RECORDER_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-recorder-2.1.5-7vymm6vaffij3yynh6irbsjvecdqxylt/spack-src/test/showoff.jpg"
    ],
    "total_files": 32
}