{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/library/src/include/ref_cpu.h": "// Copyright (c) 2016 - present Advanced Micro Devices, Inc. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#ifndef REF_CPU_H\n#define REF_CPU_H\n\n#ifdef REF_DEBUG\n\n#include \"hipfft.h\"\n#include <complex>\n#include <cstdio>\n#include <dlfcn.h>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <stdlib.h>\n\n#define LOCAL_FFTW_FORWARD (-1)\n#define LOCAL_FFTW_BACKWARD (+1)\n#define LOCAL_FFTW_ESTIMATE (1U << 6)\n\ntypedef float local_fftwf_complex[2]; // each elment is a float type\n\ntypedef void* (*ftype_fftwf_malloc)(size_t n);\ntypedef void (*ftype_fftwf_free)(void* p);\n\ntypedef void* (*ftype_fftwf_plan_many_dft)(int                  rank,\n                                           const int*           n,\n                                           int                  howmany,\n                                           local_fftwf_complex* in,\n                                           const int*           inembed,\n                                           int                  istride,\n                                           int                  idist,\n                                           local_fftwf_complex* out,\n                                           const int*           onembed,\n                                           int                  ostride,\n                                           int                  odist,\n                                           int                  sign,\n                                           unsigned             flags);\n\ntypedef void (*ftype_fftwf_execute)(void*);\n\ntypedef void (*ftype_fftwf_destroy_plan)(void*);\n\nclass RefLibHandle\n{\n    RefLibHandle()\n        : fftw3f_lib(nullptr)\n        , fftw3_lib(nullptr)\n    {\n        const char* fftw3f_lib_path = getenv(\"ROCFFT_DBG_FFTW3F_LIB\");\n        const char* fftw3_lib_path  = getenv(\"ROCFFT_DBG_FFTW3_LIB\");\n\n        if(!fftw3f_lib_path)\n        {\n            fftw3f_lib_path = \"libfftw3f.so\";\n        }\n\n        if(!fftw3_lib_path)\n        {\n            fftw3_lib_path = \"libfftw3.so\";\n        }\n\n        fftw3f_lib = dlopen(fftw3f_lib_path, RTLD_NOW);\n        if(!fftw3f_lib)\n        {\n            rocfft_cout << \"error opening \" << fftw3f_lib_path << \": \" << dlerror() << std::endl;\n            rocfft_cout << \"set env variable ROCFFT_DBG_FFTW3F_LIB to a valid path\\n\";\n        }\n\n        fftw3_lib = dlopen(fftw3_lib_path, RTLD_NOW);\n        if(!fftw3_lib)\n        {\n            rocfft_cout << \"error opening \" << fftw3_lib_path << \": \" << dlerror() << std::endl;\n            rocfft_cout << \"set env variable ROCFFT_DBG_FFTW3_LIB to a valid path\\n\";\n        }\n    }\n\npublic:\n    void* fftw3f_lib;\n    void* fftw3_lib;\n\n    // delete is a c++11 feature, prohibit copy constructor:\n    RefLibHandle(const RefLibHandle&) = delete;\n    // prohibit assignment operator:\n    RefLibHandle& operator=(const RefLibHandle&) = delete;\n\n    static RefLibHandle& GetRefLibHandle()\n    {\n        static RefLibHandle refLibHandle;\n        return refLibHandle;\n    }\n\n    ~RefLibHandle()\n    {\n        if(fftw3f_lib)\n        {\n            dlclose(fftw3f_lib);\n            fftw3f_lib = nullptr;\n        }\n\n        if(fftw3_lib)\n        {\n            dlclose(fftw3_lib);\n            fftw3_lib = nullptr;\n        }\n    }\n};\n\nclass fftwbuf\n{\nprivate:\n    void* (*local_fftwf_malloc)(const size_t);\n    void (*local_fftwf_free)(void*);\n    void freedata()\n    {\n        (*local_fftwf_free)(data);\n    }\n\npublic:\n    fftwbuf()\n        : data(NULL)\n        , size(0)\n        , typesize(0)\n    {\n        RefLibHandle& refHandle = RefLibHandle::GetRefLibHandle();\n        local_fftwf_malloc      = (ftype_fftwf_malloc)dlsym(refHandle.fftw3f_lib, \"fftwf_malloc\");\n        local_fftwf_free        = (ftype_fftwf_free)dlsym(refHandle.fftw3f_lib, \"fftwf_free\");\n    };\n    fftwbuf(const size_t size0, const size_t typesize0)\n        : data(0)\n        , size(size0)\n        , typesize(typesize0)\n    {\n        RefLibHandle& refHandle = RefLibHandle::GetRefLibHandle();\n        local_fftwf_malloc      = (ftype_fftwf_malloc)dlsym(refHandle.fftw3f_lib, \"fftwf_malloc\");\n        local_fftwf_free        = (ftype_fftwf_free)dlsym(refHandle.fftw3f_lib, \"fftwf_free\");\n\n        alloc(size0, typesize0);\n    };\n    ~fftwbuf()\n    {\n        if(data)\n        {\n            freedata();\n        }\n    };\n    void alloc(const size_t size0, const size_t typesize0)\n    {\n        size     = size0;\n        typesize = typesize0;\n        if(data != NULL)\n        {\n            freedata();\n        }\n        data = (void*)(*local_fftwf_malloc)(typesize * size);\n        assert(data != NULL);\n    }\n    size_t bufsize()\n    {\n        return size * typesize;\n    };\n    void*  data;\n    size_t size;\n    size_t typesize;\n};\n\nclass RefLibOp\n{\n    // input from fftw:\n    fftwbuf fftwin;\n\n    // output from fftw:\n    fftwbuf fftwout;\n\n    // output from lib:\n    fftwbuf libout;\n\n    void DataSetup(const void* data_p)\n    {\n        RefLibHandle& refHandle = RefLibHandle::GetRefLibHandle();\n\n        DeviceCallIn* data = (DeviceCallIn*)data_p;\n\n        size_t totalSize;\n\n        size_t in_typesize = (data->node->inArrayType == rocfft_array_type_real)\n                                 ? sizeof(float)\n                                 : sizeof(std::complex<float>);\n        size_t out_typesize = (data->node->outArrayType == rocfft_array_type_real)\n                                  ? sizeof(float)\n                                  : sizeof(std::complex<float>);\n\n        size_t     insize  = 0;\n        size_t     outsize = 0;\n        const auto batch   = data->node->batch;\n\n        // TODO: what about strides, etc?\n        switch(data->node->scheme)\n        {\n        case CS_KERNEL_CHIRP:\n            insize  = 2 * data->node->lengthBlue;\n            outsize = insize;\n            break;\n        case CS_KERNEL_FFT_MUL:\n        case CS_KERNEL_PAD_MUL:\n        case CS_KERNEL_RES_MUL:\n            // NB: the Bluestein length is the first dimesion\n            insize = std::accumulate(data->node->length.begin() + 1,\n                                     data->node->length.end(),\n                                     batch,\n                                     std::multiplies<size_t>());\n            insize *= data->node->lengthBlue;\n            outsize = insize;\n            break;\n        case CS_KERNEL_R_TO_CMPLX:\n            insize      = batch * data->node->length[0];\n            outsize     = batch * (data->node->length[0] + 1);\n            in_typesize = sizeof(std::complex<float>);\n            break;\n        case CS_KERNEL_CMPLX_TO_R:\n            insize       = batch * (data->node->length[0] + 1);\n            outsize      = batch * data->node->length[0];\n            in_typesize  = sizeof(std::complex<float>);\n            out_typesize = sizeof(std::complex<float>);\n            break;\n        default:\n            insize  = std::accumulate(data->node->length.begin(),\n                                     data->node->length.end(),\n                                     batch,\n                                     std::multiplies<size_t>());\n            outsize = insize;\n        }\n\n        assert(insize > 0);\n        assert(outsize > 0);\n\n        fftwin.alloc(insize, in_typesize);\n        fftwout.alloc(outsize, out_typesize);\n        libout.alloc(outsize, out_typesize);\n\n        memset(fftwin.data, 0x40, fftwin.bufsize());\n        memset(fftwout.data, 0x40, fftwout.bufsize());\n        memset(libout.data, 0x40, libout.bufsize());\n\n#if 0\n        // Initialize the code to some known value to help debug the\n        // cpu reference implementation.\n        std::complex<float>* input = (std::complex<float>*)fftwin.data;\n        for(int r = 0; r < fftwin.size; ++r)\n        {\n            input[r] = std::complex<float>(r + 0.5, r * r + 3);\n        }\n#endif\n    }\n\n    // Copy a host vector to a host vector, taking strides and other\n    // data layout elements into account.\n    void CopyVector(local_fftwf_complex* dst,\n                    local_fftwf_complex* src,\n                    size_t               batch,\n                    size_t               dist,\n                    std::vector<size_t>  length,\n                    std::vector<size_t>  stride)\n    {\n        size_t lenSize\n            = std::accumulate(length.begin(), length.end(), 1, std::multiplies<size_t>());\n\n        size_t b = 0;\n        while(b < batch)\n        {\n            size_t offset_dst   = 0;\n            size_t offset_src   = 0;\n            size_t offset_src_d = 0;\n            size_t pos          = 0;\n            bool   obreak       = false;\n\n            std::vector<size_t> current;\n            current.assign(length.size(), 0);\n\n            while(true)\n            {\n                offset_src = offset_src_d + current[0] * stride[0];\n\n                dst[offset_dst][0] = src[offset_src][0];\n                dst[offset_dst][1] = src[offset_src][1];\n\n                current[0]++;\n                offset_dst++;\n\n                while(current[pos] == length[pos])\n                {\n                    if(pos == (length.size() - 1))\n                    {\n                        obreak = true;\n                        break;\n                    }\n\n                    current[pos] = 0;\n                    pos++;\n                    current[pos]++;\n\n                    offset_src_d = 0;\n                    for(size_t i = 1; i < current.size(); i++)\n                        offset_src_d += current[i] * stride[i];\n                }\n\n                if(obreak)\n                    break;\n\n                pos = 0;\n            }\n\n            b++;\n            src += dist;\n            dst += lenSize;\n        }\n    }\n\n    void CopyInputVector(const void* data_p, size_t offset = 0)\n    {\n        DeviceCallIn* data = (DeviceCallIn*)data_p;\n\n        size_t in_size_bytes = (data->node->iDist * data->node->batch) * sizeof(float);\n\n        if(data->node->inArrayType != rocfft_array_type_real)\n        {\n            in_size_bytes *= 2;\n        }\n\n        void*   buf = ((char*)data->bufIn[0] + offset);\n        fftwbuf tmp_mem(data->node->iDist * data->node->batch, sizeof(std::complex<float>));\n        hipMemcpy(tmp_mem.data, buf, in_size_bytes, hipMemcpyDeviceToHost);\n\n        CopyVector((local_fftwf_complex*)fftwin.data,\n                   (local_fftwf_complex*)tmp_mem.data,\n                   data->node->batch,\n                   data->node->iDist,\n                   data->node->length,\n                   data->node->inStride);\n    }\n\n    inline float2\n        TwMul(float2* twiddles, const size_t twl, const int direction, float2 val, size_t u)\n    {\n        size_t j      = u & 255;\n        float2 result = twiddles[j];\n\n        float  real, imag;\n        size_t h = 1;\n        do\n        {\n            u >>= 8;\n            j        = u & 255;\n            real     = (result.x * twiddles[256 * h + j].x - result.y * twiddles[256 * h + j].y);\n            imag     = (result.y * twiddles[256 * h + j].x + result.x * twiddles[256 * h + j].y);\n            result.x = real;\n            result.y = imag;\n            h++;\n        } while(h < twl);\n\n        if(direction == -1)\n        {\n            real = (result.x * val.x) - (result.y * val.y);\n            imag = (result.y * val.x) + (result.x * val.y);\n        }\n        else\n        {\n            real = (result.x * val.x) + (result.y * val.y);\n            imag = -(result.y * val.x) + (result.x * val.y);\n        }\n\n        result.x = real;\n        result.y = imag;\n\n        return result;\n    }\n\n    inline void chirp(size_t N, size_t M, int dir, local_fftwf_complex* vec)\n    {\n        const double TWO_PI = atan(1.0) * 8.0 * (double)(-dir);\n\n        for(size_t i = 0; i <= (M - N); i++)\n        {\n            double cs = cos(TWO_PI * (double)(i * i) / (2.0 * (double)N));\n            double ss = sin(TWO_PI * (double)(i * i) / (2.0 * (double)N));\n\n            if(i == 0)\n            {\n                vec[i][0] = cs;\n                vec[i][1] = ss;\n\n                vec[i + M][0] = cs;\n                vec[i + M][1] = ss;\n            }\n            else if(i < N)\n            {\n                vec[i][0]     = cs;\n                vec[i][1]     = ss;\n                vec[M - i][0] = cs;\n                vec[M - i][1] = ss;\n\n                vec[i + M][0]     = cs;\n                vec[i + M][1]     = ss;\n                vec[M - i + M][0] = cs;\n                vec[M - i + M][1] = ss;\n            }\n            else\n            {\n                vec[i][0]     = 0;\n                vec[i][1]     = 0;\n                vec[i + M][0] = 0;\n                vec[i + M][1] = 0;\n            }\n        }\n    }\n\n    inline void chirp_fft(size_t N, size_t M, int dir, local_fftwf_complex* vec)\n    {\n        RefLibHandle&             refHandle = RefLibHandle::GetRefLibHandle();\n        ftype_fftwf_plan_many_dft local_fftwf_plan_many_dft\n            = (ftype_fftwf_plan_many_dft)dlsym(refHandle.fftw3f_lib, \"fftwf_plan_many_dft\");\n        ftype_fftwf_execute local_fftwf_execute\n            = (ftype_fftwf_execute)dlsym(refHandle.fftw3f_lib, \"fftwf_execute\");\n        ftype_fftwf_destroy_plan local_fftwf_destroy_plan\n            = (ftype_fftwf_destroy_plan)dlsym(refHandle.fftw3f_lib, \"fftwf_destroy_plan\");\n\n        int n[1] = {static_cast<int>(M)};\n\n        void* p = local_fftwf_plan_many_dft(1,\n                                            n,\n                                            1,\n                                            vec,\n                                            NULL,\n                                            1,\n                                            n[0],\n                                            vec,\n                                            NULL,\n                                            1,\n                                            n[0],\n                                            (dir == -1) ? LOCAL_FFTW_FORWARD : LOCAL_FFTW_BACKWARD,\n                                            LOCAL_FFTW_ESTIMATE);\n        chirp(N, M, dir, vec);\n        local_fftwf_execute(p);\n        local_fftwf_destroy_plan(p);\n    }\n\n    void Execute(const void* data_p)\n    {\n        DeviceCallIn* data = (DeviceCallIn*)data_p;\n\n        switch(data->node->scheme)\n        {\n        case CS_KERNEL_STOCKHAM:\n        {\n            RefLibHandle&             refHandle = RefLibHandle::GetRefLibHandle();\n            ftype_fftwf_plan_many_dft local_fftwf_plan_many_dft\n                = (ftype_fftwf_plan_many_dft)dlsym(refHandle.fftw3f_lib, \"fftwf_plan_many_dft\");\n            ftype_fftwf_execute local_fftwf_execute\n                = (ftype_fftwf_execute)dlsym(refHandle.fftw3f_lib, \"fftwf_execute\");\n            ftype_fftwf_destroy_plan local_fftwf_destroy_plan\n                = (ftype_fftwf_destroy_plan)dlsym(refHandle.fftw3f_lib, \"fftwf_destroy_plan\");\n\n            int n[1]    = {static_cast<int>(data->node->length[0])};\n            int howmany = data->node->batch;\n            for(size_t i = 1; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            void* p = local_fftwf_plan_many_dft(1,\n                                                n,\n                                                howmany,\n                                                (local_fftwf_complex*)fftwin.data,\n                                                NULL,\n                                                1,\n                                                n[0],\n                                                (local_fftwf_complex*)fftwout.data,\n                                                NULL,\n                                                1,\n                                                n[0],\n                                                (data->node->direction == -1) ? LOCAL_FFTW_FORWARD\n                                                                              : LOCAL_FFTW_BACKWARD,\n                                                LOCAL_FFTW_ESTIMATE);\n            CopyInputVector(data_p);\n            local_fftwf_execute(p);\n            local_fftwf_destroy_plan(p);\n        }\n        break;\n        case CS_KERNEL_2D_SINGLE:\n        {\n            RefLibHandle&             refHandle = RefLibHandle::GetRefLibHandle();\n            ftype_fftwf_plan_many_dft local_fftwf_plan_many_dft\n                = (ftype_fftwf_plan_many_dft)dlsym(refHandle.fftw3f_lib, \"fftwf_plan_many_dft\");\n            ftype_fftwf_execute local_fftwf_execute\n                = (ftype_fftwf_execute)dlsym(refHandle.fftw3f_lib, \"fftwf_execute\");\n            ftype_fftwf_destroy_plan local_fftwf_destroy_plan\n                = (ftype_fftwf_destroy_plan)dlsym(refHandle.fftw3f_lib, \"fftwf_destroy_plan\");\n\n            // fftw does row-major indexing and we have column-major,\n            // so give N1, N0\n            int n[2]    = {static_cast<int>(data->node->length[1]),\n                        static_cast<int>(data->node->length[0])};\n            int howmany = data->node->batch;\n            for(size_t i = 2; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            void* p = local_fftwf_plan_many_dft(2,\n                                                n,\n                                                howmany,\n                                                (local_fftwf_complex*)fftwin.data,\n                                                NULL,\n                                                1,\n                                                n[0],\n                                                (local_fftwf_complex*)fftwout.data,\n                                                NULL,\n                                                1,\n                                                n[0],\n                                                (data->node->direction == -1) ? LOCAL_FFTW_FORWARD\n                                                                              : LOCAL_FFTW_BACKWARD,\n                                                LOCAL_FFTW_ESTIMATE);\n            CopyInputVector(data_p);\n            local_fftwf_execute(p);\n            local_fftwf_destroy_plan(p);\n        }\n        break;\n        case CS_KERNEL_TRANSPOSE:\n        {\n            // TODO: what about the real transpose case?\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            std::complex<float>* in = (std::complex<float>*)fftwin.data;\n\n            CopyInputVector(data_p);\n\n            size_t howmany = data->node->batch;\n            for(size_t i = 2; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            size_t cols = data->node->length[0];\n            size_t rows = data->node->length[1];\n\n            if(data->node->large1D == 0)\n            {\n                for(size_t b = 0; b < howmany; b++)\n                {\n                    for(size_t i = 0; i < rows; i++)\n                    {\n                        for(size_t j = 0; j < cols; j++)\n                        {\n                            ot[b * rows * cols + j * rows + i] = in[b * rows * cols + i * cols + j];\n                        }\n                    }\n                }\n            }\n            else\n            {\n                float2*                   twtc;\n                size_t                    ns = 0;\n                TwiddleTableLarge<float2> twTable(data->node->large1D);\n                std::tie(ns, twtc) = twTable.GenerateTwiddleTable();\n\n                int twl = 0;\n\n                if(data->node->large1D > (size_t)256 * 256 * 256 * 256)\n                    printf(\"large1D twiddle size too large error\");\n                else if(data->node->large1D > (size_t)256 * 256 * 256)\n                    twl = 4;\n                else if(data->node->large1D > (size_t)256 * 256)\n                    twl = 3;\n                else if(data->node->large1D > (size_t)256)\n                    twl = 2;\n                else\n                    twl = 0;\n\n                for(size_t b = 0; b < howmany; b++)\n                {\n                    for(size_t i = 0; i < rows; i++)\n                    {\n                        for(size_t j = 0; j < cols; j++)\n                        {\n                            float2 in_v, ot_v;\n\n                            in_v.x = in[b * rows * cols + i * cols + j].real();\n                            in_v.y = in[b * rows * cols + i * cols + j].imag();\n\n                            ot_v = TwMul(twtc, twl, data->node->direction, in_v, i * j);\n\n                            ot[b * rows * cols + j * rows + i].real(ot_v.x);\n                            ot[b * rows * cols + j * rows + i].imag(ot_v.y);\n                        }\n                    }\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_COPY_R_TO_CMPLX:\n        {\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            size_t in_size_bytes    = (data->node->iDist * data->node->batch) * sizeof(float);\n\n            fftwbuf tmp_mem(data->node->iDist * data->node->batch, sizeof(std::complex<float>));\n\n            hipMemcpy(tmp_mem.data, data->bufIn[0], in_size_bytes, hipMemcpyDeviceToHost);\n\n            std::complex<float>* tmp_data = (std::complex<float>*)tmp_mem.data;\n\n            size_t elements = 1;\n            for(size_t d = 0; d < data->node->length.size(); d++)\n            {\n                elements *= data->node->length[d];\n            }\n            for(size_t b = 0; b < data->node->batch; b++)\n            {\n                for(size_t i = 0; i < elements; i++)\n                {\n                    ot[data->node->oDist * b + i]\n                        = std::complex<float>(tmp_data[data->node->iDist * b + i].real(), 0.0);\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_COPY_CMPLX_TO_HERM:\n        {\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            // assump the input is complex, the output is hermitian on take the first\n            // [N/2 + 1] elements\n            size_t in_size_bytes = (data->node->iDist * data->node->batch) * 2 * sizeof(float);\n\n            fftwbuf tmp_mem(data->node->iDist * data->node->batch, sizeof(std::complex<float>));\n\n            hipMemcpy(tmp_mem.data, data->bufIn[0], in_size_bytes, hipMemcpyDeviceToHost);\n\n            std::complex<float>* tmp_data = (std::complex<float>*)tmp_mem.data;\n\n            size_t elements = 1;\n            elements *= data->node->length[0] / 2 + 1;\n            for(size_t d = 1; d < data->node->length.size(); d++)\n            {\n                elements *= data->node->length[d];\n            }\n\n            rocfft_cout << \"iDist: \" << data->node->iDist << \" Dist: \" << data->node->oDist\n                        << \" in complex2hermitian kernel\\n\";\n            for(size_t b = 0; b < data->node->batch; b++)\n            {\n                for(size_t i = 0; i < elements; i++) // TODO: only work for 1D cases\n                {\n                    ot[data->node->oDist * b + i] = tmp_data[data->node->iDist * b + i];\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_COPY_HERM_TO_CMPLX:\n        {\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            // assump the input is hermitian, the output is complex on take the first\n            // [N/2 + 1] elements\n            size_t in_size_bytes = (data->node->iDist * data->node->batch) * 2 * sizeof(float);\n\n            fftwbuf tmp_mem(data->node->iDist * data->node->batch, sizeof(std::complex<float>));\n\n            hipMemcpy(tmp_mem.data, data->bufIn[0], in_size_bytes, hipMemcpyDeviceToHost);\n\n            std::complex<float>* tmp_data = (std::complex<float>*)tmp_mem.data;\n\n            size_t output_size = data->node->length[0];\n            size_t input_size  = output_size / 2 + 1;\n\n            rocfft_cout << \"iDist: \" << data->node->iDist << \" Dist: \" << data->node->oDist\n                        << \" in hermitian2complex kernel\\n\";\n\n            for(size_t b = 0; b < data->node->batch; b++)\n            {\n                for(size_t d = 0;\n                    d < (data->node->length.size() == 2 ? (data->node->length[1]) : 1);\n                    d++) // TODO; only work for 1D or 2D\n                {\n                    for(size_t i = 0; i < input_size; i++)\n                    {\n                        ot[data->node->oDist * b + d * output_size + i]\n                            = tmp_data[data->node->iDist * b + d * input_size + i];\n\n                        if(i > 0)\n                        {\n                            size_t mirror = output_size - i;\n                            ot[data->node->oDist * b + d * output_size + mirror]\n                                = tmp_data[data->node->iDist * b + d * input_size + i];\n                        }\n                    }\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_R_TO_CMPLX:\n        {\n            // Post-processing stage of 1D real-to-complex transform, out-of-place\n            const size_t halfN = data->node->length[0];\n            const size_t batch = data->node->batch;\n\n            assert(fftwin.size == batch * halfN);\n            assert(fftwout.size == batch * (halfN + 1));\n\n            const auto           input  = (std::complex<float>*)fftwin.data;\n            std::complex<float>* output = (std::complex<float>*)fftwout.data;\n\n            size_t output_idx_base = 0;\n\n            const std::complex<float> I(0, 1);\n            const std::complex<float> one(1, 0);\n            const std::complex<float> half(0.5, 0);\n\n            const float overN = 0.5 / halfN;\n\n            for(int ibatch = 0; ibatch < batch; ++ibatch)\n            {\n                const auto bin  = input + ibatch * halfN;\n                auto       bout = output + ibatch * (halfN + 1);\n                bout[0]         = std::complex<float>(bin[0].real() + bin[0].imag());\n                for(int r = 1; r < halfN; ++r)\n                {\n                    const auto omegaNr\n                        = std::exp(std::complex<float>(0.0f, (float)(-2.0f * M_PI * r * overN)));\n                    bout[r] = bin[r] * half * (one - I * omegaNr)\n                              + conj(bin[halfN - r]) * half * (one + I * omegaNr);\n                }\n            }\n            output[output_idx_base + halfN]\n                = std::complex<float>(input[0].real() - input[0].imag(), 0);\n        }\n        break;\n        case CS_KERNEL_CMPLX_TO_R:\n        {\n            // Pre-processing stage of 1D complex-to-real transform, out-of-place\n            const size_t halfN = data->node->length[0];\n            const size_t batch = data->node->batch;\n\n            assert(fftwin.size == batch * (halfN + 1));\n            assert(fftwout.size == batch * halfN);\n            assert(fftwin.typesize == sizeof(std::complex<float>));\n            assert(fftwout.typesize == sizeof(std::complex<float>));\n\n            const std::complex<float>* input  = (std::complex<float>*)fftwin.data;\n            std::complex<float>*       output = (std::complex<float>*)fftwout.data;\n\n            const float               overN = 0.5 / halfN;\n            const std::complex<float> I(0, 1);\n            const std::complex<float> one(1, 0);\n\n            for(int ibatch = 0; ibatch < batch; ++ibatch)\n            {\n                const auto bin  = input + ibatch * (halfN + 1);\n                auto       bout = output + ibatch * halfN;\n                for(int r = 0; r < halfN; ++r)\n                {\n                    const auto omegaNr = std::exp(std::complex<float>(0, 2.0 * M_PI * r * overN));\n                    bout[r]\n                        = bin[r] * (one + I * omegaNr) + conj(bin[halfN - r]) * (one - I * omegaNr);\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_CHIRP:\n        {\n            size_t N = data->node->length[0];\n            size_t M = data->node->lengthBlue;\n            chirp(N, M, data->node->direction, (local_fftwf_complex*)fftwout.data);\n        }\n        break;\n        case CS_KERNEL_PAD_MUL:\n        {\n            std::complex<float>* in = (std::complex<float>*)fftwin.data;\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            CopyInputVector(data_p);\n\n            size_t howmany = data->node->batch;\n            for(size_t i = 1; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            size_t N = data->node->length[0];\n            size_t M = data->node->lengthBlue;\n\n            fftwbuf chirp_mem(M * 2, sizeof(std::complex<float>));\n\n            chirp(N, M, data->node->direction, (local_fftwf_complex*)chirp_mem.data);\n\n            std::complex<float>* chirp_data = (std::complex<float>*)chirp_mem.data;\n\n            for(size_t b = 0; b < howmany; b++)\n            {\n                for(size_t i = 0; i < M; i++)\n                {\n                    if(i < N)\n                    {\n                        float in_r = in[b * N + i].real();\n                        float in_i = in[b * N + i].imag();\n                        float ch_r = chirp_data[i].real();\n                        float ch_i = chirp_data[i].imag();\n\n                        ot[b * M + i].real(in_r * ch_r + in_i * ch_i);\n                        ot[b * M + i].imag(-in_r * ch_i + in_i * ch_r);\n                    }\n                    else\n                    {\n                        ot[b * M + i].real(0);\n                        ot[b * M + i].imag(0);\n                    }\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_FFT_MUL:\n        {\n            std::complex<float>* in = (std::complex<float>*)fftwin.data;\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            size_t               M  = data->node->lengthBlue;\n            size_t               N  = data->node->parent->length[0];\n\n            CopyInputVector(data_p, M * 2 * 2 * sizeof(float));\n\n            fftwbuf chirp_mem(M * 2, sizeof(std::complex<float>));\n\n            chirp_fft(N, M, data->node->direction, (local_fftwf_complex*)chirp_mem.data);\n\n            std::complex<float>* chirp_data = (std::complex<float>*)chirp_mem.data;\n\n            size_t howmany = data->node->batch;\n            for(size_t i = 1; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            for(size_t b = 0; b < howmany; b++)\n            {\n                for(size_t i = 0; i < M; i++)\n                {\n                    float in_r = in[b * M + i].real();\n                    float in_i = in[b * M + i].imag();\n                    float ch_r = chirp_data[i].real();\n                    float ch_i = chirp_data[i].imag();\n\n                    ot[b * M + i].real(in_r * ch_r - in_i * ch_i);\n                    ot[b * M + i].imag(in_r * ch_i + in_i * ch_r);\n                }\n            }\n        }\n        break;\n        case CS_KERNEL_RES_MUL:\n        {\n            std::complex<float>* in = (std::complex<float>*)fftwin.data;\n            std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n            size_t               M  = data->node->lengthBlue;\n            size_t               N  = data->node->length[0];\n\n            CopyInputVector(data_p, M * 2 * 2 * sizeof(float));\n\n            fftwbuf chirp_mem(M * 2, sizeof(std::complex<float>));\n\n            chirp(N, M, data->node->direction, (local_fftwf_complex*)chirp_mem.data);\n\n            std::complex<float>* chirp_data = (std::complex<float>*)chirp_mem.data;\n\n            size_t howmany = data->node->batch;\n            for(size_t i = 1; i < data->node->length.size(); i++)\n                howmany *= data->node->length[i];\n\n            double MI = 1.0 / (double)M;\n            for(size_t b = 0; b < howmany; b++)\n            {\n                for(size_t i = 0; i < N; i++)\n                {\n                    float in_r = in[b * N + i].real();\n                    float in_i = in[b * N + i].imag();\n                    float ch_r = chirp_data[i].real();\n                    float ch_i = chirp_data[i].imag();\n\n                    ot[b * N + i].real(MI * (in_r * ch_r + in_i * ch_i));\n                    ot[b * N + i].imag(MI * (-in_r * ch_i + in_i * ch_r));\n                }\n            }\n        }\n        break;\n        default:\n            // assert(false);\n            // do not terminate the program but only tells not implemented\n            rocfft_cout << \"Not implemented\\n\";\n        }\n    }\n\npublic:\n    RefLibOp(const void* data_p)\n    {\n        DataSetup(data_p);\n        Execute(data_p);\n    }\n\n    void VerifyResult(const void* data_p)\n    {\n        DeviceCallIn* data        = (DeviceCallIn*)data_p;\n        size_t        out_size    = (data->node->oDist * data->node->batch);\n        size_t        checklength = data->node->length[0];\n        for(int i = 1; i < data->node->length.size(); ++i)\n        {\n            checklength *= data->node->length[i];\n        }\n        void* bufOut = data->bufOut[0];\n\n        switch(data->node->scheme)\n        {\n        case CS_KERNEL_CHIRP:\n            out_size *= 2;\n            break;\n        case CS_KERNEL_FFT_MUL:\n        case CS_KERNEL_PAD_MUL:\n            // TODO: document\n            bufOut = ((char*)bufOut + 2 * 2 * sizeof(float) * data->node->lengthBlue);\n            break;\n        case CS_KERNEL_COPY_CMPLX_TO_R:\n        case CS_KERNEL_COPY_HERM_TO_CMPLX:\n        case CS_KERNEL_STOCKHAM_BLOCK_RC:\n        case CS_KERNEL_STOCKHAM_BLOCK_CC:\n            return; // not implemented\n            break;\n        case CS_KERNEL_COPY_CMPLX_TO_HERM:\n            checklength = libout.size / 2 + 1;\n            break;\n        case CS_KERNEL_CMPLX_TO_R:\n            checklength = libout.size / 2;\n            break;\n        default:\n            break;\n        }\n\n        fftwbuf tmp_mem(out_size, sizeof(std::complex<float>));\n\n        // Copy the device information to out local buffer:\n        hipMemcpy(tmp_mem.data, bufOut, tmp_mem.bufsize(), hipMemcpyDeviceToHost);\n\n        switch(data->node->scheme)\n        {\n        case CS_KERNEL_TRANSPOSE:\n        {\n            std::vector<size_t> length_transpose_output;\n            length_transpose_output.push_back(data->node->length[1]);\n            length_transpose_output.push_back(data->node->length[0]);\n            for(size_t i = 2; i < data->node->length.size(); i++)\n                length_transpose_output.push_back(data->node->length[i]);\n            CopyVector((local_fftwf_complex*)libout.data,\n                       (local_fftwf_complex*)tmp_mem.data,\n                       data->node->batch,\n                       data->node->oDist,\n                       length_transpose_output,\n                       data->node->outStride);\n        }\n        break;\n        case CS_KERNEL_CHIRP:\n        {\n            std::vector<size_t> length_chirp;\n            length_chirp.push_back(data->node->lengthBlue);\n            CopyVector((local_fftwf_complex*)libout.data,\n                       (local_fftwf_complex*)tmp_mem.data,\n                       2 * data->node->batch,\n                       data->node->oDist,\n                       length_chirp,\n                       data->node->outStride);\n        }\n        break;\n        case CS_KERNEL_PAD_MUL:\n        {\n            std::vector<size_t> length_ot;\n            length_ot.push_back(data->node->lengthBlue);\n            for(size_t i = 1; i < data->node->length.size(); i++)\n                length_ot.push_back(data->node->length[i]);\n            CopyVector((local_fftwf_complex*)libout.data,\n                       (local_fftwf_complex*)tmp_mem.data,\n                       data->node->batch,\n                       data->node->oDist,\n                       length_ot,\n                       data->node->outStride);\n        }\n        break;\n        case CS_KERNEL_COPY_CMPLX_TO_HERM:\n            hipMemcpy(libout.data,\n                      tmp_mem.data,\n                      tmp_mem.bufsize(),\n                      hipMemcpyHostToHost); // hermitan only works for batch=1, dense\n            // packed cases\n            //assert(batch == 1);\n            return; // TODO\n            break;\n        default:\n        {\n            CopyVector((local_fftwf_complex*)libout.data,\n                       (local_fftwf_complex*)tmp_mem.data,\n                       data->node->batch,\n                       data->node->oDist,\n                       data->node->length,\n                       data->node->outStride);\n        }\n        }\n\n        double maxMag = 0.0;\n        double rmse   = 0.0;\n\n        // compare library results vs CPU results\n        // TODO: what about real-valued outputs?\n        std::complex<float>* lb = (std::complex<float>*)libout.data;\n        std::complex<float>* ot = (std::complex<float>*)fftwout.data;\n        for(size_t i = 0; i < checklength; i++)\n        {\n            double ac_r = lb[i].real();\n            double ac_i = lb[i].imag();\n            double ex_r = ot[i].real();\n            double ex_i = ot[i].imag();\n\n            double mag = ex_r * ex_r + ex_i * ex_i;\n            maxMag     = (mag > maxMag) ? mag : maxMag;\n\n            rmse += ((ex_r - ac_r) * (ex_r - ac_r) + (ex_i - ac_i) * (ex_i - ac_i));\n        }\n\n        maxMag       = sqrt(maxMag);\n        rmse         = sqrt(rmse / (double)checklength);\n        double nrmse = rmse / maxMag;\n\n        rocfft_cout << \"rmse: \" << rmse << std::endl << \"nrmse: \" << nrmse << std::endl;\n        rocfft_cout << \"---------------------------------------------\" << std::endl;\n\n#if 0\n        std::complex<float>* in      = (std::complex<float>*)fftwin.data;\n\n        rocfft_cout << \"input:\" << std::endl;\n        for(size_t i = 0; i < fftwin.size; ++i)\n        {\n            rocfft_cout << i << \"\\t(\" << in[i].real() << \", \" << in[i].imag() << \")\\n\";\n        }\n\n        rocfft_cout << \"lib output vs cpu output:\" << std::endl;\n        for(size_t i = 0; i < libout.size; ++i)\n        {\n            rocfft_cout << i << \"\\t(\" << lb[i].real() << \",\" << lb[i].imag() << \")\"\n                      << \"\\t(\" << ot[i].real() << \",\" << ot[i].imag() << \")\\n\";\n        }\n#endif\n    }\n};\n\n#endif // REF_DEBUG\n\n#endif // REF_CPU_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/clients/rider/dyna-rider.cpp": "// Copyright (c) 2020 - present Advanced Micro Devices, Inc. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// This file allows one to run tests multiple different rocFFT libraries at the same time.\n// This allows one to randomize the execution order for better a better experimental setup\n// which produces fewer type 1 errors where one incorrectly rejects the null hypothesis.\n\n#include <complex>\n#include <hip/hip_runtime_api.h>\n#include <iostream>\n#include <math.h>\n#include <vector>\n\n#include <dlfcn.h>\n#include <link.h>\n\n#include \"rider.h\"\n#include \"rocfft.h\"\n\n#include <boost/program_options.hpp>\nnamespace po = boost::program_options;\n\n// Given a libhandle from dload, return a plan to a rocFFT plan with the given parameters.\nrocfft_plan make_plan(void*                         libhandle,\n                      const rocfft_result_placement place,\n                      const rocfft_transform_type   transformType,\n                      const std::vector<size_t>&    length,\n                      const std::vector<size_t>&    istride,\n                      const std::vector<size_t>&    ostride,\n                      const size_t                  idist,\n                      const size_t                  odist,\n                      const std::vector<size_t>     ioffset,\n                      const std::vector<size_t>     ooffset,\n                      const size_t                  nbatch,\n                      const rocfft_precision        precision,\n                      const rocfft_array_type       itype,\n                      const rocfft_array_type       otype)\n{\n    auto procfft_setup = (decltype(&rocfft_setup))dlsym(libhandle, \"rocfft_setup\");\n    if(procfft_setup == NULL)\n        exit(1);\n    auto procfft_plan_description_create = (decltype(&rocfft_plan_description_create))dlsym(\n        libhandle, \"rocfft_plan_description_create\");\n    auto procfft_plan_description_destroy = (decltype(&rocfft_plan_description_destroy))dlsym(\n        libhandle, \"rocfft_plan_description_destroy\");\n    auto procfft_plan_description_set_data_layout\n        = (decltype(&rocfft_plan_description_set_data_layout))dlsym(\n            libhandle, \"rocfft_plan_description_set_data_layout\");\n    auto procfft_plan_create\n        = (decltype(&rocfft_plan_create))dlsym(libhandle, \"rocfft_plan_create\");\n    auto procfft_execute = (decltype(&rocfft_execute))dlsym(libhandle, \"rocfft_execute\");\n\n    procfft_setup();\n\n    rocfft_plan_description desc = NULL;\n    LIB_V_THROW(procfft_plan_description_create(&desc), \"rocfft_plan_description_create failed\");\n    LIB_V_THROW(procfft_plan_description_set_data_layout(desc,\n                                                         itype,\n                                                         otype,\n                                                         ioffset.data(),\n                                                         ooffset.data(),\n                                                         istride.size(),\n                                                         istride.data(),\n                                                         idist,\n                                                         ostride.size(),\n                                                         ostride.data(),\n                                                         odist),\n                \"rocfft_plan_description_data_layout failed\");\n    rocfft_plan plan = NULL;\n\n    procfft_plan_create(\n        &plan, place, transformType, precision, length.size(), length.data(), nbatch, desc);\n\n    LIB_V_THROW(procfft_plan_description_destroy(desc), \"rocfft_plan_description_destroy failed\");\n\n    return plan;\n}\n\n// Given a libhandle from dload and a rocFFT plan, destroy the plan.\nvoid destroy_plan(void* libhandle, rocfft_plan& plan)\n{\n    auto procfft_plan_destroy\n        = (decltype(&rocfft_plan_destroy))dlsym(libhandle, \"rocfft_plan_destroy\");\n    procfft_plan_destroy(plan);\n    auto procfft_cleanup = (decltype(&rocfft_cleanup))dlsym(libhandle, \"rocfft_cleanup\");\n    if(procfft_cleanup)\n        procfft_cleanup();\n}\n\n// Given a libhandle from dload and a rocFFT execution info structure, destroy the info.\nvoid destroy_info(void* libhandle, rocfft_execution_info& info)\n{\n    auto procfft_execution_info_destroy = (decltype(&rocfft_execution_info_destroy))dlsym(\n        libhandle, \"rocfft_execution_info_destroy\");\n    procfft_execution_info_destroy(info);\n}\n\n// Given a libhandle from dload, and a corresponding rocFFT plan, return how much work\n// buffer is required.\nsize_t get_wbuffersize(void* libhandle, const rocfft_plan& plan)\n{\n    auto procfft_plan_get_work_buffer_size = (decltype(&rocfft_plan_get_work_buffer_size))dlsym(\n        libhandle, \"rocfft_plan_get_work_buffer_size\");\n\n    // Get the buffersize\n    size_t workBufferSize = 0;\n    LIB_V_THROW(procfft_plan_get_work_buffer_size(plan, &workBufferSize),\n                \"rocfft_plan_get_work_buffer_size failed\");\n\n    return workBufferSize;\n}\n\n// Given a libhandle from dload and a corresponding rocFFT plan, print the plan information.\nvoid show_plan(void* libhandle, const rocfft_plan& plan)\n{\n    auto procfft_plan_get_print\n        = (decltype(&rocfft_plan_get_print))dlsym(libhandle, \"rocfft_plan_get_print\");\n\n    LIB_V_THROW(procfft_plan_get_print(plan), \"rocfft_plan_get_print failed\");\n}\n\n// Given a libhandle from dload and a corresponding rocFFT plan, a work buffer size and an\n// allocated work buffer, return a rocFFT execution info for the plan.\nrocfft_execution_info make_execinfo(void* libhandle, const size_t wbuffersize, void* wbuffer)\n{\n    auto procfft_execution_info_create\n        = (decltype(&rocfft_execution_info_create))dlsym(libhandle, \"rocfft_execution_info_create\");\n    auto procfft_execution_info_set_work_buffer\n        = (decltype(&rocfft_execution_info_set_work_buffer))dlsym(\n            libhandle, \"rocfft_execution_info_set_work_buffer\");\n\n    rocfft_execution_info info = NULL;\n    LIB_V_THROW(procfft_execution_info_create(&info), \"rocfft_execution_info_create failed\");\n    if(wbuffer != NULL)\n    {\n        LIB_V_THROW(procfft_execution_info_set_work_buffer(info, wbuffer, wbuffersize),\n                    \"rocfft_execution_info_set_work_buffer failed\");\n    }\n\n    return info;\n}\n\n// Given a libhandle from dload and a corresponding rocFFT plan and execution info,\n// execute a transform on the given input and output buffers and return the kernel\n// execution time.\nfloat run_plan(void* libhandle, rocfft_plan plan, rocfft_execution_info info, void** in, void** out)\n{\n    auto procfft_execute = (decltype(&rocfft_execute))dlsym(libhandle, \"rocfft_execute\");\n\n    hipEvent_t start, stop;\n    HIP_V_THROW(hipEventCreate(&start), \"hipEventCreate failed\");\n    HIP_V_THROW(hipEventCreate(&stop), \"hipEventCreate failed\");\n\n    HIP_V_THROW(hipEventRecord(start), \"hipEventRecord failed\");\n\n    procfft_execute(plan, in, out, info);\n\n    HIP_V_THROW(hipEventRecord(stop), \"hipEventRecord failed\");\n    HIP_V_THROW(hipEventSynchronize(stop), \"hipEventSynchronize failed\");\n\n    float time;\n    hipEventElapsedTime(&time, start, stop);\n    return time;\n}\n\nint main(int argc, char* argv[])\n{\n    // Control output verbosity:\n    int verbose;\n\n    // hip Device number for running tests:\n    int deviceId;\n\n    // Transform type parameters:\n    rocfft_transform_type transformType;\n    rocfft_array_type     itype;\n    rocfft_array_type     otype;\n\n    // Number of performance trial samples\n    int ntrial;\n\n    // Number of batches:\n    size_t nbatch;\n\n    // TODO: enable when enabled in rocFFT\n    // // Scale for transform\n    // double scale = 1.0;\n\n    // Transform length:\n    std::vector<size_t> length;\n\n    // Transform input and output strides:\n    std::vector<size_t> istride;\n    std::vector<size_t> ostride;\n\n    // Offset to start of buffer (or buffers, for planar format):\n    std::vector<size_t> ioffset;\n    std::vector<size_t> ooffset;\n\n    // Input and output distances:\n    size_t idist;\n    size_t odist;\n\n    // Vector of test target libraries\n    std::vector<std::string> libs;\n\n    // Declare the supported options.\n\n    // clang-format doesn't handle boost program options very well:\n    // clang-format off\n    po::options_description opdesc(\"rocfft rider command line options\");\n    opdesc.add_options()(\"help,h\", \"Produces this help message\")\n        (\"version,v\", \"Print queryable version information from the rocfft library\")\n        (\"device\", po::value<int>(&deviceId)->default_value(0), \"Select a specific device id\")\n        (\"verbose\", po::value<int>(&verbose)->default_value(0), \"Control output verbosity\")\n        (\"ntrial,N\", po::value<int>(&ntrial)->default_value(1), \"Trial size for the problem\")\n        (\"notInPlace,o\", \"Not in-place FFT transform (default: in-place)\")\n        (\"double\", \"Double precision transform (default: single)\")\n        (\"transformType,t\", po::value<rocfft_transform_type>(&transformType)\n         ->default_value(rocfft_transform_type_complex_forward),\n         \"Type of transform:\\n0) complex forward\\n1) complex inverse\\n2) real \"\n         \"forward\\n3) real inverse\")\n        ( \"idist\", po::value<size_t>(&idist)->default_value(0),\n          \"Input distance between successive members when batch size > 1\")\n        ( \"odist\", po::value<size_t>(&odist)->default_value(0),\n          \"Output distance between successive members when batch size > 1\")\n        // (\"scale\", po::value<double>(&scale)->default_value(1.0), \"Specify the scaling factor \")\n        ( \"batchSize,b\", po::value<size_t>(&nbatch)->default_value(1),\n          \"If this value is greater than one, arrays will be used \")\n        ( \"itype\", po::value<rocfft_array_type>(&itype)\n          ->default_value(rocfft_array_type_unset),\n          \"Array type of input data:\\n0) interleaved\\n1) planar\\n2) real\\n3) \"\n          \"hermitian interleaved\\n4) hermitian planar\")\n        ( \"otype\", po::value<rocfft_array_type>(&otype)\n          ->default_value(rocfft_array_type_unset),\n          \"Array type of output data:\\n0) interleaved\\n1) planar\\n2) real\\n3) \"\n          \"hermitian interleaved\\n4) hermitian planar\")\n        (\"lib\",  po::value<std::vector<std::string>>(&libs)->multitoken(),\n         \"Set test target library full path(appendable).\")\n        (\"length\",  po::value<std::vector<size_t>>(&length)->multitoken(), \"Lengths.\")\n        (\"istride\", po::value<std::vector<size_t>>(&istride)->multitoken(), \"Input strides.\")\n        (\"ostride\", po::value<std::vector<size_t>>(&ostride)->multitoken(), \"Output strides.\")\n        (\"ioffset\", po::value<std::vector<size_t>>(&ioffset)->multitoken(), \"Input offsets.\")\n        (\"ooffset\", po::value<std::vector<size_t>>(&ooffset)->multitoken(), \"Output offsets.\");\n    // clang-format on\n\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, opdesc), vm);\n    po::notify(vm);\n\n    if(vm.count(\"help\"))\n    {\n        std::cout << opdesc << std::endl;\n        return 0;\n    }\n\n    if(!vm.count(\"length\"))\n    {\n        std::cout << \"Please specify transform length!\" << std::endl;\n        std::cout << opdesc << std::endl;\n        return 0;\n    }\n\n    const rocfft_result_placement place\n        = vm.count(\"notInPlace\") ? rocfft_placement_notinplace : rocfft_placement_inplace;\n    const rocfft_precision precision\n        = vm.count(\"double\") ? rocfft_precision_double : rocfft_precision_single;\n\n    if(vm.count(\"notInPlace\"))\n    {\n        std::cout << \"out-of-place\\n\";\n    }\n    else\n    {\n        std::cout << \"in-place\\n\";\n    }\n\n    if(vm.count(\"ntrial\"))\n    {\n        std::cout << \"Running profile with \" << ntrial << \" samples\\n\";\n    }\n\n    if(vm.count(\"length\"))\n    {\n        std::cout << \"length:\";\n        for(auto& i : length)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n    }\n\n    if(vm.count(\"istride\"))\n    {\n        std::cout << \"istride:\";\n        for(auto& i : istride)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n    }\n    if(vm.count(\"ostride\"))\n    {\n        std::cout << \"ostride:\";\n        for(auto& i : ostride)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n    }\n\n    if(idist > 0)\n    {\n        std::cout << \"idist: \" << idist << \"\\n\";\n    }\n    if(odist > 0)\n    {\n        std::cout << \"odist: \" << odist << \"\\n\";\n    }\n\n    if(vm.count(\"ioffset\"))\n    {\n        std::cout << \"ioffset:\";\n        for(auto& i : ioffset)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n    }\n    if(vm.count(\"ooffset\"))\n    {\n        std::cout << \"ooffset:\";\n        for(auto& i : ooffset)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n    }\n\n    std::cout << std::flush;\n\n    // Fixme: set the device id properly after the IDs are synced\n    // bewteen hip runtime and rocm-smi.\n    // HIP_V_THROW(hipSetDevice(deviceId), \"set device failed!\");\n\n    // Set default data formats if not yet specified:\n    const size_t dim     = length.size();\n    auto         ilength = length;\n    if(transformType == rocfft_transform_type_real_inverse)\n    {\n        ilength[dim - 1] = ilength[dim - 1] / 2 + 1;\n    }\n    if(istride.size() == 0)\n    {\n        istride = compute_stride(ilength,\n                                 1,\n                                 place == rocfft_placement_inplace\n                                     && transformType == rocfft_transform_type_real_forward);\n    }\n    auto olength = length;\n    if(transformType == rocfft_transform_type_real_forward)\n    {\n        olength[dim - 1] = olength[dim - 1] / 2 + 1;\n    }\n    if(ostride.size() == 0)\n    {\n        ostride = compute_stride(olength,\n                                 1,\n                                 place == rocfft_placement_inplace\n                                     && transformType == rocfft_transform_type_real_inverse);\n    }\n    check_set_iotypes(place, transformType, itype, otype);\n    if(idist == 0)\n    {\n        idist = set_idist(place, transformType, length, istride);\n    }\n    if(odist == 0)\n    {\n        odist = set_odist(place, transformType, length, ostride);\n    }\n\n    if(verbose > 0)\n    {\n        std::cout << \"FFT  params:\\n\";\n        std::cout << \"\\tilength:\";\n        for(auto i : ilength)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n        std::cout << \"\\tistride:\";\n        for(auto i : istride)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n        std::cout << \"\\tidist: \" << idist << std::endl;\n\n        std::cout << \"\\tolength:\";\n        for(auto i : olength)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n        std::cout << \"\\tostride:\";\n        for(auto i : ostride)\n            std::cout << \" \" << i;\n        std::cout << \"\\n\";\n        std::cout << \"\\todist: \" << odist << std::endl;\n    }\n\n    std::vector<rocfft_plan> plan;\n\n    size_t wbuffer_size = 0;\n\n    // Set up shared object handles\n    std::vector<void*> handles;\n    for(int idx = 0; idx < libs.size(); ++idx)\n    {\n        void* libhandle = dlopen((libs[idx]).c_str(), RTLD_LAZY);\n        if(libhandle == NULL)\n        {\n            std::cout << \"Failed to open \" << libs[idx] << std::endl;\n            exit(1);\n        }\n        struct link_map* link = nullptr;\n        dlinfo(libhandle, RTLD_DI_LINKMAP, &link);\n        for(; link != nullptr; link = link->l_next)\n        {\n            if(strstr(link->l_name, \"librocfft-device\") != nullptr)\n            {\n                std::cerr << \"Error: Library \" << libs[idx] << \" depends on librocfft-device.\\n\";\n                std::cerr << \"All libraries need to be built with -DSINGLELIB=on.\\n\";\n                exit(1);\n            }\n        }\n        handles.push_back(libhandle);\n    }\n\n    // Set up plans:\n    for(int idx = 0; idx < libs.size(); ++idx)\n    {\n        // Create column-major parameters for rocFFT:\n        auto length_cm  = length;\n        auto istride_cm = istride;\n        auto ostride_cm = ostride;\n        for(int idx = 0; idx < dim / 2; ++idx)\n        {\n            const auto toidx = dim - idx - 1;\n            std::swap(istride_cm[idx], istride_cm[toidx]);\n            std::swap(ostride_cm[idx], ostride_cm[toidx]);\n            std::swap(length_cm[idx], length_cm[toidx]);\n        }\n\n        std::cout << idx << \": \" << libs[idx] << std::endl;\n        plan.push_back(make_plan(handles[idx],\n                                 place,\n                                 transformType,\n                                 length_cm,\n                                 istride_cm,\n                                 ostride_cm,\n                                 idist,\n                                 odist,\n                                 ioffset,\n                                 ooffset,\n                                 nbatch,\n                                 precision,\n                                 itype,\n                                 otype));\n        show_plan(handles[idx], plan[idx]);\n        wbuffer_size = std::max(wbuffer_size, get_wbuffersize(handles[idx], plan[idx]));\n    }\n\n    std::cout << \"Work buffer size: \" << wbuffer_size << std::endl;\n\n    // Allocate the work buffer: just one, big enough for any dloaded library.\n    void* wbuffer = NULL;\n    if(wbuffer_size)\n    {\n        HIP_V_THROW(hipMalloc(&wbuffer, wbuffer_size), \"Creating intermediate Buffer failed\");\n    }\n\n    // Associate the work buffer to the invidual libraries:\n    std::vector<rocfft_execution_info> info;\n    for(int idx = 0; idx < libs.size(); ++idx)\n    {\n        info.push_back(make_execinfo(handles[idx], wbuffer_size, wbuffer));\n    }\n\n    // Input data:\n    const auto input = compute_input(precision, itype, length, istride, idist, nbatch);\n\n    if(verbose > 1)\n    {\n        std::cout << \"GPU input:\\n\";\n        printbuffer(precision, itype, input, ilength, istride, nbatch, idist);\n    }\n\n    // GPU input and output buffers:\n    auto               ibuffer_sizes = buffer_sizes(precision, itype, idist, nbatch);\n    std::vector<void*> ibuffer(ibuffer_sizes.size());\n    for(unsigned int i = 0; i < ibuffer.size(); ++i)\n    {\n        HIP_V_THROW(hipMalloc(&ibuffer[i], ibuffer_sizes[i]), \"Creating input Buffer failed\");\n    }\n\n    std::vector<void*> obuffer;\n    if(place == rocfft_placement_inplace)\n    {\n        obuffer = ibuffer;\n    }\n    else\n    {\n        auto obuffer_sizes = buffer_sizes(precision, otype, odist, nbatch);\n        obuffer.resize(obuffer_sizes.size());\n        for(unsigned int i = 0; i < obuffer.size(); ++i)\n        {\n            HIP_V_THROW(hipMalloc(&obuffer[i], obuffer_sizes[i]), \"Creating output Buffer failed\");\n        }\n    }\n\n    if(handles.size())\n    {\n        // Run a kernel once to load the instructions on the GPU:\n\n        // Copy the input data to the GPU:\n        for(int idx = 0; idx < input.size(); ++idx)\n        {\n            HIP_V_THROW(\n                hipMemcpy(ibuffer[0], input[0].data(), input[0].size(), hipMemcpyHostToDevice),\n                \"hipMemcpy failed\");\n        }\n        // Run the plan using its associated rocFFT library:\n        for(int idx = 0; idx < handles.size(); ++idx)\n        {\n            run_plan(handles[idx], plan[idx], info[idx], ibuffer.data(), obuffer.data());\n        }\n    }\n\n    // Execution times for loaded libraries:\n    std::vector<std::vector<double>> time(libs.size());\n\n    // Run the FFTs from the different libraries in random order until they all have at\n    // least ntrial times.\n    std::vector<int> ndone(libs.size());\n    std::fill(ndone.begin(), ndone.end(), 0);\n    while(!std::all_of(ndone.begin(), ndone.end(), [&ntrial](int i) { return i >= ntrial; }))\n    {\n        const int idx = rand() % ndone.size();\n        ndone[idx]++;\n\n        // We can optionally require that all runs have exactly ntrial, but it may be more\n        // iid to just let things run:\n        // if(ndone[idx] > ntrial)\n        //     continue;\n\n        // Copy the input data to the GPU:\n        for(int idx = 0; idx < input.size(); ++idx)\n        {\n            HIP_V_THROW(\n                hipMemcpy(\n                    ibuffer[idx], input[idx].data(), input[idx].size(), hipMemcpyHostToDevice),\n                \"hipMemcpy failed\");\n        }\n\n        // Run the plan using its associated rocFFT library:\n        time[idx].push_back(\n            run_plan(handles[idx], plan[idx], info[idx], ibuffer.data(), obuffer.data()));\n\n        if(verbose > 2)\n        {\n            auto output = allocate_host_buffer(precision, otype, olength, ostride, odist, nbatch);\n            for(int idx = 0; idx < output.size(); ++idx)\n            {\n                hipMemcpy(\n                    output[idx].data(), obuffer[idx], output[idx].size(), hipMemcpyDeviceToHost);\n            }\n            std::cout << \"GPU output:\\n\";\n            printbuffer(precision, otype, output, olength, ostride, nbatch, odist);\n        }\n    }\n\n    std::cout << \"Execution times in ms:\\n\";\n    for(int idx = 0; idx < time.size(); ++idx)\n    {\n        std::cout << \"\\nExecution gpu time:\";\n        for(auto& i : time[idx])\n        {\n            std::cout << \" \" << i;\n        }\n        std::cout << \" ms\" << std::endl;\n    }\n\n    // Clean up:\n    for(int idx = 0; idx < handles.size(); ++idx)\n    {\n        destroy_info(handles[idx], info[idx]);\n        destroy_plan(handles[idx], plan[idx]);\n        dlclose(handles[idx]);\n    }\n    hipFree(wbuffer);\n    for(auto& buf : ibuffer)\n        hipFree(buf);\n    for(auto& buf : obuffer)\n        hipFree(buf);\n\n    return 0;\n}"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/rocm.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_fwdinv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_ex_n7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_02.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_06.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_ex_n8.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_1dlen.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_04.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_05.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_07.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_08.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_01.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocfft-3.8.0-rp55fu3zmeki3tfh3itr5cdz5tj6fztd/spack-src/docs/source/images/realfft_expl_03.jpg"
    ],
    "total_files": 183
}