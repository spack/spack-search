{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dotconf-1.3-dy67mklmecnudas5qmdokgzlxyjx3el3/spack-src/examples/duplicates/duplicate.c": "\n/* You need at least dot.conf 1.0.9 to compile and run this example !! */\n\n#include <stdio.h>\t\t/* fprintf(), stderr       */\n#include <stdlib.h>\t\t/* realloc()               */\n#include <string.h>\t\t/* strcmp()                */\n/* this example does not work for WIN32 */\n\n#ifndef WIN32\n#include <dlfcn.h>\t\t/* dlopen(), dlerror(), dlclose() */\n#include <unistd.h>\n#endif\n\n#include <libpool.h>\n#include <dotconf.h>\n\nstruct config_context {\n\tlong current_context;\n\tchar current_end_token[1024];\n\n\tpool_t *pool;\n};\n\nstruct ptr_list {\n\tint n_entries;\n\tvoid **entries;\n};\n\nstatic DOTCONF_CB(section_open);\nstatic DOTCONF_CB(section_close);\nstatic DOTCONF_CB(common_option);\nstatic DOTCONF_CB(addmodule_option);\n\n/*\n// the last field is used to specify the context needed for\n// each option. These will be checked at runtime by our contextchecker\n//\n*/\nstatic const configoption_t options[] = {\n\t{\"AddModule\", ARG_LIST, addmodule_option, NULL, 0},\n\t{\"ToggleOption\", ARG_TOGGLE, common_option, NULL, 0},\n\tLAST_OPTION\n};\n\n/*\n// The pointer list of dynamic options.\n// This is necessary to be able to free it up later.\n//\n*/\nstruct ptr_list memory_junk;\n\n#define MAX_MODULES       10\nstatic void *handles[MAX_MODULES];\t/* handles of dynamically loaded modules */\n\nconst char *context_checker(command_t * cmd, unsigned long option_context)\n{\n\tstruct config_context *context = cmd->context;\n\n\tif (context->current_context != option_context) {\n\t\treturn pool_strcat(context->pool, \"Option '\", cmd->name,\n\t\t\t\t   \"' not allowed in <\",\n\t\t\t\t   (strlen(context->current_end_token) >\n\t\t\t\t    2) ? context->current_end_token +\n\t\t\t\t   2 : \"global>\", \" context\", NULL);\n\t}\n\n\treturn NULL;\n}\n\nFUNC_ERRORHANDLER(error_handler)\n{\n\tfprintf(stderr, \"%s:%ld:[error] %s\\n\",\n\t\tconfigfile->filename, configfile->line, msg);\n\n\t/* continue reading the configfile ; return 1 stop after first error found */\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tconfigfile_t *configfile;\n\tstruct config_context context;\n\n\tif (argc < 2) {\n\t\tfprintf(stderr, \"Usage : %s <configfile>\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\tcontext.current_end_token[0] = '\\0';\n\tcontext.current_context = 0;\n\tcontext.pool = pool_new(NULL);\n\n\tmemory_junk.n_entries = 0;\n\tmemory_junk.entries = 0;\n\n\tmemset(handles, 0, sizeof(handles));\n\n\tconfigfile = dotconf_create(argv[1], options, (void *)&context,\n\t\t\t\t    CASE_INSENSITIVE | DUPLICATE_OPTION_NAMES);\n\tif (!configfile) {\n\t\tfprintf(stderr, \"Error opening configuration file\\n\");\n\t\treturn 1;\n\t}\n\tconfigfile->errorhandler = (dotconf_errorhandler_t) error_handler;\n\tconfigfile->contextchecker = (dotconf_contextchecker_t) context_checker;\n\n\tif (dotconf_command_loop(configfile) == 0) {\n\t\tfprintf(stderr, \"Error reading configuration file\\n\");\n\t\treturn 1;\n\t}\n\n\tdotconf_cleanup(configfile);\n\tpool_free(context.pool);\n\n\t/* clean up the possible memjunk which needed to stay in memory */\n\tif (memory_junk.n_entries) {\n\t\tint idx;\n\t\tfor (idx = 0; idx < memory_junk.n_entries; idx++) {\n\t\t\tfree(memory_junk.entries[idx]);\n\t\t}\n\t}\n\tfree(memory_junk.entries);\n\n\treturn 0;\n}\n\nDOTCONF_CB(section_open)\n{\n\tstruct config_context *context = (struct config_context *)ctx;\n\tconst char *old_end_token = context->current_end_token;\n\tint prev_context = context->current_context;\n\tconst char *err = 0;\n\n\tcontext->current_context = (long)cmd->option->info;\n\tsprintf(context->current_end_token, \"</%s\", cmd->name + 1);\n\n\twhile (!cmd->configfile->eof) {\n\t\terr = dotconf_command_loop_until_error(cmd->configfile);\n\t\tif (!err) {\n\t\t\terr =\n\t\t\t    pool_strcat(context->pool, \"</\", cmd->name + 1,\n\t\t\t\t\t\" is missing\", NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err == context->current_end_token) {\n\t\t\tbreak;\n\t\t}\n\t\tdotconf_warning(cmd->configfile, DCLOG_ERR, 0, err);\n\t}\n\n\tsprintf(context->current_end_token, \"%s\", old_end_token);\n\tcontext->current_context = prev_context;\n\n\tif (err != context->current_end_token) {\n\t\treturn err;\n\t}\n\n\treturn NULL;\n}\n\nDOTCONF_CB(section_close)\n{\n\tstruct config_context *context = (struct config_context *)ctx;\n\n\tif (!context->current_end_token) {\n\t\treturn pool_strcat(context->pool, cmd->name,\n\t\t\t\t   \" without matching <\", cmd->name + 2,\n\t\t\t\t   \" section\", NULL);\n\t}\n\n\tif (strcmp(context->current_end_token, cmd->name) != 0) {\n\t\treturn pool_strcat(context->pool, \"Expected '\",\n\t\t\t\t   context->current_end_token, \"' but saw \",\n\t\t\t\t   cmd->name, NULL);\n\t}\n\n\treturn context->current_end_token;\n}\n\nDOTCONF_CB(common_option)\n{\n\tfprintf(stderr,\n\t\t\"common_option : Option %s called  Not doing anything with it...\\n\",\n\t\tcmd->name);\n\treturn NULL;\n}\n\n/*\n// We expect  option     name  filename\n//      e.g.  AddModule first ./plugins/decision-test.so\n//\n// So in the list :\n//  0 -> name\n//  1 -> so_filename\n*/\nDOTCONF_CB(addmodule_option)\n{\n\tstruct config_context *context = (struct config_context *)ctx;\n\tconfigoption_t *module_options;\n\tconst char *error = 0;\n\tint handle_idx = -1;\n\tchar filename[FILENAME_MAX] = \"\";\n\tvoid *shared_object = 0;\n\n\tfprintf(stderr, \"addmodule_option : Option %s called\\n\", cmd->name);\n\tif (cmd->arg_count < 2) {\n\t\treturn pool_strcat(context->pool,\n\t\t\t\t   \"Not enough parameters to option \",\n\t\t\t\t   cmd->name, \" expected 2\", NULL);\n\t}\n\t// load the damn thing\n\tfor (handle_idx = 0; handle_idx < MAX_MODULES; handle_idx++) {\n\t\tif (handles[handle_idx] == 0) {\n\t\t\tsnprintf(filename, 128, \"./%s.so\", cmd->data.list[1]);\n\t\t\tif (access(filename, R_OK) == 0) {\t/* if file access is permitted */\n\t\t\t\t/* load library */\n\t\t\t\thandles[handle_idx] =\n\t\t\t\t    dlopen(filename, RTLD_LAZY);\n\t\t\t\tif (!handles[handle_idx]) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"Error opening library: %s\\n\",\n\t\t\t\t\t\tdlerror());\n\t\t\t\t\treturn \"Error opening library\";\n\t\t\t\t}\n\t\t\t\tshared_object = handles[handle_idx];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\treturn pool_strcat(context->pool,\n\t\t\t\t\t\t   \"Can't open file \", filename,\n\t\t\t\t\t\t   NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (handle_idx == MAX_MODULES) {\n\t\treturn \"Out of handle space. Not loading module\\n\";\n\t}\n\t// get the options\n\tmodule_options = dlsym(shared_object, \"options\");\n\terror = dlerror();\n\tif (error) {\n\t\tfprintf(stderr,\n\t\t\t\"addmodule_option() : Error finding the options variable in %s p=%p (%s)\\n\",\n\t\t\tcmd->data.list[1], shared_object, error);\n\t\tdlclose(shared_object);\n\t\thandles[handle_idx] = 0;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t   // Scope the options of this module to a <NAME></NAME> block where NAME is\n\t   // the name that was specified in the configfile.\n\t   //\n\t   // The context field holds a unique identifier so we can verify in our\n\t   // contextchecker that this option belongs to the right scope.\n\t   //\n\t */\n\t{\n\t\tchar *begin_context_tag =\n\t\t    (char *)malloc(strlen(cmd->data.list[1]) + 2 + 1);\n\t\tchar *end_context_tag =\n\t\t    (char *)malloc(strlen(cmd->data.list[1]) + 3 + 1);\n\t\tconfigoption_t *scope_options = 0;\n\t\tint opt_idx = -1;\n\n\t\tscope_options =\n\t\t    (configoption_t *) malloc(3 * sizeof(configoption_t));\n\t\tif (!scope_options || !begin_context_tag || !end_context_tag) {\n\t\t\treturn \"Error allocating memory\";\n\t\t}\n\t\tsprintf(begin_context_tag, \"<%s>\", cmd->data.list[0]);\n\t\tsprintf(end_context_tag, \"</%s>\", cmd->data.list[0]);\n\n\t\t// create our two extra options (scope begin/end) and a NULL option to close\n\t\t// the list\n\t\tscope_options[0].name = begin_context_tag;\n\t\tscope_options[0].type = ARG_NONE;\n\t\tscope_options[0].callback = section_open;\n\t\tscope_options[0].info = shared_object;\n\t\tscope_options[0].context = CTX_ALL;\n\n\t\tscope_options[1].name = end_context_tag;\n\t\tscope_options[1].type = ARG_NONE;\n\t\tscope_options[1].callback = section_close;\n\t\tscope_options[1].info = NULL;\n\t\tscope_options[1].context = (long)shared_object;\n\n\t\tscope_options[2].name = \"\";\n\t\tscope_options[2].type = 0;\n\t\tscope_options[2].callback = NULL;\n\t\tscope_options[2].info = NULL;\n\t\tscope_options[2].context = 0;\n\n\t\t/* Set the context field of all options from the module to the identifier */\n\t\tfor (opt_idx = 0; strlen(module_options[opt_idx].name);\n\t\t     opt_idx++) {\n\t\t\tmodule_options[opt_idx].context = (long)shared_object;\n\t\t}\n\n\t\tmemory_junk.entries = realloc(memory_junk.entries,\n\t\t\t\t\t      (memory_junk.n_entries +\n\t\t\t\t\t       3) * sizeof(void *));\n\t\tmemory_junk.entries[memory_junk.n_entries++] =\n\t\t    begin_context_tag;\n\t\tmemory_junk.entries[memory_junk.n_entries++] = end_context_tag;\n\t\tmemory_junk.entries[memory_junk.n_entries++] = scope_options;\n\n\t\tdotconf_register_options(cmd->configfile, scope_options);\n\t\tdotconf_register_options(cmd->configfile, module_options);\n\t}\n\n\tfprintf(stderr, \"Successfully loaded module %s (%s)\\n\",\n\t\tcmd->data.list[1], cmd->data.list[1]);\n\n\treturn NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dotconf-1.3-dy67mklmecnudas5qmdokgzlxyjx3el3/spack-src/examples/modules/module.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* this example does not work for WIN32 */\n\n#ifndef WIN32\n#include <dlfcn.h>\t\t/* for dlopen(), dlerror(), dlclose() */\n#include <unistd.h>\n#endif\n\n#include <dotconf.h>\n\n/* define our callbacks; */\n/* for definition of DOTCONF_CB see dotconf.h */\n\nstatic DOTCONF_CB(cb_example);\nstatic DOTCONF_CB(cb_moreargs);\nstatic DOTCONF_CB(cb_addmodule);\nstatic DOTCONF_CB(cb_multiline);\t/* here document test */\nstatic DOTCONF_CB(cb_unknown);\t/* fallback for unknwon options */\n\n/* define the Option ExampleOption that expects a string\n * and tell the parser to call the function cb_example\n */\nstatic const configoption_t options[] = {\n\t{\"ExampleOption\", ARG_STR, cb_example, 0, 0},\n\t{\"MoreArgs\", ARG_LIST, cb_moreargs, 0, 0},\n\t{\"AddModule\", ARG_STR, cb_addmodule, 0, 0},\n\t{\"MultiLineRaw\", ARG_STR, cb_multiline, 0, 0},\n\t{\"\", ARG_NAME, cb_unknown, 0, 0},\n\tLAST_OPTION\n};\n\n#define NUM_MODULES 10\nstatic void *handles[NUM_MODULES];\t/* handles of dynamically loaded modules */\n\nint main(int argc, char **argv)\n{\n\tint i;\n\tconfigfile_t *configfile;\n\n\tmemset(handles, 0, sizeof(handles));\n\tputenv(\"TESTUSER=lukas\");\n\n\t/*\n\t * start reading config, CASE_INSENSITIVE (specify NONE or 0 for the\n\t * the default behaviour which matches case sensitive\n\t */\n\tconfigfile = dotconf_create(argv[1] ? argv[1] : \"sample.conf\",\n\t\t\t\t    options, 0, CASE_INSENSITIVE);\n\tif (!configfile) {\n\t\tfprintf(stderr, \"Error opening config file\\n\");\n\t\treturn 1;\n\t}\n\n\tif (dotconf_command_loop(configfile) == 0)\n\t\tfprintf(stderr, \"Error reading config file\\n\");\n\n\tdotconf_cleanup(configfile);\n\n\tfor (i = 0; i < NUM_MODULES && handles[i]; i++)\n\t\tdlclose(handles[i]);\n\n\treturn 0;\n}\n\n/* the error-handler; a new feature of v0.7.0 to filter out messages\n   issued using config_warning\nFUNC_ERRORHANDLER(my_errorhandler)\n{\n  printf(\"ERROR [type=%d][%d] %s\\n\", type, dc_errno, msg);\n}\n*/\n\n/* declare our callback function */\nDOTCONF_CB(cb_example)\n{\n\tprintf(\"%s:%ld: ExampleOption: [arg=%s]\\n\", cmd->configfile->filename,\n\t       cmd->configfile->line, cmd->data.str);\n\treturn NULL;\n}\n\n/*\n * we dont need the userdata, so dont mention it\n * otherwise we should've appended it as argument 3\n */\nDOTCONF_CB(cb_moreargs)\n{\n\tint i;\n\tfor (i = 0; i < cmd->arg_count; i++)\n\t\tprintf(\"%s:%ld: [MoreArgs] Arg #%d '%s'\\n\",\n\t\t       cmd->configfile->filename, cmd->configfile->line, i + 1,\n\t\t       cmd->data.list[i]);\n\treturn 0;\n}\n\nDOTCONF_CB(cb_addmodule)\n{\n\tint i;\n\tchar filename[128];\t/* filename of modules */\n\n\tfor (i = 0; (i < NUM_MODULES) && (handles[i] != 0); i++) ;\n\n\tsnprintf(filename, 128, \"./%s.so\", cmd->data.str);\n\n\tif (!access(filename, R_OK)) {\t/* if file access is permitted */\n\t\t/* load library */\n\t\thandles[i] = dlopen(filename, RTLD_LAZY);\n\t\tif (!handles[i])\n\t\t\tprintf(\"Error opening library: %s\\n\", dlerror());\n\t\tdotconf_register_options(cmd->configfile,\n\t\t\t\t\t dlsym(handles[i], \"new_options\"));\n\t}\n\tprintf(\"Module %s successfully loaded\\n\", cmd->data.str);\n\treturn NULL;\n}\n\nDOTCONF_CB(cb_multiline)\n{\n\tprintf(\"%s:%ld: [MultiLine - START] -%s- [MultiLine - END]\\n\",\n\t       cmd->configfile->filename, cmd->configfile->line, cmd->data.str);\n\treturn NULL;\n}\n\nDOTCONF_CB(cb_unknown)\n{\n\tint i = 0;\n\n\tprintf(\"%s:%ld: UNKNOWN [%s]\",\n\t       cmd->configfile->filename, cmd->configfile->line, cmd->name);\n\n\tfor (i = 0; cmd->data.list[i]; i++)\n\t\tprintf(\", %s\", cmd->data.list[i]);\n\tprintf(\"\\n\");\n\treturn NULL;\n}\n"
    },
    "skipped": [],
    "total_files": 42
}