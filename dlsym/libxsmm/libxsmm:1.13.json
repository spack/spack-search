{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/src/libxsmm_gemm.h": "/******************************************************************************\n** Copyright (c) 2015-2019, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Hans Pabst (Intel Corp.)\n******************************************************************************/\n#ifndef LIBXSMM_GEMM_H\n#define LIBXSMM_GEMM_H\n\n#include \"libxsmm_main.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#if !defined(LIBXSMM_BLAS_WRAP_DYNAMIC) && defined(LIBXSMM_BUILD) && \\\n  (!defined(__BLAS) || (0 != __BLAS)) && (defined(__GNUC__) || defined(_CRAYC)) && \\\n  !(defined(__APPLE__) && defined(__MACH__) && LIBXSMM_VERSION3(6, 1, 0) >= \\\n    LIBXSMM_VERSION3(__clang_major__, __clang_minor__, __clang_patchlevel__)) && \\\n  !defined(_WIN32) && !defined(__CYGWIN__)\n# define LIBXSMM_BLAS_WRAP_DYNAMIC\n#endif\n#if defined(LIBXSMM_BLAS_WRAP_DYNAMIC)\n# include <dlfcn.h>\n#endif\n#include <limits.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\n#if !defined(LIBXSMM_GEMM_CHECK) && !defined(NDEBUG)\n# define LIBXSMM_GEMM_CHECK\n#endif\n#if !defined(LIBXSMM_GEMM_LOCK)\n# define LIBXSMM_GEMM_LOCK LIBXSMM_LOCK_DEFAULT\n#endif\n#if !defined(LIBXSMM_GEMM_TASKSCALE)\n# define LIBXSMM_GEMM_TASKSCALE 2\n#endif\n#if !defined(LIBXSMM_GEMM_MMBATCH_SCALE)\n# define LIBXSMM_GEMM_MMBATCH_SCALE 1.5\n#endif\n#if !defined(LIBXSMM_GEMM_MMBATCH_VERBOSITY)\n# define LIBXSMM_GEMM_MMBATCH_VERBOSITY ((LIBXSMM_VERBOSITY_HIGH) + 1)\n#endif\n#if !defined(LIBXSMM_GEMM_NPARGROUPS)\n# define LIBXSMM_GEMM_NPARGROUPS 128\n#endif\n\n#if !defined(LIBXSMM_WRAP) && defined(LIBXSMM_BUILD) && \\\n    (defined(LIBXSMM_CONFIG_WRAP) && 0 != (LIBXSMM_CONFIG_WRAP)) && \\\n    (defined(LIBXSMM_BLAS_WRAP_DYNAMIC) || !defined(NDEBUG) || defined(_WIN32)) /* debug */\n# define LIBXSMM_WRAP LIBXSMM_CONFIG_WRAP\n#endif\n\n/** Undefine (disarm) MKL's DIRECT_CALL macros. */\n#if (defined(MKL_DIRECT_CALL_SEQ) || defined(MKL_DIRECT_CALL))\n# if defined(sgemm_)\n#   undef sgemm_\n# endif\n# if defined(dgemm_)\n#   undef dgemm_\n# endif\n#endif\n\n#if defined(LIBXSMM_BUILD)\n# define LIBXSMM_BLAS_WRAPPER_STATIC(TYPE, KIND, ORIGINAL) if (NULL == (ORIGINAL)) { \\\n    ORIGINAL = LIBXSMM_FSYMBOL(LIBXSMM_CONCATENATE(__real_, LIBXSMM_TPREFIX(TYPE, KIND))); \\\n  }\n#elif (!defined(__BLAS) || (0 != __BLAS))\n# define LIBXSMM_BLAS_WRAPPER_STATIC(TYPE, KIND, ORIGINAL) if (NULL == (ORIGINAL)) { \\\n    ORIGINAL = LIBXSMM_BLAS_SYMBOL(TYPE, KIND); \\\n  }\n#else\n# define LIBXSMM_BLAS_WRAPPER_STATIC(TYPE, KIND, ORIGINAL)\n#endif\n\n#if defined(LIBXSMM_BLAS_WRAP_DYNAMIC)\n# define LIBXSMM_BLAS_WRAPPER_DYNAMIC(TYPE, KIND, ORIGINAL, NEXT) { \\\n    union { const void* pfin; \\\n      LIBXSMM_BLAS_FNTYPE(TYPE, KIND) (*chain)(void); /* chain */ \\\n      LIBXSMM_BLAS_FNTYPE(TYPE, KIND) pfout; \\\n    } libxsmm_blas_wrapper_dynamic_ /*= { 0 }*/; \\\n    dlerror(); /* clear an eventual error status */ \\\n    libxsmm_blas_wrapper_dynamic_.chain = NEXT; \\\n    libxsmm_blas_wrapper_dynamic_.pfin = ((NULL == libxsmm_blas_wrapper_dynamic_.pfin) ? \\\n      dlsym(RTLD_NEXT, \"libxsmm_original_\" LIBXSMM_STRINGIFY(LIBXSMM_TPREFIX(TYPE, KIND))) : NULL); \\\n    if (NULL == libxsmm_blas_wrapper_dynamic_.pfout || NULL != dlerror() || NULL == libxsmm_blas_wrapper_dynamic_.chain()) { \\\n      libxsmm_blas_wrapper_dynamic_.pfin = dlsym(RTLD_NEXT, LIBXSMM_STRINGIFY(LIBXSMM_BLAS_SYMBOL(TYPE, KIND))); \\\n      /*LIBXSMM_ATOMIC_STORE(&(ORIGINAL), libxsmm_blas_wrapper_dynamic_.pfout, LIBXSMM_ATOMIC_RELAXED);*/ \\\n      ORIGINAL = (NULL == dlerror() ? libxsmm_blas_wrapper_dynamic_.pfout : NULL); \\\n    } \\\n  }\n#else\n# define LIBXSMM_BLAS_WRAPPER_DYNAMIC(TYPE, KIND, ORIGINAL, NEXT)\n#endif\n\n#define LIBXSMM_BLAS_WRAPPER(TYPE, KIND, ORIGINAL, NEXT) if (NULL == (ORIGINAL)) { \\\n  LIBXSMM_BLAS_WRAPPER_DYNAMIC(TYPE, KIND, ORIGINAL, NEXT); \\\n  LIBXSMM_BLAS_WRAPPER_STATIC(TYPE, KIND, ORIGINAL); \\\n}\n\n\n/** Provides GEMM functions available via BLAS; NOT thread-safe. */\nLIBXSMM_API_INTERN void libxsmm_gemm_init(int archid);\n\n/** Finalizes the GEMM facility; NOT thread-safe. */\nLIBXSMM_API_INTERN void libxsmm_gemm_finalize(void);\n\nLIBXSMM_API_INTERN int libxsmm_gemm_prefetch2uid(libxsmm_gemm_prefetch_type prefetch);\nLIBXSMM_API_INTERN libxsmm_gemm_prefetch_type libxsmm_gemm_uid2prefetch(int uid);\n\n#if defined(LIBXSMM_BUILD)\n#if defined(LIBXSMM_BUILD_EXT)\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_dgemm_batch)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm_batch));\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_sgemm_batch)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm_batch));\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_dgemm)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm));\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_sgemm)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm));\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_dgemv)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemv));\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_sgemv)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemv));\nLIBXSMM_APIEXT void __wrap_dgemm_batch(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm_batch));\nLIBXSMM_APIEXT void __wrap_sgemm_batch(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm_batch));\n#endif\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_dgemm_batch)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm_batch));\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_sgemm_batch)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm_batch));\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_dgemm)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm));\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_sgemm)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm));\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_dgemv)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemv));\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_sgemv)(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemv));\nLIBXSMM_API void __real_dgemm_batch(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, double, gemm_batch));\nLIBXSMM_API void __real_sgemm_batch(LIBXSMM_BLAS_SYMBOL_SIGNATURE(const*, *, float, gemm_batch));\n#endif\n\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, double, gemm_batch);\nLIBXSMM_BLAS_SYMBOL_CDECL(const*, *, double, gemm_batch);\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, float, gemm_batch);\nLIBXSMM_BLAS_SYMBOL_CDECL(const*, *, float, gemm_batch);\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, double, gemm);\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, float, gemm);\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, double, gemv);\nLIBXSMM_BLAS_SYMBOL_FDECL(const*, *, float, gemv);\n\nLIBXSMM_EXTERN_C struct LIBXSMM_RETARGETABLE libxsmm_gemm_handle {\n  libxsmm_code_pointer copy_a, copy_b, copy_i, copy_o;\n  libxsmm_xmmfunction kernel[2];\n  unsigned int m, n, k, lda, ldb, ldc;\n  /* kernel size (tile) */\n  unsigned int km, kn, kk;\n  /* tile size per task */\n  unsigned int dm, dn, dk;\n  unsigned int itypesize, otypesize;\n  /* number of tasks per direction */\n  unsigned int mt, nt, kt;\n  int gemm_flags, flags;\n};\n\nLIBXSMM_EXTERN_C typedef union LIBXSMM_RETARGETABLE libxsmm_mmbatch_item {\n  struct {\n    const void *a, *b;\n    void *c;\n  } value;\n  struct {\n    libxsmm_gemm_descriptor desc;\n    unsigned int count;\n    const char* symbol;\n  } stat;\n  /* TODO: consider padding */\n} libxsmm_mmbatch_item;\n\nLIBXSMM_API void libxsmm_gemm_internal_set_batchflag(libxsmm_gemm_descriptor* descriptor, void* c, libxsmm_blasint index_stride,\n  libxsmm_blasint batchsize, int multithreaded);\n\nLIBXSMM_API int libxsmm_mmbatch_kernel(libxsmm_xmmfunction kernel, libxsmm_blasint index_base,\n  libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  const void* a, const void* b, void* c, libxsmm_blasint batchsize, /*unsigned*/int tid, /*unsigned*/int ntasks,\n  unsigned char itypesize, unsigned char otypesize, int flags);\n\nLIBXSMM_API int libxsmm_mmbatch_blas(\n  libxsmm_gemm_precision iprec, libxsmm_gemm_precision oprec, const char* transa, const char* transb, libxsmm_blasint m, libxsmm_blasint n, libxsmm_blasint k,\n  const void* alpha, const void* a, const libxsmm_blasint* lda, const void* b, const libxsmm_blasint* ldb, const void* beta, void* c, const libxsmm_blasint* ldc,\n  libxsmm_blasint index_base, libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  libxsmm_blasint batchsize);\n\nLIBXSMM_API_INTERN void libxsmm_dmmbatch_blas(const char* transa, const char* transb, libxsmm_blasint m, libxsmm_blasint n, libxsmm_blasint k,\n  const double* alpha, const void* a, const libxsmm_blasint* lda, const void* b, const libxsmm_blasint* ldb, const double* beta, void* c, const libxsmm_blasint* ldc,\n  libxsmm_blasint index_base, libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  libxsmm_blasint batchsize);\n\nLIBXSMM_API_INTERN void libxsmm_smmbatch_blas(const char* transa, const char* transb, libxsmm_blasint m, libxsmm_blasint n, libxsmm_blasint k,\n  const float* alpha, const void* a, const libxsmm_blasint* lda, const void* b, const libxsmm_blasint* ldb, const float* beta, void* c, const libxsmm_blasint* ldc,\n  libxsmm_blasint index_base, libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  libxsmm_blasint batchsize);\n\nLIBXSMM_EXTERN_C typedef void (*libxsmm_mmbatch_flush_function)(void);\n\n/** auto-batch descriptor (filter). */\nLIBXSMM_APIVAR_ALIGNED(libxsmm_gemm_descriptor libxsmm_mmbatch_desc);\n/** Records a batch of SMMs or is used for batch-reduce. */\nLIBXSMM_APIVAR_ALIGNED(void* libxsmm_mmbatch_array);\n/** Lock: libxsmm_mmbatch_begin, libxsmm_mmbatch_end, internal_mmbatch_flush. */\nLIBXSMM_APIVAR_ALIGNED(LIBXSMM_LOCK_TYPE(LIBXSMM_GEMM_LOCK) libxsmm_mmbatch_lock);\n/** Maximum size of the recorded batch. */\nLIBXSMM_APIVAR_ALIGNED(unsigned int libxsmm_mmbatch_size);\n/** Maximum number of parallelized batch-groups. */\nLIBXSMM_APIVAR_ALIGNED(unsigned int libxsmm_gemm_npargroups);\n/** Minimum batchsize per thread/task. */\nLIBXSMM_APIVAR_ALIGNED(unsigned int libxsmm_gemm_taskgrain);\n/** Determines if OpenMP tasks are used, and scales beyond the number of threads. */\nLIBXSMM_APIVAR_ALIGNED(int libxsmm_gemm_taskscale);\n\n/** Determines the default prefetch strategy, which is used in case of LIBXSMM_PREFETCH_AUTO. */\nLIBXSMM_APIVAR(libxsmm_gemm_prefetch_type libxsmm_gemm_auto_prefetch_default);\n/** Determines the prefetch strategy, which is used in case of LIBXSMM_PREFETCH_AUTO. */\nLIBXSMM_APIVAR(libxsmm_gemm_prefetch_type libxsmm_gemm_auto_prefetch);\n\n/**\n * Intercepted GEMM\n * - [>=1 and  odd]: sequential and non-tiled (small problem sizes only)\n * - [>=2 and even]: parallelized and tiled (all problem sizes)\n * - [>=3 and  odd]: GEMV is intercepted; small problem sizes\n * - [>=4 and even]: GEMV is intercepted; all problem sizes\n * - [0]: disabled\n */\nLIBXSMM_APIVAR_ALIGNED(int libxsmm_gemm_wrap);\n\n#endif /*LIBXSMM_GEMM_H*/\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/documentation/libxsmm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/documentation/libxsmm_mm.docx",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/documentation/libxsmm_prof-vtune.png",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/documentation/tensorflow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/documentation/libxsmm_samples.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/tests/mhd_image.raw",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/samples/magazine/magazine.docx",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/samples/utilities/mhd/mhd_in.mhd",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.13-uvwchpsksjjouo6u4uelh5vig75vq475/spack-src/samples/deeplearning/gxm/model_zoo/cifar10/mean.binaryproto"
    ],
    "total_files": 816
}