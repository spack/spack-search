{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/src/libxsmm_gemm.h": "/******************************************************************************\n** Copyright (c) 2015-2018, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Hans Pabst (Intel Corp.)\n******************************************************************************/\n#ifndef LIBXSMM_GEMM_H\n#define LIBXSMM_GEMM_H\n\n#include \"libxsmm_main.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#if !defined(LIBXSMM_GEMM_WRAP_DYNAMIC) && defined(LIBXSMM_BUILD) && \\\n  (!defined(__BLAS) || (0 != __BLAS)) && defined(__GNUC__) && \\\n  !(defined(__APPLE__) && defined(__MACH__) && LIBXSMM_VERSION3(6, 1, 0) >= \\\n    LIBXSMM_VERSION3(__clang_major__, __clang_minor__, __clang_patchlevel__)) && \\\n  !defined(_WIN32) && !defined(__CYGWIN__)\n# include <dlfcn.h>\n# define LIBXSMM_GEMM_WRAP_DYNAMIC\n#endif\n#include <limits.h>\n#include <stdio.h>\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\n#if !defined(LIBXSMM_GEMM_CHECK) && !defined(NDEBUG)\n# define LIBXSMM_GEMM_CHECK\n#endif\n#if !defined(LIBXSMM_GEMM_LOCK)\n# define LIBXSMM_GEMM_LOCK LIBXSMM_LOCK_DEFAULT\n#endif\n#if !defined(LIBXSMM_GEMM_TASKSCALE)\n# define LIBXSMM_GEMM_TASKSCALE 2\n#endif\n#if !defined(LIBXSMM_GEMM_BATCHSCALE)\n# define LIBXSMM_GEMM_BATCHSCALE 1.5\n#endif\n\n#if !defined(LIBXSMM_GEMM_MMBATCH) && defined(LIBXSMM_BUILD) && \\\n    (defined(LIBXSMM_CONFIG_WRAP) && 0 != (LIBXSMM_CONFIG_WRAP)) && \\\n    (defined(LIBXSMM_GEMM_WRAP_STATIC) || defined(LIBXSMM_GEMM_WRAP_DYNAMIC) || \\\n    !defined(NDEBUG) || defined(_WIN32)) /* debug purpose */\n# define LIBXSMM_GEMM_MMBATCH\n#endif\n\n/** Undefine (disarm) MKL's DIRECT_CALL macros. */\n#if defined(MKL_DIRECT_CALL_SEQ) || defined(MKL_DIRECT_CALL)\n# if defined(sgemm_)\n#   undef sgemm_\n# endif\n# if defined(dgemm_)\n#   undef dgemm_\n# endif\n#endif\n\n#if (!defined(__BLAS) || (0 != __BLAS))\n# define LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, SYMBOL) if (0 == (ORIGINAL)) { \\\n    union { LIBXSMM_GEMMFUNCTION_TYPE(TYPE) pf; \\\n      void (*sf)(LIBXSMM_GEMM_CONST char*, LIBXSMM_GEMM_CONST char*, \\\n        LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST float*, float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*); \\\n      void (*df)(LIBXSMM_GEMM_CONST char*, LIBXSMM_GEMM_CONST char*, \\\n        LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST double*, double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*); \\\n    } libxsmm_gemm_wrapper_blas_; \\\n    libxsmm_gemm_wrapper_blas_.LIBXSMM_TPREFIX(TYPE,f) = (SYMBOL); \\\n    /*LIBXSMM_ATOMIC(LIBXSMM_ATOMIC_STORE, LIBXSMM_BITS)(&(ORIGINAL), libxsmm_gemm_wrapper_blas_.pf, LIBXSMM_ATOMIC_RELAXED);*/ \\\n    ORIGINAL = libxsmm_gemm_wrapper_blas_.pf; \\\n  }\n# define LIBXSMM_GEMV_WRAPPER_BLAS(TYPE, ORIGINAL, SYMBOL) if (0 == (ORIGINAL)) { \\\n    union { LIBXSMM_GEMVFUNCTION_TYPE(TYPE) pf; \\\n      void (*sf)(LIBXSMM_GEMM_CONST char*, \\\n        LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST float*, float*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*); \\\n      void (*df)(LIBXSMM_GEMM_CONST char*, \\\n        LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, LIBXSMM_GEMM_CONST double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*, \\\n        LIBXSMM_GEMM_CONST double*, double*, LIBXSMM_GEMM_CONST LIBXSMM_BLASINT*); \\\n    } libxsmm_gemv_wrapper_blas_; \\\n    libxsmm_gemv_wrapper_blas_.LIBXSMM_TPREFIX(TYPE,f) = (SYMBOL); \\\n    /*LIBXSMM_ATOMIC(LIBXSMM_ATOMIC_STORE, LIBXSMM_BITS)(&(ORIGINAL), libxsmm_gemv_wrapper_blas_.pf, LIBXSMM_ATOMIC_RELAXED);*/ \\\n    ORIGINAL = libxsmm_gemv_wrapper_blas_.pf; \\\n  }\n#else\n# define LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, SYMBOL)\n# define LIBXSMM_GEMV_WRAPPER_BLAS(TYPE, ORIGINAL, SYMBOL)\n#endif\n\n#if defined(LIBXSMM_GEMM_WRAP) && defined(LIBXSMM_BUILD) && defined(LIBXSMM_BUILD_EXT) && \\\n  !(defined(__APPLE__) && defined(__MACH__) /*&& defined(__clang__)*/) && !defined(__CYGWIN__)\n# if (2 != (LIBXSMM_GEMM_WRAP)) /* SGEMM and DGEMM */\n#   define LIBXSMM_GEMM_WRAPPER_STATIC(TYPE, ORIGINAL) LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, \\\n      LIBXSMM_FSYMBOL(LIBXSMM_CONCATENATE(__real_, LIBXSMM_TPREFIX(TYPE, gemm))))\n#   define LIBXSMM_GEMV_WRAPPER_STATIC(TYPE, ORIGINAL) LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, \\\n      LIBXSMM_FSYMBOL(LIBXSMM_CONCATENATE(__real_, LIBXSMM_TPREFIX(TYPE, gemv))))\n# else /* DGEMM only */\n#   define LIBXSMM_GEMM_WRAPPER_STATIC(TYPE, ORIGINAL) if (0 != LIBXSMM_EQUAL(TYPE, double)) { \\\n      LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, LIBXSMM_FSYMBOL(__real_dgemm)) \\\n    }\n#   define LIBXSMM_GEMV_WRAPPER_STATIC(TYPE, ORIGINAL) if (0 != LIBXSMM_EQUAL(TYPE, double)) { \\\n      LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, LIBXSMM_FSYMBOL(__real_dgemv)) \\\n    }\n# endif\n# define LIBXSMM_GEMM_WRAP_STATIC\n#else\n# define LIBXSMM_GEMM_WRAPPER_STATIC(TYPE, ORIGINAL)\n# define LIBXSMM_GEMV_WRAPPER_STATIC(TYPE, ORIGINAL)\n#endif\n\n#if defined(LIBXSMM_GEMM_WRAP_DYNAMIC)\n# define LIBXSMM_GEMM_WRAPPER_DYNAMIC(TYPE, ORIGINAL) \\\n    if (0 == (ORIGINAL)) { \\\n      union { const void* pv; LIBXSMM_GEMMFUNCTION_TYPE(TYPE) pf; } libxsmm_gemm_wrapper_dynamic_ = { 0 }; \\\n      dlerror(); /* clear an eventual error status */ \\\n      libxsmm_gemm_wrapper_dynamic_.pv = dlsym(RTLD_NEXT, LIBXSMM_STRINGIFY(LIBXSMM_GEMM_SYMBOL(TYPE))); \\\n      /*LIBXSMM_ATOMIC_STORE(&(ORIGINAL), libxsmm_gemm_wrapper_dynamic_.pf, LIBXSMM_ATOMIC_RELAXED);*/ \\\n      ORIGINAL = (NULL == dlerror() ? libxsmm_gemm_wrapper_dynamic_.pf : NULL); \\\n      LIBXSMM_GEMM_WRAPPER_BLAS(TYPE, ORIGINAL, LIBXSMM_GEMM_SYMBOL(TYPE)); \\\n    }\n# define LIBXSMM_GEMV_WRAPPER_DYNAMIC(TYPE, ORIGINAL) \\\n    if (0 == (ORIGINAL)) { \\\n      union { const void* pv; LIBXSMM_GEMVFUNCTION_TYPE(TYPE) pf; } libxsmm_gemv_wrapper_dynamic_ = { 0 }; \\\n      dlerror(); /* clear an eventual error status */ \\\n      libxsmm_gemv_wrapper_dynamic_.pv = dlsym(RTLD_NEXT, LIBXSMM_STRINGIFY(LIBXSMM_GEMV_SYMBOL(TYPE))); \\\n      /*LIBXSMM_ATOMIC_STORE(&(ORIGINAL), libxsmm_gemv_wrapper_dynamic_.pf, LIBXSMM_ATOMIC_RELAXED);*/ \\\n      ORIGINAL = (NULL == dlerror() ? libxsmm_gemv_wrapper_dynamic_.pf : NULL); \\\n      LIBXSMM_GEMV_WRAPPER_BLAS(TYPE, ORIGINAL, LIBXSMM_GEMV_SYMBOL(TYPE)); \\\n    }\n#else\n# define LIBXSMM_GEMM_WRAPPER_DYNAMIC(TYPE, ORIGINAL) LIBXSMM_GEMM_WRAPPER_BLAS( \\\n    TYPE, ORIGINAL, LIBXSMM_GEMM_SYMBOL(TYPE))\n# define LIBXSMM_GEMV_WRAPPER_DYNAMIC(TYPE, ORIGINAL) LIBXSMM_GEMV_WRAPPER_BLAS( \\\n    TYPE, ORIGINAL, LIBXSMM_GEMV_SYMBOL(TYPE))\n#endif\n\n#if defined(NDEBUG) /* library code is expected to be mute */\n# define LIBXSMM_GEMM_WRAPPER(TYPE, ORIGINAL) if (0 == (ORIGINAL)) { \\\n    LIBXSMM_GEMM_WRAPPER_STATIC(TYPE, ORIGINAL); \\\n    LIBXSMM_GEMM_WRAPPER_DYNAMIC(TYPE, ORIGINAL); \\\n  }\n#else\n# define LIBXSMM_GEMM_WRAPPER(TYPE, ORIGINAL) if (0 == (ORIGINAL)) { \\\n    LIBXSMM_GEMM_WRAPPER_STATIC(TYPE, ORIGINAL); \\\n    LIBXSMM_GEMM_WRAPPER_DYNAMIC(TYPE, ORIGINAL); \\\n    if (0 == (ORIGINAL)) { \\\n      static int libxsmm_gemm_wrapper_error_once_ = 0; \\\n      if (1 == LIBXSMM_ATOMIC_ADD_FETCH(&libxsmm_gemm_wrapper_error_once_, 1, LIBXSMM_ATOMIC_RELAXED)) { \\\n        fprintf(stderr, \"LIBXSMM ERROR: application must be linked against LAPACK/BLAS!\\n\"); \\\n      } \\\n    } \\\n  }\n#endif\n\n\n/** Provides GEMM functions available via BLAS; NOT thread-safe. */\nLIBXSMM_API_INTERN void libxsmm_gemm_init(int archid);\n\n/** Finalizes the GEMM facility; NOT thread-safe. */\nLIBXSMM_API_INTERN void libxsmm_gemm_finalize(void);\n\n/** Determines the size of the element-type given by precision. */\nLIBXSMM_API_INTERN unsigned char libxsmm_gemm_typesize(libxsmm_gemm_precision precision);\n\n/** Determines the given value in double-precision based on the given precision. */\nLIBXSMM_API_INTERN int libxsmm_gemm_dvalue(libxsmm_gemm_precision precision, const void* value, double* dvalue);\n/** Determines the value given in double-precision. */\nLIBXSMM_API_INTERN int libxsmm_gemm_cast(libxsmm_gemm_precision precision, double dvalue, void* value);\n\nLIBXSMM_API_INTERN int libxsmm_gemm_prefetch2uid(libxsmm_gemm_prefetch_type prefetch);\nLIBXSMM_API_INTERN libxsmm_gemm_prefetch_type libxsmm_gemm_uid2prefetch(int uid);\n\n#if defined(LIBXSMM_GEMM_WRAP_STATIC)\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_sgemm)(\n  const char*, const char*, const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const float*, const float*, const libxsmm_blasint*, const float* b, const libxsmm_blasint*,\n  const float*, float*, const libxsmm_blasint*);\nLIBXSMM_API void LIBXSMM_FSYMBOL(__real_dgemm)(\n  const char*, const char*, const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const double*, const double*, const libxsmm_blasint*, const double* b, const libxsmm_blasint*,\n  const double*, double*, const libxsmm_blasint*);\n#endif /*defined(LIBXSMM_GEMM_WRAP_STATIC)*/\n\n#if defined(LIBXSMM_BUILD) && defined(LIBXSMM_BUILD_EXT)\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_sgemm)(\n  const char*, const char*, const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const float*, const float*, const libxsmm_blasint*, const float* b, const libxsmm_blasint*,\n  const float*, float*, const libxsmm_blasint*);\nLIBXSMM_APIEXT void LIBXSMM_FSYMBOL(__wrap_dgemm)(\n  const char*, const char*, const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const double*, const double*, const libxsmm_blasint*, const double* b, const libxsmm_blasint*,\n  const double*, double*, const libxsmm_blasint*);\n#endif\n\nLIBXSMM_GEMM_SYMBOL_BLAS(LIBXSMM_GEMM_CONST, float)\nLIBXSMM_GEMM_SYMBOL_BLAS(LIBXSMM_GEMM_CONST, double)\n\nLIBXSMM_EXTERN_C struct LIBXSMM_RETARGETABLE libxsmm_gemm_handle {\n  libxsmm_code_pointer copy_a, copy_b, copy_i, copy_o;\n  libxsmm_xmmfunction kernel[2];\n  unsigned int m, n, k, lda, ldb, ldc;\n  unsigned int tm, tn, tk, dm, dn, dk;\n  unsigned int itypesize, otypesize;\n  unsigned int nthreads, mt, nt, kt;\n  int gemm_flags, flags;\n};\n\nLIBXSMM_EXTERN_C typedef union LIBXSMM_RETARGETABLE libxsmm_gemm_batchitem {\n  struct {\n    const void *a, *b;\n    void *c;\n  } value;\n  struct {\n    libxsmm_gemm_descriptor desc;\n    unsigned int count;\n    const char* symbol;\n  } stat;\n  /* TODO: consider padding */\n} libxsmm_gemm_batchitem;\n\nLIBXSMM_API int libxsmm_mmbatch_internal(libxsmm_xmmfunction kernel, libxsmm_blasint index_base, libxsmm_blasint index_stride,\n  const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  const void* a, const void* b, void* c, libxsmm_blasint batchsize, int tid, int nthreads,\n  const libxsmm_gemm_descriptor* info);\n\nLIBXSMM_API int libxsmm_dmmbatch_blas(const char* transa, const char* transb, libxsmm_blasint m, libxsmm_blasint n, libxsmm_blasint k,\n  const double* alpha, const void* a, const libxsmm_blasint* lda, const void* b, const libxsmm_blasint* ldb, const double* beta, void* c, const libxsmm_blasint* ldc,\n  libxsmm_blasint index_base, libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  libxsmm_blasint batchsize);\nLIBXSMM_API int libxsmm_smmbatch_blas(const char* transa, const char* transb, libxsmm_blasint m, libxsmm_blasint n, libxsmm_blasint k,\n  const float* alpha, const void* a, const libxsmm_blasint* lda, const void* b, const libxsmm_blasint* ldb, const float* beta, void* c, const libxsmm_blasint* ldc,\n  libxsmm_blasint index_base, libxsmm_blasint index_stride, const libxsmm_blasint stride_a[], const libxsmm_blasint stride_b[], const libxsmm_blasint stride_c[],\n  libxsmm_blasint batchsize);\n\nLIBXSMM_EXTERN_C typedef void (*libxsmm_mmbatch_flush_function)(void);\n\n/** auto-batch descriptor (filter). */\nLIBXSMM_APIVAR_PUBLIC(libxsmm_gemm_descriptor libxsmm_gemm_batchdesc);\n/** Records a batch of SMMs. */\nLIBXSMM_APIVAR_PUBLIC(libxsmm_gemm_batchitem* libxsmm_gemm_batcharray);\n/** Lock: libxsmm_mmbatch_begin, libxsmm_mmbatch_end, internal_mmbatch_flush. */\nLIBXSMM_APIVAR_PUBLIC(LIBXSMM_LOCK_TYPE(LIBXSMM_GEMM_LOCK) libxsmm_gemm_batchlock);\n/** Maximum size of the recorded batch. */\nLIBXSMM_APIVAR_PUBLIC(unsigned int libxsmm_gemm_batchsize);\n/** Minimum batchsize per thread/task. */\nLIBXSMM_APIVAR_PUBLIC(unsigned int libxsmm_gemm_batchgrain);\n/** Determines if OpenMP tasks are used, and scales beyond the number of threads. */\nLIBXSMM_APIVAR_PUBLIC(int libxsmm_gemm_taskscale);\n\n/** Determines the default prefetch strategy, which is used in case of LIBXSMM_PREFETCH_AUTO. */\nLIBXSMM_APIVAR(libxsmm_gemm_prefetch_type libxsmm_gemm_auto_prefetch_default);\n/** Determines the prefetch strategy, which is used in case of LIBXSMM_PREFETCH_AUTO. */\nLIBXSMM_APIVAR(libxsmm_gemm_prefetch_type libxsmm_gemm_auto_prefetch);\n\n/**\n* Intercepted GEMM\n* - odd: sequential and non-tiled (small problem sizes only)\n* - even (or negative): parallelized and tiled (all problem sizes)\n* - 3: GEMV is intercepted; small problem sizes\n* - 4: GEMV is intercepted; all problem sizes\n*/\nLIBXSMM_APIVAR_PUBLIC(int libxsmm_gemm_wrap);\n\n#endif /*LIBXSMM_GEMM_H*/\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/cp2k.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/libxsmm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/libxsmm_mm.docx",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/libxsmm_prof-vtune.png",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/tensorflow.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/libxsmm_samples.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/documentation/tfserving.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/tests/mhd_image.raw",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/samples/magazine/magazine.docx",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/samples/deeplearning/gxm/model_zoo/cifar10/mean.binaryproto",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.10-dw3heq5bmw3lf3xz46i7yao4lerf7lwe/spack-src/samples/deeplearning/iconv/iconv_in.mhd"
    ],
    "total_files": 779
}