{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.4.4-gndlskyorfzjt7omi5zeectxmveh2rwu/spack-src/src/libxsmm_gemm.c": "/******************************************************************************\n** Copyright (c) 2015-2016, Intel Corporation                                **\n** All rights reserved.                                                      **\n**                                                                           **\n** Redistribution and use in source and binary forms, with or without        **\n** modification, are permitted provided that the following conditions        **\n** are met:                                                                  **\n** 1. Redistributions of source code must retain the above copyright         **\n**    notice, this list of conditions and the following disclaimer.          **\n** 2. Redistributions in binary form must reproduce the above copyright      **\n**    notice, this list of conditions and the following disclaimer in the    **\n**    documentation and/or other materials provided with the distribution.   **\n** 3. Neither the name of the copyright holder nor the names of its          **\n**    contributors may be used to endorse or promote products derived        **\n**    from this software without specific prior written permission.          **\n**                                                                           **\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       **\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         **\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     **\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT      **\n** HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    **\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  **\n** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR    **\n** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    **\n** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      **\n** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        **\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              **\n******************************************************************************/\n/* Hans Pabst (Intel Corp.)\n******************************************************************************/\n#include \"libxsmm_gemm.h\"\n#include \"libxsmm_ext_gemm.h\"\n#include \"libxsmm_sync.h\"\n\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(push,target(LIBXSMM_OFFLOAD_TARGET))\n#endif\n#include <stdlib.h>\n#include <stdint.h>\n#if defined(LIBXSMM_RTLD_NEXT)\n# include <dlfcn.h>\n#endif\n#if !defined(NDEBUG)\n# include <stdio.h>\n#endif\n#if defined(LIBXSMM_OFFLOAD_TARGET)\n# pragma offload_attribute(pop)\n#endif\n\n\n#if defined(LIBXSMM_ORIGINAL_GEMM_INDIRECT)\n\nLIBXSMM_API_DEFINITION const libxsmm_sgemm_function* libxsmm_original_sgemm_ptr(void)\n{\n  return &libxsmm_original_sgemm;\n}\n\n\nLIBXSMM_API_DEFINITION const libxsmm_dgemm_function* libxsmm_original_dgemm_ptr(void)\n{\n  return &libxsmm_original_dgemm;\n}\n\n#endif /*defined(LIBXSMM_ORIGINAL_GEMM_INDIRECT)*/\n\n\nLIBXSMM_API_DEFINITION void libxsmm_gemm_configure(int archid, int prefetch)\n{\n  int config = 0;\n  LIBXSMM_UNUSED(prefetch);\n  internal_gemm_prefetch = LIBXSMM_PREFETCH_AL2_AHEAD;\n  internal_gemm_nt = 2;\n  internal_gemm = 2;\n  {\n    /* behaviour of libxsmm_omp_?gemm routines or LD_PRELOAD ?GEMM routines\n     * 0: sequential below-threshold routine (no OpenMP); may fall-back to BLAS,\n     * 1: OpenMP-parallelized but without internal parallel region,\n     * 2: OpenMP-parallelized with internal parallel region\" )\n     */\n    const char *const env = getenv(\"LIBXSMM_GEMM\");\n    if (0 != env && 0 != *env) {\n      internal_gemm = atoi(env);\n    }\n  }\n#if defined(LIBXSMM_EXT_GEMM_TASKS)\n  { /* consider user input about using (OpenMP-)tasks; this code must be here\n    * because maybe only this translation unit is compiled with OpenMP support\n    */\n    const char *const env_tasks = getenv(\"LIBXSMM_TASKS\");\n    if (0 != env_tasks && 0 != *env_tasks) {\n      internal_gemm_tasks = atoi(env_tasks);\n    }\n  }\n#endif\n#if defined(__MIC__)\n  LIBXSMM_UNUSED(archid);\n#else\n  if (LIBXSMM_X86_AVX512_MIC == archid)\n#endif\n  {\n    internal_gemm_nt = 4;\n    config = 1;\n  }\n  { /* attempt to setup tile sizes from the environment (LIBXSMM_M, LIBXSMM_N, and LIBXSMM_K) */\n    const int tile_configs[/*configs*/][2/*DP/SP*/][3/*TILE_M,TILE_N,TILE_K*/] = {\n      { { 72, 32, 16 }, { 72, 32, 16 } }, /*generic*/\n      { { 72, 32, 16 }, { 72, 32, 16 } }  /*knl*/\n    };\n    const char* env[3];\n    env[0] = getenv(\"LIBXSMM_M\"); env[1] = getenv(\"LIBXSMM_N\"); env[2] = getenv(\"LIBXSMM_K\");\n    internal_gemm_tile[0/*DP*/][0/*M*/] = (env[0] ? atoi(env[0]) : 0);\n    internal_gemm_tile[0/*DP*/][1/*N*/] = (env[1] ? atoi(env[1]) : 0);\n    internal_gemm_tile[0/*DP*/][2/*K*/] = (env[2] ? atoi(env[2]) : 0);\n    /* environment-defined tile sizes applies for DP and SP */\n    internal_gemm_tile[1/*SP*/][0/*M*/] = internal_gemm_tile[0/*DP*/][0];\n    internal_gemm_tile[1/*SP*/][1/*N*/] = internal_gemm_tile[0/*DP*/][1];\n    internal_gemm_tile[1/*SP*/][2/*K*/] = internal_gemm_tile[0/*DP*/][2];\n    /* load predefined configuration if tile size is not setup by the environment */\n    if (0 >= internal_gemm_tile[0/*DP*/][0/*M*/]) internal_gemm_tile[0][0] = tile_configs[config][0][0];\n    if (0 >= internal_gemm_tile[0/*DP*/][1/*N*/]) internal_gemm_tile[0][1] = tile_configs[config][0][1];\n    if (0 >= internal_gemm_tile[0/*DP*/][2/*K*/]) internal_gemm_tile[0][2] = tile_configs[config][0][2];\n    if (0 >= internal_gemm_tile[1/*SP*/][0/*M*/]) internal_gemm_tile[1][0] = tile_configs[config][1][0];\n    if (0 >= internal_gemm_tile[1/*SP*/][1/*N*/]) internal_gemm_tile[1][1] = tile_configs[config][1][1];\n    if (0 >= internal_gemm_tile[1/*SP*/][2/*K*/]) internal_gemm_tile[1][2] = tile_configs[config][1][2];\n  }\n#if defined(__STATIC) && defined(LIBXSMM_BUILD) && !defined(__CYGWIN__) && \\\n  !(defined(__APPLE__) && defined(__MACH__) /*&& defined(__clang__)*/)\n  if (0 == libxsmm_original_sgemm) {\n    libxsmm_original_sgemm = LIBXSMM_FSYMBOL(__real_sgemm);\n  }\n#endif\n#if !defined(__BLAS) || (0 != __BLAS)\n  if (0 == libxsmm_original_sgemm) {\n    libxsmm_original_sgemm = LIBXSMM_FSYMBOL(sgemm);\n  }\n#endif\n#if defined(LIBXSMM_RTLD_NEXT)\n  if (0 == libxsmm_original_sgemm) {\n    union { const void* pv; libxsmm_sgemm_function pf; } gemm = { NULL };\n    gemm.pv = dlsym(RTLD_NEXT, LIBXSMM_STRINGIFY(LIBXSMM_FSYMBOL(sgemm)));\n    libxsmm_original_sgemm = gemm.pf;\n  }\n#endif\n#if defined(__STATIC) && defined(LIBXSMM_BUILD) && !defined(__CYGWIN__) && \\\n  !(defined(__APPLE__) && defined(__MACH__) /*&& defined(__clang__)*/)\n  if (0 == libxsmm_original_dgemm) {\n    libxsmm_original_dgemm = LIBXSMM_FSYMBOL(__real_dgemm);\n  }\n#endif\n#if !defined(__BLAS) || (0 != __BLAS)\n  if (0 == libxsmm_original_dgemm) {\n    libxsmm_original_dgemm = LIBXSMM_FSYMBOL(dgemm);\n  }\n#endif\n#if defined(LIBXSMM_RTLD_NEXT)\n  if (0 == libxsmm_original_dgemm) {\n    union { const void* pv; libxsmm_dgemm_function pf; } gemm = { NULL };\n    gemm.pv = dlsym(RTLD_NEXT, LIBXSMM_STRINGIFY(LIBXSMM_FSYMBOL(dgemm)));\n    libxsmm_original_dgemm = gemm.pf;\n  }\n#endif\n}\n\n\nLIBXSMM_API_DEFINITION int libxsmm_gemm_init(int archid, int prefetch)\n{\n  int result = EXIT_SUCCESS;\n  /* internal pre-initialization step */\n  libxsmm_gemm_configure(archid, prefetch);\n#if !defined(__BLAS) || (0 != __BLAS)\n  result = (0 != libxsmm_original_sgemm && 0 != libxsmm_original_dgemm) ? EXIT_SUCCESS : EXIT_FAILURE;\n#endif\n#if !defined(NDEBUG) /* library code is expected to be mute */\n  if (EXIT_SUCCESS != result) {\n    static LIBXSMM_TLS int error_blas = 0;\n    if (0 == error_blas) {\n      fprintf(stderr, \"LIBXSMM: application must be linked against a LAPACK/BLAS implementation!\\n\");\n      error_blas = 1;\n    }\n  }\n#endif\n  return result;\n}\n\n\nLIBXSMM_API_DEFINITION void libxsmm_gemm_finalize(void)\n{\n}\n\n\n#if defined(LIBXSMM_BUILD)\n\nLIBXSMM_API_DEFINITION void libxsmm_sgemm(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const float* alpha, const float* a, const libxsmm_blasint* lda,\n  const float* b, const libxsmm_blasint* ldb,\n  const float* beta, float* c, const libxsmm_blasint* ldc)\n{\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_SGEMM(flags, *m, *n, *k,\n    0 != alpha ? *alpha : ((float)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((float)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n\nLIBXSMM_API_DEFINITION void libxsmm_dgemm(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const double* alpha, const double* a, const libxsmm_blasint* lda,\n  const double* b, const libxsmm_blasint* ldb,\n  const double* beta, double* c, const libxsmm_blasint* ldc)\n{\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_DGEMM(flags, *m, *n, *k,\n    0 != alpha ? *alpha : ((double)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((double)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n#endif /*defined(LIBXSMM_BUILD)*/\n\n\n/* implementation provided for Fortran 77 compatibility */\nLIBXSMM_API void LIBXSMM_FSYMBOL(libxsmm_sgemm)(const char*, const char*,\n  const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const float*, const float*, const libxsmm_blasint*,\n  const float*, const libxsmm_blasint*,\n  const float*, float*, const libxsmm_blasint*);\nLIBXSMM_API_DEFINITION void LIBXSMM_FSYMBOL(libxsmm_sgemm)(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const float* alpha, const float* a, const libxsmm_blasint* lda,\n  const float* b, const libxsmm_blasint* ldb,\n  const float* beta, float* c, const libxsmm_blasint* ldc)\n{\n  libxsmm_sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);\n}\n\n\n/* implementation provided for Fortran 77 compatibility */\nLIBXSMM_API void LIBXSMM_FSYMBOL(libxsmm_dgemm)(const char*, const char*,\n  const libxsmm_blasint*, const libxsmm_blasint*, const libxsmm_blasint*,\n  const double*, const double*, const libxsmm_blasint*,\n  const double*, const libxsmm_blasint*,\n  const double*, double*, const libxsmm_blasint*);\nLIBXSMM_API_DEFINITION void LIBXSMM_FSYMBOL(libxsmm_dgemm)(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const double* alpha, const double* a, const libxsmm_blasint* lda,\n  const double* b, const libxsmm_blasint* ldb,\n  const double* beta, double* c, const libxsmm_blasint* ldc)\n{\n  libxsmm_dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);\n}\n\n\nLIBXSMM_API_DEFINITION void libxsmm_blas_sgemm(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const float* alpha, const float* a, const libxsmm_blasint* lda,\n  const float* b, const libxsmm_blasint* ldb,\n  const float* beta, float* c, const libxsmm_blasint* ldc)\n{\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_BLAS_SGEMM(flags, *m, *n, *k,\n    0 != alpha ? *alpha : ((float)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((float)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n\nLIBXSMM_API_DEFINITION void libxsmm_blas_dgemm(const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const double* alpha, const double* a, const libxsmm_blasint* lda,\n  const double* b, const libxsmm_blasint* ldb,\n  const double* beta, double* c, const libxsmm_blasint* ldc)\n{\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_BLAS_DGEMM(flags, *m, *n, *k,\n    0 != alpha ? *alpha : ((double)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((double)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n\nLIBXSMM_API_DEFINITION void LIBXSMM_FSYMBOL(__wrap_sgemm)(\n  const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const float* alpha, const float* a, const libxsmm_blasint* lda,\n  const float* b, const libxsmm_blasint* ldb,\n  const float* beta, float* c, const libxsmm_blasint* ldc)\n{\n  const int tm = internal_gemm_tile[1/*SP*/][0/*M*/];\n  const int tn = internal_gemm_tile[1/*SP*/][1/*N*/];\n  const int tk = internal_gemm_tile[1/*SP*/][2/*K*/];\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_EXT_GEMM_XGEMM(LIBXSMM_EXT_GEMM_FOR_INIT, LIBXSMM_EXT_GEMM_FOR_LOOP_BEGIN,\n    LIBXSMM_EXT_GEMM_FOR_LOOP_BODY, LIBXSMM_EXT_GEMM_FOR_LOOP_END,\n    float, flags | LIBXSMM_GEMM_FLAG_F32PREC, internal_gemm_nt, tm, tn, tk, *m, *n, *k,\n    0 != alpha ? *alpha : ((float)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((float)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n\nLIBXSMM_API_DEFINITION void LIBXSMM_FSYMBOL(__wrap_dgemm)(\n  const char* transa, const char* transb,\n  const libxsmm_blasint* m, const libxsmm_blasint* n, const libxsmm_blasint* k,\n  const double* alpha, const double* a, const libxsmm_blasint* lda,\n  const double* b, const libxsmm_blasint* ldb,\n  const double* beta, double* c, const libxsmm_blasint* ldc)\n{\n  const int tm = internal_gemm_tile[0/*DP*/][0/*M*/];\n  const int tn = internal_gemm_tile[0/*DP*/][1/*N*/];\n  const int tk = internal_gemm_tile[0/*DP*/][2/*K*/];\n  LIBXSMM_GEMM_DECLARE_FLAGS(flags, transa, transb, m, n, k, a, b, c);\n  LIBXSMM_EXT_GEMM_XGEMM(LIBXSMM_EXT_GEMM_FOR_INIT, LIBXSMM_EXT_GEMM_FOR_LOOP_BEGIN,\n    LIBXSMM_EXT_GEMM_FOR_LOOP_BODY, LIBXSMM_EXT_GEMM_FOR_LOOP_END,\n    double, flags, internal_gemm_nt, tm, tn, tk, *m, *n, *k,\n    0 != alpha ? *alpha : ((double)LIBXSMM_ALPHA),\n    a, *(lda ? lda : LIBXSMM_LD(m, k)), b, *(ldb ? ldb : LIBXSMM_LD(k, n)),\n    0 != beta ? *beta : ((double)LIBXSMM_BETA),\n    c, *(ldc ? ldc : LIBXSMM_LD(m, n)));\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.4.4-gndlskyorfzjt7omi5zeectxmveh2rwu/spack-src/documentation/cp2k.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libxsmm-1.4.4-gndlskyorfzjt7omi5zeectxmveh2rwu/spack-src/documentation/libxsmm.pdf"
    ],
    "total_files": 164
}