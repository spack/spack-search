{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/tests/df/no-mtab-status.sh": "#!/bin/sh\n# Test df's behaviour when the mount list cannot be read.\n# This test is skipped on systems that lack LD_PRELOAD support; that's fine.\n\n# Copyright (C) 2012-2018 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n. \"${srcdir=.}/tests/init.sh\"; path_prepend_ ./src\nprint_ver_ df\nrequire_gcc_shared_\n\n# Protect against inaccessible remote mounts etc.\ntimeout 10 df || skip_ \"df fails\"\n\ngrep '^#define HAVE_MNTENT_H 1' $CONFIG_HEADER > /dev/null \\\n      || skip_ \"no mntent.h available to confirm the interface\"\n\ngrep '^#define HAVE_GETMNTENT 1' $CONFIG_HEADER > /dev/null \\\n      || skip_ \"getmntent is not used on this system\"\n\n# Simulate \"mtab\" failure.\ncat > k.c <<EOF || framework_failure_\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <errno.h>\n#include <mntent.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#define STREQ(a, b) (strcmp (a, b) == 0)\n\nFILE* fopen(const char *path, const char *mode)\n{\n  static FILE* (*fopen_func)(char const *, char const *);\n\n  /* get reference to original (libc provided) fopen */\n  if (!fopen_func)\n    {\n      fopen_func = (FILE*(*)(char const *, char const *))\n                   dlsym(RTLD_NEXT, \"fopen\");\n      if (!fopen_func)\n        {\n          fprintf (stderr, \"Failed to find fopen()\\n\");\n          errno = ESRCH;\n          return NULL;\n        }\n    }\n\n  /* Returning ENOENT here will get read_file_system_list()\n     to fall back to using getmntent() below.  */\n  if (STREQ (path, \"/proc/self/mountinfo\"))\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n  else\n    return fopen_func(path, mode);\n}\n\nstruct mntent *getmntent (FILE *fp)\n{\n  /* Prove that LD_PRELOAD works. */\n  static int done = 0;\n  if (!done)\n    {\n      fclose (fopen (\"x\", \"w\"));\n      ++done;\n    }\n  /* Now simulate the failure. */\n  errno = ENOENT;\n  return NULL;\n}\nEOF\n\n# Then compile/link it:\ngcc_shared_ k.c k.so \\\n  || framework_failure_ 'failed to build shared library'\n\ncleanup_() { unset LD_PRELOAD; }\n\nexport LD_PRELOAD=$LD_PRELOAD:./k.so\n\n# Test if LD_PRELOAD works:\ndf 2>/dev/null\ntest -f x || skip_ \"internal test failure: maybe LD_PRELOAD doesn't work?\"\n\n# These tests are supposed to succeed:\ndf '.' || fail=1\ndf -i '.' || fail=1\ndf -T '.' || fail=1\ndf -Ti '.' || fail=1\ndf --total '.' || fail=1\n\n# These tests are supposed to fail:\nreturns_ 1 df || fail=1\nreturns_ 1 df -i || fail=1\nreturns_ 1 df -T || fail=1\nreturns_ 1 df -Ti || fail=1\nreturns_ 1 df --total || fail=1\n\nreturns_ 1 df -a || fail=1\nreturns_ 1 df -a '.' || fail=1\n\nreturns_ 1 df -l || fail=1\nreturns_ 1 df -l '.' || fail=1\n\nreturns_ 1 df -t hello || fail=1\nreturns_ 1 df -t hello '.' || fail=1\n\nreturns_ 1 df -x hello || fail=1\nreturns_ 1 df -x hello '.' || fail=1\n\nExit $fail\n",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/tests/df/skip-duplicates.sh": "#!/bin/sh\n# Test df's behavior when the mount list contains duplicate entries.\n# This test is skipped on systems that lack LD_PRELOAD support; that's fine.\n\n# Copyright (C) 2012-2018 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n. \"${srcdir=.}/tests/init.sh\"; path_prepend_ ./src\nprint_ver_ df\nrequire_gcc_shared_\n\n# We use --local here so as to not activate\n# potentially very many remote mounts.\ndf --local --output=target >LOCAL_FS || skip_ 'df fails'\ngrep '^/$' LOCAL_FS || skip_ 'no root file system found'\n\n# Get real targets to substitute for /NONROOT and /REMOTE below.\nexport CU_NONROOT_FS=$(grep /. LOCAL_FS | head -n1)\nexport CU_REMOTE_FS=$(grep /. LOCAL_FS | tail -n+2 | head -n1)\n\nunique_entries=1\ntest -z \"$CU_NONROOT_FS\" || unique_entries=$(expr $unique_entries + 1)\ntest -z \"$CU_REMOTE_FS\" || unique_entries=$(expr $unique_entries + 2)\n\ngrep '^#define HAVE_MNTENT_H 1' $CONFIG_HEADER > /dev/null \\\n      || skip_ \"no mntent.h available to confirm the interface\"\n\ngrep '^#define HAVE_GETMNTENT 1' $CONFIG_HEADER > /dev/null \\\n      || skip_ \"getmntent is not used on this system\"\n\n# Simulate an mtab file to test various cases.\ncat > k.c <<EOF || framework_failure_\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <mntent.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#define STREQ(a, b) (strcmp (a, b) == 0)\n\nFILE* fopen(const char *path, const char *mode)\n{\n  static FILE* (*fopen_func)(char const *, char const *);\n\n  /* get reference to original (libc provided) fopen */\n  if (!fopen_func)\n    {\n      fopen_func = (FILE*(*)(char const *, char const *))\n                   dlsym(RTLD_NEXT, \"fopen\");\n      if (!fopen_func)\n        {\n          fprintf (stderr, \"Failed to find fopen()\\n\");\n          errno = ESRCH;\n          return NULL;\n        }\n    }\n\n  /* Returning ENOENT here will get read_file_system_list()\n     to fall back to using getmntent() below.  */\n  if (STREQ (path, \"/proc/self/mountinfo\"))\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n  else\n    return fopen_func(path, mode);\n}\n\n#define STREQ(a, b) (strcmp (a, b) == 0)\n\nstruct mntent *getmntent (FILE *fp)\n{\n  static char *nonroot_fs;\n  static char *remote_fs;\n  static int done;\n\n  /* Prove that LD_PRELOAD works. */\n  if (!done)\n    {\n      fclose (fopen (\"x\", \"w\"));\n      ++done;\n    }\n\n  static struct mntent mntents[] = {\n    {.mnt_fsname=\"/short\",  .mnt_dir=\"/invalid/mount/dir\",       .mnt_opts=\"\"},\n    {.mnt_fsname=\"fsname\",  .mnt_dir=\"/\",                        .mnt_opts=\"\"},\n    {.mnt_fsname=\"/fsname\", .mnt_dir=\"/.\",                       .mnt_opts=\"\"},\n    {.mnt_fsname=\"/fsname\", .mnt_dir=\"/\",                        .mnt_opts=\"\"},\n    {.mnt_fsname=\"virtfs\",  .mnt_dir=\"/NONROOT\", .mnt_type=\"t1\", .mnt_opts=\"\"},\n    {.mnt_fsname=\"virtfs2\", .mnt_dir=\"/NONROOT\", .mnt_type=\"t2\", .mnt_opts=\"\"},\n    {.mnt_fsname=\"netns\",   .mnt_dir=\"net:[1234567]\",            .mnt_opts=\"\"},\n    {.mnt_fsname=\"rem:ote1\",.mnt_dir=\"/REMOTE\",                  .mnt_opts=\"\"},\n    {.mnt_fsname=\"rem:ote1\",.mnt_dir=\"/REMOTE\",                  .mnt_opts=\"\"},\n    {.mnt_fsname=\"rem:ote2\",.mnt_dir=\"/REMOTE\",                  .mnt_opts=\"\"},\n  };\n\n  if (done == 1)\n    {\n      nonroot_fs = getenv (\"CU_NONROOT_FS\");\n      if (!nonroot_fs || !*nonroot_fs)\n        nonroot_fs = \"/\"; /* merge into / entries.  */\n\n      remote_fs = getenv (\"CU_REMOTE_FS\");\n    }\n\n  if (done == 1 && !getenv (\"CU_TEST_DUPE_INVALID\"))\n    done++;  /* skip the first entry.  */\n\n  while (done++ <= 10)\n    {\n      if (!mntents[done-2].mnt_type)\n        mntents[done-2].mnt_type = \"-\";\n      if (!mntents[done-2].mnt_opts)\n        mntents[done-2].mnt_opts = \"-\";\n      if (STREQ (mntents[done-2].mnt_dir, \"/NONROOT\"))\n        mntents[done-2].mnt_dir = nonroot_fs;\n      if (STREQ (mntents[done-2].mnt_dir, \"/REMOTE\"))\n        {\n          if (!remote_fs || !*remote_fs)\n            continue;\n          else\n            mntents[done-2].mnt_dir = remote_fs;\n        }\n      return &mntents[done-2];\n    }\n\n  return NULL;\n}\nEOF\n\n# Then compile/link it:\ngcc_shared_ k.c k.so \\\n  || framework_failure_ 'failed to build shared library'\n\n# Test if LD_PRELOAD works:\nLD_PRELOAD=$LD_PRELOAD:./k.so df\ntest -f x || skip_ \"internal test failure: maybe LD_PRELOAD doesn't work?\"\n\n# The fake mtab file should only contain entries\n# having the same device number; thus the output should\n# consist of a header and unique entries.\nLD_PRELOAD=$LD_PRELOAD:./k.so df -T >out || fail=1\ntest $(wc -l <out) -eq $(expr 1 + $unique_entries) || { fail=1; cat out; }\n\n# With --total we should suppress the duplicate but separate remote file system\nLD_PRELOAD=$LD_PRELOAD:./k.so df --total >out || fail=1\ntest \"$CU_REMOTE_FS\" && elide_remote=1 || elide_remote=0\ntest $(wc -l <out) -eq $(expr 2 + $unique_entries - $elide_remote) ||\n  { fail=1; cat out; }\n\n# Ensure we don't fail when unable to stat (currently) unavailable entries\nLD_PRELOAD=$LD_PRELOAD:./k.so CU_TEST_DUPE_INVALID=1 df -T >out || fail=1\ntest $(wc -l <out) -eq $(expr 1 + $unique_entries) || { fail=1; cat out; }\n\n# df should also prefer \"/fsname\" over \"fsname\"\nif test \"$unique_entries\" = 2; then\n  test $(grep -c '/fsname' <out) -eq 1 || { fail=1; cat out; }\n  # ... and \"/fsname\" with '/' as Mounted on over '/.'\n  test $(grep -cF '/.' <out) -eq 0 || { fail=1; cat out; }\nfi\n\n# df should use the last seen devname (mnt_fsname) and devtype (mnt_type)\ntest $(grep -c 'virtfs2.*t2' <out) -eq 1 || { fail=1; cat out; }\n\n# Ensure that filtering duplicates does not affect -a processing.\nLD_PRELOAD=$LD_PRELOAD:./k.so df -a >out || fail=1\ntotal_fs=6; test \"$CU_REMOTE_FS\" && total_fs=$(expr $total_fs + 3)\ntest $(wc -l <out) -eq $total_fs || { fail=1; cat out; }\n# Ensure placeholder \"-\" values used for the eclipsed \"virtfs\"\ntest $(grep -c 'virtfs *-' <out) -eq 1 || { fail=1; cat out; }\n\n# Ensure that filtering duplicates does not affect\n# argument processing (now without the fake getmntent()).\ndf '.' '.' >out || fail=1\ntest $(wc -l <out) -eq 3 || { fail=1; cat out; }\n\nExit $fail\n",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/tests/rm/rm-readdir-fail.sh": "#!/bin/sh\n# Test rm's behaviour when the directory cannot be read.\n# This test is skipped on systems that lack LD_PRELOAD support.\n\n# Copyright (C) 2016-2018 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n. \"${srcdir=.}/tests/init.sh\"; path_prepend_ ./src\nprint_ver_ rm\nrequire_gcc_shared_\n\nmkdir -p dir/notempty || framework_failure_\n\n# Simulate \"readdir\" failure.\ncat > k.c <<\\EOF || framework_failure_\n#define _GNU_SOURCE\n\n/* Setup so we don't have to worry about readdir64.  */\n#ifndef __LP64__\n# define _FILE_OFFSET_BITS 64\n#endif\n\n#include <dlfcn.h>\n#include <dirent.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct dirent *readdir (DIR *dirp)\n{\n  static struct dirent *(*real_readdir)(DIR *dirp);\n  if (! real_readdir && ! (real_readdir = dlsym (RTLD_NEXT, \"readdir\")))\n    {\n      fprintf (stderr, \"Failed to find readdir()\\n\");\n      errno = ESRCH;\n      return NULL;\n    }\n  struct dirent* d;\n  if (! (d = real_readdir (dirp)))\n    {\n      fprintf (stderr, \"Failed to get dirent\\n\");\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Flag that LD_PRELOAD and above functions work.  */\n  static int count = 1;\n  if (count == 1)\n    fclose (fopen (\"preloaded\", \"w\"));\n\n  /* Return some entries to trigger partial read failure,\n     ensuring we don't return ignored '.' or '..'  */\n  char const *readdir_partial = getenv (\"READDIR_PARTIAL\");\n  if (readdir_partial && *readdir_partial && count <= 3)\n    {\n      count++;\n      d->d_name[0]='0'+count; d->d_name[1]='\\0';\n#ifdef _DIRENT_HAVE_D_NAMLEN\n      d->d_namlen = 2;\n#endif\n      errno = 0;\n      return d;\n    };\n\n  /* Fail.  */\n  errno = ENOENT;\n  return NULL;\n}\nEOF\n\n# Then compile/link it:\ngcc_shared_ k.c k.so \\\n  || framework_failure_ 'failed to build shared library'\n\n# Test if LD_PRELOAD works:\nexport READDIR_PARTIAL\nfor READDIR_PARTIAL in '' '1'; do\n  rm -f preloaded\n  (export LD_PRELOAD=$LD_PRELOAD:./k.so\n   returns_ 1 rm -Rf dir 2>>errt) || fail=1\n  if ! test -f preloaded; then\n    cat err\n    skip_ \"internal test failure: maybe LD_PRELOAD doesn't work?\"\n  fi\ndone\n\n# First case is failure to read any items from dir, then assume empty.\n# Generally that will be diagnosed when rm tries to rmdir().\n# Second case is more general error where we fail immediately\n# (with ENOENT in this case but it could be anything).\ncat <<EOF > exp\nrm: cannot remove 'dir'\nrm: traversal failed: dir\nEOF\nsed 's/\\(rm:.*\\):.*/\\1/' errt > err || framework_failure_\ncompare exp err || fail=1\n\nExit $fail\n",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/tests/cp/nfs-removal-race.sh": "#!/bin/sh\n# Running cp S D on an NFS client while another client has just removed D\n# would lead (w/coreutils-8.16 and earlier) to cp's initial stat call\n# seeing (via stale NFS cache) that D exists, so that cp would then call\n# open without the O_CREAT flag.  Yet, the open must actually consult\n# the server, which confesses that D has been deleted, thus causing the\n# open call to fail with ENOENT.\n#\n# This test simulates that situation by intercepting stat for a nonexistent\n# destination, D, and making the stat fill in the result struct for another\n# file and return 0.\n#\n# This test is skipped on systems that lack LD_PRELOAD support; that's fine.\n# Similarly, on a system that lacks <dlfcn.h> or __xstat, skipping it is fine.\n\n# Copyright (C) 2012-2018 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n. \"${srcdir=.}/tests/init.sh\"; path_prepend_ ./src\nprint_ver_ cp\nrequire_gcc_shared_\n\n# Replace each stat call with a call to this wrapper.\ncat > k.c <<'EOF' || framework_failure_\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n\n#define __xstat __xstat_orig\n\n#include <sys/stat.h>\n#include <stddef.h>\n\n#undef __xstat\n\nint\n__xstat (int ver, const char *path, struct stat *st)\n{\n  static int (*real_stat)(int ver, const char *path, struct stat *st) = NULL;\n  fclose(fopen(\"preloaded\", \"w\"));\n  if (!real_stat)\n    real_stat = dlsym (RTLD_NEXT, \"__xstat\");\n  /* When asked to stat nonexistent \"d\",\n     return results suggesting it exists. */\n  return real_stat (ver, *path == 'd' && path[1] == 0 ? \"d2\" : path, st);\n}\nEOF\n\n# Then compile/link it:\ngcc_shared_ k.c k.so \\\n  || framework_failure_ 'failed to build shared library'\n\ntouch d2 || framework_failure_\necho xyz > src || framework_failure_\n\n# Finally, run the test:\nLD_PRELOAD=$LD_PRELOAD:./k.so cp src d || fail=1\n\ntest -f preloaded || skip_ 'LD_PRELOAD was ineffective?'\n\ncompare src d || fail=1\nExit $fail\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/lt.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/sr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/fi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/bg.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ga.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/et.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ro.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/sv.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/hr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ia.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/uk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/pt_BR.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/sl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/pt.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ms.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/eu.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/id.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/af.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/be.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/nl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/eo.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/hu.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/sk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/nb.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/cs.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/kk.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/pl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/gl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/vi.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/zh_CN.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/el.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/da.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/zh_TW.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/lg.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/it.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ko.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ca.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/ru.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-coreutils-8.30-lf4x2tri6jnxc7txzaydatq6leipcsci/spack-src/po/tr.gmo"
    ],
    "total_files": 2677
}