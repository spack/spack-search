{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/arbor/mechcat.cpp": "#include <cstdlib>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n#include <cassert>\n\n#include <dlfcn.h>\n\n#include <arbor/arbexcept.hpp>\n#include <arbor/mechcat.hpp>\n#include <arbor/util/expected.hpp>\n\n#include \"util/rangeutil.hpp\"\n#include \"util/maputil.hpp\"\n\n/* Notes on implementation:\n *\n * The catalogue maintains the following data:\n *\n * 1. impl_map_\n *\n *    This contains the mapping between mechanism names and concrete mechanisms\n *    for a specific backend that have been registered with\n *    register_impl().\n *\n *    It is a two-level map, first indexed by name, and then by the back-end\n *    type (using std::type_index).\n *\n * 2. info_map_\n *\n *    Contains the mechanism_info metadata for a mechanism, as given to the\n *    catalogue via the add() method.\n *\n * 3. derived_map_\n *\n *    A 'derived' mechanism is one that shares the same metadata schema as its\n *    parent, but with possible overrides to its global scalar parameters and\n *    to the bindings of its ion names.\n *\n *    The derived_map_ entry for a given mechanism gives: the parent mechanism\n *    from which it is derived (which might also be a derived mechanism); the\n *    set of changes to global parameters relative to its parent; the set of\n *    ion rebindings relative to its parent; and an updated copy of the\n *    mechanism_info metadata that reflects those changes.\n *\n * The derived_map_ and info_map_ together constitute a forest: info_map_ has\n * an entry for each un-derived mechanism in the catalogue, while for any\n * derived mechanism, the parent field in derived_map_ provides the parent in\n * the derivation tree, or a root mechanism which is catalogued in info_map_.\n *\n * When an instance of the mechanism is requested from the catalogue, the\n * instance_impl_() function walks up the derivation tree to find the first\n * entry which has an associated implementation. It then accumulates the set of\n * global parameter and ion overrides that need to be applied, starting from\n * the top-most (least-derived) ancestor and working down to the requested derived\n * mechanism.\n *\n * The private implementation class catalogue_state does not throw any (catalogue\n * related) exceptions, but instead propagates errors via util::expected to the\n * mechanism_catalogue methods for handling.\n */\n\nnamespace arb {\n\nusing util::ptr_by_key;\nusing util::unexpected;\n\nusing std::make_unique;\nusing std::make_exception_ptr;\n\nusing mechanism_info_ptr = std::unique_ptr<mechanism_info>;\n\ntemplate <typename V>\nusing string_map = std::unordered_map<std::string, V>;\n\ntemplate <typename T>\nusing hopefully = util::expected<T, std::exception_ptr>;\n\nnamespace {\n// Convert hopefully<T> to T or throw.\ntemplate <typename T>\nconst T& value(const hopefully<T>& x) {\n    if (!x) std::rethrow_exception(x.error());\n    return x.value();\n}\n\ntemplate <typename T>\nT value(hopefully<T>&& x) {\n    if (!x) std::rethrow_exception(std::move(x).error());\n    return std::move(x).value();\n}\n\n// Conveniently make an unexpected exception_ptr:\ntemplate <typename X>\nauto unexpected_exception_ptr(X x) { return unexpected(make_exception_ptr(std::move(x))); }\n} // anonymous namespace\n\nstruct derivation {\n    std::string parent;\n    string_map<double> globals;        // global overrides relative to parent\n    string_map<std::string> ion_remap; // ion name remap overrides relative to parent\n    mechanism_info_ptr derived_info;\n};\n\n\n// (Pimpl) catalogue state.\n\nstruct catalogue_state {\n    catalogue_state() = default;\n\n    catalogue_state(const catalogue_state& other) {\n        import(other, \"\");\n    }\n\n    void import(const catalogue_state& other, const std::string& prefix) {\n        // Do all checks before adding anything, otherwise we might get inconsistent state.\n        auto assert_undefined = [&](const std::string& key) {\n            auto pkey = prefix+key;\n            if (defined(pkey)) {\n                throw duplicate_mechanism(pkey);\n            }\n        };\n\n        for (const auto& kv: other.info_map_) {\n            assert_undefined(kv.first);\n        }\n\n        for (const auto& kv: other.derived_map_) {\n            assert_undefined(kv.first);\n        }\n\n        for (const auto& kv: other.info_map_) {\n            auto key = prefix + kv.first;\n            info_map_[key] = make_unique<mechanism_info>(*kv.second);\n        }\n\n        for (const auto& kv: other.derived_map_) {\n            auto key = prefix + kv.first;\n            const derivation& v = kv.second;\n            derived_map_[key] = {prefix + v.parent, v.globals, v.ion_remap, make_unique<mechanism_info>(*v.derived_info)};\n        }\n\n        for (const auto& name_impls: other.impl_map_) {\n            std::unordered_map<std::type_index, std::unique_ptr<mechanism>> impls;\n            for (const auto& tidx_mptr: name_impls.second) {\n                impls[tidx_mptr.first] = tidx_mptr.second->clone();\n            }\n            auto key = prefix + name_impls.first;\n            impl_map_[key] = std::move(impls);\n        }\n    }\n\n    // Check for presence of mechanism or derived mechanism.\n    bool defined(const std::string& name) const {\n        return info_map_.count(name) || derived_map_.count(name);\n    }\n\n    // Check if name is derived or implicitly derivable.\n    bool is_derived(const std::string& name) const {\n        return derived_map_.count(name) || derive(name);\n    }\n\n    // Set mechanism info (unchecked).\n    void bind(const std::string& name, mechanism_info info) {\n        info_map_[name] = mechanism_info_ptr(new mechanism_info(std::move(info)));\n    }\n\n    // Add derived mechanism (unchecked).\n    void bind(const std::string& name, derivation deriv) {\n        derived_map_[name] = std::move(deriv);\n    }\n\n    // Register concrete mechanism for a back-end type.\n    hopefully<void> register_impl(std::type_index tidx, const std::string& name, std::unique_ptr<mechanism> mech) {\n        if (auto fptr = fingerprint_ptr(name)) {\n            if (mech->fingerprint()!=*fptr.value()) {\n                return unexpected_exception_ptr(fingerprint_mismatch(name));\n            }\n\n            impl_map_[name][tidx] = std::move(mech);\n            return {};\n        }\n        else {\n            return unexpected(fptr.error());\n        }\n    }\n\n    // Remove mechanism and its derivations and implementations.\n    void remove(const std::string& name) {\n        derived_map_.erase(name);\n        info_map_.erase(name);\n        impl_map_.erase(name);\n\n        // Erase any dangling derivation map entries.\n        std::size_t n_delete;\n        do {\n            n_delete = 0;\n            for (auto it = derived_map_.begin(); it!=derived_map_.end(); ) {\n                const auto& parent = it->second.parent;\n                if (info_map_.count(parent) || derived_map_.count(parent)) {\n                    ++it;\n                }\n                else {\n                    impl_map_.erase(it->first);\n                    derived_map_.erase(it++);\n                    ++n_delete;\n                }\n            }\n        } while (n_delete>0);\n    }\n\n    // Retrieve mechanism info for mechanism, derived mechanism, or implicitly\n    // derived mechanism.\n    hopefully<mechanism_info> info(const std::string& name) const {\n        if (const auto* deriv = ptr_by_key(derived_map_, name)) {\n            return *(deriv->derived_info.get());\n        }\n        else if (auto* p = ptr_by_key(info_map_, name)) {\n            return *(p->get());\n        }\n        else if (auto deriv = derive(name)) {\n            return *(deriv->derived_info.get());\n        }\n        else {\n            return unexpected(deriv.error());\n        }\n    }\n\n    // Retrieve mechanism fingerprint. The fingerprint of a derived mechanisms\n    // is that of its parent.\n    hopefully<const mechanism_fingerprint*> fingerprint_ptr(const std::string& name) const {\n        hopefully<derivation> implicit_deriv;\n        const std::string* base = &name;\n\n        if (!defined(name)) {\n            if ((implicit_deriv = derive(name))) {\n                base = &implicit_deriv->parent;\n            }\n            else {\n                return unexpected(implicit_deriv.error());\n            }\n        }\n\n        while (auto* deriv = ptr_by_key(derived_map_, *base)) {\n            base = &deriv->parent;\n        }\n\n        if (const auto* p = ptr_by_key(info_map_, *base)) {\n            return &p->get()->fingerprint;\n        }\n\n        throw arbor_internal_error(\"inconsistent catalogue map state\");\n    }\n\n    // Construct derived mechanism based on existing parent mechanism and overrides.\n    hopefully<derivation> derive(\n        const std::string& name, const std::string& parent,\n        const std::vector<std::pair<std::string, double>>& global_params,\n        const std::vector<std::pair<std::string, std::string>>& ion_remap_vec) const\n    {\n        if (defined(name)) {\n            return unexpected_exception_ptr(duplicate_mechanism(name));\n        }\n        else if (!defined(parent)) {\n            return unexpected_exception_ptr(no_such_mechanism(parent));\n        }\n\n        string_map<std::string> ion_remap_map(ion_remap_vec.begin(), ion_remap_vec.end());\n        derivation deriv = {parent, {}, ion_remap_map, nullptr};\n\n        mechanism_info_ptr new_info;\n        if (auto parent_info = info(parent)) {\n            new_info.reset(new mechanism_info(parent_info.value()));\n        }\n        else {\n            return unexpected(parent_info.error());\n        }\n\n        // Update global parameter values in info for derived mechanism.\n\n        for (const auto& kv: global_params) {\n            const auto& param = kv.first;\n            const auto& value = kv.second;\n\n            if (auto* p = ptr_by_key(new_info->globals, param)) {\n                if (!p->valid(value)) {\n                    return unexpected_exception_ptr(invalid_parameter_value(name, param, value));\n                }\n            }\n            else {\n                return unexpected_exception_ptr(no_such_parameter(name, param));\n            }\n\n            deriv.globals[param] = value;\n            new_info->globals.at(param).default_value = value;\n        }\n\n        for (const auto& kv: ion_remap_vec) {\n            if (!new_info->ions.count(kv.first)) {\n                return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, kv.second));\n            }\n        }\n\n        // Update ion dependencies in info to reflect the requested ion remapping.\n\n        string_map<ion_dependency> new_ions;\n        for (const auto& kv: new_info->ions) {\n            if (auto* new_ion = ptr_by_key(ion_remap_map, kv.first)) {\n                if (!new_ions.insert({*new_ion, kv.second}).second) {\n                    return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, *new_ion));\n                }\n            }\n            else {\n                if (!new_ions.insert(kv).second) {\n                    // (find offending remap to report in exception)\n                    for (const auto& entry: ion_remap_map) {\n                        if (entry.second==kv.first) {\n                            return unexpected_exception_ptr(invalid_ion_remap(name, kv.first, entry.second));\n                        }\n                    }\n                    throw arbor_internal_error(\"inconsistent catalogue ion remap state\");\n                }\n            }\n        }\n        new_info->ions = std::move(new_ions);\n\n        deriv.derived_info = std::move(new_info);\n        return std::move(deriv);\n    }\n\n    // Implicit derivation.\n    hopefully<derivation> derive(const std::string& name) const {\n        if (defined(name)) {\n            return unexpected_exception_ptr(duplicate_mechanism(name));\n        }\n\n        auto i = name.find_last_of('/');\n        if (i==std::string::npos) {\n            return unexpected_exception_ptr(no_such_mechanism(name));\n        }\n\n        std::string base = name.substr(0, i);\n        if (!defined(base)) {\n            return unexpected_exception_ptr(no_such_mechanism(base));\n        }\n\n        std::string suffix = name.substr(i+1);\n\n        const mechanism_info_ptr& info = derived_map_.count(base)? derived_map_.at(base).derived_info: info_map_.at(base);\n        bool single_ion = info->ions.size()==1u;\n        auto is_ion = [&info](const std::string& name) -> bool { return info->ions.count(name); };\n\n        std::vector<std::pair<std::string, double>> global_params;\n        std::vector<std::pair<std::string, std::string>> ion_remap;\n\n        while (!suffix.empty()) {\n            std::string assign;\n\n            auto comma = suffix.find(',');\n            if (comma==std::string::npos) {\n                assign = suffix;\n                suffix.clear();\n            }\n            else {\n                assign = suffix.substr(0, comma);\n                suffix = suffix.substr(comma+1);\n            }\n\n            std::string k, v;\n            auto eq = assign.find('=');\n            if (eq==std::string::npos) {\n                if (!single_ion) {\n                    return unexpected_exception_ptr(invalid_ion_remap(assign));\n                }\n\n                k = info->ions.begin()->first;\n                v = assign;\n            }\n            else {\n                k = assign.substr(0, eq);\n                v = assign.substr(eq+1);\n            }\n\n            if (is_ion(k)) {\n                ion_remap.push_back({k, v});\n            }\n            else {\n                char* end = 0;\n                double v_value = std::strtod(v.c_str(), &end);\n                if (!end || *end) {\n                    return unexpected_exception_ptr(invalid_parameter_value(name, k, v));\n                }\n                global_params.push_back({k, v_value});\n            }\n        }\n\n        return derive(name, base, global_params, ion_remap);\n    }\n\n    // Retrieve implementation for this mechanism name or closest ancestor.\n    hopefully<std::unique_ptr<mechanism>> implementation(std::type_index tidx, const std::string& name) const {\n        const std::string* impl_name = &name;\n        hopefully<derivation> implicit_deriv;\n\n        if (!defined(name)) {\n            implicit_deriv = derive(name);\n            if (!implicit_deriv) {\n                return unexpected(implicit_deriv.error());\n            }\n            impl_name = &implicit_deriv->parent;\n        }\n\n        for (;;) {\n            if (const auto* mech_impls = ptr_by_key(impl_map_, *impl_name)) {\n                if (auto* p = ptr_by_key(*mech_impls, tidx)) {\n                    return p->get()->clone();\n                }\n            }\n\n            // Try parent instead.\n            if (const auto* p = ptr_by_key(derived_map_, *impl_name)) {\n                impl_name = &p->parent;\n            }\n            else {\n                return unexpected_exception_ptr(no_such_implementation(name));\n            }\n        }\n    }\n\n    // Accumulate override set from derivation chain.\n    hopefully<mechanism_overrides> overrides(const std::string& name) const {\n        mechanism_overrides over;\n\n        auto apply_deriv = [](mechanism_overrides& over, const derivation& deriv) {\n            for (auto& kv: deriv.globals) {\n                over.globals[kv.first] = kv.second;\n            }\n\n            if (!deriv.ion_remap.empty()) {\n                string_map<std::string> new_rebind = deriv.ion_remap;\n                for (auto& kv: over.ion_rebind) {\n                    if (auto* v = ptr_by_key(deriv.ion_remap, kv.second)) {\n                        new_rebind.erase(kv.second);\n                        new_rebind[kv.first] = *v;\n                    }\n                }\n                for (auto& kv: over.ion_rebind) {\n                    if (!ptr_by_key(deriv.ion_remap, kv.second)) {\n                        new_rebind[kv.first] = kv.second;\n                    }\n                }\n                std::swap(new_rebind, over.ion_rebind);\n            }\n        };\n\n        // Recurse up the derivation tree to find the most distant ancestor;\n        // accumulate global parameter settings and ion remappings down to the\n        // requested mechanism.\n\n        auto apply_globals = [this, &apply_deriv](auto& self, const std::string& name, mechanism_overrides& over) -> void {\n            if (auto* p = ptr_by_key(derived_map_, name)) {\n                self(self, p->parent, over);\n                apply_deriv(over, *p);\n            }\n        };\n\n        std::optional<derivation> implicit_deriv;\n        if (!defined(name)) {\n            if (auto deriv = derive(name)) {\n                implicit_deriv = std::move(deriv.value());\n            }\n            else {\n                return unexpected(deriv.error());\n            }\n        }\n\n        apply_globals(apply_globals, implicit_deriv? implicit_deriv->parent: name, over);\n        if (implicit_deriv) {\n            apply_deriv(over, implicit_deriv.value());\n        }\n\n        return over;\n    }\n\n    // Collect all mechanism names present in this catalogue\n    std::vector<std::string> mechanism_names() const {\n        std::vector<std::string> result;\n        util::assign(result, util::keys(info_map_));\n        util::append(result, util::keys(derived_map_));\n        return result;\n    }\n\n    // Schemata for (un-derived) mechanisms.\n    string_map<mechanism_info_ptr> info_map_;\n\n    // Parent and global setting values for derived mechanisms.\n    string_map<derivation> derived_map_;\n\n    // Prototype register, keyed on mechanism name, then backend type (index).\n    string_map<std::unordered_map<std::type_index, mechanism_ptr>> impl_map_;\n};\n\n// Mechanism catalogue method implementations.\n\nmechanism_catalogue::mechanism_catalogue():\n    state_(new catalogue_state)\n{}\n\nstd::vector<std::string> mechanism_catalogue::mechanism_names() const {\n    return state_->mechanism_names();\n}\n\nmechanism_catalogue::mechanism_catalogue(mechanism_catalogue&& other) = default;\nmechanism_catalogue& mechanism_catalogue::operator=(mechanism_catalogue&& other) = default;\n\nmechanism_catalogue::mechanism_catalogue(const mechanism_catalogue& other):\n    state_(new catalogue_state(*other.state_))\n{}\n\nmechanism_catalogue& mechanism_catalogue::operator=(const mechanism_catalogue& other) {\n    state_.reset(new catalogue_state(*other.state_));\n    return *this;\n}\n\nvoid mechanism_catalogue::add(const std::string& name, mechanism_info info) {\n    if (state_->defined(name)) {\n        throw duplicate_mechanism(name);\n    }\n    state_->bind(name, std::move(info));\n}\n\nbool mechanism_catalogue::has(const std::string& name) const {\n    return state_->defined(name) || state_->derive(name);\n}\n\nbool mechanism_catalogue::is_derived(const std::string& name) const {\n    return state_->is_derived(name);\n}\n\nmechanism_info mechanism_catalogue::operator[](const std::string& name) const {\n    return value(state_->info(name));\n}\n\nconst mechanism_fingerprint& mechanism_catalogue::fingerprint(const std::string& name) const {\n    return *value(state_->fingerprint_ptr(name));\n}\n\nvoid mechanism_catalogue::derive(const std::string& name, const std::string& parent,\n    const std::vector<std::pair<std::string, double>>& global_params,\n    const std::vector<std::pair<std::string, std::string>>& ion_remap_vec)\n{\n    state_->bind(name, value(state_->derive(name, parent, global_params, ion_remap_vec)));\n}\n\nvoid mechanism_catalogue::derive(const std::string& name, const std::string& parent) {\n    state_->bind(name, value(state_->derive(parent)));\n}\n\nvoid mechanism_catalogue::import(const mechanism_catalogue& other, const std::string& prefix) {\n    state_->import(*other.state_, prefix);\n}\n\nvoid mechanism_catalogue::remove(const std::string& name) {\n    if (!has(name)) {\n        throw no_such_mechanism(name);\n    }\n    state_->remove(name);\n}\n\nvoid mechanism_catalogue::register_impl(std::type_index tidx, const std::string& name, std::unique_ptr<mechanism> mech) {\n    value(state_->register_impl(tidx, name, std::move(mech)));\n}\n\nstd::pair<mechanism_ptr, mechanism_overrides> mechanism_catalogue::instance_impl(std::type_index tidx, const std::string& name) const {\n    std::pair<mechanism_ptr, mechanism_overrides> result;\n    result.first = value(state_->implementation(tidx, name));\n    result.second = value(state_->overrides(name));\n\n    return result;\n}\n\nmechanism_catalogue::~mechanism_catalogue() = default;\n\nstatic void check_dlerror(const std::string& fn, const std::string& call) {\n    auto error = dlerror();\n    if (error) { throw arb::bad_catalogue_error{fn, call}; }\n}\n\nconst mechanism_catalogue& load_catalogue(const std::filesystem::path& fn) {\n    typedef const void* global_catalogue_t();\n\n    if (!std::filesystem::exists(fn)) { throw arb::file_not_found_error{fn}; }\n\n    auto plugin = dlopen(fn.c_str(), RTLD_LAZY);\n    check_dlerror(fn, \"dlopen\");\n    assert(plugin);\n\n    auto get_catalogue = (global_catalogue_t*)dlsym(plugin, \"get_catalogue\");\n    check_dlerror(fn, \"dlsym\");\n\n    /* NOTE We do not free the DSO handle here and accept retaining the handles\n       until termination since the mechanisms provided by the catalogue may have\n       a different lifetime than the actual catalogue itfself. This is not a\n       leak proper as `dlopen` caches handles for us.\n     */\n    return *((const mechanism_catalogue*)get_catalogue());\n}\n\n} // namespace arb\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/example/lfp/example_nrn_EP.png",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/objects/pack/pack-0f468609ba3618cddd49f4dc26d4e4023229d1bb.idx",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/objects/pack/pack-0f468609ba3618cddd49f4dc26d4e4023229d1bb.pack",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/google-benchmark/objects/pack/pack-7cbc220ecef12667d606c4d5824bbe3076144639.pack",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/google-benchmark/objects/pack/pack-7cbc220ecef12667d606c4d5824bbe3076144639.idx",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/python/pybind11/objects/pack/pack-14d4923c14735eebc13c7fb563fcd25875a7d373.idx",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/python/pybind11/objects/pack/pack-14d4923c14735eebc13c7fb563fcd25875a7d373.pack",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/.git/modules/python/pybind11/modules/tools/clang/objects/pack/pack-7a1f279894ad4c01ef7af9ab88b9f2fc048559a6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/python/pybind11/docs/pybind11_vs_boost_python1.png",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/python/pybind11/docs/pybind11-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/python/pybind11/docs/pybind11_vs_boost_python2.png",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/doc/scripts/divio_docs_theme/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/doc/scripts/divio_docs_theme/static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-arbor-master-ypf2t6hcaml4cycyzaghhqz2igdtz2gw/spack-src/doc/scripts/divio_docs_theme/static/fonts/fontawesome-webfont.woff2"
    ],
    "total_files": 1226
}