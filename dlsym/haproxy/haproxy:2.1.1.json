{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/src/i386-linux-vsys.c": "/*\n * Fast system call support for x86 on Linux\n *\n * Copyright 2010 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * Recent kernels support a faster syscall ABI on x86 using the VDSO page, but\n * some libc that are built for CPUs earlier than i686 do not implement it.\n * This code bypasses the libc when the VDSO is detected. It should only be\n * used when it's sure that the libc really does not support the VDSO, but\n * fixing the libc is preferred. Using the VDSO can improve the overall\n * performance by about 10%.\n */\n\n#if defined(__linux__) && defined(__i386__)\n/* Silently ignore other platforms to be friendly with distro packagers */\n\n#include <dlfcn.h>\n#include <sys/mman.h>\n\nvoid int80(void);                /* declared in the assembler code */\nstatic void *vsyscall = &int80;  /* initialize vsyscall to use int80 by default */\nstatic __attribute__((used)) unsigned int back_ebx;\n\n/* now we redefine some frequently used syscalls. Epoll_create is defined too\n * in order to replace old disabled implementations.\n */\nasm\n(\n    \"epoll_create: .GLOBL epoll_create\\n\"\n    \"   mov $0xfe, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 4(%esp), %ebx\\n\"\n    \"   jmp do_syscall\\n\"\n\n    \"epoll_ctl: .GLOBL epoll_ctl\\n\"\n    \"   push %esi\\n\"\n    \"   mov $0xff, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 20(%esp), %esi\\n\"\n    \"   mov 16(%esp), %edx\\n\"\n    \"   mov 12(%esp), %ecx\\n\"\n    \"   mov 8(%esp), %ebx\\n\"\n    \"   call do_syscall\\n\"\n    \"   pop %esi\\n\"\n    \"   ret\\n\"\n\n    \"epoll_wait: .GLOBL epoll_wait\\n\"\n    \"   push %esi\\n\"\n    \"   mov $0x100, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 20(%esp), %esi\\n\"\n    \"   mov 16(%esp), %edx\\n\"\n    \"   mov 12(%esp), %ecx\\n\"\n    \"   mov 8(%esp), %ebx\\n\"\n    \"   call do_syscall\\n\"\n    \"   pop %esi\\n\"\n    \"   ret\\n\"\n\n    \"splice: .GLOBL splice\\n\"\n    \"   push %ebp\\n\"\n    \"   push %edi\\n\"\n    \"   push %esi\\n\"\n    \"   mov $0x139, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 36(%esp), %ebp\\n\"\n    \"   mov 32(%esp), %edi\\n\"\n    \"   mov 28(%esp), %esi\\n\"\n    \"   mov 24(%esp), %edx\\n\"\n    \"   mov 20(%esp), %ecx\\n\"\n    \"   mov 16(%esp), %ebx\\n\"\n    \"   call do_syscall\\n\"\n    \"   pop %esi\\n\"\n    \"   pop %edi\\n\"\n    \"   pop %ebp\\n\"\n    \"   ret\\n\"\n\n    \"close: .GLOBL close\\n\"\n    \"   mov $0x06, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 4(%esp), %ebx\\n\"\n    \"   jmp do_syscall\\n\"\n\n    \"gettimeofday: .GLOBL gettimeofday\\n\"\n    \"   mov $0x4e, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 8(%esp), %ecx\\n\"\n    \"   mov 4(%esp), %ebx\\n\"\n    \"   jmp do_syscall\\n\"\n\n    \"fcntl: .GLOBL fcntl\\n\"\n    \"   mov $0xdd, %eax\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov 12(%esp), %edx\\n\"\n    \"   mov 8(%esp), %ecx\\n\"\n    \"   mov 4(%esp), %ebx\\n\"\n    \"   jmp do_syscall\\n\"\n\n    \"socket: .GLOBL socket\\n\"\n    \"   mov $0x01, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"bind: .GLOBL bind\\n\"\n    \"   mov $0x02, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"connect: .GLOBL connect\\n\"\n    \"   mov $0x03, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"listen: .GLOBL listen\\n\"\n    \"   mov $0x04, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"accept: .GLOBL accept\\n\"\n    \"   mov $0x05, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"accept4: .GLOBL accept4\\n\"\n    \"   mov $0x12, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"getsockname: .GLOBL getsockname\\n\"\n    \"   mov $0x06, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"send: .GLOBL send\\n\"\n    \"   mov $0x09, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"recv: .GLOBL recv\\n\"\n    \"   mov $0x0a, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"shutdown: .GLOBL shutdown\\n\"\n    \"   mov $0x0d, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"setsockopt: .GLOBL setsockopt\\n\"\n    \"   mov $0x0e, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"getsockopt: .GLOBL getsockopt\\n\"\n    \"   mov $0x0f, %eax\\n\"\n    \"   jmp socketcall\\n\"\n\n    \"socketcall:\\n\"\n    \"   mov %ebx, back_ebx\\n\"\n    \"   mov %eax, %ebx\\n\"\n    \"   mov $0x66, %eax\\n\"\n    \"   lea 4(%esp), %ecx\\n\"\n    /* fall through */\n\n    \"do_syscall:\\n\"\n    \"   call *vsyscall\\n\"          // always valid, may be int80 or vsyscall\n    \"   mov  back_ebx, %ebx\\n\"\n    \"   cmpl $0xfffff000, %eax\\n\"  // consider -4096..-1 for errno\n    \"   jae 0f\\n\"\n    \"   ret\\n\"\n    \"0:\\n\"               // error handling\n    \"   neg %eax\\n\"      // get errno value\n    \"   push %eax\\n\"     // save it\n    \"   call __errno_location\\n\"\n    \"   popl (%eax)\\n\"   // store the pushed errno into the proper location\n    \"   mov $-1, %eax\\n\" // and return -1\n    \"   ret\\n\"\n\n    \"int80:\\n\"           // default compatible calling convention\n    \"   int $0x80\\n\"\n    \"   ret\\n\"\n);\n\n__attribute__((constructor))\nstatic void __i386_linux_vsyscall_init(void)\n{\n\t/* We can get the pointer by resolving the __kernel_vsyscall symbol\n\t * from the \"linux-gate.so.1\" virtual shared object, but this requires\n\t * libdl. Or we can also know that the vsyscall pointer is always\n\t * located at 0xFFFFE018 when /proc/sys/abi/vsyscall32 contains the\n\t * default value 2. So we can use that once we've checked that we can\n\t * access it without faulting. The dlsym method will also work when\n\t * vsyscall32 = 1, which randomizes the VDSO address.\n\t */\n#ifdef USE_VSYSCALL_DLSYM\n\tvoid *handle = dlopen(\"linux-gate.so.1\", RTLD_NOW);\n\tif (handle) {\n\t\tvoid *ptr;\n\n\t\tptr = dlsym(handle, \"__kernel_vsyscall_kml\");\n\t\tif (!ptr)\n\t\t\tptr = dlsym(handle, \"__kernel_vsyscall\");\n\t\tif (ptr)\n\t\t\tvsyscall = ptr;\n\t\tdlclose(handle);\n\t}\n#else\n\t/* Heuristic: trying to mprotect() the VDSO area will only succeed if\n\t * it is mapped.\n\t */\n\tif (mprotect((void *)0xffffe000, 4096, PROT_READ|PROT_EXEC) == 0) {\n\t\tunsigned long ptr = *(unsigned long *)0xFFFFE018;  /* VDSO is mapped */\n\t\tif ((ptr & 0xFFFFE000) == 0xFFFFE000)\n\t\t\tvsyscall = (void *)ptr;\n\t}\n#endif\n}\n\n#endif /* defined(__linux__) && defined(__i386__) */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/design-thoughts/sess_par_sec.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/design-thoughts/be-fe-changes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/design-thoughts/backends-v0.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/design-thoughts/config-language.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/listener-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/entities.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/http-parsing.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/pattern.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/lua_socket.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/pattern.dia",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/repartition-be-fe-fi.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/internals/connection-scale.txt",
        "/tmp/vanessa/spack-stage/spack-stage-haproxy-2.1.1-o7hurv5djrqv67gs7wbjdaowtk3mjxw6/spack-src/doc/lua-api/_static/channel.png"
    ],
    "total_files": 595
}