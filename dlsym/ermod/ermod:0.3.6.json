{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdfio.c": "/* ERmod - Eneregy Representation Module\n   Copyright (C) 2000-2019 Nobuyuki Matubayasi\n   Copyright (C) 2010-2019 Shun Sakuraba\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU General Public License\n   as published by the Free Software Foundation; either version 2\n   of the License, or (at your option) any later version.\n   As a special exception, you may use this file as part of a free software\n   without restriction.  Specifically, if other files instantiate\n   templates or use macros or inline functions from this file, or you compile\n   this file and link it with other files to produce an executable, this\n   file does not by itself cause the resulting executable to be covered by\n   the GNU General Public License.  \n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. */\n\n/*\n  Generic trajectory access via VMD plugin.\n */\n\n/* FIXME: add F77_FUNC(small,CAPITAL) issues */\n#include \"config.h\"\n\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <math.h>\n\n#include <dlfcn.h>\n\n#include \"vmdplugins/molfile_plugin.h\"\n\n/*\n  Declaration of plugin access points.\n*/\n\n#ifndef INSTALL_PLUGIN_PATH\n#warning INSTALL_PLUGIN_PATH is not defined\n#define INSTALL_PLUGIN_PATH \"\"\n#endif\n\n#define ADHOC_RESOLVER \"adhocresolve.list\"\n\n#define ERMOD_FORCE_PLUGIN \"ERMOD_FORCE_PLUGIN_TYPE\"\n\n/* lazy */\n#define MAXTYPES 1000\nstatic int typecounts = 0;\nstatic molfile_plugin_t* vmdpluginentries[MAXTYPES];\n\n/* lazy too */\n#define MAXPLUGINS 100\nstatic int plugincounts = 0;\nstatic void* ldhandles[MAXPLUGINS];\n\n/*\n  Callback function. Must be compatible with vmdplugin_register_cb. \n */\nstatic int register_callback(void* __vp, vmdplugin_t * entity)\n{\n  if(entity == NULL || entity -> type == NULL) return 0;\n  vmdpluginentries[typecounts++] = (molfile_plugin_t*)entity;\n  return 0;\n}\n\nstatic int check_directory_available(char *path)\n{\n  struct stat st;\n  int r = stat(path, &st);\n\n  if(r == 0 && S_ISDIR(st.st_mode))\n    return 1;\n  return 0;\n}\n\nstatic int is_executable(char* path)\n{\n  struct stat st;\n  int r;\n  r = stat(path, &st);\n  if(r != 0) return 0;\n  if(!(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))) {\n    return 0;\n  }\n  \n  if(access(path, X_OK) == 0) return 1;\n  return 0;\n}\n\nstatic char* strdupcat(char* str1, char* str2)\n{\n  char* buf = malloc(strlen(str1) + strlen(str2) + 1);\n  strcpy(buf, str1);\n  strcat(buf, str2);\n  return buf;\n}\n\nstatic char* find_plugin_paths()\n{\n  char *pluginpath;\n  /* contract: return malloc'ed string, or return NULL if error */\n\n  /* is ERMOD_PLUGINS present and directory? */\n  if((pluginpath = getenv(\"ERMOD_PLUGINS\")) && \n     check_directory_available(pluginpath)) {\n    return strdup(pluginpath);\n  }\n\n  /* is INSTALL_PLUGIN_PATH available? */\n  if(strlen(INSTALL_PLUGIN_PATH) > 0 &&\n     check_directory_available(INSTALL_PLUGIN_PATH)) {\n    return strdup(INSTALL_PLUGIN_PATH);\n  }\n\n  return NULL;\n}\n\n\nvoid vmdfio_init_traj_(void)\n{\n  char* plugindir;\n  char* buf;\n  \n  if((plugindir = find_plugin_paths()) == NULL){\n    fprintf(stderr, \"Error: cannot find plugin paths, please set ERMOD_PLUGINS environment variable\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  /* traverse directory */\n  do{\n    DIR* dirp;\n    struct dirent *ent;\n    dirp = opendir(plugindir);\n    \n    while((ent = readdir(dirp)) != NULL){\n      /* concat paths */\n      char* d1 = strdupcat(plugindir, \"/\");\n      char* pluginpath = strdupcat(d1, ent -> d_name);\n      free(d1);\n      \n      if(is_executable(pluginpath) && pluginpath[strlen(pluginpath)-1] != '.'){\n\tvoid* handle;\n\thandle = dlopen(pluginpath, RTLD_NOW | RTLD_GLOBAL);\n\tif(!handle){\n\t  fprintf(stderr, \"Warning: failed to load plugin \\\"%s\\\", reason: \\\"%s\\\"\\n\", pluginpath, dlerror());\n\t  continue;\n\t}\n\tvoid* initptr;\n\tvoid* entptr;\n\tinitptr = dlsym(handle, \"vmdplugin_init\");\n\tentptr = dlsym(handle, \"vmdplugin_register\");\n\tif(initptr != NULL && entptr != NULL){\n\t  int r;\n\t  r = ((int (*)(void))initptr)();\n\t  if(r != 0)\n\t    fprintf(stderr, \"Warning: error while initializing %s\\n\", pluginpath);\n\t  ldhandles[plugincounts++] = handle;\n\t  r = ((int (*)(void*, vmdplugin_register_cb))entptr)(NULL, register_callback);\n\t  if(r != 0)\n\t    fprintf(stderr, \"Warning: error while registering %s\\n\", pluginpath);\n\t}else{\n\t  fprintf(stderr, \"Warning: failed to load entry point (plugin: %s)\\n\", pluginpath);\n\t}\n      }\n    }\n  }while(0);\n}\n\nvoid vmdfio_fini_traj_(void)\n{\n  int i;\n  for(i = 0; i < plugincounts; ++i){\n    void* entptr = dlsym(ldhandles[i], \"vmdplugin_fini\");\n    if(entptr){\n      ((int (*)(void))entptr)();\n    }\n    dlclose(ldhandles[i]);\n  }\n}\n\ntypedef struct vmdpluginio_t {\n  molfile_plugin_t * plugin;\n  void* filehandle;\n  int natoms;\n} vmdpluginio;\n\nvoid vmdfio_open_traj_(void **handle, char *fname, int *fnamelen, int *status)\n{\n  char* buf;\n  size_t buflen = 8192;\n  ssize_t r;\n  int fp;\n  char* ext;\n  int i;\n\n  buf = malloc(sizeof(char) * buflen + 1);\n  strncpy(buf, fname, *fnamelen);\n  buf[*fnamelen] = '\\0';\n\n  while(1){\n    r = readlink(buf, buf, buflen);\n    if(r == -1) break;\n    buf[r] = '\\0';\n  }\n\n  if(*fnamelen == strlen(buf) && strncmp(fname, buf, *fnamelen) == 0){\n    /* not a symbolic link? */\n    fprintf(stderr, \"Error: vmdfio.c: failed to open with vmdfio_open_traj_. (filename = \\\"%s\\\".) Perhaps it's not a symbolic link?\\n\", buf);\n    *status = -1;\n    goto cleanup;\n  }\n  \n  /* \n     select plugin to use.\n     use filename_extension to select\n  */\n  *status = -1;\n  *handle = NULL;\n  {\n    /* get filename extension */\n    char* lastdot = strrchr(buf, '.');\n\n    if(lastdot == NULL) goto cleanup;\n    ext = lastdot + 1;\n  }\n  fprintf(stderr, \"Opening: \\\"%s\\\"...\\n\", buf);\n\n  if(getenv(ERMOD_FORCE_PLUGIN) != NULL && \n     strlen(getenv(ERMOD_FORCE_PLUGIN)) > 0) {\n    ext = getenv(ERMOD_FORCE_PLUGIN);\n  }\n\n  for(i = 0; i < typecounts; ++i){\n    int extlen = strlen(ext);\n    molfile_plugin_t *p = vmdpluginentries[i];\n    char* plugin_supportext;\n    char* tokptr;\n    char* ptr;\n\n    if(strcmp(p -> type, MOLFILE_PLUGIN_TYPE) != 0) continue; \n    plugin_supportext = strdup(p -> filename_extension);\n\n    while(1){\n      ptr = strtok_r(plugin_supportext, \",\", &tokptr);\n      if(ptr == NULL) break;\n      plugin_supportext = NULL; /* in the next subsequent call NULL is passed */\n\n      if(strncmp(ptr, ext, extlen) == 0 && \n\t (ptr[extlen] == '\\0' || ptr[extlen] == ',')){\n\tvoid* fh;\n\tvmdpluginio* pp;\n\n\tfprintf(stderr, \"  Trying plugin \\\"%s\\\"...\", p -> prettyname);\n\n\tif(p -> abiversion <= 10) {\n\t  fprintf(stderr, \"Error: \\\"%s\\\" supports trajectory format, but it is too old (requires ABI version > 10)\\n\", p -> prettyname);\n\t  fprintf(stderr, \"Please update plugin files to those of the latest VMD's\\n\");\n\t  continue;\n\t}\n\n\tpp = malloc(sizeof(vmdpluginio));\n\tpp -> plugin = p;\n\n\t/* Found, open with this plugin */\n\tpp -> natoms = MOLFILE_NUMATOMS_UNKNOWN;\n\tfh = (p -> open_file_read)(buf, ext, &(pp->natoms));\n\tif(fh == NULL){\n\t  fprintf(stderr,\n\t\t  \"Error!\\n\"\n\t\t  \"Plugin supports file format \\\"%s\\\", estimated from the extension \\\"%s\\\".\\n\"\n\t\t  \"But the file format of \\\"%s\\\" does not match to the estimated format.\\n\"\n\t\t  \"This is possibly that the file has an incorrect extension, the file is a nested symbolic link (which is unsupported), or the trajectory file header is corrupt.\\n\",\n\t\t  p -> prettyname, ext, buf);\n\t  /* Special error message for AMBER */\n\t  if(strcmp(ext, \"nc\") == 0) {\n\t    fprintf(stderr,\n\t\t    \"Perhaps you forgot to specify \\\"ioutfm = 1\\\" in AMBER?\\n\");\n\t  }\n\t  exit(1);\n\t}\n\tpp -> filehandle = fh;\n\tfprintf(stderr, \"OK\\n\");\n\n\t*handle = pp;\n\tbreak;\n      }\n    }\n    free(plugin_supportext);\n    if(*handle){\n      *status = 0;\n      break;\n    }\n  }\n\n  if(*status == -1){\n    fprintf(stderr, \"Error: could not find appropriate plugins\\n\");\n  }\n\n\n cleanup:\n  free(buf);\n  return;\n}\n\nvoid vmdfio_read_traj_step_(void **handle, double* xout, double* box, int *natoms_aux, int *status)\n{\n  vmdpluginio *p = *handle;\n  molfile_plugin_t *plugin = p -> plugin;\n  molfile_timestep_t snapshot;\n  int natoms = p -> natoms;\n  float* buf;\n  int r;\n\n  if(natoms == MOLFILE_NUMATOMS_UNKNOWN){\n    /* not determined from the trajectory */\n    natoms = *natoms_aux;\n  }else{\n    /* check integrity */\n    if(natoms != *natoms_aux){\n      fprintf(stderr, \"Error: # of atoms in trajectory does not match with # of atoms in configurations. Perhaps you mistook the trajectory?\\n\");\n      *status = -1;\n      return;\n    }\n  }\n\n  buf = malloc(sizeof(float) * 3 * natoms);\n  snapshot.coords = buf;\n\n  r = (plugin -> read_next_timestep)(p -> filehandle, natoms, &snapshot);\n\n  do{\n    int i;\n    double x, y, u, v, w;\n\n    if(r == MOLFILE_EOF){\n      *status = -1;\n      break;\n    }\n\n    /* both are the same format */\n    for(i = 0; i < natoms * 3; ++i)\n      xout[i] = buf[i];\n\n    /*\n      ~a = (1, 0, 0)\n      ~b = (x, y, 0)\n      ~c = (u, v, w)\n      ~a.~b = x = cos gamma\n      |~a*~b| = y = sin gamma\n      ~a.~c = u = cos beta\n      ~b.~c = xu + yv = cos alpha\n    */\n\n    x = cos(snapshot.gamma * M_PI / 180.0);\n    y = sin(snapshot.gamma * M_PI / 180.0);\n    u = cos(snapshot.beta * M_PI / 180.0);\n    v = (cos(snapshot.alpha * M_PI / 180.0) - x * u) / y; /* FIXME: potential underflow risk */\n    w = sqrt(1 - u * u - v * v);  /* FIXME: same above */\n\n    box[0] = snapshot.A;\n    box[3] = snapshot.B * x; \n    box[4] = snapshot.B * y;\n    box[6] = snapshot.C * u; \n    box[7] = snapshot.C * v;\n    box[8] = snapshot.C * w;\n    \n    box[1] = 0.; box[2] = 0.; box[5] = 0;\n\n    *status = 0;\n  }while(0);\n\n  free(buf);\n  return;\n}\n\nvoid vmdfio_close_traj_(void **handle)\n{\n  vmdpluginio *p = *handle;\n  molfile_plugin_t *plugin = p -> plugin;\n  (plugin -> close_file_read)(p -> filehandle);\n  free(*handle);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdplugins/periodic_table.h",
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdplugins/phiplugin.C",
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdplugins/libexec/netcdfplugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdplugins/libexec/gromacsplugin.so",
        "/tmp/vanessa/spack-stage/spack-stage-ermod-0.3.6-as43oiffhopr4y6qi54tbol6j7tdyyo3/spack-src/vmdplugins/libexec/dcdplugin.so"
    ],
    "total_files": 138
}